/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./resources/js/app.js":
/*!*****************************!*\
  !*** ./resources/js/app.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var sweetalert2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! sweetalert2 */ \"./node_modules/sweetalert2/dist/sweetalert2.all.js\");\n/* harmony import */ var sweetalert2__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(sweetalert2__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var tinymce__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tinymce */ \"./node_modules/tinymce/tinymce.js\");\n/* harmony import */ var tinymce__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(tinymce__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n\ntry {\n  window.$ = window.jQuery = (jquery__WEBPACK_IMPORTED_MODULE_0___default());\n  window.Swal = (sweetalert2__WEBPACK_IMPORTED_MODULE_1___default());\n  window.tinymce = (tinymce__WEBPACK_IMPORTED_MODULE_2___default());\n} catch (e) {\n  console.log(e);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvYXBwLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTtFQUNBRyxNQUFNLENBQUNDLENBQVAsR0FBV0QsTUFBTSxDQUFDRSxNQUFQLEdBQWdCTCwrQ0FBM0I7RUFDQUcsTUFBTSxDQUFDRixJQUFQLEdBQWNBLG9EQUFkO0VBQ0FFLE1BQU0sQ0FBQ0csT0FBUCxHQUFpQkosZ0RBQWpCO0FBQ0gsQ0FKRCxDQUlFLE9BQU9LLENBQVAsRUFBVTtFQUNSQyxPQUFPLENBQUNDLEdBQVIsQ0FBWUYsQ0FBWjtBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2pzL2FwcC5qcz9jZWQ2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBKcXVlcnkgZnJvbSBcImpxdWVyeVwiO1xuaW1wb3J0IFN3YWwgZnJvbSBcInN3ZWV0YWxlcnQyXCI7XG5pbXBvcnQgVGlueU1DRSBmcm9tIFwidGlueW1jZVwiO1xuXG50cnkge1xuICAgIHdpbmRvdy4kID0gd2luZG93LmpRdWVyeSA9IEpxdWVyeTtcbiAgICB3aW5kb3cuU3dhbCA9IFN3YWw7XG4gICAgd2luZG93LnRpbnltY2UgPSBUaW55TUNFO1xufSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUubG9nKGUpO1xufVxuIl0sIm5hbWVzIjpbIkpxdWVyeSIsIlN3YWwiLCJUaW55TUNFIiwid2luZG93IiwiJCIsImpRdWVyeSIsInRpbnltY2UiLCJlIiwiY29uc29sZSIsImxvZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/js/app.js\n");

/***/ }),

/***/ "./node_modules/jquery/dist/jquery.js":
/*!********************************************!*\
  !*** ./node_modules/jquery/dist/jquery.js ***!
  \********************************************/
/***/ (function(module, exports) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * jQuery JavaScript Library v3.6.0\n * https://jquery.com/\n *\n * Includes Sizzle.js\n * https://sizzlejs.com/\n *\n * Copyright OpenJS Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n * Date: 2021-03-02T17:08Z\n */\n( function( global, factory ) {\n\n\t\"use strict\";\n\n\tif (  true && typeof module.exports === \"object\" ) {\n\n\t\t// For CommonJS and CommonJS-like environments where a proper `window`\n\t\t// is present, execute the factory and get jQuery.\n\t\t// For environments that do not have a `window` with a `document`\n\t\t// (such as Node.js), expose a factory as module.exports.\n\t\t// This accentuates the need for the creation of a real `window`.\n\t\t// e.g. var jQuery = require(\"jquery\")(window);\n\t\t// See ticket #14549 for more info.\n\t\tmodule.exports = global.document ?\n\t\t\tfactory( global, true ) :\n\t\t\tfunction( w ) {\n\t\t\t\tif ( !w.document ) {\n\t\t\t\t\tthrow new Error( \"jQuery requires a window with a document\" );\n\t\t\t\t}\n\t\t\t\treturn factory( w );\n\t\t\t};\n\t} else {\n\t\tfactory( global );\n\t}\n\n// Pass this if window is not defined yet\n} )( typeof window !== \"undefined\" ? window : this, function( window, noGlobal ) {\n\n// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1\n// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode\n// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common\n// enough that all such attempts are guarded in a try block.\n\"use strict\";\n\nvar arr = [];\n\nvar getProto = Object.getPrototypeOf;\n\nvar slice = arr.slice;\n\nvar flat = arr.flat ? function( array ) {\n\treturn arr.flat.call( array );\n} : function( array ) {\n\treturn arr.concat.apply( [], array );\n};\n\n\nvar push = arr.push;\n\nvar indexOf = arr.indexOf;\n\nvar class2type = {};\n\nvar toString = class2type.toString;\n\nvar hasOwn = class2type.hasOwnProperty;\n\nvar fnToString = hasOwn.toString;\n\nvar ObjectFunctionString = fnToString.call( Object );\n\nvar support = {};\n\nvar isFunction = function isFunction( obj ) {\n\n\t\t// Support: Chrome <=57, Firefox <=52\n\t\t// In some browsers, typeof returns \"function\" for HTML <object> elements\n\t\t// (i.e., `typeof document.createElement( \"object\" ) === \"function\"`).\n\t\t// We don't want to classify *any* DOM node as a function.\n\t\t// Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5\n\t\t// Plus for old WebKit, typeof returns \"function\" for HTML collections\n\t\t// (e.g., `typeof document.getElementsByTagName(\"div\") === \"function\"`). (gh-4756)\n\t\treturn typeof obj === \"function\" && typeof obj.nodeType !== \"number\" &&\n\t\t\ttypeof obj.item !== \"function\";\n\t};\n\n\nvar isWindow = function isWindow( obj ) {\n\t\treturn obj != null && obj === obj.window;\n\t};\n\n\nvar document = window.document;\n\n\n\n\tvar preservedScriptAttributes = {\n\t\ttype: true,\n\t\tsrc: true,\n\t\tnonce: true,\n\t\tnoModule: true\n\t};\n\n\tfunction DOMEval( code, node, doc ) {\n\t\tdoc = doc || document;\n\n\t\tvar i, val,\n\t\t\tscript = doc.createElement( \"script\" );\n\n\t\tscript.text = code;\n\t\tif ( node ) {\n\t\t\tfor ( i in preservedScriptAttributes ) {\n\n\t\t\t\t// Support: Firefox 64+, Edge 18+\n\t\t\t\t// Some browsers don't support the \"nonce\" property on scripts.\n\t\t\t\t// On the other hand, just using `getAttribute` is not enough as\n\t\t\t\t// the `nonce` attribute is reset to an empty string whenever it\n\t\t\t\t// becomes browsing-context connected.\n\t\t\t\t// See https://github.com/whatwg/html/issues/2369\n\t\t\t\t// See https://html.spec.whatwg.org/#nonce-attributes\n\t\t\t\t// The `node.getAttribute` check was added for the sake of\n\t\t\t\t// `jQuery.globalEval` so that it can fake a nonce-containing node\n\t\t\t\t// via an object.\n\t\t\t\tval = node[ i ] || node.getAttribute && node.getAttribute( i );\n\t\t\t\tif ( val ) {\n\t\t\t\t\tscript.setAttribute( i, val );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdoc.head.appendChild( script ).parentNode.removeChild( script );\n\t}\n\n\nfunction toType( obj ) {\n\tif ( obj == null ) {\n\t\treturn obj + \"\";\n\t}\n\n\t// Support: Android <=2.3 only (functionish RegExp)\n\treturn typeof obj === \"object\" || typeof obj === \"function\" ?\n\t\tclass2type[ toString.call( obj ) ] || \"object\" :\n\t\ttypeof obj;\n}\n/* global Symbol */\n// Defining this global in .eslintrc.json would create a danger of using the global\n// unguarded in another place, it seems safer to define global only for this module\n\n\n\nvar\n\tversion = \"3.6.0\",\n\n\t// Define a local copy of jQuery\n\tjQuery = function( selector, context ) {\n\n\t\t// The jQuery object is actually just the init constructor 'enhanced'\n\t\t// Need init if jQuery is called (just allow error to be thrown if not included)\n\t\treturn new jQuery.fn.init( selector, context );\n\t};\n\njQuery.fn = jQuery.prototype = {\n\n\t// The current version of jQuery being used\n\tjquery: version,\n\n\tconstructor: jQuery,\n\n\t// The default length of a jQuery object is 0\n\tlength: 0,\n\n\ttoArray: function() {\n\t\treturn slice.call( this );\n\t},\n\n\t// Get the Nth element in the matched element set OR\n\t// Get the whole matched element set as a clean array\n\tget: function( num ) {\n\n\t\t// Return all the elements in a clean array\n\t\tif ( num == null ) {\n\t\t\treturn slice.call( this );\n\t\t}\n\n\t\t// Return just the one element from the set\n\t\treturn num < 0 ? this[ num + this.length ] : this[ num ];\n\t},\n\n\t// Take an array of elements and push it onto the stack\n\t// (returning the new matched element set)\n\tpushStack: function( elems ) {\n\n\t\t// Build a new jQuery matched element set\n\t\tvar ret = jQuery.merge( this.constructor(), elems );\n\n\t\t// Add the old object onto the stack (as a reference)\n\t\tret.prevObject = this;\n\n\t\t// Return the newly-formed element set\n\t\treturn ret;\n\t},\n\n\t// Execute a callback for every element in the matched set.\n\teach: function( callback ) {\n\t\treturn jQuery.each( this, callback );\n\t},\n\n\tmap: function( callback ) {\n\t\treturn this.pushStack( jQuery.map( this, function( elem, i ) {\n\t\t\treturn callback.call( elem, i, elem );\n\t\t} ) );\n\t},\n\n\tslice: function() {\n\t\treturn this.pushStack( slice.apply( this, arguments ) );\n\t},\n\n\tfirst: function() {\n\t\treturn this.eq( 0 );\n\t},\n\n\tlast: function() {\n\t\treturn this.eq( -1 );\n\t},\n\n\teven: function() {\n\t\treturn this.pushStack( jQuery.grep( this, function( _elem, i ) {\n\t\t\treturn ( i + 1 ) % 2;\n\t\t} ) );\n\t},\n\n\todd: function() {\n\t\treturn this.pushStack( jQuery.grep( this, function( _elem, i ) {\n\t\t\treturn i % 2;\n\t\t} ) );\n\t},\n\n\teq: function( i ) {\n\t\tvar len = this.length,\n\t\t\tj = +i + ( i < 0 ? len : 0 );\n\t\treturn this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );\n\t},\n\n\tend: function() {\n\t\treturn this.prevObject || this.constructor();\n\t},\n\n\t// For internal use only.\n\t// Behaves like an Array's method, not like a jQuery method.\n\tpush: push,\n\tsort: arr.sort,\n\tsplice: arr.splice\n};\n\njQuery.extend = jQuery.fn.extend = function() {\n\tvar options, name, src, copy, copyIsArray, clone,\n\t\ttarget = arguments[ 0 ] || {},\n\t\ti = 1,\n\t\tlength = arguments.length,\n\t\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif ( typeof target === \"boolean\" ) {\n\t\tdeep = target;\n\n\t\t// Skip the boolean and the target\n\t\ttarget = arguments[ i ] || {};\n\t\ti++;\n\t}\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif ( typeof target !== \"object\" && !isFunction( target ) ) {\n\t\ttarget = {};\n\t}\n\n\t// Extend jQuery itself if only one argument is passed\n\tif ( i === length ) {\n\t\ttarget = this;\n\t\ti--;\n\t}\n\n\tfor ( ; i < length; i++ ) {\n\n\t\t// Only deal with non-null/undefined values\n\t\tif ( ( options = arguments[ i ] ) != null ) {\n\n\t\t\t// Extend the base object\n\t\t\tfor ( name in options ) {\n\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t// Prevent Object.prototype pollution\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif ( name === \"__proto__\" || target === copy ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject( copy ) ||\n\t\t\t\t\t( copyIsArray = Array.isArray( copy ) ) ) ) {\n\t\t\t\t\tsrc = target[ name ];\n\n\t\t\t\t\t// Ensure proper type for the source value\n\t\t\t\t\tif ( copyIsArray && !Array.isArray( src ) ) {\n\t\t\t\t\t\tclone = [];\n\t\t\t\t\t} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {\n\t\t\t\t\t\tclone = {};\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclone = src;\n\t\t\t\t\t}\n\t\t\t\t\tcopyIsArray = false;\n\n\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n\n\t\t\t\t// Don't bring in undefined values\n\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\njQuery.extend( {\n\n\t// Unique for each copy of jQuery on the page\n\texpando: \"jQuery\" + ( version + Math.random() ).replace( /\\D/g, \"\" ),\n\n\t// Assume jQuery is ready without the ready module\n\tisReady: true,\n\n\terror: function( msg ) {\n\t\tthrow new Error( msg );\n\t},\n\n\tnoop: function() {},\n\n\tisPlainObject: function( obj ) {\n\t\tvar proto, Ctor;\n\n\t\t// Detect obvious negatives\n\t\t// Use toString instead of jQuery.type to catch host objects\n\t\tif ( !obj || toString.call( obj ) !== \"[object Object]\" ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tproto = getProto( obj );\n\n\t\t// Objects with no prototype (e.g., `Object.create( null )`) are plain\n\t\tif ( !proto ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Objects with prototype are plain iff they were constructed by a global Object function\n\t\tCtor = hasOwn.call( proto, \"constructor\" ) && proto.constructor;\n\t\treturn typeof Ctor === \"function\" && fnToString.call( Ctor ) === ObjectFunctionString;\n\t},\n\n\tisEmptyObject: function( obj ) {\n\t\tvar name;\n\n\t\tfor ( name in obj ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\t// Evaluates a script in a provided context; falls back to the global one\n\t// if not specified.\n\tglobalEval: function( code, options, doc ) {\n\t\tDOMEval( code, { nonce: options && options.nonce }, doc );\n\t},\n\n\teach: function( obj, callback ) {\n\t\tvar length, i = 0;\n\n\t\tif ( isArrayLike( obj ) ) {\n\t\t\tlength = obj.length;\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor ( i in obj ) {\n\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn obj;\n\t},\n\n\t// results is for internal usage only\n\tmakeArray: function( arr, results ) {\n\t\tvar ret = results || [];\n\n\t\tif ( arr != null ) {\n\t\t\tif ( isArrayLike( Object( arr ) ) ) {\n\t\t\t\tjQuery.merge( ret,\n\t\t\t\t\ttypeof arr === \"string\" ?\n\t\t\t\t\t\t[ arr ] : arr\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tpush.call( ret, arr );\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tinArray: function( elem, arr, i ) {\n\t\treturn arr == null ? -1 : indexOf.call( arr, elem, i );\n\t},\n\n\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t// push.apply(_, arraylike) throws on ancient WebKit\n\tmerge: function( first, second ) {\n\t\tvar len = +second.length,\n\t\t\tj = 0,\n\t\t\ti = first.length;\n\n\t\tfor ( ; j < len; j++ ) {\n\t\t\tfirst[ i++ ] = second[ j ];\n\t\t}\n\n\t\tfirst.length = i;\n\n\t\treturn first;\n\t},\n\n\tgrep: function( elems, callback, invert ) {\n\t\tvar callbackInverse,\n\t\t\tmatches = [],\n\t\t\ti = 0,\n\t\t\tlength = elems.length,\n\t\t\tcallbackExpect = !invert;\n\n\t\t// Go through the array, only saving the items\n\t\t// that pass the validator function\n\t\tfor ( ; i < length; i++ ) {\n\t\t\tcallbackInverse = !callback( elems[ i ], i );\n\t\t\tif ( callbackInverse !== callbackExpect ) {\n\t\t\t\tmatches.push( elems[ i ] );\n\t\t\t}\n\t\t}\n\n\t\treturn matches;\n\t},\n\n\t// arg is for internal usage only\n\tmap: function( elems, callback, arg ) {\n\t\tvar length, value,\n\t\t\ti = 0,\n\t\t\tret = [];\n\n\t\t// Go through the array, translating each of the items to their new values\n\t\tif ( isArrayLike( elems ) ) {\n\t\t\tlength = elems.length;\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Go through every key on the object,\n\t\t} else {\n\t\t\tfor ( i in elems ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Flatten any nested arrays\n\t\treturn flat( ret );\n\t},\n\n\t// A global GUID counter for objects\n\tguid: 1,\n\n\t// jQuery.support is not used in Core but other projects attach their\n\t// properties to it so it needs to exist.\n\tsupport: support\n} );\n\nif ( typeof Symbol === \"function\" ) {\n\tjQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];\n}\n\n// Populate the class2type map\njQuery.each( \"Boolean Number String Function Array Date RegExp Object Error Symbol\".split( \" \" ),\n\tfunction( _i, name ) {\n\t\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n\t} );\n\nfunction isArrayLike( obj ) {\n\n\t// Support: real iOS 8.2 only (not reproducible in simulator)\n\t// `in` check used to prevent JIT error (gh-2145)\n\t// hasOwn isn't used here due to false negatives\n\t// regarding Nodelist length in IE\n\tvar length = !!obj && \"length\" in obj && obj.length,\n\t\ttype = toType( obj );\n\n\tif ( isFunction( obj ) || isWindow( obj ) ) {\n\t\treturn false;\n\t}\n\n\treturn type === \"array\" || length === 0 ||\n\t\ttypeof length === \"number\" && length > 0 && ( length - 1 ) in obj;\n}\nvar Sizzle =\n/*!\n * Sizzle CSS Selector Engine v2.3.6\n * https://sizzlejs.com/\n *\n * Copyright JS Foundation and other contributors\n * Released under the MIT license\n * https://js.foundation/\n *\n * Date: 2021-02-16\n */\n( function( window ) {\nvar i,\n\tsupport,\n\tExpr,\n\tgetText,\n\tisXML,\n\ttokenize,\n\tcompile,\n\tselect,\n\toutermostContext,\n\tsortInput,\n\thasDuplicate,\n\n\t// Local document vars\n\tsetDocument,\n\tdocument,\n\tdocElem,\n\tdocumentIsHTML,\n\trbuggyQSA,\n\trbuggyMatches,\n\tmatches,\n\tcontains,\n\n\t// Instance-specific data\n\texpando = \"sizzle\" + 1 * new Date(),\n\tpreferredDoc = window.document,\n\tdirruns = 0,\n\tdone = 0,\n\tclassCache = createCache(),\n\ttokenCache = createCache(),\n\tcompilerCache = createCache(),\n\tnonnativeSelectorCache = createCache(),\n\tsortOrder = function( a, b ) {\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn 0;\n\t},\n\n\t// Instance methods\n\thasOwn = ( {} ).hasOwnProperty,\n\tarr = [],\n\tpop = arr.pop,\n\tpushNative = arr.push,\n\tpush = arr.push,\n\tslice = arr.slice,\n\n\t// Use a stripped-down indexOf as it's faster than native\n\t// https://jsperf.com/thor-indexof-vs-for/5\n\tindexOf = function( list, elem ) {\n\t\tvar i = 0,\n\t\t\tlen = list.length;\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( list[ i ] === elem ) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\n\tbooleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|\" +\n\t\t\"ismap|loop|multiple|open|readonly|required|scoped\",\n\n\t// Regular expressions\n\n\t// http://www.w3.org/TR/css3-selectors/#whitespace\n\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n\n\t// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram\n\tidentifier = \"(?:\\\\\\\\[\\\\da-fA-F]{1,6}\" + whitespace +\n\t\t\"?|\\\\\\\\[^\\\\r\\\\n\\\\f]|[\\\\w-]|[^\\0-\\\\x7f])+\",\n\n\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n\tattributes = \"\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace +\n\n\t\t// Operator (capture 2)\n\t\t\"*([*^$|!~]?=)\" + whitespace +\n\n\t\t// \"Attribute values must be CSS identifiers [capture 5]\n\t\t// or strings [capture 3 or capture 4]\"\n\t\t\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" +\n\t\twhitespace + \"*\\\\]\",\n\n\tpseudos = \":(\" + identifier + \")(?:\\\\((\" +\n\n\t\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n\t\t// 1. quoted (capture 3; capture 4 or capture 5)\n\t\t\"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" +\n\n\t\t// 2. simple (capture 6)\n\t\t\"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" +\n\n\t\t// 3. anything else (capture 2)\n\t\t\".*\" +\n\t\t\")\\\\)|)\",\n\n\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\trwhitespace = new RegExp( whitespace + \"+\", \"g\" ),\n\trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" +\n\t\twhitespace + \"+$\", \"g\" ),\n\n\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\n\trcombinators = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace +\n\t\t\"*\" ),\n\trdescend = new RegExp( whitespace + \"|>\" ),\n\n\trpseudo = new RegExp( pseudos ),\n\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\n\n\tmatchExpr = {\n\t\t\"ID\": new RegExp( \"^#(\" + identifier + \")\" ),\n\t\t\"CLASS\": new RegExp( \"^\\\\.(\" + identifier + \")\" ),\n\t\t\"TAG\": new RegExp( \"^(\" + identifier + \"|[*])\" ),\n\t\t\"ATTR\": new RegExp( \"^\" + attributes ),\n\t\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\n\t\t\"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" +\n\t\t\twhitespace + \"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" +\n\t\t\twhitespace + \"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\n\t\t\"bool\": new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\n\n\t\t// For use in libraries implementing .is()\n\t\t// We use this for POS matching in `select`\n\t\t\"needsContext\": new RegExp( \"^\" + whitespace +\n\t\t\t\"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" + whitespace +\n\t\t\t\"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\n\t},\n\n\trhtml = /HTML$/i,\n\trinputs = /^(?:input|select|textarea|button)$/i,\n\trheader = /^h\\d$/i,\n\n\trnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\n\trsibling = /[+~]/,\n\n\t// CSS escapes\n\t// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\trunescape = new RegExp( \"\\\\\\\\[\\\\da-fA-F]{1,6}\" + whitespace + \"?|\\\\\\\\([^\\\\r\\\\n\\\\f])\", \"g\" ),\n\tfunescape = function( escape, nonHex ) {\n\t\tvar high = \"0x\" + escape.slice( 1 ) - 0x10000;\n\n\t\treturn nonHex ?\n\n\t\t\t// Strip the backslash prefix from a non-hex escape sequence\n\t\t\tnonHex :\n\n\t\t\t// Replace a hexadecimal escape sequence with the encoded Unicode code point\n\t\t\t// Support: IE <=11+\n\t\t\t// For values outside the Basic Multilingual Plane (BMP), manually construct a\n\t\t\t// surrogate pair\n\t\t\thigh < 0 ?\n\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n\t},\n\n\t// CSS string/identifier serialization\n\t// https://drafts.csswg.org/cssom/#common-serializing-idioms\n\trcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,\n\tfcssescape = function( ch, asCodePoint ) {\n\t\tif ( asCodePoint ) {\n\n\t\t\t// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n\t\t\tif ( ch === \"\\0\" ) {\n\t\t\t\treturn \"\\uFFFD\";\n\t\t\t}\n\n\t\t\t// Control characters and (dependent upon position) numbers get escaped as code points\n\t\t\treturn ch.slice( 0, -1 ) + \"\\\\\" +\n\t\t\t\tch.charCodeAt( ch.length - 1 ).toString( 16 ) + \" \";\n\t\t}\n\n\t\t// Other potentially-special ASCII characters get backslash-escaped\n\t\treturn \"\\\\\" + ch;\n\t},\n\n\t// Used for iframes\n\t// See setDocument()\n\t// Removing the function wrapper causes a \"Permission Denied\"\n\t// error in IE\n\tunloadHandler = function() {\n\t\tsetDocument();\n\t},\n\n\tinDisabledFieldset = addCombinator(\n\t\tfunction( elem ) {\n\t\t\treturn elem.disabled === true && elem.nodeName.toLowerCase() === \"fieldset\";\n\t\t},\n\t\t{ dir: \"parentNode\", next: \"legend\" }\n\t);\n\n// Optimize for push.apply( _, NodeList )\ntry {\n\tpush.apply(\n\t\t( arr = slice.call( preferredDoc.childNodes ) ),\n\t\tpreferredDoc.childNodes\n\t);\n\n\t// Support: Android<4.0\n\t// Detect silently failing push.apply\n\t// eslint-disable-next-line no-unused-expressions\n\tarr[ preferredDoc.childNodes.length ].nodeType;\n} catch ( e ) {\n\tpush = { apply: arr.length ?\n\n\t\t// Leverage slice if possible\n\t\tfunction( target, els ) {\n\t\t\tpushNative.apply( target, slice.call( els ) );\n\t\t} :\n\n\t\t// Support: IE<9\n\t\t// Otherwise append directly\n\t\tfunction( target, els ) {\n\t\t\tvar j = target.length,\n\t\t\t\ti = 0;\n\n\t\t\t// Can't trust NodeList.length\n\t\t\twhile ( ( target[ j++ ] = els[ i++ ] ) ) {}\n\t\t\ttarget.length = j - 1;\n\t\t}\n\t};\n}\n\nfunction Sizzle( selector, context, results, seed ) {\n\tvar m, i, elem, nid, match, groups, newSelector,\n\t\tnewContext = context && context.ownerDocument,\n\n\t\t// nodeType defaults to 9, since context defaults to document\n\t\tnodeType = context ? context.nodeType : 9;\n\n\tresults = results || [];\n\n\t// Return early from calls with invalid selector or context\n\tif ( typeof selector !== \"string\" || !selector ||\n\t\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\n\n\t\treturn results;\n\t}\n\n\t// Try to shortcut find operations (as opposed to filters) in HTML documents\n\tif ( !seed ) {\n\t\tsetDocument( context );\n\t\tcontext = context || document;\n\n\t\tif ( documentIsHTML ) {\n\n\t\t\t// If the selector is sufficiently simple, try using a \"get*By*\" DOM method\n\t\t\t// (excepting DocumentFragment context, where the methods don't exist)\n\t\t\tif ( nodeType !== 11 && ( match = rquickExpr.exec( selector ) ) ) {\n\n\t\t\t\t// ID selector\n\t\t\t\tif ( ( m = match[ 1 ] ) ) {\n\n\t\t\t\t\t// Document context\n\t\t\t\t\tif ( nodeType === 9 ) {\n\t\t\t\t\t\tif ( ( elem = context.getElementById( m ) ) ) {\n\n\t\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\t\tif ( elem.id === m ) {\n\t\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t// Element context\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\tif ( newContext && ( elem = newContext.getElementById( m ) ) &&\n\t\t\t\t\t\t\tcontains( context, elem ) &&\n\t\t\t\t\t\t\telem.id === m ) {\n\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t// Type selector\n\t\t\t\t} else if ( match[ 2 ] ) {\n\t\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n\t\t\t\t\treturn results;\n\n\t\t\t\t// Class selector\n\t\t\t\t} else if ( ( m = match[ 3 ] ) && support.getElementsByClassName &&\n\t\t\t\t\tcontext.getElementsByClassName ) {\n\n\t\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n\t\t\t\t\treturn results;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Take advantage of querySelectorAll\n\t\t\tif ( support.qsa &&\n\t\t\t\t!nonnativeSelectorCache[ selector + \" \" ] &&\n\t\t\t\t( !rbuggyQSA || !rbuggyQSA.test( selector ) ) &&\n\n\t\t\t\t// Support: IE 8 only\n\t\t\t\t// Exclude object elements\n\t\t\t\t( nodeType !== 1 || context.nodeName.toLowerCase() !== \"object\" ) ) {\n\n\t\t\t\tnewSelector = selector;\n\t\t\t\tnewContext = context;\n\n\t\t\t\t// qSA considers elements outside a scoping root when evaluating child or\n\t\t\t\t// descendant combinators, which is not what we want.\n\t\t\t\t// In such cases, we work around the behavior by prefixing every selector in the\n\t\t\t\t// list with an ID selector referencing the scope context.\n\t\t\t\t// The technique has to be used as well when a leading combinator is used\n\t\t\t\t// as such selectors are not recognized by querySelectorAll.\n\t\t\t\t// Thanks to Andrew Dupont for this technique.\n\t\t\t\tif ( nodeType === 1 &&\n\t\t\t\t\t( rdescend.test( selector ) || rcombinators.test( selector ) ) ) {\n\n\t\t\t\t\t// Expand context for sibling selectors\n\t\t\t\t\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) ||\n\t\t\t\t\t\tcontext;\n\n\t\t\t\t\t// We can use :scope instead of the ID hack if the browser\n\t\t\t\t\t// supports it & if we're not changing the context.\n\t\t\t\t\tif ( newContext !== context || !support.scope ) {\n\n\t\t\t\t\t\t// Capture the context ID, setting it first if necessary\n\t\t\t\t\t\tif ( ( nid = context.getAttribute( \"id\" ) ) ) {\n\t\t\t\t\t\t\tnid = nid.replace( rcssescape, fcssescape );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontext.setAttribute( \"id\", ( nid = expando ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prefix every selector in the list\n\t\t\t\t\tgroups = tokenize( selector );\n\t\t\t\t\ti = groups.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tgroups[ i ] = ( nid ? \"#\" + nid : \":scope\" ) + \" \" +\n\t\t\t\t\t\t\ttoSelector( groups[ i ] );\n\t\t\t\t\t}\n\t\t\t\t\tnewSelector = groups.join( \",\" );\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tpush.apply( results,\n\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n\t\t\t\t\t);\n\t\t\t\t\treturn results;\n\t\t\t\t} catch ( qsaError ) {\n\t\t\t\t\tnonnativeSelectorCache( selector, true );\n\t\t\t\t} finally {\n\t\t\t\t\tif ( nid === expando ) {\n\t\t\t\t\t\tcontext.removeAttribute( \"id\" );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// All others\n\treturn select( selector.replace( rtrim, \"$1\" ), context, results, seed );\n}\n\n/**\n * Create key-value caches of limited size\n * @returns {function(string, object)} Returns the Object data after storing it on itself with\n *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n *\tdeleting the oldest entry\n */\nfunction createCache() {\n\tvar keys = [];\n\n\tfunction cache( key, value ) {\n\n\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n\t\tif ( keys.push( key + \" \" ) > Expr.cacheLength ) {\n\n\t\t\t// Only keep the most recent entries\n\t\t\tdelete cache[ keys.shift() ];\n\t\t}\n\t\treturn ( cache[ key + \" \" ] = value );\n\t}\n\treturn cache;\n}\n\n/**\n * Mark a function for special use by Sizzle\n * @param {Function} fn The function to mark\n */\nfunction markFunction( fn ) {\n\tfn[ expando ] = true;\n\treturn fn;\n}\n\n/**\n * Support testing using an element\n * @param {Function} fn Passed the created element and returns a boolean result\n */\nfunction assert( fn ) {\n\tvar el = document.createElement( \"fieldset\" );\n\n\ttry {\n\t\treturn !!fn( el );\n\t} catch ( e ) {\n\t\treturn false;\n\t} finally {\n\n\t\t// Remove from its parent by default\n\t\tif ( el.parentNode ) {\n\t\t\tel.parentNode.removeChild( el );\n\t\t}\n\n\t\t// release memory in IE\n\t\tel = null;\n\t}\n}\n\n/**\n * Adds the same handler for all of the specified attrs\n * @param {String} attrs Pipe-separated list of attributes\n * @param {Function} handler The method that will be applied\n */\nfunction addHandle( attrs, handler ) {\n\tvar arr = attrs.split( \"|\" ),\n\t\ti = arr.length;\n\n\twhile ( i-- ) {\n\t\tExpr.attrHandle[ arr[ i ] ] = handler;\n\t}\n}\n\n/**\n * Checks document order of two siblings\n * @param {Element} a\n * @param {Element} b\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n */\nfunction siblingCheck( a, b ) {\n\tvar cur = b && a,\n\t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n\t\t\ta.sourceIndex - b.sourceIndex;\n\n\t// Use IE sourceIndex if available on both nodes\n\tif ( diff ) {\n\t\treturn diff;\n\t}\n\n\t// Check if b follows a\n\tif ( cur ) {\n\t\twhile ( ( cur = cur.nextSibling ) ) {\n\t\t\tif ( cur === b ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a ? 1 : -1;\n}\n\n/**\n * Returns a function to use in pseudos for input types\n * @param {String} type\n */\nfunction createInputPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn name === \"input\" && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for buttons\n * @param {String} type\n */\nfunction createButtonPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn ( name === \"input\" || name === \"button\" ) && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for :enabled/:disabled\n * @param {Boolean} disabled true for :disabled; false for :enabled\n */\nfunction createDisabledPseudo( disabled ) {\n\n\t// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\n\treturn function( elem ) {\n\n\t\t// Only certain elements can match :enabled or :disabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\n\t\tif ( \"form\" in elem ) {\n\n\t\t\t// Check for inherited disabledness on relevant non-disabled elements:\n\t\t\t// * listed form-associated elements in a disabled fieldset\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#category-listed\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\n\t\t\t// * option elements in a disabled optgroup\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\n\t\t\t// All such elements have a \"form\" property.\n\t\t\tif ( elem.parentNode && elem.disabled === false ) {\n\n\t\t\t\t// Option elements defer to a parent optgroup if present\n\t\t\t\tif ( \"label\" in elem ) {\n\t\t\t\t\tif ( \"label\" in elem.parentNode ) {\n\t\t\t\t\t\treturn elem.parentNode.disabled === disabled;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn elem.disabled === disabled;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Support: IE 6 - 11\n\t\t\t\t// Use the isDisabled shortcut property to check for disabled fieldset ancestors\n\t\t\t\treturn elem.isDisabled === disabled ||\n\n\t\t\t\t\t// Where there is no isDisabled, check manually\n\t\t\t\t\t/* jshint -W018 */\n\t\t\t\t\telem.isDisabled !== !disabled &&\n\t\t\t\t\tinDisabledFieldset( elem ) === disabled;\n\t\t\t}\n\n\t\t\treturn elem.disabled === disabled;\n\n\t\t// Try to winnow out elements that can't be disabled before trusting the disabled property.\n\t\t// Some victims get caught in our net (label, legend, menu, track), but it shouldn't\n\t\t// even exist on them, let alone have a boolean value.\n\t\t} else if ( \"label\" in elem ) {\n\t\t\treturn elem.disabled === disabled;\n\t\t}\n\n\t\t// Remaining elements are neither :enabled nor :disabled\n\t\treturn false;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for positionals\n * @param {Function} fn\n */\nfunction createPositionalPseudo( fn ) {\n\treturn markFunction( function( argument ) {\n\t\targument = +argument;\n\t\treturn markFunction( function( seed, matches ) {\n\t\t\tvar j,\n\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n\t\t\t\ti = matchIndexes.length;\n\n\t\t\t// Match elements found at the specified indexes\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( seed[ ( j = matchIndexes[ i ] ) ] ) {\n\t\t\t\t\tseed[ j ] = !( matches[ j ] = seed[ j ] );\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t} );\n}\n\n/**\n * Checks a node for validity as a Sizzle context\n * @param {Element|Object=} context\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n */\nfunction testContext( context ) {\n\treturn context && typeof context.getElementsByTagName !== \"undefined\" && context;\n}\n\n// Expose support vars for convenience\nsupport = Sizzle.support = {};\n\n/**\n * Detects XML nodes\n * @param {Element|Object} elem An element or a document\n * @returns {Boolean} True iff elem is a non-HTML XML node\n */\nisXML = Sizzle.isXML = function( elem ) {\n\tvar namespace = elem && elem.namespaceURI,\n\t\tdocElem = elem && ( elem.ownerDocument || elem ).documentElement;\n\n\t// Support: IE <=8\n\t// Assume HTML when documentElement doesn't yet exist, such as inside loading iframes\n\t// https://bugs.jquery.com/ticket/4833\n\treturn !rhtml.test( namespace || docElem && docElem.nodeName || \"HTML\" );\n};\n\n/**\n * Sets document-related variables once based on the current document\n * @param {Element|Object} [doc] An element or document object to use to set the document\n * @returns {Object} Returns the current document\n */\nsetDocument = Sizzle.setDocument = function( node ) {\n\tvar hasCompare, subWindow,\n\t\tdoc = node ? node.ownerDocument || node : preferredDoc;\n\n\t// Return early if doc is invalid or already selected\n\t// Support: IE 11+, Edge 17 - 18+\n\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t// two documents; shallow comparisons work.\n\t// eslint-disable-next-line eqeqeq\n\tif ( doc == document || doc.nodeType !== 9 || !doc.documentElement ) {\n\t\treturn document;\n\t}\n\n\t// Update global variables\n\tdocument = doc;\n\tdocElem = document.documentElement;\n\tdocumentIsHTML = !isXML( document );\n\n\t// Support: IE 9 - 11+, Edge 12 - 18+\n\t// Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\n\t// Support: IE 11+, Edge 17 - 18+\n\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t// two documents; shallow comparisons work.\n\t// eslint-disable-next-line eqeqeq\n\tif ( preferredDoc != document &&\n\t\t( subWindow = document.defaultView ) && subWindow.top !== subWindow ) {\n\n\t\t// Support: IE 11, Edge\n\t\tif ( subWindow.addEventListener ) {\n\t\t\tsubWindow.addEventListener( \"unload\", unloadHandler, false );\n\n\t\t// Support: IE 9 - 10 only\n\t\t} else if ( subWindow.attachEvent ) {\n\t\t\tsubWindow.attachEvent( \"onunload\", unloadHandler );\n\t\t}\n\t}\n\n\t// Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,\n\t// Safari 4 - 5 only, Opera <=11.6 - 12.x only\n\t// IE/Edge & older browsers don't support the :scope pseudo-class.\n\t// Support: Safari 6.0 only\n\t// Safari 6.0 supports :scope but it's an alias of :root there.\n\tsupport.scope = assert( function( el ) {\n\t\tdocElem.appendChild( el ).appendChild( document.createElement( \"div\" ) );\n\t\treturn typeof el.querySelectorAll !== \"undefined\" &&\n\t\t\t!el.querySelectorAll( \":scope fieldset div\" ).length;\n\t} );\n\n\t/* Attributes\n\t---------------------------------------------------------------------- */\n\n\t// Support: IE<8\n\t// Verify that getAttribute really returns attributes and not properties\n\t// (excepting IE8 booleans)\n\tsupport.attributes = assert( function( el ) {\n\t\tel.className = \"i\";\n\t\treturn !el.getAttribute( \"className\" );\n\t} );\n\n\t/* getElement(s)By*\n\t---------------------------------------------------------------------- */\n\n\t// Check if getElementsByTagName(\"*\") returns only elements\n\tsupport.getElementsByTagName = assert( function( el ) {\n\t\tel.appendChild( document.createComment( \"\" ) );\n\t\treturn !el.getElementsByTagName( \"*\" ).length;\n\t} );\n\n\t// Support: IE<9\n\tsupport.getElementsByClassName = rnative.test( document.getElementsByClassName );\n\n\t// Support: IE<10\n\t// Check if getElementById returns elements by name\n\t// The broken getElementById methods don't pick up programmatically-set names,\n\t// so use a roundabout getElementsByName test\n\tsupport.getById = assert( function( el ) {\n\t\tdocElem.appendChild( el ).id = expando;\n\t\treturn !document.getElementsByName || !document.getElementsByName( expando ).length;\n\t} );\n\n\t// ID filter and find\n\tif ( support.getById ) {\n\t\tExpr.filter[ \"ID\" ] = function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn elem.getAttribute( \"id\" ) === attrId;\n\t\t\t};\n\t\t};\n\t\tExpr.find[ \"ID\" ] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\tvar elem = context.getElementById( id );\n\t\t\t\treturn elem ? [ elem ] : [];\n\t\t\t}\n\t\t};\n\t} else {\n\t\tExpr.filter[ \"ID\" ] =  function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" &&\n\t\t\t\t\telem.getAttributeNode( \"id\" );\n\t\t\t\treturn node && node.value === attrId;\n\t\t\t};\n\t\t};\n\n\t\t// Support: IE 6 - 7 only\n\t\t// getElementById is not reliable as a find shortcut\n\t\tExpr.find[ \"ID\" ] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\tvar node, i, elems,\n\t\t\t\t\telem = context.getElementById( id );\n\n\t\t\t\tif ( elem ) {\n\n\t\t\t\t\t// Verify the id attribute\n\t\t\t\t\tnode = elem.getAttributeNode( \"id\" );\n\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t}\n\n\t\t\t\t\t// Fall back on getElementsByName\n\t\t\t\t\telems = context.getElementsByName( id );\n\t\t\t\t\ti = 0;\n\t\t\t\t\twhile ( ( elem = elems[ i++ ] ) ) {\n\t\t\t\t\t\tnode = elem.getAttributeNode( \"id\" );\n\t\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn [];\n\t\t\t}\n\t\t};\n\t}\n\n\t// Tag\n\tExpr.find[ \"TAG\" ] = support.getElementsByTagName ?\n\t\tfunction( tag, context ) {\n\t\t\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\t\t\treturn context.getElementsByTagName( tag );\n\n\t\t\t// DocumentFragment nodes don't have gEBTN\n\t\t\t} else if ( support.qsa ) {\n\t\t\t\treturn context.querySelectorAll( tag );\n\t\t\t}\n\t\t} :\n\n\t\tfunction( tag, context ) {\n\t\t\tvar elem,\n\t\t\t\ttmp = [],\n\t\t\t\ti = 0,\n\n\t\t\t\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n\t\t\t\tresults = context.getElementsByTagName( tag );\n\n\t\t\t// Filter out possible comments\n\t\t\tif ( tag === \"*\" ) {\n\t\t\t\twhile ( ( elem = results[ i++ ] ) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\ttmp.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t// Class\n\tExpr.find[ \"CLASS\" ] = support.getElementsByClassName && function( className, context ) {\n\t\tif ( typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML ) {\n\t\t\treturn context.getElementsByClassName( className );\n\t\t}\n\t};\n\n\t/* QSA/matchesSelector\n\t---------------------------------------------------------------------- */\n\n\t// QSA and matchesSelector support\n\n\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\trbuggyMatches = [];\n\n\t// qSa(:focus) reports false when true (Chrome 21)\n\t// We allow this because of a bug in IE8/9 that throws an error\n\t// whenever `document.activeElement` is accessed on an iframe\n\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t// See https://bugs.jquery.com/ticket/13378\n\trbuggyQSA = [];\n\n\tif ( ( support.qsa = rnative.test( document.querySelectorAll ) ) ) {\n\n\t\t// Build QSA regex\n\t\t// Regex strategy adopted from Diego Perini\n\t\tassert( function( el ) {\n\n\t\t\tvar input;\n\n\t\t\t// Select is set to empty string on purpose\n\t\t\t// This is to test IE's treatment of not explicitly\n\t\t\t// setting a boolean content attribute,\n\t\t\t// since its presence should be enough\n\t\t\t// https://bugs.jquery.com/ticket/12359\n\t\t\tdocElem.appendChild( el ).innerHTML = \"<a id='\" + expando + \"'></a>\" +\n\t\t\t\t\"<select id='\" + expando + \"-\\r\\\\' msallowcapture=''>\" +\n\t\t\t\t\"<option selected=''></option></select>\";\n\n\t\t\t// Support: IE8, Opera 11-12.16\n\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n\t\t\t// The test attribute must be unknown in Opera but \"safe\" for WinRT\n\t\t\t// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\t\t\tif ( el.querySelectorAll( \"[msallowcapture^='']\" ).length ) {\n\t\t\t\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\" );\n\t\t\t}\n\n\t\t\t// Support: IE8\n\t\t\t// Boolean attributes and \"value\" are not treated correctly\n\t\t\tif ( !el.querySelectorAll( \"[selected]\" ).length ) {\n\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\n\t\t\t}\n\n\t\t\t// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n\t\t\tif ( !el.querySelectorAll( \"[id~=\" + expando + \"-]\" ).length ) {\n\t\t\t\trbuggyQSA.push( \"~=\" );\n\t\t\t}\n\n\t\t\t// Support: IE 11+, Edge 15 - 18+\n\t\t\t// IE 11/Edge don't find elements on a `[name='']` query in some cases.\n\t\t\t// Adding a temporary attribute to the document before the selection works\n\t\t\t// around the issue.\n\t\t\t// Interestingly, IE 10 & older don't seem to have the issue.\n\t\t\tinput = document.createElement( \"input\" );\n\t\t\tinput.setAttribute( \"name\", \"\" );\n\t\t\tel.appendChild( input );\n\t\t\tif ( !el.querySelectorAll( \"[name='']\" ).length ) {\n\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*name\" + whitespace + \"*=\" +\n\t\t\t\t\twhitespace + \"*(?:''|\\\"\\\")\" );\n\t\t\t}\n\n\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !el.querySelectorAll( \":checked\" ).length ) {\n\t\t\t\trbuggyQSA.push( \":checked\" );\n\t\t\t}\n\n\t\t\t// Support: Safari 8+, iOS 8+\n\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=136851\n\t\t\t// In-page `selector#id sibling-combinator selector` fails\n\t\t\tif ( !el.querySelectorAll( \"a#\" + expando + \"+*\" ).length ) {\n\t\t\t\trbuggyQSA.push( \".#.+[+~]\" );\n\t\t\t}\n\n\t\t\t// Support: Firefox <=3.6 - 5 only\n\t\t\t// Old Firefox doesn't throw on a badly-escaped identifier.\n\t\t\tel.querySelectorAll( \"\\\\\\f\" );\n\t\t\trbuggyQSA.push( \"[\\\\r\\\\n\\\\f]\" );\n\t\t} );\n\n\t\tassert( function( el ) {\n\t\t\tel.innerHTML = \"<a href='' disabled='disabled'></a>\" +\n\t\t\t\t\"<select disabled='disabled'><option/></select>\";\n\n\t\t\t// Support: Windows 8 Native Apps\n\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n\t\t\tvar input = document.createElement( \"input\" );\n\t\t\tinput.setAttribute( \"type\", \"hidden\" );\n\t\t\tel.appendChild( input ).setAttribute( \"name\", \"D\" );\n\n\t\t\t// Support: IE8\n\t\t\t// Enforce case-sensitivity of name attribute\n\t\t\tif ( el.querySelectorAll( \"[name=d]\" ).length ) {\n\t\t\t\trbuggyQSA.push( \"name\" + whitespace + \"*[*^$|!~]?=\" );\n\t\t\t}\n\n\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( el.querySelectorAll( \":enabled\" ).length !== 2 ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Support: IE9-11+\n\t\t\t// IE's :disabled selector does not pick up the children of disabled fieldsets\n\t\t\tdocElem.appendChild( el ).disabled = true;\n\t\t\tif ( el.querySelectorAll( \":disabled\" ).length !== 2 ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Support: Opera 10 - 11 only\n\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\tel.querySelectorAll( \"*,:x\" );\n\t\t\trbuggyQSA.push( \",.*:\" );\n\t\t} );\n\t}\n\n\tif ( ( support.matchesSelector = rnative.test( ( matches = docElem.matches ||\n\t\tdocElem.webkitMatchesSelector ||\n\t\tdocElem.mozMatchesSelector ||\n\t\tdocElem.oMatchesSelector ||\n\t\tdocElem.msMatchesSelector ) ) ) ) {\n\n\t\tassert( function( el ) {\n\n\t\t\t// Check to see if it's possible to do matchesSelector\n\t\t\t// on a disconnected node (IE 9)\n\t\t\tsupport.disconnectedMatch = matches.call( el, \"*\" );\n\n\t\t\t// This should fail with an exception\n\t\t\t// Gecko does not error, returns false instead\n\t\t\tmatches.call( el, \"[s!='']:x\" );\n\t\t\trbuggyMatches.push( \"!=\", pseudos );\n\t\t} );\n\t}\n\n\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join( \"|\" ) );\n\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join( \"|\" ) );\n\n\t/* Contains\n\t---------------------------------------------------------------------- */\n\thasCompare = rnative.test( docElem.compareDocumentPosition );\n\n\t// Element contains another\n\t// Purposefully self-exclusive\n\t// As in, an element does not contain itself\n\tcontains = hasCompare || rnative.test( docElem.contains ) ?\n\t\tfunction( a, b ) {\n\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t\tbup = b && b.parentNode;\n\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n\t\t\t\tadown.contains ?\n\t\t\t\t\tadown.contains( bup ) :\n\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n\t\t\t) );\n\t\t} :\n\t\tfunction( a, b ) {\n\t\t\tif ( b ) {\n\t\t\t\twhile ( ( b = b.parentNode ) ) {\n\t\t\t\t\tif ( b === a ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t/* Sorting\n\t---------------------------------------------------------------------- */\n\n\t// Document order sorting\n\tsortOrder = hasCompare ?\n\tfunction( a, b ) {\n\n\t\t// Flag for duplicate removal\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Sort on method existence if only one input has compareDocumentPosition\n\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\t\tif ( compare ) {\n\t\t\treturn compare;\n\t\t}\n\n\t\t// Calculate position if both inputs belong to the same document\n\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t// two documents; shallow comparisons work.\n\t\t// eslint-disable-next-line eqeqeq\n\t\tcompare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?\n\t\t\ta.compareDocumentPosition( b ) :\n\n\t\t\t// Otherwise we know they are disconnected\n\t\t\t1;\n\n\t\t// Disconnected nodes\n\t\tif ( compare & 1 ||\n\t\t\t( !support.sortDetached && b.compareDocumentPosition( a ) === compare ) ) {\n\n\t\t\t// Choose the first element that is related to our preferred document\n\t\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t\t// two documents; shallow comparisons work.\n\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\tif ( a == document || a.ownerDocument == preferredDoc &&\n\t\t\t\tcontains( preferredDoc, a ) ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t\t// two documents; shallow comparisons work.\n\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\tif ( b == document || b.ownerDocument == preferredDoc &&\n\t\t\t\tcontains( preferredDoc, b ) ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t// Maintain original order\n\t\t\treturn sortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\t\t}\n\n\t\treturn compare & 4 ? -1 : 1;\n\t} :\n\tfunction( a, b ) {\n\n\t\t// Exit early if the nodes are identical\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\taup = a.parentNode,\n\t\t\tbup = b.parentNode,\n\t\t\tap = [ a ],\n\t\t\tbp = [ b ];\n\n\t\t// Parentless nodes are either documents or disconnected\n\t\tif ( !aup || !bup ) {\n\n\t\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t\t// two documents; shallow comparisons work.\n\t\t\t/* eslint-disable eqeqeq */\n\t\t\treturn a == document ? -1 :\n\t\t\t\tb == document ? 1 :\n\t\t\t\t/* eslint-enable eqeqeq */\n\t\t\t\taup ? -1 :\n\t\t\t\tbup ? 1 :\n\t\t\t\tsortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\n\t\t// If the nodes are siblings, we can do a quick check\n\t\t} else if ( aup === bup ) {\n\t\t\treturn siblingCheck( a, b );\n\t\t}\n\n\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\tcur = a;\n\t\twhile ( ( cur = cur.parentNode ) ) {\n\t\t\tap.unshift( cur );\n\t\t}\n\t\tcur = b;\n\t\twhile ( ( cur = cur.parentNode ) ) {\n\t\t\tbp.unshift( cur );\n\t\t}\n\n\t\t// Walk down the tree looking for a discrepancy\n\t\twhile ( ap[ i ] === bp[ i ] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i ?\n\n\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\tsiblingCheck( ap[ i ], bp[ i ] ) :\n\n\t\t\t// Otherwise nodes in our document sort first\n\t\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t\t// two documents; shallow comparisons work.\n\t\t\t/* eslint-disable eqeqeq */\n\t\t\tap[ i ] == preferredDoc ? -1 :\n\t\t\tbp[ i ] == preferredDoc ? 1 :\n\t\t\t/* eslint-enable eqeqeq */\n\t\t\t0;\n\t};\n\n\treturn document;\n};\n\nSizzle.matches = function( expr, elements ) {\n\treturn Sizzle( expr, null, null, elements );\n};\n\nSizzle.matchesSelector = function( elem, expr ) {\n\tsetDocument( elem );\n\n\tif ( support.matchesSelector && documentIsHTML &&\n\t\t!nonnativeSelectorCache[ expr + \" \" ] &&\n\t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n\t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n\n\t\ttry {\n\t\t\tvar ret = matches.call( elem, expr );\n\n\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\n\t\t\tif ( ret || support.disconnectedMatch ||\n\n\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t// fragment in IE 9\n\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} catch ( e ) {\n\t\t\tnonnativeSelectorCache( expr, true );\n\t\t}\n\t}\n\n\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\n};\n\nSizzle.contains = function( context, elem ) {\n\n\t// Set document vars if needed\n\t// Support: IE 11+, Edge 17 - 18+\n\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t// two documents; shallow comparisons work.\n\t// eslint-disable-next-line eqeqeq\n\tif ( ( context.ownerDocument || context ) != document ) {\n\t\tsetDocument( context );\n\t}\n\treturn contains( context, elem );\n};\n\nSizzle.attr = function( elem, name ) {\n\n\t// Set document vars if needed\n\t// Support: IE 11+, Edge 17 - 18+\n\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t// two documents; shallow comparisons work.\n\t// eslint-disable-next-line eqeqeq\n\tif ( ( elem.ownerDocument || elem ) != document ) {\n\t\tsetDocument( elem );\n\t}\n\n\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n\n\t\t// Don't get fooled by Object.prototype properties (jQuery #13807)\n\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n\t\t\tfn( elem, name, !documentIsHTML ) :\n\t\t\tundefined;\n\n\treturn val !== undefined ?\n\t\tval :\n\t\tsupport.attributes || !documentIsHTML ?\n\t\t\telem.getAttribute( name ) :\n\t\t\t( val = elem.getAttributeNode( name ) ) && val.specified ?\n\t\t\t\tval.value :\n\t\t\t\tnull;\n};\n\nSizzle.escape = function( sel ) {\n\treturn ( sel + \"\" ).replace( rcssescape, fcssescape );\n};\n\nSizzle.error = function( msg ) {\n\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\n};\n\n/**\n * Document sorting and removing duplicates\n * @param {ArrayLike} results\n */\nSizzle.uniqueSort = function( results ) {\n\tvar elem,\n\t\tduplicates = [],\n\t\tj = 0,\n\t\ti = 0;\n\n\t// Unless we *know* we can detect duplicates, assume their presence\n\thasDuplicate = !support.detectDuplicates;\n\tsortInput = !support.sortStable && results.slice( 0 );\n\tresults.sort( sortOrder );\n\n\tif ( hasDuplicate ) {\n\t\twhile ( ( elem = results[ i++ ] ) ) {\n\t\t\tif ( elem === results[ i ] ) {\n\t\t\t\tj = duplicates.push( i );\n\t\t\t}\n\t\t}\n\t\twhile ( j-- ) {\n\t\t\tresults.splice( duplicates[ j ], 1 );\n\t\t}\n\t}\n\n\t// Clear input after sorting to release objects\n\t// See https://github.com/jquery/sizzle/pull/225\n\tsortInput = null;\n\n\treturn results;\n};\n\n/**\n * Utility function for retrieving the text value of an array of DOM nodes\n * @param {Array|Element} elem\n */\ngetText = Sizzle.getText = function( elem ) {\n\tvar node,\n\t\tret = \"\",\n\t\ti = 0,\n\t\tnodeType = elem.nodeType;\n\n\tif ( !nodeType ) {\n\n\t\t// If no nodeType, this is expected to be an array\n\t\twhile ( ( node = elem[ i++ ] ) ) {\n\n\t\t\t// Do not traverse comment nodes\n\t\t\tret += getText( node );\n\t\t}\n\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n\n\t\t// Use textContent for elements\n\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n\t\tif ( typeof elem.textContent === \"string\" ) {\n\t\t\treturn elem.textContent;\n\t\t} else {\n\n\t\t\t// Traverse its children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tret += getText( elem );\n\t\t\t}\n\t\t}\n\t} else if ( nodeType === 3 || nodeType === 4 ) {\n\t\treturn elem.nodeValue;\n\t}\n\n\t// Do not include comment or processing instruction nodes\n\n\treturn ret;\n};\n\nExpr = Sizzle.selectors = {\n\n\t// Can be adjusted by the user\n\tcacheLength: 50,\n\n\tcreatePseudo: markFunction,\n\n\tmatch: matchExpr,\n\n\tattrHandle: {},\n\n\tfind: {},\n\n\trelative: {\n\t\t\">\": { dir: \"parentNode\", first: true },\n\t\t\" \": { dir: \"parentNode\" },\n\t\t\"+\": { dir: \"previousSibling\", first: true },\n\t\t\"~\": { dir: \"previousSibling\" }\n\t},\n\n\tpreFilter: {\n\t\t\"ATTR\": function( match ) {\n\t\t\tmatch[ 1 ] = match[ 1 ].replace( runescape, funescape );\n\n\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\tmatch[ 3 ] = ( match[ 3 ] || match[ 4 ] ||\n\t\t\t\tmatch[ 5 ] || \"\" ).replace( runescape, funescape );\n\n\t\t\tif ( match[ 2 ] === \"~=\" ) {\n\t\t\t\tmatch[ 3 ] = \" \" + match[ 3 ] + \" \";\n\t\t\t}\n\n\t\t\treturn match.slice( 0, 4 );\n\t\t},\n\n\t\t\"CHILD\": function( match ) {\n\n\t\t\t/* matches from matchExpr[\"CHILD\"]\n\t\t\t\t1 type (only|nth|...)\n\t\t\t\t2 what (child|of-type)\n\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t5 sign of xn-component\n\t\t\t\t6 x of xn-component\n\t\t\t\t7 sign of y-component\n\t\t\t\t8 y of y-component\n\t\t\t*/\n\t\t\tmatch[ 1 ] = match[ 1 ].toLowerCase();\n\n\t\t\tif ( match[ 1 ].slice( 0, 3 ) === \"nth\" ) {\n\n\t\t\t\t// nth-* requires argument\n\t\t\t\tif ( !match[ 3 ] ) {\n\t\t\t\t\tSizzle.error( match[ 0 ] );\n\t\t\t\t}\n\n\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\tmatch[ 4 ] = +( match[ 4 ] ?\n\t\t\t\t\tmatch[ 5 ] + ( match[ 6 ] || 1 ) :\n\t\t\t\t\t2 * ( match[ 3 ] === \"even\" || match[ 3 ] === \"odd\" ) );\n\t\t\t\tmatch[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === \"odd\" );\n\n\t\t\t\t// other types prohibit arguments\n\t\t\t} else if ( match[ 3 ] ) {\n\t\t\t\tSizzle.error( match[ 0 ] );\n\t\t\t}\n\n\t\t\treturn match;\n\t\t},\n\n\t\t\"PSEUDO\": function( match ) {\n\t\t\tvar excess,\n\t\t\t\tunquoted = !match[ 6 ] && match[ 2 ];\n\n\t\t\tif ( matchExpr[ \"CHILD\" ].test( match[ 0 ] ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Accept quoted arguments as-is\n\t\t\tif ( match[ 3 ] ) {\n\t\t\t\tmatch[ 2 ] = match[ 4 ] || match[ 5 ] || \"\";\n\n\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n\n\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t( excess = tokenize( unquoted, true ) ) &&\n\n\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t( excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length ) ) {\n\n\t\t\t\t// excess is a negative index\n\t\t\t\tmatch[ 0 ] = match[ 0 ].slice( 0, excess );\n\t\t\t\tmatch[ 2 ] = unquoted.slice( 0, excess );\n\t\t\t}\n\n\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\treturn match.slice( 0, 3 );\n\t\t}\n\t},\n\n\tfilter: {\n\n\t\t\"TAG\": function( nodeNameSelector ) {\n\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn nodeNameSelector === \"*\" ?\n\t\t\t\tfunction() {\n\t\t\t\t\treturn true;\n\t\t\t\t} :\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t};\n\t\t},\n\n\t\t\"CLASS\": function( className ) {\n\t\t\tvar pattern = classCache[ className + \" \" ];\n\n\t\t\treturn pattern ||\n\t\t\t\t( pattern = new RegExp( \"(^|\" + whitespace +\n\t\t\t\t\t\")\" + className + \"(\" + whitespace + \"|$)\" ) ) && classCache(\n\t\t\t\t\t\tclassName, function( elem ) {\n\t\t\t\t\t\t\treturn pattern.test(\n\t\t\t\t\t\t\t\ttypeof elem.className === \"string\" && elem.className ||\n\t\t\t\t\t\t\t\ttypeof elem.getAttribute !== \"undefined\" &&\n\t\t\t\t\t\t\t\t\telem.getAttribute( \"class\" ) ||\n\t\t\t\t\t\t\t\t\"\"\n\t\t\t\t\t\t\t);\n\t\t\t\t} );\n\t\t},\n\n\t\t\"ATTR\": function( name, operator, check ) {\n\t\t\treturn function( elem ) {\n\t\t\t\tvar result = Sizzle.attr( elem, name );\n\n\t\t\t\tif ( result == null ) {\n\t\t\t\t\treturn operator === \"!=\";\n\t\t\t\t}\n\t\t\t\tif ( !operator ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tresult += \"\";\n\n\t\t\t\t/* eslint-disable max-len */\n\n\t\t\t\treturn operator === \"=\" ? result === check :\n\t\t\t\t\toperator === \"!=\" ? result !== check :\n\t\t\t\t\toperator === \"^=\" ? check && result.indexOf( check ) === 0 :\n\t\t\t\t\toperator === \"*=\" ? check && result.indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"$=\" ? check && result.slice( -check.length ) === check :\n\t\t\t\t\toperator === \"~=\" ? ( \" \" + result.replace( rwhitespace, \" \" ) + \" \" ).indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\n\t\t\t\t\tfalse;\n\t\t\t\t/* eslint-enable max-len */\n\n\t\t\t};\n\t\t},\n\n\t\t\"CHILD\": function( type, what, _argument, first, last ) {\n\t\t\tvar simple = type.slice( 0, 3 ) !== \"nth\",\n\t\t\t\tforward = type.slice( -4 ) !== \"last\",\n\t\t\t\tofType = what === \"of-type\";\n\n\t\t\treturn first === 1 && last === 0 ?\n\n\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t} :\n\n\t\t\t\tfunction( elem, _context, xml ) {\n\t\t\t\t\tvar cache, uniqueCache, outerCache, node, nodeIndex, start,\n\t\t\t\t\t\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n\t\t\t\t\t\tparent = elem.parentNode,\n\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\tuseCache = !xml && !ofType,\n\t\t\t\t\t\tdiff = false;\n\n\t\t\t\t\tif ( parent ) {\n\n\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\tif ( simple ) {\n\t\t\t\t\t\t\twhile ( dir ) {\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\twhile ( ( node = node[ dir ] ) ) {\n\t\t\t\t\t\t\t\t\tif ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) {\n\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\n\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n\n\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\tif ( forward && useCache ) {\n\n\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\n\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\tnode = parent;\n\t\t\t\t\t\t\touterCache = node[ expando ] || ( node[ expando ] = {} );\n\n\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t( outerCache[ node.uniqueID ] = {} );\n\n\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\tdiff = nodeIndex && cache[ 2 ];\n\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n\n\t\t\t\t\t\t\twhile ( ( node = ++nodeIndex && node && node[ dir ] ||\n\n\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\t( diff = nodeIndex = 0 ) || start.pop() ) ) {\n\n\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, nodeIndex, diff ];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t\tif ( useCache ) {\n\n\t\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\touterCache = node[ expando ] || ( node[ expando ] = {} );\n\n\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t( outerCache[ node.uniqueID ] = {} );\n\n\t\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\t\tdiff = nodeIndex;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// xml :nth-child(...)\n\t\t\t\t\t\t\t// or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t\tif ( diff === false ) {\n\n\t\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\t\twhile ( ( node = ++nodeIndex && node && node[ dir ] ||\n\t\t\t\t\t\t\t\t\t( diff = nodeIndex = 0 ) || start.pop() ) ) {\n\n\t\t\t\t\t\t\t\t\tif ( ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) &&\n\t\t\t\t\t\t\t\t\t\t++diff ) {\n\n\t\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t\t\touterCache = node[ expando ] ||\n\t\t\t\t\t\t\t\t\t\t\t\t( node[ expando ] = {} );\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t\t\t\t( outerCache[ node.uniqueID ] = {} );\n\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, diff ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t},\n\n\t\t\"PSEUDO\": function( pseudo, argument ) {\n\n\t\t\t// pseudo-class names are case-insensitive\n\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\tvar args,\n\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n\t\t\t\t\tSizzle.error( \"unsupported pseudo: \" + pseudo );\n\n\t\t\t// The user may use createPseudo to indicate that\n\t\t\t// arguments are needed to create the filter function\n\t\t\t// just as Sizzle does\n\t\t\tif ( fn[ expando ] ) {\n\t\t\t\treturn fn( argument );\n\t\t\t}\n\n\t\t\t// But maintain support for old signatures\n\t\t\tif ( fn.length > 1 ) {\n\t\t\t\targs = [ pseudo, pseudo, \"\", argument ];\n\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n\t\t\t\t\tmarkFunction( function( seed, matches ) {\n\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n\t\t\t\t\t\t\ti = matched.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tidx = indexOf( seed, matched[ i ] );\n\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[ i ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t} ) :\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn fn( elem, 0, args );\n\t\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn fn;\n\t\t}\n\t},\n\n\tpseudos: {\n\n\t\t// Potentially complex pseudos\n\t\t\"not\": markFunction( function( selector ) {\n\n\t\t\t// Trim the selector passed to compile\n\t\t\t// to avoid treating leading and trailing\n\t\t\t// spaces as combinators\n\t\t\tvar input = [],\n\t\t\t\tresults = [],\n\t\t\t\tmatcher = compile( selector.replace( rtrim, \"$1\" ) );\n\n\t\t\treturn matcher[ expando ] ?\n\t\t\t\tmarkFunction( function( seed, matches, _context, xml ) {\n\t\t\t\t\tvar elem,\n\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n\t\t\t\t\t\ti = seed.length;\n\n\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( ( elem = unmatched[ i ] ) ) {\n\t\t\t\t\t\t\tseed[ i ] = !( matches[ i ] = elem );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} ) :\n\t\t\t\tfunction( elem, _context, xml ) {\n\t\t\t\t\tinput[ 0 ] = elem;\n\t\t\t\t\tmatcher( input, null, xml, results );\n\n\t\t\t\t\t// Don't keep the element (issue #299)\n\t\t\t\t\tinput[ 0 ] = null;\n\t\t\t\t\treturn !results.pop();\n\t\t\t\t};\n\t\t} ),\n\n\t\t\"has\": markFunction( function( selector ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n\t\t\t};\n\t\t} ),\n\n\t\t\"contains\": markFunction( function( text ) {\n\t\t\ttext = text.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn ( elem.textContent || getText( elem ) ).indexOf( text ) > -1;\n\t\t\t};\n\t\t} ),\n\n\t\t// \"Whether an element is represented by a :lang() selector\n\t\t// is based solely on the element's language value\n\t\t// being equal to the identifier C,\n\t\t// or beginning with the identifier C immediately followed by \"-\".\n\t\t// The matching of C against the element's language value is performed case-insensitively.\n\t\t// The identifier C does not have to be a valid language name.\"\n\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t\"lang\": markFunction( function( lang ) {\n\n\t\t\t// lang value must be a valid identifier\n\t\t\tif ( !ridentifier.test( lang || \"\" ) ) {\n\t\t\t\tSizzle.error( \"unsupported lang: \" + lang );\n\t\t\t}\n\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn function( elem ) {\n\t\t\t\tvar elemLang;\n\t\t\t\tdo {\n\t\t\t\t\tif ( ( elemLang = documentIsHTML ?\n\t\t\t\t\t\telem.lang :\n\t\t\t\t\t\telem.getAttribute( \"xml:lang\" ) || elem.getAttribute( \"lang\" ) ) ) {\n\n\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\n\t\t\t\t\t}\n\t\t\t\t} while ( ( elem = elem.parentNode ) && elem.nodeType === 1 );\n\t\t\t\treturn false;\n\t\t\t};\n\t\t} ),\n\n\t\t// Miscellaneous\n\t\t\"target\": function( elem ) {\n\t\t\tvar hash = window.location && window.location.hash;\n\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n\t\t},\n\n\t\t\"root\": function( elem ) {\n\t\t\treturn elem === docElem;\n\t\t},\n\n\t\t\"focus\": function( elem ) {\n\t\t\treturn elem === document.activeElement &&\n\t\t\t\t( !document.hasFocus || document.hasFocus() ) &&\n\t\t\t\t!!( elem.type || elem.href || ~elem.tabIndex );\n\t\t},\n\n\t\t// Boolean properties\n\t\t\"enabled\": createDisabledPseudo( false ),\n\t\t\"disabled\": createDisabledPseudo( true ),\n\n\t\t\"checked\": function( elem ) {\n\n\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\treturn ( nodeName === \"input\" && !!elem.checked ) ||\n\t\t\t\t( nodeName === \"option\" && !!elem.selected );\n\t\t},\n\n\t\t\"selected\": function( elem ) {\n\n\t\t\t// Accessing this property makes selected-by-default\n\t\t\t// options in Safari work properly\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\t// eslint-disable-next-line no-unused-expressions\n\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t}\n\n\t\t\treturn elem.selected === true;\n\t\t},\n\n\t\t// Contents\n\t\t\"empty\": function( elem ) {\n\n\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tif ( elem.nodeType < 6 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\t\"parent\": function( elem ) {\n\t\t\treturn !Expr.pseudos[ \"empty\" ]( elem );\n\t\t},\n\n\t\t// Element/input types\n\t\t\"header\": function( elem ) {\n\t\t\treturn rheader.test( elem.nodeName );\n\t\t},\n\n\t\t\"input\": function( elem ) {\n\t\t\treturn rinputs.test( elem.nodeName );\n\t\t},\n\n\t\t\"button\": function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\n\t\t},\n\n\t\t\"text\": function( elem ) {\n\t\t\tvar attr;\n\t\t\treturn elem.nodeName.toLowerCase() === \"input\" &&\n\t\t\t\telem.type === \"text\" &&\n\n\t\t\t\t// Support: IE<8\n\t\t\t\t// New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n\t\t\t\t( ( attr = elem.getAttribute( \"type\" ) ) == null ||\n\t\t\t\t\tattr.toLowerCase() === \"text\" );\n\t\t},\n\n\t\t// Position-in-collection\n\t\t\"first\": createPositionalPseudo( function() {\n\t\t\treturn [ 0 ];\n\t\t} ),\n\n\t\t\"last\": createPositionalPseudo( function( _matchIndexes, length ) {\n\t\t\treturn [ length - 1 ];\n\t\t} ),\n\n\t\t\"eq\": createPositionalPseudo( function( _matchIndexes, length, argument ) {\n\t\t\treturn [ argument < 0 ? argument + length : argument ];\n\t\t} ),\n\n\t\t\"even\": createPositionalPseudo( function( matchIndexes, length ) {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t} ),\n\n\t\t\"odd\": createPositionalPseudo( function( matchIndexes, length ) {\n\t\t\tvar i = 1;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t} ),\n\n\t\t\"lt\": createPositionalPseudo( function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ?\n\t\t\t\targument + length :\n\t\t\t\targument > length ?\n\t\t\t\t\tlength :\n\t\t\t\t\targument;\n\t\t\tfor ( ; --i >= 0; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t} ),\n\n\t\t\"gt\": createPositionalPseudo( function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; ++i < length; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t} )\n\t}\n};\n\nExpr.pseudos[ \"nth\" ] = Expr.pseudos[ \"eq\" ];\n\n// Add button/input type pseudos\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n\tExpr.pseudos[ i ] = createInputPseudo( i );\n}\nfor ( i in { submit: true, reset: true } ) {\n\tExpr.pseudos[ i ] = createButtonPseudo( i );\n}\n\n// Easy API for creating new setFilters\nfunction setFilters() {}\nsetFilters.prototype = Expr.filters = Expr.pseudos;\nExpr.setFilters = new setFilters();\n\ntokenize = Sizzle.tokenize = function( selector, parseOnly ) {\n\tvar matched, match, tokens, type,\n\t\tsoFar, groups, preFilters,\n\t\tcached = tokenCache[ selector + \" \" ];\n\n\tif ( cached ) {\n\t\treturn parseOnly ? 0 : cached.slice( 0 );\n\t}\n\n\tsoFar = selector;\n\tgroups = [];\n\tpreFilters = Expr.preFilter;\n\n\twhile ( soFar ) {\n\n\t\t// Comma and first run\n\t\tif ( !matched || ( match = rcomma.exec( soFar ) ) ) {\n\t\t\tif ( match ) {\n\n\t\t\t\t// Don't consume trailing commas as valid\n\t\t\t\tsoFar = soFar.slice( match[ 0 ].length ) || soFar;\n\t\t\t}\n\t\t\tgroups.push( ( tokens = [] ) );\n\t\t}\n\n\t\tmatched = false;\n\n\t\t// Combinators\n\t\tif ( ( match = rcombinators.exec( soFar ) ) ) {\n\t\t\tmatched = match.shift();\n\t\t\ttokens.push( {\n\t\t\t\tvalue: matched,\n\n\t\t\t\t// Cast descendant combinators to space\n\t\t\t\ttype: match[ 0 ].replace( rtrim, \" \" )\n\t\t\t} );\n\t\t\tsoFar = soFar.slice( matched.length );\n\t\t}\n\n\t\t// Filters\n\t\tfor ( type in Expr.filter ) {\n\t\t\tif ( ( match = matchExpr[ type ].exec( soFar ) ) && ( !preFilters[ type ] ||\n\t\t\t\t( match = preFilters[ type ]( match ) ) ) ) {\n\t\t\t\tmatched = match.shift();\n\t\t\t\ttokens.push( {\n\t\t\t\t\tvalue: matched,\n\t\t\t\t\ttype: type,\n\t\t\t\t\tmatches: match\n\t\t\t\t} );\n\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t}\n\t\t}\n\n\t\tif ( !matched ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Return the length of the invalid excess\n\t// if we're just parsing\n\t// Otherwise, throw an error or return tokens\n\treturn parseOnly ?\n\t\tsoFar.length :\n\t\tsoFar ?\n\t\t\tSizzle.error( selector ) :\n\n\t\t\t// Cache the tokens\n\t\t\ttokenCache( selector, groups ).slice( 0 );\n};\n\nfunction toSelector( tokens ) {\n\tvar i = 0,\n\t\tlen = tokens.length,\n\t\tselector = \"\";\n\tfor ( ; i < len; i++ ) {\n\t\tselector += tokens[ i ].value;\n\t}\n\treturn selector;\n}\n\nfunction addCombinator( matcher, combinator, base ) {\n\tvar dir = combinator.dir,\n\t\tskip = combinator.next,\n\t\tkey = skip || dir,\n\t\tcheckNonElements = base && key === \"parentNode\",\n\t\tdoneName = done++;\n\n\treturn combinator.first ?\n\n\t\t// Check against closest ancestor/preceding element\n\t\tfunction( elem, context, xml ) {\n\t\t\twhile ( ( elem = elem[ dir ] ) ) {\n\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\treturn matcher( elem, context, xml );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t} :\n\n\t\t// Check against all ancestor/preceding elements\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar oldCache, uniqueCache, outerCache,\n\t\t\t\tnewCache = [ dirruns, doneName ];\n\n\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\n\t\t\tif ( xml ) {\n\t\t\t\twhile ( ( elem = elem[ dir ] ) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile ( ( elem = elem[ dir ] ) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\touterCache = elem[ expando ] || ( elem[ expando ] = {} );\n\n\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\tuniqueCache = outerCache[ elem.uniqueID ] ||\n\t\t\t\t\t\t\t( outerCache[ elem.uniqueID ] = {} );\n\n\t\t\t\t\t\tif ( skip && skip === elem.nodeName.toLowerCase() ) {\n\t\t\t\t\t\t\telem = elem[ dir ] || elem;\n\t\t\t\t\t\t} else if ( ( oldCache = uniqueCache[ key ] ) &&\n\t\t\t\t\t\t\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n\n\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n\t\t\t\t\t\t\treturn ( newCache[ 2 ] = oldCache[ 2 ] );\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n\t\t\t\t\t\t\tuniqueCache[ key ] = newCache;\n\n\t\t\t\t\t\t\t// A match means we're done; a fail means we have to keep checking\n\t\t\t\t\t\t\tif ( ( newCache[ 2 ] = matcher( elem, context, xml ) ) ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n}\n\nfunction elementMatcher( matchers ) {\n\treturn matchers.length > 1 ?\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar i = matchers.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( !matchers[ i ]( elem, context, xml ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} :\n\t\tmatchers[ 0 ];\n}\n\nfunction multipleContexts( selector, contexts, results ) {\n\tvar i = 0,\n\t\tlen = contexts.length;\n\tfor ( ; i < len; i++ ) {\n\t\tSizzle( selector, contexts[ i ], results );\n\t}\n\treturn results;\n}\n\nfunction condense( unmatched, map, filter, context, xml ) {\n\tvar elem,\n\t\tnewUnmatched = [],\n\t\ti = 0,\n\t\tlen = unmatched.length,\n\t\tmapped = map != null;\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( ( elem = unmatched[ i ] ) ) {\n\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n\t\t\t\tnewUnmatched.push( elem );\n\t\t\t\tif ( mapped ) {\n\t\t\t\t\tmap.push( i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newUnmatched;\n}\n\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n\tif ( postFilter && !postFilter[ expando ] ) {\n\t\tpostFilter = setMatcher( postFilter );\n\t}\n\tif ( postFinder && !postFinder[ expando ] ) {\n\t\tpostFinder = setMatcher( postFinder, postSelector );\n\t}\n\treturn markFunction( function( seed, results, context, xml ) {\n\t\tvar temp, i, elem,\n\t\t\tpreMap = [],\n\t\t\tpostMap = [],\n\t\t\tpreexisting = results.length,\n\n\t\t\t// Get initial elements from seed or context\n\t\t\telems = seed || multipleContexts(\n\t\t\t\tselector || \"*\",\n\t\t\t\tcontext.nodeType ? [ context ] : context,\n\t\t\t\t[]\n\t\t\t),\n\n\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n\t\t\t\telems,\n\n\t\t\tmatcherOut = matcher ?\n\n\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\n\t\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t\t[] :\n\n\t\t\t\t\t// ...otherwise use results directly\n\t\t\t\t\tresults :\n\t\t\t\tmatcherIn;\n\n\t\t// Find primary matches\n\t\tif ( matcher ) {\n\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n\t\t}\n\n\t\t// Apply postFilter\n\t\tif ( postFilter ) {\n\t\t\ttemp = condense( matcherOut, postMap );\n\t\t\tpostFilter( temp, [], context, xml );\n\n\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\ti = temp.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( ( elem = temp[ i ] ) ) {\n\t\t\t\t\tmatcherOut[ postMap[ i ] ] = !( matcherIn[ postMap[ i ] ] = elem );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( seed ) {\n\t\t\tif ( postFinder || preFilter ) {\n\t\t\t\tif ( postFinder ) {\n\n\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\ttemp = [];\n\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( ( elem = matcherOut[ i ] ) ) {\n\n\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\ttemp.push( ( matcherIn[ i ] = elem ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpostFinder( null, ( matcherOut = [] ), temp, xml );\n\t\t\t\t}\n\n\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\ti = matcherOut.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( ( elem = matcherOut[ i ] ) &&\n\t\t\t\t\t\t( temp = postFinder ? indexOf( seed, elem ) : preMap[ i ] ) > -1 ) {\n\n\t\t\t\t\t\tseed[ temp ] = !( results[ temp ] = elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Add elements to results, through postFinder if defined\n\t\t} else {\n\t\t\tmatcherOut = condense(\n\t\t\t\tmatcherOut === results ?\n\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n\t\t\t\t\tmatcherOut\n\t\t\t);\n\t\t\tif ( postFinder ) {\n\t\t\t\tpostFinder( null, results, matcherOut, xml );\n\t\t\t} else {\n\t\t\t\tpush.apply( results, matcherOut );\n\t\t\t}\n\t\t}\n\t} );\n}\n\nfunction matcherFromTokens( tokens ) {\n\tvar checkContext, matcher, j,\n\t\tlen = tokens.length,\n\t\tleadingRelative = Expr.relative[ tokens[ 0 ].type ],\n\t\timplicitRelative = leadingRelative || Expr.relative[ \" \" ],\n\t\ti = leadingRelative ? 1 : 0,\n\n\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\tmatchContext = addCombinator( function( elem ) {\n\t\t\treturn elem === checkContext;\n\t\t}, implicitRelative, true ),\n\t\tmatchAnyContext = addCombinator( function( elem ) {\n\t\t\treturn indexOf( checkContext, elem ) > -1;\n\t\t}, implicitRelative, true ),\n\t\tmatchers = [ function( elem, context, xml ) {\n\t\t\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n\t\t\t\t( checkContext = context ).nodeType ?\n\t\t\t\t\tmatchContext( elem, context, xml ) :\n\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n\n\t\t\t// Avoid hanging onto element (issue #299)\n\t\t\tcheckContext = null;\n\t\t\treturn ret;\n\t\t} ];\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( ( matcher = Expr.relative[ tokens[ i ].type ] ) ) {\n\t\t\tmatchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];\n\t\t} else {\n\t\t\tmatcher = Expr.filter[ tokens[ i ].type ].apply( null, tokens[ i ].matches );\n\n\t\t\t// Return special upon seeing a positional matcher\n\t\t\tif ( matcher[ expando ] ) {\n\n\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\tj = ++i;\n\t\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\t\tif ( Expr.relative[ tokens[ j ].type ] ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn setMatcher(\n\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n\t\t\t\t\ti > 1 && toSelector(\n\n\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\ttokens\n\t\t\t\t\t\t.slice( 0, i - 1 )\n\t\t\t\t\t\t.concat( { value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" } )\n\t\t\t\t\t).replace( rtrim, \"$1\" ),\n\t\t\t\t\tmatcher,\n\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n\t\t\t\t\tj < len && matcherFromTokens( ( tokens = tokens.slice( j ) ) ),\n\t\t\t\t\tj < len && toSelector( tokens )\n\t\t\t\t);\n\t\t\t}\n\t\t\tmatchers.push( matcher );\n\t\t}\n\t}\n\n\treturn elementMatcher( matchers );\n}\n\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n\tvar bySet = setMatchers.length > 0,\n\t\tbyElement = elementMatchers.length > 0,\n\t\tsuperMatcher = function( seed, context, xml, results, outermost ) {\n\t\t\tvar elem, j, matcher,\n\t\t\t\tmatchedCount = 0,\n\t\t\t\ti = \"0\",\n\t\t\t\tunmatched = seed && [],\n\t\t\t\tsetMatched = [],\n\t\t\t\tcontextBackup = outermostContext,\n\n\t\t\t\t// We must always have either seed elements or outermost context\n\t\t\t\telems = seed || byElement && Expr.find[ \"TAG\" ]( \"*\", outermost ),\n\n\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\tdirrunsUnique = ( dirruns += contextBackup == null ? 1 : Math.random() || 0.1 ),\n\t\t\t\tlen = elems.length;\n\n\t\t\tif ( outermost ) {\n\n\t\t\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t\t\t// two documents; shallow comparisons work.\n\t\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\t\toutermostContext = context == document || context || outermost;\n\t\t\t}\n\n\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t// Support: IE<9, Safari\n\t\t\t// Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\t\t\tfor ( ; i !== len && ( elem = elems[ i ] ) != null; i++ ) {\n\t\t\t\tif ( byElement && elem ) {\n\t\t\t\t\tj = 0;\n\n\t\t\t\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t\t\t\t// two documents; shallow comparisons work.\n\t\t\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\t\t\tif ( !context && elem.ownerDocument != document ) {\n\t\t\t\t\t\tsetDocument( elem );\n\t\t\t\t\t\txml = !documentIsHTML;\n\t\t\t\t\t}\n\t\t\t\t\twhile ( ( matcher = elementMatchers[ j++ ] ) ) {\n\t\t\t\t\t\tif ( matcher( elem, context || document, xml ) ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( outermost ) {\n\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\tif ( bySet ) {\n\n\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\tif ( ( elem = !matcher && elem ) ) {\n\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\tunmatched.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// `i` is now the count of elements visited above, and adding it to `matchedCount`\n\t\t\t// makes the latter nonnegative.\n\t\t\tmatchedCount += i;\n\n\t\t\t// Apply set filters to unmatched elements\n\t\t\t// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n\t\t\t// equals `i`), unless we didn't visit _any_ elements in the above loop because we have\n\t\t\t// no element matchers and no seed.\n\t\t\t// Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\n\t\t\t// case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\n\t\t\t// numerically zero.\n\t\t\tif ( bySet && i !== matchedCount ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( ( matcher = setMatchers[ j++ ] ) ) {\n\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n\t\t\t\t}\n\n\t\t\t\tif ( seed ) {\n\n\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\tif ( matchedCount > 0 ) {\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( !( unmatched[ i ] || setMatched[ i ] ) ) {\n\t\t\t\t\t\t\t\tsetMatched[ i ] = pop.call( results );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\tsetMatched = condense( setMatched );\n\t\t\t\t}\n\n\t\t\t\t// Add matches to results\n\t\t\t\tpush.apply( results, setMatched );\n\n\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n\n\t\t\t\t\tSizzle.uniqueSort( results );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Override manipulation of globals by nested matchers\n\t\t\tif ( outermost ) {\n\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\toutermostContext = contextBackup;\n\t\t\t}\n\n\t\t\treturn unmatched;\n\t\t};\n\n\treturn bySet ?\n\t\tmarkFunction( superMatcher ) :\n\t\tsuperMatcher;\n}\n\ncompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\n\tvar i,\n\t\tsetMatchers = [],\n\t\telementMatchers = [],\n\t\tcached = compilerCache[ selector + \" \" ];\n\n\tif ( !cached ) {\n\n\t\t// Generate a function of recursive functions that can be used to check each element\n\t\tif ( !match ) {\n\t\t\tmatch = tokenize( selector );\n\t\t}\n\t\ti = match.length;\n\t\twhile ( i-- ) {\n\t\t\tcached = matcherFromTokens( match[ i ] );\n\t\t\tif ( cached[ expando ] ) {\n\t\t\t\tsetMatchers.push( cached );\n\t\t\t} else {\n\t\t\t\telementMatchers.push( cached );\n\t\t\t}\n\t\t}\n\n\t\t// Cache the compiled function\n\t\tcached = compilerCache(\n\t\t\tselector,\n\t\t\tmatcherFromGroupMatchers( elementMatchers, setMatchers )\n\t\t);\n\n\t\t// Save selector and tokenization\n\t\tcached.selector = selector;\n\t}\n\treturn cached;\n};\n\n/**\n * A low-level selection function that works with Sizzle's compiled\n *  selector functions\n * @param {String|Function} selector A selector or a pre-compiled\n *  selector function built with Sizzle.compile\n * @param {Element} context\n * @param {Array} [results]\n * @param {Array} [seed] A set of elements to match against\n */\nselect = Sizzle.select = function( selector, context, results, seed ) {\n\tvar i, tokens, token, type, find,\n\t\tcompiled = typeof selector === \"function\" && selector,\n\t\tmatch = !seed && tokenize( ( selector = compiled.selector || selector ) );\n\n\tresults = results || [];\n\n\t// Try to minimize operations if there is only one selector in the list and no seed\n\t// (the latter of which guarantees us context)\n\tif ( match.length === 1 ) {\n\n\t\t// Reduce context if the leading compound selector is an ID\n\t\ttokens = match[ 0 ] = match[ 0 ].slice( 0 );\n\t\tif ( tokens.length > 2 && ( token = tokens[ 0 ] ).type === \"ID\" &&\n\t\t\tcontext.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[ 1 ].type ] ) {\n\n\t\t\tcontext = ( Expr.find[ \"ID\" ]( token.matches[ 0 ]\n\t\t\t\t.replace( runescape, funescape ), context ) || [] )[ 0 ];\n\t\t\tif ( !context ) {\n\t\t\t\treturn results;\n\n\t\t\t// Precompiled matchers will still verify ancestry, so step up a level\n\t\t\t} else if ( compiled ) {\n\t\t\t\tcontext = context.parentNode;\n\t\t\t}\n\n\t\t\tselector = selector.slice( tokens.shift().value.length );\n\t\t}\n\n\t\t// Fetch a seed set for right-to-left matching\n\t\ti = matchExpr[ \"needsContext\" ].test( selector ) ? 0 : tokens.length;\n\t\twhile ( i-- ) {\n\t\t\ttoken = tokens[ i ];\n\n\t\t\t// Abort if we hit a combinator\n\t\t\tif ( Expr.relative[ ( type = token.type ) ] ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( ( find = Expr.find[ type ] ) ) {\n\n\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\tif ( ( seed = find(\n\t\t\t\t\ttoken.matches[ 0 ].replace( runescape, funescape ),\n\t\t\t\t\trsibling.test( tokens[ 0 ].type ) && testContext( context.parentNode ) ||\n\t\t\t\t\t\tcontext\n\t\t\t\t) ) ) {\n\n\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\ttokens.splice( i, 1 );\n\t\t\t\t\tselector = seed.length && toSelector( tokens );\n\t\t\t\t\tif ( !selector ) {\n\t\t\t\t\t\tpush.apply( results, seed );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Compile and execute a filtering function if one is not provided\n\t// Provide `match` to avoid retokenization if we modified the selector above\n\t( compiled || compile( selector, match ) )(\n\t\tseed,\n\t\tcontext,\n\t\t!documentIsHTML,\n\t\tresults,\n\t\t!context || rsibling.test( selector ) && testContext( context.parentNode ) || context\n\t);\n\treturn results;\n};\n\n// One-time assignments\n\n// Sort stability\nsupport.sortStable = expando.split( \"\" ).sort( sortOrder ).join( \"\" ) === expando;\n\n// Support: Chrome 14-35+\n// Always assume duplicates if they aren't passed to the comparison function\nsupport.detectDuplicates = !!hasDuplicate;\n\n// Initialize against the default document\nsetDocument();\n\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n// Detached nodes confoundingly follow *each other*\nsupport.sortDetached = assert( function( el ) {\n\n\t// Should return 1, but returns 4 (following)\n\treturn el.compareDocumentPosition( document.createElement( \"fieldset\" ) ) & 1;\n} );\n\n// Support: IE<8\n// Prevent attribute/property \"interpolation\"\n// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\nif ( !assert( function( el ) {\n\tel.innerHTML = \"<a href='#'></a>\";\n\treturn el.firstChild.getAttribute( \"href\" ) === \"#\";\n} ) ) {\n\taddHandle( \"type|href|height|width\", function( elem, name, isXML ) {\n\t\tif ( !isXML ) {\n\t\t\treturn elem.getAttribute( name, name.toLowerCase() === \"type\" ? 1 : 2 );\n\t\t}\n\t} );\n}\n\n// Support: IE<9\n// Use defaultValue in place of getAttribute(\"value\")\nif ( !support.attributes || !assert( function( el ) {\n\tel.innerHTML = \"<input/>\";\n\tel.firstChild.setAttribute( \"value\", \"\" );\n\treturn el.firstChild.getAttribute( \"value\" ) === \"\";\n} ) ) {\n\taddHandle( \"value\", function( elem, _name, isXML ) {\n\t\tif ( !isXML && elem.nodeName.toLowerCase() === \"input\" ) {\n\t\t\treturn elem.defaultValue;\n\t\t}\n\t} );\n}\n\n// Support: IE<9\n// Use getAttributeNode to fetch booleans when getAttribute lies\nif ( !assert( function( el ) {\n\treturn el.getAttribute( \"disabled\" ) == null;\n} ) ) {\n\taddHandle( booleans, function( elem, name, isXML ) {\n\t\tvar val;\n\t\tif ( !isXML ) {\n\t\t\treturn elem[ name ] === true ? name.toLowerCase() :\n\t\t\t\t( val = elem.getAttributeNode( name ) ) && val.specified ?\n\t\t\t\t\tval.value :\n\t\t\t\t\tnull;\n\t\t}\n\t} );\n}\n\nreturn Sizzle;\n\n} )( window );\n\n\n\njQuery.find = Sizzle;\njQuery.expr = Sizzle.selectors;\n\n// Deprecated\njQuery.expr[ \":\" ] = jQuery.expr.pseudos;\njQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;\njQuery.text = Sizzle.getText;\njQuery.isXMLDoc = Sizzle.isXML;\njQuery.contains = Sizzle.contains;\njQuery.escapeSelector = Sizzle.escape;\n\n\n\n\nvar dir = function( elem, dir, until ) {\n\tvar matched = [],\n\t\ttruncate = until !== undefined;\n\n\twhile ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {\n\t\tif ( elem.nodeType === 1 ) {\n\t\t\tif ( truncate && jQuery( elem ).is( until ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmatched.push( elem );\n\t\t}\n\t}\n\treturn matched;\n};\n\n\nvar siblings = function( n, elem ) {\n\tvar matched = [];\n\n\tfor ( ; n; n = n.nextSibling ) {\n\t\tif ( n.nodeType === 1 && n !== elem ) {\n\t\t\tmatched.push( n );\n\t\t}\n\t}\n\n\treturn matched;\n};\n\n\nvar rneedsContext = jQuery.expr.match.needsContext;\n\n\n\nfunction nodeName( elem, name ) {\n\n\treturn elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n\n}\nvar rsingleTag = ( /^<([a-z][^\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\/?>(?:<\\/\\1>|)$/i );\n\n\n\n// Implement the identical functionality for filter and not\nfunction winnow( elements, qualifier, not ) {\n\tif ( isFunction( qualifier ) ) {\n\t\treturn jQuery.grep( elements, function( elem, i ) {\n\t\t\treturn !!qualifier.call( elem, i, elem ) !== not;\n\t\t} );\n\t}\n\n\t// Single element\n\tif ( qualifier.nodeType ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( elem === qualifier ) !== not;\n\t\t} );\n\t}\n\n\t// Arraylike of elements (jQuery, arguments, Array)\n\tif ( typeof qualifier !== \"string\" ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not;\n\t\t} );\n\t}\n\n\t// Filtered directly for both simple and complex selectors\n\treturn jQuery.filter( qualifier, elements, not );\n}\n\njQuery.filter = function( expr, elems, not ) {\n\tvar elem = elems[ 0 ];\n\n\tif ( not ) {\n\t\texpr = \":not(\" + expr + \")\";\n\t}\n\n\tif ( elems.length === 1 && elem.nodeType === 1 ) {\n\t\treturn jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];\n\t}\n\n\treturn jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\n\t\treturn elem.nodeType === 1;\n\t} ) );\n};\n\njQuery.fn.extend( {\n\tfind: function( selector ) {\n\t\tvar i, ret,\n\t\t\tlen = this.length,\n\t\t\tself = this;\n\n\t\tif ( typeof selector !== \"string\" ) {\n\t\t\treturn this.pushStack( jQuery( selector ).filter( function() {\n\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} ) );\n\t\t}\n\n\t\tret = this.pushStack( [] );\n\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tjQuery.find( selector, self[ i ], ret );\n\t\t}\n\n\t\treturn len > 1 ? jQuery.uniqueSort( ret ) : ret;\n\t},\n\tfilter: function( selector ) {\n\t\treturn this.pushStack( winnow( this, selector || [], false ) );\n\t},\n\tnot: function( selector ) {\n\t\treturn this.pushStack( winnow( this, selector || [], true ) );\n\t},\n\tis: function( selector ) {\n\t\treturn !!winnow(\n\t\t\tthis,\n\n\t\t\t// If this is a positional/relative selector, check membership in the returned set\n\t\t\t// so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n\t\t\ttypeof selector === \"string\" && rneedsContext.test( selector ) ?\n\t\t\t\tjQuery( selector ) :\n\t\t\t\tselector || [],\n\t\t\tfalse\n\t\t).length;\n\t}\n} );\n\n\n// Initialize a jQuery object\n\n\n// A central reference to the root jQuery(document)\nvar rootjQuery,\n\n\t// A simple way to check for HTML strings\n\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n\t// Strict HTML recognition (#11290: must start with <)\n\t// Shortcut simple #id case for speed\n\trquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/,\n\n\tinit = jQuery.fn.init = function( selector, context, root ) {\n\t\tvar match, elem;\n\n\t\t// HANDLE: $(\"\"), $(null), $(undefined), $(false)\n\t\tif ( !selector ) {\n\t\t\treturn this;\n\t\t}\n\n\t\t// Method init() accepts an alternate rootjQuery\n\t\t// so migrate can support jQuery.sub (gh-2101)\n\t\troot = root || rootjQuery;\n\n\t\t// Handle HTML strings\n\t\tif ( typeof selector === \"string\" ) {\n\t\t\tif ( selector[ 0 ] === \"<\" &&\n\t\t\t\tselector[ selector.length - 1 ] === \">\" &&\n\t\t\t\tselector.length >= 3 ) {\n\n\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\n\t\t\t\tmatch = [ null, selector, null ];\n\n\t\t\t} else {\n\t\t\t\tmatch = rquickExpr.exec( selector );\n\t\t\t}\n\n\t\t\t// Match html or make sure no context is specified for #id\n\t\t\tif ( match && ( match[ 1 ] || !context ) ) {\n\n\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\tif ( match[ 1 ] ) {\n\t\t\t\t\tcontext = context instanceof jQuery ? context[ 0 ] : context;\n\n\t\t\t\t\t// Option to run scripts is true for back-compat\n\t\t\t\t\t// Intentionally let the error be thrown if parseHTML is not present\n\t\t\t\t\tjQuery.merge( this, jQuery.parseHTML(\n\t\t\t\t\t\tmatch[ 1 ],\n\t\t\t\t\t\tcontext && context.nodeType ? context.ownerDocument || context : document,\n\t\t\t\t\t\ttrue\n\t\t\t\t\t) );\n\n\t\t\t\t\t// HANDLE: $(html, props)\n\t\t\t\t\tif ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {\n\t\t\t\t\t\tfor ( match in context ) {\n\n\t\t\t\t\t\t\t// Properties of context are called as methods if possible\n\t\t\t\t\t\t\tif ( isFunction( this[ match ] ) ) {\n\t\t\t\t\t\t\t\tthis[ match ]( context[ match ] );\n\n\t\t\t\t\t\t\t// ...and otherwise set as attributes\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.attr( match, context[ match ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t// HANDLE: $(#id)\n\t\t\t\t} else {\n\t\t\t\t\telem = document.getElementById( match[ 2 ] );\n\n\t\t\t\t\tif ( elem ) {\n\n\t\t\t\t\t\t// Inject the element directly into the jQuery object\n\t\t\t\t\t\tthis[ 0 ] = elem;\n\t\t\t\t\t\tthis.length = 1;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t// HANDLE: $(expr, $(...))\n\t\t\t} else if ( !context || context.jquery ) {\n\t\t\t\treturn ( context || root ).find( selector );\n\n\t\t\t// HANDLE: $(expr, context)\n\t\t\t// (which is just equivalent to: $(context).find(expr)\n\t\t\t} else {\n\t\t\t\treturn this.constructor( context ).find( selector );\n\t\t\t}\n\n\t\t// HANDLE: $(DOMElement)\n\t\t} else if ( selector.nodeType ) {\n\t\t\tthis[ 0 ] = selector;\n\t\t\tthis.length = 1;\n\t\t\treturn this;\n\n\t\t// HANDLE: $(function)\n\t\t// Shortcut for document ready\n\t\t} else if ( isFunction( selector ) ) {\n\t\t\treturn root.ready !== undefined ?\n\t\t\t\troot.ready( selector ) :\n\n\t\t\t\t// Execute immediately if ready is not present\n\t\t\t\tselector( jQuery );\n\t\t}\n\n\t\treturn jQuery.makeArray( selector, this );\n\t};\n\n// Give the init function the jQuery prototype for later instantiation\ninit.prototype = jQuery.fn;\n\n// Initialize central reference\nrootjQuery = jQuery( document );\n\n\nvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\n\n\t// Methods guaranteed to produce a unique set when starting from a unique set\n\tguaranteedUnique = {\n\t\tchildren: true,\n\t\tcontents: true,\n\t\tnext: true,\n\t\tprev: true\n\t};\n\njQuery.fn.extend( {\n\thas: function( target ) {\n\t\tvar targets = jQuery( target, this ),\n\t\t\tl = targets.length;\n\n\t\treturn this.filter( function() {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tif ( jQuery.contains( this, targets[ i ] ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t},\n\n\tclosest: function( selectors, context ) {\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\tl = this.length,\n\t\t\tmatched = [],\n\t\t\ttargets = typeof selectors !== \"string\" && jQuery( selectors );\n\n\t\t// Positional selectors never match, since there's no _selection_ context\n\t\tif ( !rneedsContext.test( selectors ) ) {\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tfor ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {\n\n\t\t\t\t\t// Always skip document fragments\n\t\t\t\t\tif ( cur.nodeType < 11 && ( targets ?\n\t\t\t\t\t\ttargets.index( cur ) > -1 :\n\n\t\t\t\t\t\t// Don't pass non-elements to Sizzle\n\t\t\t\t\t\tcur.nodeType === 1 &&\n\t\t\t\t\t\t\tjQuery.find.matchesSelector( cur, selectors ) ) ) {\n\n\t\t\t\t\t\tmatched.push( cur );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );\n\t},\n\n\t// Determine the position of an element within the set\n\tindex: function( elem ) {\n\n\t\t// No argument, return index in parent\n\t\tif ( !elem ) {\n\t\t\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\n\t\t}\n\n\t\t// Index in selector\n\t\tif ( typeof elem === \"string\" ) {\n\t\t\treturn indexOf.call( jQuery( elem ), this[ 0 ] );\n\t\t}\n\n\t\t// Locate the position of the desired element\n\t\treturn indexOf.call( this,\n\n\t\t\t// If it receives a jQuery object, the first element is used\n\t\t\telem.jquery ? elem[ 0 ] : elem\n\t\t);\n\t},\n\n\tadd: function( selector, context ) {\n\t\treturn this.pushStack(\n\t\t\tjQuery.uniqueSort(\n\t\t\t\tjQuery.merge( this.get(), jQuery( selector, context ) )\n\t\t\t)\n\t\t);\n\t},\n\n\taddBack: function( selector ) {\n\t\treturn this.add( selector == null ?\n\t\t\tthis.prevObject : this.prevObject.filter( selector )\n\t\t);\n\t}\n} );\n\nfunction sibling( cur, dir ) {\n\twhile ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}\n\treturn cur;\n}\n\njQuery.each( {\n\tparent: function( elem ) {\n\t\tvar parent = elem.parentNode;\n\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n\t},\n\tparents: function( elem ) {\n\t\treturn dir( elem, \"parentNode\" );\n\t},\n\tparentsUntil: function( elem, _i, until ) {\n\t\treturn dir( elem, \"parentNode\", until );\n\t},\n\tnext: function( elem ) {\n\t\treturn sibling( elem, \"nextSibling\" );\n\t},\n\tprev: function( elem ) {\n\t\treturn sibling( elem, \"previousSibling\" );\n\t},\n\tnextAll: function( elem ) {\n\t\treturn dir( elem, \"nextSibling\" );\n\t},\n\tprevAll: function( elem ) {\n\t\treturn dir( elem, \"previousSibling\" );\n\t},\n\tnextUntil: function( elem, _i, until ) {\n\t\treturn dir( elem, \"nextSibling\", until );\n\t},\n\tprevUntil: function( elem, _i, until ) {\n\t\treturn dir( elem, \"previousSibling\", until );\n\t},\n\tsiblings: function( elem ) {\n\t\treturn siblings( ( elem.parentNode || {} ).firstChild, elem );\n\t},\n\tchildren: function( elem ) {\n\t\treturn siblings( elem.firstChild );\n\t},\n\tcontents: function( elem ) {\n\t\tif ( elem.contentDocument != null &&\n\n\t\t\t// Support: IE 11+\n\t\t\t// <object> elements with no `data` attribute has an object\n\t\t\t// `contentDocument` with a `null` prototype.\n\t\t\tgetProto( elem.contentDocument ) ) {\n\n\t\t\treturn elem.contentDocument;\n\t\t}\n\n\t\t// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only\n\t\t// Treat the template element as a regular one in browsers that\n\t\t// don't support it.\n\t\tif ( nodeName( elem, \"template\" ) ) {\n\t\t\telem = elem.content || elem;\n\t\t}\n\n\t\treturn jQuery.merge( [], elem.childNodes );\n\t}\n}, function( name, fn ) {\n\tjQuery.fn[ name ] = function( until, selector ) {\n\t\tvar matched = jQuery.map( this, fn, until );\n\n\t\tif ( name.slice( -5 ) !== \"Until\" ) {\n\t\t\tselector = until;\n\t\t}\n\n\t\tif ( selector && typeof selector === \"string\" ) {\n\t\t\tmatched = jQuery.filter( selector, matched );\n\t\t}\n\n\t\tif ( this.length > 1 ) {\n\n\t\t\t// Remove duplicates\n\t\t\tif ( !guaranteedUnique[ name ] ) {\n\t\t\t\tjQuery.uniqueSort( matched );\n\t\t\t}\n\n\t\t\t// Reverse order for parents* and prev-derivatives\n\t\t\tif ( rparentsprev.test( name ) ) {\n\t\t\t\tmatched.reverse();\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched );\n\t};\n} );\nvar rnothtmlwhite = ( /[^\\x20\\t\\r\\n\\f]+/g );\n\n\n\n// Convert String-formatted options into Object-formatted ones\nfunction createOptions( options ) {\n\tvar object = {};\n\tjQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {\n\t\tobject[ flag ] = true;\n\t} );\n\treturn object;\n}\n\n/*\n * Create a callback list using the following parameters:\n *\n *\toptions: an optional list of space-separated options that will change how\n *\t\t\tthe callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * \"fired\" multiple times.\n *\n * Possible options:\n *\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n *\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n *\t\t\t\t\tvalues (like a Deferred)\n *\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n *\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\n *\n */\njQuery.Callbacks = function( options ) {\n\n\t// Convert options from String-formatted to Object-formatted if needed\n\t// (we check in cache first)\n\toptions = typeof options === \"string\" ?\n\t\tcreateOptions( options ) :\n\t\tjQuery.extend( {}, options );\n\n\tvar // Flag to know if list is currently firing\n\t\tfiring,\n\n\t\t// Last fire value for non-forgettable lists\n\t\tmemory,\n\n\t\t// Flag to know if list was already fired\n\t\tfired,\n\n\t\t// Flag to prevent firing\n\t\tlocked,\n\n\t\t// Actual callback list\n\t\tlist = [],\n\n\t\t// Queue of execution data for repeatable lists\n\t\tqueue = [],\n\n\t\t// Index of currently firing callback (modified by add/remove as needed)\n\t\tfiringIndex = -1,\n\n\t\t// Fire callbacks\n\t\tfire = function() {\n\n\t\t\t// Enforce single-firing\n\t\t\tlocked = locked || options.once;\n\n\t\t\t// Execute callbacks for all pending executions,\n\t\t\t// respecting firingIndex overrides and runtime changes\n\t\t\tfired = firing = true;\n\t\t\tfor ( ; queue.length; firingIndex = -1 ) {\n\t\t\t\tmemory = queue.shift();\n\t\t\t\twhile ( ++firingIndex < list.length ) {\n\n\t\t\t\t\t// Run callback and check for early termination\n\t\t\t\t\tif ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&\n\t\t\t\t\t\toptions.stopOnFalse ) {\n\n\t\t\t\t\t\t// Jump to end and forget the data so .add doesn't re-fire\n\t\t\t\t\t\tfiringIndex = list.length;\n\t\t\t\t\t\tmemory = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Forget the data if we're done with it\n\t\t\tif ( !options.memory ) {\n\t\t\t\tmemory = false;\n\t\t\t}\n\n\t\t\tfiring = false;\n\n\t\t\t// Clean up if we're done firing for good\n\t\t\tif ( locked ) {\n\n\t\t\t\t// Keep an empty list if we have data for future add calls\n\t\t\t\tif ( memory ) {\n\t\t\t\t\tlist = [];\n\n\t\t\t\t// Otherwise, this object is spent\n\t\t\t\t} else {\n\t\t\t\t\tlist = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Actual Callbacks object\n\t\tself = {\n\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function() {\n\t\t\t\tif ( list ) {\n\n\t\t\t\t\t// If we have memory from a past run, we should fire after adding\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfiringIndex = list.length - 1;\n\t\t\t\t\t\tqueue.push( memory );\n\t\t\t\t\t}\n\n\t\t\t\t\t( function add( args ) {\n\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\tif ( isFunction( arg ) ) {\n\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\t\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if ( arg && arg.length && toType( arg ) !== \"string\" ) {\n\n\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\t\t\t\t\t} )( arguments );\n\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function() {\n\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\tvar index;\n\t\t\t\t\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\tlist.splice( index, 1 );\n\n\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Check if a given callback is in the list.\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\thas: function( fn ) {\n\t\t\t\treturn fn ?\n\t\t\t\t\tjQuery.inArray( fn, list ) > -1 :\n\t\t\t\t\tlist.length > 0;\n\t\t\t},\n\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\tlist = [];\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Disable .fire and .add\n\t\t\t// Abort any current/pending executions\n\t\t\t// Clear all callbacks and values\n\t\t\tdisable: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tlist = memory = \"\";\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tdisabled: function() {\n\t\t\t\treturn !list;\n\t\t\t},\n\n\t\t\t// Disable .fire\n\t\t\t// Also disable .add unless we have memory (since it would have no effect)\n\t\t\t// Abort any pending executions\n\t\t\tlock: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tif ( !memory && !firing ) {\n\t\t\t\t\tlist = memory = \"\";\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tlocked: function() {\n\t\t\t\treturn !!locked;\n\t\t\t},\n\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function( context, args ) {\n\t\t\t\tif ( !locked ) {\n\t\t\t\t\targs = args || [];\n\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\t\tqueue.push( args );\n\t\t\t\t\tif ( !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function() {\n\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function() {\n\t\t\t\treturn !!fired;\n\t\t\t}\n\t\t};\n\n\treturn self;\n};\n\n\nfunction Identity( v ) {\n\treturn v;\n}\nfunction Thrower( ex ) {\n\tthrow ex;\n}\n\nfunction adoptValue( value, resolve, reject, noValue ) {\n\tvar method;\n\n\ttry {\n\n\t\t// Check for promise aspect first to privilege synchronous behavior\n\t\tif ( value && isFunction( ( method = value.promise ) ) ) {\n\t\t\tmethod.call( value ).done( resolve ).fail( reject );\n\n\t\t// Other thenables\n\t\t} else if ( value && isFunction( ( method = value.then ) ) ) {\n\t\t\tmethod.call( value, resolve, reject );\n\n\t\t// Other non-thenables\n\t\t} else {\n\n\t\t\t// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:\n\t\t\t// * false: [ value ].slice( 0 ) => resolve( value )\n\t\t\t// * true: [ value ].slice( 1 ) => resolve()\n\t\t\tresolve.apply( undefined, [ value ].slice( noValue ) );\n\t\t}\n\n\t// For Promises/A+, convert exceptions into rejections\n\t// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in\n\t// Deferred#then to conditionally suppress rejection.\n\t} catch ( value ) {\n\n\t\t// Support: Android 4.0 only\n\t\t// Strict mode functions invoked without .call/.apply get global-object context\n\t\treject.apply( undefined, [ value ] );\n\t}\n}\n\njQuery.extend( {\n\n\tDeferred: function( func ) {\n\t\tvar tuples = [\n\n\t\t\t\t// action, add listener, callbacks,\n\t\t\t\t// ... .then handlers, argument index, [final state]\n\t\t\t\t[ \"notify\", \"progress\", jQuery.Callbacks( \"memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"memory\" ), 2 ],\n\t\t\t\t[ \"resolve\", \"done\", jQuery.Callbacks( \"once memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 0, \"resolved\" ],\n\t\t\t\t[ \"reject\", \"fail\", jQuery.Callbacks( \"once memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 1, \"rejected\" ]\n\t\t\t],\n\t\t\tstate = \"pending\",\n\t\t\tpromise = {\n\t\t\t\tstate: function() {\n\t\t\t\t\treturn state;\n\t\t\t\t},\n\t\t\t\talways: function() {\n\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\t\"catch\": function( fn ) {\n\t\t\t\t\treturn promise.then( null, fn );\n\t\t\t\t},\n\n\t\t\t\t// Keep pipe for back-compat\n\t\t\t\tpipe: function( /* fnDone, fnFail, fnProgress */ ) {\n\t\t\t\t\tvar fns = arguments;\n\n\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\t\t\t\t\t\tjQuery.each( tuples, function( _i, tuple ) {\n\n\t\t\t\t\t\t\t// Map tuples (progress, done, fail) to arguments (done, fail, progress)\n\t\t\t\t\t\t\tvar fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];\n\n\t\t\t\t\t\t\t// deferred.progress(function() { bind to newDefer or newDefer.notify })\n\t\t\t\t\t\t\t// deferred.done(function() { bind to newDefer or newDefer.resolve })\n\t\t\t\t\t\t\t// deferred.fail(function() { bind to newDefer or newDefer.reject })\n\t\t\t\t\t\t\tdeferred[ tuple[ 1 ] ]( function() {\n\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\n\t\t\t\t\t\t\t\tif ( returned && isFunction( returned.promise ) ) {\n\t\t\t\t\t\t\t\t\treturned.promise()\n\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify )\n\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnewDefer[ tuple[ 0 ] + \"With\" ](\n\t\t\t\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t\t\t\tfn ? [ returned ] : arguments\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tfns = null;\n\t\t\t\t\t} ).promise();\n\t\t\t\t},\n\t\t\t\tthen: function( onFulfilled, onRejected, onProgress ) {\n\t\t\t\t\tvar maxDepth = 0;\n\t\t\t\t\tfunction resolve( depth, deferred, handler, special ) {\n\t\t\t\t\t\treturn function() {\n\t\t\t\t\t\t\tvar that = this,\n\t\t\t\t\t\t\t\targs = arguments,\n\t\t\t\t\t\t\t\tmightThrow = function() {\n\t\t\t\t\t\t\t\t\tvar returned, then;\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.3\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-59\n\t\t\t\t\t\t\t\t\t// Ignore double-resolution attempts\n\t\t\t\t\t\t\t\t\tif ( depth < maxDepth ) {\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturned = handler.apply( that, args );\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.1\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-48\n\t\t\t\t\t\t\t\t\tif ( returned === deferred.promise() ) {\n\t\t\t\t\t\t\t\t\t\tthrow new TypeError( \"Thenable self-resolution\" );\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ sections 2.3.3.1, 3.5\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-54\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-75\n\t\t\t\t\t\t\t\t\t// Retrieve `then` only once\n\t\t\t\t\t\t\t\t\tthen = returned &&\n\n\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.4\n\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-64\n\t\t\t\t\t\t\t\t\t\t// Only check objects and functions for thenability\n\t\t\t\t\t\t\t\t\t\t( typeof returned === \"object\" ||\n\t\t\t\t\t\t\t\t\t\t\ttypeof returned === \"function\" ) &&\n\t\t\t\t\t\t\t\t\t\treturned.then;\n\n\t\t\t\t\t\t\t\t\t// Handle a returned thenable\n\t\t\t\t\t\t\t\t\tif ( isFunction( then ) ) {\n\n\t\t\t\t\t\t\t\t\t\t// Special processors (notify) just wait for resolution\n\t\t\t\t\t\t\t\t\t\tif ( special ) {\n\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special )\n\t\t\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\t\t// Normal processors (resolve) also hook into progress\n\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t// ...and disregard older resolution values\n\t\t\t\t\t\t\t\t\t\t\tmaxDepth++;\n\n\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity,\n\t\t\t\t\t\t\t\t\t\t\t\t\tdeferred.notifyWith )\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Handle all other returned values\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\tif ( handler !== Identity ) {\n\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\targs = [ returned ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// Process the value(s)\n\t\t\t\t\t\t\t\t\t\t// Default process is resolve\n\t\t\t\t\t\t\t\t\t\t( special || deferred.resolveWith )( that, args );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t// Only normal processors (resolve) catch and reject exceptions\n\t\t\t\t\t\t\t\tprocess = special ?\n\t\t\t\t\t\t\t\t\tmightThrow :\n\t\t\t\t\t\t\t\t\tfunction() {\n\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\tmightThrow();\n\t\t\t\t\t\t\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t\t\t\t\t\t\tif ( jQuery.Deferred.exceptionHook ) {\n\t\t\t\t\t\t\t\t\t\t\t\tjQuery.Deferred.exceptionHook( e,\n\t\t\t\t\t\t\t\t\t\t\t\t\tprocess.stackTrace );\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.4.1\n\t\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-61\n\t\t\t\t\t\t\t\t\t\t\t// Ignore post-resolution exceptions\n\t\t\t\t\t\t\t\t\t\t\tif ( depth + 1 >= maxDepth ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\t\t\tif ( handler !== Thrower ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\t\t\targs = [ e ];\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tdeferred.rejectWith( that, args );\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.1\n\t\t\t\t\t\t\t// https://promisesaplus.com/#point-57\n\t\t\t\t\t\t\t// Re-resolve promises immediately to dodge false rejection from\n\t\t\t\t\t\t\t// subsequent errors\n\t\t\t\t\t\t\tif ( depth ) {\n\t\t\t\t\t\t\t\tprocess();\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// Call an optional hook to record the stack, in case of exception\n\t\t\t\t\t\t\t\t// since it's otherwise lost when execution goes async\n\t\t\t\t\t\t\t\tif ( jQuery.Deferred.getStackHook ) {\n\t\t\t\t\t\t\t\t\tprocess.stackTrace = jQuery.Deferred.getStackHook();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\twindow.setTimeout( process );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\n\t\t\t\t\t\t// progress_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 0 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tisFunction( onProgress ) ?\n\t\t\t\t\t\t\t\t\tonProgress :\n\t\t\t\t\t\t\t\t\tIdentity,\n\t\t\t\t\t\t\t\tnewDefer.notifyWith\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// fulfilled_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 1 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tisFunction( onFulfilled ) ?\n\t\t\t\t\t\t\t\t\tonFulfilled :\n\t\t\t\t\t\t\t\t\tIdentity\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// rejected_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 2 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tisFunction( onRejected ) ?\n\t\t\t\t\t\t\t\t\tonRejected :\n\t\t\t\t\t\t\t\t\tThrower\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t} ).promise();\n\t\t\t\t},\n\n\t\t\t\t// Get a promise for this deferred\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\tpromise: function( obj ) {\n\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdeferred = {};\n\n\t\t// Add list-specific methods\n\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\tvar list = tuple[ 2 ],\n\t\t\t\tstateString = tuple[ 5 ];\n\n\t\t\t// promise.progress = list.add\n\t\t\t// promise.done = list.add\n\t\t\t// promise.fail = list.add\n\t\t\tpromise[ tuple[ 1 ] ] = list.add;\n\n\t\t\t// Handle state\n\t\t\tif ( stateString ) {\n\t\t\t\tlist.add(\n\t\t\t\t\tfunction() {\n\n\t\t\t\t\t\t// state = \"resolved\" (i.e., fulfilled)\n\t\t\t\t\t\t// state = \"rejected\"\n\t\t\t\t\t\tstate = stateString;\n\t\t\t\t\t},\n\n\t\t\t\t\t// rejected_callbacks.disable\n\t\t\t\t\t// fulfilled_callbacks.disable\n\t\t\t\t\ttuples[ 3 - i ][ 2 ].disable,\n\n\t\t\t\t\t// rejected_handlers.disable\n\t\t\t\t\t// fulfilled_handlers.disable\n\t\t\t\t\ttuples[ 3 - i ][ 3 ].disable,\n\n\t\t\t\t\t// progress_callbacks.lock\n\t\t\t\t\ttuples[ 0 ][ 2 ].lock,\n\n\t\t\t\t\t// progress_handlers.lock\n\t\t\t\t\ttuples[ 0 ][ 3 ].lock\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// progress_handlers.fire\n\t\t\t// fulfilled_handlers.fire\n\t\t\t// rejected_handlers.fire\n\t\t\tlist.add( tuple[ 3 ].fire );\n\n\t\t\t// deferred.notify = function() { deferred.notifyWith(...) }\n\t\t\t// deferred.resolve = function() { deferred.resolveWith(...) }\n\t\t\t// deferred.reject = function() { deferred.rejectWith(...) }\n\t\t\tdeferred[ tuple[ 0 ] ] = function() {\n\t\t\t\tdeferred[ tuple[ 0 ] + \"With\" ]( this === deferred ? undefined : this, arguments );\n\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\t// deferred.notifyWith = list.fireWith\n\t\t\t// deferred.resolveWith = list.fireWith\n\t\t\t// deferred.rejectWith = list.fireWith\n\t\t\tdeferred[ tuple[ 0 ] + \"With\" ] = list.fireWith;\n\t\t} );\n\n\t\t// Make the deferred a promise\n\t\tpromise.promise( deferred );\n\n\t\t// Call given func if any\n\t\tif ( func ) {\n\t\t\tfunc.call( deferred, deferred );\n\t\t}\n\n\t\t// All done!\n\t\treturn deferred;\n\t},\n\n\t// Deferred helper\n\twhen: function( singleValue ) {\n\t\tvar\n\n\t\t\t// count of uncompleted subordinates\n\t\t\tremaining = arguments.length,\n\n\t\t\t// count of unprocessed arguments\n\t\t\ti = remaining,\n\n\t\t\t// subordinate fulfillment data\n\t\t\tresolveContexts = Array( i ),\n\t\t\tresolveValues = slice.call( arguments ),\n\n\t\t\t// the primary Deferred\n\t\t\tprimary = jQuery.Deferred(),\n\n\t\t\t// subordinate callback factory\n\t\t\tupdateFunc = function( i ) {\n\t\t\t\treturn function( value ) {\n\t\t\t\t\tresolveContexts[ i ] = this;\n\t\t\t\t\tresolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\n\t\t\t\t\tif ( !( --remaining ) ) {\n\t\t\t\t\t\tprimary.resolveWith( resolveContexts, resolveValues );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\n\t\t// Single- and empty arguments are adopted like Promise.resolve\n\t\tif ( remaining <= 1 ) {\n\t\t\tadoptValue( singleValue, primary.done( updateFunc( i ) ).resolve, primary.reject,\n\t\t\t\t!remaining );\n\n\t\t\t// Use .then() to unwrap secondary thenables (cf. gh-3000)\n\t\t\tif ( primary.state() === \"pending\" ||\n\t\t\t\tisFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {\n\n\t\t\t\treturn primary.then();\n\t\t\t}\n\t\t}\n\n\t\t// Multiple arguments are aggregated like Promise.all array elements\n\t\twhile ( i-- ) {\n\t\t\tadoptValue( resolveValues[ i ], updateFunc( i ), primary.reject );\n\t\t}\n\n\t\treturn primary.promise();\n\t}\n} );\n\n\n// These usually indicate a programmer mistake during development,\n// warn about them ASAP rather than swallowing them by default.\nvar rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;\n\njQuery.Deferred.exceptionHook = function( error, stack ) {\n\n\t// Support: IE 8 - 9 only\n\t// Console exists when dev tools are open, which can happen at any time\n\tif ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {\n\t\twindow.console.warn( \"jQuery.Deferred exception: \" + error.message, error.stack, stack );\n\t}\n};\n\n\n\n\njQuery.readyException = function( error ) {\n\twindow.setTimeout( function() {\n\t\tthrow error;\n\t} );\n};\n\n\n\n\n// The deferred used on DOM ready\nvar readyList = jQuery.Deferred();\n\njQuery.fn.ready = function( fn ) {\n\n\treadyList\n\t\t.then( fn )\n\n\t\t// Wrap jQuery.readyException in a function so that the lookup\n\t\t// happens at the time of error handling instead of callback\n\t\t// registration.\n\t\t.catch( function( error ) {\n\t\t\tjQuery.readyException( error );\n\t\t} );\n\n\treturn this;\n};\n\njQuery.extend( {\n\n\t// Is the DOM ready to be used? Set to true once it occurs.\n\tisReady: false,\n\n\t// A counter to track how many items to wait for before\n\t// the ready event fires. See #6781\n\treadyWait: 1,\n\n\t// Handle when the DOM is ready\n\tready: function( wait ) {\n\n\t\t// Abort if there are pending holds or we're already ready\n\t\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Remember that the DOM is ready\n\t\tjQuery.isReady = true;\n\n\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If there are functions bound, to execute\n\t\treadyList.resolveWith( document, [ jQuery ] );\n\t}\n} );\n\njQuery.ready.then = readyList.then;\n\n// The ready event handler and self cleanup method\nfunction completed() {\n\tdocument.removeEventListener( \"DOMContentLoaded\", completed );\n\twindow.removeEventListener( \"load\", completed );\n\tjQuery.ready();\n}\n\n// Catch cases where $(document).ready() is called\n// after the browser event has already occurred.\n// Support: IE <=9 - 10 only\n// Older IE sometimes signals \"interactive\" too soon\nif ( document.readyState === \"complete\" ||\n\t( document.readyState !== \"loading\" && !document.documentElement.doScroll ) ) {\n\n\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n\twindow.setTimeout( jQuery.ready );\n\n} else {\n\n\t// Use the handy event callback\n\tdocument.addEventListener( \"DOMContentLoaded\", completed );\n\n\t// A fallback to window.onload, that will always work\n\twindow.addEventListener( \"load\", completed );\n}\n\n\n\n\n// Multifunctional method to get and set values of a collection\n// The value/s can optionally be executed if it's a function\nvar access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\n\tvar i = 0,\n\t\tlen = elems.length,\n\t\tbulk = key == null;\n\n\t// Sets many values\n\tif ( toType( key ) === \"object\" ) {\n\t\tchainable = true;\n\t\tfor ( i in key ) {\n\t\t\taccess( elems, fn, i, key[ i ], true, emptyGet, raw );\n\t\t}\n\n\t// Sets one value\n\t} else if ( value !== undefined ) {\n\t\tchainable = true;\n\n\t\tif ( !isFunction( value ) ) {\n\t\t\traw = true;\n\t\t}\n\n\t\tif ( bulk ) {\n\n\t\t\t// Bulk operations run against the entire set\n\t\t\tif ( raw ) {\n\t\t\t\tfn.call( elems, value );\n\t\t\t\tfn = null;\n\n\t\t\t// ...except when executing function values\n\t\t\t} else {\n\t\t\t\tbulk = fn;\n\t\t\t\tfn = function( elem, _key, value ) {\n\t\t\t\t\treturn bulk.call( jQuery( elem ), value );\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif ( fn ) {\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\tfn(\n\t\t\t\t\telems[ i ], key, raw ?\n\t\t\t\t\t\tvalue :\n\t\t\t\t\t\tvalue.call( elems[ i ], i, fn( elems[ i ], key ) )\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( chainable ) {\n\t\treturn elems;\n\t}\n\n\t// Gets\n\tif ( bulk ) {\n\t\treturn fn.call( elems );\n\t}\n\n\treturn len ? fn( elems[ 0 ], key ) : emptyGet;\n};\n\n\n// Matches dashed string for camelizing\nvar rmsPrefix = /^-ms-/,\n\trdashAlpha = /-([a-z])/g;\n\n// Used by camelCase as callback to replace()\nfunction fcamelCase( _all, letter ) {\n\treturn letter.toUpperCase();\n}\n\n// Convert dashed to camelCase; used by the css and data modules\n// Support: IE <=9 - 11, Edge 12 - 15\n// Microsoft forgot to hump their vendor prefix (#9572)\nfunction camelCase( string ) {\n\treturn string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\n}\nvar acceptData = function( owner ) {\n\n\t// Accepts only:\n\t//  - Node\n\t//    - Node.ELEMENT_NODE\n\t//    - Node.DOCUMENT_NODE\n\t//  - Object\n\t//    - Any\n\treturn owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );\n};\n\n\n\n\nfunction Data() {\n\tthis.expando = jQuery.expando + Data.uid++;\n}\n\nData.uid = 1;\n\nData.prototype = {\n\n\tcache: function( owner ) {\n\n\t\t// Check if the owner object already has a cache\n\t\tvar value = owner[ this.expando ];\n\n\t\t// If not, create one\n\t\tif ( !value ) {\n\t\t\tvalue = {};\n\n\t\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t\t// but we should not, see #8335.\n\t\t\t// Always return an empty object.\n\t\t\tif ( acceptData( owner ) ) {\n\n\t\t\t\t// If it is a node unlikely to be stringify-ed or looped over\n\t\t\t\t// use plain assignment\n\t\t\t\tif ( owner.nodeType ) {\n\t\t\t\t\towner[ this.expando ] = value;\n\n\t\t\t\t// Otherwise secure it in a non-enumerable property\n\t\t\t\t// configurable must be true to allow the property to be\n\t\t\t\t// deleted when data is removed\n\t\t\t\t} else {\n\t\t\t\t\tObject.defineProperty( owner, this.expando, {\n\t\t\t\t\t\tvalue: value,\n\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn value;\n\t},\n\tset: function( owner, data, value ) {\n\t\tvar prop,\n\t\t\tcache = this.cache( owner );\n\n\t\t// Handle: [ owner, key, value ] args\n\t\t// Always use camelCase key (gh-2257)\n\t\tif ( typeof data === \"string\" ) {\n\t\t\tcache[ camelCase( data ) ] = value;\n\n\t\t// Handle: [ owner, { properties } ] args\n\t\t} else {\n\n\t\t\t// Copy the properties one-by-one to the cache object\n\t\t\tfor ( prop in data ) {\n\t\t\t\tcache[ camelCase( prop ) ] = data[ prop ];\n\t\t\t}\n\t\t}\n\t\treturn cache;\n\t},\n\tget: function( owner, key ) {\n\t\treturn key === undefined ?\n\t\t\tthis.cache( owner ) :\n\n\t\t\t// Always use camelCase key (gh-2257)\n\t\t\towner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];\n\t},\n\taccess: function( owner, key, value ) {\n\n\t\t// In cases where either:\n\t\t//\n\t\t//   1. No key was specified\n\t\t//   2. A string key was specified, but no value provided\n\t\t//\n\t\t// Take the \"read\" path and allow the get method to determine\n\t\t// which value to return, respectively either:\n\t\t//\n\t\t//   1. The entire cache object\n\t\t//   2. The data stored at the key\n\t\t//\n\t\tif ( key === undefined ||\n\t\t\t\t( ( key && typeof key === \"string\" ) && value === undefined ) ) {\n\n\t\t\treturn this.get( owner, key );\n\t\t}\n\n\t\t// When the key is not a string, or both a key and value\n\t\t// are specified, set or extend (existing objects) with either:\n\t\t//\n\t\t//   1. An object of properties\n\t\t//   2. A key and value\n\t\t//\n\t\tthis.set( owner, key, value );\n\n\t\t// Since the \"set\" path can have two possible entry points\n\t\t// return the expected data based on which path was taken[*]\n\t\treturn value !== undefined ? value : key;\n\t},\n\tremove: function( owner, key ) {\n\t\tvar i,\n\t\t\tcache = owner[ this.expando ];\n\n\t\tif ( cache === undefined ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( key !== undefined ) {\n\n\t\t\t// Support array or space separated string of keys\n\t\t\tif ( Array.isArray( key ) ) {\n\n\t\t\t\t// If key is an array of keys...\n\t\t\t\t// We always set camelCase keys, so remove that.\n\t\t\t\tkey = key.map( camelCase );\n\t\t\t} else {\n\t\t\t\tkey = camelCase( key );\n\n\t\t\t\t// If a key with the spaces exists, use it.\n\t\t\t\t// Otherwise, create an array by matching non-whitespace\n\t\t\t\tkey = key in cache ?\n\t\t\t\t\t[ key ] :\n\t\t\t\t\t( key.match( rnothtmlwhite ) || [] );\n\t\t\t}\n\n\t\t\ti = key.length;\n\n\t\t\twhile ( i-- ) {\n\t\t\t\tdelete cache[ key[ i ] ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove the expando if there's no more data\n\t\tif ( key === undefined || jQuery.isEmptyObject( cache ) ) {\n\n\t\t\t// Support: Chrome <=35 - 45\n\t\t\t// Webkit & Blink performance suffers when deleting properties\n\t\t\t// from DOM nodes, so set to undefined instead\n\t\t\t// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)\n\t\t\tif ( owner.nodeType ) {\n\t\t\t\towner[ this.expando ] = undefined;\n\t\t\t} else {\n\t\t\t\tdelete owner[ this.expando ];\n\t\t\t}\n\t\t}\n\t},\n\thasData: function( owner ) {\n\t\tvar cache = owner[ this.expando ];\n\t\treturn cache !== undefined && !jQuery.isEmptyObject( cache );\n\t}\n};\nvar dataPriv = new Data();\n\nvar dataUser = new Data();\n\n\n\n//\tImplementation Summary\n//\n//\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n//\t2. Improve the module's maintainability by reducing the storage\n//\t\tpaths to a single mechanism.\n//\t3. Use the same single mechanism to support \"private\" and \"user\" data.\n//\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\n//\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n//\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n\nvar rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n\trmultiDash = /[A-Z]/g;\n\nfunction getData( data ) {\n\tif ( data === \"true\" ) {\n\t\treturn true;\n\t}\n\n\tif ( data === \"false\" ) {\n\t\treturn false;\n\t}\n\n\tif ( data === \"null\" ) {\n\t\treturn null;\n\t}\n\n\t// Only convert to a number if it doesn't change the string\n\tif ( data === +data + \"\" ) {\n\t\treturn +data;\n\t}\n\n\tif ( rbrace.test( data ) ) {\n\t\treturn JSON.parse( data );\n\t}\n\n\treturn data;\n}\n\nfunction dataAttr( elem, key, data ) {\n\tvar name;\n\n\t// If nothing was found internally, try to fetch any\n\t// data from the HTML5 data-* attribute\n\tif ( data === undefined && elem.nodeType === 1 ) {\n\t\tname = \"data-\" + key.replace( rmultiDash, \"-$&\" ).toLowerCase();\n\t\tdata = elem.getAttribute( name );\n\n\t\tif ( typeof data === \"string\" ) {\n\t\t\ttry {\n\t\t\t\tdata = getData( data );\n\t\t\t} catch ( e ) {}\n\n\t\t\t// Make sure we set the data so it isn't changed later\n\t\t\tdataUser.set( elem, key, data );\n\t\t} else {\n\t\t\tdata = undefined;\n\t\t}\n\t}\n\treturn data;\n}\n\njQuery.extend( {\n\thasData: function( elem ) {\n\t\treturn dataUser.hasData( elem ) || dataPriv.hasData( elem );\n\t},\n\n\tdata: function( elem, name, data ) {\n\t\treturn dataUser.access( elem, name, data );\n\t},\n\n\tremoveData: function( elem, name ) {\n\t\tdataUser.remove( elem, name );\n\t},\n\n\t// TODO: Now that all calls to _data and _removeData have been replaced\n\t// with direct calls to dataPriv methods, these can be deprecated.\n\t_data: function( elem, name, data ) {\n\t\treturn dataPriv.access( elem, name, data );\n\t},\n\n\t_removeData: function( elem, name ) {\n\t\tdataPriv.remove( elem, name );\n\t}\n} );\n\njQuery.fn.extend( {\n\tdata: function( key, value ) {\n\t\tvar i, name, data,\n\t\t\telem = this[ 0 ],\n\t\t\tattrs = elem && elem.attributes;\n\n\t\t// Gets all values\n\t\tif ( key === undefined ) {\n\t\t\tif ( this.length ) {\n\t\t\t\tdata = dataUser.get( elem );\n\n\t\t\t\tif ( elem.nodeType === 1 && !dataPriv.get( elem, \"hasDataAttrs\" ) ) {\n\t\t\t\t\ti = attrs.length;\n\t\t\t\t\twhile ( i-- ) {\n\n\t\t\t\t\t\t// Support: IE 11 only\n\t\t\t\t\t\t// The attrs elements can be null (#14894)\n\t\t\t\t\t\tif ( attrs[ i ] ) {\n\t\t\t\t\t\t\tname = attrs[ i ].name;\n\t\t\t\t\t\t\tif ( name.indexOf( \"data-\" ) === 0 ) {\n\t\t\t\t\t\t\t\tname = camelCase( name.slice( 5 ) );\n\t\t\t\t\t\t\t\tdataAttr( elem, name, data[ name ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdataPriv.set( elem, \"hasDataAttrs\", true );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\t// Sets multiple values\n\t\tif ( typeof key === \"object\" ) {\n\t\t\treturn this.each( function() {\n\t\t\t\tdataUser.set( this, key );\n\t\t\t} );\n\t\t}\n\n\t\treturn access( this, function( value ) {\n\t\t\tvar data;\n\n\t\t\t// The calling jQuery object (element matches) is not empty\n\t\t\t// (and therefore has an element appears at this[ 0 ]) and the\n\t\t\t// `value` parameter was not undefined. An empty jQuery object\n\t\t\t// will result in `undefined` for elem = this[ 0 ] which will\n\t\t\t// throw an exception if an attempt to read a data cache is made.\n\t\t\tif ( elem && value === undefined ) {\n\n\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t// The key will always be camelCased in Data\n\t\t\t\tdata = dataUser.get( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// Attempt to \"discover\" the data in\n\t\t\t\t// HTML5 custom data-* attrs\n\t\t\t\tdata = dataAttr( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// We tried really hard, but the data doesn't exist.\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Set the data...\n\t\t\tthis.each( function() {\n\n\t\t\t\t// We always store the camelCased key\n\t\t\t\tdataUser.set( this, key, value );\n\t\t\t} );\n\t\t}, null, value, arguments.length > 1, null, true );\n\t},\n\n\tremoveData: function( key ) {\n\t\treturn this.each( function() {\n\t\t\tdataUser.remove( this, key );\n\t\t} );\n\t}\n} );\n\n\njQuery.extend( {\n\tqueue: function( elem, type, data ) {\n\t\tvar queue;\n\n\t\tif ( elem ) {\n\t\t\ttype = ( type || \"fx\" ) + \"queue\";\n\t\t\tqueue = dataPriv.get( elem, type );\n\n\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n\t\t\tif ( data ) {\n\t\t\t\tif ( !queue || Array.isArray( data ) ) {\n\t\t\t\t\tqueue = dataPriv.access( elem, type, jQuery.makeArray( data ) );\n\t\t\t\t} else {\n\t\t\t\t\tqueue.push( data );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queue || [];\n\t\t}\n\t},\n\n\tdequeue: function( elem, type ) {\n\t\ttype = type || \"fx\";\n\n\t\tvar queue = jQuery.queue( elem, type ),\n\t\t\tstartLength = queue.length,\n\t\t\tfn = queue.shift(),\n\t\t\thooks = jQuery._queueHooks( elem, type ),\n\t\t\tnext = function() {\n\t\t\t\tjQuery.dequeue( elem, type );\n\t\t\t};\n\n\t\t// If the fx queue is dequeued, always remove the progress sentinel\n\t\tif ( fn === \"inprogress\" ) {\n\t\t\tfn = queue.shift();\n\t\t\tstartLength--;\n\t\t}\n\n\t\tif ( fn ) {\n\n\t\t\t// Add a progress sentinel to prevent the fx queue from being\n\t\t\t// automatically dequeued\n\t\t\tif ( type === \"fx\" ) {\n\t\t\t\tqueue.unshift( \"inprogress\" );\n\t\t\t}\n\n\t\t\t// Clear up the last queue stop function\n\t\t\tdelete hooks.stop;\n\t\t\tfn.call( elem, next, hooks );\n\t\t}\n\n\t\tif ( !startLength && hooks ) {\n\t\t\thooks.empty.fire();\n\t\t}\n\t},\n\n\t// Not public - generate a queueHooks object, or return the current one\n\t_queueHooks: function( elem, type ) {\n\t\tvar key = type + \"queueHooks\";\n\t\treturn dataPriv.get( elem, key ) || dataPriv.access( elem, key, {\n\t\t\tempty: jQuery.Callbacks( \"once memory\" ).add( function() {\n\t\t\t\tdataPriv.remove( elem, [ type + \"queue\", key ] );\n\t\t\t} )\n\t\t} );\n\t}\n} );\n\njQuery.fn.extend( {\n\tqueue: function( type, data ) {\n\t\tvar setter = 2;\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tdata = type;\n\t\t\ttype = \"fx\";\n\t\t\tsetter--;\n\t\t}\n\n\t\tif ( arguments.length < setter ) {\n\t\t\treturn jQuery.queue( this[ 0 ], type );\n\t\t}\n\n\t\treturn data === undefined ?\n\t\t\tthis :\n\t\t\tthis.each( function() {\n\t\t\t\tvar queue = jQuery.queue( this, type, data );\n\n\t\t\t\t// Ensure a hooks for this queue\n\t\t\t\tjQuery._queueHooks( this, type );\n\n\t\t\t\tif ( type === \"fx\" && queue[ 0 ] !== \"inprogress\" ) {\n\t\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t\t}\n\t\t\t} );\n\t},\n\tdequeue: function( type ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.dequeue( this, type );\n\t\t} );\n\t},\n\tclearQueue: function( type ) {\n\t\treturn this.queue( type || \"fx\", [] );\n\t},\n\n\t// Get a promise resolved when queues of a certain type\n\t// are emptied (fx is the type by default)\n\tpromise: function( type, obj ) {\n\t\tvar tmp,\n\t\t\tcount = 1,\n\t\t\tdefer = jQuery.Deferred(),\n\t\t\telements = this,\n\t\t\ti = this.length,\n\t\t\tresolve = function() {\n\t\t\t\tif ( !( --count ) ) {\n\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\n\t\t\t\t}\n\t\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tobj = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\ttype = type || \"fx\";\n\n\t\twhile ( i-- ) {\n\t\t\ttmp = dataPriv.get( elements[ i ], type + \"queueHooks\" );\n\t\t\tif ( tmp && tmp.empty ) {\n\t\t\t\tcount++;\n\t\t\t\ttmp.empty.add( resolve );\n\t\t\t}\n\t\t}\n\t\tresolve();\n\t\treturn defer.promise( obj );\n\t}\n} );\nvar pnum = ( /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/ ).source;\n\nvar rcssNum = new RegExp( \"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\" );\n\n\nvar cssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ];\n\nvar documentElement = document.documentElement;\n\n\n\n\tvar isAttached = function( elem ) {\n\t\t\treturn jQuery.contains( elem.ownerDocument, elem );\n\t\t},\n\t\tcomposed = { composed: true };\n\n\t// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only\n\t// Check attachment across shadow DOM boundaries when possible (gh-3504)\n\t// Support: iOS 10.0-10.2 only\n\t// Early iOS 10 versions support `attachShadow` but not `getRootNode`,\n\t// leading to errors. We need to check for `getRootNode`.\n\tif ( documentElement.getRootNode ) {\n\t\tisAttached = function( elem ) {\n\t\t\treturn jQuery.contains( elem.ownerDocument, elem ) ||\n\t\t\t\telem.getRootNode( composed ) === elem.ownerDocument;\n\t\t};\n\t}\nvar isHiddenWithinTree = function( elem, el ) {\n\n\t\t// isHiddenWithinTree might be called from jQuery#filter function;\n\t\t// in that case, element will be second argument\n\t\telem = el || elem;\n\n\t\t// Inline style trumps all\n\t\treturn elem.style.display === \"none\" ||\n\t\t\telem.style.display === \"\" &&\n\n\t\t\t// Otherwise, check computed style\n\t\t\t// Support: Firefox <=43 - 45\n\t\t\t// Disconnected elements can have computed display: none, so first confirm that elem is\n\t\t\t// in the document.\n\t\t\tisAttached( elem ) &&\n\n\t\t\tjQuery.css( elem, \"display\" ) === \"none\";\n\t};\n\n\n\nfunction adjustCSS( elem, prop, valueParts, tween ) {\n\tvar adjusted, scale,\n\t\tmaxIterations = 20,\n\t\tcurrentValue = tween ?\n\t\t\tfunction() {\n\t\t\t\treturn tween.cur();\n\t\t\t} :\n\t\t\tfunction() {\n\t\t\t\treturn jQuery.css( elem, prop, \"\" );\n\t\t\t},\n\t\tinitial = currentValue(),\n\t\tunit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" ),\n\n\t\t// Starting value computation is required for potential unit mismatches\n\t\tinitialInUnit = elem.nodeType &&\n\t\t\t( jQuery.cssNumber[ prop ] || unit !== \"px\" && +initial ) &&\n\t\t\trcssNum.exec( jQuery.css( elem, prop ) );\n\n\tif ( initialInUnit && initialInUnit[ 3 ] !== unit ) {\n\n\t\t// Support: Firefox <=54\n\t\t// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)\n\t\tinitial = initial / 2;\n\n\t\t// Trust units reported by jQuery.css\n\t\tunit = unit || initialInUnit[ 3 ];\n\n\t\t// Iteratively approximate from a nonzero starting point\n\t\tinitialInUnit = +initial || 1;\n\n\t\twhile ( maxIterations-- ) {\n\n\t\t\t// Evaluate and update our best guess (doubling guesses that zero out).\n\t\t\t// Finish if the scale equals or crosses 1 (making the old*new product non-positive).\n\t\t\tjQuery.style( elem, prop, initialInUnit + unit );\n\t\t\tif ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {\n\t\t\t\tmaxIterations = 0;\n\t\t\t}\n\t\t\tinitialInUnit = initialInUnit / scale;\n\n\t\t}\n\n\t\tinitialInUnit = initialInUnit * 2;\n\t\tjQuery.style( elem, prop, initialInUnit + unit );\n\n\t\t// Make sure we update the tween properties later on\n\t\tvalueParts = valueParts || [];\n\t}\n\n\tif ( valueParts ) {\n\t\tinitialInUnit = +initialInUnit || +initial || 0;\n\n\t\t// Apply relative offset (+=/-=) if specified\n\t\tadjusted = valueParts[ 1 ] ?\n\t\t\tinitialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :\n\t\t\t+valueParts[ 2 ];\n\t\tif ( tween ) {\n\t\t\ttween.unit = unit;\n\t\t\ttween.start = initialInUnit;\n\t\t\ttween.end = adjusted;\n\t\t}\n\t}\n\treturn adjusted;\n}\n\n\nvar defaultDisplayMap = {};\n\nfunction getDefaultDisplay( elem ) {\n\tvar temp,\n\t\tdoc = elem.ownerDocument,\n\t\tnodeName = elem.nodeName,\n\t\tdisplay = defaultDisplayMap[ nodeName ];\n\n\tif ( display ) {\n\t\treturn display;\n\t}\n\n\ttemp = doc.body.appendChild( doc.createElement( nodeName ) );\n\tdisplay = jQuery.css( temp, \"display\" );\n\n\ttemp.parentNode.removeChild( temp );\n\n\tif ( display === \"none\" ) {\n\t\tdisplay = \"block\";\n\t}\n\tdefaultDisplayMap[ nodeName ] = display;\n\n\treturn display;\n}\n\nfunction showHide( elements, show ) {\n\tvar display, elem,\n\t\tvalues = [],\n\t\tindex = 0,\n\t\tlength = elements.length;\n\n\t// Determine new display value for elements that need to change\n\tfor ( ; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdisplay = elem.style.display;\n\t\tif ( show ) {\n\n\t\t\t// Since we force visibility upon cascade-hidden elements, an immediate (and slow)\n\t\t\t// check is required in this first loop unless we have a nonempty display value (either\n\t\t\t// inline or about-to-be-restored)\n\t\t\tif ( display === \"none\" ) {\n\t\t\t\tvalues[ index ] = dataPriv.get( elem, \"display\" ) || null;\n\t\t\t\tif ( !values[ index ] ) {\n\t\t\t\t\telem.style.display = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( elem.style.display === \"\" && isHiddenWithinTree( elem ) ) {\n\t\t\t\tvalues[ index ] = getDefaultDisplay( elem );\n\t\t\t}\n\t\t} else {\n\t\t\tif ( display !== \"none\" ) {\n\t\t\t\tvalues[ index ] = \"none\";\n\n\t\t\t\t// Remember what we're overwriting\n\t\t\t\tdataPriv.set( elem, \"display\", display );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set the display of the elements in a second loop to avoid constant reflow\n\tfor ( index = 0; index < length; index++ ) {\n\t\tif ( values[ index ] != null ) {\n\t\t\telements[ index ].style.display = values[ index ];\n\t\t}\n\t}\n\n\treturn elements;\n}\n\njQuery.fn.extend( {\n\tshow: function() {\n\t\treturn showHide( this, true );\n\t},\n\thide: function() {\n\t\treturn showHide( this );\n\t},\n\ttoggle: function( state ) {\n\t\tif ( typeof state === \"boolean\" ) {\n\t\t\treturn state ? this.show() : this.hide();\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tif ( isHiddenWithinTree( this ) ) {\n\t\t\t\tjQuery( this ).show();\n\t\t\t} else {\n\t\t\t\tjQuery( this ).hide();\n\t\t\t}\n\t\t} );\n\t}\n} );\nvar rcheckableType = ( /^(?:checkbox|radio)$/i );\n\nvar rtagName = ( /<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)/i );\n\nvar rscriptType = ( /^$|^module$|\\/(?:java|ecma)script/i );\n\n\n\n( function() {\n\tvar fragment = document.createDocumentFragment(),\n\t\tdiv = fragment.appendChild( document.createElement( \"div\" ) ),\n\t\tinput = document.createElement( \"input\" );\n\n\t// Support: Android 4.0 - 4.3 only\n\t// Check state lost if the name is set (#11217)\n\t// Support: Windows Web Apps (WWA)\n\t// `name` and `type` must use .setAttribute for WWA (#14901)\n\tinput.setAttribute( \"type\", \"radio\" );\n\tinput.setAttribute( \"checked\", \"checked\" );\n\tinput.setAttribute( \"name\", \"t\" );\n\n\tdiv.appendChild( input );\n\n\t// Support: Android <=4.1 only\n\t// Older WebKit doesn't clone checked state correctly in fragments\n\tsupport.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\n\n\t// Support: IE <=11 only\n\t// Make sure textarea (and checkbox) defaultValue is properly cloned\n\tdiv.innerHTML = \"<textarea>x</textarea>\";\n\tsupport.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\n\n\t// Support: IE <=9 only\n\t// IE <=9 replaces <option> tags with their contents when inserted outside of\n\t// the select element.\n\tdiv.innerHTML = \"<option></option>\";\n\tsupport.option = !!div.lastChild;\n} )();\n\n\n// We have to close these tags to support XHTML (#13200)\nvar wrapMap = {\n\n\t// XHTML parsers do not magically insert elements in the\n\t// same way that tag soup parsers do. So we cannot shorten\n\t// this by omitting <tbody> or other required elements.\n\tthead: [ 1, \"<table>\", \"</table>\" ],\n\tcol: [ 2, \"<table><colgroup>\", \"</colgroup></table>\" ],\n\ttr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\n\ttd: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\n\n\t_default: [ 0, \"\", \"\" ]\n};\n\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\nwrapMap.th = wrapMap.td;\n\n// Support: IE <=9 only\nif ( !support.option ) {\n\twrapMap.optgroup = wrapMap.option = [ 1, \"<select multiple='multiple'>\", \"</select>\" ];\n}\n\n\nfunction getAll( context, tag ) {\n\n\t// Support: IE <=9 - 11 only\n\t// Use typeof to avoid zero-argument method invocation on host objects (#15151)\n\tvar ret;\n\n\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\tret = context.getElementsByTagName( tag || \"*\" );\n\n\t} else if ( typeof context.querySelectorAll !== \"undefined\" ) {\n\t\tret = context.querySelectorAll( tag || \"*\" );\n\n\t} else {\n\t\tret = [];\n\t}\n\n\tif ( tag === undefined || tag && nodeName( context, tag ) ) {\n\t\treturn jQuery.merge( [ context ], ret );\n\t}\n\n\treturn ret;\n}\n\n\n// Mark scripts as having already been evaluated\nfunction setGlobalEval( elems, refElements ) {\n\tvar i = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\tdataPriv.set(\n\t\t\telems[ i ],\n\t\t\t\"globalEval\",\n\t\t\t!refElements || dataPriv.get( refElements[ i ], \"globalEval\" )\n\t\t);\n\t}\n}\n\n\nvar rhtml = /<|&#?\\w+;/;\n\nfunction buildFragment( elems, context, scripts, selection, ignored ) {\n\tvar elem, tmp, tag, wrap, attached, j,\n\t\tfragment = context.createDocumentFragment(),\n\t\tnodes = [],\n\t\ti = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\telem = elems[ i ];\n\n\t\tif ( elem || elem === 0 ) {\n\n\t\t\t// Add nodes directly\n\t\t\tif ( toType( elem ) === \"object\" ) {\n\n\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n\n\t\t\t// Convert non-html into a text node\n\t\t\t} else if ( !rhtml.test( elem ) ) {\n\t\t\t\tnodes.push( context.createTextNode( elem ) );\n\n\t\t\t// Convert html into DOM nodes\n\t\t\t} else {\n\t\t\t\ttmp = tmp || fragment.appendChild( context.createElement( \"div\" ) );\n\n\t\t\t\t// Deserialize a standard representation\n\t\t\t\ttag = ( rtagName.exec( elem ) || [ \"\", \"\" ] )[ 1 ].toLowerCase();\n\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default;\n\t\t\t\ttmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];\n\n\t\t\t\t// Descend through wrappers to the right content\n\t\t\t\tj = wrap[ 0 ];\n\t\t\t\twhile ( j-- ) {\n\t\t\t\t\ttmp = tmp.lastChild;\n\t\t\t\t}\n\n\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tjQuery.merge( nodes, tmp.childNodes );\n\n\t\t\t\t// Remember the top-level container\n\t\t\t\ttmp = fragment.firstChild;\n\n\t\t\t\t// Ensure the created nodes are orphaned (#12392)\n\t\t\t\ttmp.textContent = \"\";\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove wrapper from fragment\n\tfragment.textContent = \"\";\n\n\ti = 0;\n\twhile ( ( elem = nodes[ i++ ] ) ) {\n\n\t\t// Skip elements already in the context collection (trac-4087)\n\t\tif ( selection && jQuery.inArray( elem, selection ) > -1 ) {\n\t\t\tif ( ignored ) {\n\t\t\t\tignored.push( elem );\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tattached = isAttached( elem );\n\n\t\t// Append to fragment\n\t\ttmp = getAll( fragment.appendChild( elem ), \"script\" );\n\n\t\t// Preserve script evaluation history\n\t\tif ( attached ) {\n\t\t\tsetGlobalEval( tmp );\n\t\t}\n\n\t\t// Capture executables\n\t\tif ( scripts ) {\n\t\t\tj = 0;\n\t\t\twhile ( ( elem = tmp[ j++ ] ) ) {\n\t\t\t\tif ( rscriptType.test( elem.type || \"\" ) ) {\n\t\t\t\t\tscripts.push( elem );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn fragment;\n}\n\n\nvar rtypenamespace = /^([^.]*)(?:\\.(.+)|)/;\n\nfunction returnTrue() {\n\treturn true;\n}\n\nfunction returnFalse() {\n\treturn false;\n}\n\n// Support: IE <=9 - 11+\n// focus() and blur() are asynchronous, except when they are no-op.\n// So expect focus to be synchronous when the element is already active,\n// and blur to be synchronous when the element is not already active.\n// (focus and blur are always synchronous in other supported browsers,\n// this just defines when we can count on it).\nfunction expectSync( elem, type ) {\n\treturn ( elem === safeActiveElement() ) === ( type === \"focus\" );\n}\n\n// Support: IE <=9 only\n// Accessing document.activeElement can throw unexpectedly\n// https://bugs.jquery.com/ticket/13393\nfunction safeActiveElement() {\n\ttry {\n\t\treturn document.activeElement;\n\t} catch ( err ) { }\n}\n\nfunction on( elem, types, selector, data, fn, one ) {\n\tvar origFn, type;\n\n\t// Types can be a map of types/handlers\n\tif ( typeof types === \"object\" ) {\n\n\t\t// ( types-Object, selector, data )\n\t\tif ( typeof selector !== \"string\" ) {\n\n\t\t\t// ( types-Object, data )\n\t\t\tdata = data || selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tfor ( type in types ) {\n\t\t\ton( elem, type, selector, data, types[ type ], one );\n\t\t}\n\t\treturn elem;\n\t}\n\n\tif ( data == null && fn == null ) {\n\n\t\t// ( types, fn )\n\t\tfn = selector;\n\t\tdata = selector = undefined;\n\t} else if ( fn == null ) {\n\t\tif ( typeof selector === \"string\" ) {\n\n\t\t\t// ( types, selector, fn )\n\t\t\tfn = data;\n\t\t\tdata = undefined;\n\t\t} else {\n\n\t\t\t// ( types, data, fn )\n\t\t\tfn = data;\n\t\t\tdata = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t}\n\tif ( fn === false ) {\n\t\tfn = returnFalse;\n\t} else if ( !fn ) {\n\t\treturn elem;\n\t}\n\n\tif ( one === 1 ) {\n\t\torigFn = fn;\n\t\tfn = function( event ) {\n\n\t\t\t// Can use an empty set, since event contains the info\n\t\t\tjQuery().off( event );\n\t\t\treturn origFn.apply( this, arguments );\n\t\t};\n\n\t\t// Use same guid so caller can remove using origFn\n\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n\t}\n\treturn elem.each( function() {\n\t\tjQuery.event.add( this, types, fn, data, selector );\n\t} );\n}\n\n/*\n * Helper functions for managing events -- not part of the public interface.\n * Props to Dean Edwards' addEvent library for many of the ideas.\n */\njQuery.event = {\n\n\tglobal: {},\n\n\tadd: function( elem, types, handler, data, selector ) {\n\n\t\tvar handleObjIn, eventHandle, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = dataPriv.get( elem );\n\n\t\t// Only attach events to objects that accept data\n\t\tif ( !acceptData( elem ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Caller can pass in an object of custom data in lieu of the handler\n\t\tif ( handler.handler ) {\n\t\t\thandleObjIn = handler;\n\t\t\thandler = handleObjIn.handler;\n\t\t\tselector = handleObjIn.selector;\n\t\t}\n\n\t\t// Ensure that invalid selectors throw exceptions at attach time\n\t\t// Evaluate against documentElement in case elem is a non-element node (e.g., document)\n\t\tif ( selector ) {\n\t\t\tjQuery.find.matchesSelector( documentElement, selector );\n\t\t}\n\n\t\t// Make sure that the handler has a unique ID, used to find/remove it later\n\t\tif ( !handler.guid ) {\n\t\t\thandler.guid = jQuery.guid++;\n\t\t}\n\n\t\t// Init the element's event structure and main handler, if this is the first\n\t\tif ( !( events = elemData.events ) ) {\n\t\t\tevents = elemData.events = Object.create( null );\n\t\t}\n\t\tif ( !( eventHandle = elemData.handle ) ) {\n\t\t\teventHandle = elemData.handle = function( e ) {\n\n\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\n\t\t\t\t// when an event is called after a page has unloaded\n\t\t\t\treturn typeof jQuery !== \"undefined\" && jQuery.event.triggered !== e.type ?\n\t\t\t\t\tjQuery.event.dispatch.apply( elem, arguments ) : undefined;\n\t\t\t};\n\t\t}\n\n\t\t// Handle multiple events separated by a space\n\t\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\ttype = origType = tmp[ 1 ];\n\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// There *must* be a type, no attaching namespace-only handlers\n\t\t\tif ( !type ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If event changes its type, use the special event handlers for the changed type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// If selector defined, determine special event api type, otherwise given type\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\n\t\t\t// Update special based on newly reset type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// handleObj is passed to all event handlers\n\t\t\thandleObj = jQuery.extend( {\n\t\t\t\ttype: type,\n\t\t\t\torigType: origType,\n\t\t\t\tdata: data,\n\t\t\t\thandler: handler,\n\t\t\t\tguid: handler.guid,\n\t\t\t\tselector: selector,\n\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n\t\t\t\tnamespace: namespaces.join( \".\" )\n\t\t\t}, handleObjIn );\n\n\t\t\t// Init the event handler queue if we're the first\n\t\t\tif ( !( handlers = events[ type ] ) ) {\n\t\t\t\thandlers = events[ type ] = [];\n\t\t\t\thandlers.delegateCount = 0;\n\n\t\t\t\t// Only use addEventListener if the special events handler returns false\n\t\t\t\tif ( !special.setup ||\n\t\t\t\t\tspecial.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n\n\t\t\t\t\tif ( elem.addEventListener ) {\n\t\t\t\t\t\telem.addEventListener( type, eventHandle );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( special.add ) {\n\t\t\t\tspecial.add.call( elem, handleObj );\n\n\t\t\t\tif ( !handleObj.handler.guid ) {\n\t\t\t\t\thandleObj.handler.guid = handler.guid;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add to the element's handler list, delegates in front\n\t\t\tif ( selector ) {\n\t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\n\t\t\t} else {\n\t\t\t\thandlers.push( handleObj );\n\t\t\t}\n\n\t\t\t// Keep track of which events have ever been used, for event optimization\n\t\t\tjQuery.event.global[ type ] = true;\n\t\t}\n\n\t},\n\n\t// Detach an event or set of events from an element\n\tremove: function( elem, types, handler, selector, mappedTypes ) {\n\n\t\tvar j, origCount, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = dataPriv.hasData( elem ) && dataPriv.get( elem );\n\n\t\tif ( !elemData || !( events = elemData.events ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Once for each type.namespace in types; type may be omitted\n\t\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\ttype = origType = tmp[ 1 ];\n\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// Unbind all events (on this namespace, if provided) for the element\n\t\t\tif ( !type ) {\n\t\t\t\tfor ( type in events ) {\n\t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\t\t\thandlers = events[ type ] || [];\n\t\t\ttmp = tmp[ 2 ] &&\n\t\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" );\n\n\t\t\t// Remove matching events\n\t\t\torigCount = j = handlers.length;\n\t\t\twhile ( j-- ) {\n\t\t\t\thandleObj = handlers[ j ];\n\n\t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\n\t\t\t\t\t( !handler || handler.guid === handleObj.guid ) &&\n\t\t\t\t\t( !tmp || tmp.test( handleObj.namespace ) ) &&\n\t\t\t\t\t( !selector || selector === handleObj.selector ||\n\t\t\t\t\t\tselector === \"**\" && handleObj.selector ) ) {\n\t\t\t\t\thandlers.splice( j, 1 );\n\n\t\t\t\t\tif ( handleObj.selector ) {\n\t\t\t\t\t\thandlers.delegateCount--;\n\t\t\t\t\t}\n\t\t\t\t\tif ( special.remove ) {\n\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove generic event handler if we removed something and no more handlers exist\n\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\n\t\t\tif ( origCount && !handlers.length ) {\n\t\t\t\tif ( !special.teardown ||\n\t\t\t\t\tspecial.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n\n\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\n\t\t\t\t}\n\n\t\t\t\tdelete events[ type ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove data and the expando if it's no longer used\n\t\tif ( jQuery.isEmptyObject( events ) ) {\n\t\t\tdataPriv.remove( elem, \"handle events\" );\n\t\t}\n\t},\n\n\tdispatch: function( nativeEvent ) {\n\n\t\tvar i, j, ret, matched, handleObj, handlerQueue,\n\t\t\targs = new Array( arguments.length ),\n\n\t\t\t// Make a writable jQuery.Event from the native event object\n\t\t\tevent = jQuery.event.fix( nativeEvent ),\n\n\t\t\thandlers = (\n\t\t\t\tdataPriv.get( this, \"events\" ) || Object.create( null )\n\t\t\t)[ event.type ] || [],\n\t\t\tspecial = jQuery.event.special[ event.type ] || {};\n\n\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\n\t\targs[ 0 ] = event;\n\n\t\tfor ( i = 1; i < arguments.length; i++ ) {\n\t\t\targs[ i ] = arguments[ i ];\n\t\t}\n\n\t\tevent.delegateTarget = this;\n\n\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\n\t\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine handlers\n\t\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\n\n\t\t// Run delegates first; they may want to stop propagation beneath us\n\t\ti = 0;\n\t\twhile ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {\n\t\t\tevent.currentTarget = matched.elem;\n\n\t\t\tj = 0;\n\t\t\twhile ( ( handleObj = matched.handlers[ j++ ] ) &&\n\t\t\t\t!event.isImmediatePropagationStopped() ) {\n\n\t\t\t\t// If the event is namespaced, then each handler is only invoked if it is\n\t\t\t\t// specially universal or its namespaces are a superset of the event's.\n\t\t\t\tif ( !event.rnamespace || handleObj.namespace === false ||\n\t\t\t\t\tevent.rnamespace.test( handleObj.namespace ) ) {\n\n\t\t\t\t\tevent.handleObj = handleObj;\n\t\t\t\t\tevent.data = handleObj.data;\n\n\t\t\t\t\tret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||\n\t\t\t\t\t\thandleObj.handler ).apply( matched.elem, args );\n\n\t\t\t\t\tif ( ret !== undefined ) {\n\t\t\t\t\t\tif ( ( event.result = ret ) === false ) {\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Call the postDispatch hook for the mapped type\n\t\tif ( special.postDispatch ) {\n\t\t\tspecial.postDispatch.call( this, event );\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\thandlers: function( event, handlers ) {\n\t\tvar i, handleObj, sel, matchedHandlers, matchedSelectors,\n\t\t\thandlerQueue = [],\n\t\t\tdelegateCount = handlers.delegateCount,\n\t\t\tcur = event.target;\n\n\t\t// Find delegate handlers\n\t\tif ( delegateCount &&\n\n\t\t\t// Support: IE <=9\n\t\t\t// Black-hole SVG <use> instance trees (trac-13180)\n\t\t\tcur.nodeType &&\n\n\t\t\t// Support: Firefox <=42\n\t\t\t// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\n\t\t\t// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\n\t\t\t// Support: IE 11 only\n\t\t\t// ...but not arrow key \"clicks\" of radio inputs, which can have `button` -1 (gh-2343)\n\t\t\t!( event.type === \"click\" && event.button >= 1 ) ) {\n\n\t\t\tfor ( ; cur !== this; cur = cur.parentNode || this ) {\n\n\t\t\t\t// Don't check non-elements (#13208)\n\t\t\t\t// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n\t\t\t\tif ( cur.nodeType === 1 && !( event.type === \"click\" && cur.disabled === true ) ) {\n\t\t\t\t\tmatchedHandlers = [];\n\t\t\t\t\tmatchedSelectors = {};\n\t\t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\n\t\t\t\t\t\thandleObj = handlers[ i ];\n\n\t\t\t\t\t\t// Don't conflict with Object.prototype properties (#13203)\n\t\t\t\t\t\tsel = handleObj.selector + \" \";\n\n\t\t\t\t\t\tif ( matchedSelectors[ sel ] === undefined ) {\n\t\t\t\t\t\t\tmatchedSelectors[ sel ] = handleObj.needsContext ?\n\t\t\t\t\t\t\t\tjQuery( sel, this ).index( cur ) > -1 :\n\t\t\t\t\t\t\t\tjQuery.find( sel, this, null, [ cur ] ).length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( matchedSelectors[ sel ] ) {\n\t\t\t\t\t\t\tmatchedHandlers.push( handleObj );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( matchedHandlers.length ) {\n\t\t\t\t\t\thandlerQueue.push( { elem: cur, handlers: matchedHandlers } );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add the remaining (directly-bound) handlers\n\t\tcur = this;\n\t\tif ( delegateCount < handlers.length ) {\n\t\t\thandlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );\n\t\t}\n\n\t\treturn handlerQueue;\n\t},\n\n\taddProp: function( name, hook ) {\n\t\tObject.defineProperty( jQuery.Event.prototype, name, {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\n\t\t\tget: isFunction( hook ) ?\n\t\t\t\tfunction() {\n\t\t\t\t\tif ( this.originalEvent ) {\n\t\t\t\t\t\treturn hook( this.originalEvent );\n\t\t\t\t\t}\n\t\t\t\t} :\n\t\t\t\tfunction() {\n\t\t\t\t\tif ( this.originalEvent ) {\n\t\t\t\t\t\treturn this.originalEvent[ name ];\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\tset: function( value ) {\n\t\t\t\tObject.defineProperty( this, name, {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\twritable: true,\n\t\t\t\t\tvalue: value\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\t},\n\n\tfix: function( originalEvent ) {\n\t\treturn originalEvent[ jQuery.expando ] ?\n\t\t\toriginalEvent :\n\t\t\tnew jQuery.Event( originalEvent );\n\t},\n\n\tspecial: {\n\t\tload: {\n\n\t\t\t// Prevent triggered image.load events from bubbling to window.load\n\t\t\tnoBubble: true\n\t\t},\n\t\tclick: {\n\n\t\t\t// Utilize native event to ensure correct state for checkable inputs\n\t\t\tsetup: function( data ) {\n\n\t\t\t\t// For mutual compressibility with _default, replace `this` access with a local var.\n\t\t\t\t// `|| data` is dead code meant only to preserve the variable through minification.\n\t\t\t\tvar el = this || data;\n\n\t\t\t\t// Claim the first handler\n\t\t\t\tif ( rcheckableType.test( el.type ) &&\n\t\t\t\t\tel.click && nodeName( el, \"input\" ) ) {\n\n\t\t\t\t\t// dataPriv.set( el, \"click\", ... )\n\t\t\t\t\tleverageNative( el, \"click\", returnTrue );\n\t\t\t\t}\n\n\t\t\t\t// Return false to allow normal processing in the caller\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\ttrigger: function( data ) {\n\n\t\t\t\t// For mutual compressibility with _default, replace `this` access with a local var.\n\t\t\t\t// `|| data` is dead code meant only to preserve the variable through minification.\n\t\t\t\tvar el = this || data;\n\n\t\t\t\t// Force setup before triggering a click\n\t\t\t\tif ( rcheckableType.test( el.type ) &&\n\t\t\t\t\tel.click && nodeName( el, \"input\" ) ) {\n\n\t\t\t\t\tleverageNative( el, \"click\" );\n\t\t\t\t}\n\n\t\t\t\t// Return non-false to allow normal event-path propagation\n\t\t\t\treturn true;\n\t\t\t},\n\n\t\t\t// For cross-browser consistency, suppress native .click() on links\n\t\t\t// Also prevent it if we're currently inside a leveraged native-event stack\n\t\t\t_default: function( event ) {\n\t\t\t\tvar target = event.target;\n\t\t\t\treturn rcheckableType.test( target.type ) &&\n\t\t\t\t\ttarget.click && nodeName( target, \"input\" ) &&\n\t\t\t\t\tdataPriv.get( target, \"click\" ) ||\n\t\t\t\t\tnodeName( target, \"a\" );\n\t\t\t}\n\t\t},\n\n\t\tbeforeunload: {\n\t\t\tpostDispatch: function( event ) {\n\n\t\t\t\t// Support: Firefox 20+\n\t\t\t\t// Firefox doesn't alert if the returnValue field is not set.\n\t\t\t\tif ( event.result !== undefined && event.originalEvent ) {\n\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n// Ensure the presence of an event listener that handles manually-triggered\n// synthetic events by interrupting progress until reinvoked in response to\n// *native* events that it fires directly, ensuring that state changes have\n// already occurred before other listeners are invoked.\nfunction leverageNative( el, type, expectSync ) {\n\n\t// Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add\n\tif ( !expectSync ) {\n\t\tif ( dataPriv.get( el, type ) === undefined ) {\n\t\t\tjQuery.event.add( el, type, returnTrue );\n\t\t}\n\t\treturn;\n\t}\n\n\t// Register the controller as a special universal handler for all event namespaces\n\tdataPriv.set( el, type, false );\n\tjQuery.event.add( el, type, {\n\t\tnamespace: false,\n\t\thandler: function( event ) {\n\t\t\tvar notAsync, result,\n\t\t\t\tsaved = dataPriv.get( this, type );\n\n\t\t\tif ( ( event.isTrigger & 1 ) && this[ type ] ) {\n\n\t\t\t\t// Interrupt processing of the outer synthetic .trigger()ed event\n\t\t\t\t// Saved data should be false in such cases, but might be a leftover capture object\n\t\t\t\t// from an async native handler (gh-4350)\n\t\t\t\tif ( !saved.length ) {\n\n\t\t\t\t\t// Store arguments for use when handling the inner native event\n\t\t\t\t\t// There will always be at least one argument (an event object), so this array\n\t\t\t\t\t// will not be confused with a leftover capture object.\n\t\t\t\t\tsaved = slice.call( arguments );\n\t\t\t\t\tdataPriv.set( this, type, saved );\n\n\t\t\t\t\t// Trigger the native event and capture its result\n\t\t\t\t\t// Support: IE <=9 - 11+\n\t\t\t\t\t// focus() and blur() are asynchronous\n\t\t\t\t\tnotAsync = expectSync( this, type );\n\t\t\t\t\tthis[ type ]();\n\t\t\t\t\tresult = dataPriv.get( this, type );\n\t\t\t\t\tif ( saved !== result || notAsync ) {\n\t\t\t\t\t\tdataPriv.set( this, type, false );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult = {};\n\t\t\t\t\t}\n\t\t\t\t\tif ( saved !== result ) {\n\n\t\t\t\t\t\t// Cancel the outer synthetic event\n\t\t\t\t\t\tevent.stopImmediatePropagation();\n\t\t\t\t\t\tevent.preventDefault();\n\n\t\t\t\t\t\t// Support: Chrome 86+\n\t\t\t\t\t\t// In Chrome, if an element having a focusout handler is blurred by\n\t\t\t\t\t\t// clicking outside of it, it invokes the handler synchronously. If\n\t\t\t\t\t\t// that handler calls `.remove()` on the element, the data is cleared,\n\t\t\t\t\t\t// leaving `result` undefined. We need to guard against this.\n\t\t\t\t\t\treturn result && result.value;\n\t\t\t\t\t}\n\n\t\t\t\t// If this is an inner synthetic event for an event with a bubbling surrogate\n\t\t\t\t// (focus or blur), assume that the surrogate already propagated from triggering the\n\t\t\t\t// native event and prevent that from happening again here.\n\t\t\t\t// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the\n\t\t\t\t// bubbling surrogate propagates *after* the non-bubbling base), but that seems\n\t\t\t\t// less bad than duplication.\n\t\t\t\t} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {\n\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t}\n\n\t\t\t// If this is a native event triggered above, everything is now in order\n\t\t\t// Fire an inner synthetic event with the original arguments\n\t\t\t} else if ( saved.length ) {\n\n\t\t\t\t// ...and capture the result\n\t\t\t\tdataPriv.set( this, type, {\n\t\t\t\t\tvalue: jQuery.event.trigger(\n\n\t\t\t\t\t\t// Support: IE <=9 - 11+\n\t\t\t\t\t\t// Extend with the prototype to reset the above stopImmediatePropagation()\n\t\t\t\t\t\tjQuery.extend( saved[ 0 ], jQuery.Event.prototype ),\n\t\t\t\t\t\tsaved.slice( 1 ),\n\t\t\t\t\t\tthis\n\t\t\t\t\t)\n\t\t\t\t} );\n\n\t\t\t\t// Abort handling of the native event\n\t\t\t\tevent.stopImmediatePropagation();\n\t\t\t}\n\t\t}\n\t} );\n}\n\njQuery.removeEvent = function( elem, type, handle ) {\n\n\t// This \"if\" is needed for plain objects\n\tif ( elem.removeEventListener ) {\n\t\telem.removeEventListener( type, handle );\n\t}\n};\n\njQuery.Event = function( src, props ) {\n\n\t// Allow instantiation without the 'new' keyword\n\tif ( !( this instanceof jQuery.Event ) ) {\n\t\treturn new jQuery.Event( src, props );\n\t}\n\n\t// Event object\n\tif ( src && src.type ) {\n\t\tthis.originalEvent = src;\n\t\tthis.type = src.type;\n\n\t\t// Events bubbling up the document may have been marked as prevented\n\t\t// by a handler lower down the tree; reflect the correct value.\n\t\tthis.isDefaultPrevented = src.defaultPrevented ||\n\t\t\t\tsrc.defaultPrevented === undefined &&\n\n\t\t\t\t// Support: Android <=2.3 only\n\t\t\t\tsrc.returnValue === false ?\n\t\t\treturnTrue :\n\t\t\treturnFalse;\n\n\t\t// Create target properties\n\t\t// Support: Safari <=6 - 7 only\n\t\t// Target should not be a text node (#504, #13143)\n\t\tthis.target = ( src.target && src.target.nodeType === 3 ) ?\n\t\t\tsrc.target.parentNode :\n\t\t\tsrc.target;\n\n\t\tthis.currentTarget = src.currentTarget;\n\t\tthis.relatedTarget = src.relatedTarget;\n\n\t// Event type\n\t} else {\n\t\tthis.type = src;\n\t}\n\n\t// Put explicitly provided properties onto the event object\n\tif ( props ) {\n\t\tjQuery.extend( this, props );\n\t}\n\n\t// Create a timestamp if incoming event doesn't have one\n\tthis.timeStamp = src && src.timeStamp || Date.now();\n\n\t// Mark it as fixed\n\tthis[ jQuery.expando ] = true;\n};\n\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\njQuery.Event.prototype = {\n\tconstructor: jQuery.Event,\n\tisDefaultPrevented: returnFalse,\n\tisPropagationStopped: returnFalse,\n\tisImmediatePropagationStopped: returnFalse,\n\tisSimulated: false,\n\n\tpreventDefault: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isDefaultPrevented = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.preventDefault();\n\t\t}\n\t},\n\tstopPropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isPropagationStopped = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.stopPropagation();\n\t\t}\n\t},\n\tstopImmediatePropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isImmediatePropagationStopped = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.stopImmediatePropagation();\n\t\t}\n\n\t\tthis.stopPropagation();\n\t}\n};\n\n// Includes all common event props including KeyEvent and MouseEvent specific props\njQuery.each( {\n\taltKey: true,\n\tbubbles: true,\n\tcancelable: true,\n\tchangedTouches: true,\n\tctrlKey: true,\n\tdetail: true,\n\teventPhase: true,\n\tmetaKey: true,\n\tpageX: true,\n\tpageY: true,\n\tshiftKey: true,\n\tview: true,\n\t\"char\": true,\n\tcode: true,\n\tcharCode: true,\n\tkey: true,\n\tkeyCode: true,\n\tbutton: true,\n\tbuttons: true,\n\tclientX: true,\n\tclientY: true,\n\toffsetX: true,\n\toffsetY: true,\n\tpointerId: true,\n\tpointerType: true,\n\tscreenX: true,\n\tscreenY: true,\n\ttargetTouches: true,\n\ttoElement: true,\n\ttouches: true,\n\twhich: true\n}, jQuery.event.addProp );\n\njQuery.each( { focus: \"focusin\", blur: \"focusout\" }, function( type, delegateType ) {\n\tjQuery.event.special[ type ] = {\n\n\t\t// Utilize native event if possible so blur/focus sequence is correct\n\t\tsetup: function() {\n\n\t\t\t// Claim the first handler\n\t\t\t// dataPriv.set( this, \"focus\", ... )\n\t\t\t// dataPriv.set( this, \"blur\", ... )\n\t\t\tleverageNative( this, type, expectSync );\n\n\t\t\t// Return false to allow normal processing in the caller\n\t\t\treturn false;\n\t\t},\n\t\ttrigger: function() {\n\n\t\t\t// Force setup before trigger\n\t\t\tleverageNative( this, type );\n\n\t\t\t// Return non-false to allow normal event-path propagation\n\t\t\treturn true;\n\t\t},\n\n\t\t// Suppress native focus or blur as it's already being fired\n\t\t// in leverageNative.\n\t\t_default: function() {\n\t\t\treturn true;\n\t\t},\n\n\t\tdelegateType: delegateType\n\t};\n} );\n\n// Create mouseenter/leave events using mouseover/out and event-time checks\n// so that event delegation works in jQuery.\n// Do the same for pointerenter/pointerleave and pointerover/pointerout\n//\n// Support: Safari 7 only\n// Safari sends mouseenter too often; see:\n// https://bugs.chromium.org/p/chromium/issues/detail?id=470258\n// for the description of the bug (it existed in older Chrome versions as well).\njQuery.each( {\n\tmouseenter: \"mouseover\",\n\tmouseleave: \"mouseout\",\n\tpointerenter: \"pointerover\",\n\tpointerleave: \"pointerout\"\n}, function( orig, fix ) {\n\tjQuery.event.special[ orig ] = {\n\t\tdelegateType: fix,\n\t\tbindType: fix,\n\n\t\thandle: function( event ) {\n\t\t\tvar ret,\n\t\t\t\ttarget = this,\n\t\t\t\trelated = event.relatedTarget,\n\t\t\t\thandleObj = event.handleObj;\n\n\t\t\t// For mouseenter/leave call the handler if related is outside the target.\n\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\n\t\t\tif ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {\n\t\t\t\tevent.type = handleObj.origType;\n\t\t\t\tret = handleObj.handler.apply( this, arguments );\n\t\t\t\tevent.type = fix;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t};\n} );\n\njQuery.fn.extend( {\n\n\ton: function( types, selector, data, fn ) {\n\t\treturn on( this, types, selector, data, fn );\n\t},\n\tone: function( types, selector, data, fn ) {\n\t\treturn on( this, types, selector, data, fn, 1 );\n\t},\n\toff: function( types, selector, fn ) {\n\t\tvar handleObj, type;\n\t\tif ( types && types.preventDefault && types.handleObj ) {\n\n\t\t\t// ( event )  dispatched jQuery.Event\n\t\t\thandleObj = types.handleObj;\n\t\t\tjQuery( types.delegateTarget ).off(\n\t\t\t\thandleObj.namespace ?\n\t\t\t\t\thandleObj.origType + \".\" + handleObj.namespace :\n\t\t\t\t\thandleObj.origType,\n\t\t\t\thandleObj.selector,\n\t\t\t\thandleObj.handler\n\t\t\t);\n\t\t\treturn this;\n\t\t}\n\t\tif ( typeof types === \"object\" ) {\n\n\t\t\t// ( types-object [, selector] )\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.off( type, selector, types[ type ] );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\tif ( selector === false || typeof selector === \"function\" ) {\n\n\t\t\t// ( types [, fn] )\n\t\t\tfn = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.remove( this, types, fn, selector );\n\t\t} );\n\t}\n} );\n\n\nvar\n\n\t// Support: IE <=10 - 11, Edge 12 - 13 only\n\t// In IE/Edge using regex groups here causes severe slowdowns.\n\t// See https://connect.microsoft.com/IE/feedback/details/1736512/\n\trnoInnerhtml = /<script|<style|<link/i,\n\n\t// checked=\"checked\" or checked\n\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n\trcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g;\n\n// Prefer a tbody over its parent table for containing new rows\nfunction manipulationTarget( elem, content ) {\n\tif ( nodeName( elem, \"table\" ) &&\n\t\tnodeName( content.nodeType !== 11 ? content : content.firstChild, \"tr\" ) ) {\n\n\t\treturn jQuery( elem ).children( \"tbody\" )[ 0 ] || elem;\n\t}\n\n\treturn elem;\n}\n\n// Replace/restore the type attribute of script elements for safe DOM manipulation\nfunction disableScript( elem ) {\n\telem.type = ( elem.getAttribute( \"type\" ) !== null ) + \"/\" + elem.type;\n\treturn elem;\n}\nfunction restoreScript( elem ) {\n\tif ( ( elem.type || \"\" ).slice( 0, 5 ) === \"true/\" ) {\n\t\telem.type = elem.type.slice( 5 );\n\t} else {\n\t\telem.removeAttribute( \"type\" );\n\t}\n\n\treturn elem;\n}\n\nfunction cloneCopyEvent( src, dest ) {\n\tvar i, l, type, pdataOld, udataOld, udataCur, events;\n\n\tif ( dest.nodeType !== 1 ) {\n\t\treturn;\n\t}\n\n\t// 1. Copy private data: events, handlers, etc.\n\tif ( dataPriv.hasData( src ) ) {\n\t\tpdataOld = dataPriv.get( src );\n\t\tevents = pdataOld.events;\n\n\t\tif ( events ) {\n\t\t\tdataPriv.remove( dest, \"handle events\" );\n\n\t\t\tfor ( type in events ) {\n\t\t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\n\t\t\t\t\tjQuery.event.add( dest, type, events[ type ][ i ] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// 2. Copy user data\n\tif ( dataUser.hasData( src ) ) {\n\t\tudataOld = dataUser.access( src );\n\t\tudataCur = jQuery.extend( {}, udataOld );\n\n\t\tdataUser.set( dest, udataCur );\n\t}\n}\n\n// Fix IE bugs, see support tests\nfunction fixInput( src, dest ) {\n\tvar nodeName = dest.nodeName.toLowerCase();\n\n\t// Fails to persist the checked state of a cloned checkbox or radio button.\n\tif ( nodeName === \"input\" && rcheckableType.test( src.type ) ) {\n\t\tdest.checked = src.checked;\n\n\t// Fails to return the selected option to the default selected state when cloning options\n\t} else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\n\t\tdest.defaultValue = src.defaultValue;\n\t}\n}\n\nfunction domManip( collection, args, callback, ignored ) {\n\n\t// Flatten any nested arrays\n\targs = flat( args );\n\n\tvar fragment, first, scripts, hasScripts, node, doc,\n\t\ti = 0,\n\t\tl = collection.length,\n\t\tiNoClone = l - 1,\n\t\tvalue = args[ 0 ],\n\t\tvalueIsFunction = isFunction( value );\n\n\t// We can't cloneNode fragments that contain checked, in WebKit\n\tif ( valueIsFunction ||\n\t\t\t( l > 1 && typeof value === \"string\" &&\n\t\t\t\t!support.checkClone && rchecked.test( value ) ) ) {\n\t\treturn collection.each( function( index ) {\n\t\t\tvar self = collection.eq( index );\n\t\t\tif ( valueIsFunction ) {\n\t\t\t\targs[ 0 ] = value.call( this, index, self.html() );\n\t\t\t}\n\t\t\tdomManip( self, args, callback, ignored );\n\t\t} );\n\t}\n\n\tif ( l ) {\n\t\tfragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );\n\t\tfirst = fragment.firstChild;\n\n\t\tif ( fragment.childNodes.length === 1 ) {\n\t\t\tfragment = first;\n\t\t}\n\n\t\t// Require either new content or an interest in ignored elements to invoke the callback\n\t\tif ( first || ignored ) {\n\t\t\tscripts = jQuery.map( getAll( fragment, \"script\" ), disableScript );\n\t\t\thasScripts = scripts.length;\n\n\t\t\t// Use the original fragment for the last item\n\t\t\t// instead of the first because it can end up\n\t\t\t// being emptied incorrectly in certain situations (#8070).\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tnode = fragment;\n\n\t\t\t\tif ( i !== iNoClone ) {\n\t\t\t\t\tnode = jQuery.clone( node, true, true );\n\n\t\t\t\t\t// Keep references to cloned scripts for later restoration\n\t\t\t\t\tif ( hasScripts ) {\n\n\t\t\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\t\tjQuery.merge( scripts, getAll( node, \"script\" ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcallback.call( collection[ i ], node, i );\n\t\t\t}\n\n\t\t\tif ( hasScripts ) {\n\t\t\t\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\n\n\t\t\t\t// Reenable scripts\n\t\t\t\tjQuery.map( scripts, restoreScript );\n\n\t\t\t\t// Evaluate executable scripts on first document insertion\n\t\t\t\tfor ( i = 0; i < hasScripts; i++ ) {\n\t\t\t\t\tnode = scripts[ i ];\n\t\t\t\t\tif ( rscriptType.test( node.type || \"\" ) &&\n\t\t\t\t\t\t!dataPriv.access( node, \"globalEval\" ) &&\n\t\t\t\t\t\tjQuery.contains( doc, node ) ) {\n\n\t\t\t\t\t\tif ( node.src && ( node.type || \"\" ).toLowerCase()  !== \"module\" ) {\n\n\t\t\t\t\t\t\t// Optional AJAX dependency, but won't run scripts if not present\n\t\t\t\t\t\t\tif ( jQuery._evalUrl && !node.noModule ) {\n\t\t\t\t\t\t\t\tjQuery._evalUrl( node.src, {\n\t\t\t\t\t\t\t\t\tnonce: node.nonce || node.getAttribute( \"nonce\" )\n\t\t\t\t\t\t\t\t}, doc );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDOMEval( node.textContent.replace( rcleanScript, \"\" ), node, doc );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn collection;\n}\n\nfunction remove( elem, selector, keepData ) {\n\tvar node,\n\t\tnodes = selector ? jQuery.filter( selector, elem ) : elem,\n\t\ti = 0;\n\n\tfor ( ; ( node = nodes[ i ] ) != null; i++ ) {\n\t\tif ( !keepData && node.nodeType === 1 ) {\n\t\t\tjQuery.cleanData( getAll( node ) );\n\t\t}\n\n\t\tif ( node.parentNode ) {\n\t\t\tif ( keepData && isAttached( node ) ) {\n\t\t\t\tsetGlobalEval( getAll( node, \"script\" ) );\n\t\t\t}\n\t\t\tnode.parentNode.removeChild( node );\n\t\t}\n\t}\n\n\treturn elem;\n}\n\njQuery.extend( {\n\thtmlPrefilter: function( html ) {\n\t\treturn html;\n\t},\n\n\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\n\t\tvar i, l, srcElements, destElements,\n\t\t\tclone = elem.cloneNode( true ),\n\t\t\tinPage = isAttached( elem );\n\n\t\t// Fix IE cloning issues\n\t\tif ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&\n\t\t\t\t!jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2\n\t\t\tdestElements = getAll( clone );\n\t\t\tsrcElements = getAll( elem );\n\n\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\tfixInput( srcElements[ i ], destElements[ i ] );\n\t\t\t}\n\t\t}\n\n\t\t// Copy the events from the original to the clone\n\t\tif ( dataAndEvents ) {\n\t\t\tif ( deepDataAndEvents ) {\n\t\t\t\tsrcElements = srcElements || getAll( elem );\n\t\t\t\tdestElements = destElements || getAll( clone );\n\n\t\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\t\tcloneCopyEvent( srcElements[ i ], destElements[ i ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcloneCopyEvent( elem, clone );\n\t\t\t}\n\t\t}\n\n\t\t// Preserve script evaluation history\n\t\tdestElements = getAll( clone, \"script\" );\n\t\tif ( destElements.length > 0 ) {\n\t\t\tsetGlobalEval( destElements, !inPage && getAll( elem, \"script\" ) );\n\t\t}\n\n\t\t// Return the cloned set\n\t\treturn clone;\n\t},\n\n\tcleanData: function( elems ) {\n\t\tvar data, elem, type,\n\t\t\tspecial = jQuery.event.special,\n\t\t\ti = 0;\n\n\t\tfor ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {\n\t\t\tif ( acceptData( elem ) ) {\n\t\t\t\tif ( ( data = elem[ dataPriv.expando ] ) ) {\n\t\t\t\t\tif ( data.events ) {\n\t\t\t\t\t\tfor ( type in data.events ) {\n\t\t\t\t\t\t\tif ( special[ type ] ) {\n\t\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\n\n\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove's overhead\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\telem[ dataPriv.expando ] = undefined;\n\t\t\t\t}\n\t\t\t\tif ( elem[ dataUser.expando ] ) {\n\n\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\telem[ dataUser.expando ] = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n} );\n\njQuery.fn.extend( {\n\tdetach: function( selector ) {\n\t\treturn remove( this, selector, true );\n\t},\n\n\tremove: function( selector ) {\n\t\treturn remove( this, selector );\n\t},\n\n\ttext: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\treturn value === undefined ?\n\t\t\t\tjQuery.text( this ) :\n\t\t\t\tthis.empty().each( function() {\n\t\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\t\t\tthis.textContent = value;\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t}, null, value, arguments.length );\n\t},\n\n\tappend: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.appendChild( elem );\n\t\t\t}\n\t\t} );\n\t},\n\n\tprepend: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.insertBefore( elem, target.firstChild );\n\t\t\t}\n\t\t} );\n\t},\n\n\tbefore: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this );\n\t\t\t}\n\t\t} );\n\t},\n\n\tafter: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n\t\t\t}\n\t\t} );\n\t},\n\n\tempty: function() {\n\t\tvar elem,\n\t\t\ti = 0;\n\n\t\tfor ( ; ( elem = this[ i ] ) != null; i++ ) {\n\t\t\tif ( elem.nodeType === 1 ) {\n\n\t\t\t\t// Prevent memory leaks\n\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\n\t\t\t\t// Remove any remaining nodes\n\t\t\t\telem.textContent = \"\";\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tclone: function( dataAndEvents, deepDataAndEvents ) {\n\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\n\t\treturn this.map( function() {\n\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n\t\t} );\n\t},\n\n\thtml: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\tvar elem = this[ 0 ] || {},\n\t\t\t\ti = 0,\n\t\t\t\tl = this.length;\n\n\t\t\tif ( value === undefined && elem.nodeType === 1 ) {\n\t\t\t\treturn elem.innerHTML;\n\t\t\t}\n\n\t\t\t// See if we can take a shortcut and just use innerHTML\n\t\t\tif ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\n\t\t\t\t!wrapMap[ ( rtagName.exec( value ) || [ \"\", \"\" ] )[ 1 ].toLowerCase() ] ) {\n\n\t\t\t\tvalue = jQuery.htmlPrefilter( value );\n\n\t\t\t\ttry {\n\t\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\t\telem = this[ i ] || {};\n\n\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\t\t\t\t\t\telem.innerHTML = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telem = 0;\n\n\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n\t\t\t\t} catch ( e ) {}\n\t\t\t}\n\n\t\t\tif ( elem ) {\n\t\t\t\tthis.empty().append( value );\n\t\t\t}\n\t\t}, null, value, arguments.length );\n\t},\n\n\treplaceWith: function() {\n\t\tvar ignored = [];\n\n\t\t// Make the changes, replacing each non-ignored context element with the new content\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tvar parent = this.parentNode;\n\n\t\t\tif ( jQuery.inArray( this, ignored ) < 0 ) {\n\t\t\t\tjQuery.cleanData( getAll( this ) );\n\t\t\t\tif ( parent ) {\n\t\t\t\t\tparent.replaceChild( elem, this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Force callback invocation\n\t\t}, ignored );\n\t}\n} );\n\njQuery.each( {\n\tappendTo: \"append\",\n\tprependTo: \"prepend\",\n\tinsertBefore: \"before\",\n\tinsertAfter: \"after\",\n\treplaceAll: \"replaceWith\"\n}, function( name, original ) {\n\tjQuery.fn[ name ] = function( selector ) {\n\t\tvar elems,\n\t\t\tret = [],\n\t\t\tinsert = jQuery( selector ),\n\t\t\tlast = insert.length - 1,\n\t\t\ti = 0;\n\n\t\tfor ( ; i <= last; i++ ) {\n\t\t\telems = i === last ? this : this.clone( true );\n\t\t\tjQuery( insert[ i ] )[ original ]( elems );\n\n\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t// .get() because push.apply(_, arraylike) throws on ancient WebKit\n\t\t\tpush.apply( ret, elems.get() );\n\t\t}\n\n\t\treturn this.pushStack( ret );\n\t};\n} );\nvar rnumnonpx = new RegExp( \"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\" );\n\nvar getStyles = function( elem ) {\n\n\t\t// Support: IE <=11 only, Firefox <=30 (#15098, #14150)\n\t\t// IE throws on elements created in popups\n\t\t// FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n\t\tvar view = elem.ownerDocument.defaultView;\n\n\t\tif ( !view || !view.opener ) {\n\t\t\tview = window;\n\t\t}\n\n\t\treturn view.getComputedStyle( elem );\n\t};\n\nvar swap = function( elem, options, callback ) {\n\tvar ret, name,\n\t\told = {};\n\n\t// Remember the old values, and insert the new ones\n\tfor ( name in options ) {\n\t\told[ name ] = elem.style[ name ];\n\t\telem.style[ name ] = options[ name ];\n\t}\n\n\tret = callback.call( elem );\n\n\t// Revert the old values\n\tfor ( name in options ) {\n\t\telem.style[ name ] = old[ name ];\n\t}\n\n\treturn ret;\n};\n\n\nvar rboxStyle = new RegExp( cssExpand.join( \"|\" ), \"i\" );\n\n\n\n( function() {\n\n\t// Executing both pixelPosition & boxSizingReliable tests require only one layout\n\t// so they're executed at the same time to save the second computation.\n\tfunction computeStyleTests() {\n\n\t\t// This is a singleton, we need to execute it only once\n\t\tif ( !div ) {\n\t\t\treturn;\n\t\t}\n\n\t\tcontainer.style.cssText = \"position:absolute;left:-11111px;width:60px;\" +\n\t\t\t\"margin-top:1px;padding:0;border:0\";\n\t\tdiv.style.cssText =\n\t\t\t\"position:relative;display:block;box-sizing:border-box;overflow:scroll;\" +\n\t\t\t\"margin:auto;border:1px;padding:1px;\" +\n\t\t\t\"width:60%;top:1%\";\n\t\tdocumentElement.appendChild( container ).appendChild( div );\n\n\t\tvar divStyle = window.getComputedStyle( div );\n\t\tpixelPositionVal = divStyle.top !== \"1%\";\n\n\t\t// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44\n\t\treliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;\n\n\t\t// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3\n\t\t// Some styles come back with percentage values, even though they shouldn't\n\t\tdiv.style.right = \"60%\";\n\t\tpixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;\n\n\t\t// Support: IE 9 - 11 only\n\t\t// Detect misreporting of content dimensions for box-sizing:border-box elements\n\t\tboxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;\n\n\t\t// Support: IE 9 only\n\t\t// Detect overflow:scroll screwiness (gh-3699)\n\t\t// Support: Chrome <=64\n\t\t// Don't get tricked when zoom affects offsetWidth (gh-4029)\n\t\tdiv.style.position = \"absolute\";\n\t\tscrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;\n\n\t\tdocumentElement.removeChild( container );\n\n\t\t// Nullify the div so it wouldn't be stored in the memory and\n\t\t// it will also be a sign that checks already performed\n\t\tdiv = null;\n\t}\n\n\tfunction roundPixelMeasures( measure ) {\n\t\treturn Math.round( parseFloat( measure ) );\n\t}\n\n\tvar pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,\n\t\treliableTrDimensionsVal, reliableMarginLeftVal,\n\t\tcontainer = document.createElement( \"div\" ),\n\t\tdiv = document.createElement( \"div\" );\n\n\t// Finish early in limited (non-browser) environments\n\tif ( !div.style ) {\n\t\treturn;\n\t}\n\n\t// Support: IE <=9 - 11 only\n\t// Style of cloned element affects source element cloned (#8908)\n\tdiv.style.backgroundClip = \"content-box\";\n\tdiv.cloneNode( true ).style.backgroundClip = \"\";\n\tsupport.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n\n\tjQuery.extend( support, {\n\t\tboxSizingReliable: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn boxSizingReliableVal;\n\t\t},\n\t\tpixelBoxStyles: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn pixelBoxStylesVal;\n\t\t},\n\t\tpixelPosition: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn pixelPositionVal;\n\t\t},\n\t\treliableMarginLeft: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn reliableMarginLeftVal;\n\t\t},\n\t\tscrollboxSize: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn scrollboxSizeVal;\n\t\t},\n\n\t\t// Support: IE 9 - 11+, Edge 15 - 18+\n\t\t// IE/Edge misreport `getComputedStyle` of table rows with width/height\n\t\t// set in CSS while `offset*` properties report correct values.\n\t\t// Behavior in IE 9 is more subtle than in newer versions & it passes\n\t\t// some versions of this test; make sure not to make it pass there!\n\t\t//\n\t\t// Support: Firefox 70+\n\t\t// Only Firefox includes border widths\n\t\t// in computed dimensions. (gh-4529)\n\t\treliableTrDimensions: function() {\n\t\t\tvar table, tr, trChild, trStyle;\n\t\t\tif ( reliableTrDimensionsVal == null ) {\n\t\t\t\ttable = document.createElement( \"table\" );\n\t\t\t\ttr = document.createElement( \"tr\" );\n\t\t\t\ttrChild = document.createElement( \"div\" );\n\n\t\t\t\ttable.style.cssText = \"position:absolute;left:-11111px;border-collapse:separate\";\n\t\t\t\ttr.style.cssText = \"border:1px solid\";\n\n\t\t\t\t// Support: Chrome 86+\n\t\t\t\t// Height set through cssText does not get applied.\n\t\t\t\t// Computed height then comes back as 0.\n\t\t\t\ttr.style.height = \"1px\";\n\t\t\t\ttrChild.style.height = \"9px\";\n\n\t\t\t\t// Support: Android 8 Chrome 86+\n\t\t\t\t// In our bodyBackground.html iframe,\n\t\t\t\t// display for all div elements is set to \"inline\",\n\t\t\t\t// which causes a problem only in Android 8 Chrome 86.\n\t\t\t\t// Ensuring the div is display: block\n\t\t\t\t// gets around this issue.\n\t\t\t\ttrChild.style.display = \"block\";\n\n\t\t\t\tdocumentElement\n\t\t\t\t\t.appendChild( table )\n\t\t\t\t\t.appendChild( tr )\n\t\t\t\t\t.appendChild( trChild );\n\n\t\t\t\ttrStyle = window.getComputedStyle( tr );\n\t\t\t\treliableTrDimensionsVal = ( parseInt( trStyle.height, 10 ) +\n\t\t\t\t\tparseInt( trStyle.borderTopWidth, 10 ) +\n\t\t\t\t\tparseInt( trStyle.borderBottomWidth, 10 ) ) === tr.offsetHeight;\n\n\t\t\t\tdocumentElement.removeChild( table );\n\t\t\t}\n\t\t\treturn reliableTrDimensionsVal;\n\t\t}\n\t} );\n} )();\n\n\nfunction curCSS( elem, name, computed ) {\n\tvar width, minWidth, maxWidth, ret,\n\n\t\t// Support: Firefox 51+\n\t\t// Retrieving style before computed somehow\n\t\t// fixes an issue with getting wrong values\n\t\t// on detached elements\n\t\tstyle = elem.style;\n\n\tcomputed = computed || getStyles( elem );\n\n\t// getPropertyValue is needed for:\n\t//   .css('filter') (IE 9 only, #12537)\n\t//   .css('--customProperty) (#3144)\n\tif ( computed ) {\n\t\tret = computed.getPropertyValue( name ) || computed[ name ];\n\n\t\tif ( ret === \"\" && !isAttached( elem ) ) {\n\t\t\tret = jQuery.style( elem, name );\n\t\t}\n\n\t\t// A tribute to the \"awesome hack by Dean Edwards\"\n\t\t// Android Browser returns percentage for some values,\n\t\t// but width seems to be reliably pixels.\n\t\t// This is against the CSSOM draft spec:\n\t\t// https://drafts.csswg.org/cssom/#resolved-values\n\t\tif ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {\n\n\t\t\t// Remember the original values\n\t\t\twidth = style.width;\n\t\t\tminWidth = style.minWidth;\n\t\t\tmaxWidth = style.maxWidth;\n\n\t\t\t// Put in the new values to get a computed value out\n\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n\t\t\tret = computed.width;\n\n\t\t\t// Revert the changed values\n\t\t\tstyle.width = width;\n\t\t\tstyle.minWidth = minWidth;\n\t\t\tstyle.maxWidth = maxWidth;\n\t\t}\n\t}\n\n\treturn ret !== undefined ?\n\n\t\t// Support: IE <=9 - 11 only\n\t\t// IE returns zIndex value as an integer.\n\t\tret + \"\" :\n\t\tret;\n}\n\n\nfunction addGetHookIf( conditionFn, hookFn ) {\n\n\t// Define the hook, we'll check on the first run if it's really needed.\n\treturn {\n\t\tget: function() {\n\t\t\tif ( conditionFn() ) {\n\n\t\t\t\t// Hook not needed (or it's not possible to use it due\n\t\t\t\t// to missing dependency), remove it.\n\t\t\t\tdelete this.get;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Hook needed; redefine it so that the support test is not executed again.\n\t\t\treturn ( this.get = hookFn ).apply( this, arguments );\n\t\t}\n\t};\n}\n\n\nvar cssPrefixes = [ \"Webkit\", \"Moz\", \"ms\" ],\n\temptyStyle = document.createElement( \"div\" ).style,\n\tvendorProps = {};\n\n// Return a vendor-prefixed property or undefined\nfunction vendorPropName( name ) {\n\n\t// Check for vendor prefixed names\n\tvar capName = name[ 0 ].toUpperCase() + name.slice( 1 ),\n\t\ti = cssPrefixes.length;\n\n\twhile ( i-- ) {\n\t\tname = cssPrefixes[ i ] + capName;\n\t\tif ( name in emptyStyle ) {\n\t\t\treturn name;\n\t\t}\n\t}\n}\n\n// Return a potentially-mapped jQuery.cssProps or vendor prefixed property\nfunction finalPropName( name ) {\n\tvar final = jQuery.cssProps[ name ] || vendorProps[ name ];\n\n\tif ( final ) {\n\t\treturn final;\n\t}\n\tif ( name in emptyStyle ) {\n\t\treturn name;\n\t}\n\treturn vendorProps[ name ] = vendorPropName( name ) || name;\n}\n\n\nvar\n\n\t// Swappable if display is none or starts with table\n\t// except \"table\", \"table-cell\", or \"table-caption\"\n\t// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\n\trcustomProp = /^--/,\n\tcssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n\tcssNormalTransform = {\n\t\tletterSpacing: \"0\",\n\t\tfontWeight: \"400\"\n\t};\n\nfunction setPositiveNumber( _elem, value, subtract ) {\n\n\t// Any relative (+/-) values have already been\n\t// normalized at this point\n\tvar matches = rcssNum.exec( value );\n\treturn matches ?\n\n\t\t// Guard against undefined \"subtract\", e.g., when used as in cssHooks\n\t\tMath.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || \"px\" ) :\n\t\tvalue;\n}\n\nfunction boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {\n\tvar i = dimension === \"width\" ? 1 : 0,\n\t\textra = 0,\n\t\tdelta = 0;\n\n\t// Adjustment may not be necessary\n\tif ( box === ( isBorderBox ? \"border\" : \"content\" ) ) {\n\t\treturn 0;\n\t}\n\n\tfor ( ; i < 4; i += 2 ) {\n\n\t\t// Both box models exclude margin\n\t\tif ( box === \"margin\" ) {\n\t\t\tdelta += jQuery.css( elem, box + cssExpand[ i ], true, styles );\n\t\t}\n\n\t\t// If we get here with a content-box, we're seeking \"padding\" or \"border\" or \"margin\"\n\t\tif ( !isBorderBox ) {\n\n\t\t\t// Add padding\n\t\t\tdelta += jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\n\t\t\t// For \"border\" or \"margin\", add border\n\t\t\tif ( box !== \"padding\" ) {\n\t\t\t\tdelta += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\n\t\t\t// But still keep track of it otherwise\n\t\t\t} else {\n\t\t\t\textra += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\n\t\t// If we get here with a border-box (content + padding + border), we're seeking \"content\" or\n\t\t// \"padding\" or \"margin\"\n\t\t} else {\n\n\t\t\t// For \"content\", subtract padding\n\t\t\tif ( box === \"content\" ) {\n\t\t\t\tdelta -= jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\t\t\t}\n\n\t\t\t// For \"content\" or \"padding\", subtract border\n\t\t\tif ( box !== \"margin\" ) {\n\t\t\t\tdelta -= jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Account for positive content-box scroll gutter when requested by providing computedVal\n\tif ( !isBorderBox && computedVal >= 0 ) {\n\n\t\t// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border\n\t\t// Assuming integer scroll gutter, subtract the rest and round down\n\t\tdelta += Math.max( 0, Math.ceil(\n\t\t\telem[ \"offset\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -\n\t\t\tcomputedVal -\n\t\t\tdelta -\n\t\t\textra -\n\t\t\t0.5\n\n\t\t// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter\n\t\t// Use an explicit zero to avoid NaN (gh-3964)\n\t\t) ) || 0;\n\t}\n\n\treturn delta;\n}\n\nfunction getWidthOrHeight( elem, dimension, extra ) {\n\n\t// Start with computed style\n\tvar styles = getStyles( elem ),\n\n\t\t// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).\n\t\t// Fake content-box until we know it's needed to know the true value.\n\t\tboxSizingNeeded = !support.boxSizingReliable() || extra,\n\t\tisBorderBox = boxSizingNeeded &&\n\t\t\tjQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n\t\tvalueIsBorderBox = isBorderBox,\n\n\t\tval = curCSS( elem, dimension, styles ),\n\t\toffsetProp = \"offset\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );\n\n\t// Support: Firefox <=54\n\t// Return a confounding non-pixel value or feign ignorance, as appropriate.\n\tif ( rnumnonpx.test( val ) ) {\n\t\tif ( !extra ) {\n\t\t\treturn val;\n\t\t}\n\t\tval = \"auto\";\n\t}\n\n\n\t// Support: IE 9 - 11 only\n\t// Use offsetWidth/offsetHeight for when box sizing is unreliable.\n\t// In those cases, the computed value can be trusted to be border-box.\n\tif ( ( !support.boxSizingReliable() && isBorderBox ||\n\n\t\t// Support: IE 10 - 11+, Edge 15 - 18+\n\t\t// IE/Edge misreport `getComputedStyle` of table rows with width/height\n\t\t// set in CSS while `offset*` properties report correct values.\n\t\t// Interestingly, in some cases IE 9 doesn't suffer from this issue.\n\t\t!support.reliableTrDimensions() && nodeName( elem, \"tr\" ) ||\n\n\t\t// Fall back to offsetWidth/offsetHeight when value is \"auto\"\n\t\t// This happens for inline elements with no explicit setting (gh-3571)\n\t\tval === \"auto\" ||\n\n\t\t// Support: Android <=4.1 - 4.3 only\n\t\t// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)\n\t\t!parseFloat( val ) && jQuery.css( elem, \"display\", false, styles ) === \"inline\" ) &&\n\n\t\t// Make sure the element is visible & connected\n\t\telem.getClientRects().length ) {\n\n\t\tisBorderBox = jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\";\n\n\t\t// Where available, offsetWidth/offsetHeight approximate border box dimensions.\n\t\t// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the\n\t\t// retrieved value as a content box dimension.\n\t\tvalueIsBorderBox = offsetProp in elem;\n\t\tif ( valueIsBorderBox ) {\n\t\t\tval = elem[ offsetProp ];\n\t\t}\n\t}\n\n\t// Normalize \"\" and auto\n\tval = parseFloat( val ) || 0;\n\n\t// Adjust for the element's box model\n\treturn ( val +\n\t\tboxModelAdjustment(\n\t\t\telem,\n\t\t\tdimension,\n\t\t\textra || ( isBorderBox ? \"border\" : \"content\" ),\n\t\t\tvalueIsBorderBox,\n\t\t\tstyles,\n\n\t\t\t// Provide the current computed size to request scroll gutter calculation (gh-3589)\n\t\t\tval\n\t\t)\n\t) + \"px\";\n}\n\njQuery.extend( {\n\n\t// Add in style property hooks for overriding the default\n\t// behavior of getting and setting a style property\n\tcssHooks: {\n\t\topacity: {\n\t\t\tget: function( elem, computed ) {\n\t\t\t\tif ( computed ) {\n\n\t\t\t\t\t// We should always get a number back from opacity\n\t\t\t\t\tvar ret = curCSS( elem, \"opacity\" );\n\t\t\t\t\treturn ret === \"\" ? \"1\" : ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t// Don't automatically add \"px\" to these possibly-unitless properties\n\tcssNumber: {\n\t\t\"animationIterationCount\": true,\n\t\t\"columnCount\": true,\n\t\t\"fillOpacity\": true,\n\t\t\"flexGrow\": true,\n\t\t\"flexShrink\": true,\n\t\t\"fontWeight\": true,\n\t\t\"gridArea\": true,\n\t\t\"gridColumn\": true,\n\t\t\"gridColumnEnd\": true,\n\t\t\"gridColumnStart\": true,\n\t\t\"gridRow\": true,\n\t\t\"gridRowEnd\": true,\n\t\t\"gridRowStart\": true,\n\t\t\"lineHeight\": true,\n\t\t\"opacity\": true,\n\t\t\"order\": true,\n\t\t\"orphans\": true,\n\t\t\"widows\": true,\n\t\t\"zIndex\": true,\n\t\t\"zoom\": true\n\t},\n\n\t// Add in properties whose names you wish to fix before\n\t// setting or getting the value\n\tcssProps: {},\n\n\t// Get and set the style property on a DOM Node\n\tstyle: function( elem, name, value, extra ) {\n\n\t\t// Don't set styles on text and comment nodes\n\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Make sure that we're working with the right name\n\t\tvar ret, type, hooks,\n\t\t\torigName = camelCase( name ),\n\t\t\tisCustomProp = rcustomProp.test( name ),\n\t\t\tstyle = elem.style;\n\n\t\t// Make sure that we're working with the right name. We don't\n\t\t// want to query the value if it is a CSS custom property\n\t\t// since they are user-defined.\n\t\tif ( !isCustomProp ) {\n\t\t\tname = finalPropName( origName );\n\t\t}\n\n\t\t// Gets hook for the prefixed version, then unprefixed version\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// Check if we're setting a value\n\t\tif ( value !== undefined ) {\n\t\t\ttype = typeof value;\n\n\t\t\t// Convert \"+=\" or \"-=\" to relative numbers (#7345)\n\t\t\tif ( type === \"string\" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {\n\t\t\t\tvalue = adjustCSS( elem, name, ret );\n\n\t\t\t\t// Fixes bug #9237\n\t\t\t\ttype = \"number\";\n\t\t\t}\n\n\t\t\t// Make sure that null and NaN values aren't set (#7116)\n\t\t\tif ( value == null || value !== value ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If a number was passed in, add the unit (except for certain CSS properties)\n\t\t\t// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append\n\t\t\t// \"px\" to a few hardcoded values.\n\t\t\tif ( type === \"number\" && !isCustomProp ) {\n\t\t\t\tvalue += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? \"\" : \"px\" );\n\t\t\t}\n\n\t\t\t// background-* props affect original clone's values\n\t\t\tif ( !support.clearCloneStyle && value === \"\" && name.indexOf( \"background\" ) === 0 ) {\n\t\t\t\tstyle[ name ] = \"inherit\";\n\t\t\t}\n\n\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n\t\t\tif ( !hooks || !( \"set\" in hooks ) ||\n\t\t\t\t( value = hooks.set( elem, value, extra ) ) !== undefined ) {\n\n\t\t\t\tif ( isCustomProp ) {\n\t\t\t\t\tstyle.setProperty( name, value );\n\t\t\t\t} else {\n\t\t\t\t\tstyle[ name ] = value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// If a hook was provided get the non-computed value from there\n\t\t\tif ( hooks && \"get\" in hooks &&\n\t\t\t\t( ret = hooks.get( elem, false, extra ) ) !== undefined ) {\n\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t// Otherwise just get the value from the style object\n\t\t\treturn style[ name ];\n\t\t}\n\t},\n\n\tcss: function( elem, name, extra, styles ) {\n\t\tvar val, num, hooks,\n\t\t\torigName = camelCase( name ),\n\t\t\tisCustomProp = rcustomProp.test( name );\n\n\t\t// Make sure that we're working with the right name. We don't\n\t\t// want to modify the value if it is a CSS custom property\n\t\t// since they are user-defined.\n\t\tif ( !isCustomProp ) {\n\t\t\tname = finalPropName( origName );\n\t\t}\n\n\t\t// Try prefixed name followed by the unprefixed name\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// If a hook was provided get the computed value from there\n\t\tif ( hooks && \"get\" in hooks ) {\n\t\t\tval = hooks.get( elem, true, extra );\n\t\t}\n\n\t\t// Otherwise, if a way to get the computed value exists, use that\n\t\tif ( val === undefined ) {\n\t\t\tval = curCSS( elem, name, styles );\n\t\t}\n\n\t\t// Convert \"normal\" to computed value\n\t\tif ( val === \"normal\" && name in cssNormalTransform ) {\n\t\t\tval = cssNormalTransform[ name ];\n\t\t}\n\n\t\t// Make numeric if forced or a qualifier was provided and val looks numeric\n\t\tif ( extra === \"\" || extra ) {\n\t\t\tnum = parseFloat( val );\n\t\t\treturn extra === true || isFinite( num ) ? num || 0 : val;\n\t\t}\n\n\t\treturn val;\n\t}\n} );\n\njQuery.each( [ \"height\", \"width\" ], function( _i, dimension ) {\n\tjQuery.cssHooks[ dimension ] = {\n\t\tget: function( elem, computed, extra ) {\n\t\t\tif ( computed ) {\n\n\t\t\t\t// Certain elements can have dimension info if we invisibly show them\n\t\t\t\t// but it must have a current display style that would benefit\n\t\t\t\treturn rdisplayswap.test( jQuery.css( elem, \"display\" ) ) &&\n\n\t\t\t\t\t// Support: Safari 8+\n\t\t\t\t\t// Table columns in Safari have non-zero offsetWidth & zero\n\t\t\t\t\t// getBoundingClientRect().width unless display is changed.\n\t\t\t\t\t// Support: IE <=11 only\n\t\t\t\t\t// Running getBoundingClientRect on a disconnected node\n\t\t\t\t\t// in IE throws an error.\n\t\t\t\t\t( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?\n\t\t\t\t\tswap( elem, cssShow, function() {\n\t\t\t\t\t\treturn getWidthOrHeight( elem, dimension, extra );\n\t\t\t\t\t} ) :\n\t\t\t\t\tgetWidthOrHeight( elem, dimension, extra );\n\t\t\t}\n\t\t},\n\n\t\tset: function( elem, value, extra ) {\n\t\t\tvar matches,\n\t\t\t\tstyles = getStyles( elem ),\n\n\t\t\t\t// Only read styles.position if the test has a chance to fail\n\t\t\t\t// to avoid forcing a reflow.\n\t\t\t\tscrollboxSizeBuggy = !support.scrollboxSize() &&\n\t\t\t\t\tstyles.position === \"absolute\",\n\n\t\t\t\t// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)\n\t\t\t\tboxSizingNeeded = scrollboxSizeBuggy || extra,\n\t\t\t\tisBorderBox = boxSizingNeeded &&\n\t\t\t\t\tjQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n\t\t\t\tsubtract = extra ?\n\t\t\t\t\tboxModelAdjustment(\n\t\t\t\t\t\telem,\n\t\t\t\t\t\tdimension,\n\t\t\t\t\t\textra,\n\t\t\t\t\t\tisBorderBox,\n\t\t\t\t\t\tstyles\n\t\t\t\t\t) :\n\t\t\t\t\t0;\n\n\t\t\t// Account for unreliable border-box dimensions by comparing offset* to computed and\n\t\t\t// faking a content-box to get border and padding (gh-3699)\n\t\t\tif ( isBorderBox && scrollboxSizeBuggy ) {\n\t\t\t\tsubtract -= Math.ceil(\n\t\t\t\t\telem[ \"offset\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -\n\t\t\t\t\tparseFloat( styles[ dimension ] ) -\n\t\t\t\t\tboxModelAdjustment( elem, dimension, \"border\", false, styles ) -\n\t\t\t\t\t0.5\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Convert to pixels if value adjustment is needed\n\t\t\tif ( subtract && ( matches = rcssNum.exec( value ) ) &&\n\t\t\t\t( matches[ 3 ] || \"px\" ) !== \"px\" ) {\n\n\t\t\t\telem.style[ dimension ] = value;\n\t\t\t\tvalue = jQuery.css( elem, dimension );\n\t\t\t}\n\n\t\t\treturn setPositiveNumber( elem, value, subtract );\n\t\t}\n\t};\n} );\n\njQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,\n\tfunction( elem, computed ) {\n\t\tif ( computed ) {\n\t\t\treturn ( parseFloat( curCSS( elem, \"marginLeft\" ) ) ||\n\t\t\t\telem.getBoundingClientRect().left -\n\t\t\t\t\tswap( elem, { marginLeft: 0 }, function() {\n\t\t\t\t\t\treturn elem.getBoundingClientRect().left;\n\t\t\t\t\t} )\n\t\t\t) + \"px\";\n\t\t}\n\t}\n);\n\n// These hooks are used by animate to expand properties\njQuery.each( {\n\tmargin: \"\",\n\tpadding: \"\",\n\tborder: \"Width\"\n}, function( prefix, suffix ) {\n\tjQuery.cssHooks[ prefix + suffix ] = {\n\t\texpand: function( value ) {\n\t\t\tvar i = 0,\n\t\t\t\texpanded = {},\n\n\t\t\t\t// Assumes a single number if not a string\n\t\t\t\tparts = typeof value === \"string\" ? value.split( \" \" ) : [ value ];\n\n\t\t\tfor ( ; i < 4; i++ ) {\n\t\t\t\texpanded[ prefix + cssExpand[ i ] + suffix ] =\n\t\t\t\t\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n\t\t\t}\n\n\t\t\treturn expanded;\n\t\t}\n\t};\n\n\tif ( prefix !== \"margin\" ) {\n\t\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n\t}\n} );\n\njQuery.fn.extend( {\n\tcss: function( name, value ) {\n\t\treturn access( this, function( elem, name, value ) {\n\t\t\tvar styles, len,\n\t\t\t\tmap = {},\n\t\t\t\ti = 0;\n\n\t\t\tif ( Array.isArray( name ) ) {\n\t\t\t\tstyles = getStyles( elem );\n\t\t\t\tlen = name.length;\n\n\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n\t\t\t\t}\n\n\t\t\t\treturn map;\n\t\t\t}\n\n\t\t\treturn value !== undefined ?\n\t\t\t\tjQuery.style( elem, name, value ) :\n\t\t\t\tjQuery.css( elem, name );\n\t\t}, name, value, arguments.length > 1 );\n\t}\n} );\n\n\nfunction Tween( elem, options, prop, end, easing ) {\n\treturn new Tween.prototype.init( elem, options, prop, end, easing );\n}\njQuery.Tween = Tween;\n\nTween.prototype = {\n\tconstructor: Tween,\n\tinit: function( elem, options, prop, end, easing, unit ) {\n\t\tthis.elem = elem;\n\t\tthis.prop = prop;\n\t\tthis.easing = easing || jQuery.easing._default;\n\t\tthis.options = options;\n\t\tthis.start = this.now = this.cur();\n\t\tthis.end = end;\n\t\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\n\t},\n\tcur: function() {\n\t\tvar hooks = Tween.propHooks[ this.prop ];\n\n\t\treturn hooks && hooks.get ?\n\t\t\thooks.get( this ) :\n\t\t\tTween.propHooks._default.get( this );\n\t},\n\trun: function( percent ) {\n\t\tvar eased,\n\t\t\thooks = Tween.propHooks[ this.prop ];\n\n\t\tif ( this.options.duration ) {\n\t\t\tthis.pos = eased = jQuery.easing[ this.easing ](\n\t\t\t\tpercent, this.options.duration * percent, 0, 1, this.options.duration\n\t\t\t);\n\t\t} else {\n\t\t\tthis.pos = eased = percent;\n\t\t}\n\t\tthis.now = ( this.end - this.start ) * eased + this.start;\n\n\t\tif ( this.options.step ) {\n\t\t\tthis.options.step.call( this.elem, this.now, this );\n\t\t}\n\n\t\tif ( hooks && hooks.set ) {\n\t\t\thooks.set( this );\n\t\t} else {\n\t\t\tTween.propHooks._default.set( this );\n\t\t}\n\t\treturn this;\n\t}\n};\n\nTween.prototype.init.prototype = Tween.prototype;\n\nTween.propHooks = {\n\t_default: {\n\t\tget: function( tween ) {\n\t\t\tvar result;\n\n\t\t\t// Use a property on the element directly when it is not a DOM element,\n\t\t\t// or when there is no matching style property that exists.\n\t\t\tif ( tween.elem.nodeType !== 1 ||\n\t\t\t\ttween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {\n\t\t\t\treturn tween.elem[ tween.prop ];\n\t\t\t}\n\n\t\t\t// Passing an empty string as a 3rd parameter to .css will automatically\n\t\t\t// attempt a parseFloat and fallback to a string if the parse fails.\n\t\t\t// Simple values such as \"10px\" are parsed to Float;\n\t\t\t// complex values such as \"rotate(1rad)\" are returned as-is.\n\t\t\tresult = jQuery.css( tween.elem, tween.prop, \"\" );\n\n\t\t\t// Empty strings, null, undefined and \"auto\" are converted to 0.\n\t\t\treturn !result || result === \"auto\" ? 0 : result;\n\t\t},\n\t\tset: function( tween ) {\n\n\t\t\t// Use step hook for back compat.\n\t\t\t// Use cssHook if its there.\n\t\t\t// Use .style if available and use plain properties where available.\n\t\t\tif ( jQuery.fx.step[ tween.prop ] ) {\n\t\t\t\tjQuery.fx.step[ tween.prop ]( tween );\n\t\t\t} else if ( tween.elem.nodeType === 1 && (\n\t\t\t\tjQuery.cssHooks[ tween.prop ] ||\n\t\t\t\t\ttween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {\n\t\t\t\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n\t\t\t} else {\n\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t\t}\n\t\t}\n\t}\n};\n\n// Support: IE <=9 only\n// Panic based approach to setting things on disconnected nodes\nTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n\tset: function( tween ) {\n\t\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\n\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t}\n\t}\n};\n\njQuery.easing = {\n\tlinear: function( p ) {\n\t\treturn p;\n\t},\n\tswing: function( p ) {\n\t\treturn 0.5 - Math.cos( p * Math.PI ) / 2;\n\t},\n\t_default: \"swing\"\n};\n\njQuery.fx = Tween.prototype.init;\n\n// Back compat <1.8 extension point\njQuery.fx.step = {};\n\n\n\n\nvar\n\tfxNow, inProgress,\n\trfxtypes = /^(?:toggle|show|hide)$/,\n\trrun = /queueHooks$/;\n\nfunction schedule() {\n\tif ( inProgress ) {\n\t\tif ( document.hidden === false && window.requestAnimationFrame ) {\n\t\t\twindow.requestAnimationFrame( schedule );\n\t\t} else {\n\t\t\twindow.setTimeout( schedule, jQuery.fx.interval );\n\t\t}\n\n\t\tjQuery.fx.tick();\n\t}\n}\n\n// Animations created synchronously will run synchronously\nfunction createFxNow() {\n\twindow.setTimeout( function() {\n\t\tfxNow = undefined;\n\t} );\n\treturn ( fxNow = Date.now() );\n}\n\n// Generate parameters to create a standard animation\nfunction genFx( type, includeWidth ) {\n\tvar which,\n\t\ti = 0,\n\t\tattrs = { height: type };\n\n\t// If we include width, step value is 1 to do all cssExpand values,\n\t// otherwise step value is 2 to skip over Left and Right\n\tincludeWidth = includeWidth ? 1 : 0;\n\tfor ( ; i < 4; i += 2 - includeWidth ) {\n\t\twhich = cssExpand[ i ];\n\t\tattrs[ \"margin\" + which ] = attrs[ \"padding\" + which ] = type;\n\t}\n\n\tif ( includeWidth ) {\n\t\tattrs.opacity = attrs.width = type;\n\t}\n\n\treturn attrs;\n}\n\nfunction createTween( value, prop, animation ) {\n\tvar tween,\n\t\tcollection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ \"*\" ] ),\n\t\tindex = 0,\n\t\tlength = collection.length;\n\tfor ( ; index < length; index++ ) {\n\t\tif ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {\n\n\t\t\t// We're done with this property\n\t\t\treturn tween;\n\t\t}\n\t}\n}\n\nfunction defaultPrefilter( elem, props, opts ) {\n\tvar prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,\n\t\tisBox = \"width\" in props || \"height\" in props,\n\t\tanim = this,\n\t\torig = {},\n\t\tstyle = elem.style,\n\t\thidden = elem.nodeType && isHiddenWithinTree( elem ),\n\t\tdataShow = dataPriv.get( elem, \"fxshow\" );\n\n\t// Queue-skipping animations hijack the fx hooks\n\tif ( !opts.queue ) {\n\t\thooks = jQuery._queueHooks( elem, \"fx\" );\n\t\tif ( hooks.unqueued == null ) {\n\t\t\thooks.unqueued = 0;\n\t\t\toldfire = hooks.empty.fire;\n\t\t\thooks.empty.fire = function() {\n\t\t\t\tif ( !hooks.unqueued ) {\n\t\t\t\t\toldfire();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\thooks.unqueued++;\n\n\t\tanim.always( function() {\n\n\t\t\t// Ensure the complete handler is called before this completes\n\t\t\tanim.always( function() {\n\t\t\t\thooks.unqueued--;\n\t\t\t\tif ( !jQuery.queue( elem, \"fx\" ).length ) {\n\t\t\t\t\thooks.empty.fire();\n\t\t\t\t}\n\t\t\t} );\n\t\t} );\n\t}\n\n\t// Detect show/hide animations\n\tfor ( prop in props ) {\n\t\tvalue = props[ prop ];\n\t\tif ( rfxtypes.test( value ) ) {\n\t\t\tdelete props[ prop ];\n\t\t\ttoggle = toggle || value === \"toggle\";\n\t\t\tif ( value === ( hidden ? \"hide\" : \"show\" ) ) {\n\n\t\t\t\t// Pretend to be hidden if this is a \"show\" and\n\t\t\t\t// there is still data from a stopped show/hide\n\t\t\t\tif ( value === \"show\" && dataShow && dataShow[ prop ] !== undefined ) {\n\t\t\t\t\thidden = true;\n\n\t\t\t\t// Ignore all other no-op show/hide data\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\n\t\t}\n\t}\n\n\t// Bail out if this is a no-op like .hide().hide()\n\tpropTween = !jQuery.isEmptyObject( props );\n\tif ( !propTween && jQuery.isEmptyObject( orig ) ) {\n\t\treturn;\n\t}\n\n\t// Restrict \"overflow\" and \"display\" styles during box animations\n\tif ( isBox && elem.nodeType === 1 ) {\n\n\t\t// Support: IE <=9 - 11, Edge 12 - 15\n\t\t// Record all 3 overflow attributes because IE does not infer the shorthand\n\t\t// from identically-valued overflowX and overflowY and Edge just mirrors\n\t\t// the overflowX value there.\n\t\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n\n\t\t// Identify a display type, preferring old show/hide data over the CSS cascade\n\t\trestoreDisplay = dataShow && dataShow.display;\n\t\tif ( restoreDisplay == null ) {\n\t\t\trestoreDisplay = dataPriv.get( elem, \"display\" );\n\t\t}\n\t\tdisplay = jQuery.css( elem, \"display\" );\n\t\tif ( display === \"none\" ) {\n\t\t\tif ( restoreDisplay ) {\n\t\t\t\tdisplay = restoreDisplay;\n\t\t\t} else {\n\n\t\t\t\t// Get nonempty value(s) by temporarily forcing visibility\n\t\t\t\tshowHide( [ elem ], true );\n\t\t\t\trestoreDisplay = elem.style.display || restoreDisplay;\n\t\t\t\tdisplay = jQuery.css( elem, \"display\" );\n\t\t\t\tshowHide( [ elem ] );\n\t\t\t}\n\t\t}\n\n\t\t// Animate inline elements as inline-block\n\t\tif ( display === \"inline\" || display === \"inline-block\" && restoreDisplay != null ) {\n\t\t\tif ( jQuery.css( elem, \"float\" ) === \"none\" ) {\n\n\t\t\t\t// Restore the original display value at the end of pure show/hide animations\n\t\t\t\tif ( !propTween ) {\n\t\t\t\t\tanim.done( function() {\n\t\t\t\t\t\tstyle.display = restoreDisplay;\n\t\t\t\t\t} );\n\t\t\t\t\tif ( restoreDisplay == null ) {\n\t\t\t\t\t\tdisplay = style.display;\n\t\t\t\t\t\trestoreDisplay = display === \"none\" ? \"\" : display;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstyle.display = \"inline-block\";\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( opts.overflow ) {\n\t\tstyle.overflow = \"hidden\";\n\t\tanim.always( function() {\n\t\t\tstyle.overflow = opts.overflow[ 0 ];\n\t\t\tstyle.overflowX = opts.overflow[ 1 ];\n\t\t\tstyle.overflowY = opts.overflow[ 2 ];\n\t\t} );\n\t}\n\n\t// Implement show/hide animations\n\tpropTween = false;\n\tfor ( prop in orig ) {\n\n\t\t// General show/hide setup for this element animation\n\t\tif ( !propTween ) {\n\t\t\tif ( dataShow ) {\n\t\t\t\tif ( \"hidden\" in dataShow ) {\n\t\t\t\t\thidden = dataShow.hidden;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdataShow = dataPriv.access( elem, \"fxshow\", { display: restoreDisplay } );\n\t\t\t}\n\n\t\t\t// Store hidden/visible for toggle so `.stop().toggle()` \"reverses\"\n\t\t\tif ( toggle ) {\n\t\t\t\tdataShow.hidden = !hidden;\n\t\t\t}\n\n\t\t\t// Show elements before animating them\n\t\t\tif ( hidden ) {\n\t\t\t\tshowHide( [ elem ], true );\n\t\t\t}\n\n\t\t\t/* eslint-disable no-loop-func */\n\n\t\t\tanim.done( function() {\n\n\t\t\t\t/* eslint-enable no-loop-func */\n\n\t\t\t\t// The final step of a \"hide\" animation is actually hiding the element\n\t\t\t\tif ( !hidden ) {\n\t\t\t\t\tshowHide( [ elem ] );\n\t\t\t\t}\n\t\t\t\tdataPriv.remove( elem, \"fxshow\" );\n\t\t\t\tfor ( prop in orig ) {\n\t\t\t\t\tjQuery.style( elem, prop, orig[ prop ] );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\n\t\t// Per-property setup\n\t\tpropTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\n\t\tif ( !( prop in dataShow ) ) {\n\t\t\tdataShow[ prop ] = propTween.start;\n\t\t\tif ( hidden ) {\n\t\t\t\tpropTween.end = propTween.start;\n\t\t\t\tpropTween.start = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction propFilter( props, specialEasing ) {\n\tvar index, name, easing, value, hooks;\n\n\t// camelCase, specialEasing and expand cssHook pass\n\tfor ( index in props ) {\n\t\tname = camelCase( index );\n\t\teasing = specialEasing[ name ];\n\t\tvalue = props[ index ];\n\t\tif ( Array.isArray( value ) ) {\n\t\t\teasing = value[ 1 ];\n\t\t\tvalue = props[ index ] = value[ 0 ];\n\t\t}\n\n\t\tif ( index !== name ) {\n\t\t\tprops[ name ] = value;\n\t\t\tdelete props[ index ];\n\t\t}\n\n\t\thooks = jQuery.cssHooks[ name ];\n\t\tif ( hooks && \"expand\" in hooks ) {\n\t\t\tvalue = hooks.expand( value );\n\t\t\tdelete props[ name ];\n\n\t\t\t// Not quite $.extend, this won't overwrite existing keys.\n\t\t\t// Reusing 'index' because we have the correct \"name\"\n\t\t\tfor ( index in value ) {\n\t\t\t\tif ( !( index in props ) ) {\n\t\t\t\t\tprops[ index ] = value[ index ];\n\t\t\t\t\tspecialEasing[ index ] = easing;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tspecialEasing[ name ] = easing;\n\t\t}\n\t}\n}\n\nfunction Animation( elem, properties, options ) {\n\tvar result,\n\t\tstopped,\n\t\tindex = 0,\n\t\tlength = Animation.prefilters.length,\n\t\tdeferred = jQuery.Deferred().always( function() {\n\n\t\t\t// Don't match elem in the :animated selector\n\t\t\tdelete tick.elem;\n\t\t} ),\n\t\ttick = function() {\n\t\t\tif ( stopped ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar currentTime = fxNow || createFxNow(),\n\t\t\t\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n\n\t\t\t\t// Support: Android 2.3 only\n\t\t\t\t// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)\n\t\t\t\ttemp = remaining / animation.duration || 0,\n\t\t\t\tpercent = 1 - temp,\n\t\t\t\tindex = 0,\n\t\t\t\tlength = animation.tweens.length;\n\n\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\tanimation.tweens[ index ].run( percent );\n\t\t\t}\n\n\t\t\tdeferred.notifyWith( elem, [ animation, percent, remaining ] );\n\n\t\t\t// If there's more to do, yield\n\t\t\tif ( percent < 1 && length ) {\n\t\t\t\treturn remaining;\n\t\t\t}\n\n\t\t\t// If this was an empty animation, synthesize a final progress notification\n\t\t\tif ( !length ) {\n\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\n\t\t\t}\n\n\t\t\t// Resolve the animation and report its conclusion\n\t\t\tdeferred.resolveWith( elem, [ animation ] );\n\t\t\treturn false;\n\t\t},\n\t\tanimation = deferred.promise( {\n\t\t\telem: elem,\n\t\t\tprops: jQuery.extend( {}, properties ),\n\t\t\topts: jQuery.extend( true, {\n\t\t\t\tspecialEasing: {},\n\t\t\t\teasing: jQuery.easing._default\n\t\t\t}, options ),\n\t\t\toriginalProperties: properties,\n\t\t\toriginalOptions: options,\n\t\t\tstartTime: fxNow || createFxNow(),\n\t\t\tduration: options.duration,\n\t\t\ttweens: [],\n\t\t\tcreateTween: function( prop, end ) {\n\t\t\t\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\n\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\n\t\t\t\tanimation.tweens.push( tween );\n\t\t\t\treturn tween;\n\t\t\t},\n\t\t\tstop: function( gotoEnd ) {\n\t\t\t\tvar index = 0,\n\n\t\t\t\t\t// If we are going to the end, we want to run all the tweens\n\t\t\t\t\t// otherwise we skip this part\n\t\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n\t\t\t\tif ( stopped ) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tstopped = true;\n\t\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\t\tanimation.tweens[ index ].run( 1 );\n\t\t\t\t}\n\n\t\t\t\t// Resolve when we played the last frame; otherwise, reject\n\t\t\t\tif ( gotoEnd ) {\n\t\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\n\t\t\t\t\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t} ),\n\t\tprops = animation.props;\n\n\tpropFilter( props, animation.opts.specialEasing );\n\n\tfor ( ; index < length; index++ ) {\n\t\tresult = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );\n\t\tif ( result ) {\n\t\t\tif ( isFunction( result.stop ) ) {\n\t\t\t\tjQuery._queueHooks( animation.elem, animation.opts.queue ).stop =\n\t\t\t\t\tresult.stop.bind( result );\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tjQuery.map( props, createTween, animation );\n\n\tif ( isFunction( animation.opts.start ) ) {\n\t\tanimation.opts.start.call( elem, animation );\n\t}\n\n\t// Attach callbacks from options\n\tanimation\n\t\t.progress( animation.opts.progress )\n\t\t.done( animation.opts.done, animation.opts.complete )\n\t\t.fail( animation.opts.fail )\n\t\t.always( animation.opts.always );\n\n\tjQuery.fx.timer(\n\t\tjQuery.extend( tick, {\n\t\t\telem: elem,\n\t\t\tanim: animation,\n\t\t\tqueue: animation.opts.queue\n\t\t} )\n\t);\n\n\treturn animation;\n}\n\njQuery.Animation = jQuery.extend( Animation, {\n\n\ttweeners: {\n\t\t\"*\": [ function( prop, value ) {\n\t\t\tvar tween = this.createTween( prop, value );\n\t\t\tadjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );\n\t\t\treturn tween;\n\t\t} ]\n\t},\n\n\ttweener: function( props, callback ) {\n\t\tif ( isFunction( props ) ) {\n\t\t\tcallback = props;\n\t\t\tprops = [ \"*\" ];\n\t\t} else {\n\t\t\tprops = props.match( rnothtmlwhite );\n\t\t}\n\n\t\tvar prop,\n\t\t\tindex = 0,\n\t\t\tlength = props.length;\n\n\t\tfor ( ; index < length; index++ ) {\n\t\t\tprop = props[ index ];\n\t\t\tAnimation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];\n\t\t\tAnimation.tweeners[ prop ].unshift( callback );\n\t\t}\n\t},\n\n\tprefilters: [ defaultPrefilter ],\n\n\tprefilter: function( callback, prepend ) {\n\t\tif ( prepend ) {\n\t\t\tAnimation.prefilters.unshift( callback );\n\t\t} else {\n\t\t\tAnimation.prefilters.push( callback );\n\t\t}\n\t}\n} );\n\njQuery.speed = function( speed, easing, fn ) {\n\tvar opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\n\t\tcomplete: fn || !fn && easing ||\n\t\t\tisFunction( speed ) && speed,\n\t\tduration: speed,\n\t\teasing: fn && easing || easing && !isFunction( easing ) && easing\n\t};\n\n\t// Go to the end state if fx are off\n\tif ( jQuery.fx.off ) {\n\t\topt.duration = 0;\n\n\t} else {\n\t\tif ( typeof opt.duration !== \"number\" ) {\n\t\t\tif ( opt.duration in jQuery.fx.speeds ) {\n\t\t\t\topt.duration = jQuery.fx.speeds[ opt.duration ];\n\n\t\t\t} else {\n\t\t\t\topt.duration = jQuery.fx.speeds._default;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Normalize opt.queue - true/undefined/null -> \"fx\"\n\tif ( opt.queue == null || opt.queue === true ) {\n\t\topt.queue = \"fx\";\n\t}\n\n\t// Queueing\n\topt.old = opt.complete;\n\n\topt.complete = function() {\n\t\tif ( isFunction( opt.old ) ) {\n\t\t\topt.old.call( this );\n\t\t}\n\n\t\tif ( opt.queue ) {\n\t\t\tjQuery.dequeue( this, opt.queue );\n\t\t}\n\t};\n\n\treturn opt;\n};\n\njQuery.fn.extend( {\n\tfadeTo: function( speed, to, easing, callback ) {\n\n\t\t// Show any hidden elements after setting opacity to 0\n\t\treturn this.filter( isHiddenWithinTree ).css( \"opacity\", 0 ).show()\n\n\t\t\t// Animate to the value specified\n\t\t\t.end().animate( { opacity: to }, speed, easing, callback );\n\t},\n\tanimate: function( prop, speed, easing, callback ) {\n\t\tvar empty = jQuery.isEmptyObject( prop ),\n\t\t\toptall = jQuery.speed( speed, easing, callback ),\n\t\t\tdoAnimation = function() {\n\n\t\t\t\t// Operate on a copy of prop so per-property easing won't be lost\n\t\t\t\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\n\n\t\t\t\t// Empty animations, or finishing resolves immediately\n\t\t\t\tif ( empty || dataPriv.get( this, \"finish\" ) ) {\n\t\t\t\t\tanim.stop( true );\n\t\t\t\t}\n\t\t\t};\n\n\t\tdoAnimation.finish = doAnimation;\n\n\t\treturn empty || optall.queue === false ?\n\t\t\tthis.each( doAnimation ) :\n\t\t\tthis.queue( optall.queue, doAnimation );\n\t},\n\tstop: function( type, clearQueue, gotoEnd ) {\n\t\tvar stopQueue = function( hooks ) {\n\t\t\tvar stop = hooks.stop;\n\t\t\tdelete hooks.stop;\n\t\t\tstop( gotoEnd );\n\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tgotoEnd = clearQueue;\n\t\t\tclearQueue = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\tif ( clearQueue ) {\n\t\t\tthis.queue( type || \"fx\", [] );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar dequeue = true,\n\t\t\t\tindex = type != null && type + \"queueHooks\",\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tdata = dataPriv.get( this );\n\n\t\t\tif ( index ) {\n\t\t\t\tif ( data[ index ] && data[ index ].stop ) {\n\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( index in data ) {\n\t\t\t\t\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n\t\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this &&\n\t\t\t\t\t( type == null || timers[ index ].queue === type ) ) {\n\n\t\t\t\t\ttimers[ index ].anim.stop( gotoEnd );\n\t\t\t\t\tdequeue = false;\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Start the next in the queue if the last step wasn't forced.\n\t\t\t// Timers currently will call their complete callbacks, which\n\t\t\t// will dequeue but only if they were gotoEnd.\n\t\t\tif ( dequeue || !gotoEnd ) {\n\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t}\n\t\t} );\n\t},\n\tfinish: function( type ) {\n\t\tif ( type !== false ) {\n\t\t\ttype = type || \"fx\";\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tvar index,\n\t\t\t\tdata = dataPriv.get( this ),\n\t\t\t\tqueue = data[ type + \"queue\" ],\n\t\t\t\thooks = data[ type + \"queueHooks\" ],\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tlength = queue ? queue.length : 0;\n\n\t\t\t// Enable finishing flag on private data\n\t\t\tdata.finish = true;\n\n\t\t\t// Empty the queue first\n\t\t\tjQuery.queue( this, type, [] );\n\n\t\t\tif ( hooks && hooks.stop ) {\n\t\t\t\thooks.stop.call( this, true );\n\t\t\t}\n\n\t\t\t// Look for any active animations, and finish them\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n\t\t\t\t\ttimers[ index ].anim.stop( true );\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Look for any animations in the old queue and finish them\n\t\t\tfor ( index = 0; index < length; index++ ) {\n\t\t\t\tif ( queue[ index ] && queue[ index ].finish ) {\n\t\t\t\t\tqueue[ index ].finish.call( this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Turn off finishing flag\n\t\t\tdelete data.finish;\n\t\t} );\n\t}\n} );\n\njQuery.each( [ \"toggle\", \"show\", \"hide\" ], function( _i, name ) {\n\tvar cssFn = jQuery.fn[ name ];\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn speed == null || typeof speed === \"boolean\" ?\n\t\t\tcssFn.apply( this, arguments ) :\n\t\t\tthis.animate( genFx( name, true ), speed, easing, callback );\n\t};\n} );\n\n// Generate shortcuts for custom animations\njQuery.each( {\n\tslideDown: genFx( \"show\" ),\n\tslideUp: genFx( \"hide\" ),\n\tslideToggle: genFx( \"toggle\" ),\n\tfadeIn: { opacity: \"show\" },\n\tfadeOut: { opacity: \"hide\" },\n\tfadeToggle: { opacity: \"toggle\" }\n}, function( name, props ) {\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn this.animate( props, speed, easing, callback );\n\t};\n} );\n\njQuery.timers = [];\njQuery.fx.tick = function() {\n\tvar timer,\n\t\ti = 0,\n\t\ttimers = jQuery.timers;\n\n\tfxNow = Date.now();\n\n\tfor ( ; i < timers.length; i++ ) {\n\t\ttimer = timers[ i ];\n\n\t\t// Run the timer and safely remove it when done (allowing for external removal)\n\t\tif ( !timer() && timers[ i ] === timer ) {\n\t\t\ttimers.splice( i--, 1 );\n\t\t}\n\t}\n\n\tif ( !timers.length ) {\n\t\tjQuery.fx.stop();\n\t}\n\tfxNow = undefined;\n};\n\njQuery.fx.timer = function( timer ) {\n\tjQuery.timers.push( timer );\n\tjQuery.fx.start();\n};\n\njQuery.fx.interval = 13;\njQuery.fx.start = function() {\n\tif ( inProgress ) {\n\t\treturn;\n\t}\n\n\tinProgress = true;\n\tschedule();\n};\n\njQuery.fx.stop = function() {\n\tinProgress = null;\n};\n\njQuery.fx.speeds = {\n\tslow: 600,\n\tfast: 200,\n\n\t// Default speed\n\t_default: 400\n};\n\n\n// Based off of the plugin by Clint Helfers, with permission.\n// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/\njQuery.fn.delay = function( time, type ) {\n\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n\ttype = type || \"fx\";\n\n\treturn this.queue( type, function( next, hooks ) {\n\t\tvar timeout = window.setTimeout( next, time );\n\t\thooks.stop = function() {\n\t\t\twindow.clearTimeout( timeout );\n\t\t};\n\t} );\n};\n\n\n( function() {\n\tvar input = document.createElement( \"input\" ),\n\t\tselect = document.createElement( \"select\" ),\n\t\topt = select.appendChild( document.createElement( \"option\" ) );\n\n\tinput.type = \"checkbox\";\n\n\t// Support: Android <=4.3 only\n\t// Default value for a checkbox should be \"on\"\n\tsupport.checkOn = input.value !== \"\";\n\n\t// Support: IE <=11 only\n\t// Must access selectedIndex to make default options select\n\tsupport.optSelected = opt.selected;\n\n\t// Support: IE <=11 only\n\t// An input loses its value after becoming a radio\n\tinput = document.createElement( \"input\" );\n\tinput.value = \"t\";\n\tinput.type = \"radio\";\n\tsupport.radioValue = input.value === \"t\";\n} )();\n\n\nvar boolHook,\n\tattrHandle = jQuery.expr.attrHandle;\n\njQuery.fn.extend( {\n\tattr: function( name, value ) {\n\t\treturn access( this, jQuery.attr, name, value, arguments.length > 1 );\n\t},\n\n\tremoveAttr: function( name ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.removeAttr( this, name );\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tattr: function( elem, name, value ) {\n\t\tvar ret, hooks,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don't get/set attributes on text, comment and attribute nodes\n\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fallback to prop when attributes are not supported\n\t\tif ( typeof elem.getAttribute === \"undefined\" ) {\n\t\t\treturn jQuery.prop( elem, name, value );\n\t\t}\n\n\t\t// Attribute hooks are determined by the lowercase version\n\t\t// Grab necessary hook if one is defined\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\t\t\thooks = jQuery.attrHooks[ name.toLowerCase() ] ||\n\t\t\t\t( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\tif ( value === null ) {\n\t\t\t\tjQuery.removeAttr( elem, name );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( hooks && \"set\" in hooks &&\n\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\telem.setAttribute( name, value + \"\" );\n\t\t\treturn value;\n\t\t}\n\n\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = jQuery.find.attr( elem, name );\n\n\t\t// Non-existent attributes return null, we normalize to undefined\n\t\treturn ret == null ? undefined : ret;\n\t},\n\n\tattrHooks: {\n\t\ttype: {\n\t\t\tset: function( elem, value ) {\n\t\t\t\tif ( !support.radioValue && value === \"radio\" &&\n\t\t\t\t\tnodeName( elem, \"input\" ) ) {\n\t\t\t\t\tvar val = elem.value;\n\t\t\t\t\telem.setAttribute( \"type\", value );\n\t\t\t\t\tif ( val ) {\n\t\t\t\t\t\telem.value = val;\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tremoveAttr: function( elem, value ) {\n\t\tvar name,\n\t\t\ti = 0,\n\n\t\t\t// Attribute names can contain non-HTML whitespace characters\n\t\t\t// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n\t\t\tattrNames = value && value.match( rnothtmlwhite );\n\n\t\tif ( attrNames && elem.nodeType === 1 ) {\n\t\t\twhile ( ( name = attrNames[ i++ ] ) ) {\n\t\t\t\telem.removeAttribute( name );\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Hooks for boolean attributes\nboolHook = {\n\tset: function( elem, value, name ) {\n\t\tif ( value === false ) {\n\n\t\t\t// Remove boolean attributes when set to false\n\t\t\tjQuery.removeAttr( elem, name );\n\t\t} else {\n\t\t\telem.setAttribute( name, name );\n\t\t}\n\t\treturn name;\n\t}\n};\n\njQuery.each( jQuery.expr.match.bool.source.match( /\\w+/g ), function( _i, name ) {\n\tvar getter = attrHandle[ name ] || jQuery.find.attr;\n\n\tattrHandle[ name ] = function( elem, name, isXML ) {\n\t\tvar ret, handle,\n\t\t\tlowercaseName = name.toLowerCase();\n\n\t\tif ( !isXML ) {\n\n\t\t\t// Avoid an infinite loop by temporarily removing this function from the getter\n\t\t\thandle = attrHandle[ lowercaseName ];\n\t\t\tattrHandle[ lowercaseName ] = ret;\n\t\t\tret = getter( elem, name, isXML ) != null ?\n\t\t\t\tlowercaseName :\n\t\t\t\tnull;\n\t\t\tattrHandle[ lowercaseName ] = handle;\n\t\t}\n\t\treturn ret;\n\t};\n} );\n\n\n\n\nvar rfocusable = /^(?:input|select|textarea|button)$/i,\n\trclickable = /^(?:a|area)$/i;\n\njQuery.fn.extend( {\n\tprop: function( name, value ) {\n\t\treturn access( this, jQuery.prop, name, value, arguments.length > 1 );\n\t},\n\n\tremoveProp: function( name ) {\n\t\treturn this.each( function() {\n\t\t\tdelete this[ jQuery.propFix[ name ] || name ];\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tprop: function( elem, name, value ) {\n\t\tvar ret, hooks,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don't get/set properties on text, comment and attribute nodes\n\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// Fix name and attach hooks\n\t\t\tname = jQuery.propFix[ name ] || name;\n\t\t\thooks = jQuery.propHooks[ name ];\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\tif ( hooks && \"set\" in hooks &&\n\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\treturn ( elem[ name ] = value );\n\t\t}\n\n\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn elem[ name ];\n\t},\n\n\tpropHooks: {\n\t\ttabIndex: {\n\t\t\tget: function( elem ) {\n\n\t\t\t\t// Support: IE <=9 - 11 only\n\t\t\t\t// elem.tabIndex doesn't always return the\n\t\t\t\t// correct value when it hasn't been explicitly set\n\t\t\t\t// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n\t\t\t\t// Use proper attribute retrieval(#12072)\n\t\t\t\tvar tabindex = jQuery.find.attr( elem, \"tabindex\" );\n\n\t\t\t\tif ( tabindex ) {\n\t\t\t\t\treturn parseInt( tabindex, 10 );\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\trfocusable.test( elem.nodeName ) ||\n\t\t\t\t\trclickable.test( elem.nodeName ) &&\n\t\t\t\t\telem.href\n\t\t\t\t) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t},\n\n\tpropFix: {\n\t\t\"for\": \"htmlFor\",\n\t\t\"class\": \"className\"\n\t}\n} );\n\n// Support: IE <=11 only\n// Accessing the selectedIndex property\n// forces the browser to respect setting selected\n// on the option\n// The getter ensures a default option is selected\n// when in an optgroup\n// eslint rule \"no-unused-expressions\" is disabled for this code\n// since it considers such accessions noop\nif ( !support.optSelected ) {\n\tjQuery.propHooks.selected = {\n\t\tget: function( elem ) {\n\n\t\t\t/* eslint no-unused-expressions: \"off\" */\n\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent && parent.parentNode ) {\n\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\t\tset: function( elem ) {\n\n\t\t\t/* eslint no-unused-expressions: \"off\" */\n\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent ) {\n\t\t\t\tparent.selectedIndex;\n\n\t\t\t\tif ( parent.parentNode ) {\n\t\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\njQuery.each( [\n\t\"tabIndex\",\n\t\"readOnly\",\n\t\"maxLength\",\n\t\"cellSpacing\",\n\t\"cellPadding\",\n\t\"rowSpan\",\n\t\"colSpan\",\n\t\"useMap\",\n\t\"frameBorder\",\n\t\"contentEditable\"\n], function() {\n\tjQuery.propFix[ this.toLowerCase() ] = this;\n} );\n\n\n\n\n\t// Strip and collapse whitespace according to HTML spec\n\t// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace\n\tfunction stripAndCollapse( value ) {\n\t\tvar tokens = value.match( rnothtmlwhite ) || [];\n\t\treturn tokens.join( \" \" );\n\t}\n\n\nfunction getClass( elem ) {\n\treturn elem.getAttribute && elem.getAttribute( \"class\" ) || \"\";\n}\n\nfunction classesToArray( value ) {\n\tif ( Array.isArray( value ) ) {\n\t\treturn value;\n\t}\n\tif ( typeof value === \"string\" ) {\n\t\treturn value.match( rnothtmlwhite ) || [];\n\t}\n\treturn [];\n}\n\njQuery.fn.extend( {\n\taddClass: function( value ) {\n\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\ti = 0;\n\n\t\tif ( isFunction( value ) ) {\n\t\t\treturn this.each( function( j ) {\n\t\t\t\tjQuery( this ).addClass( value.call( this, j, getClass( this ) ) );\n\t\t\t} );\n\t\t}\n\n\t\tclasses = classesToArray( value );\n\n\t\tif ( classes.length ) {\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\tcurValue = getClass( elem );\n\t\t\t\tcur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\t\t\t\t\t\tif ( cur.indexOf( \" \" + clazz + \" \" ) < 0 ) {\n\t\t\t\t\t\t\tcur += clazz + \" \";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\telem.setAttribute( \"class\", finalValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tremoveClass: function( value ) {\n\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\ti = 0;\n\n\t\tif ( isFunction( value ) ) {\n\t\t\treturn this.each( function( j ) {\n\t\t\t\tjQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );\n\t\t\t} );\n\t\t}\n\n\t\tif ( !arguments.length ) {\n\t\t\treturn this.attr( \"class\", \"\" );\n\t\t}\n\n\t\tclasses = classesToArray( value );\n\n\t\tif ( classes.length ) {\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\tcurValue = getClass( elem );\n\n\t\t\t\t// This expression is here for better compressibility (see addClass)\n\t\t\t\tcur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\n\t\t\t\t\t\t// Remove *all* instances\n\t\t\t\t\t\twhile ( cur.indexOf( \" \" + clazz + \" \" ) > -1 ) {\n\t\t\t\t\t\t\tcur = cur.replace( \" \" + clazz + \" \", \" \" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\telem.setAttribute( \"class\", finalValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\ttoggleClass: function( value, stateVal ) {\n\t\tvar type = typeof value,\n\t\t\tisValidValue = type === \"string\" || Array.isArray( value );\n\n\t\tif ( typeof stateVal === \"boolean\" && isValidValue ) {\n\t\t\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\n\t\t}\n\n\t\tif ( isFunction( value ) ) {\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).toggleClass(\n\t\t\t\t\tvalue.call( this, i, getClass( this ), stateVal ),\n\t\t\t\t\tstateVal\n\t\t\t\t);\n\t\t\t} );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar className, i, self, classNames;\n\n\t\t\tif ( isValidValue ) {\n\n\t\t\t\t// Toggle individual class names\n\t\t\t\ti = 0;\n\t\t\t\tself = jQuery( this );\n\t\t\t\tclassNames = classesToArray( value );\n\n\t\t\t\twhile ( ( className = classNames[ i++ ] ) ) {\n\n\t\t\t\t\t// Check each className given, space separated list\n\t\t\t\t\tif ( self.hasClass( className ) ) {\n\t\t\t\t\t\tself.removeClass( className );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.addClass( className );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Toggle whole class name\n\t\t\t} else if ( value === undefined || type === \"boolean\" ) {\n\t\t\t\tclassName = getClass( this );\n\t\t\t\tif ( className ) {\n\n\t\t\t\t\t// Store className if set\n\t\t\t\t\tdataPriv.set( this, \"__className__\", className );\n\t\t\t\t}\n\n\t\t\t\t// If the element has a class name or if we're passed `false`,\n\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\n\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\n\t\t\t\t// falling back to the empty string if nothing was stored.\n\t\t\t\tif ( this.setAttribute ) {\n\t\t\t\t\tthis.setAttribute( \"class\",\n\t\t\t\t\t\tclassName || value === false ?\n\t\t\t\t\t\t\t\"\" :\n\t\t\t\t\t\t\tdataPriv.get( this, \"__className__\" ) || \"\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t},\n\n\thasClass: function( selector ) {\n\t\tvar className, elem,\n\t\t\ti = 0;\n\n\t\tclassName = \" \" + selector + \" \";\n\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\tif ( elem.nodeType === 1 &&\n\t\t\t\t( \" \" + stripAndCollapse( getClass( elem ) ) + \" \" ).indexOf( className ) > -1 ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n} );\n\n\n\n\nvar rreturn = /\\r/g;\n\njQuery.fn.extend( {\n\tval: function( value ) {\n\t\tvar hooks, ret, valueIsFunction,\n\t\t\telem = this[ 0 ];\n\n\t\tif ( !arguments.length ) {\n\t\t\tif ( elem ) {\n\t\t\t\thooks = jQuery.valHooks[ elem.type ] ||\n\t\t\t\t\tjQuery.valHooks[ elem.nodeName.toLowerCase() ];\n\n\t\t\t\tif ( hooks &&\n\t\t\t\t\t\"get\" in hooks &&\n\t\t\t\t\t( ret = hooks.get( elem, \"value\" ) ) !== undefined\n\t\t\t\t) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tret = elem.value;\n\n\t\t\t\t// Handle most common string cases\n\t\t\t\tif ( typeof ret === \"string\" ) {\n\t\t\t\t\treturn ret.replace( rreturn, \"\" );\n\t\t\t\t}\n\n\t\t\t\t// Handle cases where value is null/undef or number\n\t\t\t\treturn ret == null ? \"\" : ret;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tvalueIsFunction = isFunction( value );\n\n\t\treturn this.each( function( i ) {\n\t\t\tvar val;\n\n\t\t\tif ( this.nodeType !== 1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( valueIsFunction ) {\n\t\t\t\tval = value.call( this, i, jQuery( this ).val() );\n\t\t\t} else {\n\t\t\t\tval = value;\n\t\t\t}\n\n\t\t\t// Treat null/undefined as \"\"; convert numbers to string\n\t\t\tif ( val == null ) {\n\t\t\t\tval = \"\";\n\n\t\t\t} else if ( typeof val === \"number\" ) {\n\t\t\t\tval += \"\";\n\n\t\t\t} else if ( Array.isArray( val ) ) {\n\t\t\t\tval = jQuery.map( val, function( value ) {\n\t\t\t\t\treturn value == null ? \"\" : value + \"\";\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n\n\t\t\t// If set returns undefined, fall back to normal setting\n\t\t\tif ( !hooks || !( \"set\" in hooks ) || hooks.set( this, val, \"value\" ) === undefined ) {\n\t\t\t\tthis.value = val;\n\t\t\t}\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tvalHooks: {\n\t\toption: {\n\t\t\tget: function( elem ) {\n\n\t\t\t\tvar val = jQuery.find.attr( elem, \"value\" );\n\t\t\t\treturn val != null ?\n\t\t\t\t\tval :\n\n\t\t\t\t\t// Support: IE <=10 - 11 only\n\t\t\t\t\t// option.text throws exceptions (#14686, #14858)\n\t\t\t\t\t// Strip and collapse whitespace\n\t\t\t\t\t// https://html.spec.whatwg.org/#strip-and-collapse-whitespace\n\t\t\t\t\tstripAndCollapse( jQuery.text( elem ) );\n\t\t\t}\n\t\t},\n\t\tselect: {\n\t\t\tget: function( elem ) {\n\t\t\t\tvar value, option, i,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tindex = elem.selectedIndex,\n\t\t\t\t\tone = elem.type === \"select-one\",\n\t\t\t\t\tvalues = one ? null : [],\n\t\t\t\t\tmax = one ? index + 1 : options.length;\n\n\t\t\t\tif ( index < 0 ) {\n\t\t\t\t\ti = max;\n\n\t\t\t\t} else {\n\t\t\t\t\ti = one ? index : 0;\n\t\t\t\t}\n\n\t\t\t\t// Loop through all the selected options\n\t\t\t\tfor ( ; i < max; i++ ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t// IE8-9 doesn't update selected after form reset (#2551)\n\t\t\t\t\tif ( ( option.selected || i === index ) &&\n\n\t\t\t\t\t\t\t// Don't return options that are disabled or in a disabled optgroup\n\t\t\t\t\t\t\t!option.disabled &&\n\t\t\t\t\t\t\t( !option.parentNode.disabled ||\n\t\t\t\t\t\t\t\t!nodeName( option.parentNode, \"optgroup\" ) ) ) {\n\n\t\t\t\t\t\t// Get the specific value for the option\n\t\t\t\t\t\tvalue = jQuery( option ).val();\n\n\t\t\t\t\t\t// We don't need an array for one selects\n\t\t\t\t\t\tif ( one ) {\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Multi-Selects return an array\n\t\t\t\t\t\tvalues.push( value );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn values;\n\t\t\t},\n\n\t\t\tset: function( elem, value ) {\n\t\t\t\tvar optionSet, option,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tvalues = jQuery.makeArray( value ),\n\t\t\t\t\ti = options.length;\n\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t/* eslint-disable no-cond-assign */\n\n\t\t\t\t\tif ( option.selected =\n\t\t\t\t\t\tjQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1\n\t\t\t\t\t) {\n\t\t\t\t\t\toptionSet = true;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* eslint-enable no-cond-assign */\n\t\t\t\t}\n\n\t\t\t\t// Force browsers to behave consistently when non-matching value is set\n\t\t\t\tif ( !optionSet ) {\n\t\t\t\t\telem.selectedIndex = -1;\n\t\t\t\t}\n\t\t\t\treturn values;\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Radios and checkboxes getter/setter\njQuery.each( [ \"radio\", \"checkbox\" ], function() {\n\tjQuery.valHooks[ this ] = {\n\t\tset: function( elem, value ) {\n\t\t\tif ( Array.isArray( value ) ) {\n\t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );\n\t\t\t}\n\t\t}\n\t};\n\tif ( !support.checkOn ) {\n\t\tjQuery.valHooks[ this ].get = function( elem ) {\n\t\t\treturn elem.getAttribute( \"value\" ) === null ? \"on\" : elem.value;\n\t\t};\n\t}\n} );\n\n\n\n\n// Return jQuery for attributes-only inclusion\n\n\nsupport.focusin = \"onfocusin\" in window;\n\n\nvar rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n\tstopPropagationCallback = function( e ) {\n\t\te.stopPropagation();\n\t};\n\njQuery.extend( jQuery.event, {\n\n\ttrigger: function( event, data, elem, onlyHandlers ) {\n\n\t\tvar i, cur, tmp, bubbleType, ontype, handle, special, lastElement,\n\t\t\teventPath = [ elem || document ],\n\t\t\ttype = hasOwn.call( event, \"type\" ) ? event.type : event,\n\t\t\tnamespaces = hasOwn.call( event, \"namespace\" ) ? event.namespace.split( \".\" ) : [];\n\n\t\tcur = lastElement = tmp = elem = elem || document;\n\n\t\t// Don't do events on text and comment nodes\n\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// focus/blur morphs to focusin/out; ensure we're not firing them right now\n\t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( type.indexOf( \".\" ) > -1 ) {\n\n\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\n\t\t\tnamespaces = type.split( \".\" );\n\t\t\ttype = namespaces.shift();\n\t\t\tnamespaces.sort();\n\t\t}\n\t\tontype = type.indexOf( \":\" ) < 0 && \"on\" + type;\n\n\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\n\t\tevent = event[ jQuery.expando ] ?\n\t\t\tevent :\n\t\t\tnew jQuery.Event( type, typeof event === \"object\" && event );\n\n\t\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n\t\tevent.isTrigger = onlyHandlers ? 2 : 3;\n\t\tevent.namespace = namespaces.join( \".\" );\n\t\tevent.rnamespace = event.namespace ?\n\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" ) :\n\t\t\tnull;\n\n\t\t// Clean up the event in case it is being reused\n\t\tevent.result = undefined;\n\t\tif ( !event.target ) {\n\t\t\tevent.target = elem;\n\t\t}\n\n\t\t// Clone any incoming data and prepend the event, creating the handler arg list\n\t\tdata = data == null ?\n\t\t\t[ event ] :\n\t\t\tjQuery.makeArray( data, [ event ] );\n\n\t\t// Allow special events to draw outside the lines\n\t\tspecial = jQuery.event.special[ type ] || {};\n\t\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine event propagation path in advance, per W3C events spec (#9951)\n\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\t\tif ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {\n\n\t\t\tbubbleType = special.delegateType || type;\n\t\t\tif ( !rfocusMorph.test( bubbleType + type ) ) {\n\t\t\t\tcur = cur.parentNode;\n\t\t\t}\n\t\t\tfor ( ; cur; cur = cur.parentNode ) {\n\t\t\t\teventPath.push( cur );\n\t\t\t\ttmp = cur;\n\t\t\t}\n\n\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\n\t\t\tif ( tmp === ( elem.ownerDocument || document ) ) {\n\t\t\t\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\n\t\t\t}\n\t\t}\n\n\t\t// Fire handlers on the event path\n\t\ti = 0;\n\t\twhile ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {\n\t\t\tlastElement = cur;\n\t\t\tevent.type = i > 1 ?\n\t\t\t\tbubbleType :\n\t\t\t\tspecial.bindType || type;\n\n\t\t\t// jQuery handler\n\t\t\thandle = ( dataPriv.get( cur, \"events\" ) || Object.create( null ) )[ event.type ] &&\n\t\t\t\tdataPriv.get( cur, \"handle\" );\n\t\t\tif ( handle ) {\n\t\t\t\thandle.apply( cur, data );\n\t\t\t}\n\n\t\t\t// Native handler\n\t\t\thandle = ontype && cur[ ontype ];\n\t\t\tif ( handle && handle.apply && acceptData( cur ) ) {\n\t\t\t\tevent.result = handle.apply( cur, data );\n\t\t\t\tif ( event.result === false ) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tevent.type = type;\n\n\t\t// If nobody prevented the default action, do it now\n\t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\n\n\t\t\tif ( ( !special._default ||\n\t\t\t\tspecial._default.apply( eventPath.pop(), data ) === false ) &&\n\t\t\t\tacceptData( elem ) ) {\n\n\t\t\t\t// Call a native DOM method on the target with the same name as the event.\n\t\t\t\t// Don't do default actions on window, that's where global variables be (#6170)\n\t\t\t\tif ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {\n\n\t\t\t\t\t// Don't re-trigger an onFOO event when we call its FOO() method\n\t\t\t\t\ttmp = elem[ ontype ];\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\n\t\t\t\t\tjQuery.event.triggered = type;\n\n\t\t\t\t\tif ( event.isPropagationStopped() ) {\n\t\t\t\t\t\tlastElement.addEventListener( type, stopPropagationCallback );\n\t\t\t\t\t}\n\n\t\t\t\t\telem[ type ]();\n\n\t\t\t\t\tif ( event.isPropagationStopped() ) {\n\t\t\t\t\t\tlastElement.removeEventListener( type, stopPropagationCallback );\n\t\t\t\t\t}\n\n\t\t\t\t\tjQuery.event.triggered = undefined;\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\t// Piggyback on a donor event to simulate a different one\n\t// Used only for `focus(in | out)` events\n\tsimulate: function( type, elem, event ) {\n\t\tvar e = jQuery.extend(\n\t\t\tnew jQuery.Event(),\n\t\t\tevent,\n\t\t\t{\n\t\t\t\ttype: type,\n\t\t\t\tisSimulated: true\n\t\t\t}\n\t\t);\n\n\t\tjQuery.event.trigger( e, null, elem );\n\t}\n\n} );\n\njQuery.fn.extend( {\n\n\ttrigger: function( type, data ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.trigger( type, data, this );\n\t\t} );\n\t},\n\ttriggerHandler: function( type, data ) {\n\t\tvar elem = this[ 0 ];\n\t\tif ( elem ) {\n\t\t\treturn jQuery.event.trigger( type, data, elem, true );\n\t\t}\n\t}\n} );\n\n\n// Support: Firefox <=44\n// Firefox doesn't have focus(in | out) events\n// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\n//\n// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1\n// focus(in | out) events fire after focus & blur events,\n// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\n// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857\nif ( !support.focusin ) {\n\tjQuery.each( { focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) {\n\n\t\t// Attach a single capturing handler on the document while someone wants focusin/focusout\n\t\tvar handler = function( event ) {\n\t\t\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );\n\t\t};\n\n\t\tjQuery.event.special[ fix ] = {\n\t\t\tsetup: function() {\n\n\t\t\t\t// Handle: regular nodes (via `this.ownerDocument`), window\n\t\t\t\t// (via `this.document`) & document (via `this`).\n\t\t\t\tvar doc = this.ownerDocument || this.document || this,\n\t\t\t\t\tattaches = dataPriv.access( doc, fix );\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.addEventListener( orig, handler, true );\n\t\t\t\t}\n\t\t\t\tdataPriv.access( doc, fix, ( attaches || 0 ) + 1 );\n\t\t\t},\n\t\t\tteardown: function() {\n\t\t\t\tvar doc = this.ownerDocument || this.document || this,\n\t\t\t\t\tattaches = dataPriv.access( doc, fix ) - 1;\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.removeEventListener( orig, handler, true );\n\t\t\t\t\tdataPriv.remove( doc, fix );\n\n\t\t\t\t} else {\n\t\t\t\t\tdataPriv.access( doc, fix, attaches );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t} );\n}\nvar location = window.location;\n\nvar nonce = { guid: Date.now() };\n\nvar rquery = ( /\\?/ );\n\n\n\n// Cross-browser xml parsing\njQuery.parseXML = function( data ) {\n\tvar xml, parserErrorElem;\n\tif ( !data || typeof data !== \"string\" ) {\n\t\treturn null;\n\t}\n\n\t// Support: IE 9 - 11 only\n\t// IE throws on parseFromString with invalid input.\n\ttry {\n\t\txml = ( new window.DOMParser() ).parseFromString( data, \"text/xml\" );\n\t} catch ( e ) {}\n\n\tparserErrorElem = xml && xml.getElementsByTagName( \"parsererror\" )[ 0 ];\n\tif ( !xml || parserErrorElem ) {\n\t\tjQuery.error( \"Invalid XML: \" + (\n\t\t\tparserErrorElem ?\n\t\t\t\tjQuery.map( parserErrorElem.childNodes, function( el ) {\n\t\t\t\t\treturn el.textContent;\n\t\t\t\t} ).join( \"\\n\" ) :\n\t\t\t\tdata\n\t\t) );\n\t}\n\treturn xml;\n};\n\n\nvar\n\trbracket = /\\[\\]$/,\n\trCRLF = /\\r?\\n/g,\n\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n\trsubmittable = /^(?:input|select|textarea|keygen)/i;\n\nfunction buildParams( prefix, obj, traditional, add ) {\n\tvar name;\n\n\tif ( Array.isArray( obj ) ) {\n\n\t\t// Serialize array item.\n\t\tjQuery.each( obj, function( i, v ) {\n\t\t\tif ( traditional || rbracket.test( prefix ) ) {\n\n\t\t\t\t// Treat each array item as a scalar.\n\t\t\t\tadd( prefix, v );\n\n\t\t\t} else {\n\n\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\n\t\t\t\tbuildParams(\n\t\t\t\t\tprefix + \"[\" + ( typeof v === \"object\" && v != null ? i : \"\" ) + \"]\",\n\t\t\t\t\tv,\n\t\t\t\t\ttraditional,\n\t\t\t\t\tadd\n\t\t\t\t);\n\t\t\t}\n\t\t} );\n\n\t} else if ( !traditional && toType( obj ) === \"object\" ) {\n\n\t\t// Serialize object item.\n\t\tfor ( name in obj ) {\n\t\t\tbuildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\n\t\t}\n\n\t} else {\n\n\t\t// Serialize scalar item.\n\t\tadd( prefix, obj );\n\t}\n}\n\n// Serialize an array of form elements or a set of\n// key/values into a query string\njQuery.param = function( a, traditional ) {\n\tvar prefix,\n\t\ts = [],\n\t\tadd = function( key, valueOrFunction ) {\n\n\t\t\t// If value is a function, invoke it and use its return value\n\t\t\tvar value = isFunction( valueOrFunction ) ?\n\t\t\t\tvalueOrFunction() :\n\t\t\t\tvalueOrFunction;\n\n\t\t\ts[ s.length ] = encodeURIComponent( key ) + \"=\" +\n\t\t\t\tencodeURIComponent( value == null ? \"\" : value );\n\t\t};\n\n\tif ( a == null ) {\n\t\treturn \"\";\n\t}\n\n\t// If an array was passed in, assume that it is an array of form elements.\n\tif ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n\n\t\t// Serialize the form elements\n\t\tjQuery.each( a, function() {\n\t\t\tadd( this.name, this.value );\n\t\t} );\n\n\t} else {\n\n\t\t// If traditional, encode the \"old\" way (the way 1.3.2 or older\n\t\t// did it), otherwise encode params recursively.\n\t\tfor ( prefix in a ) {\n\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\n\t\t}\n\t}\n\n\t// Return the resulting serialization\n\treturn s.join( \"&\" );\n};\n\njQuery.fn.extend( {\n\tserialize: function() {\n\t\treturn jQuery.param( this.serializeArray() );\n\t},\n\tserializeArray: function() {\n\t\treturn this.map( function() {\n\n\t\t\t// Can add propHook for \"elements\" to filter or add form elements\n\t\t\tvar elements = jQuery.prop( this, \"elements\" );\n\t\t\treturn elements ? jQuery.makeArray( elements ) : this;\n\t\t} ).filter( function() {\n\t\t\tvar type = this.type;\n\n\t\t\t// Use .is( \":disabled\" ) so that fieldset[disabled] works\n\t\t\treturn this.name && !jQuery( this ).is( \":disabled\" ) &&\n\t\t\t\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n\t\t\t\t( this.checked || !rcheckableType.test( type ) );\n\t\t} ).map( function( _i, elem ) {\n\t\t\tvar val = jQuery( this ).val();\n\n\t\t\tif ( val == null ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif ( Array.isArray( val ) ) {\n\t\t\t\treturn jQuery.map( val, function( val ) {\n\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t} ).get();\n\t}\n} );\n\n\nvar\n\tr20 = /%20/g,\n\trhash = /#.*$/,\n\trantiCache = /([?&])_=[^&]*/,\n\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n\n\t// #7653, #8125, #8152: local protocol detection\n\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\trnoContent = /^(?:GET|HEAD)$/,\n\trprotocol = /^\\/\\//,\n\n\t/* Prefilters\n\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n\t * 2) These are called:\n\t *    - BEFORE asking for a transport\n\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n\t * 3) key is the dataType\n\t * 4) the catchall symbol \"*\" can be used\n\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n\t */\n\tprefilters = {},\n\n\t/* Transports bindings\n\t * 1) key is the dataType\n\t * 2) the catchall symbol \"*\" can be used\n\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n\t */\n\ttransports = {},\n\n\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n\tallTypes = \"*/\".concat( \"*\" ),\n\n\t// Anchor tag for parsing the document origin\n\toriginAnchor = document.createElement( \"a\" );\n\noriginAnchor.href = location.href;\n\n// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\nfunction addToPrefiltersOrTransports( structure ) {\n\n\t// dataTypeExpression is optional and defaults to \"*\"\n\treturn function( dataTypeExpression, func ) {\n\n\t\tif ( typeof dataTypeExpression !== \"string\" ) {\n\t\t\tfunc = dataTypeExpression;\n\t\t\tdataTypeExpression = \"*\";\n\t\t}\n\n\t\tvar dataType,\n\t\t\ti = 0,\n\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];\n\n\t\tif ( isFunction( func ) ) {\n\n\t\t\t// For each dataType in the dataTypeExpression\n\t\t\twhile ( ( dataType = dataTypes[ i++ ] ) ) {\n\n\t\t\t\t// Prepend if requested\n\t\t\t\tif ( dataType[ 0 ] === \"+\" ) {\n\t\t\t\t\tdataType = dataType.slice( 1 ) || \"*\";\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );\n\n\t\t\t\t// Otherwise append\n\t\t\t\t} else {\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).push( func );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Base inspection function for prefilters and transports\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n\n\tvar inspected = {},\n\t\tseekingTransport = ( structure === transports );\n\n\tfunction inspect( dataType ) {\n\t\tvar selected;\n\t\tinspected[ dataType ] = true;\n\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n\t\t\tif ( typeof dataTypeOrTransport === \"string\" &&\n\t\t\t\t!seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n\n\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\n\t\t\t\tinspect( dataTypeOrTransport );\n\t\t\t\treturn false;\n\t\t\t} else if ( seekingTransport ) {\n\t\t\t\treturn !( selected = dataTypeOrTransport );\n\t\t\t}\n\t\t} );\n\t\treturn selected;\n\t}\n\n\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\n}\n\n// A special extend for ajax options\n// that takes \"flat\" options (not to be deep extended)\n// Fixes #9887\nfunction ajaxExtend( target, src ) {\n\tvar key, deep,\n\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n\tfor ( key in src ) {\n\t\tif ( src[ key ] !== undefined ) {\n\t\t\t( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];\n\t\t}\n\t}\n\tif ( deep ) {\n\t\tjQuery.extend( true, target, deep );\n\t}\n\n\treturn target;\n}\n\n/* Handles responses to an ajax request:\n * - finds the right dataType (mediates between content-type and expected dataType)\n * - returns the corresponding response\n */\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\n\n\tvar ct, type, finalDataType, firstDataType,\n\t\tcontents = s.contents,\n\t\tdataTypes = s.dataTypes;\n\n\t// Remove auto dataType and get content-type in the process\n\twhile ( dataTypes[ 0 ] === \"*\" ) {\n\t\tdataTypes.shift();\n\t\tif ( ct === undefined ) {\n\t\t\tct = s.mimeType || jqXHR.getResponseHeader( \"Content-Type\" );\n\t\t}\n\t}\n\n\t// Check if we're dealing with a known content-type\n\tif ( ct ) {\n\t\tfor ( type in contents ) {\n\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n\t\t\t\tdataTypes.unshift( type );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check to see if we have a response for the expected dataType\n\tif ( dataTypes[ 0 ] in responses ) {\n\t\tfinalDataType = dataTypes[ 0 ];\n\t} else {\n\n\t\t// Try convertible dataTypes\n\t\tfor ( type in responses ) {\n\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[ 0 ] ] ) {\n\t\t\t\tfinalDataType = type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( !firstDataType ) {\n\t\t\t\tfirstDataType = type;\n\t\t\t}\n\t\t}\n\n\t\t// Or just use first one\n\t\tfinalDataType = finalDataType || firstDataType;\n\t}\n\n\t// If we found a dataType\n\t// We add the dataType to the list if needed\n\t// and return the corresponding response\n\tif ( finalDataType ) {\n\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n\t\t\tdataTypes.unshift( finalDataType );\n\t\t}\n\t\treturn responses[ finalDataType ];\n\t}\n}\n\n/* Chain conversions given the request and the original response\n * Also sets the responseXXX fields on the jqXHR instance\n */\nfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\n\tvar conv2, current, conv, tmp, prev,\n\t\tconverters = {},\n\n\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\t\tdataTypes = s.dataTypes.slice();\n\n\t// Create converters map with lowercased keys\n\tif ( dataTypes[ 1 ] ) {\n\t\tfor ( conv in s.converters ) {\n\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n\t\t}\n\t}\n\n\tcurrent = dataTypes.shift();\n\n\t// Convert to each sequential dataType\n\twhile ( current ) {\n\n\t\tif ( s.responseFields[ current ] ) {\n\t\t\tjqXHR[ s.responseFields[ current ] ] = response;\n\t\t}\n\n\t\t// Apply the dataFilter if provided\n\t\tif ( !prev && isSuccess && s.dataFilter ) {\n\t\t\tresponse = s.dataFilter( response, s.dataType );\n\t\t}\n\n\t\tprev = current;\n\t\tcurrent = dataTypes.shift();\n\n\t\tif ( current ) {\n\n\t\t\t// There's only work to do if current dataType is non-auto\n\t\t\tif ( current === \"*\" ) {\n\n\t\t\t\tcurrent = prev;\n\n\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\t\t\t} else if ( prev !== \"*\" && prev !== current ) {\n\n\t\t\t\t// Seek a direct converter\n\t\t\t\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\n\n\t\t\t\t// If none found, seek a pair\n\t\t\t\tif ( !conv ) {\n\t\t\t\t\tfor ( conv2 in converters ) {\n\n\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\ttmp = conv2.split( \" \" );\n\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n\n\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\n\t\t\t\t\t\t\t\tconverters[ \"* \" + tmp[ 0 ] ];\n\t\t\t\t\t\t\tif ( conv ) {\n\n\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\tif ( conv === true ) {\n\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n\n\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n\t\t\t\t\t\t\t\t\tdataTypes.unshift( tmp[ 1 ] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Apply converter (if not an equivalence)\n\t\t\t\tif ( conv !== true ) {\n\n\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\tif ( conv && s.throws ) {\n\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tstate: \"parsererror\",\n\t\t\t\t\t\t\t\terror: conv ? e : \"No conversion from \" + prev + \" to \" + current\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { state: \"success\", data: response };\n}\n\njQuery.extend( {\n\n\t// Counter for holding the number of active queries\n\tactive: 0,\n\n\t// Last-Modified header cache for next request\n\tlastModified: {},\n\tetag: {},\n\n\tajaxSettings: {\n\t\turl: location.href,\n\t\ttype: \"GET\",\n\t\tisLocal: rlocalProtocol.test( location.protocol ),\n\t\tglobal: true,\n\t\tprocessData: true,\n\t\tasync: true,\n\t\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\n\t\t/*\n\t\ttimeout: 0,\n\t\tdata: null,\n\t\tdataType: null,\n\t\tusername: null,\n\t\tpassword: null,\n\t\tcache: null,\n\t\tthrows: false,\n\t\ttraditional: false,\n\t\theaders: {},\n\t\t*/\n\n\t\taccepts: {\n\t\t\t\"*\": allTypes,\n\t\t\ttext: \"text/plain\",\n\t\t\thtml: \"text/html\",\n\t\t\txml: \"application/xml, text/xml\",\n\t\t\tjson: \"application/json, text/javascript\"\n\t\t},\n\n\t\tcontents: {\n\t\t\txml: /\\bxml\\b/,\n\t\t\thtml: /\\bhtml/,\n\t\t\tjson: /\\bjson\\b/\n\t\t},\n\n\t\tresponseFields: {\n\t\t\txml: \"responseXML\",\n\t\t\ttext: \"responseText\",\n\t\t\tjson: \"responseJSON\"\n\t\t},\n\n\t\t// Data converters\n\t\t// Keys separate source (or catchall \"*\") and destination types with a single space\n\t\tconverters: {\n\n\t\t\t// Convert anything to text\n\t\t\t\"* text\": String,\n\n\t\t\t// Text to html (true = no transformation)\n\t\t\t\"text html\": true,\n\n\t\t\t// Evaluate text as a json expression\n\t\t\t\"text json\": JSON.parse,\n\n\t\t\t// Parse text as xml\n\t\t\t\"text xml\": jQuery.parseXML\n\t\t},\n\n\t\t// For options that shouldn't be deep extended:\n\t\t// you can add your own custom options here if\n\t\t// and when you create one that shouldn't be\n\t\t// deep extended (see ajaxExtend)\n\t\tflatOptions: {\n\t\t\turl: true,\n\t\t\tcontext: true\n\t\t}\n\t},\n\n\t// Creates a full fledged settings object into target\n\t// with both ajaxSettings and settings fields.\n\t// If target is omitted, writes into ajaxSettings.\n\tajaxSetup: function( target, settings ) {\n\t\treturn settings ?\n\n\t\t\t// Building a settings object\n\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n\n\t\t\t// Extending ajaxSettings\n\t\t\tajaxExtend( jQuery.ajaxSettings, target );\n\t},\n\n\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n\tajaxTransport: addToPrefiltersOrTransports( transports ),\n\n\t// Main method\n\tajax: function( url, options ) {\n\n\t\t// If url is an object, simulate pre-1.5 signature\n\t\tif ( typeof url === \"object\" ) {\n\t\t\toptions = url;\n\t\t\turl = undefined;\n\t\t}\n\n\t\t// Force options to be an object\n\t\toptions = options || {};\n\n\t\tvar transport,\n\n\t\t\t// URL without anti-cache param\n\t\t\tcacheURL,\n\n\t\t\t// Response headers\n\t\t\tresponseHeadersString,\n\t\t\tresponseHeaders,\n\n\t\t\t// timeout handle\n\t\t\ttimeoutTimer,\n\n\t\t\t// Url cleanup var\n\t\t\turlAnchor,\n\n\t\t\t// Request state (becomes false upon send and true upon completion)\n\t\t\tcompleted,\n\n\t\t\t// To know if global events are to be dispatched\n\t\t\tfireGlobals,\n\n\t\t\t// Loop variable\n\t\t\ti,\n\n\t\t\t// uncached part of the url\n\t\t\tuncached,\n\n\t\t\t// Create the final options object\n\t\t\ts = jQuery.ajaxSetup( {}, options ),\n\n\t\t\t// Callbacks context\n\t\t\tcallbackContext = s.context || s,\n\n\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\n\t\t\tglobalEventContext = s.context &&\n\t\t\t\t( callbackContext.nodeType || callbackContext.jquery ) ?\n\t\t\t\tjQuery( callbackContext ) :\n\t\t\t\tjQuery.event,\n\n\t\t\t// Deferreds\n\t\t\tdeferred = jQuery.Deferred(),\n\t\t\tcompleteDeferred = jQuery.Callbacks( \"once memory\" ),\n\n\t\t\t// Status-dependent callbacks\n\t\t\tstatusCode = s.statusCode || {},\n\n\t\t\t// Headers (they are sent all at once)\n\t\t\trequestHeaders = {},\n\t\t\trequestHeadersNames = {},\n\n\t\t\t// Default abort message\n\t\t\tstrAbort = \"canceled\",\n\n\t\t\t// Fake xhr\n\t\t\tjqXHR = {\n\t\t\t\treadyState: 0,\n\n\t\t\t\t// Builds headers hashtable if needed\n\t\t\t\tgetResponseHeader: function( key ) {\n\t\t\t\t\tvar match;\n\t\t\t\t\tif ( completed ) {\n\t\t\t\t\t\tif ( !responseHeaders ) {\n\t\t\t\t\t\t\tresponseHeaders = {};\n\t\t\t\t\t\t\twhile ( ( match = rheaders.exec( responseHeadersString ) ) ) {\n\t\t\t\t\t\t\t\tresponseHeaders[ match[ 1 ].toLowerCase() + \" \" ] =\n\t\t\t\t\t\t\t\t\t( responseHeaders[ match[ 1 ].toLowerCase() + \" \" ] || [] )\n\t\t\t\t\t\t\t\t\t\t.concat( match[ 2 ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() + \" \" ];\n\t\t\t\t\t}\n\t\t\t\t\treturn match == null ? null : match.join( \", \" );\n\t\t\t\t},\n\n\t\t\t\t// Raw string\n\t\t\t\tgetAllResponseHeaders: function() {\n\t\t\t\t\treturn completed ? responseHeadersString : null;\n\t\t\t\t},\n\n\t\t\t\t// Caches the header\n\t\t\t\tsetRequestHeader: function( name, value ) {\n\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\tname = requestHeadersNames[ name.toLowerCase() ] =\n\t\t\t\t\t\t\trequestHeadersNames[ name.toLowerCase() ] || name;\n\t\t\t\t\t\trequestHeaders[ name ] = value;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Overrides response content-type header\n\t\t\t\toverrideMimeType: function( type ) {\n\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\ts.mimeType = type;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tstatusCode: function( map ) {\n\t\t\t\t\tvar code;\n\t\t\t\t\tif ( map ) {\n\t\t\t\t\t\tif ( completed ) {\n\n\t\t\t\t\t\t\t// Execute the appropriate callbacks\n\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// Lazy-add the new callbacks in a way that preserves old ones\n\t\t\t\t\t\t\tfor ( code in map ) {\n\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Cancel the request\n\t\t\t\tabort: function( statusText ) {\n\t\t\t\t\tvar finalText = statusText || strAbort;\n\t\t\t\t\tif ( transport ) {\n\t\t\t\t\t\ttransport.abort( finalText );\n\t\t\t\t\t}\n\t\t\t\t\tdone( 0, finalText );\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t};\n\n\t\t// Attach deferreds\n\t\tdeferred.promise( jqXHR );\n\n\t\t// Add protocol if not provided (prefilters might expect it)\n\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\n\t\t// We also use the url parameter if available\n\t\ts.url = ( ( url || s.url || location.href ) + \"\" )\n\t\t\t.replace( rprotocol, location.protocol + \"//\" );\n\n\t\t// Alias method option to type as per ticket #12004\n\t\ts.type = options.method || options.type || s.method || s.type;\n\n\t\t// Extract dataTypes list\n\t\ts.dataTypes = ( s.dataType || \"*\" ).toLowerCase().match( rnothtmlwhite ) || [ \"\" ];\n\n\t\t// A cross-domain request is in order when the origin doesn't match the current origin.\n\t\tif ( s.crossDomain == null ) {\n\t\t\turlAnchor = document.createElement( \"a\" );\n\n\t\t\t// Support: IE <=8 - 11, Edge 12 - 15\n\t\t\t// IE throws exception on accessing the href property if url is malformed,\n\t\t\t// e.g. http://example.com:80x/\n\t\t\ttry {\n\t\t\t\turlAnchor.href = s.url;\n\n\t\t\t\t// Support: IE <=8 - 11 only\n\t\t\t\t// Anchor's host property isn't correctly set when s.url is relative\n\t\t\t\turlAnchor.href = urlAnchor.href;\n\t\t\t\ts.crossDomain = originAnchor.protocol + \"//\" + originAnchor.host !==\n\t\t\t\t\turlAnchor.protocol + \"//\" + urlAnchor.host;\n\t\t\t} catch ( e ) {\n\n\t\t\t\t// If there is an error parsing the URL, assume it is crossDomain,\n\t\t\t\t// it can be rejected by the transport if it is invalid\n\t\t\t\ts.crossDomain = true;\n\t\t\t}\n\t\t}\n\n\t\t// Convert data if not already a string\n\t\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\n\t\t\ts.data = jQuery.param( s.data, s.traditional );\n\t\t}\n\n\t\t// Apply prefilters\n\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\n\t\t// If request was aborted inside a prefilter, stop there\n\t\tif ( completed ) {\n\t\t\treturn jqXHR;\n\t\t}\n\n\t\t// We can fire global events as of now if asked to\n\t\t// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n\t\tfireGlobals = jQuery.event && s.global;\n\n\t\t// Watch for a new set of requests\n\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n\t\t\tjQuery.event.trigger( \"ajaxStart\" );\n\t\t}\n\n\t\t// Uppercase the type\n\t\ts.type = s.type.toUpperCase();\n\n\t\t// Determine if request has content\n\t\ts.hasContent = !rnoContent.test( s.type );\n\n\t\t// Save the URL in case we're toying with the If-Modified-Since\n\t\t// and/or If-None-Match header later on\n\t\t// Remove hash to simplify url manipulation\n\t\tcacheURL = s.url.replace( rhash, \"\" );\n\n\t\t// More options handling for requests with no content\n\t\tif ( !s.hasContent ) {\n\n\t\t\t// Remember the hash so we can put it back\n\t\t\tuncached = s.url.slice( cacheURL.length );\n\n\t\t\t// If data is available and should be processed, append data to url\n\t\t\tif ( s.data && ( s.processData || typeof s.data === \"string\" ) ) {\n\t\t\t\tcacheURL += ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + s.data;\n\n\t\t\t\t// #9682: remove data so that it's not used in an eventual retry\n\t\t\t\tdelete s.data;\n\t\t\t}\n\n\t\t\t// Add or update anti-cache param if needed\n\t\t\tif ( s.cache === false ) {\n\t\t\t\tcacheURL = cacheURL.replace( rantiCache, \"$1\" );\n\t\t\t\tuncached = ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + \"_=\" + ( nonce.guid++ ) +\n\t\t\t\t\tuncached;\n\t\t\t}\n\n\t\t\t// Put hash and anti-cache on the URL that will be requested (gh-1732)\n\t\t\ts.url = cacheURL + uncached;\n\n\t\t// Change '%20' to '+' if this is encoded form body content (gh-2658)\n\t\t} else if ( s.data && s.processData &&\n\t\t\t( s.contentType || \"\" ).indexOf( \"application/x-www-form-urlencoded\" ) === 0 ) {\n\t\t\ts.data = s.data.replace( r20, \"+\" );\n\t\t}\n\n\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\tif ( s.ifModified ) {\n\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ cacheURL ] );\n\t\t\t}\n\t\t\tif ( jQuery.etag[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ cacheURL ] );\n\t\t\t}\n\t\t}\n\n\t\t// Set the correct header, if data is being sent\n\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n\t\t\tjqXHR.setRequestHeader( \"Content-Type\", s.contentType );\n\t\t}\n\n\t\t// Set the Accepts header for the server, depending on the dataType\n\t\tjqXHR.setRequestHeader(\n\t\t\t\"Accept\",\n\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?\n\t\t\t\ts.accepts[ s.dataTypes[ 0 ] ] +\n\t\t\t\t\t( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\n\t\t\t\ts.accepts[ \"*\" ]\n\t\t);\n\n\t\t// Check for headers option\n\t\tfor ( i in s.headers ) {\n\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n\t\t}\n\n\t\t// Allow custom headers/mimetypes and early abort\n\t\tif ( s.beforeSend &&\n\t\t\t( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {\n\n\t\t\t// Abort if not done already and return\n\t\t\treturn jqXHR.abort();\n\t\t}\n\n\t\t// Aborting is no longer a cancellation\n\t\tstrAbort = \"abort\";\n\n\t\t// Install callbacks on deferreds\n\t\tcompleteDeferred.add( s.complete );\n\t\tjqXHR.done( s.success );\n\t\tjqXHR.fail( s.error );\n\n\t\t// Get transport\n\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\n\t\t// If no transport, we auto-abort\n\t\tif ( !transport ) {\n\t\t\tdone( -1, \"No Transport\" );\n\t\t} else {\n\t\t\tjqXHR.readyState = 1;\n\n\t\t\t// Send global event\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\n\t\t\t}\n\n\t\t\t// If request was aborted inside ajaxSend, stop there\n\t\t\tif ( completed ) {\n\t\t\t\treturn jqXHR;\n\t\t\t}\n\n\t\t\t// Timeout\n\t\t\tif ( s.async && s.timeout > 0 ) {\n\t\t\t\ttimeoutTimer = window.setTimeout( function() {\n\t\t\t\t\tjqXHR.abort( \"timeout\" );\n\t\t\t\t}, s.timeout );\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tcompleted = false;\n\t\t\t\ttransport.send( requestHeaders, done );\n\t\t\t} catch ( e ) {\n\n\t\t\t\t// Rethrow post-completion exceptions\n\t\t\t\tif ( completed ) {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\n\t\t\t\t// Propagate others as results\n\t\t\t\tdone( -1, e );\n\t\t\t}\n\t\t}\n\n\t\t// Callback for when everything is done\n\t\tfunction done( status, nativeStatusText, responses, headers ) {\n\t\t\tvar isSuccess, success, error, response, modified,\n\t\t\t\tstatusText = nativeStatusText;\n\n\t\t\t// Ignore repeat invocations\n\t\t\tif ( completed ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcompleted = true;\n\n\t\t\t// Clear timeout if it exists\n\t\t\tif ( timeoutTimer ) {\n\t\t\t\twindow.clearTimeout( timeoutTimer );\n\t\t\t}\n\n\t\t\t// Dereference transport for early garbage collection\n\t\t\t// (no matter how long the jqXHR object will be used)\n\t\t\ttransport = undefined;\n\n\t\t\t// Cache response headers\n\t\t\tresponseHeadersString = headers || \"\";\n\n\t\t\t// Set readyState\n\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n\n\t\t\t// Determine if successful\n\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\n\n\t\t\t// Get response data\n\t\t\tif ( responses ) {\n\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\n\t\t\t}\n\n\t\t\t// Use a noop converter for missing script but not if jsonp\n\t\t\tif ( !isSuccess &&\n\t\t\t\tjQuery.inArray( \"script\", s.dataTypes ) > -1 &&\n\t\t\t\tjQuery.inArray( \"json\", s.dataTypes ) < 0 ) {\n\t\t\t\ts.converters[ \"text script\" ] = function() {};\n\t\t\t}\n\n\t\t\t// Convert no matter what (that way responseXXX fields are always set)\n\t\t\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\n\n\t\t\t// If successful, handle type chaining\n\t\t\tif ( isSuccess ) {\n\n\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\t\tif ( s.ifModified ) {\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"Last-Modified\" );\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"etag\" );\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// if no content\n\t\t\t\tif ( status === 204 || s.type === \"HEAD\" ) {\n\t\t\t\t\tstatusText = \"nocontent\";\n\n\t\t\t\t// if not modified\n\t\t\t\t} else if ( status === 304 ) {\n\t\t\t\t\tstatusText = \"notmodified\";\n\n\t\t\t\t// If we have data, let's convert it\n\t\t\t\t} else {\n\t\t\t\t\tstatusText = response.state;\n\t\t\t\t\tsuccess = response.data;\n\t\t\t\t\terror = response.error;\n\t\t\t\t\tisSuccess = !error;\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t// Extract error from statusText and normalize for non-aborts\n\t\t\t\terror = statusText;\n\t\t\t\tif ( status || !statusText ) {\n\t\t\t\t\tstatusText = \"error\";\n\t\t\t\t\tif ( status < 0 ) {\n\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set data for the fake xhr object\n\t\t\tjqXHR.status = status;\n\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + \"\";\n\n\t\t\t// Success/Error\n\t\t\tif ( isSuccess ) {\n\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n\t\t\t} else {\n\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n\t\t\t}\n\n\t\t\t// Status-dependent callbacks\n\t\t\tjqXHR.statusCode( statusCode );\n\t\t\tstatusCode = undefined;\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\n\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n\t\t\t}\n\n\t\t\t// Complete\n\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\n\n\t\t\t\t// Handle the global AJAX counter\n\t\t\t\tif ( !( --jQuery.active ) ) {\n\t\t\t\t\tjQuery.event.trigger( \"ajaxStop\" );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jqXHR;\n\t},\n\n\tgetJSON: function( url, data, callback ) {\n\t\treturn jQuery.get( url, data, callback, \"json\" );\n\t},\n\n\tgetScript: function( url, callback ) {\n\t\treturn jQuery.get( url, undefined, callback, \"script\" );\n\t}\n} );\n\njQuery.each( [ \"get\", \"post\" ], function( _i, method ) {\n\tjQuery[ method ] = function( url, data, callback, type ) {\n\n\t\t// Shift arguments if data argument was omitted\n\t\tif ( isFunction( data ) ) {\n\t\t\ttype = type || callback;\n\t\t\tcallback = data;\n\t\t\tdata = undefined;\n\t\t}\n\n\t\t// The url can be an options object (which then must have .url)\n\t\treturn jQuery.ajax( jQuery.extend( {\n\t\t\turl: url,\n\t\t\ttype: method,\n\t\t\tdataType: type,\n\t\t\tdata: data,\n\t\t\tsuccess: callback\n\t\t}, jQuery.isPlainObject( url ) && url ) );\n\t};\n} );\n\njQuery.ajaxPrefilter( function( s ) {\n\tvar i;\n\tfor ( i in s.headers ) {\n\t\tif ( i.toLowerCase() === \"content-type\" ) {\n\t\t\ts.contentType = s.headers[ i ] || \"\";\n\t\t}\n\t}\n} );\n\n\njQuery._evalUrl = function( url, options, doc ) {\n\treturn jQuery.ajax( {\n\t\turl: url,\n\n\t\t// Make this explicit, since user can override this through ajaxSetup (#11264)\n\t\ttype: \"GET\",\n\t\tdataType: \"script\",\n\t\tcache: true,\n\t\tasync: false,\n\t\tglobal: false,\n\n\t\t// Only evaluate the response if it is successful (gh-4126)\n\t\t// dataFilter is not invoked for failure responses, so using it instead\n\t\t// of the default converter is kludgy but it works.\n\t\tconverters: {\n\t\t\t\"text script\": function() {}\n\t\t},\n\t\tdataFilter: function( response ) {\n\t\t\tjQuery.globalEval( response, options, doc );\n\t\t}\n\t} );\n};\n\n\njQuery.fn.extend( {\n\twrapAll: function( html ) {\n\t\tvar wrap;\n\n\t\tif ( this[ 0 ] ) {\n\t\t\tif ( isFunction( html ) ) {\n\t\t\t\thtml = html.call( this[ 0 ] );\n\t\t\t}\n\n\t\t\t// The elements to wrap the target around\n\t\t\twrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\n\n\t\t\tif ( this[ 0 ].parentNode ) {\n\t\t\t\twrap.insertBefore( this[ 0 ] );\n\t\t\t}\n\n\t\t\twrap.map( function() {\n\t\t\t\tvar elem = this;\n\n\t\t\t\twhile ( elem.firstElementChild ) {\n\t\t\t\t\telem = elem.firstElementChild;\n\t\t\t\t}\n\n\t\t\t\treturn elem;\n\t\t\t} ).append( this );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\twrapInner: function( html ) {\n\t\tif ( isFunction( html ) ) {\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).wrapInner( html.call( this, i ) );\n\t\t\t} );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar self = jQuery( this ),\n\t\t\t\tcontents = self.contents();\n\n\t\t\tif ( contents.length ) {\n\t\t\t\tcontents.wrapAll( html );\n\n\t\t\t} else {\n\t\t\t\tself.append( html );\n\t\t\t}\n\t\t} );\n\t},\n\n\twrap: function( html ) {\n\t\tvar htmlIsFunction = isFunction( html );\n\n\t\treturn this.each( function( i ) {\n\t\t\tjQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );\n\t\t} );\n\t},\n\n\tunwrap: function( selector ) {\n\t\tthis.parent( selector ).not( \"body\" ).each( function() {\n\t\t\tjQuery( this ).replaceWith( this.childNodes );\n\t\t} );\n\t\treturn this;\n\t}\n} );\n\n\njQuery.expr.pseudos.hidden = function( elem ) {\n\treturn !jQuery.expr.pseudos.visible( elem );\n};\njQuery.expr.pseudos.visible = function( elem ) {\n\treturn !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );\n};\n\n\n\n\njQuery.ajaxSettings.xhr = function() {\n\ttry {\n\t\treturn new window.XMLHttpRequest();\n\t} catch ( e ) {}\n};\n\nvar xhrSuccessStatus = {\n\n\t\t// File protocol always yields status code 0, assume 200\n\t\t0: 200,\n\n\t\t// Support: IE <=9 only\n\t\t// #1450: sometimes IE returns 1223 when it should be 204\n\t\t1223: 204\n\t},\n\txhrSupported = jQuery.ajaxSettings.xhr();\n\nsupport.cors = !!xhrSupported && ( \"withCredentials\" in xhrSupported );\nsupport.ajax = xhrSupported = !!xhrSupported;\n\njQuery.ajaxTransport( function( options ) {\n\tvar callback, errorCallback;\n\n\t// Cross domain only allowed if supported through XMLHttpRequest\n\tif ( support.cors || xhrSupported && !options.crossDomain ) {\n\t\treturn {\n\t\t\tsend: function( headers, complete ) {\n\t\t\t\tvar i,\n\t\t\t\t\txhr = options.xhr();\n\n\t\t\t\txhr.open(\n\t\t\t\t\toptions.type,\n\t\t\t\t\toptions.url,\n\t\t\t\t\toptions.async,\n\t\t\t\t\toptions.username,\n\t\t\t\t\toptions.password\n\t\t\t\t);\n\n\t\t\t\t// Apply custom fields if provided\n\t\t\t\tif ( options.xhrFields ) {\n\t\t\t\t\tfor ( i in options.xhrFields ) {\n\t\t\t\t\t\txhr[ i ] = options.xhrFields[ i ];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Override mime type if needed\n\t\t\t\tif ( options.mimeType && xhr.overrideMimeType ) {\n\t\t\t\t\txhr.overrideMimeType( options.mimeType );\n\t\t\t\t}\n\n\t\t\t\t// X-Requested-With header\n\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\n\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\n\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\n\t\t\t\t// For same-domain requests, won't change header if already provided.\n\t\t\t\tif ( !options.crossDomain && !headers[ \"X-Requested-With\" ] ) {\n\t\t\t\t\theaders[ \"X-Requested-With\" ] = \"XMLHttpRequest\";\n\t\t\t\t}\n\n\t\t\t\t// Set headers\n\t\t\t\tfor ( i in headers ) {\n\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] );\n\t\t\t\t}\n\n\t\t\t\t// Callback\n\t\t\t\tcallback = function( type ) {\n\t\t\t\t\treturn function() {\n\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\tcallback = errorCallback = xhr.onload =\n\t\t\t\t\t\t\t\txhr.onerror = xhr.onabort = xhr.ontimeout =\n\t\t\t\t\t\t\t\t\txhr.onreadystatechange = null;\n\n\t\t\t\t\t\t\tif ( type === \"abort\" ) {\n\t\t\t\t\t\t\t\txhr.abort();\n\t\t\t\t\t\t\t} else if ( type === \"error\" ) {\n\n\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t// On a manual native abort, IE9 throws\n\t\t\t\t\t\t\t\t// errors on any property access that is not readyState\n\t\t\t\t\t\t\t\tif ( typeof xhr.status !== \"number\" ) {\n\t\t\t\t\t\t\t\t\tcomplete( 0, \"error\" );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcomplete(\n\n\t\t\t\t\t\t\t\t\t\t// File: protocol always yields status 0; see #8605, #14207\n\t\t\t\t\t\t\t\t\t\txhr.status,\n\t\t\t\t\t\t\t\t\t\txhr.statusText\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcomplete(\n\t\t\t\t\t\t\t\t\txhrSuccessStatus[ xhr.status ] || xhr.status,\n\t\t\t\t\t\t\t\t\txhr.statusText,\n\n\t\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t\t// IE9 has no XHR2 but throws on binary (trac-11426)\n\t\t\t\t\t\t\t\t\t// For XHR2 non-text, let the caller handle it (gh-2498)\n\t\t\t\t\t\t\t\t\t( xhr.responseType || \"text\" ) !== \"text\"  ||\n\t\t\t\t\t\t\t\t\ttypeof xhr.responseText !== \"string\" ?\n\t\t\t\t\t\t\t\t\t\t{ binary: xhr.response } :\n\t\t\t\t\t\t\t\t\t\t{ text: xhr.responseText },\n\t\t\t\t\t\t\t\t\txhr.getAllResponseHeaders()\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t};\n\n\t\t\t\t// Listen to events\n\t\t\t\txhr.onload = callback();\n\t\t\t\terrorCallback = xhr.onerror = xhr.ontimeout = callback( \"error\" );\n\n\t\t\t\t// Support: IE 9 only\n\t\t\t\t// Use onreadystatechange to replace onabort\n\t\t\t\t// to handle uncaught aborts\n\t\t\t\tif ( xhr.onabort !== undefined ) {\n\t\t\t\t\txhr.onabort = errorCallback;\n\t\t\t\t} else {\n\t\t\t\t\txhr.onreadystatechange = function() {\n\n\t\t\t\t\t\t// Check readyState before timeout as it changes\n\t\t\t\t\t\tif ( xhr.readyState === 4 ) {\n\n\t\t\t\t\t\t\t// Allow onerror to be called first,\n\t\t\t\t\t\t\t// but that will not handle a native abort\n\t\t\t\t\t\t\t// Also, save errorCallback to a variable\n\t\t\t\t\t\t\t// as xhr.onerror cannot be accessed\n\t\t\t\t\t\t\twindow.setTimeout( function() {\n\t\t\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\t\t\terrorCallback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Create the abort callback\n\t\t\t\tcallback = callback( \"abort\" );\n\n\t\t\t\ttry {\n\n\t\t\t\t\t// Do send the request (this may raise an exception)\n\t\t\t\t\txhr.send( options.hasContent && options.data || null );\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t// #14683: Only rethrow if this hasn't been notified as an error yet\n\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n} );\n\n\n\n\n// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\njQuery.ajaxPrefilter( function( s ) {\n\tif ( s.crossDomain ) {\n\t\ts.contents.script = false;\n\t}\n} );\n\n// Install script dataType\njQuery.ajaxSetup( {\n\taccepts: {\n\t\tscript: \"text/javascript, application/javascript, \" +\n\t\t\t\"application/ecmascript, application/x-ecmascript\"\n\t},\n\tcontents: {\n\t\tscript: /\\b(?:java|ecma)script\\b/\n\t},\n\tconverters: {\n\t\t\"text script\": function( text ) {\n\t\t\tjQuery.globalEval( text );\n\t\t\treturn text;\n\t\t}\n\t}\n} );\n\n// Handle cache's special case and crossDomain\njQuery.ajaxPrefilter( \"script\", function( s ) {\n\tif ( s.cache === undefined ) {\n\t\ts.cache = false;\n\t}\n\tif ( s.crossDomain ) {\n\t\ts.type = \"GET\";\n\t}\n} );\n\n// Bind script tag hack transport\njQuery.ajaxTransport( \"script\", function( s ) {\n\n\t// This transport only deals with cross domain or forced-by-attrs requests\n\tif ( s.crossDomain || s.scriptAttrs ) {\n\t\tvar script, callback;\n\t\treturn {\n\t\t\tsend: function( _, complete ) {\n\t\t\t\tscript = jQuery( \"<script>\" )\n\t\t\t\t\t.attr( s.scriptAttrs || {} )\n\t\t\t\t\t.prop( { charset: s.scriptCharset, src: s.url } )\n\t\t\t\t\t.on( \"load error\", callback = function( evt ) {\n\t\t\t\t\t\tscript.remove();\n\t\t\t\t\t\tcallback = null;\n\t\t\t\t\t\tif ( evt ) {\n\t\t\t\t\t\t\tcomplete( evt.type === \"error\" ? 404 : 200, evt.type );\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\n\t\t\t\t// Use native DOM manipulation to avoid our domManip AJAX trickery\n\t\t\t\tdocument.head.appendChild( script[ 0 ] );\n\t\t\t},\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n} );\n\n\n\n\nvar oldCallbacks = [],\n\trjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\n// Default jsonp settings\njQuery.ajaxSetup( {\n\tjsonp: \"callback\",\n\tjsonpCallback: function() {\n\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \"_\" + ( nonce.guid++ ) );\n\t\tthis[ callback ] = true;\n\t\treturn callback;\n\t}\n} );\n\n// Detect, normalize options and install callbacks for jsonp requests\njQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\n\n\tvar callbackName, overwritten, responseContainer,\n\t\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n\t\t\t\"url\" :\n\t\t\ttypeof s.data === \"string\" &&\n\t\t\t\t( s.contentType || \"\" )\n\t\t\t\t\t.indexOf( \"application/x-www-form-urlencoded\" ) === 0 &&\n\t\t\t\trjsonp.test( s.data ) && \"data\"\n\t\t);\n\n\t// Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n\tif ( jsonProp || s.dataTypes[ 0 ] === \"jsonp\" ) {\n\n\t\t// Get callback name, remembering preexisting value associated with it\n\t\tcallbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?\n\t\t\ts.jsonpCallback() :\n\t\t\ts.jsonpCallback;\n\n\t\t// Insert callback into url or form data\n\t\tif ( jsonProp ) {\n\t\t\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \"$1\" + callbackName );\n\t\t} else if ( s.jsonp !== false ) {\n\t\t\ts.url += ( rquery.test( s.url ) ? \"&\" : \"?\" ) + s.jsonp + \"=\" + callbackName;\n\t\t}\n\n\t\t// Use data converter to retrieve json after script execution\n\t\ts.converters[ \"script json\" ] = function() {\n\t\t\tif ( !responseContainer ) {\n\t\t\t\tjQuery.error( callbackName + \" was not called\" );\n\t\t\t}\n\t\t\treturn responseContainer[ 0 ];\n\t\t};\n\n\t\t// Force json dataType\n\t\ts.dataTypes[ 0 ] = \"json\";\n\n\t\t// Install callback\n\t\toverwritten = window[ callbackName ];\n\t\twindow[ callbackName ] = function() {\n\t\t\tresponseContainer = arguments;\n\t\t};\n\n\t\t// Clean-up function (fires after converters)\n\t\tjqXHR.always( function() {\n\n\t\t\t// If previous value didn't exist - remove it\n\t\t\tif ( overwritten === undefined ) {\n\t\t\t\tjQuery( window ).removeProp( callbackName );\n\n\t\t\t// Otherwise restore preexisting value\n\t\t\t} else {\n\t\t\t\twindow[ callbackName ] = overwritten;\n\t\t\t}\n\n\t\t\t// Save back as free\n\t\t\tif ( s[ callbackName ] ) {\n\n\t\t\t\t// Make sure that re-using the options doesn't screw things around\n\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n\n\t\t\t\t// Save the callback name for future use\n\t\t\t\toldCallbacks.push( callbackName );\n\t\t\t}\n\n\t\t\t// Call if it was a function and we have a response\n\t\t\tif ( responseContainer && isFunction( overwritten ) ) {\n\t\t\t\toverwritten( responseContainer[ 0 ] );\n\t\t\t}\n\n\t\t\tresponseContainer = overwritten = undefined;\n\t\t} );\n\n\t\t// Delegate to script\n\t\treturn \"script\";\n\t}\n} );\n\n\n\n\n// Support: Safari 8 only\n// In Safari 8 documents created via document.implementation.createHTMLDocument\n// collapse sibling forms: the second one becomes a child of the first one.\n// Because of that, this security measure has to be disabled in Safari 8.\n// https://bugs.webkit.org/show_bug.cgi?id=137337\nsupport.createHTMLDocument = ( function() {\n\tvar body = document.implementation.createHTMLDocument( \"\" ).body;\n\tbody.innerHTML = \"<form></form><form></form>\";\n\treturn body.childNodes.length === 2;\n} )();\n\n\n// Argument \"data\" should be string of html\n// context (optional): If specified, the fragment will be created in this context,\n// defaults to document\n// keepScripts (optional): If true, will include scripts passed in the html string\njQuery.parseHTML = function( data, context, keepScripts ) {\n\tif ( typeof data !== \"string\" ) {\n\t\treturn [];\n\t}\n\tif ( typeof context === \"boolean\" ) {\n\t\tkeepScripts = context;\n\t\tcontext = false;\n\t}\n\n\tvar base, parsed, scripts;\n\n\tif ( !context ) {\n\n\t\t// Stop scripts or inline event handlers from being executed immediately\n\t\t// by using document.implementation\n\t\tif ( support.createHTMLDocument ) {\n\t\t\tcontext = document.implementation.createHTMLDocument( \"\" );\n\n\t\t\t// Set the base href for the created document\n\t\t\t// so any parsed elements with URLs\n\t\t\t// are based on the document's URL (gh-2965)\n\t\t\tbase = context.createElement( \"base\" );\n\t\t\tbase.href = document.location.href;\n\t\t\tcontext.head.appendChild( base );\n\t\t} else {\n\t\t\tcontext = document;\n\t\t}\n\t}\n\n\tparsed = rsingleTag.exec( data );\n\tscripts = !keepScripts && [];\n\n\t// Single tag\n\tif ( parsed ) {\n\t\treturn [ context.createElement( parsed[ 1 ] ) ];\n\t}\n\n\tparsed = buildFragment( [ data ], context, scripts );\n\n\tif ( scripts && scripts.length ) {\n\t\tjQuery( scripts ).remove();\n\t}\n\n\treturn jQuery.merge( [], parsed.childNodes );\n};\n\n\n/**\n * Load a url into a page\n */\njQuery.fn.load = function( url, params, callback ) {\n\tvar selector, type, response,\n\t\tself = this,\n\t\toff = url.indexOf( \" \" );\n\n\tif ( off > -1 ) {\n\t\tselector = stripAndCollapse( url.slice( off ) );\n\t\turl = url.slice( 0, off );\n\t}\n\n\t// If it's a function\n\tif ( isFunction( params ) ) {\n\n\t\t// We assume that it's the callback\n\t\tcallback = params;\n\t\tparams = undefined;\n\n\t// Otherwise, build a param string\n\t} else if ( params && typeof params === \"object\" ) {\n\t\ttype = \"POST\";\n\t}\n\n\t// If we have elements to modify, make the request\n\tif ( self.length > 0 ) {\n\t\tjQuery.ajax( {\n\t\t\turl: url,\n\n\t\t\t// If \"type\" variable is undefined, then \"GET\" method will be used.\n\t\t\t// Make value of this field explicit since\n\t\t\t// user can override it through ajaxSetup method\n\t\t\ttype: type || \"GET\",\n\t\t\tdataType: \"html\",\n\t\t\tdata: params\n\t\t} ).done( function( responseText ) {\n\n\t\t\t// Save response for use in complete callback\n\t\t\tresponse = arguments;\n\n\t\t\tself.html( selector ?\n\n\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\n\t\t\t\t// Exclude scripts to avoid IE 'Permission Denied' errors\n\t\t\t\tjQuery( \"<div>\" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :\n\n\t\t\t\t// Otherwise use the full result\n\t\t\t\tresponseText );\n\n\t\t// If the request succeeds, this function gets \"data\", \"status\", \"jqXHR\"\n\t\t// but they are ignored because response was set above.\n\t\t// If it fails, this function gets \"jqXHR\", \"status\", \"error\"\n\t\t} ).always( callback && function( jqXHR, status ) {\n\t\t\tself.each( function() {\n\t\t\t\tcallback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );\n\t\t\t} );\n\t\t} );\n\t}\n\n\treturn this;\n};\n\n\n\n\njQuery.expr.pseudos.animated = function( elem ) {\n\treturn jQuery.grep( jQuery.timers, function( fn ) {\n\t\treturn elem === fn.elem;\n\t} ).length;\n};\n\n\n\n\njQuery.offset = {\n\tsetOffset: function( elem, options, i ) {\n\t\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\n\t\t\tposition = jQuery.css( elem, \"position\" ),\n\t\t\tcurElem = jQuery( elem ),\n\t\t\tprops = {};\n\n\t\t// Set position first, in-case top/left are set even on static elem\n\t\tif ( position === \"static\" ) {\n\t\t\telem.style.position = \"relative\";\n\t\t}\n\n\t\tcurOffset = curElem.offset();\n\t\tcurCSSTop = jQuery.css( elem, \"top\" );\n\t\tcurCSSLeft = jQuery.css( elem, \"left\" );\n\t\tcalculatePosition = ( position === \"absolute\" || position === \"fixed\" ) &&\n\t\t\t( curCSSTop + curCSSLeft ).indexOf( \"auto\" ) > -1;\n\n\t\t// Need to be able to calculate position if either\n\t\t// top or left is auto and position is either absolute or fixed\n\t\tif ( calculatePosition ) {\n\t\t\tcurPosition = curElem.position();\n\t\t\tcurTop = curPosition.top;\n\t\t\tcurLeft = curPosition.left;\n\n\t\t} else {\n\t\t\tcurTop = parseFloat( curCSSTop ) || 0;\n\t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\n\t\t}\n\n\t\tif ( isFunction( options ) ) {\n\n\t\t\t// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\n\t\t\toptions = options.call( elem, i, jQuery.extend( {}, curOffset ) );\n\t\t}\n\n\t\tif ( options.top != null ) {\n\t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\n\t\t}\n\t\tif ( options.left != null ) {\n\t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\n\t\t}\n\n\t\tif ( \"using\" in options ) {\n\t\t\toptions.using.call( elem, props );\n\n\t\t} else {\n\t\t\tcurElem.css( props );\n\t\t}\n\t}\n};\n\njQuery.fn.extend( {\n\n\t// offset() relates an element's border box to the document origin\n\toffset: function( options ) {\n\n\t\t// Preserve chaining for setter\n\t\tif ( arguments.length ) {\n\t\t\treturn options === undefined ?\n\t\t\t\tthis :\n\t\t\t\tthis.each( function( i ) {\n\t\t\t\t\tjQuery.offset.setOffset( this, options, i );\n\t\t\t\t} );\n\t\t}\n\n\t\tvar rect, win,\n\t\t\telem = this[ 0 ];\n\n\t\tif ( !elem ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Return zeros for disconnected and hidden (display: none) elements (gh-2310)\n\t\t// Support: IE <=11 only\n\t\t// Running getBoundingClientRect on a\n\t\t// disconnected node in IE throws an error\n\t\tif ( !elem.getClientRects().length ) {\n\t\t\treturn { top: 0, left: 0 };\n\t\t}\n\n\t\t// Get document-relative position by adding viewport scroll to viewport-relative gBCR\n\t\trect = elem.getBoundingClientRect();\n\t\twin = elem.ownerDocument.defaultView;\n\t\treturn {\n\t\t\ttop: rect.top + win.pageYOffset,\n\t\t\tleft: rect.left + win.pageXOffset\n\t\t};\n\t},\n\n\t// position() relates an element's margin box to its offset parent's padding box\n\t// This corresponds to the behavior of CSS absolute positioning\n\tposition: function() {\n\t\tif ( !this[ 0 ] ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar offsetParent, offset, doc,\n\t\t\telem = this[ 0 ],\n\t\t\tparentOffset = { top: 0, left: 0 };\n\n\t\t// position:fixed elements are offset from the viewport, which itself always has zero offset\n\t\tif ( jQuery.css( elem, \"position\" ) === \"fixed\" ) {\n\n\t\t\t// Assume position:fixed implies availability of getBoundingClientRect\n\t\t\toffset = elem.getBoundingClientRect();\n\n\t\t} else {\n\t\t\toffset = this.offset();\n\n\t\t\t// Account for the *real* offset parent, which can be the document or its root element\n\t\t\t// when a statically positioned element is identified\n\t\t\tdoc = elem.ownerDocument;\n\t\t\toffsetParent = elem.offsetParent || doc.documentElement;\n\t\t\twhile ( offsetParent &&\n\t\t\t\t( offsetParent === doc.body || offsetParent === doc.documentElement ) &&\n\t\t\t\tjQuery.css( offsetParent, \"position\" ) === \"static\" ) {\n\n\t\t\t\toffsetParent = offsetParent.parentNode;\n\t\t\t}\n\t\t\tif ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {\n\n\t\t\t\t// Incorporate borders into its offset, since they are outside its content origin\n\t\t\t\tparentOffset = jQuery( offsetParent ).offset();\n\t\t\t\tparentOffset.top += jQuery.css( offsetParent, \"borderTopWidth\", true );\n\t\t\t\tparentOffset.left += jQuery.css( offsetParent, \"borderLeftWidth\", true );\n\t\t\t}\n\t\t}\n\n\t\t// Subtract parent offsets and element margins\n\t\treturn {\n\t\t\ttop: offset.top - parentOffset.top - jQuery.css( elem, \"marginTop\", true ),\n\t\t\tleft: offset.left - parentOffset.left - jQuery.css( elem, \"marginLeft\", true )\n\t\t};\n\t},\n\n\t// This method will return documentElement in the following cases:\n\t// 1) For the element inside the iframe without offsetParent, this method will return\n\t//    documentElement of the parent window\n\t// 2) For the hidden or detached element\n\t// 3) For body or html element, i.e. in case of the html node - it will return itself\n\t//\n\t// but those exceptions were never presented as a real life use-cases\n\t// and might be considered as more preferable results.\n\t//\n\t// This logic, however, is not guaranteed and can change at any point in the future\n\toffsetParent: function() {\n\t\treturn this.map( function() {\n\t\t\tvar offsetParent = this.offsetParent;\n\n\t\t\twhile ( offsetParent && jQuery.css( offsetParent, \"position\" ) === \"static\" ) {\n\t\t\t\toffsetParent = offsetParent.offsetParent;\n\t\t\t}\n\n\t\t\treturn offsetParent || documentElement;\n\t\t} );\n\t}\n} );\n\n// Create scrollLeft and scrollTop methods\njQuery.each( { scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function( method, prop ) {\n\tvar top = \"pageYOffset\" === prop;\n\n\tjQuery.fn[ method ] = function( val ) {\n\t\treturn access( this, function( elem, method, val ) {\n\n\t\t\t// Coalesce documents and windows\n\t\t\tvar win;\n\t\t\tif ( isWindow( elem ) ) {\n\t\t\t\twin = elem;\n\t\t\t} else if ( elem.nodeType === 9 ) {\n\t\t\t\twin = elem.defaultView;\n\t\t\t}\n\n\t\t\tif ( val === undefined ) {\n\t\t\t\treturn win ? win[ prop ] : elem[ method ];\n\t\t\t}\n\n\t\t\tif ( win ) {\n\t\t\t\twin.scrollTo(\n\t\t\t\t\t!top ? val : win.pageXOffset,\n\t\t\t\t\ttop ? val : win.pageYOffset\n\t\t\t\t);\n\n\t\t\t} else {\n\t\t\t\telem[ method ] = val;\n\t\t\t}\n\t\t}, method, val, arguments.length );\n\t};\n} );\n\n// Support: Safari <=7 - 9.1, Chrome <=37 - 49\n// Add the top/left cssHooks using jQuery.fn.position\n// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347\n// getComputedStyle returns percent when specified for top/left/bottom/right;\n// rather than make the css module depend on the offset module, just check for it here\njQuery.each( [ \"top\", \"left\" ], function( _i, prop ) {\n\tjQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\n\t\tfunction( elem, computed ) {\n\t\t\tif ( computed ) {\n\t\t\t\tcomputed = curCSS( elem, prop );\n\n\t\t\t\t// If curCSS returns percentage, fallback to offset\n\t\t\t\treturn rnumnonpx.test( computed ) ?\n\t\t\t\t\tjQuery( elem ).position()[ prop ] + \"px\" :\n\t\t\t\t\tcomputed;\n\t\t\t}\n\t\t}\n\t);\n} );\n\n\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\njQuery.each( { Height: \"height\", Width: \"width\" }, function( name, type ) {\n\tjQuery.each( {\n\t\tpadding: \"inner\" + name,\n\t\tcontent: type,\n\t\t\"\": \"outer\" + name\n\t}, function( defaultExtra, funcName ) {\n\n\t\t// Margin is only for outerHeight, outerWidth\n\t\tjQuery.fn[ funcName ] = function( margin, value ) {\n\t\t\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \"boolean\" ),\n\t\t\t\textra = defaultExtra || ( margin === true || value === true ? \"margin\" : \"border\" );\n\n\t\t\treturn access( this, function( elem, type, value ) {\n\t\t\t\tvar doc;\n\n\t\t\t\tif ( isWindow( elem ) ) {\n\n\t\t\t\t\t// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)\n\t\t\t\t\treturn funcName.indexOf( \"outer\" ) === 0 ?\n\t\t\t\t\t\telem[ \"inner\" + name ] :\n\t\t\t\t\t\telem.document.documentElement[ \"client\" + name ];\n\t\t\t\t}\n\n\t\t\t\t// Get document width or height\n\t\t\t\tif ( elem.nodeType === 9 ) {\n\t\t\t\t\tdoc = elem.documentElement;\n\n\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n\t\t\t\t\t// whichever is greatest\n\t\t\t\t\treturn Math.max(\n\t\t\t\t\t\telem.body[ \"scroll\" + name ], doc[ \"scroll\" + name ],\n\t\t\t\t\t\telem.body[ \"offset\" + name ], doc[ \"offset\" + name ],\n\t\t\t\t\t\tdoc[ \"client\" + name ]\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn value === undefined ?\n\n\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\n\t\t\t\t\tjQuery.css( elem, type, extra ) :\n\n\t\t\t\t\t// Set width or height on the element\n\t\t\t\t\tjQuery.style( elem, type, value, extra );\n\t\t\t}, type, chainable ? margin : undefined, chainable );\n\t\t};\n\t} );\n} );\n\n\njQuery.each( [\n\t\"ajaxStart\",\n\t\"ajaxStop\",\n\t\"ajaxComplete\",\n\t\"ajaxError\",\n\t\"ajaxSuccess\",\n\t\"ajaxSend\"\n], function( _i, type ) {\n\tjQuery.fn[ type ] = function( fn ) {\n\t\treturn this.on( type, fn );\n\t};\n} );\n\n\n\n\njQuery.fn.extend( {\n\n\tbind: function( types, data, fn ) {\n\t\treturn this.on( types, null, data, fn );\n\t},\n\tunbind: function( types, fn ) {\n\t\treturn this.off( types, null, fn );\n\t},\n\n\tdelegate: function( selector, types, data, fn ) {\n\t\treturn this.on( types, selector, data, fn );\n\t},\n\tundelegate: function( selector, types, fn ) {\n\n\t\t// ( namespace ) or ( selector, types [, fn] )\n\t\treturn arguments.length === 1 ?\n\t\t\tthis.off( selector, \"**\" ) :\n\t\t\tthis.off( types, selector || \"**\", fn );\n\t},\n\n\thover: function( fnOver, fnOut ) {\n\t\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n\t}\n} );\n\njQuery.each(\n\t( \"blur focus focusin focusout resize scroll click dblclick \" +\n\t\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n\t\"change select submit keydown keypress keyup contextmenu\" ).split( \" \" ),\n\tfunction( _i, name ) {\n\n\t\t// Handle event binding\n\t\tjQuery.fn[ name ] = function( data, fn ) {\n\t\t\treturn arguments.length > 0 ?\n\t\t\t\tthis.on( name, null, data, fn ) :\n\t\t\t\tthis.trigger( name );\n\t\t};\n\t}\n);\n\n\n\n\n// Support: Android <=4.0 only\n// Make sure we trim BOM and NBSP\nvar rtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;\n\n// Bind a function to a context, optionally partially applying any\n// arguments.\n// jQuery.proxy is deprecated to promote standards (specifically Function#bind)\n// However, it is not slated for removal any time soon\njQuery.proxy = function( fn, context ) {\n\tvar tmp, args, proxy;\n\n\tif ( typeof context === \"string\" ) {\n\t\ttmp = fn[ context ];\n\t\tcontext = fn;\n\t\tfn = tmp;\n\t}\n\n\t// Quick check to determine if target is callable, in the spec\n\t// this throws a TypeError, but we will just return undefined.\n\tif ( !isFunction( fn ) ) {\n\t\treturn undefined;\n\t}\n\n\t// Simulated bind\n\targs = slice.call( arguments, 2 );\n\tproxy = function() {\n\t\treturn fn.apply( context || this, args.concat( slice.call( arguments ) ) );\n\t};\n\n\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\n\treturn proxy;\n};\n\njQuery.holdReady = function( hold ) {\n\tif ( hold ) {\n\t\tjQuery.readyWait++;\n\t} else {\n\t\tjQuery.ready( true );\n\t}\n};\njQuery.isArray = Array.isArray;\njQuery.parseJSON = JSON.parse;\njQuery.nodeName = nodeName;\njQuery.isFunction = isFunction;\njQuery.isWindow = isWindow;\njQuery.camelCase = camelCase;\njQuery.type = toType;\n\njQuery.now = Date.now;\n\njQuery.isNumeric = function( obj ) {\n\n\t// As of jQuery 3.0, isNumeric is limited to\n\t// strings and numbers (primitives or objects)\n\t// that can be coerced to finite numbers (gh-2662)\n\tvar type = jQuery.type( obj );\n\treturn ( type === \"number\" || type === \"string\" ) &&\n\n\t\t// parseFloat NaNs numeric-cast false positives (\"\")\n\t\t// ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n\t\t// subtraction forces infinities to NaN\n\t\t!isNaN( obj - parseFloat( obj ) );\n};\n\njQuery.trim = function( text ) {\n\treturn text == null ?\n\t\t\"\" :\n\t\t( text + \"\" ).replace( rtrim, \"\" );\n};\n\n\n\n// Register as a named AMD module, since jQuery can be concatenated with other\n// files that may use define, but not via a proper concatenation script that\n// understands anonymous AMD modules. A named AMD is safest and most robust\n// way to register. Lowercase jquery is used because AMD module names are\n// derived from file names, and jQuery is normally delivered in a lowercase\n// file name. Do this after creating the global so that if an AMD module wants\n// to call noConflict to hide this version of jQuery, it will work.\n\n// Note that for maximum portability, libraries that are not jQuery should\n// declare themselves as anonymous modules, and avoid setting a global if an\n// AMD loader is present. jQuery is a special case. For more information, see\n// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n\nif ( true ) {\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n\t\treturn jQuery;\n\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n}\n\n\n\n\nvar\n\n\t// Map over jQuery in case of overwrite\n\t_jQuery = window.jQuery,\n\n\t// Map over the $ in case of overwrite\n\t_$ = window.$;\n\njQuery.noConflict = function( deep ) {\n\tif ( window.$ === jQuery ) {\n\t\twindow.$ = _$;\n\t}\n\n\tif ( deep && window.jQuery === jQuery ) {\n\t\twindow.jQuery = _jQuery;\n\t}\n\n\treturn jQuery;\n};\n\n// Expose jQuery and $ identifiers, even in AMD\n// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n// and CommonJS for browser emulators (#13566)\nif ( typeof noGlobal === \"undefined\" ) {\n\twindow.jQuery = window.$ = jQuery;\n}\n\n\n\n\nreturn jQuery;\n} );\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvanF1ZXJ5L2Rpc3QvanF1ZXJ5LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsTUFBTSxLQUEwQjs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsWUFBWTs7QUFFckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGLG9CQUFvQjs7QUFFcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUYsOENBQThDO0FBQzlDO0FBQ0E7QUFDQSxtQkFBbUIsaUNBQWlDO0FBQ3BELEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLFNBQVM7QUFDbkI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxTQUFTO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyxJQUFJO0FBQ3RDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsSUFBSTs7QUFFcEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDLElBQUk7QUFDOUM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSwwQkFBMEI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFNBQVMsNkJBQTZCO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsYUFBYSx3QkFBd0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0IsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0EsaUNBQWlDLE1BQU07QUFDdkM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGVBQWU7O0FBRWYsU0FBUzs7QUFFVDtBQUNBLFNBQVMsZ0NBQWdDO0FBQ3pDLFNBQVMsbUJBQW1CO0FBQzVCLFNBQVMscUNBQXFDO0FBQzlDLFNBQVM7QUFDVCxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDhEQUE4RDs7QUFFOUQ7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFROztBQUVSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtEQUErRDs7QUFFL0Q7QUFDQTtBQUNBO0FBQ0EsNENBQTRDOztBQUU1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0EsK0NBQStDOztBQUUvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQSxrRUFBa0UsVUFBVTtBQUM1RSx1Q0FBdUMsMkJBQTJCO0FBQ2xFO0FBQ0EsaUNBQWlDLE1BQU07QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGFBQWEsdUVBQXVFO0FBQ3BGO0FBQ0E7QUFDQSxhQUFhLDRCQUE0QjtBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFNBQVM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNkRBQTZEOztBQUU3RDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTs7QUFFQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFNBQVM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsU0FBUztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSixTQUFTLFNBQVM7QUFDbEI7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlEQUFpRDtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQsV0FBVyw0Q0FBNEM7QUFDdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QjtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBLEVBQUU7Ozs7QUFJRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQSxTQUFTLEdBQUc7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7OztBQUlBOztBQUVBOztBQUVBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsTUFBTTtBQUNOOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQiwyQkFBMkIsd0JBQXdCOztBQUVuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSwyQ0FBMkM7QUFDM0MsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUNBQXlDLHFDQUFxQztBQUM5RSxxQ0FBcUMsc0NBQXNDO0FBQzNFLHFDQUFxQyxxQ0FBcUM7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQztBQUNyQyxzQ0FBc0M7QUFDdEMscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7Ozs7O0FBS0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsYUFBYTtBQUNyQyxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixTQUFTO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBOzs7QUFHQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUyxnQkFBZ0I7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsRUFBRTtBQUNGOztBQUVBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIOztBQUVBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLE9BQU87QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsT0FBTztBQUNoQjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXOztBQUVYOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGVBQWUsc0JBQXNCO0FBQ3JDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGdFQUFnRTtBQUNoRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVcsY0FBYzs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix1Q0FBdUM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVEQUF1RDtBQUMvRTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsSUFBSTtBQUNKLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLCtDQUErQztBQUNyRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsZUFBZSxvQ0FBb0M7QUFDbkQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEVBQUU7OztBQUdGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUywrQkFBK0I7QUFDeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDQUF5QyxPQUFPO0FBQ2hEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxxQ0FBcUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLDhCQUE4QjtBQUN4Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFOztBQUVGO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxXQUFXO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBK0MsY0FBYyxXQUFXO0FBQ3hFLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0Esc0JBQXNCLGNBQWMsc0JBQXNCLGdCQUFnQjtBQUMxRSxnQkFBZ0IsV0FBVyxZQUFZO0FBQ3ZDLGNBQWM7QUFDZDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZDQUE2QyxjQUFjO0FBQzNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7O0FBR0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDhEQUE4RDtBQUMzRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLE9BQU87O0FBRWhCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixlQUFlO0FBQ2xDO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFlBQVksU0FBUztBQUNyQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBLFNBQVMsT0FBTztBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsZ0JBQWdCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxrREFBa0QsMEJBQTBCO0FBQzVFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTs7QUFFQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBLFNBQVMsZ0JBQWdCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxnQkFBZ0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsYUFBYTtBQUNsQyxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQyxTQUFTO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQyxTQUFTO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsWUFBWSxpQkFBaUI7QUFDN0IsZUFBZTtBQUNmLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsU0FBUyxtQkFBbUI7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7Ozs7QUFLRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7Ozs7QUFLRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7Ozs7O0FBS0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxrQ0FBa0M7QUFDbEM7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7OztBQUtGOzs7QUFHQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEM7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQ0FBb0M7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQSxjQUFjOztBQUVkOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUosR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSixHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkLE1BQU07QUFDTjs7QUFFQSxZQUFZO0FBQ1osSUFBSTtBQUNKO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCLGlEQUFpRDtBQUNqRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVO0FBQ1Y7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQSxzQkFBc0I7QUFDdEIsMkJBQTJCOztBQUUzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUEsb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1QkFBdUI7QUFDbkMsWUFBWSx3QkFBd0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7Ozs7O0FBS0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsY0FBYyx1Q0FBdUM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7Ozs7QUFLRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLEVBQUU7Ozs7O0FBS0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EscURBQXFEO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBLEVBQUU7O0FBRUY7QUFDQSxlQUFlLHFEQUFxRDtBQUNwRTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBLGVBQWUsa0NBQWtDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRztBQUNILEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7OztBQUtGOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSyxJQUEwQztBQUMvQyxDQUFDLGlDQUFrQixFQUFFLG1DQUFFO0FBQ3ZCO0FBQ0EsRUFBRTtBQUFBLGtHQUFFO0FBQ0o7Ozs7O0FBS0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5L2Rpc3QvanF1ZXJ5LmpzPzgyNjIiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBqUXVlcnkgSmF2YVNjcmlwdCBMaWJyYXJ5IHYzLjYuMFxuICogaHR0cHM6Ly9qcXVlcnkuY29tL1xuICpcbiAqIEluY2x1ZGVzIFNpenpsZS5qc1xuICogaHR0cHM6Ly9zaXp6bGVqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IE9wZW5KUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cHM6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDIxLTAzLTAyVDE3OjA4WlxuICovXG4oIGZ1bmN0aW9uKCBnbG9iYWwsIGZhY3RvcnkgKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0aWYgKCB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vIEZvciBDb21tb25KUyBhbmQgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgd2hlcmUgYSBwcm9wZXIgYHdpbmRvd2Bcblx0XHQvLyBpcyBwcmVzZW50LCBleGVjdXRlIHRoZSBmYWN0b3J5IGFuZCBnZXQgalF1ZXJ5LlxuXHRcdC8vIEZvciBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3QgaGF2ZSBhIGB3aW5kb3dgIHdpdGggYSBgZG9jdW1lbnRgXG5cdFx0Ly8gKHN1Y2ggYXMgTm9kZS5qcyksIGV4cG9zZSBhIGZhY3RvcnkgYXMgbW9kdWxlLmV4cG9ydHMuXG5cdFx0Ly8gVGhpcyBhY2NlbnR1YXRlcyB0aGUgbmVlZCBmb3IgdGhlIGNyZWF0aW9uIG9mIGEgcmVhbCBgd2luZG93YC5cblx0XHQvLyBlLmcuIHZhciBqUXVlcnkgPSByZXF1aXJlKFwianF1ZXJ5XCIpKHdpbmRvdyk7XG5cdFx0Ly8gU2VlIHRpY2tldCAjMTQ1NDkgZm9yIG1vcmUgaW5mby5cblx0XHRtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5kb2N1bWVudCA/XG5cdFx0XHRmYWN0b3J5KCBnbG9iYWwsIHRydWUgKSA6XG5cdFx0XHRmdW5jdGlvbiggdyApIHtcblx0XHRcdFx0aWYgKCAhdy5kb2N1bWVudCApIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIFwialF1ZXJ5IHJlcXVpcmVzIGEgd2luZG93IHdpdGggYSBkb2N1bWVudFwiICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhY3RvcnkoIHcgKTtcblx0XHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0ZmFjdG9yeSggZ2xvYmFsICk7XG5cdH1cblxuLy8gUGFzcyB0aGlzIGlmIHdpbmRvdyBpcyBub3QgZGVmaW5lZCB5ZXRcbn0gKSggdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHRoaXMsIGZ1bmN0aW9uKCB3aW5kb3csIG5vR2xvYmFsICkge1xuXG4vLyBFZGdlIDw9IDEyIC0gMTMrLCBGaXJlZm94IDw9MTggLSA0NSssIElFIDEwIC0gMTEsIFNhZmFyaSA1LjEgLSA5KywgaU9TIDYgLSA5LjFcbi8vIHRocm93IGV4Y2VwdGlvbnMgd2hlbiBub24tc3RyaWN0IGNvZGUgKGUuZy4sIEFTUC5ORVQgNC41KSBhY2Nlc3NlcyBzdHJpY3QgbW9kZVxuLy8gYXJndW1lbnRzLmNhbGxlZS5jYWxsZXIgKHRyYWMtMTMzMzUpLiBCdXQgYXMgb2YgalF1ZXJ5IDMuMCAoMjAxNiksIHN0cmljdCBtb2RlIHNob3VsZCBiZSBjb21tb25cbi8vIGVub3VnaCB0aGF0IGFsbCBzdWNoIGF0dGVtcHRzIGFyZSBndWFyZGVkIGluIGEgdHJ5IGJsb2NrLlxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBhcnIgPSBbXTtcblxudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuXG52YXIgc2xpY2UgPSBhcnIuc2xpY2U7XG5cbnZhciBmbGF0ID0gYXJyLmZsYXQgPyBmdW5jdGlvbiggYXJyYXkgKSB7XG5cdHJldHVybiBhcnIuZmxhdC5jYWxsKCBhcnJheSApO1xufSA6IGZ1bmN0aW9uKCBhcnJheSApIHtcblx0cmV0dXJuIGFyci5jb25jYXQuYXBwbHkoIFtdLCBhcnJheSApO1xufTtcblxuXG52YXIgcHVzaCA9IGFyci5wdXNoO1xuXG52YXIgaW5kZXhPZiA9IGFyci5pbmRleE9mO1xuXG52YXIgY2xhc3MydHlwZSA9IHt9O1xuXG52YXIgdG9TdHJpbmcgPSBjbGFzczJ0eXBlLnRvU3RyaW5nO1xuXG52YXIgaGFzT3duID0gY2xhc3MydHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIGZuVG9TdHJpbmcgPSBoYXNPd24udG9TdHJpbmc7XG5cbnZhciBPYmplY3RGdW5jdGlvblN0cmluZyA9IGZuVG9TdHJpbmcuY2FsbCggT2JqZWN0ICk7XG5cbnZhciBzdXBwb3J0ID0ge307XG5cbnZhciBpc0Z1bmN0aW9uID0gZnVuY3Rpb24gaXNGdW5jdGlvbiggb2JqICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9NTcsIEZpcmVmb3ggPD01MlxuXHRcdC8vIEluIHNvbWUgYnJvd3NlcnMsIHR5cGVvZiByZXR1cm5zIFwiZnVuY3Rpb25cIiBmb3IgSFRNTCA8b2JqZWN0PiBlbGVtZW50c1xuXHRcdC8vIChpLmUuLCBgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwib2JqZWN0XCIgKSA9PT0gXCJmdW5jdGlvblwiYCkuXG5cdFx0Ly8gV2UgZG9uJ3Qgd2FudCB0byBjbGFzc2lmeSAqYW55KiBET00gbm9kZSBhcyBhIGZ1bmN0aW9uLlxuXHRcdC8vIFN1cHBvcnQ6IFF0V2ViIDw9My44LjUsIFdlYktpdCA8PTUzNC4zNCwgd2todG1sdG9wZGYgdG9vbCA8PTAuMTIuNVxuXHRcdC8vIFBsdXMgZm9yIG9sZCBXZWJLaXQsIHR5cGVvZiByZXR1cm5zIFwiZnVuY3Rpb25cIiBmb3IgSFRNTCBjb2xsZWN0aW9uc1xuXHRcdC8vIChlLmcuLCBgdHlwZW9mIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiZGl2XCIpID09PSBcImZ1bmN0aW9uXCJgKS4gKGdoLTQ3NTYpXG5cdFx0cmV0dXJuIHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygb2JqLm5vZGVUeXBlICE9PSBcIm51bWJlclwiICYmXG5cdFx0XHR0eXBlb2Ygb2JqLml0ZW0gIT09IFwiZnVuY3Rpb25cIjtcblx0fTtcblxuXG52YXIgaXNXaW5kb3cgPSBmdW5jdGlvbiBpc1dpbmRvdyggb2JqICkge1xuXHRcdHJldHVybiBvYmogIT0gbnVsbCAmJiBvYmogPT09IG9iai53aW5kb3c7XG5cdH07XG5cblxudmFyIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xuXG5cblxuXHR2YXIgcHJlc2VydmVkU2NyaXB0QXR0cmlidXRlcyA9IHtcblx0XHR0eXBlOiB0cnVlLFxuXHRcdHNyYzogdHJ1ZSxcblx0XHRub25jZTogdHJ1ZSxcblx0XHRub01vZHVsZTogdHJ1ZVxuXHR9O1xuXG5cdGZ1bmN0aW9uIERPTUV2YWwoIGNvZGUsIG5vZGUsIGRvYyApIHtcblx0XHRkb2MgPSBkb2MgfHwgZG9jdW1lbnQ7XG5cblx0XHR2YXIgaSwgdmFsLFxuXHRcdFx0c2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoIFwic2NyaXB0XCIgKTtcblxuXHRcdHNjcmlwdC50ZXh0ID0gY29kZTtcblx0XHRpZiAoIG5vZGUgKSB7XG5cdFx0XHRmb3IgKCBpIGluIHByZXNlcnZlZFNjcmlwdEF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA2NCssIEVkZ2UgMTgrXG5cdFx0XHRcdC8vIFNvbWUgYnJvd3NlcnMgZG9uJ3Qgc3VwcG9ydCB0aGUgXCJub25jZVwiIHByb3BlcnR5IG9uIHNjcmlwdHMuXG5cdFx0XHRcdC8vIE9uIHRoZSBvdGhlciBoYW5kLCBqdXN0IHVzaW5nIGBnZXRBdHRyaWJ1dGVgIGlzIG5vdCBlbm91Z2ggYXNcblx0XHRcdFx0Ly8gdGhlIGBub25jZWAgYXR0cmlidXRlIGlzIHJlc2V0IHRvIGFuIGVtcHR5IHN0cmluZyB3aGVuZXZlciBpdFxuXHRcdFx0XHQvLyBiZWNvbWVzIGJyb3dzaW5nLWNvbnRleHQgY29ubmVjdGVkLlxuXHRcdFx0XHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3doYXR3Zy9odG1sL2lzc3Vlcy8yMzY5XG5cdFx0XHRcdC8vIFNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNub25jZS1hdHRyaWJ1dGVzXG5cdFx0XHRcdC8vIFRoZSBgbm9kZS5nZXRBdHRyaWJ1dGVgIGNoZWNrIHdhcyBhZGRlZCBmb3IgdGhlIHNha2Ugb2Zcblx0XHRcdFx0Ly8gYGpRdWVyeS5nbG9iYWxFdmFsYCBzbyB0aGF0IGl0IGNhbiBmYWtlIGEgbm9uY2UtY29udGFpbmluZyBub2RlXG5cdFx0XHRcdC8vIHZpYSBhbiBvYmplY3QuXG5cdFx0XHRcdHZhbCA9IG5vZGVbIGkgXSB8fCBub2RlLmdldEF0dHJpYnV0ZSAmJiBub2RlLmdldEF0dHJpYnV0ZSggaSApO1xuXHRcdFx0XHRpZiAoIHZhbCApIHtcblx0XHRcdFx0XHRzY3JpcHQuc2V0QXR0cmlidXRlKCBpLCB2YWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRkb2MuaGVhZC5hcHBlbmRDaGlsZCggc2NyaXB0ICkucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggc2NyaXB0ICk7XG5cdH1cblxuXG5mdW5jdGlvbiB0b1R5cGUoIG9iaiApIHtcblx0aWYgKCBvYmogPT0gbnVsbCApIHtcblx0XHRyZXR1cm4gb2JqICsgXCJcIjtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD0yLjMgb25seSAoZnVuY3Rpb25pc2ggUmVnRXhwKVxuXHRyZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIgP1xuXHRcdGNsYXNzMnR5cGVbIHRvU3RyaW5nLmNhbGwoIG9iaiApIF0gfHwgXCJvYmplY3RcIiA6XG5cdFx0dHlwZW9mIG9iajtcbn1cbi8qIGdsb2JhbCBTeW1ib2wgKi9cbi8vIERlZmluaW5nIHRoaXMgZ2xvYmFsIGluIC5lc2xpbnRyYy5qc29uIHdvdWxkIGNyZWF0ZSBhIGRhbmdlciBvZiB1c2luZyB0aGUgZ2xvYmFsXG4vLyB1bmd1YXJkZWQgaW4gYW5vdGhlciBwbGFjZSwgaXQgc2VlbXMgc2FmZXIgdG8gZGVmaW5lIGdsb2JhbCBvbmx5IGZvciB0aGlzIG1vZHVsZVxuXG5cblxudmFyXG5cdHZlcnNpb24gPSBcIjMuNi4wXCIsXG5cblx0Ly8gRGVmaW5lIGEgbG9jYWwgY29weSBvZiBqUXVlcnlcblx0alF1ZXJ5ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXG5cdFx0Ly8gVGhlIGpRdWVyeSBvYmplY3QgaXMgYWN0dWFsbHkganVzdCB0aGUgaW5pdCBjb25zdHJ1Y3RvciAnZW5oYW5jZWQnXG5cdFx0Ly8gTmVlZCBpbml0IGlmIGpRdWVyeSBpcyBjYWxsZWQgKGp1c3QgYWxsb3cgZXJyb3IgdG8gYmUgdGhyb3duIGlmIG5vdCBpbmNsdWRlZClcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5mbi5pbml0KCBzZWxlY3RvciwgY29udGV4dCApO1xuXHR9O1xuXG5qUXVlcnkuZm4gPSBqUXVlcnkucHJvdG90eXBlID0ge1xuXG5cdC8vIFRoZSBjdXJyZW50IHZlcnNpb24gb2YgalF1ZXJ5IGJlaW5nIHVzZWRcblx0anF1ZXJ5OiB2ZXJzaW9uLFxuXG5cdGNvbnN0cnVjdG9yOiBqUXVlcnksXG5cblx0Ly8gVGhlIGRlZmF1bHQgbGVuZ3RoIG9mIGEgalF1ZXJ5IG9iamVjdCBpcyAwXG5cdGxlbmd0aDogMCxcblxuXHR0b0FycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2xpY2UuY2FsbCggdGhpcyApO1xuXHR9LFxuXG5cdC8vIEdldCB0aGUgTnRoIGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgZWxlbWVudCBzZXQgT1Jcblx0Ly8gR2V0IHRoZSB3aG9sZSBtYXRjaGVkIGVsZW1lbnQgc2V0IGFzIGEgY2xlYW4gYXJyYXlcblx0Z2V0OiBmdW5jdGlvbiggbnVtICkge1xuXG5cdFx0Ly8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgaW4gYSBjbGVhbiBhcnJheVxuXHRcdGlmICggbnVtID09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gc2xpY2UuY2FsbCggdGhpcyApO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiBqdXN0IHRoZSBvbmUgZWxlbWVudCBmcm9tIHRoZSBzZXRcblx0XHRyZXR1cm4gbnVtIDwgMCA/IHRoaXNbIG51bSArIHRoaXMubGVuZ3RoIF0gOiB0aGlzWyBudW0gXTtcblx0fSxcblxuXHQvLyBUYWtlIGFuIGFycmF5IG9mIGVsZW1lbnRzIGFuZCBwdXNoIGl0IG9udG8gdGhlIHN0YWNrXG5cdC8vIChyZXR1cm5pbmcgdGhlIG5ldyBtYXRjaGVkIGVsZW1lbnQgc2V0KVxuXHRwdXNoU3RhY2s6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblxuXHRcdC8vIEJ1aWxkIGEgbmV3IGpRdWVyeSBtYXRjaGVkIGVsZW1lbnQgc2V0XG5cdFx0dmFyIHJldCA9IGpRdWVyeS5tZXJnZSggdGhpcy5jb25zdHJ1Y3RvcigpLCBlbGVtcyApO1xuXG5cdFx0Ly8gQWRkIHRoZSBvbGQgb2JqZWN0IG9udG8gdGhlIHN0YWNrIChhcyBhIHJlZmVyZW5jZSlcblx0XHRyZXQucHJldk9iamVjdCA9IHRoaXM7XG5cblx0XHQvLyBSZXR1cm4gdGhlIG5ld2x5LWZvcm1lZCBlbGVtZW50IHNldFxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0Ly8gRXhlY3V0ZSBhIGNhbGxiYWNrIGZvciBldmVyeSBlbGVtZW50IGluIHRoZSBtYXRjaGVkIHNldC5cblx0ZWFjaDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZWFjaCggdGhpcywgY2FsbGJhY2sgKTtcblx0fSxcblxuXHRtYXA6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeS5tYXAoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuIGNhbGxiYWNrLmNhbGwoIGVsZW0sIGksIGVsZW0gKTtcblx0XHR9ICkgKTtcblx0fSxcblxuXHRzbGljZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBzbGljZS5hcHBseSggdGhpcywgYXJndW1lbnRzICkgKTtcblx0fSxcblxuXHRmaXJzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIDAgKTtcblx0fSxcblxuXHRsYXN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggLTEgKTtcblx0fSxcblxuXHRldmVuOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeS5ncmVwKCB0aGlzLCBmdW5jdGlvbiggX2VsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gKCBpICsgMSApICUgMjtcblx0XHR9ICkgKTtcblx0fSxcblxuXHRvZGQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5LmdyZXAoIHRoaXMsIGZ1bmN0aW9uKCBfZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiBpICUgMjtcblx0XHR9ICkgKTtcblx0fSxcblxuXHRlcTogZnVuY3Rpb24oIGkgKSB7XG5cdFx0dmFyIGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0aiA9ICtpICsgKCBpIDwgMCA/IGxlbiA6IDAgKTtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGogPj0gMCAmJiBqIDwgbGVuID8gWyB0aGlzWyBqIF0gXSA6IFtdICk7XG5cdH0sXG5cblx0ZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wcmV2T2JqZWN0IHx8IHRoaXMuY29uc3RydWN0b3IoKTtcblx0fSxcblxuXHQvLyBGb3IgaW50ZXJuYWwgdXNlIG9ubHkuXG5cdC8vIEJlaGF2ZXMgbGlrZSBhbiBBcnJheSdzIG1ldGhvZCwgbm90IGxpa2UgYSBqUXVlcnkgbWV0aG9kLlxuXHRwdXNoOiBwdXNoLFxuXHRzb3J0OiBhcnIuc29ydCxcblx0c3BsaWNlOiBhcnIuc3BsaWNlXG59O1xuXG5qUXVlcnkuZXh0ZW5kID0galF1ZXJ5LmZuLmV4dGVuZCA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgb3B0aW9ucywgbmFtZSwgc3JjLCBjb3B5LCBjb3B5SXNBcnJheSwgY2xvbmUsXG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWyAwIF0gfHwge30sXG5cdFx0aSA9IDEsXG5cdFx0bGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcblx0XHRkZWVwID0gZmFsc2U7XG5cblx0Ly8gSGFuZGxlIGEgZGVlcCBjb3B5IHNpdHVhdGlvblxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdGRlZXAgPSB0YXJnZXQ7XG5cblx0XHQvLyBTa2lwIHRoZSBib29sZWFuIGFuZCB0aGUgdGFyZ2V0XG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWyBpIF0gfHwge307XG5cdFx0aSsrO1xuXHR9XG5cblx0Ly8gSGFuZGxlIGNhc2Ugd2hlbiB0YXJnZXQgaXMgYSBzdHJpbmcgb3Igc29tZXRoaW5nIChwb3NzaWJsZSBpbiBkZWVwIGNvcHkpXG5cdGlmICggdHlwZW9mIHRhcmdldCAhPT0gXCJvYmplY3RcIiAmJiAhaXNGdW5jdGlvbiggdGFyZ2V0ICkgKSB7XG5cdFx0dGFyZ2V0ID0ge307XG5cdH1cblxuXHQvLyBFeHRlbmQgalF1ZXJ5IGl0c2VsZiBpZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwYXNzZWRcblx0aWYgKCBpID09PSBsZW5ndGggKSB7XG5cdFx0dGFyZ2V0ID0gdGhpcztcblx0XHRpLS07XG5cdH1cblxuXHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblxuXHRcdC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcblx0XHRpZiAoICggb3B0aW9ucyA9IGFyZ3VtZW50c1sgaSBdICkgIT0gbnVsbCApIHtcblxuXHRcdFx0Ly8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxuXHRcdFx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdFx0XHRjb3B5ID0gb3B0aW9uc1sgbmFtZSBdO1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgT2JqZWN0LnByb3RvdHlwZSBwb2xsdXRpb25cblx0XHRcdFx0Ly8gUHJldmVudCBuZXZlci1lbmRpbmcgbG9vcFxuXHRcdFx0XHRpZiAoIG5hbWUgPT09IFwiX19wcm90b19fXCIgfHwgdGFyZ2V0ID09PSBjb3B5ICkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVjdXJzZSBpZiB3ZSdyZSBtZXJnaW5nIHBsYWluIG9iamVjdHMgb3IgYXJyYXlzXG5cdFx0XHRcdGlmICggZGVlcCAmJiBjb3B5ICYmICggalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvcHkgKSB8fFxuXHRcdFx0XHRcdCggY29weUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KCBjb3B5ICkgKSApICkge1xuXHRcdFx0XHRcdHNyYyA9IHRhcmdldFsgbmFtZSBdO1xuXG5cdFx0XHRcdFx0Ly8gRW5zdXJlIHByb3BlciB0eXBlIGZvciB0aGUgc291cmNlIHZhbHVlXG5cdFx0XHRcdFx0aWYgKCBjb3B5SXNBcnJheSAmJiAhQXJyYXkuaXNBcnJheSggc3JjICkgKSB7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IFtdO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoICFjb3B5SXNBcnJheSAmJiAhalF1ZXJ5LmlzUGxhaW5PYmplY3QoIHNyYyApICkge1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSB7fTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmM7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNvcHlJc0FycmF5ID0gZmFsc2U7XG5cblx0XHRcdFx0XHQvLyBOZXZlciBtb3ZlIG9yaWdpbmFsIG9iamVjdHMsIGNsb25lIHRoZW1cblx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGpRdWVyeS5leHRlbmQoIGRlZXAsIGNsb25lLCBjb3B5ICk7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgYnJpbmcgaW4gdW5kZWZpbmVkIHZhbHVlc1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBjb3B5ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBjb3B5O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBtb2RpZmllZCBvYmplY3Rcblx0cmV0dXJuIHRhcmdldDtcbn07XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBVbmlxdWUgZm9yIGVhY2ggY29weSBvZiBqUXVlcnkgb24gdGhlIHBhZ2Vcblx0ZXhwYW5kbzogXCJqUXVlcnlcIiArICggdmVyc2lvbiArIE1hdGgucmFuZG9tKCkgKS5yZXBsYWNlKCAvXFxEL2csIFwiXCIgKSxcblxuXHQvLyBBc3N1bWUgalF1ZXJ5IGlzIHJlYWR5IHdpdGhvdXQgdGhlIHJlYWR5IG1vZHVsZVxuXHRpc1JlYWR5OiB0cnVlLFxuXG5cdGVycm9yOiBmdW5jdGlvbiggbXNnICkge1xuXHRcdHRocm93IG5ldyBFcnJvciggbXNnICk7XG5cdH0sXG5cblx0bm9vcDogZnVuY3Rpb24oKSB7fSxcblxuXHRpc1BsYWluT2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHZhciBwcm90bywgQ3RvcjtcblxuXHRcdC8vIERldGVjdCBvYnZpb3VzIG5lZ2F0aXZlc1xuXHRcdC8vIFVzZSB0b1N0cmluZyBpbnN0ZWFkIG9mIGpRdWVyeS50eXBlIHRvIGNhdGNoIGhvc3Qgb2JqZWN0c1xuXHRcdGlmICggIW9iaiB8fCB0b1N0cmluZy5jYWxsKCBvYmogKSAhPT0gXCJbb2JqZWN0IE9iamVjdF1cIiApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRwcm90byA9IGdldFByb3RvKCBvYmogKTtcblxuXHRcdC8vIE9iamVjdHMgd2l0aCBubyBwcm90b3R5cGUgKGUuZy4sIGBPYmplY3QuY3JlYXRlKCBudWxsIClgKSBhcmUgcGxhaW5cblx0XHRpZiAoICFwcm90byApIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIE9iamVjdHMgd2l0aCBwcm90b3R5cGUgYXJlIHBsYWluIGlmZiB0aGV5IHdlcmUgY29uc3RydWN0ZWQgYnkgYSBnbG9iYWwgT2JqZWN0IGZ1bmN0aW9uXG5cdFx0Q3RvciA9IGhhc093bi5jYWxsKCBwcm90bywgXCJjb25zdHJ1Y3RvclwiICkgJiYgcHJvdG8uY29uc3RydWN0b3I7XG5cdFx0cmV0dXJuIHR5cGVvZiBDdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgZm5Ub1N0cmluZy5jYWxsKCBDdG9yICkgPT09IE9iamVjdEZ1bmN0aW9uU3RyaW5nO1xuXHR9LFxuXG5cdGlzRW1wdHlPYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0dmFyIG5hbWU7XG5cblx0XHRmb3IgKCBuYW1lIGluIG9iaiApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0Ly8gRXZhbHVhdGVzIGEgc2NyaXB0IGluIGEgcHJvdmlkZWQgY29udGV4dDsgZmFsbHMgYmFjayB0byB0aGUgZ2xvYmFsIG9uZVxuXHQvLyBpZiBub3Qgc3BlY2lmaWVkLlxuXHRnbG9iYWxFdmFsOiBmdW5jdGlvbiggY29kZSwgb3B0aW9ucywgZG9jICkge1xuXHRcdERPTUV2YWwoIGNvZGUsIHsgbm9uY2U6IG9wdGlvbnMgJiYgb3B0aW9ucy5ub25jZSB9LCBkb2MgKTtcblx0fSxcblxuXHRlYWNoOiBmdW5jdGlvbiggb2JqLCBjYWxsYmFjayApIHtcblx0XHR2YXIgbGVuZ3RoLCBpID0gMDtcblxuXHRcdGlmICggaXNBcnJheUxpa2UoIG9iaiApICkge1xuXHRcdFx0bGVuZ3RoID0gb2JqLmxlbmd0aDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCBpIGluIG9iaiApIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gb2JqO1xuXHR9LFxuXG5cdC8vIHJlc3VsdHMgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFrZUFycmF5OiBmdW5jdGlvbiggYXJyLCByZXN1bHRzICkge1xuXHRcdHZhciByZXQgPSByZXN1bHRzIHx8IFtdO1xuXG5cdFx0aWYgKCBhcnIgIT0gbnVsbCApIHtcblx0XHRcdGlmICggaXNBcnJheUxpa2UoIE9iamVjdCggYXJyICkgKSApIHtcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCByZXQsXG5cdFx0XHRcdFx0dHlwZW9mIGFyciA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0XHRbIGFyciBdIDogYXJyXG5cdFx0XHRcdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdXNoLmNhbGwoIHJldCwgYXJyICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHRpbkFycmF5OiBmdW5jdGlvbiggZWxlbSwgYXJyLCBpICkge1xuXHRcdHJldHVybiBhcnIgPT0gbnVsbCA/IC0xIDogaW5kZXhPZi5jYWxsKCBhcnIsIGVsZW0sIGkgKTtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRtZXJnZTogZnVuY3Rpb24oIGZpcnN0LCBzZWNvbmQgKSB7XG5cdFx0dmFyIGxlbiA9ICtzZWNvbmQubGVuZ3RoLFxuXHRcdFx0aiA9IDAsXG5cdFx0XHRpID0gZmlyc3QubGVuZ3RoO1xuXG5cdFx0Zm9yICggOyBqIDwgbGVuOyBqKysgKSB7XG5cdFx0XHRmaXJzdFsgaSsrIF0gPSBzZWNvbmRbIGogXTtcblx0XHR9XG5cblx0XHRmaXJzdC5sZW5ndGggPSBpO1xuXG5cdFx0cmV0dXJuIGZpcnN0O1xuXHR9LFxuXG5cdGdyZXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGludmVydCApIHtcblx0XHR2YXIgY2FsbGJhY2tJbnZlcnNlLFxuXHRcdFx0bWF0Y2hlcyA9IFtdLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGgsXG5cdFx0XHRjYWxsYmFja0V4cGVjdCA9ICFpbnZlcnQ7XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgb25seSBzYXZpbmcgdGhlIGl0ZW1zXG5cdFx0Ly8gdGhhdCBwYXNzIHRoZSB2YWxpZGF0b3IgZnVuY3Rpb25cblx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdGNhbGxiYWNrSW52ZXJzZSA9ICFjYWxsYmFjayggZWxlbXNbIGkgXSwgaSApO1xuXHRcdFx0aWYgKCBjYWxsYmFja0ludmVyc2UgIT09IGNhbGxiYWNrRXhwZWN0ICkge1xuXHRcdFx0XHRtYXRjaGVzLnB1c2goIGVsZW1zWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbWF0Y2hlcztcblx0fSxcblxuXHQvLyBhcmcgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBhcmcgKSB7XG5cdFx0dmFyIGxlbmd0aCwgdmFsdWUsXG5cdFx0XHRpID0gMCxcblx0XHRcdHJldCA9IFtdO1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIHRyYW5zbGF0aW5nIGVhY2ggb2YgdGhlIGl0ZW1zIHRvIHRoZWlyIG5ldyB2YWx1ZXNcblx0XHRpZiAoIGlzQXJyYXlMaWtlKCBlbGVtcyApICkge1xuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gR28gdGhyb3VnaCBldmVyeSBrZXkgb24gdGhlIG9iamVjdCxcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSBpbiBlbGVtcyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRcdHJldHVybiBmbGF0KCByZXQgKTtcblx0fSxcblxuXHQvLyBBIGdsb2JhbCBHVUlEIGNvdW50ZXIgZm9yIG9iamVjdHNcblx0Z3VpZDogMSxcblxuXHQvLyBqUXVlcnkuc3VwcG9ydCBpcyBub3QgdXNlZCBpbiBDb3JlIGJ1dCBvdGhlciBwcm9qZWN0cyBhdHRhY2ggdGhlaXJcblx0Ly8gcHJvcGVydGllcyB0byBpdCBzbyBpdCBuZWVkcyB0byBleGlzdC5cblx0c3VwcG9ydDogc3VwcG9ydFxufSApO1xuXG5pZiAoIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiApIHtcblx0alF1ZXJ5LmZuWyBTeW1ib2wuaXRlcmF0b3IgXSA9IGFyclsgU3ltYm9sLml0ZXJhdG9yIF07XG59XG5cbi8vIFBvcHVsYXRlIHRoZSBjbGFzczJ0eXBlIG1hcFxualF1ZXJ5LmVhY2goIFwiQm9vbGVhbiBOdW1iZXIgU3RyaW5nIEZ1bmN0aW9uIEFycmF5IERhdGUgUmVnRXhwIE9iamVjdCBFcnJvciBTeW1ib2xcIi5zcGxpdCggXCIgXCIgKSxcblx0ZnVuY3Rpb24oIF9pLCBuYW1lICkge1xuXHRcdGNsYXNzMnR5cGVbIFwiW29iamVjdCBcIiArIG5hbWUgKyBcIl1cIiBdID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXHR9ICk7XG5cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKCBvYmogKSB7XG5cblx0Ly8gU3VwcG9ydDogcmVhbCBpT1MgOC4yIG9ubHkgKG5vdCByZXByb2R1Y2libGUgaW4gc2ltdWxhdG9yKVxuXHQvLyBgaW5gIGNoZWNrIHVzZWQgdG8gcHJldmVudCBKSVQgZXJyb3IgKGdoLTIxNDUpXG5cdC8vIGhhc093biBpc24ndCB1c2VkIGhlcmUgZHVlIHRvIGZhbHNlIG5lZ2F0aXZlc1xuXHQvLyByZWdhcmRpbmcgTm9kZWxpc3QgbGVuZ3RoIGluIElFXG5cdHZhciBsZW5ndGggPSAhIW9iaiAmJiBcImxlbmd0aFwiIGluIG9iaiAmJiBvYmoubGVuZ3RoLFxuXHRcdHR5cGUgPSB0b1R5cGUoIG9iaiApO1xuXG5cdGlmICggaXNGdW5jdGlvbiggb2JqICkgfHwgaXNXaW5kb3coIG9iaiApICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHJldHVybiB0eXBlID09PSBcImFycmF5XCIgfHwgbGVuZ3RoID09PSAwIHx8XG5cdFx0dHlwZW9mIGxlbmd0aCA9PT0gXCJudW1iZXJcIiAmJiBsZW5ndGggPiAwICYmICggbGVuZ3RoIC0gMSApIGluIG9iajtcbn1cbnZhciBTaXp6bGUgPVxuLyohXG4gKiBTaXp6bGUgQ1NTIFNlbGVjdG9yIEVuZ2luZSB2Mi4zLjZcbiAqIGh0dHBzOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCBKUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cHM6Ly9qcy5mb3VuZGF0aW9uL1xuICpcbiAqIERhdGU6IDIwMjEtMDItMTZcbiAqL1xuKCBmdW5jdGlvbiggd2luZG93ICkge1xudmFyIGksXG5cdHN1cHBvcnQsXG5cdEV4cHIsXG5cdGdldFRleHQsXG5cdGlzWE1MLFxuXHR0b2tlbml6ZSxcblx0Y29tcGlsZSxcblx0c2VsZWN0LFxuXHRvdXRlcm1vc3RDb250ZXh0LFxuXHRzb3J0SW5wdXQsXG5cdGhhc0R1cGxpY2F0ZSxcblxuXHQvLyBMb2NhbCBkb2N1bWVudCB2YXJzXG5cdHNldERvY3VtZW50LFxuXHRkb2N1bWVudCxcblx0ZG9jRWxlbSxcblx0ZG9jdW1lbnRJc0hUTUwsXG5cdHJidWdneVFTQSxcblx0cmJ1Z2d5TWF0Y2hlcyxcblx0bWF0Y2hlcyxcblx0Y29udGFpbnMsXG5cblx0Ly8gSW5zdGFuY2Utc3BlY2lmaWMgZGF0YVxuXHRleHBhbmRvID0gXCJzaXp6bGVcIiArIDEgKiBuZXcgRGF0ZSgpLFxuXHRwcmVmZXJyZWREb2MgPSB3aW5kb3cuZG9jdW1lbnQsXG5cdGRpcnJ1bnMgPSAwLFxuXHRkb25lID0gMCxcblx0Y2xhc3NDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHRva2VuQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRjb21waWxlckNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0bm9ubmF0aXZlU2VsZWN0b3JDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHNvcnRPcmRlciA9IGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiAwO1xuXHR9LFxuXG5cdC8vIEluc3RhbmNlIG1ldGhvZHNcblx0aGFzT3duID0gKCB7fSApLmhhc093blByb3BlcnR5LFxuXHRhcnIgPSBbXSxcblx0cG9wID0gYXJyLnBvcCxcblx0cHVzaE5hdGl2ZSA9IGFyci5wdXNoLFxuXHRwdXNoID0gYXJyLnB1c2gsXG5cdHNsaWNlID0gYXJyLnNsaWNlLFxuXG5cdC8vIFVzZSBhIHN0cmlwcGVkLWRvd24gaW5kZXhPZiBhcyBpdCdzIGZhc3RlciB0aGFuIG5hdGl2ZVxuXHQvLyBodHRwczovL2pzcGVyZi5jb20vdGhvci1pbmRleG9mLXZzLWZvci81XG5cdGluZGV4T2YgPSBmdW5jdGlvbiggbGlzdCwgZWxlbSApIHtcblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRsZW4gPSBsaXN0Lmxlbmd0aDtcblx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGlmICggbGlzdFsgaSBdID09PSBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIC0xO1xuXHR9LFxuXG5cdGJvb2xlYW5zID0gXCJjaGVja2VkfHNlbGVjdGVkfGFzeW5jfGF1dG9mb2N1c3xhdXRvcGxheXxjb250cm9sc3xkZWZlcnxkaXNhYmxlZHxoaWRkZW58XCIgK1xuXHRcdFwiaXNtYXB8bG9vcHxtdWx0aXBsZXxvcGVufHJlYWRvbmx5fHJlcXVpcmVkfHNjb3BlZFwiLFxuXG5cdC8vIFJlZ3VsYXIgZXhwcmVzc2lvbnNcblxuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXNlbGVjdG9ycy8jd2hpdGVzcGFjZVxuXHR3aGl0ZXNwYWNlID0gXCJbXFxcXHgyMFxcXFx0XFxcXHJcXFxcblxcXFxmXVwiLFxuXG5cdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9jc3Mtc3ludGF4LTMvI2lkZW50LXRva2VuLWRpYWdyYW1cblx0aWRlbnRpZmllciA9IFwiKD86XFxcXFxcXFxbXFxcXGRhLWZBLUZdezEsNn1cIiArIHdoaXRlc3BhY2UgK1xuXHRcdFwiP3xcXFxcXFxcXFteXFxcXHJcXFxcblxcXFxmXXxbXFxcXHctXXxbXlxcMC1cXFxceDdmXSkrXCIsXG5cblx0Ly8gQXR0cmlidXRlIHNlbGVjdG9yczogaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNhdHRyaWJ1dGUtc2VsZWN0b3JzXG5cdGF0dHJpYnV0ZXMgPSBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFwiICsgaWRlbnRpZmllciArIFwiKSg/OlwiICsgd2hpdGVzcGFjZSArXG5cblx0XHQvLyBPcGVyYXRvciAoY2FwdHVyZSAyKVxuXHRcdFwiKihbKl4kfCF+XT89KVwiICsgd2hpdGVzcGFjZSArXG5cblx0XHQvLyBcIkF0dHJpYnV0ZSB2YWx1ZXMgbXVzdCBiZSBDU1MgaWRlbnRpZmllcnMgW2NhcHR1cmUgNV1cblx0XHQvLyBvciBzdHJpbmdzIFtjYXB0dXJlIDMgb3IgY2FwdHVyZSA0XVwiXG5cdFx0XCIqKD86JygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwifChcIiArIGlkZW50aWZpZXIgKyBcIikpfClcIiArXG5cdFx0d2hpdGVzcGFjZSArIFwiKlxcXFxdXCIsXG5cblx0cHNldWRvcyA9IFwiOihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcXFxcKChcIiArXG5cblx0XHQvLyBUbyByZWR1Y2UgdGhlIG51bWJlciBvZiBzZWxlY3RvcnMgbmVlZGluZyB0b2tlbml6ZSBpbiB0aGUgcHJlRmlsdGVyLCBwcmVmZXIgYXJndW1lbnRzOlxuXHRcdC8vIDEuIHF1b3RlZCAoY2FwdHVyZSAzOyBjYXB0dXJlIDQgb3IgY2FwdHVyZSA1KVxuXHRcdFwiKCcoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcIil8XCIgK1xuXG5cdFx0Ly8gMi4gc2ltcGxlIChjYXB0dXJlIDYpXG5cdFx0XCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKVtcXFxcXV18XCIgKyBhdHRyaWJ1dGVzICsgXCIpKil8XCIgK1xuXG5cdFx0Ly8gMy4gYW55dGhpbmcgZWxzZSAoY2FwdHVyZSAyKVxuXHRcdFwiLipcIiArXG5cdFx0XCIpXFxcXCl8KVwiLFxuXG5cdC8vIExlYWRpbmcgYW5kIG5vbi1lc2NhcGVkIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGNhcHR1cmluZyBzb21lIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMgcHJlY2VkaW5nIHRoZSBsYXR0ZXJcblx0cndoaXRlc3BhY2UgPSBuZXcgUmVnRXhwKCB3aGl0ZXNwYWNlICsgXCIrXCIsIFwiZ1wiICksXG5cdHJ0cmltID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIrfCgoPzpefFteXFxcXFxcXFxdKSg/OlxcXFxcXFxcLikqKVwiICtcblx0XHR3aGl0ZXNwYWNlICsgXCIrJFwiLCBcImdcIiApLFxuXG5cdHJjb21tYSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKixcIiArIHdoaXRlc3BhY2UgKyBcIipcIiApLFxuXHRyY29tYmluYXRvcnMgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiooWz4rfl18XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcIipcIiApLFxuXHRyZGVzY2VuZCA9IG5ldyBSZWdFeHAoIHdoaXRlc3BhY2UgKyBcInw+XCIgKSxcblxuXHRycHNldWRvID0gbmV3IFJlZ0V4cCggcHNldWRvcyApLFxuXHRyaWRlbnRpZmllciA9IG5ldyBSZWdFeHAoIFwiXlwiICsgaWRlbnRpZmllciArIFwiJFwiICksXG5cblx0bWF0Y2hFeHByID0ge1xuXHRcdFwiSURcIjogbmV3IFJlZ0V4cCggXCJeIyhcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuXHRcdFwiQ0xBU1NcIjogbmV3IFJlZ0V4cCggXCJeXFxcXC4oXCIgKyBpZGVudGlmaWVyICsgXCIpXCIgKSxcblx0XHRcIlRBR1wiOiBuZXcgUmVnRXhwKCBcIl4oXCIgKyBpZGVudGlmaWVyICsgXCJ8WypdKVwiICksXG5cdFx0XCJBVFRSXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgYXR0cmlidXRlcyApLFxuXHRcdFwiUFNFVURPXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgcHNldWRvcyApLFxuXHRcdFwiQ0hJTERcIjogbmV3IFJlZ0V4cCggXCJeOihvbmx5fGZpcnN0fGxhc3R8bnRofG50aC1sYXN0KS0oY2hpbGR8b2YtdHlwZSkoPzpcXFxcKFwiICtcblx0XHRcdHdoaXRlc3BhY2UgKyBcIiooZXZlbnxvZGR8KChbKy1dfCkoXFxcXGQqKW58KVwiICsgd2hpdGVzcGFjZSArIFwiKig/OihbKy1dfClcIiArXG5cdFx0XHR3aGl0ZXNwYWNlICsgXCIqKFxcXFxkKyl8KSlcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpXCIsIFwiaVwiICksXG5cdFx0XCJib29sXCI6IG5ldyBSZWdFeHAoIFwiXig/OlwiICsgYm9vbGVhbnMgKyBcIikkXCIsIFwiaVwiICksXG5cblx0XHQvLyBGb3IgdXNlIGluIGxpYnJhcmllcyBpbXBsZW1lbnRpbmcgLmlzKClcblx0XHQvLyBXZSB1c2UgdGhpcyBmb3IgUE9TIG1hdGNoaW5nIGluIGBzZWxlY3RgXG5cdFx0XCJuZWVkc0NvbnRleHRcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKls+K35dfDooZXZlbnxvZGR8ZXF8Z3R8bHR8bnRofGZpcnN0fGxhc3QpKD86XFxcXChcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqKCg/Oi1cXFxcZCk/XFxcXGQqKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfCkoPz1bXi1dfCQpXCIsIFwiaVwiIClcblx0fSxcblxuXHRyaHRtbCA9IC9IVE1MJC9pLFxuXHRyaW5wdXRzID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcblx0cmhlYWRlciA9IC9eaFxcZCQvaSxcblxuXHRybmF0aXZlID0gL15bXntdK1xce1xccypcXFtuYXRpdmUgXFx3LyxcblxuXHQvLyBFYXNpbHktcGFyc2VhYmxlL3JldHJpZXZhYmxlIElEIG9yIFRBRyBvciBDTEFTUyBzZWxlY3RvcnNcblx0cnF1aWNrRXhwciA9IC9eKD86IyhbXFx3LV0rKXwoXFx3Kyl8XFwuKFtcXHctXSspKSQvLFxuXG5cdHJzaWJsaW5nID0gL1srfl0vLFxuXG5cdC8vIENTUyBlc2NhcGVzXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCNlc2NhcGVkLWNoYXJhY3RlcnNcblx0cnVuZXNjYXBlID0gbmV3IFJlZ0V4cCggXCJcXFxcXFxcXFtcXFxcZGEtZkEtRl17MSw2fVwiICsgd2hpdGVzcGFjZSArIFwiP3xcXFxcXFxcXChbXlxcXFxyXFxcXG5cXFxcZl0pXCIsIFwiZ1wiICksXG5cdGZ1bmVzY2FwZSA9IGZ1bmN0aW9uKCBlc2NhcGUsIG5vbkhleCApIHtcblx0XHR2YXIgaGlnaCA9IFwiMHhcIiArIGVzY2FwZS5zbGljZSggMSApIC0gMHgxMDAwMDtcblxuXHRcdHJldHVybiBub25IZXggP1xuXG5cdFx0XHQvLyBTdHJpcCB0aGUgYmFja3NsYXNoIHByZWZpeCBmcm9tIGEgbm9uLWhleCBlc2NhcGUgc2VxdWVuY2Vcblx0XHRcdG5vbkhleCA6XG5cblx0XHRcdC8vIFJlcGxhY2UgYSBoZXhhZGVjaW1hbCBlc2NhcGUgc2VxdWVuY2Ugd2l0aCB0aGUgZW5jb2RlZCBVbmljb2RlIGNvZGUgcG9pbnRcblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9MTErXG5cdFx0XHQvLyBGb3IgdmFsdWVzIG91dHNpZGUgdGhlIEJhc2ljIE11bHRpbGluZ3VhbCBQbGFuZSAoQk1QKSwgbWFudWFsbHkgY29uc3RydWN0IGFcblx0XHRcdC8vIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRoaWdoIDwgMCA/XG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggKyAweDEwMDAwICkgOlxuXHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoID4+IDEwIHwgMHhEODAwLCBoaWdoICYgMHgzRkYgfCAweERDMDAgKTtcblx0fSxcblxuXHQvLyBDU1Mgc3RyaW5nL2lkZW50aWZpZXIgc2VyaWFsaXphdGlvblxuXHQvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI2NvbW1vbi1zZXJpYWxpemluZy1pZGlvbXNcblx0cmNzc2VzY2FwZSA9IC8oW1xcMC1cXHgxZlxceDdmXXxeLT9cXGQpfF4tJHxbXlxcMC1cXHgxZlxceDdmLVxcdUZGRkZcXHctXS9nLFxuXHRmY3NzZXNjYXBlID0gZnVuY3Rpb24oIGNoLCBhc0NvZGVQb2ludCApIHtcblx0XHRpZiAoIGFzQ29kZVBvaW50ICkge1xuXG5cdFx0XHQvLyBVKzAwMDAgTlVMTCBiZWNvbWVzIFUrRkZGRCBSRVBMQUNFTUVOVCBDSEFSQUNURVJcblx0XHRcdGlmICggY2ggPT09IFwiXFwwXCIgKSB7XG5cdFx0XHRcdHJldHVybiBcIlxcdUZGRkRcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udHJvbCBjaGFyYWN0ZXJzIGFuZCAoZGVwZW5kZW50IHVwb24gcG9zaXRpb24pIG51bWJlcnMgZ2V0IGVzY2FwZWQgYXMgY29kZSBwb2ludHNcblx0XHRcdHJldHVybiBjaC5zbGljZSggMCwgLTEgKSArIFwiXFxcXFwiICtcblx0XHRcdFx0Y2guY2hhckNvZGVBdCggY2gubGVuZ3RoIC0gMSApLnRvU3RyaW5nKCAxNiApICsgXCIgXCI7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXIgcG90ZW50aWFsbHktc3BlY2lhbCBBU0NJSSBjaGFyYWN0ZXJzIGdldCBiYWNrc2xhc2gtZXNjYXBlZFxuXHRcdHJldHVybiBcIlxcXFxcIiArIGNoO1xuXHR9LFxuXG5cdC8vIFVzZWQgZm9yIGlmcmFtZXNcblx0Ly8gU2VlIHNldERvY3VtZW50KClcblx0Ly8gUmVtb3ZpbmcgdGhlIGZ1bmN0aW9uIHdyYXBwZXIgY2F1c2VzIGEgXCJQZXJtaXNzaW9uIERlbmllZFwiXG5cdC8vIGVycm9yIGluIElFXG5cdHVubG9hZEhhbmRsZXIgPSBmdW5jdGlvbigpIHtcblx0XHRzZXREb2N1bWVudCgpO1xuXHR9LFxuXG5cdGluRGlzYWJsZWRGaWVsZHNldCA9IGFkZENvbWJpbmF0b3IoXG5cdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gdHJ1ZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiZmllbGRzZXRcIjtcblx0XHR9LFxuXHRcdHsgZGlyOiBcInBhcmVudE5vZGVcIiwgbmV4dDogXCJsZWdlbmRcIiB9XG5cdCk7XG5cbi8vIE9wdGltaXplIGZvciBwdXNoLmFwcGx5KCBfLCBOb2RlTGlzdCApXG50cnkge1xuXHRwdXNoLmFwcGx5KFxuXHRcdCggYXJyID0gc2xpY2UuY2FsbCggcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMgKSApLFxuXHRcdHByZWZlcnJlZERvYy5jaGlsZE5vZGVzXG5cdCk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjBcblx0Ly8gRGV0ZWN0IHNpbGVudGx5IGZhaWxpbmcgcHVzaC5hcHBseVxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG5cdGFyclsgcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMubGVuZ3RoIF0ubm9kZVR5cGU7XG59IGNhdGNoICggZSApIHtcblx0cHVzaCA9IHsgYXBwbHk6IGFyci5sZW5ndGggP1xuXG5cdFx0Ly8gTGV2ZXJhZ2Ugc2xpY2UgaWYgcG9zc2libGVcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHRwdXNoTmF0aXZlLmFwcGx5KCB0YXJnZXQsIHNsaWNlLmNhbGwoIGVscyApICk7XG5cdFx0fSA6XG5cblx0XHQvLyBTdXBwb3J0OiBJRTw5XG5cdFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZCBkaXJlY3RseVxuXHRcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHZhciBqID0gdGFyZ2V0Lmxlbmd0aCxcblx0XHRcdFx0aSA9IDA7XG5cblx0XHRcdC8vIENhbid0IHRydXN0IE5vZGVMaXN0Lmxlbmd0aFxuXHRcdFx0d2hpbGUgKCAoIHRhcmdldFsgaisrIF0gPSBlbHNbIGkrKyBdICkgKSB7fVxuXHRcdFx0dGFyZ2V0Lmxlbmd0aCA9IGogLSAxO1xuXHRcdH1cblx0fTtcbn1cblxuZnVuY3Rpb24gU2l6emxlKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIG0sIGksIGVsZW0sIG5pZCwgbWF0Y2gsIGdyb3VwcywgbmV3U2VsZWN0b3IsXG5cdFx0bmV3Q29udGV4dCA9IGNvbnRleHQgJiYgY29udGV4dC5vd25lckRvY3VtZW50LFxuXG5cdFx0Ly8gbm9kZVR5cGUgZGVmYXVsdHMgdG8gOSwgc2luY2UgY29udGV4dCBkZWZhdWx0cyB0byBkb2N1bWVudFxuXHRcdG5vZGVUeXBlID0gY29udGV4dCA/IGNvbnRleHQubm9kZVR5cGUgOiA5O1xuXG5cdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG5cdC8vIFJldHVybiBlYXJseSBmcm9tIGNhbGxzIHdpdGggaW52YWxpZCBzZWxlY3RvciBvciBjb250ZXh0XG5cdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiIHx8ICFzZWxlY3RvciB8fFxuXHRcdG5vZGVUeXBlICE9PSAxICYmIG5vZGVUeXBlICE9PSA5ICYmIG5vZGVUeXBlICE9PSAxMSApIHtcblxuXHRcdHJldHVybiByZXN1bHRzO1xuXHR9XG5cblx0Ly8gVHJ5IHRvIHNob3J0Y3V0IGZpbmQgb3BlcmF0aW9ucyAoYXMgb3Bwb3NlZCB0byBmaWx0ZXJzKSBpbiBIVE1MIGRvY3VtZW50c1xuXHRpZiAoICFzZWVkICkge1xuXHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdFx0Y29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7XG5cblx0XHRpZiAoIGRvY3VtZW50SXNIVE1MICkge1xuXG5cdFx0XHQvLyBJZiB0aGUgc2VsZWN0b3IgaXMgc3VmZmljaWVudGx5IHNpbXBsZSwgdHJ5IHVzaW5nIGEgXCJnZXQqQnkqXCIgRE9NIG1ldGhvZFxuXHRcdFx0Ly8gKGV4Y2VwdGluZyBEb2N1bWVudEZyYWdtZW50IGNvbnRleHQsIHdoZXJlIHRoZSBtZXRob2RzIGRvbid0IGV4aXN0KVxuXHRcdFx0aWYgKCBub2RlVHlwZSAhPT0gMTEgJiYgKCBtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKSApICkge1xuXG5cdFx0XHRcdC8vIElEIHNlbGVjdG9yXG5cdFx0XHRcdGlmICggKCBtID0gbWF0Y2hbIDEgXSApICkge1xuXG5cdFx0XHRcdFx0Ly8gRG9jdW1lbnQgY29udGV4dFxuXHRcdFx0XHRcdGlmICggbm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICggZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSApICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFLCBPcGVyYSwgV2Via2l0XG5cdFx0XHRcdFx0XHRcdC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXG5cdFx0XHRcdFx0XHRcdC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdFx0aWYgKCBlbGVtLmlkID09PSBtICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEVsZW1lbnQgY29udGV4dFxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFLCBPcGVyYSwgV2Via2l0XG5cdFx0XHRcdFx0XHQvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xuXHRcdFx0XHRcdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0aWYgKCBuZXdDb250ZXh0ICYmICggZWxlbSA9IG5ld0NvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSApICYmXG5cdFx0XHRcdFx0XHRcdGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICkgJiZcblx0XHRcdFx0XHRcdFx0ZWxlbS5pZCA9PT0gbSApIHtcblxuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFR5cGUgc2VsZWN0b3Jcblx0XHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbIDIgXSApIHtcblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBzZWxlY3RvciApICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdFx0Ly8gQ2xhc3Mgc2VsZWN0b3Jcblx0XHRcdFx0fSBlbHNlIGlmICggKCBtID0gbWF0Y2hbIDMgXSApICYmIHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJlxuXHRcdFx0XHRcdGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggbSApICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVGFrZSBhZHZhbnRhZ2Ugb2YgcXVlcnlTZWxlY3RvckFsbFxuXHRcdFx0aWYgKCBzdXBwb3J0LnFzYSAmJlxuXHRcdFx0XHQhbm9ubmF0aXZlU2VsZWN0b3JDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdICYmXG5cdFx0XHRcdCggIXJidWdneVFTQSB8fCAhcmJ1Z2d5UVNBLnRlc3QoIHNlbGVjdG9yICkgKSAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDggb25seVxuXHRcdFx0XHQvLyBFeGNsdWRlIG9iamVjdCBlbGVtZW50c1xuXHRcdFx0XHQoIG5vZGVUeXBlICE9PSAxIHx8IGNvbnRleHQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCJvYmplY3RcIiApICkge1xuXG5cdFx0XHRcdG5ld1NlbGVjdG9yID0gc2VsZWN0b3I7XG5cdFx0XHRcdG5ld0NvbnRleHQgPSBjb250ZXh0O1xuXG5cdFx0XHRcdC8vIHFTQSBjb25zaWRlcnMgZWxlbWVudHMgb3V0c2lkZSBhIHNjb3Bpbmcgcm9vdCB3aGVuIGV2YWx1YXRpbmcgY2hpbGQgb3Jcblx0XHRcdFx0Ly8gZGVzY2VuZGFudCBjb21iaW5hdG9ycywgd2hpY2ggaXMgbm90IHdoYXQgd2Ugd2FudC5cblx0XHRcdFx0Ly8gSW4gc3VjaCBjYXNlcywgd2Ugd29yayBhcm91bmQgdGhlIGJlaGF2aW9yIGJ5IHByZWZpeGluZyBldmVyeSBzZWxlY3RvciBpbiB0aGVcblx0XHRcdFx0Ly8gbGlzdCB3aXRoIGFuIElEIHNlbGVjdG9yIHJlZmVyZW5jaW5nIHRoZSBzY29wZSBjb250ZXh0LlxuXHRcdFx0XHQvLyBUaGUgdGVjaG5pcXVlIGhhcyB0byBiZSB1c2VkIGFzIHdlbGwgd2hlbiBhIGxlYWRpbmcgY29tYmluYXRvciBpcyB1c2VkXG5cdFx0XHRcdC8vIGFzIHN1Y2ggc2VsZWN0b3JzIGFyZSBub3QgcmVjb2duaXplZCBieSBxdWVyeVNlbGVjdG9yQWxsLlxuXHRcdFx0XHQvLyBUaGFua3MgdG8gQW5kcmV3IER1cG9udCBmb3IgdGhpcyB0ZWNobmlxdWUuXG5cdFx0XHRcdGlmICggbm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0XHQoIHJkZXNjZW5kLnRlc3QoIHNlbGVjdG9yICkgfHwgcmNvbWJpbmF0b3JzLnRlc3QoIHNlbGVjdG9yICkgKSApIHtcblxuXHRcdFx0XHRcdC8vIEV4cGFuZCBjb250ZXh0IGZvciBzaWJsaW5nIHNlbGVjdG9yc1xuXHRcdFx0XHRcdG5ld0NvbnRleHQgPSByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fFxuXHRcdFx0XHRcdFx0Y29udGV4dDtcblxuXHRcdFx0XHRcdC8vIFdlIGNhbiB1c2UgOnNjb3BlIGluc3RlYWQgb2YgdGhlIElEIGhhY2sgaWYgdGhlIGJyb3dzZXJcblx0XHRcdFx0XHQvLyBzdXBwb3J0cyBpdCAmIGlmIHdlJ3JlIG5vdCBjaGFuZ2luZyB0aGUgY29udGV4dC5cblx0XHRcdFx0XHRpZiAoIG5ld0NvbnRleHQgIT09IGNvbnRleHQgfHwgIXN1cHBvcnQuc2NvcGUgKSB7XG5cblx0XHRcdFx0XHRcdC8vIENhcHR1cmUgdGhlIGNvbnRleHQgSUQsIHNldHRpbmcgaXQgZmlyc3QgaWYgbmVjZXNzYXJ5XG5cdFx0XHRcdFx0XHRpZiAoICggbmlkID0gY29udGV4dC5nZXRBdHRyaWJ1dGUoIFwiaWRcIiApICkgKSB7XG5cdFx0XHRcdFx0XHRcdG5pZCA9IG5pZC5yZXBsYWNlKCByY3NzZXNjYXBlLCBmY3NzZXNjYXBlICk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRjb250ZXh0LnNldEF0dHJpYnV0ZSggXCJpZFwiLCAoIG5pZCA9IGV4cGFuZG8gKSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZWZpeCBldmVyeSBzZWxlY3RvciBpbiB0aGUgbGlzdFxuXHRcdFx0XHRcdGdyb3VwcyA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdFx0XHRcdGkgPSBncm91cHMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0Z3JvdXBzWyBpIF0gPSAoIG5pZCA/IFwiI1wiICsgbmlkIDogXCI6c2NvcGVcIiApICsgXCIgXCIgK1xuXHRcdFx0XHRcdFx0XHR0b1NlbGVjdG9yKCBncm91cHNbIGkgXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRuZXdTZWxlY3RvciA9IGdyb3Vwcy5qb2luKCBcIixcIiApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLFxuXHRcdFx0XHRcdFx0bmV3Q29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCBuZXdTZWxlY3RvciApXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0fSBjYXRjaCAoIHFzYUVycm9yICkge1xuXHRcdFx0XHRcdG5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGUoIHNlbGVjdG9yLCB0cnVlICk7XG5cdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0aWYgKCBuaWQgPT09IGV4cGFuZG8gKSB7XG5cdFx0XHRcdFx0XHRjb250ZXh0LnJlbW92ZUF0dHJpYnV0ZSggXCJpZFwiICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQWxsIG90aGVyc1xuXHRyZXR1cm4gc2VsZWN0KCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUga2V5LXZhbHVlIGNhY2hlcyBvZiBsaW1pdGVkIHNpemVcbiAqIEByZXR1cm5zIHtmdW5jdGlvbihzdHJpbmcsIG9iamVjdCl9IFJldHVybnMgdGhlIE9iamVjdCBkYXRhIGFmdGVyIHN0b3JpbmcgaXQgb24gaXRzZWxmIHdpdGhcbiAqXHRwcm9wZXJ0eSBuYW1lIHRoZSAoc3BhY2Utc3VmZml4ZWQpIHN0cmluZyBhbmQgKGlmIHRoZSBjYWNoZSBpcyBsYXJnZXIgdGhhbiBFeHByLmNhY2hlTGVuZ3RoKVxuICpcdGRlbGV0aW5nIHRoZSBvbGRlc3QgZW50cnlcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2FjaGUoKSB7XG5cdHZhciBrZXlzID0gW107XG5cblx0ZnVuY3Rpb24gY2FjaGUoIGtleSwgdmFsdWUgKSB7XG5cblx0XHQvLyBVc2UgKGtleSArIFwiIFwiKSB0byBhdm9pZCBjb2xsaXNpb24gd2l0aCBuYXRpdmUgcHJvdG90eXBlIHByb3BlcnRpZXMgKHNlZSBJc3N1ZSAjMTU3KVxuXHRcdGlmICgga2V5cy5wdXNoKCBrZXkgKyBcIiBcIiApID4gRXhwci5jYWNoZUxlbmd0aCApIHtcblxuXHRcdFx0Ly8gT25seSBrZWVwIHRoZSBtb3N0IHJlY2VudCBlbnRyaWVzXG5cdFx0XHRkZWxldGUgY2FjaGVbIGtleXMuc2hpZnQoKSBdO1xuXHRcdH1cblx0XHRyZXR1cm4gKCBjYWNoZVsga2V5ICsgXCIgXCIgXSA9IHZhbHVlICk7XG5cdH1cblx0cmV0dXJuIGNhY2hlO1xufVxuXG4vKipcbiAqIE1hcmsgYSBmdW5jdGlvbiBmb3Igc3BlY2lhbCB1c2UgYnkgU2l6emxlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gbWFya1xuICovXG5mdW5jdGlvbiBtYXJrRnVuY3Rpb24oIGZuICkge1xuXHRmblsgZXhwYW5kbyBdID0gdHJ1ZTtcblx0cmV0dXJuIGZuO1xufVxuXG4vKipcbiAqIFN1cHBvcnQgdGVzdGluZyB1c2luZyBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBQYXNzZWQgdGhlIGNyZWF0ZWQgZWxlbWVudCBhbmQgcmV0dXJucyBhIGJvb2xlYW4gcmVzdWx0XG4gKi9cbmZ1bmN0aW9uIGFzc2VydCggZm4gKSB7XG5cdHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZmllbGRzZXRcIiApO1xuXG5cdHRyeSB7XG5cdFx0cmV0dXJuICEhZm4oIGVsICk7XG5cdH0gY2F0Y2ggKCBlICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fSBmaW5hbGx5IHtcblxuXHRcdC8vIFJlbW92ZSBmcm9tIGl0cyBwYXJlbnQgYnkgZGVmYXVsdFxuXHRcdGlmICggZWwucGFyZW50Tm9kZSApIHtcblx0XHRcdGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIGVsICk7XG5cdFx0fVxuXG5cdFx0Ly8gcmVsZWFzZSBtZW1vcnkgaW4gSUVcblx0XHRlbCA9IG51bGw7XG5cdH1cbn1cblxuLyoqXG4gKiBBZGRzIHRoZSBzYW1lIGhhbmRsZXIgZm9yIGFsbCBvZiB0aGUgc3BlY2lmaWVkIGF0dHJzXG4gKiBAcGFyYW0ge1N0cmluZ30gYXR0cnMgUGlwZS1zZXBhcmF0ZWQgbGlzdCBvZiBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIFRoZSBtZXRob2QgdGhhdCB3aWxsIGJlIGFwcGxpZWRcbiAqL1xuZnVuY3Rpb24gYWRkSGFuZGxlKCBhdHRycywgaGFuZGxlciApIHtcblx0dmFyIGFyciA9IGF0dHJzLnNwbGl0KCBcInxcIiApLFxuXHRcdGkgPSBhcnIubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdEV4cHIuYXR0ckhhbmRsZVsgYXJyWyBpIF0gXSA9IGhhbmRsZXI7XG5cdH1cbn1cblxuLyoqXG4gKiBDaGVja3MgZG9jdW1lbnQgb3JkZXIgb2YgdHdvIHNpYmxpbmdzXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGFcbiAqIEBwYXJhbSB7RWxlbWVudH0gYlxuICogQHJldHVybnMge051bWJlcn0gUmV0dXJucyBsZXNzIHRoYW4gMCBpZiBhIHByZWNlZGVzIGIsIGdyZWF0ZXIgdGhhbiAwIGlmIGEgZm9sbG93cyBiXG4gKi9cbmZ1bmN0aW9uIHNpYmxpbmdDaGVjayggYSwgYiApIHtcblx0dmFyIGN1ciA9IGIgJiYgYSxcblx0XHRkaWZmID0gY3VyICYmIGEubm9kZVR5cGUgPT09IDEgJiYgYi5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0YS5zb3VyY2VJbmRleCAtIGIuc291cmNlSW5kZXg7XG5cblx0Ly8gVXNlIElFIHNvdXJjZUluZGV4IGlmIGF2YWlsYWJsZSBvbiBib3RoIG5vZGVzXG5cdGlmICggZGlmZiApIHtcblx0XHRyZXR1cm4gZGlmZjtcblx0fVxuXG5cdC8vIENoZWNrIGlmIGIgZm9sbG93cyBhXG5cdGlmICggY3VyICkge1xuXHRcdHdoaWxlICggKCBjdXIgPSBjdXIubmV4dFNpYmxpbmcgKSApIHtcblx0XHRcdGlmICggY3VyID09PSBiICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGEgPyAxIDogLTE7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBpbnB1dCB0eXBlc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5wdXRQc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGJ1dHRvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJ1dHRvblBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiAoIG5hbWUgPT09IFwiaW5wdXRcIiB8fCBuYW1lID09PSBcImJ1dHRvblwiICkgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgOmVuYWJsZWQvOmRpc2FibGVkXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGRpc2FibGVkIHRydWUgZm9yIDpkaXNhYmxlZDsgZmFsc2UgZm9yIDplbmFibGVkXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURpc2FibGVkUHNldWRvKCBkaXNhYmxlZCApIHtcblxuXHQvLyBLbm93biA6ZGlzYWJsZWQgZmFsc2UgcG9zaXRpdmVzOiBmaWVsZHNldFtkaXNhYmxlZF0gPiBsZWdlbmQ6bnRoLW9mLXR5cGUobisyKSA6Y2FuLWRpc2FibGVcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gT25seSBjZXJ0YWluIGVsZW1lbnRzIGNhbiBtYXRjaCA6ZW5hYmxlZCBvciA6ZGlzYWJsZWRcblx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zY3JpcHRpbmcuaHRtbCNzZWxlY3Rvci1lbmFibGVkXG5cdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2NyaXB0aW5nLmh0bWwjc2VsZWN0b3ItZGlzYWJsZWRcblx0XHRpZiAoIFwiZm9ybVwiIGluIGVsZW0gKSB7XG5cblx0XHRcdC8vIENoZWNrIGZvciBpbmhlcml0ZWQgZGlzYWJsZWRuZXNzIG9uIHJlbGV2YW50IG5vbi1kaXNhYmxlZCBlbGVtZW50czpcblx0XHRcdC8vICogbGlzdGVkIGZvcm0tYXNzb2NpYXRlZCBlbGVtZW50cyBpbiBhIGRpc2FibGVkIGZpZWxkc2V0XG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY2F0ZWdvcnktbGlzdGVkXG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY29uY2VwdC1mZS1kaXNhYmxlZFxuXHRcdFx0Ly8gKiBvcHRpb24gZWxlbWVudHMgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuXHRcdFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NvbmNlcHQtb3B0aW9uLWRpc2FibGVkXG5cdFx0XHQvLyBBbGwgc3VjaCBlbGVtZW50cyBoYXZlIGEgXCJmb3JtXCIgcHJvcGVydHkuXG5cdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSAmJiBlbGVtLmRpc2FibGVkID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHQvLyBPcHRpb24gZWxlbWVudHMgZGVmZXIgdG8gYSBwYXJlbnQgb3B0Z3JvdXAgaWYgcHJlc2VudFxuXHRcdFx0XHRpZiAoIFwibGFiZWxcIiBpbiBlbGVtICkge1xuXHRcdFx0XHRcdGlmICggXCJsYWJlbFwiIGluIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLnBhcmVudE5vZGUuZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgNiAtIDExXG5cdFx0XHRcdC8vIFVzZSB0aGUgaXNEaXNhYmxlZCBzaG9ydGN1dCBwcm9wZXJ0eSB0byBjaGVjayBmb3IgZGlzYWJsZWQgZmllbGRzZXQgYW5jZXN0b3JzXG5cdFx0XHRcdHJldHVybiBlbGVtLmlzRGlzYWJsZWQgPT09IGRpc2FibGVkIHx8XG5cblx0XHRcdFx0XHQvLyBXaGVyZSB0aGVyZSBpcyBubyBpc0Rpc2FibGVkLCBjaGVjayBtYW51YWxseVxuXHRcdFx0XHRcdC8qIGpzaGludCAtVzAxOCAqL1xuXHRcdFx0XHRcdGVsZW0uaXNEaXNhYmxlZCAhPT0gIWRpc2FibGVkICYmXG5cdFx0XHRcdFx0aW5EaXNhYmxlZEZpZWxkc2V0KCBlbGVtICkgPT09IGRpc2FibGVkO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cblx0XHQvLyBUcnkgdG8gd2lubm93IG91dCBlbGVtZW50cyB0aGF0IGNhbid0IGJlIGRpc2FibGVkIGJlZm9yZSB0cnVzdGluZyB0aGUgZGlzYWJsZWQgcHJvcGVydHkuXG5cdFx0Ly8gU29tZSB2aWN0aW1zIGdldCBjYXVnaHQgaW4gb3VyIG5ldCAobGFiZWwsIGxlZ2VuZCwgbWVudSwgdHJhY2spLCBidXQgaXQgc2hvdWxkbid0XG5cdFx0Ly8gZXZlbiBleGlzdCBvbiB0aGVtLCBsZXQgYWxvbmUgaGF2ZSBhIGJvb2xlYW4gdmFsdWUuXG5cdFx0fSBlbHNlIGlmICggXCJsYWJlbFwiIGluIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gUmVtYWluaW5nIGVsZW1lbnRzIGFyZSBuZWl0aGVyIDplbmFibGVkIG5vciA6ZGlzYWJsZWRcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBwb3NpdGlvbmFsc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZm4gKSB7XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBhcmd1bWVudCApIHtcblx0XHRhcmd1bWVudCA9ICthcmd1bWVudDtcblx0XHRyZXR1cm4gbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdHZhciBqLFxuXHRcdFx0XHRtYXRjaEluZGV4ZXMgPSBmbiggW10sIHNlZWQubGVuZ3RoLCBhcmd1bWVudCApLFxuXHRcdFx0XHRpID0gbWF0Y2hJbmRleGVzLmxlbmd0aDtcblxuXHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgZm91bmQgYXQgdGhlIHNwZWNpZmllZCBpbmRleGVzXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCBzZWVkWyAoIGogPSBtYXRjaEluZGV4ZXNbIGkgXSApIF0gKSB7XG5cdFx0XHRcdFx0c2VlZFsgaiBdID0gISggbWF0Y2hlc1sgaiBdID0gc2VlZFsgaiBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdH0gKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgYSBub2RlIGZvciB2YWxpZGl0eSBhcyBhIFNpenpsZSBjb250ZXh0XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0PX0gY29udGV4dFxuICogQHJldHVybnMge0VsZW1lbnR8T2JqZWN0fEJvb2xlYW59IFRoZSBpbnB1dCBub2RlIGlmIGFjY2VwdGFibGUsIG90aGVyd2lzZSBhIGZhbHN5IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHRlc3RDb250ZXh0KCBjb250ZXh0ICkge1xuXHRyZXR1cm4gY29udGV4dCAmJiB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjb250ZXh0O1xufVxuXG4vLyBFeHBvc2Ugc3VwcG9ydCB2YXJzIGZvciBjb252ZW5pZW5jZVxuc3VwcG9ydCA9IFNpenpsZS5zdXBwb3J0ID0ge307XG5cbi8qKlxuICogRGV0ZWN0cyBYTUwgbm9kZXNcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IGVsZW0gQW4gZWxlbWVudCBvciBhIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZmYgZWxlbSBpcyBhIG5vbi1IVE1MIFhNTCBub2RlXG4gKi9cbmlzWE1MID0gU2l6emxlLmlzWE1MID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHZhciBuYW1lc3BhY2UgPSBlbGVtICYmIGVsZW0ubmFtZXNwYWNlVVJJLFxuXHRcdGRvY0VsZW0gPSBlbGVtICYmICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKS5kb2N1bWVudEVsZW1lbnQ7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD04XG5cdC8vIEFzc3VtZSBIVE1MIHdoZW4gZG9jdW1lbnRFbGVtZW50IGRvZXNuJ3QgeWV0IGV4aXN0LCBzdWNoIGFzIGluc2lkZSBsb2FkaW5nIGlmcmFtZXNcblx0Ly8gaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzQ4MzNcblx0cmV0dXJuICFyaHRtbC50ZXN0KCBuYW1lc3BhY2UgfHwgZG9jRWxlbSAmJiBkb2NFbGVtLm5vZGVOYW1lIHx8IFwiSFRNTFwiICk7XG59O1xuXG4vKipcbiAqIFNldHMgZG9jdW1lbnQtcmVsYXRlZCB2YXJpYWJsZXMgb25jZSBiYXNlZCBvbiB0aGUgY3VycmVudCBkb2N1bWVudFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gW2RvY10gQW4gZWxlbWVudCBvciBkb2N1bWVudCBvYmplY3QgdG8gdXNlIHRvIHNldCB0aGUgZG9jdW1lbnRcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAqL1xuc2V0RG9jdW1lbnQgPSBTaXp6bGUuc2V0RG9jdW1lbnQgPSBmdW5jdGlvbiggbm9kZSApIHtcblx0dmFyIGhhc0NvbXBhcmUsIHN1YldpbmRvdyxcblx0XHRkb2MgPSBub2RlID8gbm9kZS5vd25lckRvY3VtZW50IHx8IG5vZGUgOiBwcmVmZXJyZWREb2M7XG5cblx0Ly8gUmV0dXJuIGVhcmx5IGlmIGRvYyBpcyBpbnZhbGlkIG9yIGFscmVhZHkgc2VsZWN0ZWRcblx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0aWYgKCBkb2MgPT0gZG9jdW1lbnQgfHwgZG9jLm5vZGVUeXBlICE9PSA5IHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50ICkge1xuXHRcdHJldHVybiBkb2N1bWVudDtcblx0fVxuXG5cdC8vIFVwZGF0ZSBnbG9iYWwgdmFyaWFibGVzXG5cdGRvY3VtZW50ID0gZG9jO1xuXHRkb2NFbGVtID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXHRkb2N1bWVudElzSFRNTCA9ICFpc1hNTCggZG9jdW1lbnQgKTtcblxuXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTErLCBFZGdlIDEyIC0gMTgrXG5cdC8vIEFjY2Vzc2luZyBpZnJhbWUgZG9jdW1lbnRzIGFmdGVyIHVubG9hZCB0aHJvd3MgXCJwZXJtaXNzaW9uIGRlbmllZFwiIGVycm9ycyAoalF1ZXJ5ICMxMzkzNilcblx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0aWYgKCBwcmVmZXJyZWREb2MgIT0gZG9jdW1lbnQgJiZcblx0XHQoIHN1YldpbmRvdyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3ICkgJiYgc3ViV2luZG93LnRvcCAhPT0gc3ViV2luZG93ICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgMTEsIEVkZ2Vcblx0XHRpZiAoIHN1YldpbmRvdy5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdFx0c3ViV2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIFwidW5sb2FkXCIsIHVubG9hZEhhbmRsZXIsIGZhbHNlICk7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTAgb25seVxuXHRcdH0gZWxzZSBpZiAoIHN1YldpbmRvdy5hdHRhY2hFdmVudCApIHtcblx0XHRcdHN1YldpbmRvdy5hdHRhY2hFdmVudCggXCJvbnVubG9hZFwiLCB1bmxvYWRIYW5kbGVyICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUUgOCAtIDExKywgRWRnZSAxMiAtIDE4KywgQ2hyb21lIDw9MTYgLSAyNSBvbmx5LCBGaXJlZm94IDw9My42IC0gMzEgb25seSxcblx0Ly8gU2FmYXJpIDQgLSA1IG9ubHksIE9wZXJhIDw9MTEuNiAtIDEyLnggb25seVxuXHQvLyBJRS9FZGdlICYgb2xkZXIgYnJvd3NlcnMgZG9uJ3Qgc3VwcG9ydCB0aGUgOnNjb3BlIHBzZXVkby1jbGFzcy5cblx0Ly8gU3VwcG9ydDogU2FmYXJpIDYuMCBvbmx5XG5cdC8vIFNhZmFyaSA2LjAgc3VwcG9ydHMgOnNjb3BlIGJ1dCBpdCdzIGFuIGFsaWFzIG9mIDpyb290IHRoZXJlLlxuXHRzdXBwb3J0LnNjb3BlID0gYXNzZXJ0KCBmdW5jdGlvbiggZWwgKSB7XG5cdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICk7XG5cdFx0cmV0dXJuIHR5cGVvZiBlbC5xdWVyeVNlbGVjdG9yQWxsICE9PSBcInVuZGVmaW5lZFwiICYmXG5cdFx0XHQhZWwucXVlcnlTZWxlY3RvckFsbCggXCI6c2NvcGUgZmllbGRzZXQgZGl2XCIgKS5sZW5ndGg7XG5cdH0gKTtcblxuXHQvKiBBdHRyaWJ1dGVzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBTdXBwb3J0OiBJRTw4XG5cdC8vIFZlcmlmeSB0aGF0IGdldEF0dHJpYnV0ZSByZWFsbHkgcmV0dXJucyBhdHRyaWJ1dGVzIGFuZCBub3QgcHJvcGVydGllc1xuXHQvLyAoZXhjZXB0aW5nIElFOCBib29sZWFucylcblx0c3VwcG9ydC5hdHRyaWJ1dGVzID0gYXNzZXJ0KCBmdW5jdGlvbiggZWwgKSB7XG5cdFx0ZWwuY2xhc3NOYW1lID0gXCJpXCI7XG5cdFx0cmV0dXJuICFlbC5nZXRBdHRyaWJ1dGUoIFwiY2xhc3NOYW1lXCIgKTtcblx0fSApO1xuXG5cdC8qIGdldEVsZW1lbnQocylCeSpcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIENoZWNrIGlmIGdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKSByZXR1cm5zIG9ubHkgZWxlbWVudHNcblx0c3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA9IGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXHRcdGVsLmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVDb21tZW50KCBcIlwiICkgKTtcblx0XHRyZXR1cm4gIWVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcIipcIiApLmxlbmd0aDtcblx0fSApO1xuXG5cdC8vIFN1cHBvcnQ6IElFPDlcblx0c3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lID0gcm5hdGl2ZS50ZXN0KCBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICk7XG5cblx0Ly8gU3VwcG9ydDogSUU8MTBcblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudEJ5SWQgcmV0dXJucyBlbGVtZW50cyBieSBuYW1lXG5cdC8vIFRoZSBicm9rZW4gZ2V0RWxlbWVudEJ5SWQgbWV0aG9kcyBkb24ndCBwaWNrIHVwIHByb2dyYW1tYXRpY2FsbHktc2V0IG5hbWVzLFxuXHQvLyBzbyB1c2UgYSByb3VuZGFib3V0IGdldEVsZW1lbnRzQnlOYW1lIHRlc3Rcblx0c3VwcG9ydC5nZXRCeUlkID0gYXNzZXJ0KCBmdW5jdGlvbiggZWwgKSB7XG5cdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5pZCA9IGV4cGFuZG87XG5cdFx0cmV0dXJuICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSB8fCAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoIGV4cGFuZG8gKS5sZW5ndGg7XG5cdH0gKTtcblxuXHQvLyBJRCBmaWx0ZXIgYW5kIGZpbmRcblx0aWYgKCBzdXBwb3J0LmdldEJ5SWQgKSB7XG5cdFx0RXhwci5maWx0ZXJbIFwiSURcIiBdID0gZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggXCJpZFwiICkgPT09IGF0dHJJZDtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRFeHByLmZpbmRbIFwiSURcIiBdID0gZnVuY3Rpb24oIGlkLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdFx0dmFyIGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuXHRcdFx0XHRyZXR1cm4gZWxlbSA/IFsgZWxlbSBdIDogW107XG5cdFx0XHR9XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRFeHByLmZpbHRlclsgXCJJRFwiIF0gPSAgZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlTm9kZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuXHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggXCJpZFwiICk7XG5cdFx0XHRcdHJldHVybiBub2RlICYmIG5vZGUudmFsdWUgPT09IGF0dHJJZDtcblx0XHRcdH07XG5cdFx0fTtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDYgLSA3IG9ubHlcblx0XHQvLyBnZXRFbGVtZW50QnlJZCBpcyBub3QgcmVsaWFibGUgYXMgYSBmaW5kIHNob3J0Y3V0XG5cdFx0RXhwci5maW5kWyBcIklEXCIgXSA9IGZ1bmN0aW9uKCBpZCwgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRcdHZhciBub2RlLCBpLCBlbGVtcyxcblx0XHRcdFx0XHRlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggaWQgKTtcblxuXHRcdFx0XHRpZiAoIGVsZW0gKSB7XG5cblx0XHRcdFx0XHQvLyBWZXJpZnkgdGhlIGlkIGF0dHJpYnV0ZVxuXHRcdFx0XHRcdG5vZGUgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIFwiaWRcIiApO1xuXHRcdFx0XHRcdGlmICggbm9kZSAmJiBub2RlLnZhbHVlID09PSBpZCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBbIGVsZW0gXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBGYWxsIGJhY2sgb24gZ2V0RWxlbWVudHNCeU5hbWVcblx0XHRcdFx0XHRlbGVtcyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeU5hbWUoIGlkICk7XG5cdFx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGVsZW0gPSBlbGVtc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIFwiaWRcIiApO1xuXHRcdFx0XHRcdFx0aWYgKCBub2RlICYmIG5vZGUudmFsdWUgPT09IGlkICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gWyBlbGVtIF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXHQvLyBUYWdcblx0RXhwci5maW5kWyBcIlRBR1wiIF0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID9cblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApO1xuXG5cdFx0XHQvLyBEb2N1bWVudEZyYWdtZW50IG5vZGVzIGRvbid0IGhhdmUgZ0VCVE5cblx0XHRcdH0gZWxzZSBpZiAoIHN1cHBvcnQucXNhICkge1xuXHRcdFx0XHRyZXR1cm4gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgKTtcblx0XHRcdH1cblx0XHR9IDpcblxuXHRcdGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG5cdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0dG1wID0gW10sXG5cdFx0XHRcdGkgPSAwLFxuXG5cdFx0XHRcdC8vIEJ5IGhhcHB5IGNvaW5jaWRlbmNlLCBhIChicm9rZW4pIGdFQlROIGFwcGVhcnMgb24gRG9jdW1lbnRGcmFnbWVudCBub2RlcyB0b29cblx0XHRcdFx0cmVzdWx0cyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApO1xuXG5cdFx0XHQvLyBGaWx0ZXIgb3V0IHBvc3NpYmxlIGNvbW1lbnRzXG5cdFx0XHRpZiAoIHRhZyA9PT0gXCIqXCIgKSB7XG5cdFx0XHRcdHdoaWxlICggKCBlbGVtID0gcmVzdWx0c1sgaSsrIF0gKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHR0bXAucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0bXA7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHR9O1xuXG5cdC8vIENsYXNzXG5cdEV4cHIuZmluZFsgXCJDTEFTU1wiIF0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiYgZnVuY3Rpb24oIGNsYXNzTmFtZSwgY29udGV4dCApIHtcblx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBjbGFzc05hbWUgKTtcblx0XHR9XG5cdH07XG5cblx0LyogUVNBL21hdGNoZXNTZWxlY3RvclxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gUVNBIGFuZCBtYXRjaGVzU2VsZWN0b3Igc3VwcG9ydFxuXG5cdC8vIG1hdGNoZXNTZWxlY3Rvcig6YWN0aXZlKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoSUU5L09wZXJhIDExLjUpXG5cdHJidWdneU1hdGNoZXMgPSBbXTtcblxuXHQvLyBxU2EoOmZvY3VzKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoQ2hyb21lIDIxKVxuXHQvLyBXZSBhbGxvdyB0aGlzIGJlY2F1c2Ugb2YgYSBidWcgaW4gSUU4LzkgdGhhdCB0aHJvd3MgYW4gZXJyb3Jcblx0Ly8gd2hlbmV2ZXIgYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRgIGlzIGFjY2Vzc2VkIG9uIGFuIGlmcmFtZVxuXHQvLyBTbywgd2UgYWxsb3cgOmZvY3VzIHRvIHBhc3MgdGhyb3VnaCBRU0EgYWxsIHRoZSB0aW1lIHRvIGF2b2lkIHRoZSBJRSBlcnJvclxuXHQvLyBTZWUgaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEzMzc4XG5cdHJidWdneVFTQSA9IFtdO1xuXG5cdGlmICggKCBzdXBwb3J0LnFzYSA9IHJuYXRpdmUudGVzdCggZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCApICkgKSB7XG5cblx0XHQvLyBCdWlsZCBRU0EgcmVnZXhcblx0XHQvLyBSZWdleCBzdHJhdGVneSBhZG9wdGVkIGZyb20gRGllZ28gUGVyaW5pXG5cdFx0YXNzZXJ0KCBmdW5jdGlvbiggZWwgKSB7XG5cblx0XHRcdHZhciBpbnB1dDtcblxuXHRcdFx0Ly8gU2VsZWN0IGlzIHNldCB0byBlbXB0eSBzdHJpbmcgb24gcHVycG9zZVxuXHRcdFx0Ly8gVGhpcyBpcyB0byB0ZXN0IElFJ3MgdHJlYXRtZW50IG9mIG5vdCBleHBsaWNpdGx5XG5cdFx0XHQvLyBzZXR0aW5nIGEgYm9vbGVhbiBjb250ZW50IGF0dHJpYnV0ZSxcblx0XHRcdC8vIHNpbmNlIGl0cyBwcmVzZW5jZSBzaG91bGQgYmUgZW5vdWdoXG5cdFx0XHQvLyBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIzNTlcblx0XHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuaW5uZXJIVE1MID0gXCI8YSBpZD0nXCIgKyBleHBhbmRvICsgXCInPjwvYT5cIiArXG5cdFx0XHRcdFwiPHNlbGVjdCBpZD0nXCIgKyBleHBhbmRvICsgXCItXFxyXFxcXCcgbXNhbGxvd2NhcHR1cmU9Jyc+XCIgK1xuXHRcdFx0XHRcIjxvcHRpb24gc2VsZWN0ZWQ9Jyc+PC9vcHRpb24+PC9zZWxlY3Q+XCI7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOCwgT3BlcmEgMTEtMTIuMTZcblx0XHRcdC8vIE5vdGhpbmcgc2hvdWxkIGJlIHNlbGVjdGVkIHdoZW4gZW1wdHkgc3RyaW5ncyBmb2xsb3cgXj0gb3IgJD0gb3IgKj1cblx0XHRcdC8vIFRoZSB0ZXN0IGF0dHJpYnV0ZSBtdXN0IGJlIHVua25vd24gaW4gT3BlcmEgYnV0IFwic2FmZVwiIGZvciBXaW5SVFxuXHRcdFx0Ly8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9oaDQ2NTM4OC5hc3B4I2F0dHJpYnV0ZV9zZWN0aW9uXG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW21zYWxsb3djYXB0dXJlXj0nJ11cIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiWypeJF09XCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86Jyd8XFxcIlxcXCIpXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4XG5cdFx0XHQvLyBCb29sZWFuIGF0dHJpYnV0ZXMgYW5kIFwidmFsdWVcIiBhcmUgbm90IHRyZWF0ZWQgY29ycmVjdGx5XG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIltzZWxlY3RlZF1cIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooPzp2YWx1ZXxcIiArIGJvb2xlYW5zICsgXCIpXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lPDI5LCBBbmRyb2lkPDQuNCwgU2FmYXJpPDcuMCssIGlPUzw3LjArLCBQaGFudG9tSlM8MS45LjgrXG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIltpZH49XCIgKyBleHBhbmRvICsgXCItXVwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJ+PVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNSAtIDE4K1xuXHRcdFx0Ly8gSUUgMTEvRWRnZSBkb24ndCBmaW5kIGVsZW1lbnRzIG9uIGEgYFtuYW1lPScnXWAgcXVlcnkgaW4gc29tZSBjYXNlcy5cblx0XHRcdC8vIEFkZGluZyBhIHRlbXBvcmFyeSBhdHRyaWJ1dGUgdG8gdGhlIGRvY3VtZW50IGJlZm9yZSB0aGUgc2VsZWN0aW9uIHdvcmtzXG5cdFx0XHQvLyBhcm91bmQgdGhlIGlzc3VlLlxuXHRcdFx0Ly8gSW50ZXJlc3RpbmdseSwgSUUgMTAgJiBvbGRlciBkb24ndCBzZWVtIHRvIGhhdmUgdGhlIGlzc3VlLlxuXHRcdFx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblx0XHRcdGlucHV0LnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwiXCIgKTtcblx0XHRcdGVsLmFwcGVuZENoaWxkKCBpbnB1dCApO1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJbbmFtZT0nJ11cIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIipuYW1lXCIgKyB3aGl0ZXNwYWNlICsgXCIqPVwiICtcblx0XHRcdFx0XHR3aGl0ZXNwYWNlICsgXCIqKD86Jyd8XFxcIlxcXCIpXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gV2Via2l0L09wZXJhIC0gOmNoZWNrZWQgc2hvdWxkIHJldHVybiBzZWxlY3RlZCBvcHRpb24gZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCI6Y2hlY2tlZFwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6Y2hlY2tlZFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA4KywgaU9TIDgrXG5cdFx0XHQvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM2ODUxXG5cdFx0XHQvLyBJbi1wYWdlIGBzZWxlY3RvciNpZCBzaWJsaW5nLWNvbWJpbmF0b3Igc2VsZWN0b3JgIGZhaWxzXG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcImEjXCIgKyBleHBhbmRvICsgXCIrKlwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCIuIy4rWyt+XVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD0zLjYgLSA1IG9ubHlcblx0XHRcdC8vIE9sZCBGaXJlZm94IGRvZXNuJ3QgdGhyb3cgb24gYSBiYWRseS1lc2NhcGVkIGlkZW50aWZpZXIuXG5cdFx0XHRlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIlxcXFxcXGZcIiApO1xuXHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiW1xcXFxyXFxcXG5cXFxcZl1cIiApO1xuXHRcdH0gKTtcblxuXHRcdGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0ZWwuaW5uZXJIVE1MID0gXCI8YSBocmVmPScnIGRpc2FibGVkPSdkaXNhYmxlZCc+PC9hPlwiICtcblx0XHRcdFx0XCI8c2VsZWN0IGRpc2FibGVkPSdkaXNhYmxlZCc+PG9wdGlvbi8+PC9zZWxlY3Q+XCI7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IFdpbmRvd3MgOCBOYXRpdmUgQXBwc1xuXHRcdFx0Ly8gVGhlIHR5cGUgYW5kIG5hbWUgYXR0cmlidXRlcyBhcmUgcmVzdHJpY3RlZCBkdXJpbmcgLmlubmVySFRNTCBhc3NpZ25tZW50XG5cdFx0XHR2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblx0XHRcdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwiaGlkZGVuXCIgKTtcblx0XHRcdGVsLmFwcGVuZENoaWxkKCBpbnB1dCApLnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwiRFwiICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdFx0Ly8gRW5mb3JjZSBjYXNlLXNlbnNpdGl2aXR5IG9mIG5hbWUgYXR0cmlidXRlXG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW25hbWU9ZF1cIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwibmFtZVwiICsgd2hpdGVzcGFjZSArIFwiKlsqXiR8IX5dPz1cIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGRiAzLjUgLSA6ZW5hYmxlZC86ZGlzYWJsZWQgYW5kIGhpZGRlbiBlbGVtZW50cyAoaGlkZGVuIGVsZW1lbnRzIGFyZSBzdGlsbCBlbmFibGVkKVxuXHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbCggXCI6ZW5hYmxlZFwiICkubGVuZ3RoICE9PSAyICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOS0xMStcblx0XHRcdC8vIElFJ3MgOmRpc2FibGVkIHNlbGVjdG9yIGRvZXMgbm90IHBpY2sgdXAgdGhlIGNoaWxkcmVuIG9mIGRpc2FibGVkIGZpZWxkc2V0c1xuXHRcdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5kaXNhYmxlZCA9IHRydWU7XG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiOmRpc2FibGVkXCIgKS5sZW5ndGggIT09IDIgKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIjplbmFibGVkXCIsIFwiOmRpc2FibGVkXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogT3BlcmEgMTAgLSAxMSBvbmx5XG5cdFx0XHQvLyBPcGVyYSAxMC0xMSBkb2VzIG5vdCB0aHJvdyBvbiBwb3N0LWNvbW1hIGludmFsaWQgcHNldWRvc1xuXHRcdFx0ZWwucXVlcnlTZWxlY3RvckFsbCggXCIqLDp4XCIgKTtcblx0XHRcdHJidWdneVFTQS5wdXNoKCBcIiwuKjpcIiApO1xuXHRcdH0gKTtcblx0fVxuXG5cdGlmICggKCBzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciA9IHJuYXRpdmUudGVzdCggKCBtYXRjaGVzID0gZG9jRWxlbS5tYXRjaGVzIHx8XG5cdFx0ZG9jRWxlbS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm1vek1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ub01hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ubXNNYXRjaGVzU2VsZWN0b3IgKSApICkgKSB7XG5cblx0XHRhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblxuXHRcdFx0Ly8gQ2hlY2sgdG8gc2VlIGlmIGl0J3MgcG9zc2libGUgdG8gZG8gbWF0Y2hlc1NlbGVjdG9yXG5cdFx0XHQvLyBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlIChJRSA5KVxuXHRcdFx0c3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCA9IG1hdGNoZXMuY2FsbCggZWwsIFwiKlwiICk7XG5cblx0XHRcdC8vIFRoaXMgc2hvdWxkIGZhaWwgd2l0aCBhbiBleGNlcHRpb25cblx0XHRcdC8vIEdlY2tvIGRvZXMgbm90IGVycm9yLCByZXR1cm5zIGZhbHNlIGluc3RlYWRcblx0XHRcdG1hdGNoZXMuY2FsbCggZWwsIFwiW3MhPScnXTp4XCIgKTtcblx0XHRcdHJidWdneU1hdGNoZXMucHVzaCggXCIhPVwiLCBwc2V1ZG9zICk7XG5cdFx0fSApO1xuXHR9XG5cblx0cmJ1Z2d5UVNBID0gcmJ1Z2d5UVNBLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lRU0Euam9pbiggXCJ8XCIgKSApO1xuXHRyYnVnZ3lNYXRjaGVzID0gcmJ1Z2d5TWF0Y2hlcy5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5TWF0Y2hlcy5qb2luKCBcInxcIiApICk7XG5cblx0LyogQ29udGFpbnNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXHRoYXNDb21wYXJlID0gcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICk7XG5cblx0Ly8gRWxlbWVudCBjb250YWlucyBhbm90aGVyXG5cdC8vIFB1cnBvc2VmdWxseSBzZWxmLWV4Y2x1c2l2ZVxuXHQvLyBBcyBpbiwgYW4gZWxlbWVudCBkb2VzIG5vdCBjb250YWluIGl0c2VsZlxuXHRjb250YWlucyA9IGhhc0NvbXBhcmUgfHwgcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbnRhaW5zICkgP1xuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0dmFyIGFkb3duID0gYS5ub2RlVHlwZSA9PT0gOSA/IGEuZG9jdW1lbnRFbGVtZW50IDogYSxcblx0XHRcdFx0YnVwID0gYiAmJiBiLnBhcmVudE5vZGU7XG5cdFx0XHRyZXR1cm4gYSA9PT0gYnVwIHx8ICEhKCBidXAgJiYgYnVwLm5vZGVUeXBlID09PSAxICYmIChcblx0XHRcdFx0YWRvd24uY29udGFpbnMgP1xuXHRcdFx0XHRcdGFkb3duLmNvbnRhaW5zKCBidXAgKSA6XG5cdFx0XHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAmJiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBidXAgKSAmIDE2XG5cdFx0XHQpICk7XG5cdFx0fSA6XG5cdFx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHRpZiAoIGIgKSB7XG5cdFx0XHRcdHdoaWxlICggKCBiID0gYi5wYXJlbnROb2RlICkgKSB7XG5cdFx0XHRcdFx0aWYgKCBiID09PSBhICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblxuXHQvKiBTb3J0aW5nXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBEb2N1bWVudCBvcmRlciBzb3J0aW5nXG5cdHNvcnRPcmRlciA9IGhhc0NvbXBhcmUgP1xuXHRmdW5jdGlvbiggYSwgYiApIHtcblxuXHRcdC8vIEZsYWcgZm9yIGR1cGxpY2F0ZSByZW1vdmFsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdC8vIFNvcnQgb24gbWV0aG9kIGV4aXN0ZW5jZSBpZiBvbmx5IG9uZSBpbnB1dCBoYXMgY29tcGFyZURvY3VtZW50UG9zaXRpb25cblx0XHR2YXIgY29tcGFyZSA9ICFhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIC0gIWIuY29tcGFyZURvY3VtZW50UG9zaXRpb247XG5cdFx0aWYgKCBjb21wYXJlICkge1xuXHRcdFx0cmV0dXJuIGNvbXBhcmU7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsY3VsYXRlIHBvc2l0aW9uIGlmIGJvdGggaW5wdXRzIGJlbG9uZyB0byB0aGUgc2FtZSBkb2N1bWVudFxuXHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHRcdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHRcdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdFx0Y29tcGFyZSA9ICggYS5vd25lckRvY3VtZW50IHx8IGEgKSA9PSAoIGIub3duZXJEb2N1bWVudCB8fCBiICkgP1xuXHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYiApIDpcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHdlIGtub3cgdGhleSBhcmUgZGlzY29ubmVjdGVkXG5cdFx0XHQxO1xuXG5cdFx0Ly8gRGlzY29ubmVjdGVkIG5vZGVzXG5cdFx0aWYgKCBjb21wYXJlICYgMSB8fFxuXHRcdFx0KCAhc3VwcG9ydC5zb3J0RGV0YWNoZWQgJiYgYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYSApID09PSBjb21wYXJlICkgKSB7XG5cblx0XHRcdC8vIENob29zZSB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IGlzIHJlbGF0ZWQgdG8gb3VyIHByZWZlcnJlZCBkb2N1bWVudFxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdFx0XHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0XHRcdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0XHRcdGlmICggYSA9PSBkb2N1bWVudCB8fCBhLm93bmVyRG9jdW1lbnQgPT0gcHJlZmVycmVkRG9jICYmXG5cdFx0XHRcdGNvbnRhaW5zKCBwcmVmZXJyZWREb2MsIGEgKSApIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0XHRcdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHRcdFx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRcdFx0aWYgKCBiID09IGRvY3VtZW50IHx8IGIub3duZXJEb2N1bWVudCA9PSBwcmVmZXJyZWREb2MgJiZcblx0XHRcdFx0Y29udGFpbnMoIHByZWZlcnJlZERvYywgYiApICkge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFpbnRhaW4gb3JpZ2luYWwgb3JkZXJcblx0XHRcdHJldHVybiBzb3J0SW5wdXQgP1xuXHRcdFx0XHQoIGluZGV4T2YoIHNvcnRJbnB1dCwgYSApIC0gaW5kZXhPZiggc29ydElucHV0LCBiICkgKSA6XG5cdFx0XHRcdDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbXBhcmUgJiA0ID8gLTEgOiAxO1xuXHR9IDpcblx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cblx0XHQvLyBFeGl0IGVhcmx5IGlmIHRoZSBub2RlcyBhcmUgaWRlbnRpY2FsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGF1cCA9IGEucGFyZW50Tm9kZSxcblx0XHRcdGJ1cCA9IGIucGFyZW50Tm9kZSxcblx0XHRcdGFwID0gWyBhIF0sXG5cdFx0XHRicCA9IFsgYiBdO1xuXG5cdFx0Ly8gUGFyZW50bGVzcyBub2RlcyBhcmUgZWl0aGVyIGRvY3VtZW50cyBvciBkaXNjb25uZWN0ZWRcblx0XHRpZiAoICFhdXAgfHwgIWJ1cCApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdFx0XHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0XHRcdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0XHRcdC8qIGVzbGludC1kaXNhYmxlIGVxZXFlcSAqL1xuXHRcdFx0cmV0dXJuIGEgPT0gZG9jdW1lbnQgPyAtMSA6XG5cdFx0XHRcdGIgPT0gZG9jdW1lbnQgPyAxIDpcblx0XHRcdFx0LyogZXNsaW50LWVuYWJsZSBlcWVxZXEgKi9cblx0XHRcdFx0YXVwID8gLTEgOlxuXHRcdFx0XHRidXAgPyAxIDpcblx0XHRcdFx0c29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXG5cdFx0Ly8gSWYgdGhlIG5vZGVzIGFyZSBzaWJsaW5ncywgd2UgY2FuIGRvIGEgcXVpY2sgY2hlY2tcblx0XHR9IGVsc2UgaWYgKCBhdXAgPT09IGJ1cCApIHtcblx0XHRcdHJldHVybiBzaWJsaW5nQ2hlY2soIGEsIGIgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2Ugd2UgbmVlZCBmdWxsIGxpc3RzIG9mIHRoZWlyIGFuY2VzdG9ycyBmb3IgY29tcGFyaXNvblxuXHRcdGN1ciA9IGE7XG5cdFx0d2hpbGUgKCAoIGN1ciA9IGN1ci5wYXJlbnROb2RlICkgKSB7XG5cdFx0XHRhcC51bnNoaWZ0KCBjdXIgKTtcblx0XHR9XG5cdFx0Y3VyID0gYjtcblx0XHR3aGlsZSAoICggY3VyID0gY3VyLnBhcmVudE5vZGUgKSApIHtcblx0XHRcdGJwLnVuc2hpZnQoIGN1ciApO1xuXHRcdH1cblxuXHRcdC8vIFdhbGsgZG93biB0aGUgdHJlZSBsb29raW5nIGZvciBhIGRpc2NyZXBhbmN5XG5cdFx0d2hpbGUgKCBhcFsgaSBdID09PSBicFsgaSBdICkge1xuXHRcdFx0aSsrO1xuXHRcdH1cblxuXHRcdHJldHVybiBpID9cblxuXHRcdFx0Ly8gRG8gYSBzaWJsaW5nIGNoZWNrIGlmIHRoZSBub2RlcyBoYXZlIGEgY29tbW9uIGFuY2VzdG9yXG5cdFx0XHRzaWJsaW5nQ2hlY2soIGFwWyBpIF0sIGJwWyBpIF0gKSA6XG5cblx0XHRcdC8vIE90aGVyd2lzZSBub2RlcyBpbiBvdXIgZG9jdW1lbnQgc29ydCBmaXJzdFxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdFx0XHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0XHRcdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0XHRcdC8qIGVzbGludC1kaXNhYmxlIGVxZXFlcSAqL1xuXHRcdFx0YXBbIGkgXSA9PSBwcmVmZXJyZWREb2MgPyAtMSA6XG5cdFx0XHRicFsgaSBdID09IHByZWZlcnJlZERvYyA/IDEgOlxuXHRcdFx0LyogZXNsaW50LWVuYWJsZSBlcWVxZXEgKi9cblx0XHRcdDA7XG5cdH07XG5cblx0cmV0dXJuIGRvY3VtZW50O1xufTtcblxuU2l6emxlLm1hdGNoZXMgPSBmdW5jdGlvbiggZXhwciwgZWxlbWVudHMgKSB7XG5cdHJldHVybiBTaXp6bGUoIGV4cHIsIG51bGwsIG51bGwsIGVsZW1lbnRzICk7XG59O1xuXG5TaXp6bGUubWF0Y2hlc1NlbGVjdG9yID0gZnVuY3Rpb24oIGVsZW0sIGV4cHIgKSB7XG5cdHNldERvY3VtZW50KCBlbGVtICk7XG5cblx0aWYgKCBzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciAmJiBkb2N1bWVudElzSFRNTCAmJlxuXHRcdCFub25uYXRpdmVTZWxlY3RvckNhY2hlWyBleHByICsgXCIgXCIgXSAmJlxuXHRcdCggIXJidWdneU1hdGNoZXMgfHwgIXJidWdneU1hdGNoZXMudGVzdCggZXhwciApICkgJiZcblx0XHQoICFyYnVnZ3lRU0EgICAgIHx8ICFyYnVnZ3lRU0EudGVzdCggZXhwciApICkgKSB7XG5cblx0XHR0cnkge1xuXHRcdFx0dmFyIHJldCA9IG1hdGNoZXMuY2FsbCggZWxlbSwgZXhwciApO1xuXG5cdFx0XHQvLyBJRSA5J3MgbWF0Y2hlc1NlbGVjdG9yIHJldHVybnMgZmFsc2Ugb24gZGlzY29ubmVjdGVkIG5vZGVzXG5cdFx0XHRpZiAoIHJldCB8fCBzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoIHx8XG5cblx0XHRcdFx0Ly8gQXMgd2VsbCwgZGlzY29ubmVjdGVkIG5vZGVzIGFyZSBzYWlkIHRvIGJlIGluIGEgZG9jdW1lbnRcblx0XHRcdFx0Ly8gZnJhZ21lbnQgaW4gSUUgOVxuXHRcdFx0XHRlbGVtLmRvY3VtZW50ICYmIGVsZW0uZG9jdW1lbnQubm9kZVR5cGUgIT09IDExICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0bm9ubmF0aXZlU2VsZWN0b3JDYWNoZSggZXhwciwgdHJ1ZSApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBTaXp6bGUoIGV4cHIsIGRvY3VtZW50LCBudWxsLCBbIGVsZW0gXSApLmxlbmd0aCA+IDA7XG59O1xuXG5TaXp6bGUuY29udGFpbnMgPSBmdW5jdGlvbiggY29udGV4dCwgZWxlbSApIHtcblxuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0aWYgKCAoIGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0ICkgIT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0fVxuXHRyZXR1cm4gY29udGFpbnMoIGNvbnRleHQsIGVsZW0gKTtcbn07XG5cblNpenpsZS5hdHRyID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdH1cblxuXHR2YXIgZm4gPSBFeHByLmF0dHJIYW5kbGVbIG5hbWUudG9Mb3dlckNhc2UoKSBdLFxuXG5cdFx0Ly8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKGpRdWVyeSAjMTM4MDcpXG5cdFx0dmFsID0gZm4gJiYgaGFzT3duLmNhbGwoIEV4cHIuYXR0ckhhbmRsZSwgbmFtZS50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0Zm4oIGVsZW0sIG5hbWUsICFkb2N1bWVudElzSFRNTCApIDpcblx0XHRcdHVuZGVmaW5lZDtcblxuXHRyZXR1cm4gdmFsICE9PSB1bmRlZmluZWQgP1xuXHRcdHZhbCA6XG5cdFx0c3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApIDpcblx0XHRcdCggdmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBuYW1lICkgKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0dmFsLnZhbHVlIDpcblx0XHRcdFx0bnVsbDtcbn07XG5cblNpenpsZS5lc2NhcGUgPSBmdW5jdGlvbiggc2VsICkge1xuXHRyZXR1cm4gKCBzZWwgKyBcIlwiICkucmVwbGFjZSggcmNzc2VzY2FwZSwgZmNzc2VzY2FwZSApO1xufTtcblxuU2l6emxlLmVycm9yID0gZnVuY3Rpb24oIG1zZyApIHtcblx0dGhyb3cgbmV3IEVycm9yKCBcIlN5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246IFwiICsgbXNnICk7XG59O1xuXG4vKipcbiAqIERvY3VtZW50IHNvcnRpbmcgYW5kIHJlbW92aW5nIGR1cGxpY2F0ZXNcbiAqIEBwYXJhbSB7QXJyYXlMaWtlfSByZXN1bHRzXG4gKi9cblNpenpsZS51bmlxdWVTb3J0ID0gZnVuY3Rpb24oIHJlc3VsdHMgKSB7XG5cdHZhciBlbGVtLFxuXHRcdGR1cGxpY2F0ZXMgPSBbXSxcblx0XHRqID0gMCxcblx0XHRpID0gMDtcblxuXHQvLyBVbmxlc3Mgd2UgKmtub3cqIHdlIGNhbiBkZXRlY3QgZHVwbGljYXRlcywgYXNzdW1lIHRoZWlyIHByZXNlbmNlXG5cdGhhc0R1cGxpY2F0ZSA9ICFzdXBwb3J0LmRldGVjdER1cGxpY2F0ZXM7XG5cdHNvcnRJbnB1dCA9ICFzdXBwb3J0LnNvcnRTdGFibGUgJiYgcmVzdWx0cy5zbGljZSggMCApO1xuXHRyZXN1bHRzLnNvcnQoIHNvcnRPcmRlciApO1xuXG5cdGlmICggaGFzRHVwbGljYXRlICkge1xuXHRcdHdoaWxlICggKCBlbGVtID0gcmVzdWx0c1sgaSsrIF0gKSApIHtcblx0XHRcdGlmICggZWxlbSA9PT0gcmVzdWx0c1sgaSBdICkge1xuXHRcdFx0XHRqID0gZHVwbGljYXRlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0cmVzdWx0cy5zcGxpY2UoIGR1cGxpY2F0ZXNbIGogXSwgMSApO1xuXHRcdH1cblx0fVxuXG5cdC8vIENsZWFyIGlucHV0IGFmdGVyIHNvcnRpbmcgdG8gcmVsZWFzZSBvYmplY3RzXG5cdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L3NpenpsZS9wdWxsLzIyNVxuXHRzb3J0SW5wdXQgPSBudWxsO1xuXG5cdHJldHVybiByZXN1bHRzO1xufTtcblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIGZvciByZXRyaWV2aW5nIHRoZSB0ZXh0IHZhbHVlIG9mIGFuIGFycmF5IG9mIERPTSBub2Rlc1xuICogQHBhcmFtIHtBcnJheXxFbGVtZW50fSBlbGVtXG4gKi9cbmdldFRleHQgPSBTaXp6bGUuZ2V0VGV4dCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHR2YXIgbm9kZSxcblx0XHRyZXQgPSBcIlwiLFxuXHRcdGkgPSAwLFxuXHRcdG5vZGVUeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRpZiAoICFub2RlVHlwZSApIHtcblxuXHRcdC8vIElmIG5vIG5vZGVUeXBlLCB0aGlzIGlzIGV4cGVjdGVkIHRvIGJlIGFuIGFycmF5XG5cdFx0d2hpbGUgKCAoIG5vZGUgPSBlbGVtWyBpKysgXSApICkge1xuXG5cdFx0XHQvLyBEbyBub3QgdHJhdmVyc2UgY29tbWVudCBub2Rlc1xuXHRcdFx0cmV0ICs9IGdldFRleHQoIG5vZGUgKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAxIHx8IG5vZGVUeXBlID09PSA5IHx8IG5vZGVUeXBlID09PSAxMSApIHtcblxuXHRcdC8vIFVzZSB0ZXh0Q29udGVudCBmb3IgZWxlbWVudHNcblx0XHQvLyBpbm5lclRleHQgdXNhZ2UgcmVtb3ZlZCBmb3IgY29uc2lzdGVuY3kgb2YgbmV3IGxpbmVzIChqUXVlcnkgIzExMTUzKVxuXHRcdGlmICggdHlwZW9mIGVsZW0udGV4dENvbnRlbnQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS50ZXh0Q29udGVudDtcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBUcmF2ZXJzZSBpdHMgY2hpbGRyZW5cblx0XHRcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuXHRcdFx0XHRyZXQgKz0gZ2V0VGV4dCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDMgfHwgbm9kZVR5cGUgPT09IDQgKSB7XG5cdFx0cmV0dXJuIGVsZW0ubm9kZVZhbHVlO1xuXHR9XG5cblx0Ly8gRG8gbm90IGluY2x1ZGUgY29tbWVudCBvciBwcm9jZXNzaW5nIGluc3RydWN0aW9uIG5vZGVzXG5cblx0cmV0dXJuIHJldDtcbn07XG5cbkV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzID0ge1xuXG5cdC8vIENhbiBiZSBhZGp1c3RlZCBieSB0aGUgdXNlclxuXHRjYWNoZUxlbmd0aDogNTAsXG5cblx0Y3JlYXRlUHNldWRvOiBtYXJrRnVuY3Rpb24sXG5cblx0bWF0Y2g6IG1hdGNoRXhwcixcblxuXHRhdHRySGFuZGxlOiB7fSxcblxuXHRmaW5kOiB7fSxcblxuXHRyZWxhdGl2ZToge1xuXHRcdFwiPlwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCIgXCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiB9LFxuXHRcdFwiK1wiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIn5cIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIgfVxuXHR9LFxuXG5cdHByZUZpbHRlcjoge1xuXHRcdFwiQVRUUlwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaFsgMSBdID0gbWF0Y2hbIDEgXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG5cdFx0XHQvLyBNb3ZlIHRoZSBnaXZlbiB2YWx1ZSB0byBtYXRjaFszXSB3aGV0aGVyIHF1b3RlZCBvciB1bnF1b3RlZFxuXHRcdFx0bWF0Y2hbIDMgXSA9ICggbWF0Y2hbIDMgXSB8fCBtYXRjaFsgNCBdIHx8XG5cdFx0XHRcdG1hdGNoWyA1IF0gfHwgXCJcIiApLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdGlmICggbWF0Y2hbIDIgXSA9PT0gXCJ+PVwiICkge1xuXHRcdFx0XHRtYXRjaFsgMyBdID0gXCIgXCIgKyBtYXRjaFsgMyBdICsgXCIgXCI7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgNCApO1xuXHRcdH0sXG5cblx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblxuXHRcdFx0LyogbWF0Y2hlcyBmcm9tIG1hdGNoRXhwcltcIkNISUxEXCJdXG5cdFx0XHRcdDEgdHlwZSAob25seXxudGh8Li4uKVxuXHRcdFx0XHQyIHdoYXQgKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdDMgYXJndW1lbnQgKGV2ZW58b2RkfFxcZCp8XFxkKm4oWystXVxcZCspP3wuLi4pXG5cdFx0XHRcdDQgeG4tY29tcG9uZW50IG9mIHhuK3kgYXJndW1lbnQgKFsrLV0/XFxkKm58KVxuXHRcdFx0XHQ1IHNpZ24gb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDYgeCBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NyBzaWduIG9mIHktY29tcG9uZW50XG5cdFx0XHRcdDggeSBvZiB5LWNvbXBvbmVudFxuXHRcdFx0Ki9cblx0XHRcdG1hdGNoWyAxIF0gPSBtYXRjaFsgMSBdLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdGlmICggbWF0Y2hbIDEgXS5zbGljZSggMCwgMyApID09PSBcIm50aFwiICkge1xuXG5cdFx0XHRcdC8vIG50aC0qIHJlcXVpcmVzIGFyZ3VtZW50XG5cdFx0XHRcdGlmICggIW1hdGNoWyAzIF0gKSB7XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBtYXRjaFsgMCBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBudW1lcmljIHggYW5kIHkgcGFyYW1ldGVycyBmb3IgRXhwci5maWx0ZXIuQ0hJTERcblx0XHRcdFx0Ly8gcmVtZW1iZXIgdGhhdCBmYWxzZS90cnVlIGNhc3QgcmVzcGVjdGl2ZWx5IHRvIDAvMVxuXHRcdFx0XHRtYXRjaFsgNCBdID0gKyggbWF0Y2hbIDQgXSA/XG5cdFx0XHRcdFx0bWF0Y2hbIDUgXSArICggbWF0Y2hbIDYgXSB8fCAxICkgOlxuXHRcdFx0XHRcdDIgKiAoIG1hdGNoWyAzIF0gPT09IFwiZXZlblwiIHx8IG1hdGNoWyAzIF0gPT09IFwib2RkXCIgKSApO1xuXHRcdFx0XHRtYXRjaFsgNSBdID0gKyggKCBtYXRjaFsgNyBdICsgbWF0Y2hbIDggXSApIHx8IG1hdGNoWyAzIF0gPT09IFwib2RkXCIgKTtcblxuXHRcdFx0XHQvLyBvdGhlciB0eXBlcyBwcm9oaWJpdCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWyAzIF0gKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggbWF0Y2hbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0fSxcblxuXHRcdFwiUFNFVURPXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdHZhciBleGNlc3MsXG5cdFx0XHRcdHVucXVvdGVkID0gIW1hdGNoWyA2IF0gJiYgbWF0Y2hbIDIgXTtcblxuXHRcdFx0aWYgKCBtYXRjaEV4cHJbIFwiQ0hJTERcIiBdLnRlc3QoIG1hdGNoWyAwIF0gKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFjY2VwdCBxdW90ZWQgYXJndW1lbnRzIGFzLWlzXG5cdFx0XHRpZiAoIG1hdGNoWyAzIF0gKSB7XG5cdFx0XHRcdG1hdGNoWyAyIF0gPSBtYXRjaFsgNCBdIHx8IG1hdGNoWyA1IF0gfHwgXCJcIjtcblxuXHRcdFx0Ly8gU3RyaXAgZXhjZXNzIGNoYXJhY3RlcnMgZnJvbSB1bnF1b3RlZCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIHVucXVvdGVkICYmIHJwc2V1ZG8udGVzdCggdW5xdW90ZWQgKSAmJlxuXG5cdFx0XHRcdC8vIEdldCBleGNlc3MgZnJvbSB0b2tlbml6ZSAocmVjdXJzaXZlbHkpXG5cdFx0XHRcdCggZXhjZXNzID0gdG9rZW5pemUoIHVucXVvdGVkLCB0cnVlICkgKSAmJlxuXG5cdFx0XHRcdC8vIGFkdmFuY2UgdG8gdGhlIG5leHQgY2xvc2luZyBwYXJlbnRoZXNpc1xuXHRcdFx0XHQoIGV4Y2VzcyA9IHVucXVvdGVkLmluZGV4T2YoIFwiKVwiLCB1bnF1b3RlZC5sZW5ndGggLSBleGNlc3MgKSAtIHVucXVvdGVkLmxlbmd0aCApICkge1xuXG5cdFx0XHRcdC8vIGV4Y2VzcyBpcyBhIG5lZ2F0aXZlIGluZGV4XG5cdFx0XHRcdG1hdGNoWyAwIF0gPSBtYXRjaFsgMCBdLnNsaWNlKCAwLCBleGNlc3MgKTtcblx0XHRcdFx0bWF0Y2hbIDIgXSA9IHVucXVvdGVkLnNsaWNlKCAwLCBleGNlc3MgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV0dXJuIG9ubHkgY2FwdHVyZXMgbmVlZGVkIGJ5IHRoZSBwc2V1ZG8gZmlsdGVyIG1ldGhvZCAodHlwZSBhbmQgYXJndW1lbnQpXG5cdFx0XHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDMgKTtcblx0XHR9XG5cdH0sXG5cblx0ZmlsdGVyOiB7XG5cblx0XHRcIlRBR1wiOiBmdW5jdGlvbiggbm9kZU5hbWVTZWxlY3RvciApIHtcblx0XHRcdHZhciBub2RlTmFtZSA9IG5vZGVOYW1lU2VsZWN0b3IucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5vZGVOYW1lU2VsZWN0b3IgPT09IFwiKlwiID9cblx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH0gOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5vZGVOYW1lO1xuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIkNMQVNTXCI6IGZ1bmN0aW9uKCBjbGFzc05hbWUgKSB7XG5cdFx0XHR2YXIgcGF0dGVybiA9IGNsYXNzQ2FjaGVbIGNsYXNzTmFtZSArIFwiIFwiIF07XG5cblx0XHRcdHJldHVybiBwYXR0ZXJuIHx8XG5cdFx0XHRcdCggcGF0dGVybiA9IG5ldyBSZWdFeHAoIFwiKF58XCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFx0XHRcIilcIiArIGNsYXNzTmFtZSArIFwiKFwiICsgd2hpdGVzcGFjZSArIFwifCQpXCIgKSApICYmIGNsYXNzQ2FjaGUoXG5cdFx0XHRcdFx0XHRjbGFzc05hbWUsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcGF0dGVybi50ZXN0KFxuXHRcdFx0XHRcdFx0XHRcdHR5cGVvZiBlbGVtLmNsYXNzTmFtZSA9PT0gXCJzdHJpbmdcIiAmJiBlbGVtLmNsYXNzTmFtZSB8fFxuXHRcdFx0XHRcdFx0XHRcdHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiApIHx8XG5cdFx0XHRcdFx0XHRcdFx0XCJcIlxuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9ICk7XG5cdFx0fSxcblxuXHRcdFwiQVRUUlwiOiBmdW5jdGlvbiggbmFtZSwgb3BlcmF0b3IsIGNoZWNrICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgcmVzdWx0ID0gU2l6emxlLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdFx0XHRpZiAoIHJlc3VsdCA9PSBudWxsICkge1xuXHRcdFx0XHRcdHJldHVybiBvcGVyYXRvciA9PT0gXCIhPVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggIW9wZXJhdG9yICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmVzdWx0ICs9IFwiXCI7XG5cblx0XHRcdFx0LyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG5cdFx0XHRcdHJldHVybiBvcGVyYXRvciA9PT0gXCI9XCIgPyByZXN1bHQgPT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIhPVwiID8gcmVzdWx0ICE9PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiXj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID09PSAwIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIqPVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPiAtMSA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiJD1cIiA/IGNoZWNrICYmIHJlc3VsdC5zbGljZSggLWNoZWNrLmxlbmd0aCApID09PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwifj1cIiA/ICggXCIgXCIgKyByZXN1bHQucmVwbGFjZSggcndoaXRlc3BhY2UsIFwiIFwiICkgKyBcIiBcIiApLmluZGV4T2YoIGNoZWNrICkgPiAtMSA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwifD1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgfHwgcmVzdWx0LnNsaWNlKCAwLCBjaGVjay5sZW5ndGggKyAxICkgPT09IGNoZWNrICsgXCItXCIgOlxuXHRcdFx0XHRcdGZhbHNlO1xuXHRcdFx0XHQvKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cblxuXHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJDSElMRFwiOiBmdW5jdGlvbiggdHlwZSwgd2hhdCwgX2FyZ3VtZW50LCBmaXJzdCwgbGFzdCApIHtcblx0XHRcdHZhciBzaW1wbGUgPSB0eXBlLnNsaWNlKCAwLCAzICkgIT09IFwibnRoXCIsXG5cdFx0XHRcdGZvcndhcmQgPSB0eXBlLnNsaWNlKCAtNCApICE9PSBcImxhc3RcIixcblx0XHRcdFx0b2ZUeXBlID0gd2hhdCA9PT0gXCJvZi10eXBlXCI7XG5cblx0XHRcdHJldHVybiBmaXJzdCA9PT0gMSAmJiBsYXN0ID09PSAwID9cblxuXHRcdFx0XHQvLyBTaG9ydGN1dCBmb3IgOm50aC0qKG4pXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiAhIWVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdFx0fSA6XG5cblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIF9jb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0dmFyIGNhY2hlLCB1bmlxdWVDYWNoZSwgb3V0ZXJDYWNoZSwgbm9kZSwgbm9kZUluZGV4LCBzdGFydCxcblx0XHRcdFx0XHRcdGRpciA9IHNpbXBsZSAhPT0gZm9yd2FyZCA/IFwibmV4dFNpYmxpbmdcIiA6IFwicHJldmlvdXNTaWJsaW5nXCIsXG5cdFx0XHRcdFx0XHRwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGUsXG5cdFx0XHRcdFx0XHRuYW1lID0gb2ZUeXBlICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcblx0XHRcdFx0XHRcdHVzZUNhY2hlID0gIXhtbCAmJiAhb2ZUeXBlLFxuXHRcdFx0XHRcdFx0ZGlmZiA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdC8vIDooZmlyc3R8bGFzdHxvbmx5KS0oY2hpbGR8b2YtdHlwZSlcblx0XHRcdFx0XHRcdGlmICggc2ltcGxlICkge1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoIGRpciApIHtcblx0XHRcdFx0XHRcdFx0XHRub2RlID0gZWxlbTtcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbm9kZSA9IG5vZGVbIGRpciBdICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG9mVHlwZSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdC8vIFJldmVyc2UgZGlyZWN0aW9uIGZvciA6b25seS0qIChpZiB3ZSBoYXZlbid0IHlldCBkb25lIHNvKVxuXHRcdFx0XHRcdFx0XHRcdHN0YXJ0ID0gZGlyID0gdHlwZSA9PT0gXCJvbmx5XCIgJiYgIXN0YXJ0ICYmIFwibmV4dFNpYmxpbmdcIjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0c3RhcnQgPSBbIGZvcndhcmQgPyBwYXJlbnQuZmlyc3RDaGlsZCA6IHBhcmVudC5sYXN0Q2hpbGQgXTtcblxuXHRcdFx0XHRcdFx0Ly8gbm9uLXhtbCA6bnRoLWNoaWxkKC4uLikgc3RvcmVzIGNhY2hlIGRhdGEgb24gYHBhcmVudGBcblx0XHRcdFx0XHRcdGlmICggZm9yd2FyZCAmJiB1c2VDYWNoZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBTZWVrIGBlbGVtYCBmcm9tIGEgcHJldmlvdXNseS1jYWNoZWQgaW5kZXhcblxuXHRcdFx0XHRcdFx0XHQvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XG5cdFx0XHRcdFx0XHRcdG5vZGUgPSBwYXJlbnQ7XG5cdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKCBub2RlWyBleHBhbmRvIF0gPSB7fSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0KCBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSApO1xuXG5cdFx0XHRcdFx0XHRcdGNhY2hlID0gdW5pcXVlQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuXHRcdFx0XHRcdFx0XHRkaWZmID0gbm9kZUluZGV4ICYmIGNhY2hlWyAyIF07XG5cdFx0XHRcdFx0XHRcdG5vZGUgPSBub2RlSW5kZXggJiYgcGFyZW50LmNoaWxkTm9kZXNbIG5vZGVJbmRleCBdO1xuXG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKCBub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gRmFsbGJhY2sgdG8gc2Vla2luZyBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0XHQoIGRpZmYgPSBub2RlSW5kZXggPSAwICkgfHwgc3RhcnQucG9wKCkgKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFdoZW4gZm91bmQsIGNhY2hlIGluZGV4ZXMgb24gYHBhcmVudGAgYW5kIGJyZWFrXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBub2RlLm5vZGVUeXBlID09PSAxICYmICsrZGlmZiAmJiBub2RlID09PSBlbGVtICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGVbIHR5cGUgXSA9IFsgZGlycnVucywgbm9kZUluZGV4LCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBVc2UgcHJldmlvdXNseS1jYWNoZWQgZWxlbWVudCBpbmRleCBpZiBhdmFpbGFibGVcblx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIC4uLmluIGEgZ3ppcC1mcmllbmRseSB3YXlcblx0XHRcdFx0XHRcdFx0XHRub2RlID0gZWxlbTtcblx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8ICggbm9kZVsgZXhwYW5kbyBdID0ge30gKTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0KCBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0Y2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcblx0XHRcdFx0XHRcdFx0XHRkaWZmID0gbm9kZUluZGV4O1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Ly8geG1sIDpudGgtY2hpbGQoLi4uKVxuXHRcdFx0XHRcdFx0XHQvLyBvciA6bnRoLWxhc3QtY2hpbGQoLi4uKSBvciA6bnRoKC1sYXN0KT8tb2YtdHlwZSguLi4pXG5cdFx0XHRcdFx0XHRcdGlmICggZGlmZiA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBVc2UgdGhlIHNhbWUgbG9vcCBhcyBhYm92ZSB0byBzZWVrIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKCBub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0KCBkaWZmID0gbm9kZUluZGV4ID0gMCApIHx8IHN0YXJ0LnBvcCgpICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICggKCBvZlR5cGUgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVUeXBlID09PSAxICkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0KytkaWZmICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIENhY2hlIHRoZSBpbmRleCBvZiBlYWNoIGVuY291bnRlcmVkIGVsZW1lbnRcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQoIG5vZGVbIGV4cGFuZG8gXSA9IHt9ICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCggb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30gKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBJbmNvcnBvcmF0ZSB0aGUgb2Zmc2V0LCB0aGVuIGNoZWNrIGFnYWluc3QgY3ljbGUgc2l6ZVxuXHRcdFx0XHRcdFx0ZGlmZiAtPSBsYXN0O1xuXHRcdFx0XHRcdFx0cmV0dXJuIGRpZmYgPT09IGZpcnN0IHx8ICggZGlmZiAlIGZpcnN0ID09PSAwICYmIGRpZmYgLyBmaXJzdCA+PSAwICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIlBTRVVET1wiOiBmdW5jdGlvbiggcHNldWRvLCBhcmd1bWVudCApIHtcblxuXHRcdFx0Ly8gcHNldWRvLWNsYXNzIG5hbWVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI3BzZXVkby1jbGFzc2VzXG5cdFx0XHQvLyBQcmlvcml0aXplIGJ5IGNhc2Ugc2Vuc2l0aXZpdHkgaW4gY2FzZSBjdXN0b20gcHNldWRvcyBhcmUgYWRkZWQgd2l0aCB1cHBlcmNhc2UgbGV0dGVyc1xuXHRcdFx0Ly8gUmVtZW1iZXIgdGhhdCBzZXRGaWx0ZXJzIGluaGVyaXRzIGZyb20gcHNldWRvc1xuXHRcdFx0dmFyIGFyZ3MsXG5cdFx0XHRcdGZuID0gRXhwci5wc2V1ZG9zWyBwc2V1ZG8gXSB8fCBFeHByLnNldEZpbHRlcnNbIHBzZXVkby50b0xvd2VyQ2FzZSgpIF0gfHxcblx0XHRcdFx0XHRTaXp6bGUuZXJyb3IoIFwidW5zdXBwb3J0ZWQgcHNldWRvOiBcIiArIHBzZXVkbyApO1xuXG5cdFx0XHQvLyBUaGUgdXNlciBtYXkgdXNlIGNyZWF0ZVBzZXVkbyB0byBpbmRpY2F0ZSB0aGF0XG5cdFx0XHQvLyBhcmd1bWVudHMgYXJlIG5lZWRlZCB0byBjcmVhdGUgdGhlIGZpbHRlciBmdW5jdGlvblxuXHRcdFx0Ly8ganVzdCBhcyBTaXp6bGUgZG9lc1xuXHRcdFx0aWYgKCBmblsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRyZXR1cm4gZm4oIGFyZ3VtZW50ICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEJ1dCBtYWludGFpbiBzdXBwb3J0IGZvciBvbGQgc2lnbmF0dXJlc1xuXHRcdFx0aWYgKCBmbi5sZW5ndGggPiAxICkge1xuXHRcdFx0XHRhcmdzID0gWyBwc2V1ZG8sIHBzZXVkbywgXCJcIiwgYXJndW1lbnQgXTtcblx0XHRcdFx0cmV0dXJuIEV4cHIuc2V0RmlsdGVycy5oYXNPd25Qcm9wZXJ0eSggcHNldWRvLnRvTG93ZXJDYXNlKCkgKSA/XG5cdFx0XHRcdFx0bWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdFx0XHRcdHZhciBpZHgsXG5cdFx0XHRcdFx0XHRcdG1hdGNoZWQgPSBmbiggc2VlZCwgYXJndW1lbnQgKSxcblx0XHRcdFx0XHRcdFx0aSA9IG1hdGNoZWQubGVuZ3RoO1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdGlkeCA9IGluZGV4T2YoIHNlZWQsIG1hdGNoZWRbIGkgXSApO1xuXHRcdFx0XHRcdFx0XHRzZWVkWyBpZHggXSA9ICEoIG1hdGNoZXNbIGlkeCBdID0gbWF0Y2hlZFsgaSBdICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSApIDpcblx0XHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmbiggZWxlbSwgMCwgYXJncyApO1xuXHRcdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmbjtcblx0XHR9XG5cdH0sXG5cblx0cHNldWRvczoge1xuXG5cdFx0Ly8gUG90ZW50aWFsbHkgY29tcGxleCBwc2V1ZG9zXG5cdFx0XCJub3RcIjogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cblx0XHRcdC8vIFRyaW0gdGhlIHNlbGVjdG9yIHBhc3NlZCB0byBjb21waWxlXG5cdFx0XHQvLyB0byBhdm9pZCB0cmVhdGluZyBsZWFkaW5nIGFuZCB0cmFpbGluZ1xuXHRcdFx0Ly8gc3BhY2VzIGFzIGNvbWJpbmF0b3JzXG5cdFx0XHR2YXIgaW5wdXQgPSBbXSxcblx0XHRcdFx0cmVzdWx0cyA9IFtdLFxuXHRcdFx0XHRtYXRjaGVyID0gY29tcGlsZSggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApICk7XG5cblx0XHRcdHJldHVybiBtYXRjaGVyWyBleHBhbmRvIF0gP1xuXHRcdFx0XHRtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzLCBfY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBlbGVtLFxuXHRcdFx0XHRcdFx0dW5tYXRjaGVkID0gbWF0Y2hlciggc2VlZCwgbnVsbCwgeG1sLCBbXSApLFxuXHRcdFx0XHRcdFx0aSA9IHNlZWQubGVuZ3RoO1xuXG5cdFx0XHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgdW5tYXRjaGVkIGJ5IGBtYXRjaGVyYFxuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoIGVsZW0gPSB1bm1hdGNoZWRbIGkgXSApICkge1xuXHRcdFx0XHRcdFx0XHRzZWVkWyBpIF0gPSAhKCBtYXRjaGVzWyBpIF0gPSBlbGVtICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICkgOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSwgX2NvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHRpbnB1dFsgMCBdID0gZWxlbTtcblx0XHRcdFx0XHRtYXRjaGVyKCBpbnB1dCwgbnVsbCwgeG1sLCByZXN1bHRzICk7XG5cblx0XHRcdFx0XHQvLyBEb24ndCBrZWVwIHRoZSBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0XHRcdGlucHV0WyAwIF0gPSBudWxsO1xuXHRcdFx0XHRcdHJldHVybiAhcmVzdWx0cy5wb3AoKTtcblx0XHRcdFx0fTtcblx0XHR9ICksXG5cblx0XHRcImhhc1wiOiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIFNpenpsZSggc2VsZWN0b3IsIGVsZW0gKS5sZW5ndGggPiAwO1xuXHRcdFx0fTtcblx0XHR9ICksXG5cblx0XHRcImNvbnRhaW5zXCI6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLnRleHRDb250ZW50IHx8IGdldFRleHQoIGVsZW0gKSApLmluZGV4T2YoIHRleHQgKSA+IC0xO1xuXHRcdFx0fTtcblx0XHR9ICksXG5cblx0XHQvLyBcIldoZXRoZXIgYW4gZWxlbWVudCBpcyByZXByZXNlbnRlZCBieSBhIDpsYW5nKCkgc2VsZWN0b3Jcblx0XHQvLyBpcyBiYXNlZCBzb2xlbHkgb24gdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZVxuXHRcdC8vIGJlaW5nIGVxdWFsIHRvIHRoZSBpZGVudGlmaWVyIEMsXG5cdFx0Ly8gb3IgYmVnaW5uaW5nIHdpdGggdGhlIGlkZW50aWZpZXIgQyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBcIi1cIi5cblx0XHQvLyBUaGUgbWF0Y2hpbmcgb2YgQyBhZ2FpbnN0IHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWUgaXMgcGVyZm9ybWVkIGNhc2UtaW5zZW5zaXRpdmVseS5cblx0XHQvLyBUaGUgaWRlbnRpZmllciBDIGRvZXMgbm90IGhhdmUgdG8gYmUgYSB2YWxpZCBsYW5ndWFnZSBuYW1lLlwiXG5cdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNsYW5nLXBzZXVkb1xuXHRcdFwibGFuZ1wiOiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBsYW5nICkge1xuXG5cdFx0XHQvLyBsYW5nIHZhbHVlIG11c3QgYmUgYSB2YWxpZCBpZGVudGlmaWVyXG5cdFx0XHRpZiAoICFyaWRlbnRpZmllci50ZXN0KCBsYW5nIHx8IFwiXCIgKSApIHtcblx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIGxhbmc6IFwiICsgbGFuZyApO1xuXHRcdFx0fVxuXHRcdFx0bGFuZyA9IGxhbmcucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgZWxlbUxhbmc7XG5cdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRpZiAoICggZWxlbUxhbmcgPSBkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRcdFx0XHRlbGVtLmxhbmcgOlxuXHRcdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoIFwieG1sOmxhbmdcIiApIHx8IGVsZW0uZ2V0QXR0cmlidXRlKCBcImxhbmdcIiApICkgKSB7XG5cblx0XHRcdFx0XHRcdGVsZW1MYW5nID0gZWxlbUxhbmcudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtTGFuZyA9PT0gbGFuZyB8fCBlbGVtTGFuZy5pbmRleE9mKCBsYW5nICsgXCItXCIgKSA9PT0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gd2hpbGUgKCAoIGVsZW0gPSBlbGVtLnBhcmVudE5vZGUgKSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH07XG5cdFx0fSApLFxuXG5cdFx0Ly8gTWlzY2VsbGFuZW91c1xuXHRcdFwidGFyZ2V0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGhhc2ggPSB3aW5kb3cubG9jYXRpb24gJiYgd2luZG93LmxvY2F0aW9uLmhhc2g7XG5cdFx0XHRyZXR1cm4gaGFzaCAmJiBoYXNoLnNsaWNlKCAxICkgPT09IGVsZW0uaWQ7XG5cdFx0fSxcblxuXHRcdFwicm9vdFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2NFbGVtO1xuXHRcdH0sXG5cblx0XHRcImZvY3VzXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiZcblx0XHRcdFx0KCAhZG9jdW1lbnQuaGFzRm9jdXMgfHwgZG9jdW1lbnQuaGFzRm9jdXMoKSApICYmXG5cdFx0XHRcdCEhKCBlbGVtLnR5cGUgfHwgZWxlbS5ocmVmIHx8IH5lbGVtLnRhYkluZGV4ICk7XG5cdFx0fSxcblxuXHRcdC8vIEJvb2xlYW4gcHJvcGVydGllc1xuXHRcdFwiZW5hYmxlZFwiOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggZmFsc2UgKSxcblx0XHRcImRpc2FibGVkXCI6IGNyZWF0ZURpc2FibGVkUHNldWRvKCB0cnVlICksXG5cblx0XHRcImNoZWNrZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8vIEluIENTUzMsIDpjaGVja2VkIHNob3VsZCByZXR1cm4gYm90aCBjaGVja2VkIGFuZCBzZWxlY3RlZCBlbGVtZW50c1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcblx0XHRcdHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgISFlbGVtLmNoZWNrZWQgKSB8fFxuXHRcdFx0XHQoIG5vZGVOYW1lID09PSBcIm9wdGlvblwiICYmICEhZWxlbS5zZWxlY3RlZCApO1xuXHRcdH0sXG5cblx0XHRcInNlbGVjdGVkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvLyBBY2Nlc3NpbmcgdGhpcyBwcm9wZXJ0eSBtYWtlcyBzZWxlY3RlZC1ieS1kZWZhdWx0XG5cdFx0XHQvLyBvcHRpb25zIGluIFNhZmFyaSB3b3JrIHByb3Blcmx5XG5cdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuXHRcdFx0XHRlbGVtLnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVsZW0uc2VsZWN0ZWQgPT09IHRydWU7XG5cdFx0fSxcblxuXHRcdC8vIENvbnRlbnRzXG5cdFx0XCJlbXB0eVwiOiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNlbXB0eS1wc2V1ZG9cblx0XHRcdC8vIDplbXB0eSBpcyBuZWdhdGVkIGJ5IGVsZW1lbnQgKDEpIG9yIGNvbnRlbnQgbm9kZXMgKHRleHQ6IDM7IGNkYXRhOiA0OyBlbnRpdHkgcmVmOiA1KSxcblx0XHRcdC8vICAgYnV0IG5vdCBieSBvdGhlcnMgKGNvbW1lbnQ6IDg7IHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb246IDc7IGV0Yy4pXG5cdFx0XHQvLyBub2RlVHlwZSA8IDYgd29ya3MgYmVjYXVzZSBhdHRyaWJ1dGVzICgyKSBkbyBub3QgYXBwZWFyIGFzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlIDwgNiApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHRcInBhcmVudFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAhRXhwci5wc2V1ZG9zWyBcImVtcHR5XCIgXSggZWxlbSApO1xuXHRcdH0sXG5cblx0XHQvLyBFbGVtZW50L2lucHV0IHR5cGVzXG5cdFx0XCJoZWFkZXJcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gcmhlYWRlci50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdFwiaW5wdXRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gcmlucHV0cy50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdFwiYnV0dG9uXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gXCJidXR0b25cIiB8fCBuYW1lID09PSBcImJ1dHRvblwiO1xuXHRcdH0sXG5cblx0XHRcInRleHRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgYXR0cjtcblx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiAmJlxuXHRcdFx0XHRlbGVtLnR5cGUgPT09IFwidGV4dFwiICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUU8OFxuXHRcdFx0XHQvLyBOZXcgSFRNTDUgYXR0cmlidXRlIHZhbHVlcyAoZS5nLiwgXCJzZWFyY2hcIikgYXBwZWFyIHdpdGggZWxlbS50eXBlID09PSBcInRleHRcIlxuXHRcdFx0XHQoICggYXR0ciA9IGVsZW0uZ2V0QXR0cmlidXRlKCBcInR5cGVcIiApICkgPT0gbnVsbCB8fFxuXHRcdFx0XHRcdGF0dHIudG9Mb3dlckNhc2UoKSA9PT0gXCJ0ZXh0XCIgKTtcblx0XHR9LFxuXG5cdFx0Ly8gUG9zaXRpb24taW4tY29sbGVjdGlvblxuXHRcdFwiZmlyc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gWyAwIF07XG5cdFx0fSApLFxuXG5cdFx0XCJsYXN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCBfbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gWyBsZW5ndGggLSAxIF07XG5cdFx0fSApLFxuXG5cdFx0XCJlcVwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbiggX21hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHJldHVybiBbIGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQgXTtcblx0XHR9ICksXG5cblx0XHRcImV2ZW5cIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0gKSxcblxuXHRcdFwib2RkXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMTtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9ICksXG5cblx0XHRcImx0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/XG5cdFx0XHRcdGFyZ3VtZW50ICsgbGVuZ3RoIDpcblx0XHRcdFx0YXJndW1lbnQgPiBsZW5ndGggP1xuXHRcdFx0XHRcdGxlbmd0aCA6XG5cdFx0XHRcdFx0YXJndW1lbnQ7XG5cdFx0XHRmb3IgKCA7IC0taSA+PSAwOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSApLFxuXG5cdFx0XCJndFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50O1xuXHRcdFx0Zm9yICggOyArK2kgPCBsZW5ndGg7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9IClcblx0fVxufTtcblxuRXhwci5wc2V1ZG9zWyBcIm50aFwiIF0gPSBFeHByLnBzZXVkb3NbIFwiZXFcIiBdO1xuXG4vLyBBZGQgYnV0dG9uL2lucHV0IHR5cGUgcHNldWRvc1xuZm9yICggaSBpbiB7IHJhZGlvOiB0cnVlLCBjaGVja2JveDogdHJ1ZSwgZmlsZTogdHJ1ZSwgcGFzc3dvcmQ6IHRydWUsIGltYWdlOiB0cnVlIH0gKSB7XG5cdEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlSW5wdXRQc2V1ZG8oIGkgKTtcbn1cbmZvciAoIGkgaW4geyBzdWJtaXQ6IHRydWUsIHJlc2V0OiB0cnVlIH0gKSB7XG5cdEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlQnV0dG9uUHNldWRvKCBpICk7XG59XG5cbi8vIEVhc3kgQVBJIGZvciBjcmVhdGluZyBuZXcgc2V0RmlsdGVyc1xuZnVuY3Rpb24gc2V0RmlsdGVycygpIHt9XG5zZXRGaWx0ZXJzLnByb3RvdHlwZSA9IEV4cHIuZmlsdGVycyA9IEV4cHIucHNldWRvcztcbkV4cHIuc2V0RmlsdGVycyA9IG5ldyBzZXRGaWx0ZXJzKCk7XG5cbnRva2VuaXplID0gU2l6emxlLnRva2VuaXplID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBwYXJzZU9ubHkgKSB7XG5cdHZhciBtYXRjaGVkLCBtYXRjaCwgdG9rZW5zLCB0eXBlLFxuXHRcdHNvRmFyLCBncm91cHMsIHByZUZpbHRlcnMsXG5cdFx0Y2FjaGVkID0gdG9rZW5DYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuXG5cdGlmICggY2FjaGVkICkge1xuXHRcdHJldHVybiBwYXJzZU9ubHkgPyAwIDogY2FjaGVkLnNsaWNlKCAwICk7XG5cdH1cblxuXHRzb0ZhciA9IHNlbGVjdG9yO1xuXHRncm91cHMgPSBbXTtcblx0cHJlRmlsdGVycyA9IEV4cHIucHJlRmlsdGVyO1xuXG5cdHdoaWxlICggc29GYXIgKSB7XG5cblx0XHQvLyBDb21tYSBhbmQgZmlyc3QgcnVuXG5cdFx0aWYgKCAhbWF0Y2hlZCB8fCAoIG1hdGNoID0gcmNvbW1hLmV4ZWMoIHNvRmFyICkgKSApIHtcblx0XHRcdGlmICggbWF0Y2ggKSB7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgY29uc3VtZSB0cmFpbGluZyBjb21tYXMgYXMgdmFsaWRcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hbIDAgXS5sZW5ndGggKSB8fCBzb0Zhcjtcblx0XHRcdH1cblx0XHRcdGdyb3Vwcy5wdXNoKCAoIHRva2VucyA9IFtdICkgKTtcblx0XHR9XG5cblx0XHRtYXRjaGVkID0gZmFsc2U7XG5cblx0XHQvLyBDb21iaW5hdG9yc1xuXHRcdGlmICggKCBtYXRjaCA9IHJjb21iaW5hdG9ycy5leGVjKCBzb0ZhciApICkgKSB7XG5cdFx0XHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcblx0XHRcdHRva2Vucy5wdXNoKCB7XG5cdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXG5cdFx0XHRcdC8vIENhc3QgZGVzY2VuZGFudCBjb21iaW5hdG9ycyB0byBzcGFjZVxuXHRcdFx0XHR0eXBlOiBtYXRjaFsgMCBdLnJlcGxhY2UoIHJ0cmltLCBcIiBcIiApXG5cdFx0XHR9ICk7XG5cdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZpbHRlcnNcblx0XHRmb3IgKCB0eXBlIGluIEV4cHIuZmlsdGVyICkge1xuXHRcdFx0aWYgKCAoIG1hdGNoID0gbWF0Y2hFeHByWyB0eXBlIF0uZXhlYyggc29GYXIgKSApICYmICggIXByZUZpbHRlcnNbIHR5cGUgXSB8fFxuXHRcdFx0XHQoIG1hdGNoID0gcHJlRmlsdGVyc1sgdHlwZSBdKCBtYXRjaCApICkgKSApIHtcblx0XHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHRcdHRva2Vucy5wdXNoKCB7XG5cdFx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cdFx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0XHRtYXRjaGVzOiBtYXRjaFxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCAhbWF0Y2hlZCApIHtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbGVuZ3RoIG9mIHRoZSBpbnZhbGlkIGV4Y2Vzc1xuXHQvLyBpZiB3ZSdyZSBqdXN0IHBhcnNpbmdcblx0Ly8gT3RoZXJ3aXNlLCB0aHJvdyBhbiBlcnJvciBvciByZXR1cm4gdG9rZW5zXG5cdHJldHVybiBwYXJzZU9ubHkgP1xuXHRcdHNvRmFyLmxlbmd0aCA6XG5cdFx0c29GYXIgP1xuXHRcdFx0U2l6emxlLmVycm9yKCBzZWxlY3RvciApIDpcblxuXHRcdFx0Ly8gQ2FjaGUgdGhlIHRva2Vuc1xuXHRcdFx0dG9rZW5DYWNoZSggc2VsZWN0b3IsIGdyb3VwcyApLnNsaWNlKCAwICk7XG59O1xuXG5mdW5jdGlvbiB0b1NlbGVjdG9yKCB0b2tlbnMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdHNlbGVjdG9yID0gXCJcIjtcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0c2VsZWN0b3IgKz0gdG9rZW5zWyBpIF0udmFsdWU7XG5cdH1cblx0cmV0dXJuIHNlbGVjdG9yO1xufVxuXG5mdW5jdGlvbiBhZGRDb21iaW5hdG9yKCBtYXRjaGVyLCBjb21iaW5hdG9yLCBiYXNlICkge1xuXHR2YXIgZGlyID0gY29tYmluYXRvci5kaXIsXG5cdFx0c2tpcCA9IGNvbWJpbmF0b3IubmV4dCxcblx0XHRrZXkgPSBza2lwIHx8IGRpcixcblx0XHRjaGVja05vbkVsZW1lbnRzID0gYmFzZSAmJiBrZXkgPT09IFwicGFyZW50Tm9kZVwiLFxuXHRcdGRvbmVOYW1lID0gZG9uZSsrO1xuXG5cdHJldHVybiBjb21iaW5hdG9yLmZpcnN0ID9cblxuXHRcdC8vIENoZWNrIGFnYWluc3QgY2xvc2VzdCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IGVsZW1bIGRpciBdICkgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdHJldHVybiBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0gOlxuXG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBhbGwgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRzXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBvbGRDYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsXG5cdFx0XHRcdG5ld0NhY2hlID0gWyBkaXJydW5zLCBkb25lTmFtZSBdO1xuXG5cdFx0XHQvLyBXZSBjYW4ndCBzZXQgYXJiaXRyYXJ5IGRhdGEgb24gWE1MIG5vZGVzLCBzbyB0aGV5IGRvbid0IGJlbmVmaXQgZnJvbSBjb21iaW5hdG9yIGNhY2hpbmdcblx0XHRcdGlmICggeG1sICkge1xuXHRcdFx0XHR3aGlsZSAoICggZWxlbSA9IGVsZW1bIGRpciBdICkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBlbGVtWyBleHBhbmRvIF0gfHwgKCBlbGVtWyBleHBhbmRvIF0gPSB7fSApO1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgZWxlbS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdCggb3V0ZXJDYWNoZVsgZWxlbS51bmlxdWVJRCBdID0ge30gKTtcblxuXHRcdFx0XHRcdFx0aWYgKCBza2lwICYmIHNraXAgPT09IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSApIHtcblx0XHRcdFx0XHRcdFx0ZWxlbSA9IGVsZW1bIGRpciBdIHx8IGVsZW07XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCAoIG9sZENhY2hlID0gdW5pcXVlQ2FjaGVbIGtleSBdICkgJiZcblx0XHRcdFx0XHRcdFx0b2xkQ2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBvbGRDYWNoZVsgMSBdID09PSBkb25lTmFtZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBBc3NpZ24gdG8gbmV3Q2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gKCBuZXdDYWNoZVsgMiBdID0gb2xkQ2FjaGVbIDIgXSApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBSZXVzZSBuZXdjYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyBrZXkgXSA9IG5ld0NhY2hlO1xuXG5cdFx0XHRcdFx0XHRcdC8vIEEgbWF0Y2ggbWVhbnMgd2UncmUgZG9uZTsgYSBmYWlsIG1lYW5zIHdlIGhhdmUgdG8ga2VlcCBjaGVja2luZ1xuXHRcdFx0XHRcdFx0XHRpZiAoICggbmV3Q2FjaGVbIDIgXSA9IG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xufVxuXG5mdW5jdGlvbiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSB7XG5cdHJldHVybiBtYXRjaGVycy5sZW5ndGggPiAxID9cblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIGkgPSBtYXRjaGVycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCAhbWF0Y2hlcnNbIGkgXSggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IDpcblx0XHRtYXRjaGVyc1sgMCBdO1xufVxuXG5mdW5jdGlvbiBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciwgY29udGV4dHMsIHJlc3VsdHMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSBjb250ZXh0cy5sZW5ndGg7XG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFNpenpsZSggc2VsZWN0b3IsIGNvbnRleHRzWyBpIF0sIHJlc3VsdHMgKTtcblx0fVxuXHRyZXR1cm4gcmVzdWx0cztcbn1cblxuZnVuY3Rpb24gY29uZGVuc2UoIHVubWF0Y2hlZCwgbWFwLCBmaWx0ZXIsIGNvbnRleHQsIHhtbCApIHtcblx0dmFyIGVsZW0sXG5cdFx0bmV3VW5tYXRjaGVkID0gW10sXG5cdFx0aSA9IDAsXG5cdFx0bGVuID0gdW5tYXRjaGVkLmxlbmd0aCxcblx0XHRtYXBwZWQgPSBtYXAgIT0gbnVsbDtcblxuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRpZiAoICggZWxlbSA9IHVubWF0Y2hlZFsgaSBdICkgKSB7XG5cdFx0XHRpZiAoICFmaWx0ZXIgfHwgZmlsdGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0bmV3VW5tYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0aWYgKCBtYXBwZWQgKSB7XG5cdFx0XHRcdFx0bWFwLnB1c2goIGkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBuZXdVbm1hdGNoZWQ7XG59XG5cbmZ1bmN0aW9uIHNldE1hdGNoZXIoIHByZUZpbHRlciwgc2VsZWN0b3IsIG1hdGNoZXIsIHBvc3RGaWx0ZXIsIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApIHtcblx0aWYgKCBwb3N0RmlsdGVyICYmICFwb3N0RmlsdGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbHRlciA9IHNldE1hdGNoZXIoIHBvc3RGaWx0ZXIgKTtcblx0fVxuXHRpZiAoIHBvc3RGaW5kZXIgJiYgIXBvc3RGaW5kZXJbIGV4cGFuZG8gXSApIHtcblx0XHRwb3N0RmluZGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICk7XG5cdH1cblx0cmV0dXJuIG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIHNlZWQsIHJlc3VsdHMsIGNvbnRleHQsIHhtbCApIHtcblx0XHR2YXIgdGVtcCwgaSwgZWxlbSxcblx0XHRcdHByZU1hcCA9IFtdLFxuXHRcdFx0cG9zdE1hcCA9IFtdLFxuXHRcdFx0cHJlZXhpc3RpbmcgPSByZXN1bHRzLmxlbmd0aCxcblxuXHRcdFx0Ly8gR2V0IGluaXRpYWwgZWxlbWVudHMgZnJvbSBzZWVkIG9yIGNvbnRleHRcblx0XHRcdGVsZW1zID0gc2VlZCB8fCBtdWx0aXBsZUNvbnRleHRzKFxuXHRcdFx0XHRzZWxlY3RvciB8fCBcIipcIixcblx0XHRcdFx0Y29udGV4dC5ub2RlVHlwZSA/IFsgY29udGV4dCBdIDogY29udGV4dCxcblx0XHRcdFx0W11cblx0XHRcdCksXG5cblx0XHRcdC8vIFByZWZpbHRlciB0byBnZXQgbWF0Y2hlciBpbnB1dCwgcHJlc2VydmluZyBhIG1hcCBmb3Igc2VlZC1yZXN1bHRzIHN5bmNocm9uaXphdGlvblxuXHRcdFx0bWF0Y2hlckluID0gcHJlRmlsdGVyICYmICggc2VlZCB8fCAhc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGNvbmRlbnNlKCBlbGVtcywgcHJlTWFwLCBwcmVGaWx0ZXIsIGNvbnRleHQsIHhtbCApIDpcblx0XHRcdFx0ZWxlbXMsXG5cblx0XHRcdG1hdGNoZXJPdXQgPSBtYXRjaGVyID9cblxuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGEgcG9zdEZpbmRlciwgb3IgZmlsdGVyZWQgc2VlZCwgb3Igbm9uLXNlZWQgcG9zdEZpbHRlciBvciBwcmVleGlzdGluZyByZXN1bHRzLFxuXHRcdFx0XHRwb3N0RmluZGVyIHx8ICggc2VlZCA/IHByZUZpbHRlciA6IHByZWV4aXN0aW5nIHx8IHBvc3RGaWx0ZXIgKSA/XG5cblx0XHRcdFx0XHQvLyAuLi5pbnRlcm1lZGlhdGUgcHJvY2Vzc2luZyBpcyBuZWNlc3Nhcnlcblx0XHRcdFx0XHRbXSA6XG5cblx0XHRcdFx0XHQvLyAuLi5vdGhlcndpc2UgdXNlIHJlc3VsdHMgZGlyZWN0bHlcblx0XHRcdFx0XHRyZXN1bHRzIDpcblx0XHRcdFx0bWF0Y2hlckluO1xuXG5cdFx0Ly8gRmluZCBwcmltYXJ5IG1hdGNoZXNcblx0XHRpZiAoIG1hdGNoZXIgKSB7XG5cdFx0XHRtYXRjaGVyKCBtYXRjaGVySW4sIG1hdGNoZXJPdXQsIGNvbnRleHQsIHhtbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHBvc3RGaWx0ZXJcblx0XHRpZiAoIHBvc3RGaWx0ZXIgKSB7XG5cdFx0XHR0ZW1wID0gY29uZGVuc2UoIG1hdGNoZXJPdXQsIHBvc3RNYXAgKTtcblx0XHRcdHBvc3RGaWx0ZXIoIHRlbXAsIFtdLCBjb250ZXh0LCB4bWwgKTtcblxuXHRcdFx0Ly8gVW4tbWF0Y2ggZmFpbGluZyBlbGVtZW50cyBieSBtb3ZpbmcgdGhlbSBiYWNrIHRvIG1hdGNoZXJJblxuXHRcdFx0aSA9IHRlbXAubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggKCBlbGVtID0gdGVtcFsgaSBdICkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlck91dFsgcG9zdE1hcFsgaSBdIF0gPSAhKCBtYXRjaGVySW5bIHBvc3RNYXBbIGkgXSBdID0gZWxlbSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyIHx8IHByZUZpbHRlciApIHtcblx0XHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXG5cdFx0XHRcdFx0Ly8gR2V0IHRoZSBmaW5hbCBtYXRjaGVyT3V0IGJ5IGNvbmRlbnNpbmcgdGhpcyBpbnRlcm1lZGlhdGUgaW50byBwb3N0RmluZGVyIGNvbnRleHRzXG5cdFx0XHRcdFx0dGVtcCA9IFtdO1xuXHRcdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKCBlbGVtID0gbWF0Y2hlck91dFsgaSBdICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gUmVzdG9yZSBtYXRjaGVySW4gc2luY2UgZWxlbSBpcyBub3QgeWV0IGEgZmluYWwgbWF0Y2hcblx0XHRcdFx0XHRcdFx0dGVtcC5wdXNoKCAoIG1hdGNoZXJJblsgaSBdID0gZWxlbSApICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBvc3RGaW5kZXIoIG51bGwsICggbWF0Y2hlck91dCA9IFtdICksIHRlbXAsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTW92ZSBtYXRjaGVkIGVsZW1lbnRzIGZyb20gc2VlZCB0byByZXN1bHRzIHRvIGtlZXAgdGhlbSBzeW5jaHJvbml6ZWRcblx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRpZiAoICggZWxlbSA9IG1hdGNoZXJPdXRbIGkgXSApICYmXG5cdFx0XHRcdFx0XHQoIHRlbXAgPSBwb3N0RmluZGVyID8gaW5kZXhPZiggc2VlZCwgZWxlbSApIDogcHJlTWFwWyBpIF0gKSA+IC0xICkge1xuXG5cdFx0XHRcdFx0XHRzZWVkWyB0ZW1wIF0gPSAhKCByZXN1bHRzWyB0ZW1wIF0gPSBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBBZGQgZWxlbWVudHMgdG8gcmVzdWx0cywgdGhyb3VnaCBwb3N0RmluZGVyIGlmIGRlZmluZWRcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF0Y2hlck91dCA9IGNvbmRlbnNlKFxuXHRcdFx0XHRtYXRjaGVyT3V0ID09PSByZXN1bHRzID9cblx0XHRcdFx0XHRtYXRjaGVyT3V0LnNwbGljZSggcHJlZXhpc3RpbmcsIG1hdGNoZXJPdXQubGVuZ3RoICkgOlxuXHRcdFx0XHRcdG1hdGNoZXJPdXRcblx0XHRcdCk7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cdFx0XHRcdHBvc3RGaW5kZXIoIG51bGwsIHJlc3VsdHMsIG1hdGNoZXJPdXQsIHhtbCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgbWF0Y2hlck91dCApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSApO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zICkge1xuXHR2YXIgY2hlY2tDb250ZXh0LCBtYXRjaGVyLCBqLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0bGVhZGluZ1JlbGF0aXZlID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zWyAwIF0udHlwZSBdLFxuXHRcdGltcGxpY2l0UmVsYXRpdmUgPSBsZWFkaW5nUmVsYXRpdmUgfHwgRXhwci5yZWxhdGl2ZVsgXCIgXCIgXSxcblx0XHRpID0gbGVhZGluZ1JlbGF0aXZlID8gMSA6IDAsXG5cblx0XHQvLyBUaGUgZm91bmRhdGlvbmFsIG1hdGNoZXIgZW5zdXJlcyB0aGF0IGVsZW1lbnRzIGFyZSByZWFjaGFibGUgZnJvbSB0b3AtbGV2ZWwgY29udGV4dChzKVxuXHRcdG1hdGNoQ29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGNoZWNrQ29udGV4dDtcblx0XHR9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXG5cdFx0bWF0Y2hBbnlDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXhPZiggY2hlY2tDb250ZXh0LCBlbGVtICkgPiAtMTtcblx0XHR9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXG5cdFx0bWF0Y2hlcnMgPSBbIGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgcmV0ID0gKCAhbGVhZGluZ1JlbGF0aXZlICYmICggeG1sIHx8IGNvbnRleHQgIT09IG91dGVybW9zdENvbnRleHQgKSApIHx8IChcblx0XHRcdFx0KCBjaGVja0NvbnRleHQgPSBjb250ZXh0ICkubm9kZVR5cGUgP1xuXHRcdFx0XHRcdG1hdGNoQ29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRcdG1hdGNoQW55Q29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgKTtcblxuXHRcdFx0Ly8gQXZvaWQgaGFuZ2luZyBvbnRvIGVsZW1lbnQgKGlzc3VlICMyOTkpXG5cdFx0XHRjaGVja0NvbnRleHQgPSBudWxsO1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9IF07XG5cblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0aWYgKCAoIG1hdGNoZXIgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbIGkgXS50eXBlIF0gKSApIHtcblx0XHRcdG1hdGNoZXJzID0gWyBhZGRDb21iaW5hdG9yKCBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSwgbWF0Y2hlciApIF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXIgPSBFeHByLmZpbHRlclsgdG9rZW5zWyBpIF0udHlwZSBdLmFwcGx5KCBudWxsLCB0b2tlbnNbIGkgXS5tYXRjaGVzICk7XG5cblx0XHRcdC8vIFJldHVybiBzcGVjaWFsIHVwb24gc2VlaW5nIGEgcG9zaXRpb25hbCBtYXRjaGVyXG5cdFx0XHRpZiAoIG1hdGNoZXJbIGV4cGFuZG8gXSApIHtcblxuXHRcdFx0XHQvLyBGaW5kIHRoZSBuZXh0IHJlbGF0aXZlIG9wZXJhdG9yIChpZiBhbnkpIGZvciBwcm9wZXIgaGFuZGxpbmdcblx0XHRcdFx0aiA9ICsraTtcblx0XHRcdFx0Zm9yICggOyBqIDwgbGVuOyBqKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBFeHByLnJlbGF0aXZlWyB0b2tlbnNbIGogXS50eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHNldE1hdGNoZXIoXG5cdFx0XHRcdFx0aSA+IDEgJiYgZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksXG5cdFx0XHRcdFx0aSA+IDEgJiYgdG9TZWxlY3RvcihcblxuXHRcdFx0XHRcdC8vIElmIHRoZSBwcmVjZWRpbmcgdG9rZW4gd2FzIGEgZGVzY2VuZGFudCBjb21iaW5hdG9yLCBpbnNlcnQgYW4gaW1wbGljaXQgYW55LWVsZW1lbnQgYCpgXG5cdFx0XHRcdFx0dG9rZW5zXG5cdFx0XHRcdFx0XHQuc2xpY2UoIDAsIGkgLSAxIClcblx0XHRcdFx0XHRcdC5jb25jYXQoIHsgdmFsdWU6IHRva2Vuc1sgaSAtIDIgXS50eXBlID09PSBcIiBcIiA/IFwiKlwiIDogXCJcIiB9IClcblx0XHRcdFx0XHQpLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSxcblx0XHRcdFx0XHRtYXRjaGVyLFxuXHRcdFx0XHRcdGkgPCBqICYmIG1hdGNoZXJGcm9tVG9rZW5zKCB0b2tlbnMuc2xpY2UoIGksIGogKSApLFxuXHRcdFx0XHRcdGogPCBsZW4gJiYgbWF0Y2hlckZyb21Ub2tlbnMoICggdG9rZW5zID0gdG9rZW5zLnNsaWNlKCBqICkgKSApLFxuXHRcdFx0XHRcdGogPCBsZW4gJiYgdG9TZWxlY3RvciggdG9rZW5zIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHRcdG1hdGNoZXJzLnB1c2goIG1hdGNoZXIgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyggZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycyApIHtcblx0dmFyIGJ5U2V0ID0gc2V0TWF0Y2hlcnMubGVuZ3RoID4gMCxcblx0XHRieUVsZW1lbnQgPSBlbGVtZW50TWF0Y2hlcnMubGVuZ3RoID4gMCxcblx0XHRzdXBlck1hdGNoZXIgPSBmdW5jdGlvbiggc2VlZCwgY29udGV4dCwgeG1sLCByZXN1bHRzLCBvdXRlcm1vc3QgKSB7XG5cdFx0XHR2YXIgZWxlbSwgaiwgbWF0Y2hlcixcblx0XHRcdFx0bWF0Y2hlZENvdW50ID0gMCxcblx0XHRcdFx0aSA9IFwiMFwiLFxuXHRcdFx0XHR1bm1hdGNoZWQgPSBzZWVkICYmIFtdLFxuXHRcdFx0XHRzZXRNYXRjaGVkID0gW10sXG5cdFx0XHRcdGNvbnRleHRCYWNrdXAgPSBvdXRlcm1vc3RDb250ZXh0LFxuXG5cdFx0XHRcdC8vIFdlIG11c3QgYWx3YXlzIGhhdmUgZWl0aGVyIHNlZWQgZWxlbWVudHMgb3Igb3V0ZXJtb3N0IGNvbnRleHRcblx0XHRcdFx0ZWxlbXMgPSBzZWVkIHx8IGJ5RWxlbWVudCAmJiBFeHByLmZpbmRbIFwiVEFHXCIgXSggXCIqXCIsIG91dGVybW9zdCApLFxuXG5cdFx0XHRcdC8vIFVzZSBpbnRlZ2VyIGRpcnJ1bnMgaWZmIHRoaXMgaXMgdGhlIG91dGVybW9zdCBtYXRjaGVyXG5cdFx0XHRcdGRpcnJ1bnNVbmlxdWUgPSAoIGRpcnJ1bnMgKz0gY29udGV4dEJhY2t1cCA9PSBudWxsID8gMSA6IE1hdGgucmFuZG9tKCkgfHwgMC4xICksXG5cdFx0XHRcdGxlbiA9IGVsZW1zLmxlbmd0aDtcblxuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdFx0XHRcdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHRcdFx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0XHRcdFx0b3V0ZXJtb3N0Q29udGV4dCA9IGNvbnRleHQgPT0gZG9jdW1lbnQgfHwgY29udGV4dCB8fCBvdXRlcm1vc3Q7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBlbGVtZW50cyBwYXNzaW5nIGVsZW1lbnRNYXRjaGVycyBkaXJlY3RseSB0byByZXN1bHRzXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTw5LCBTYWZhcmlcblx0XHRcdC8vIFRvbGVyYXRlIE5vZGVMaXN0IHByb3BlcnRpZXMgKElFOiBcImxlbmd0aFwiOyBTYWZhcmk6IDxudW1iZXI+KSBtYXRjaGluZyBlbGVtZW50cyBieSBpZFxuXHRcdFx0Zm9yICggOyBpICE9PSBsZW4gJiYgKCBlbGVtID0gZWxlbXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBieUVsZW1lbnQgJiYgZWxlbSApIHtcblx0XHRcdFx0XHRqID0gMDtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHRcdFx0XHRcdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHRcdFx0XHRcdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0XHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdFx0XHRcdFx0aWYgKCAhY29udGV4dCAmJiBlbGVtLm93bmVyRG9jdW1lbnQgIT0gZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHRcdFx0XHRcdFx0eG1sID0gIWRvY3VtZW50SXNIVE1MO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR3aGlsZSAoICggbWF0Y2hlciA9IGVsZW1lbnRNYXRjaGVyc1sgaisrIF0gKSApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCB8fCBkb2N1bWVudCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdFx0XHRkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUcmFjayB1bm1hdGNoZWQgZWxlbWVudHMgZm9yIHNldCBmaWx0ZXJzXG5cdFx0XHRcdGlmICggYnlTZXQgKSB7XG5cblx0XHRcdFx0XHQvLyBUaGV5IHdpbGwgaGF2ZSBnb25lIHRocm91Z2ggYWxsIHBvc3NpYmxlIG1hdGNoZXJzXG5cdFx0XHRcdFx0aWYgKCAoIGVsZW0gPSAhbWF0Y2hlciAmJiBlbGVtICkgKSB7XG5cdFx0XHRcdFx0XHRtYXRjaGVkQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBMZW5ndGhlbiB0aGUgYXJyYXkgZm9yIGV2ZXJ5IGVsZW1lbnQsIG1hdGNoZWQgb3Igbm90XG5cdFx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdFx0dW5tYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gYGlgIGlzIG5vdyB0aGUgY291bnQgb2YgZWxlbWVudHMgdmlzaXRlZCBhYm92ZSwgYW5kIGFkZGluZyBpdCB0byBgbWF0Y2hlZENvdW50YFxuXHRcdFx0Ly8gbWFrZXMgdGhlIGxhdHRlciBub25uZWdhdGl2ZS5cblx0XHRcdG1hdGNoZWRDb3VudCArPSBpO1xuXG5cdFx0XHQvLyBBcHBseSBzZXQgZmlsdGVycyB0byB1bm1hdGNoZWQgZWxlbWVudHNcblx0XHRcdC8vIE5PVEU6IFRoaXMgY2FuIGJlIHNraXBwZWQgaWYgdGhlcmUgYXJlIG5vIHVubWF0Y2hlZCBlbGVtZW50cyAoaS5lLiwgYG1hdGNoZWRDb3VudGBcblx0XHRcdC8vIGVxdWFscyBgaWApLCB1bmxlc3Mgd2UgZGlkbid0IHZpc2l0IF9hbnlfIGVsZW1lbnRzIGluIHRoZSBhYm92ZSBsb29wIGJlY2F1c2Ugd2UgaGF2ZVxuXHRcdFx0Ly8gbm8gZWxlbWVudCBtYXRjaGVycyBhbmQgbm8gc2VlZC5cblx0XHRcdC8vIEluY3JlbWVudGluZyBhbiBpbml0aWFsbHktc3RyaW5nIFwiMFwiIGBpYCBhbGxvd3MgYGlgIHRvIHJlbWFpbiBhIHN0cmluZyBvbmx5IGluIHRoYXRcblx0XHRcdC8vIGNhc2UsIHdoaWNoIHdpbGwgcmVzdWx0IGluIGEgXCIwMFwiIGBtYXRjaGVkQ291bnRgIHRoYXQgZGlmZmVycyBmcm9tIGBpYCBidXQgaXMgYWxzb1xuXHRcdFx0Ly8gbnVtZXJpY2FsbHkgemVyby5cblx0XHRcdGlmICggYnlTZXQgJiYgaSAhPT0gbWF0Y2hlZENvdW50ICkge1xuXHRcdFx0XHRqID0gMDtcblx0XHRcdFx0d2hpbGUgKCAoIG1hdGNoZXIgPSBzZXRNYXRjaGVyc1sgaisrIF0gKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyKCB1bm1hdGNoZWQsIHNldE1hdGNoZWQsIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBzZWVkICkge1xuXG5cdFx0XHRcdFx0Ly8gUmVpbnRlZ3JhdGUgZWxlbWVudCBtYXRjaGVzIHRvIGVsaW1pbmF0ZSB0aGUgbmVlZCBmb3Igc29ydGluZ1xuXHRcdFx0XHRcdGlmICggbWF0Y2hlZENvdW50ID4gMCApIHtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoICEoIHVubWF0Y2hlZFsgaSBdIHx8IHNldE1hdGNoZWRbIGkgXSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHNldE1hdGNoZWRbIGkgXSA9IHBvcC5jYWxsKCByZXN1bHRzICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBEaXNjYXJkIGluZGV4IHBsYWNlaG9sZGVyIHZhbHVlcyB0byBnZXQgb25seSBhY3R1YWwgbWF0Y2hlc1xuXHRcdFx0XHRcdHNldE1hdGNoZWQgPSBjb25kZW5zZSggc2V0TWF0Y2hlZCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQWRkIG1hdGNoZXMgdG8gcmVzdWx0c1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZXRNYXRjaGVkICk7XG5cblx0XHRcdFx0Ly8gU2VlZGxlc3Mgc2V0IG1hdGNoZXMgc3VjY2VlZGluZyBtdWx0aXBsZSBzdWNjZXNzZnVsIG1hdGNoZXJzIHN0aXB1bGF0ZSBzb3J0aW5nXG5cdFx0XHRcdGlmICggb3V0ZXJtb3N0ICYmICFzZWVkICYmIHNldE1hdGNoZWQubGVuZ3RoID4gMCAmJlxuXHRcdFx0XHRcdCggbWF0Y2hlZENvdW50ICsgc2V0TWF0Y2hlcnMubGVuZ3RoICkgPiAxICkge1xuXG5cdFx0XHRcdFx0U2l6emxlLnVuaXF1ZVNvcnQoIHJlc3VsdHMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdmVycmlkZSBtYW5pcHVsYXRpb24gb2YgZ2xvYmFscyBieSBuZXN0ZWQgbWF0Y2hlcnNcblx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcblx0XHRcdFx0b3V0ZXJtb3N0Q29udGV4dCA9IGNvbnRleHRCYWNrdXA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB1bm1hdGNoZWQ7XG5cdFx0fTtcblxuXHRyZXR1cm4gYnlTZXQgP1xuXHRcdG1hcmtGdW5jdGlvbiggc3VwZXJNYXRjaGVyICkgOlxuXHRcdHN1cGVyTWF0Y2hlcjtcbn1cblxuY29tcGlsZSA9IFNpenpsZS5jb21waWxlID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBtYXRjaCAvKiBJbnRlcm5hbCBVc2UgT25seSAqLyApIHtcblx0dmFyIGksXG5cdFx0c2V0TWF0Y2hlcnMgPSBbXSxcblx0XHRlbGVtZW50TWF0Y2hlcnMgPSBbXSxcblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XG5cblx0aWYgKCAhY2FjaGVkICkge1xuXG5cdFx0Ly8gR2VuZXJhdGUgYSBmdW5jdGlvbiBvZiByZWN1cnNpdmUgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2hlY2sgZWFjaCBlbGVtZW50XG5cdFx0aWYgKCAhbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaCA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdH1cblx0XHRpID0gbWF0Y2gubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0Y2FjaGVkID0gbWF0Y2hlckZyb21Ub2tlbnMoIG1hdGNoWyBpIF0gKTtcblx0XHRcdGlmICggY2FjaGVkWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHNldE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbWVudE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhY2hlIHRoZSBjb21waWxlZCBmdW5jdGlvblxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGUoXG5cdFx0XHRzZWxlY3Rvcixcblx0XHRcdG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyggZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycyApXG5cdFx0KTtcblxuXHRcdC8vIFNhdmUgc2VsZWN0b3IgYW5kIHRva2VuaXphdGlvblxuXHRcdGNhY2hlZC5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXHR9XG5cdHJldHVybiBjYWNoZWQ7XG59O1xuXG4vKipcbiAqIEEgbG93LWxldmVsIHNlbGVjdGlvbiBmdW5jdGlvbiB0aGF0IHdvcmtzIHdpdGggU2l6emxlJ3MgY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBzZWxlY3RvciBBIHNlbGVjdG9yIG9yIGEgcHJlLWNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb24gYnVpbHQgd2l0aCBTaXp6bGUuY29tcGlsZVxuICogQHBhcmFtIHtFbGVtZW50fSBjb250ZXh0XG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0c11cbiAqIEBwYXJhbSB7QXJyYXl9IFtzZWVkXSBBIHNldCBvZiBlbGVtZW50cyB0byBtYXRjaCBhZ2FpbnN0XG4gKi9cbnNlbGVjdCA9IFNpenpsZS5zZWxlY3QgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBpLCB0b2tlbnMsIHRva2VuLCB0eXBlLCBmaW5kLFxuXHRcdGNvbXBpbGVkID0gdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgc2VsZWN0b3IsXG5cdFx0bWF0Y2ggPSAhc2VlZCAmJiB0b2tlbml6ZSggKCBzZWxlY3RvciA9IGNvbXBpbGVkLnNlbGVjdG9yIHx8IHNlbGVjdG9yICkgKTtcblxuXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuXHQvLyBUcnkgdG8gbWluaW1pemUgb3BlcmF0aW9ucyBpZiB0aGVyZSBpcyBvbmx5IG9uZSBzZWxlY3RvciBpbiB0aGUgbGlzdCBhbmQgbm8gc2VlZFxuXHQvLyAodGhlIGxhdHRlciBvZiB3aGljaCBndWFyYW50ZWVzIHVzIGNvbnRleHQpXG5cdGlmICggbWF0Y2gubGVuZ3RoID09PSAxICkge1xuXG5cdFx0Ly8gUmVkdWNlIGNvbnRleHQgaWYgdGhlIGxlYWRpbmcgY29tcG91bmQgc2VsZWN0b3IgaXMgYW4gSURcblx0XHR0b2tlbnMgPSBtYXRjaFsgMCBdID0gbWF0Y2hbIDAgXS5zbGljZSggMCApO1xuXHRcdGlmICggdG9rZW5zLmxlbmd0aCA+IDIgJiYgKCB0b2tlbiA9IHRva2Vuc1sgMCBdICkudHlwZSA9PT0gXCJJRFwiICYmXG5cdFx0XHRjb250ZXh0Lm5vZGVUeXBlID09PSA5ICYmIGRvY3VtZW50SXNIVE1MICYmIEV4cHIucmVsYXRpdmVbIHRva2Vuc1sgMSBdLnR5cGUgXSApIHtcblxuXHRcdFx0Y29udGV4dCA9ICggRXhwci5maW5kWyBcIklEXCIgXSggdG9rZW4ubWF0Y2hlc1sgMCBdXG5cdFx0XHRcdC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLCBjb250ZXh0ICkgfHwgW10gKVsgMCBdO1xuXHRcdFx0aWYgKCAhY29udGV4dCApIHtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdC8vIFByZWNvbXBpbGVkIG1hdGNoZXJzIHdpbGwgc3RpbGwgdmVyaWZ5IGFuY2VzdHJ5LCBzbyBzdGVwIHVwIGEgbGV2ZWxcblx0XHRcdH0gZWxzZSBpZiAoIGNvbXBpbGVkICkge1xuXHRcdFx0XHRjb250ZXh0ID0gY29udGV4dC5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXG5cdFx0XHRzZWxlY3RvciA9IHNlbGVjdG9yLnNsaWNlKCB0b2tlbnMuc2hpZnQoKS52YWx1ZS5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGZXRjaCBhIHNlZWQgc2V0IGZvciByaWdodC10by1sZWZ0IG1hdGNoaW5nXG5cdFx0aSA9IG1hdGNoRXhwclsgXCJuZWVkc0NvbnRleHRcIiBdLnRlc3QoIHNlbGVjdG9yICkgPyAwIDogdG9rZW5zLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHRva2VuID0gdG9rZW5zWyBpIF07XG5cblx0XHRcdC8vIEFib3J0IGlmIHdlIGhpdCBhIGNvbWJpbmF0b3Jcblx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgKCB0eXBlID0gdG9rZW4udHlwZSApIF0gKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAoIGZpbmQgPSBFeHByLmZpbmRbIHR5cGUgXSApICkge1xuXG5cdFx0XHRcdC8vIFNlYXJjaCwgZXhwYW5kaW5nIGNvbnRleHQgZm9yIGxlYWRpbmcgc2libGluZyBjb21iaW5hdG9yc1xuXHRcdFx0XHRpZiAoICggc2VlZCA9IGZpbmQoXG5cdFx0XHRcdFx0dG9rZW4ubWF0Y2hlc1sgMCBdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICksXG5cdFx0XHRcdFx0cnNpYmxpbmcudGVzdCggdG9rZW5zWyAwIF0udHlwZSApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fFxuXHRcdFx0XHRcdFx0Y29udGV4dFxuXHRcdFx0XHQpICkgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiBzZWVkIGlzIGVtcHR5IG9yIG5vIHRva2VucyByZW1haW4sIHdlIGNhbiByZXR1cm4gZWFybHlcblx0XHRcdFx0XHR0b2tlbnMuc3BsaWNlKCBpLCAxICk7XG5cdFx0XHRcdFx0c2VsZWN0b3IgPSBzZWVkLmxlbmd0aCAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKTtcblx0XHRcdFx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNlZWQgKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ29tcGlsZSBhbmQgZXhlY3V0ZSBhIGZpbHRlcmluZyBmdW5jdGlvbiBpZiBvbmUgaXMgbm90IHByb3ZpZGVkXG5cdC8vIFByb3ZpZGUgYG1hdGNoYCB0byBhdm9pZCByZXRva2VuaXphdGlvbiBpZiB3ZSBtb2RpZmllZCB0aGUgc2VsZWN0b3IgYWJvdmVcblx0KCBjb21waWxlZCB8fCBjb21waWxlKCBzZWxlY3RvciwgbWF0Y2ggKSApKFxuXHRcdHNlZWQsXG5cdFx0Y29udGV4dCxcblx0XHQhZG9jdW1lbnRJc0hUTUwsXG5cdFx0cmVzdWx0cyxcblx0XHQhY29udGV4dCB8fCByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdCk7XG5cdHJldHVybiByZXN1bHRzO1xufTtcblxuLy8gT25lLXRpbWUgYXNzaWdubWVudHNcblxuLy8gU29ydCBzdGFiaWxpdHlcbnN1cHBvcnQuc29ydFN0YWJsZSA9IGV4cGFuZG8uc3BsaXQoIFwiXCIgKS5zb3J0KCBzb3J0T3JkZXIgKS5qb2luKCBcIlwiICkgPT09IGV4cGFuZG87XG5cbi8vIFN1cHBvcnQ6IENocm9tZSAxNC0zNStcbi8vIEFsd2F5cyBhc3N1bWUgZHVwbGljYXRlcyBpZiB0aGV5IGFyZW4ndCBwYXNzZWQgdG8gdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25cbnN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcyA9ICEhaGFzRHVwbGljYXRlO1xuXG4vLyBJbml0aWFsaXplIGFnYWluc3QgdGhlIGRlZmF1bHQgZG9jdW1lbnRcbnNldERvY3VtZW50KCk7XG5cbi8vIFN1cHBvcnQ6IFdlYmtpdDw1MzcuMzIgLSBTYWZhcmkgNi4wLjMvQ2hyb21lIDI1IChmaXhlZCBpbiBDaHJvbWUgMjcpXG4vLyBEZXRhY2hlZCBub2RlcyBjb25mb3VuZGluZ2x5IGZvbGxvdyAqZWFjaCBvdGhlcipcbnN1cHBvcnQuc29ydERldGFjaGVkID0gYXNzZXJ0KCBmdW5jdGlvbiggZWwgKSB7XG5cblx0Ly8gU2hvdWxkIHJldHVybiAxLCBidXQgcmV0dXJucyA0IChmb2xsb3dpbmcpXG5cdHJldHVybiBlbC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJmaWVsZHNldFwiICkgKSAmIDE7XG59ICk7XG5cbi8vIFN1cHBvcnQ6IElFPDhcbi8vIFByZXZlbnQgYXR0cmlidXRlL3Byb3BlcnR5IFwiaW50ZXJwb2xhdGlvblwiXG4vLyBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTM2NDI5JTI4VlMuODUlMjkuYXNweFxuaWYgKCAhYXNzZXJ0KCBmdW5jdGlvbiggZWwgKSB7XG5cdGVsLmlubmVySFRNTCA9IFwiPGEgaHJlZj0nIyc+PC9hPlwiO1xuXHRyZXR1cm4gZWwuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoIFwiaHJlZlwiICkgPT09IFwiI1wiO1xufSApICkge1xuXHRhZGRIYW5kbGUoIFwidHlwZXxocmVmfGhlaWdodHx3aWR0aFwiLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJ0eXBlXCIgPyAxIDogMiApO1xuXHRcdH1cblx0fSApO1xufVxuXG4vLyBTdXBwb3J0OiBJRTw5XG4vLyBVc2UgZGVmYXVsdFZhbHVlIGluIHBsYWNlIG9mIGdldEF0dHJpYnV0ZShcInZhbHVlXCIpXG5pZiAoICFzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXHRlbC5pbm5lckhUTUwgPSBcIjxpbnB1dC8+XCI7XG5cdGVsLmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKCBcInZhbHVlXCIsIFwiXCIgKTtcblx0cmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gXCJcIjtcbn0gKSApIHtcblx0YWRkSGFuZGxlKCBcInZhbHVlXCIsIGZ1bmN0aW9uKCBlbGVtLCBfbmFtZSwgaXNYTUwgKSB7XG5cdFx0aWYgKCAhaXNYTUwgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kZWZhdWx0VmFsdWU7XG5cdFx0fVxuXHR9ICk7XG59XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBnZXRBdHRyaWJ1dGVOb2RlIHRvIGZldGNoIGJvb2xlYW5zIHdoZW4gZ2V0QXR0cmlidXRlIGxpZXNcbmlmICggIWFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXHRyZXR1cm4gZWwuZ2V0QXR0cmlidXRlKCBcImRpc2FibGVkXCIgKSA9PSBudWxsO1xufSApICkge1xuXHRhZGRIYW5kbGUoIGJvb2xlYW5zLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0dmFyIHZhbDtcblx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdHJldHVybiBlbGVtWyBuYW1lIF0gPT09IHRydWUgPyBuYW1lLnRvTG93ZXJDYXNlKCkgOlxuXHRcdFx0XHQoIHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggbmFtZSApICkgJiYgdmFsLnNwZWNpZmllZCA/XG5cdFx0XHRcdFx0dmFsLnZhbHVlIDpcblx0XHRcdFx0XHRudWxsO1xuXHRcdH1cblx0fSApO1xufVxuXG5yZXR1cm4gU2l6emxlO1xuXG59ICkoIHdpbmRvdyApO1xuXG5cblxualF1ZXJ5LmZpbmQgPSBTaXp6bGU7XG5qUXVlcnkuZXhwciA9IFNpenpsZS5zZWxlY3RvcnM7XG5cbi8vIERlcHJlY2F0ZWRcbmpRdWVyeS5leHByWyBcIjpcIiBdID0galF1ZXJ5LmV4cHIucHNldWRvcztcbmpRdWVyeS51bmlxdWVTb3J0ID0galF1ZXJ5LnVuaXF1ZSA9IFNpenpsZS51bmlxdWVTb3J0O1xualF1ZXJ5LnRleHQgPSBTaXp6bGUuZ2V0VGV4dDtcbmpRdWVyeS5pc1hNTERvYyA9IFNpenpsZS5pc1hNTDtcbmpRdWVyeS5jb250YWlucyA9IFNpenpsZS5jb250YWlucztcbmpRdWVyeS5lc2NhcGVTZWxlY3RvciA9IFNpenpsZS5lc2NhcGU7XG5cblxuXG5cbnZhciBkaXIgPSBmdW5jdGlvbiggZWxlbSwgZGlyLCB1bnRpbCApIHtcblx0dmFyIG1hdGNoZWQgPSBbXSxcblx0XHR0cnVuY2F0ZSA9IHVudGlsICE9PSB1bmRlZmluZWQ7XG5cblx0d2hpbGUgKCAoIGVsZW0gPSBlbGVtWyBkaXIgXSApICYmIGVsZW0ubm9kZVR5cGUgIT09IDkgKSB7XG5cdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0aWYgKCB0cnVuY2F0ZSAmJiBqUXVlcnkoIGVsZW0gKS5pcyggdW50aWwgKSApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRtYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG1hdGNoZWQ7XG59O1xuXG5cbnZhciBzaWJsaW5ncyA9IGZ1bmN0aW9uKCBuLCBlbGVtICkge1xuXHR2YXIgbWF0Y2hlZCA9IFtdO1xuXG5cdGZvciAoIDsgbjsgbiA9IG4ubmV4dFNpYmxpbmcgKSB7XG5cdFx0aWYgKCBuLm5vZGVUeXBlID09PSAxICYmIG4gIT09IGVsZW0gKSB7XG5cdFx0XHRtYXRjaGVkLnB1c2goIG4gKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbWF0Y2hlZDtcbn07XG5cblxudmFyIHJuZWVkc0NvbnRleHQgPSBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQ7XG5cblxuXG5mdW5jdGlvbiBub2RlTmFtZSggZWxlbSwgbmFtZSApIHtcblxuXHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUudG9Mb3dlckNhc2UoKTtcblxufVxudmFyIHJzaW5nbGVUYWcgPSAoIC9ePChbYS16XVteXFwvXFwwPjpcXHgyMFxcdFxcclxcblxcZl0qKVtcXHgyMFxcdFxcclxcblxcZl0qXFwvPz4oPzo8XFwvXFwxPnwpJC9pICk7XG5cblxuXG4vLyBJbXBsZW1lbnQgdGhlIGlkZW50aWNhbCBmdW5jdGlvbmFsaXR5IGZvciBmaWx0ZXIgYW5kIG5vdFxuZnVuY3Rpb24gd2lubm93KCBlbGVtZW50cywgcXVhbGlmaWVyLCBub3QgKSB7XG5cdGlmICggaXNGdW5jdGlvbiggcXVhbGlmaWVyICkgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gISFxdWFsaWZpZXIuY2FsbCggZWxlbSwgaSwgZWxlbSApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gU2luZ2xlIGVsZW1lbnRcblx0aWYgKCBxdWFsaWZpZXIubm9kZVR5cGUgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCBlbGVtID09PSBxdWFsaWZpZXIgKSAhPT0gbm90O1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEFycmF5bGlrZSBvZiBlbGVtZW50cyAoalF1ZXJ5LCBhcmd1bWVudHMsIEFycmF5KVxuXHRpZiAoIHR5cGVvZiBxdWFsaWZpZXIgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCBpbmRleE9mLmNhbGwoIHF1YWxpZmllciwgZWxlbSApID4gLTEgKSAhPT0gbm90O1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEZpbHRlcmVkIGRpcmVjdGx5IGZvciBib3RoIHNpbXBsZSBhbmQgY29tcGxleCBzZWxlY3RvcnNcblx0cmV0dXJuIGpRdWVyeS5maWx0ZXIoIHF1YWxpZmllciwgZWxlbWVudHMsIG5vdCApO1xufVxuXG5qUXVlcnkuZmlsdGVyID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1zLCBub3QgKSB7XG5cdHZhciBlbGVtID0gZWxlbXNbIDAgXTtcblxuXHRpZiAoIG5vdCApIHtcblx0XHRleHByID0gXCI6bm90KFwiICsgZXhwciArIFwiKVwiO1xuXHR9XG5cblx0aWYgKCBlbGVtcy5sZW5ndGggPT09IDEgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBlbGVtLCBleHByICkgPyBbIGVsZW0gXSA6IFtdO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5maW5kLm1hdGNoZXMoIGV4cHIsIGpRdWVyeS5ncmVwKCBlbGVtcywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGVsZW0ubm9kZVR5cGUgPT09IDE7XG5cdH0gKSApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRmaW5kOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGksIHJldCxcblx0XHRcdGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0c2VsZiA9IHRoaXM7XG5cblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5KCBzZWxlY3RvciApLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHNlbGZbIGkgXSwgdGhpcyApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9ICkgKTtcblx0XHR9XG5cblx0XHRyZXQgPSB0aGlzLnB1c2hTdGFjayggW10gKTtcblxuXHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRqUXVlcnkuZmluZCggc2VsZWN0b3IsIHNlbGZbIGkgXSwgcmV0ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGxlbiA+IDEgPyBqUXVlcnkudW5pcXVlU29ydCggcmV0ICkgOiByZXQ7XG5cdH0sXG5cdGZpbHRlcjogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgZmFsc2UgKSApO1xuXHR9LFxuXHRub3Q6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyggdGhpcywgc2VsZWN0b3IgfHwgW10sIHRydWUgKSApO1xuXHR9LFxuXHRpczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiAhIXdpbm5vdyhcblx0XHRcdHRoaXMsXG5cblx0XHRcdC8vIElmIHRoaXMgaXMgYSBwb3NpdGlvbmFsL3JlbGF0aXZlIHNlbGVjdG9yLCBjaGVjayBtZW1iZXJzaGlwIGluIHRoZSByZXR1cm5lZCBzZXRcblx0XHRcdC8vIHNvICQoXCJwOmZpcnN0XCIpLmlzKFwicDpsYXN0XCIpIHdvbid0IHJldHVybiB0cnVlIGZvciBhIGRvYyB3aXRoIHR3byBcInBcIi5cblx0XHRcdHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiAmJiBybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICkgP1xuXHRcdFx0XHRqUXVlcnkoIHNlbGVjdG9yICkgOlxuXHRcdFx0XHRzZWxlY3RvciB8fCBbXSxcblx0XHRcdGZhbHNlXG5cdFx0KS5sZW5ndGg7XG5cdH1cbn0gKTtcblxuXG4vLyBJbml0aWFsaXplIGEgalF1ZXJ5IG9iamVjdFxuXG5cbi8vIEEgY2VudHJhbCByZWZlcmVuY2UgdG8gdGhlIHJvb3QgalF1ZXJ5KGRvY3VtZW50KVxudmFyIHJvb3RqUXVlcnksXG5cblx0Ly8gQSBzaW1wbGUgd2F5IHRvIGNoZWNrIGZvciBIVE1MIHN0cmluZ3Ncblx0Ly8gUHJpb3JpdGl6ZSAjaWQgb3ZlciA8dGFnPiB0byBhdm9pZCBYU1MgdmlhIGxvY2F0aW9uLmhhc2ggKCM5NTIxKVxuXHQvLyBTdHJpY3QgSFRNTCByZWNvZ25pdGlvbiAoIzExMjkwOiBtdXN0IHN0YXJ0IHdpdGggPClcblx0Ly8gU2hvcnRjdXQgc2ltcGxlICNpZCBjYXNlIGZvciBzcGVlZFxuXHRycXVpY2tFeHByID0gL14oPzpcXHMqKDxbXFx3XFxXXSs+KVtePl0qfCMoW1xcdy1dKykpJC8sXG5cblx0aW5pdCA9IGpRdWVyeS5mbi5pbml0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByb290ICkge1xuXHRcdHZhciBtYXRjaCwgZWxlbTtcblxuXHRcdC8vIEhBTkRMRTogJChcIlwiKSwgJChudWxsKSwgJCh1bmRlZmluZWQpLCAkKGZhbHNlKVxuXHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Ly8gTWV0aG9kIGluaXQoKSBhY2NlcHRzIGFuIGFsdGVybmF0ZSByb290alF1ZXJ5XG5cdFx0Ly8gc28gbWlncmF0ZSBjYW4gc3VwcG9ydCBqUXVlcnkuc3ViIChnaC0yMTAxKVxuXHRcdHJvb3QgPSByb290IHx8IHJvb3RqUXVlcnk7XG5cblx0XHQvLyBIYW5kbGUgSFRNTCBzdHJpbmdzXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRpZiAoIHNlbGVjdG9yWyAwIF0gPT09IFwiPFwiICYmXG5cdFx0XHRcdHNlbGVjdG9yWyBzZWxlY3Rvci5sZW5ndGggLSAxIF0gPT09IFwiPlwiICYmXG5cdFx0XHRcdHNlbGVjdG9yLmxlbmd0aCA+PSAzICkge1xuXG5cdFx0XHRcdC8vIEFzc3VtZSB0aGF0IHN0cmluZ3MgdGhhdCBzdGFydCBhbmQgZW5kIHdpdGggPD4gYXJlIEhUTUwgYW5kIHNraXAgdGhlIHJlZ2V4IGNoZWNrXG5cdFx0XHRcdG1hdGNoID0gWyBudWxsLCBzZWxlY3RvciwgbnVsbCBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWF0Y2ggaHRtbCBvciBtYWtlIHN1cmUgbm8gY29udGV4dCBpcyBzcGVjaWZpZWQgZm9yICNpZFxuXHRcdFx0aWYgKCBtYXRjaCAmJiAoIG1hdGNoWyAxIF0gfHwgIWNvbnRleHQgKSApIHtcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCkgLT4gJChhcnJheSlcblx0XHRcdFx0aWYgKCBtYXRjaFsgMSBdICkge1xuXHRcdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0IGluc3RhbmNlb2YgalF1ZXJ5ID8gY29udGV4dFsgMCBdIDogY29udGV4dDtcblxuXHRcdFx0XHRcdC8vIE9wdGlvbiB0byBydW4gc2NyaXB0cyBpcyB0cnVlIGZvciBiYWNrLWNvbXBhdFxuXHRcdFx0XHRcdC8vIEludGVudGlvbmFsbHkgbGV0IHRoZSBlcnJvciBiZSB0aHJvd24gaWYgcGFyc2VIVE1MIGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLCBqUXVlcnkucGFyc2VIVE1MKFxuXHRcdFx0XHRcdFx0bWF0Y2hbIDEgXSxcblx0XHRcdFx0XHRcdGNvbnRleHQgJiYgY29udGV4dC5ub2RlVHlwZSA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogZG9jdW1lbnQsXG5cdFx0XHRcdFx0XHR0cnVlXG5cdFx0XHRcdFx0KSApO1xuXG5cdFx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwsIHByb3BzKVxuXHRcdFx0XHRcdGlmICggcnNpbmdsZVRhZy50ZXN0KCBtYXRjaFsgMSBdICkgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvbnRleHQgKSApIHtcblx0XHRcdFx0XHRcdGZvciAoIG1hdGNoIGluIGNvbnRleHQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gUHJvcGVydGllcyBvZiBjb250ZXh0IGFyZSBjYWxsZWQgYXMgbWV0aG9kcyBpZiBwb3NzaWJsZVxuXHRcdFx0XHRcdFx0XHRpZiAoIGlzRnVuY3Rpb24oIHRoaXNbIG1hdGNoIF0gKSApIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzWyBtYXRjaCBdKCBjb250ZXh0WyBtYXRjaCBdICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gLi4uYW5kIG90aGVyd2lzZSBzZXQgYXMgYXR0cmlidXRlc1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuYXR0ciggbWF0Y2gsIGNvbnRleHRbIG1hdGNoIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJCgjaWQpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCBtYXRjaFsgMiBdICk7XG5cblx0XHRcdFx0XHRpZiAoIGVsZW0gKSB7XG5cblx0XHRcdFx0XHRcdC8vIEluamVjdCB0aGUgZWxlbWVudCBkaXJlY3RseSBpbnRvIHRoZSBqUXVlcnkgb2JqZWN0XG5cdFx0XHRcdFx0XHR0aGlzWyAwIF0gPSBlbGVtO1xuXHRcdFx0XHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgJCguLi4pKVxuXHRcdFx0fSBlbHNlIGlmICggIWNvbnRleHQgfHwgY29udGV4dC5qcXVlcnkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGNvbnRleHQgfHwgcm9vdCApLmZpbmQoIHNlbGVjdG9yICk7XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCBjb250ZXh0KVxuXHRcdFx0Ly8gKHdoaWNoIGlzIGp1c3QgZXF1aXZhbGVudCB0bzogJChjb250ZXh0KS5maW5kKGV4cHIpXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5jb25zdHJ1Y3RvciggY29udGV4dCApLmZpbmQoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHQvLyBIQU5ETEU6ICQoRE9NRWxlbWVudClcblx0XHR9IGVsc2UgaWYgKCBzZWxlY3Rvci5ub2RlVHlwZSApIHtcblx0XHRcdHRoaXNbIDAgXSA9IHNlbGVjdG9yO1xuXHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHQvLyBIQU5ETEU6ICQoZnVuY3Rpb24pXG5cdFx0Ly8gU2hvcnRjdXQgZm9yIGRvY3VtZW50IHJlYWR5XG5cdFx0fSBlbHNlIGlmICggaXNGdW5jdGlvbiggc2VsZWN0b3IgKSApIHtcblx0XHRcdHJldHVybiByb290LnJlYWR5ICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRyb290LnJlYWR5KCBzZWxlY3RvciApIDpcblxuXHRcdFx0XHQvLyBFeGVjdXRlIGltbWVkaWF0ZWx5IGlmIHJlYWR5IGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdHNlbGVjdG9yKCBqUXVlcnkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4galF1ZXJ5Lm1ha2VBcnJheSggc2VsZWN0b3IsIHRoaXMgKTtcblx0fTtcblxuLy8gR2l2ZSB0aGUgaW5pdCBmdW5jdGlvbiB0aGUgalF1ZXJ5IHByb3RvdHlwZSBmb3IgbGF0ZXIgaW5zdGFudGlhdGlvblxuaW5pdC5wcm90b3R5cGUgPSBqUXVlcnkuZm47XG5cbi8vIEluaXRpYWxpemUgY2VudHJhbCByZWZlcmVuY2VcbnJvb3RqUXVlcnkgPSBqUXVlcnkoIGRvY3VtZW50ICk7XG5cblxudmFyIHJwYXJlbnRzcHJldiA9IC9eKD86cGFyZW50c3xwcmV2KD86VW50aWx8QWxsKSkvLFxuXG5cdC8vIE1ldGhvZHMgZ3VhcmFudGVlZCB0byBwcm9kdWNlIGEgdW5pcXVlIHNldCB3aGVuIHN0YXJ0aW5nIGZyb20gYSB1bmlxdWUgc2V0XG5cdGd1YXJhbnRlZWRVbmlxdWUgPSB7XG5cdFx0Y2hpbGRyZW46IHRydWUsXG5cdFx0Y29udGVudHM6IHRydWUsXG5cdFx0bmV4dDogdHJ1ZSxcblx0XHRwcmV2OiB0cnVlXG5cdH07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0aGFzOiBmdW5jdGlvbiggdGFyZ2V0ICkge1xuXHRcdHZhciB0YXJnZXRzID0galF1ZXJ5KCB0YXJnZXQsIHRoaXMgKSxcblx0XHRcdGwgPSB0YXJnZXRzLmxlbmd0aDtcblxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCB0aGlzLCB0YXJnZXRzWyBpIF0gKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRjbG9zZXN0OiBmdW5jdGlvbiggc2VsZWN0b3JzLCBjb250ZXh0ICkge1xuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGwgPSB0aGlzLmxlbmd0aCxcblx0XHRcdG1hdGNoZWQgPSBbXSxcblx0XHRcdHRhcmdldHMgPSB0eXBlb2Ygc2VsZWN0b3JzICE9PSBcInN0cmluZ1wiICYmIGpRdWVyeSggc2VsZWN0b3JzICk7XG5cblx0XHQvLyBQb3NpdGlvbmFsIHNlbGVjdG9ycyBuZXZlciBtYXRjaCwgc2luY2UgdGhlcmUncyBubyBfc2VsZWN0aW9uXyBjb250ZXh0XG5cdFx0aWYgKCAhcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvcnMgKSApIHtcblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0Zm9yICggY3VyID0gdGhpc1sgaSBdOyBjdXIgJiYgY3VyICE9PSBjb250ZXh0OyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblxuXHRcdFx0XHRcdC8vIEFsd2F5cyBza2lwIGRvY3VtZW50IGZyYWdtZW50c1xuXHRcdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlIDwgMTEgJiYgKCB0YXJnZXRzID9cblx0XHRcdFx0XHRcdHRhcmdldHMuaW5kZXgoIGN1ciApID4gLTEgOlxuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBwYXNzIG5vbi1lbGVtZW50cyB0byBTaXp6bGVcblx0XHRcdFx0XHRcdGN1ci5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGN1ciwgc2VsZWN0b3JzICkgKSApIHtcblxuXHRcdFx0XHRcdFx0bWF0Y2hlZC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZC5sZW5ndGggPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKSA6IG1hdGNoZWQgKTtcblx0fSxcblxuXHQvLyBEZXRlcm1pbmUgdGhlIHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQgd2l0aGluIHRoZSBzZXRcblx0aW5kZXg6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gTm8gYXJndW1lbnQsIHJldHVybiBpbmRleCBpbiBwYXJlbnRcblx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0cmV0dXJuICggdGhpc1sgMCBdICYmIHRoaXNbIDAgXS5wYXJlbnROb2RlICkgPyB0aGlzLmZpcnN0KCkucHJldkFsbCgpLmxlbmd0aCA6IC0xO1xuXHRcdH1cblxuXHRcdC8vIEluZGV4IGluIHNlbGVjdG9yXG5cdFx0aWYgKCB0eXBlb2YgZWxlbSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBpbmRleE9mLmNhbGwoIGpRdWVyeSggZWxlbSApLCB0aGlzWyAwIF0gKTtcblx0XHR9XG5cblx0XHQvLyBMb2NhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBkZXNpcmVkIGVsZW1lbnRcblx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCB0aGlzLFxuXG5cdFx0XHQvLyBJZiBpdCByZWNlaXZlcyBhIGpRdWVyeSBvYmplY3QsIHRoZSBmaXJzdCBlbGVtZW50IGlzIHVzZWRcblx0XHRcdGVsZW0uanF1ZXJ5ID8gZWxlbVsgMCBdIDogZWxlbVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKFxuXHRcdFx0alF1ZXJ5LnVuaXF1ZVNvcnQoXG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcy5nZXQoKSwgalF1ZXJ5KCBzZWxlY3RvciwgY29udGV4dCApIClcblx0XHRcdClcblx0XHQpO1xuXHR9LFxuXG5cdGFkZEJhY2s6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5hZGQoIHNlbGVjdG9yID09IG51bGwgP1xuXHRcdFx0dGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlciggc2VsZWN0b3IgKVxuXHRcdCk7XG5cdH1cbn0gKTtcblxuZnVuY3Rpb24gc2libGluZyggY3VyLCBkaXIgKSB7XG5cdHdoaWxlICggKCBjdXIgPSBjdXJbIGRpciBdICkgJiYgY3VyLm5vZGVUeXBlICE9PSAxICkge31cblx0cmV0dXJuIGN1cjtcbn1cblxualF1ZXJ5LmVhY2goIHtcblx0cGFyZW50OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdHJldHVybiBwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlICE9PSAxMSA/IHBhcmVudCA6IG51bGw7XG5cdH0sXG5cdHBhcmVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiICk7XG5cdH0sXG5cdHBhcmVudHNVbnRpbDogZnVuY3Rpb24oIGVsZW0sIF9pLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiwgdW50aWwgKTtcblx0fSxcblx0bmV4dDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuXHR9LFxuXHRuZXh0QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldkFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuXHR9LFxuXHRuZXh0VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBfaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRwcmV2VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBfaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0c2libGluZ3M6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggKCBlbGVtLnBhcmVudE5vZGUgfHwge30gKS5maXJzdENoaWxkLCBlbGVtICk7XG5cdH0sXG5cdGNoaWxkcmVuOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZ3MoIGVsZW0uZmlyc3RDaGlsZCApO1xuXHR9LFxuXHRjb250ZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0aWYgKCBlbGVtLmNvbnRlbnREb2N1bWVudCAhPSBudWxsICYmXG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExK1xuXHRcdFx0Ly8gPG9iamVjdD4gZWxlbWVudHMgd2l0aCBubyBgZGF0YWAgYXR0cmlidXRlIGhhcyBhbiBvYmplY3Rcblx0XHRcdC8vIGBjb250ZW50RG9jdW1lbnRgIHdpdGggYSBgbnVsbGAgcHJvdG90eXBlLlxuXHRcdFx0Z2V0UHJvdG8oIGVsZW0uY29udGVudERvY3VtZW50ICkgKSB7XG5cblx0XHRcdHJldHVybiBlbGVtLmNvbnRlbnREb2N1bWVudDtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seSwgaU9TIDcgb25seSwgQW5kcm9pZCBCcm93c2VyIDw9NC4zIG9ubHlcblx0XHQvLyBUcmVhdCB0aGUgdGVtcGxhdGUgZWxlbWVudCBhcyBhIHJlZ3VsYXIgb25lIGluIGJyb3dzZXJzIHRoYXRcblx0XHQvLyBkb24ndCBzdXBwb3J0IGl0LlxuXHRcdGlmICggbm9kZU5hbWUoIGVsZW0sIFwidGVtcGxhdGVcIiApICkge1xuXHRcdFx0ZWxlbSA9IGVsZW0uY29udGVudCB8fCBlbGVtO1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBlbGVtLmNoaWxkTm9kZXMgKTtcblx0fVxufSwgZnVuY3Rpb24oIG5hbWUsIGZuICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCB1bnRpbCwgc2VsZWN0b3IgKSB7XG5cdFx0dmFyIG1hdGNoZWQgPSBqUXVlcnkubWFwKCB0aGlzLCBmbiwgdW50aWwgKTtcblxuXHRcdGlmICggbmFtZS5zbGljZSggLTUgKSAhPT0gXCJVbnRpbFwiICkge1xuXHRcdFx0c2VsZWN0b3IgPSB1bnRpbDtcblx0XHR9XG5cblx0XHRpZiAoIHNlbGVjdG9yICYmIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG1hdGNoZWQgPSBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgbWF0Y2hlZCApO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHQvLyBSZW1vdmUgZHVwbGljYXRlc1xuXHRcdFx0aWYgKCAhZ3VhcmFudGVlZFVuaXF1ZVsgbmFtZSBdICkge1xuXHRcdFx0XHRqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXZlcnNlIG9yZGVyIGZvciBwYXJlbnRzKiBhbmQgcHJldi1kZXJpdmF0aXZlc1xuXHRcdFx0aWYgKCBycGFyZW50c3ByZXYudGVzdCggbmFtZSApICkge1xuXHRcdFx0XHRtYXRjaGVkLnJldmVyc2UoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQgKTtcblx0fTtcbn0gKTtcbnZhciBybm90aHRtbHdoaXRlID0gKCAvW15cXHgyMFxcdFxcclxcblxcZl0rL2cgKTtcblxuXG5cbi8vIENvbnZlcnQgU3RyaW5nLWZvcm1hdHRlZCBvcHRpb25zIGludG8gT2JqZWN0LWZvcm1hdHRlZCBvbmVzXG5mdW5jdGlvbiBjcmVhdGVPcHRpb25zKCBvcHRpb25zICkge1xuXHR2YXIgb2JqZWN0ID0ge307XG5cdGpRdWVyeS5lYWNoKCBvcHRpb25zLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW10sIGZ1bmN0aW9uKCBfLCBmbGFnICkge1xuXHRcdG9iamVjdFsgZmxhZyBdID0gdHJ1ZTtcblx0fSApO1xuXHRyZXR1cm4gb2JqZWN0O1xufVxuXG4vKlxuICogQ3JlYXRlIGEgY2FsbGJhY2sgbGlzdCB1c2luZyB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gKlxuICpcdG9wdGlvbnM6IGFuIG9wdGlvbmFsIGxpc3Qgb2Ygc3BhY2Utc2VwYXJhdGVkIG9wdGlvbnMgdGhhdCB3aWxsIGNoYW5nZSBob3dcbiAqXHRcdFx0dGhlIGNhbGxiYWNrIGxpc3QgYmVoYXZlcyBvciBhIG1vcmUgdHJhZGl0aW9uYWwgb3B0aW9uIG9iamVjdFxuICpcbiAqIEJ5IGRlZmF1bHQgYSBjYWxsYmFjayBsaXN0IHdpbGwgYWN0IGxpa2UgYW4gZXZlbnQgY2FsbGJhY2sgbGlzdCBhbmQgY2FuIGJlXG4gKiBcImZpcmVkXCIgbXVsdGlwbGUgdGltZXMuXG4gKlxuICogUG9zc2libGUgb3B0aW9uczpcbiAqXG4gKlx0b25jZTpcdFx0XHR3aWxsIGVuc3VyZSB0aGUgY2FsbGJhY2sgbGlzdCBjYW4gb25seSBiZSBmaXJlZCBvbmNlIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdG1lbW9yeTpcdFx0XHR3aWxsIGtlZXAgdHJhY2sgb2YgcHJldmlvdXMgdmFsdWVzIGFuZCB3aWxsIGNhbGwgYW55IGNhbGxiYWNrIGFkZGVkXG4gKlx0XHRcdFx0XHRhZnRlciB0aGUgbGlzdCBoYXMgYmVlbiBmaXJlZCByaWdodCBhd2F5IHdpdGggdGhlIGxhdGVzdCBcIm1lbW9yaXplZFwiXG4gKlx0XHRcdFx0XHR2YWx1ZXMgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0dW5pcXVlOlx0XHRcdHdpbGwgZW5zdXJlIGEgY2FsbGJhY2sgY2FuIG9ubHkgYmUgYWRkZWQgb25jZSAobm8gZHVwbGljYXRlIGluIHRoZSBsaXN0KVxuICpcbiAqXHRzdG9wT25GYWxzZTpcdGludGVycnVwdCBjYWxsaW5ncyB3aGVuIGEgY2FsbGJhY2sgcmV0dXJucyBmYWxzZVxuICpcbiAqL1xualF1ZXJ5LkNhbGxiYWNrcyA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdC8vIENvbnZlcnQgb3B0aW9ucyBmcm9tIFN0cmluZy1mb3JtYXR0ZWQgdG8gT2JqZWN0LWZvcm1hdHRlZCBpZiBuZWVkZWRcblx0Ly8gKHdlIGNoZWNrIGluIGNhY2hlIGZpcnN0KVxuXHRvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgP1xuXHRcdGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSA6XG5cdFx0alF1ZXJ5LmV4dGVuZCgge30sIG9wdGlvbnMgKTtcblxuXHR2YXIgLy8gRmxhZyB0byBrbm93IGlmIGxpc3QgaXMgY3VycmVudGx5IGZpcmluZ1xuXHRcdGZpcmluZyxcblxuXHRcdC8vIExhc3QgZmlyZSB2YWx1ZSBmb3Igbm9uLWZvcmdldHRhYmxlIGxpc3RzXG5cdFx0bWVtb3J5LFxuXG5cdFx0Ly8gRmxhZyB0byBrbm93IGlmIGxpc3Qgd2FzIGFscmVhZHkgZmlyZWRcblx0XHRmaXJlZCxcblxuXHRcdC8vIEZsYWcgdG8gcHJldmVudCBmaXJpbmdcblx0XHRsb2NrZWQsXG5cblx0XHQvLyBBY3R1YWwgY2FsbGJhY2sgbGlzdFxuXHRcdGxpc3QgPSBbXSxcblxuXHRcdC8vIFF1ZXVlIG9mIGV4ZWN1dGlvbiBkYXRhIGZvciByZXBlYXRhYmxlIGxpc3RzXG5cdFx0cXVldWUgPSBbXSxcblxuXHRcdC8vIEluZGV4IG9mIGN1cnJlbnRseSBmaXJpbmcgY2FsbGJhY2sgKG1vZGlmaWVkIGJ5IGFkZC9yZW1vdmUgYXMgbmVlZGVkKVxuXHRcdGZpcmluZ0luZGV4ID0gLTEsXG5cblx0XHQvLyBGaXJlIGNhbGxiYWNrc1xuXHRcdGZpcmUgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5mb3JjZSBzaW5nbGUtZmlyaW5nXG5cdFx0XHRsb2NrZWQgPSBsb2NrZWQgfHwgb3B0aW9ucy5vbmNlO1xuXG5cdFx0XHQvLyBFeGVjdXRlIGNhbGxiYWNrcyBmb3IgYWxsIHBlbmRpbmcgZXhlY3V0aW9ucyxcblx0XHRcdC8vIHJlc3BlY3RpbmcgZmlyaW5nSW5kZXggb3ZlcnJpZGVzIGFuZCBydW50aW1lIGNoYW5nZXNcblx0XHRcdGZpcmVkID0gZmlyaW5nID0gdHJ1ZTtcblx0XHRcdGZvciAoIDsgcXVldWUubGVuZ3RoOyBmaXJpbmdJbmRleCA9IC0xICkge1xuXHRcdFx0XHRtZW1vcnkgPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0XHR3aGlsZSAoICsrZmlyaW5nSW5kZXggPCBsaXN0Lmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdC8vIFJ1biBjYWxsYmFjayBhbmQgY2hlY2sgZm9yIGVhcmx5IHRlcm1pbmF0aW9uXG5cdFx0XHRcdFx0aWYgKCBsaXN0WyBmaXJpbmdJbmRleCBdLmFwcGx5KCBtZW1vcnlbIDAgXSwgbWVtb3J5WyAxIF0gKSA9PT0gZmFsc2UgJiZcblx0XHRcdFx0XHRcdG9wdGlvbnMuc3RvcE9uRmFsc2UgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEp1bXAgdG8gZW5kIGFuZCBmb3JnZXQgdGhlIGRhdGEgc28gLmFkZCBkb2Vzbid0IHJlLWZpcmVcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRcdFx0XHRtZW1vcnkgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yZ2V0IHRoZSBkYXRhIGlmIHdlJ3JlIGRvbmUgd2l0aCBpdFxuXHRcdFx0aWYgKCAhb3B0aW9ucy5tZW1vcnkgKSB7XG5cdFx0XHRcdG1lbW9yeSA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRmaXJpbmcgPSBmYWxzZTtcblxuXHRcdFx0Ly8gQ2xlYW4gdXAgaWYgd2UncmUgZG9uZSBmaXJpbmcgZm9yIGdvb2Rcblx0XHRcdGlmICggbG9ja2VkICkge1xuXG5cdFx0XHRcdC8vIEtlZXAgYW4gZW1wdHkgbGlzdCBpZiB3ZSBoYXZlIGRhdGEgZm9yIGZ1dHVyZSBhZGQgY2FsbHNcblx0XHRcdFx0aWYgKCBtZW1vcnkgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgdGhpcyBvYmplY3QgaXMgc3BlbnRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsaXN0ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvLyBBY3R1YWwgQ2FsbGJhY2tzIG9iamVjdFxuXHRcdHNlbGYgPSB7XG5cblx0XHRcdC8vIEFkZCBhIGNhbGxiYWNrIG9yIGEgY29sbGVjdGlvbiBvZiBjYWxsYmFja3MgdG8gdGhlIGxpc3Rcblx0XHRcdGFkZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblxuXHRcdFx0XHRcdC8vIElmIHdlIGhhdmUgbWVtb3J5IGZyb20gYSBwYXN0IHJ1biwgd2Ugc2hvdWxkIGZpcmUgYWZ0ZXIgYWRkaW5nXG5cdFx0XHRcdFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGggLSAxO1xuXHRcdFx0XHRcdFx0cXVldWUucHVzaCggbWVtb3J5ICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0KCBmdW5jdGlvbiBhZGQoIGFyZ3MgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggYXJncywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoICFvcHRpb25zLnVuaXF1ZSB8fCAhc2VsZi5oYXMoIGFyZyApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0bGlzdC5wdXNoKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGFyZyAmJiBhcmcubGVuZ3RoICYmIHRvVHlwZSggYXJnICkgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBJbnNwZWN0IHJlY3Vyc2l2ZWx5XG5cdFx0XHRcdFx0XHRcdFx0YWRkKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdH0gKSggYXJndW1lbnRzICk7XG5cblx0XHRcdFx0XHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFJlbW92ZSBhIGNhbGxiYWNrIGZyb20gdGhlIGxpc3Rcblx0XHRcdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0dmFyIGluZGV4O1xuXHRcdFx0XHRcdHdoaWxlICggKCBpbmRleCA9IGpRdWVyeS5pbkFycmF5KCBhcmcsIGxpc3QsIGluZGV4ICkgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0bGlzdC5zcGxpY2UoIGluZGV4LCAxICk7XG5cblx0XHRcdFx0XHRcdC8vIEhhbmRsZSBmaXJpbmcgaW5kZXhlc1xuXHRcdFx0XHRcdFx0aWYgKCBpbmRleCA8PSBmaXJpbmdJbmRleCApIHtcblx0XHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXgtLTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDaGVjayBpZiBhIGdpdmVuIGNhbGxiYWNrIGlzIGluIHRoZSBsaXN0LlxuXHRcdFx0Ly8gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHJldHVybiB3aGV0aGVyIG9yIG5vdCBsaXN0IGhhcyBjYWxsYmFja3MgYXR0YWNoZWQuXG5cdFx0XHRoYXM6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0cmV0dXJuIGZuID9cblx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggZm4sIGxpc3QgKSA+IC0xIDpcblx0XHRcdFx0XHRsaXN0Lmxlbmd0aCA+IDA7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZW1vdmUgYWxsIGNhbGxiYWNrcyBmcm9tIHRoZSBsaXN0XG5cdFx0XHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBEaXNhYmxlIC5maXJlIGFuZCAuYWRkXG5cdFx0XHQvLyBBYm9ydCBhbnkgY3VycmVudC9wZW5kaW5nIGV4ZWN1dGlvbnNcblx0XHRcdC8vIENsZWFyIGFsbCBjYWxsYmFja3MgYW5kIHZhbHVlc1xuXHRcdFx0ZGlzYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxvY2tlZCA9IHF1ZXVlID0gW107XG5cdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRkaXNhYmxlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhbGlzdDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIERpc2FibGUgLmZpcmVcblx0XHRcdC8vIEFsc28gZGlzYWJsZSAuYWRkIHVubGVzcyB3ZSBoYXZlIG1lbW9yeSAoc2luY2UgaXQgd291bGQgaGF2ZSBubyBlZmZlY3QpXG5cdFx0XHQvLyBBYm9ydCBhbnkgcGVuZGluZyBleGVjdXRpb25zXG5cdFx0XHRsb2NrOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bG9ja2VkID0gcXVldWUgPSBbXTtcblx0XHRcdFx0aWYgKCAhbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IG1lbW9yeSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0bG9ja2VkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICEhbG9ja2VkO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2FsbCBhbGwgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGNvbnRleHQgYW5kIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZVdpdGg6IGZ1bmN0aW9uKCBjb250ZXh0LCBhcmdzICkge1xuXHRcdFx0XHRpZiAoICFsb2NrZWQgKSB7XG5cdFx0XHRcdFx0YXJncyA9IGFyZ3MgfHwgW107XG5cdFx0XHRcdFx0YXJncyA9IFsgY29udGV4dCwgYXJncy5zbGljZSA/IGFyZ3Muc2xpY2UoKSA6IGFyZ3MgXTtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBhcmdzICk7XG5cdFx0XHRcdFx0aWYgKCAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIENhbGwgYWxsIHRoZSBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzXG5cdFx0XHRmaXJlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi5maXJlV2l0aCggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gVG8ga25vdyBpZiB0aGUgY2FsbGJhY2tzIGhhdmUgYWxyZWFkeSBiZWVuIGNhbGxlZCBhdCBsZWFzdCBvbmNlXG5cdFx0XHRmaXJlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWZpcmVkO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0cmV0dXJuIHNlbGY7XG59O1xuXG5cbmZ1bmN0aW9uIElkZW50aXR5KCB2ICkge1xuXHRyZXR1cm4gdjtcbn1cbmZ1bmN0aW9uIFRocm93ZXIoIGV4ICkge1xuXHR0aHJvdyBleDtcbn1cblxuZnVuY3Rpb24gYWRvcHRWYWx1ZSggdmFsdWUsIHJlc29sdmUsIHJlamVjdCwgbm9WYWx1ZSApIHtcblx0dmFyIG1ldGhvZDtcblxuXHR0cnkge1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIHByb21pc2UgYXNwZWN0IGZpcnN0IHRvIHByaXZpbGVnZSBzeW5jaHJvbm91cyBiZWhhdmlvclxuXHRcdGlmICggdmFsdWUgJiYgaXNGdW5jdGlvbiggKCBtZXRob2QgPSB2YWx1ZS5wcm9taXNlICkgKSApIHtcblx0XHRcdG1ldGhvZC5jYWxsKCB2YWx1ZSApLmRvbmUoIHJlc29sdmUgKS5mYWlsKCByZWplY3QgKTtcblxuXHRcdC8vIE90aGVyIHRoZW5hYmxlc1xuXHRcdH0gZWxzZSBpZiAoIHZhbHVlICYmIGlzRnVuY3Rpb24oICggbWV0aG9kID0gdmFsdWUudGhlbiApICkgKSB7XG5cdFx0XHRtZXRob2QuY2FsbCggdmFsdWUsIHJlc29sdmUsIHJlamVjdCApO1xuXG5cdFx0Ly8gT3RoZXIgbm9uLXRoZW5hYmxlc1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIENvbnRyb2wgYHJlc29sdmVgIGFyZ3VtZW50cyBieSBsZXR0aW5nIEFycmF5I3NsaWNlIGNhc3QgYm9vbGVhbiBgbm9WYWx1ZWAgdG8gaW50ZWdlcjpcblx0XHRcdC8vICogZmFsc2U6IFsgdmFsdWUgXS5zbGljZSggMCApID0+IHJlc29sdmUoIHZhbHVlIClcblx0XHRcdC8vICogdHJ1ZTogWyB2YWx1ZSBdLnNsaWNlKCAxICkgPT4gcmVzb2x2ZSgpXG5cdFx0XHRyZXNvbHZlLmFwcGx5KCB1bmRlZmluZWQsIFsgdmFsdWUgXS5zbGljZSggbm9WYWx1ZSApICk7XG5cdFx0fVxuXG5cdC8vIEZvciBQcm9taXNlcy9BKywgY29udmVydCBleGNlcHRpb25zIGludG8gcmVqZWN0aW9uc1xuXHQvLyBTaW5jZSBqUXVlcnkud2hlbiBkb2Vzbid0IHVud3JhcCB0aGVuYWJsZXMsIHdlIGNhbiBza2lwIHRoZSBleHRyYSBjaGVja3MgYXBwZWFyaW5nIGluXG5cdC8vIERlZmVycmVkI3RoZW4gdG8gY29uZGl0aW9uYWxseSBzdXBwcmVzcyByZWplY3Rpb24uXG5cdH0gY2F0Y2ggKCB2YWx1ZSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIG9ubHlcblx0XHQvLyBTdHJpY3QgbW9kZSBmdW5jdGlvbnMgaW52b2tlZCB3aXRob3V0IC5jYWxsLy5hcHBseSBnZXQgZ2xvYmFsLW9iamVjdCBjb250ZXh0XG5cdFx0cmVqZWN0LmFwcGx5KCB1bmRlZmluZWQsIFsgdmFsdWUgXSApO1xuXHR9XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHREZWZlcnJlZDogZnVuY3Rpb24oIGZ1bmMgKSB7XG5cdFx0dmFyIHR1cGxlcyA9IFtcblxuXHRcdFx0XHQvLyBhY3Rpb24sIGFkZCBsaXN0ZW5lciwgY2FsbGJhY2tzLFxuXHRcdFx0XHQvLyAuLi4gLnRoZW4gaGFuZGxlcnMsIGFyZ3VtZW50IGluZGV4LCBbZmluYWwgc3RhdGVdXG5cdFx0XHRcdFsgXCJub3RpZnlcIiwgXCJwcm9ncmVzc1wiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJtZW1vcnlcIiApLCAyIF0sXG5cdFx0XHRcdFsgXCJyZXNvbHZlXCIsIFwiZG9uZVwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgMCwgXCJyZXNvbHZlZFwiIF0sXG5cdFx0XHRcdFsgXCJyZWplY3RcIiwgXCJmYWlsXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCAxLCBcInJlamVjdGVkXCIgXVxuXHRcdFx0XSxcblx0XHRcdHN0YXRlID0gXCJwZW5kaW5nXCIsXG5cdFx0XHRwcm9taXNlID0ge1xuXHRcdFx0XHRzdGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHN0YXRlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRhbHdheXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGRlZmVycmVkLmRvbmUoIGFyZ3VtZW50cyApLmZhaWwoIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRcImNhdGNoXCI6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcHJvbWlzZS50aGVuKCBudWxsLCBmbiApO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIEtlZXAgcGlwZSBmb3IgYmFjay1jb21wYXRcblx0XHRcdFx0cGlwZTogZnVuY3Rpb24oIC8qIGZuRG9uZSwgZm5GYWlsLCBmblByb2dyZXNzICovICkge1xuXHRcdFx0XHRcdHZhciBmbnMgPSBhcmd1bWVudHM7XG5cblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggX2ksIHR1cGxlICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIE1hcCB0dXBsZXMgKHByb2dyZXNzLCBkb25lLCBmYWlsKSB0byBhcmd1bWVudHMgKGRvbmUsIGZhaWwsIHByb2dyZXNzKVxuXHRcdFx0XHRcdFx0XHR2YXIgZm4gPSBpc0Z1bmN0aW9uKCBmbnNbIHR1cGxlWyA0IF0gXSApICYmIGZuc1sgdHVwbGVbIDQgXSBdO1xuXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLnByb2dyZXNzKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLm5vdGlmeSB9KVxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5kb25lKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlc29sdmUgfSlcblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQuZmFpbChmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5yZWplY3QgfSlcblx0XHRcdFx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAxIF0gXSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHJldHVybmVkID0gZm4gJiYgZm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdFx0XHRcdGlmICggcmV0dXJuZWQgJiYgaXNGdW5jdGlvbiggcmV0dXJuZWQucHJvbWlzZSApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQucHJvbWlzZSgpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5wcm9ncmVzcyggbmV3RGVmZXIubm90aWZ5IClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmRvbmUoIG5ld0RlZmVyLnJlc29sdmUgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZmFpbCggbmV3RGVmZXIucmVqZWN0ICk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXShcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0Zm4gPyBbIHJldHVybmVkIF0gOiBhcmd1bWVudHNcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHRmbnMgPSBudWxsO1xuXHRcdFx0XHRcdH0gKS5wcm9taXNlKCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHRoZW46IGZ1bmN0aW9uKCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgb25Qcm9ncmVzcyApIHtcblx0XHRcdFx0XHR2YXIgbWF4RGVwdGggPSAwO1xuXHRcdFx0XHRcdGZ1bmN0aW9uIHJlc29sdmUoIGRlcHRoLCBkZWZlcnJlZCwgaGFuZGxlciwgc3BlY2lhbCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIHJldHVybmVkLCB0aGVuO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuM1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTlcblx0XHRcdFx0XHRcdFx0XHRcdC8vIElnbm9yZSBkb3VibGUtcmVzb2x1dGlvbiBhdHRlbXB0c1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCA8IG1heERlcHRoICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkID0gaGFuZGxlci5hcHBseSggdGhhdCwgYXJncyApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4xXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC00OFxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCByZXR1cm5lZCA9PT0gZGVmZXJyZWQucHJvbWlzZSgpICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCBcIlRoZW5hYmxlIHNlbGYtcmVzb2x1dGlvblwiICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb25zIDIuMy4zLjEsIDMuNVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTRcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTc1XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBSZXRyaWV2ZSBgdGhlbmAgb25seSBvbmNlXG5cdFx0XHRcdFx0XHRcdFx0XHR0aGVuID0gcmV0dXJuZWQgJiZcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy40XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTY0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgY2hlY2sgb2JqZWN0cyBhbmQgZnVuY3Rpb25zIGZvciB0aGVuYWJpbGl0eVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQoIHR5cGVvZiByZXR1cm5lZCA9PT0gXCJvYmplY3RcIiB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGVvZiByZXR1cm5lZCA9PT0gXCJmdW5jdGlvblwiICkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQudGhlbjtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGEgcmV0dXJuZWQgdGhlbmFibGVcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggaXNGdW5jdGlvbiggdGhlbiApICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFNwZWNpYWwgcHJvY2Vzc29ycyAobm90aWZ5KSBqdXN0IHdhaXQgZm9yIHJlc29sdXRpb25cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoZW4uY2FsbChcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE5vcm1hbCBwcm9jZXNzb3JzIChyZXNvbHZlKSBhbHNvIGhvb2sgaW50byBwcm9ncmVzc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gLi4uYW5kIGRpc3JlZ2FyZCBvbGRlciByZXNvbHV0aW9uIHZhbHVlc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1heERlcHRoKys7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGVuLmNhbGwoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgVGhyb3dlciwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBIYW5kbGUgYWxsIG90aGVyIHJldHVybmVkIHZhbHVlc1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IHN1YnN0aXR1dGUgaGFuZGxlcnMgcGFzcyBvbiBjb250ZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGhhbmRsZXIgIT09IElkZW50aXR5ICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoYXQgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXJncyA9IFsgcmV0dXJuZWQgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFByb2Nlc3MgdGhlIHZhbHVlKHMpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIERlZmF1bHQgcHJvY2VzcyBpcyByZXNvbHZlXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCggc3BlY2lhbCB8fCBkZWZlcnJlZC5yZXNvbHZlV2l0aCApKCB0aGF0LCBhcmdzICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgbm9ybWFsIHByb2Nlc3NvcnMgKHJlc29sdmUpIGNhdGNoIGFuZCByZWplY3QgZXhjZXB0aW9uc1xuXHRcdFx0XHRcdFx0XHRcdHByb2Nlc3MgPSBzcGVjaWFsID9cblx0XHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3cgOlxuXHRcdFx0XHRcdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdygpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayggZSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cHJvY2Vzcy5zdGFja1RyYWNlICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjQuMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTYxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gSWdub3JlIHBvc3QtcmVzb2x1dGlvbiBleGNlcHRpb25zXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCArIDEgPj0gbWF4RGVwdGggKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgc3Vic3RpdHV0ZSBoYW5kbGVycyBwYXNzIG9uIGNvbnRleHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBoYW5kbGVyICE9PSBUaHJvd2VyICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGF0ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhcmdzID0gWyBlIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIHRoYXQsIGFyZ3MgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjFcblx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTdcblx0XHRcdFx0XHRcdFx0Ly8gUmUtcmVzb2x2ZSBwcm9taXNlcyBpbW1lZGlhdGVseSB0byBkb2RnZSBmYWxzZSByZWplY3Rpb24gZnJvbVxuXHRcdFx0XHRcdFx0XHQvLyBzdWJzZXF1ZW50IGVycm9yc1xuXHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoICkge1xuXHRcdFx0XHRcdFx0XHRcdHByb2Nlc3MoKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIENhbGwgYW4gb3B0aW9uYWwgaG9vayB0byByZWNvcmQgdGhlIHN0YWNrLCBpbiBjYXNlIG9mIGV4Y2VwdGlvblxuXHRcdFx0XHRcdFx0XHRcdC8vIHNpbmNlIGl0J3Mgb3RoZXJ3aXNlIGxvc3Qgd2hlbiBleGVjdXRpb24gZ29lcyBhc3luY1xuXHRcdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHByb2Nlc3Muc3RhY2tUcmFjZSA9IGpRdWVyeS5EZWZlcnJlZC5nZXRTdGFja0hvb2soKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQoIHByb2Nlc3MgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cblx0XHRcdFx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0aXNGdW5jdGlvbiggb25Qcm9ncmVzcyApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uUHJvZ3Jlc3MgOlxuXHRcdFx0XHRcdFx0XHRcdFx0SWRlbnRpdHksXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIubm90aWZ5V2l0aFxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAxIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRpc0Z1bmN0aW9uKCBvbkZ1bGZpbGxlZCApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uRnVsZmlsbGVkIDpcblx0XHRcdFx0XHRcdFx0XHRcdElkZW50aXR5XG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMiBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0aXNGdW5jdGlvbiggb25SZWplY3RlZCApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uUmVqZWN0ZWQgOlxuXHRcdFx0XHRcdFx0XHRcdFx0VGhyb3dlclxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH0gKS5wcm9taXNlKCk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gR2V0IGEgcHJvbWlzZSBmb3IgdGhpcyBkZWZlcnJlZFxuXHRcdFx0XHQvLyBJZiBvYmogaXMgcHJvdmlkZWQsIHRoZSBwcm9taXNlIGFzcGVjdCBpcyBhZGRlZCB0byB0aGUgb2JqZWN0XG5cdFx0XHRcdHByb21pc2U6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9iaiAhPSBudWxsID8galF1ZXJ5LmV4dGVuZCggb2JqLCBwcm9taXNlICkgOiBwcm9taXNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVmZXJyZWQgPSB7fTtcblxuXHRcdC8vIEFkZCBsaXN0LXNwZWNpZmljIG1ldGhvZHNcblx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cdFx0XHR2YXIgbGlzdCA9IHR1cGxlWyAyIF0sXG5cdFx0XHRcdHN0YXRlU3RyaW5nID0gdHVwbGVbIDUgXTtcblxuXHRcdFx0Ly8gcHJvbWlzZS5wcm9ncmVzcyA9IGxpc3QuYWRkXG5cdFx0XHQvLyBwcm9taXNlLmRvbmUgPSBsaXN0LmFkZFxuXHRcdFx0Ly8gcHJvbWlzZS5mYWlsID0gbGlzdC5hZGRcblx0XHRcdHByb21pc2VbIHR1cGxlWyAxIF0gXSA9IGxpc3QuYWRkO1xuXG5cdFx0XHQvLyBIYW5kbGUgc3RhdGVcblx0XHRcdGlmICggc3RhdGVTdHJpbmcgKSB7XG5cdFx0XHRcdGxpc3QuYWRkKFxuXHRcdFx0XHRcdGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0XHQvLyBzdGF0ZSA9IFwicmVzb2x2ZWRcIiAoaS5lLiwgZnVsZmlsbGVkKVxuXHRcdFx0XHRcdFx0Ly8gc3RhdGUgPSBcInJlamVjdGVkXCJcblx0XHRcdFx0XHRcdHN0YXRlID0gc3RhdGVTdHJpbmc7XG5cdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdC8vIHJlamVjdGVkX2NhbGxiYWNrcy5kaXNhYmxlXG5cdFx0XHRcdFx0Ly8gZnVsZmlsbGVkX2NhbGxiYWNrcy5kaXNhYmxlXG5cdFx0XHRcdFx0dHVwbGVzWyAzIC0gaSBdWyAyIF0uZGlzYWJsZSxcblxuXHRcdFx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmRpc2FibGVcblx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuZGlzYWJsZVxuXHRcdFx0XHRcdHR1cGxlc1sgMyAtIGkgXVsgMyBdLmRpc2FibGUsXG5cblx0XHRcdFx0XHQvLyBwcm9ncmVzc19jYWxsYmFja3MubG9ja1xuXHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAyIF0ubG9jayxcblxuXHRcdFx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmxvY2tcblx0XHRcdFx0XHR0dXBsZXNbIDAgXVsgMyBdLmxvY2tcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMuZmlyZVxuXHRcdFx0Ly8gZnVsZmlsbGVkX2hhbmRsZXJzLmZpcmVcblx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmZpcmVcblx0XHRcdGxpc3QuYWRkKCB0dXBsZVsgMyBdLmZpcmUgKTtcblxuXHRcdFx0Ly8gZGVmZXJyZWQubm90aWZ5ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLm5vdGlmeVdpdGgoLi4uKSB9XG5cdFx0XHQvLyBkZWZlcnJlZC5yZXNvbHZlID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlc29sdmVXaXRoKC4uLikgfVxuXHRcdFx0Ly8gZGVmZXJyZWQucmVqZWN0ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlamVjdFdpdGgoLi4uKSB9XG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSggdGhpcyA9PT0gZGVmZXJyZWQgPyB1bmRlZmluZWQgOiB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBkZWZlcnJlZC5ub3RpZnlXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0Ly8gZGVmZXJyZWQucmVzb2x2ZVdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHQvLyBkZWZlcnJlZC5yZWplY3RXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdID0gbGlzdC5maXJlV2l0aDtcblx0XHR9ICk7XG5cblx0XHQvLyBNYWtlIHRoZSBkZWZlcnJlZCBhIHByb21pc2Vcblx0XHRwcm9taXNlLnByb21pc2UoIGRlZmVycmVkICk7XG5cblx0XHQvLyBDYWxsIGdpdmVuIGZ1bmMgaWYgYW55XG5cdFx0aWYgKCBmdW5jICkge1xuXHRcdFx0ZnVuYy5jYWxsKCBkZWZlcnJlZCwgZGVmZXJyZWQgKTtcblx0XHR9XG5cblx0XHQvLyBBbGwgZG9uZSFcblx0XHRyZXR1cm4gZGVmZXJyZWQ7XG5cdH0sXG5cblx0Ly8gRGVmZXJyZWQgaGVscGVyXG5cdHdoZW46IGZ1bmN0aW9uKCBzaW5nbGVWYWx1ZSApIHtcblx0XHR2YXJcblxuXHRcdFx0Ly8gY291bnQgb2YgdW5jb21wbGV0ZWQgc3Vib3JkaW5hdGVzXG5cdFx0XHRyZW1haW5pbmcgPSBhcmd1bWVudHMubGVuZ3RoLFxuXG5cdFx0XHQvLyBjb3VudCBvZiB1bnByb2Nlc3NlZCBhcmd1bWVudHNcblx0XHRcdGkgPSByZW1haW5pbmcsXG5cblx0XHRcdC8vIHN1Ym9yZGluYXRlIGZ1bGZpbGxtZW50IGRhdGFcblx0XHRcdHJlc29sdmVDb250ZXh0cyA9IEFycmF5KCBpICksXG5cdFx0XHRyZXNvbHZlVmFsdWVzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICksXG5cblx0XHRcdC8vIHRoZSBwcmltYXJ5IERlZmVycmVkXG5cdFx0XHRwcmltYXJ5ID0galF1ZXJ5LkRlZmVycmVkKCksXG5cblx0XHRcdC8vIHN1Ym9yZGluYXRlIGNhbGxiYWNrIGZhY3Rvcnlcblx0XHRcdHVwZGF0ZUZ1bmMgPSBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXNvbHZlQ29udGV4dHNbIGkgXSA9IHRoaXM7XG5cdFx0XHRcdFx0cmVzb2x2ZVZhbHVlc1sgaSBdID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSA6IHZhbHVlO1xuXHRcdFx0XHRcdGlmICggISggLS1yZW1haW5pbmcgKSApIHtcblx0XHRcdFx0XHRcdHByaW1hcnkucmVzb2x2ZVdpdGgoIHJlc29sdmVDb250ZXh0cywgcmVzb2x2ZVZhbHVlcyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH07XG5cblx0XHQvLyBTaW5nbGUtIGFuZCBlbXB0eSBhcmd1bWVudHMgYXJlIGFkb3B0ZWQgbGlrZSBQcm9taXNlLnJlc29sdmVcblx0XHRpZiAoIHJlbWFpbmluZyA8PSAxICkge1xuXHRcdFx0YWRvcHRWYWx1ZSggc2luZ2xlVmFsdWUsIHByaW1hcnkuZG9uZSggdXBkYXRlRnVuYyggaSApICkucmVzb2x2ZSwgcHJpbWFyeS5yZWplY3QsXG5cdFx0XHRcdCFyZW1haW5pbmcgKTtcblxuXHRcdFx0Ly8gVXNlIC50aGVuKCkgdG8gdW53cmFwIHNlY29uZGFyeSB0aGVuYWJsZXMgKGNmLiBnaC0zMDAwKVxuXHRcdFx0aWYgKCBwcmltYXJ5LnN0YXRlKCkgPT09IFwicGVuZGluZ1wiIHx8XG5cdFx0XHRcdGlzRnVuY3Rpb24oIHJlc29sdmVWYWx1ZXNbIGkgXSAmJiByZXNvbHZlVmFsdWVzWyBpIF0udGhlbiApICkge1xuXG5cdFx0XHRcdHJldHVybiBwcmltYXJ5LnRoZW4oKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBNdWx0aXBsZSBhcmd1bWVudHMgYXJlIGFnZ3JlZ2F0ZWQgbGlrZSBQcm9taXNlLmFsbCBhcnJheSBlbGVtZW50c1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0YWRvcHRWYWx1ZSggcmVzb2x2ZVZhbHVlc1sgaSBdLCB1cGRhdGVGdW5jKCBpICksIHByaW1hcnkucmVqZWN0ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHByaW1hcnkucHJvbWlzZSgpO1xuXHR9XG59ICk7XG5cblxuLy8gVGhlc2UgdXN1YWxseSBpbmRpY2F0ZSBhIHByb2dyYW1tZXIgbWlzdGFrZSBkdXJpbmcgZGV2ZWxvcG1lbnQsXG4vLyB3YXJuIGFib3V0IHRoZW0gQVNBUCByYXRoZXIgdGhhbiBzd2FsbG93aW5nIHRoZW0gYnkgZGVmYXVsdC5cbnZhciByZXJyb3JOYW1lcyA9IC9eKEV2YWx8SW50ZXJuYWx8UmFuZ2V8UmVmZXJlbmNlfFN5bnRheHxUeXBlfFVSSSlFcnJvciQvO1xuXG5qUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayA9IGZ1bmN0aW9uKCBlcnJvciwgc3RhY2sgKSB7XG5cblx0Ly8gU3VwcG9ydDogSUUgOCAtIDkgb25seVxuXHQvLyBDb25zb2xlIGV4aXN0cyB3aGVuIGRldiB0b29scyBhcmUgb3Blbiwgd2hpY2ggY2FuIGhhcHBlbiBhdCBhbnkgdGltZVxuXHRpZiAoIHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5jb25zb2xlLndhcm4gJiYgZXJyb3IgJiYgcmVycm9yTmFtZXMudGVzdCggZXJyb3IubmFtZSApICkge1xuXHRcdHdpbmRvdy5jb25zb2xlLndhcm4oIFwialF1ZXJ5LkRlZmVycmVkIGV4Y2VwdGlvbjogXCIgKyBlcnJvci5tZXNzYWdlLCBlcnJvci5zdGFjaywgc3RhY2sgKTtcblx0fVxufTtcblxuXG5cblxualF1ZXJ5LnJlYWR5RXhjZXB0aW9uID0gZnVuY3Rpb24oIGVycm9yICkge1xuXHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gKTtcbn07XG5cblxuXG5cbi8vIFRoZSBkZWZlcnJlZCB1c2VkIG9uIERPTSByZWFkeVxudmFyIHJlYWR5TGlzdCA9IGpRdWVyeS5EZWZlcnJlZCgpO1xuXG5qUXVlcnkuZm4ucmVhZHkgPSBmdW5jdGlvbiggZm4gKSB7XG5cblx0cmVhZHlMaXN0XG5cdFx0LnRoZW4oIGZuIClcblxuXHRcdC8vIFdyYXAgalF1ZXJ5LnJlYWR5RXhjZXB0aW9uIGluIGEgZnVuY3Rpb24gc28gdGhhdCB0aGUgbG9va3VwXG5cdFx0Ly8gaGFwcGVucyBhdCB0aGUgdGltZSBvZiBlcnJvciBoYW5kbGluZyBpbnN0ZWFkIG9mIGNhbGxiYWNrXG5cdFx0Ly8gcmVnaXN0cmF0aW9uLlxuXHRcdC5jYXRjaCggZnVuY3Rpb24oIGVycm9yICkge1xuXHRcdFx0alF1ZXJ5LnJlYWR5RXhjZXB0aW9uKCBlcnJvciApO1xuXHRcdH0gKTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBJcyB0aGUgRE9NIHJlYWR5IHRvIGJlIHVzZWQ/IFNldCB0byB0cnVlIG9uY2UgaXQgb2NjdXJzLlxuXHRpc1JlYWR5OiBmYWxzZSxcblxuXHQvLyBBIGNvdW50ZXIgdG8gdHJhY2sgaG93IG1hbnkgaXRlbXMgdG8gd2FpdCBmb3IgYmVmb3JlXG5cdC8vIHRoZSByZWFkeSBldmVudCBmaXJlcy4gU2VlICM2NzgxXG5cdHJlYWR5V2FpdDogMSxcblxuXHQvLyBIYW5kbGUgd2hlbiB0aGUgRE9NIGlzIHJlYWR5XG5cdHJlYWR5OiBmdW5jdGlvbiggd2FpdCApIHtcblxuXHRcdC8vIEFib3J0IGlmIHRoZXJlIGFyZSBwZW5kaW5nIGhvbGRzIG9yIHdlJ3JlIGFscmVhZHkgcmVhZHlcblx0XHRpZiAoIHdhaXQgPT09IHRydWUgPyAtLWpRdWVyeS5yZWFkeVdhaXQgOiBqUXVlcnkuaXNSZWFkeSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBSZW1lbWJlciB0aGF0IHRoZSBET00gaXMgcmVhZHlcblx0XHRqUXVlcnkuaXNSZWFkeSA9IHRydWU7XG5cblx0XHQvLyBJZiBhIG5vcm1hbCBET00gUmVhZHkgZXZlbnQgZmlyZWQsIGRlY3JlbWVudCwgYW5kIHdhaXQgaWYgbmVlZCBiZVxuXHRcdGlmICggd2FpdCAhPT0gdHJ1ZSAmJiAtLWpRdWVyeS5yZWFkeVdhaXQgPiAwICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoZXJlIGFyZSBmdW5jdGlvbnMgYm91bmQsIHRvIGV4ZWN1dGVcblx0XHRyZWFkeUxpc3QucmVzb2x2ZVdpdGgoIGRvY3VtZW50LCBbIGpRdWVyeSBdICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LnJlYWR5LnRoZW4gPSByZWFkeUxpc3QudGhlbjtcblxuLy8gVGhlIHJlYWR5IGV2ZW50IGhhbmRsZXIgYW5kIHNlbGYgY2xlYW51cCBtZXRob2RcbmZ1bmN0aW9uIGNvbXBsZXRlZCgpIHtcblx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCApO1xuXHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCApO1xuXHRqUXVlcnkucmVhZHkoKTtcbn1cblxuLy8gQ2F0Y2ggY2FzZXMgd2hlcmUgJChkb2N1bWVudCkucmVhZHkoKSBpcyBjYWxsZWRcbi8vIGFmdGVyIHRoZSBicm93c2VyIGV2ZW50IGhhcyBhbHJlYWR5IG9jY3VycmVkLlxuLy8gU3VwcG9ydDogSUUgPD05IC0gMTAgb25seVxuLy8gT2xkZXIgSUUgc29tZXRpbWVzIHNpZ25hbHMgXCJpbnRlcmFjdGl2ZVwiIHRvbyBzb29uXG5pZiAoIGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIiB8fFxuXHQoIGRvY3VtZW50LnJlYWR5U3RhdGUgIT09IFwibG9hZGluZ1wiICYmICFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGwgKSApIHtcblxuXHQvLyBIYW5kbGUgaXQgYXN5bmNocm9ub3VzbHkgdG8gYWxsb3cgc2NyaXB0cyB0aGUgb3Bwb3J0dW5pdHkgdG8gZGVsYXkgcmVhZHlcblx0d2luZG93LnNldFRpbWVvdXQoIGpRdWVyeS5yZWFkeSApO1xuXG59IGVsc2Uge1xuXG5cdC8vIFVzZSB0aGUgaGFuZHkgZXZlbnQgY2FsbGJhY2tcblx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCApO1xuXG5cdC8vIEEgZmFsbGJhY2sgdG8gd2luZG93Lm9ubG9hZCwgdGhhdCB3aWxsIGFsd2F5cyB3b3JrXG5cdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG59XG5cblxuXG5cbi8vIE11bHRpZnVuY3Rpb25hbCBtZXRob2QgdG8gZ2V0IGFuZCBzZXQgdmFsdWVzIG9mIGEgY29sbGVjdGlvblxuLy8gVGhlIHZhbHVlL3MgY2FuIG9wdGlvbmFsbHkgYmUgZXhlY3V0ZWQgaWYgaXQncyBhIGZ1bmN0aW9uXG52YXIgYWNjZXNzID0gZnVuY3Rpb24oIGVsZW1zLCBmbiwga2V5LCB2YWx1ZSwgY2hhaW5hYmxlLCBlbXB0eUdldCwgcmF3ICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gZWxlbXMubGVuZ3RoLFxuXHRcdGJ1bGsgPSBrZXkgPT0gbnVsbDtcblxuXHQvLyBTZXRzIG1hbnkgdmFsdWVzXG5cdGlmICggdG9UeXBlKCBrZXkgKSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXHRcdGZvciAoIGkgaW4ga2V5ICkge1xuXHRcdFx0YWNjZXNzKCBlbGVtcywgZm4sIGksIGtleVsgaSBdLCB0cnVlLCBlbXB0eUdldCwgcmF3ICk7XG5cdFx0fVxuXG5cdC8vIFNldHMgb25lIHZhbHVlXG5cdH0gZWxzZSBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblxuXHRcdGlmICggIWlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyYXcgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICggYnVsayApIHtcblxuXHRcdFx0Ly8gQnVsayBvcGVyYXRpb25zIHJ1biBhZ2FpbnN0IHRoZSBlbnRpcmUgc2V0XG5cdFx0XHRpZiAoIHJhdyApIHtcblx0XHRcdFx0Zm4uY2FsbCggZWxlbXMsIHZhbHVlICk7XG5cdFx0XHRcdGZuID0gbnVsbDtcblxuXHRcdFx0Ly8gLi4uZXhjZXB0IHdoZW4gZXhlY3V0aW5nIGZ1bmN0aW9uIHZhbHVlc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YnVsayA9IGZuO1xuXHRcdFx0XHRmbiA9IGZ1bmN0aW9uKCBlbGVtLCBfa2V5LCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gYnVsay5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdmFsdWUgKTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIGZuICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdGZuKFxuXHRcdFx0XHRcdGVsZW1zWyBpIF0sIGtleSwgcmF3ID9cblx0XHRcdFx0XHRcdHZhbHVlIDpcblx0XHRcdFx0XHRcdHZhbHVlLmNhbGwoIGVsZW1zWyBpIF0sIGksIGZuKCBlbGVtc1sgaSBdLCBrZXkgKSApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBjaGFpbmFibGUgKSB7XG5cdFx0cmV0dXJuIGVsZW1zO1xuXHR9XG5cblx0Ly8gR2V0c1xuXHRpZiAoIGJ1bGsgKSB7XG5cdFx0cmV0dXJuIGZuLmNhbGwoIGVsZW1zICk7XG5cdH1cblxuXHRyZXR1cm4gbGVuID8gZm4oIGVsZW1zWyAwIF0sIGtleSApIDogZW1wdHlHZXQ7XG59O1xuXG5cbi8vIE1hdGNoZXMgZGFzaGVkIHN0cmluZyBmb3IgY2FtZWxpemluZ1xudmFyIHJtc1ByZWZpeCA9IC9eLW1zLS8sXG5cdHJkYXNoQWxwaGEgPSAvLShbYS16XSkvZztcblxuLy8gVXNlZCBieSBjYW1lbENhc2UgYXMgY2FsbGJhY2sgdG8gcmVwbGFjZSgpXG5mdW5jdGlvbiBmY2FtZWxDYXNlKCBfYWxsLCBsZXR0ZXIgKSB7XG5cdHJldHVybiBsZXR0ZXIudG9VcHBlckNhc2UoKTtcbn1cblxuLy8gQ29udmVydCBkYXNoZWQgdG8gY2FtZWxDYXNlOyB1c2VkIGJ5IHRoZSBjc3MgYW5kIGRhdGEgbW9kdWxlc1xuLy8gU3VwcG9ydDogSUUgPD05IC0gMTEsIEVkZ2UgMTIgLSAxNVxuLy8gTWljcm9zb2Z0IGZvcmdvdCB0byBodW1wIHRoZWlyIHZlbmRvciBwcmVmaXggKCM5NTcyKVxuZnVuY3Rpb24gY2FtZWxDYXNlKCBzdHJpbmcgKSB7XG5cdHJldHVybiBzdHJpbmcucmVwbGFjZSggcm1zUHJlZml4LCBcIm1zLVwiICkucmVwbGFjZSggcmRhc2hBbHBoYSwgZmNhbWVsQ2FzZSApO1xufVxudmFyIGFjY2VwdERhdGEgPSBmdW5jdGlvbiggb3duZXIgKSB7XG5cblx0Ly8gQWNjZXB0cyBvbmx5OlxuXHQvLyAgLSBOb2RlXG5cdC8vICAgIC0gTm9kZS5FTEVNRU5UX05PREVcblx0Ly8gICAgLSBOb2RlLkRPQ1VNRU5UX05PREVcblx0Ly8gIC0gT2JqZWN0XG5cdC8vICAgIC0gQW55XG5cdHJldHVybiBvd25lci5ub2RlVHlwZSA9PT0gMSB8fCBvd25lci5ub2RlVHlwZSA9PT0gOSB8fCAhKCArb3duZXIubm9kZVR5cGUgKTtcbn07XG5cblxuXG5cbmZ1bmN0aW9uIERhdGEoKSB7XG5cdHRoaXMuZXhwYW5kbyA9IGpRdWVyeS5leHBhbmRvICsgRGF0YS51aWQrKztcbn1cblxuRGF0YS51aWQgPSAxO1xuXG5EYXRhLnByb3RvdHlwZSA9IHtcblxuXHRjYWNoZTogZnVuY3Rpb24oIG93bmVyICkge1xuXG5cdFx0Ly8gQ2hlY2sgaWYgdGhlIG93bmVyIG9iamVjdCBhbHJlYWR5IGhhcyBhIGNhY2hlXG5cdFx0dmFyIHZhbHVlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXG5cdFx0Ly8gSWYgbm90LCBjcmVhdGUgb25lXG5cdFx0aWYgKCAhdmFsdWUgKSB7XG5cdFx0XHR2YWx1ZSA9IHt9O1xuXG5cdFx0XHQvLyBXZSBjYW4gYWNjZXB0IGRhdGEgZm9yIG5vbi1lbGVtZW50IG5vZGVzIGluIG1vZGVybiBicm93c2Vycyxcblx0XHRcdC8vIGJ1dCB3ZSBzaG91bGQgbm90LCBzZWUgIzgzMzUuXG5cdFx0XHQvLyBBbHdheXMgcmV0dXJuIGFuIGVtcHR5IG9iamVjdC5cblx0XHRcdGlmICggYWNjZXB0RGF0YSggb3duZXIgKSApIHtcblxuXHRcdFx0XHQvLyBJZiBpdCBpcyBhIG5vZGUgdW5saWtlbHkgdG8gYmUgc3RyaW5naWZ5LWVkIG9yIGxvb3BlZCBvdmVyXG5cdFx0XHRcdC8vIHVzZSBwbGFpbiBhc3NpZ25tZW50XG5cdFx0XHRcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XG5cdFx0XHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdmFsdWU7XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHNlY3VyZSBpdCBpbiBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5XG5cdFx0XHRcdC8vIGNvbmZpZ3VyYWJsZSBtdXN0IGJlIHRydWUgdG8gYWxsb3cgdGhlIHByb3BlcnR5IHRvIGJlXG5cdFx0XHRcdC8vIGRlbGV0ZWQgd2hlbiBkYXRhIGlzIHJlbW92ZWRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIG93bmVyLCB0aGlzLmV4cGFuZG8sIHtcblx0XHRcdFx0XHRcdHZhbHVlOiB2YWx1ZSxcblx0XHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB2YWx1ZTtcblx0fSxcblx0c2V0OiBmdW5jdGlvbiggb3duZXIsIGRhdGEsIHZhbHVlICkge1xuXHRcdHZhciBwcm9wLFxuXHRcdFx0Y2FjaGUgPSB0aGlzLmNhY2hlKCBvd25lciApO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCBrZXksIHZhbHVlIF0gYXJnc1xuXHRcdC8vIEFsd2F5cyB1c2UgY2FtZWxDYXNlIGtleSAoZ2gtMjI1Nylcblx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Y2FjaGVbIGNhbWVsQ2FzZSggZGF0YSApIF0gPSB2YWx1ZTtcblxuXHRcdC8vIEhhbmRsZTogWyBvd25lciwgeyBwcm9wZXJ0aWVzIH0gXSBhcmdzXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gQ29weSB0aGUgcHJvcGVydGllcyBvbmUtYnktb25lIHRvIHRoZSBjYWNoZSBvYmplY3Rcblx0XHRcdGZvciAoIHByb3AgaW4gZGF0YSApIHtcblx0XHRcdFx0Y2FjaGVbIGNhbWVsQ2FzZSggcHJvcCApIF0gPSBkYXRhWyBwcm9wIF07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBjYWNoZTtcblx0fSxcblx0Z2V0OiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcblx0XHRyZXR1cm4ga2V5ID09PSB1bmRlZmluZWQgP1xuXHRcdFx0dGhpcy5jYWNoZSggb3duZXIgKSA6XG5cblx0XHRcdC8vIEFsd2F5cyB1c2UgY2FtZWxDYXNlIGtleSAoZ2gtMjI1Nylcblx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSAmJiBvd25lclsgdGhpcy5leHBhbmRvIF1bIGNhbWVsQ2FzZSgga2V5ICkgXTtcblx0fSxcblx0YWNjZXNzOiBmdW5jdGlvbiggb3duZXIsIGtleSwgdmFsdWUgKSB7XG5cblx0XHQvLyBJbiBjYXNlcyB3aGVyZSBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIE5vIGtleSB3YXMgc3BlY2lmaWVkXG5cdFx0Ly8gICAyLiBBIHN0cmluZyBrZXkgd2FzIHNwZWNpZmllZCwgYnV0IG5vIHZhbHVlIHByb3ZpZGVkXG5cdFx0Ly9cblx0XHQvLyBUYWtlIHRoZSBcInJlYWRcIiBwYXRoIGFuZCBhbGxvdyB0aGUgZ2V0IG1ldGhvZCB0byBkZXRlcm1pbmVcblx0XHQvLyB3aGljaCB2YWx1ZSB0byByZXR1cm4sIHJlc3BlY3RpdmVseSBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIFRoZSBlbnRpcmUgY2FjaGUgb2JqZWN0XG5cdFx0Ly8gICAyLiBUaGUgZGF0YSBzdG9yZWQgYXQgdGhlIGtleVxuXHRcdC8vXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCB8fFxuXHRcdFx0XHQoICgga2V5ICYmIHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIgKSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICkgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLmdldCggb3duZXIsIGtleSApO1xuXHRcdH1cblxuXHRcdC8vIFdoZW4gdGhlIGtleSBpcyBub3QgYSBzdHJpbmcsIG9yIGJvdGggYSBrZXkgYW5kIHZhbHVlXG5cdFx0Ly8gYXJlIHNwZWNpZmllZCwgc2V0IG9yIGV4dGVuZCAoZXhpc3Rpbmcgb2JqZWN0cykgd2l0aCBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIEFuIG9iamVjdCBvZiBwcm9wZXJ0aWVzXG5cdFx0Ly8gICAyLiBBIGtleSBhbmQgdmFsdWVcblx0XHQvL1xuXHRcdHRoaXMuc2V0KCBvd25lciwga2V5LCB2YWx1ZSApO1xuXG5cdFx0Ly8gU2luY2UgdGhlIFwic2V0XCIgcGF0aCBjYW4gaGF2ZSB0d28gcG9zc2libGUgZW50cnkgcG9pbnRzXG5cdFx0Ly8gcmV0dXJuIHRoZSBleHBlY3RlZCBkYXRhIGJhc2VkIG9uIHdoaWNoIHBhdGggd2FzIHRha2VuWypdXG5cdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IGtleTtcblx0fSxcblx0cmVtb3ZlOiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcblx0XHR2YXIgaSxcblx0XHRcdGNhY2hlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXG5cdFx0aWYgKCBjYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICgga2V5ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQgYXJyYXkgb3Igc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyBvZiBrZXlzXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIGtleSApICkge1xuXG5cdFx0XHRcdC8vIElmIGtleSBpcyBhbiBhcnJheSBvZiBrZXlzLi4uXG5cdFx0XHRcdC8vIFdlIGFsd2F5cyBzZXQgY2FtZWxDYXNlIGtleXMsIHNvIHJlbW92ZSB0aGF0LlxuXHRcdFx0XHRrZXkgPSBrZXkubWFwKCBjYW1lbENhc2UgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGtleSA9IGNhbWVsQ2FzZSgga2V5ICk7XG5cblx0XHRcdFx0Ly8gSWYgYSBrZXkgd2l0aCB0aGUgc3BhY2VzIGV4aXN0cywgdXNlIGl0LlxuXHRcdFx0XHQvLyBPdGhlcndpc2UsIGNyZWF0ZSBhbiBhcnJheSBieSBtYXRjaGluZyBub24td2hpdGVzcGFjZVxuXHRcdFx0XHRrZXkgPSBrZXkgaW4gY2FjaGUgP1xuXHRcdFx0XHRcdFsga2V5IF0gOlxuXHRcdFx0XHRcdCgga2V5Lm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW10gKTtcblx0XHRcdH1cblxuXHRcdFx0aSA9IGtleS5sZW5ndGg7XG5cblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRkZWxldGUgY2FjaGVbIGtleVsgaSBdIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIHRoZSBleHBhbmRvIGlmIHRoZXJlJ3Mgbm8gbW9yZSBkYXRhXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCB8fCBqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKSApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NVxuXHRcdFx0Ly8gV2Via2l0ICYgQmxpbmsgcGVyZm9ybWFuY2Ugc3VmZmVycyB3aGVuIGRlbGV0aW5nIHByb3BlcnRpZXNcblx0XHRcdC8vIGZyb20gRE9NIG5vZGVzLCBzbyBzZXQgdG8gdW5kZWZpbmVkIGluc3RlYWRcblx0XHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM3ODYwNyAoYnVnIHJlc3RyaWN0ZWQpXG5cdFx0XHRpZiAoIG93bmVyLm5vZGVUeXBlICkge1xuXHRcdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWxldGUgb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0aGFzRGF0YTogZnVuY3Rpb24oIG93bmVyICkge1xuXHRcdHZhciBjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblx0XHRyZXR1cm4gY2FjaGUgIT09IHVuZGVmaW5lZCAmJiAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICk7XG5cdH1cbn07XG52YXIgZGF0YVByaXYgPSBuZXcgRGF0YSgpO1xuXG52YXIgZGF0YVVzZXIgPSBuZXcgRGF0YSgpO1xuXG5cblxuLy9cdEltcGxlbWVudGF0aW9uIFN1bW1hcnlcbi8vXG4vL1x0MS4gRW5mb3JjZSBBUEkgc3VyZmFjZSBhbmQgc2VtYW50aWMgY29tcGF0aWJpbGl0eSB3aXRoIDEuOS54IGJyYW5jaFxuLy9cdDIuIEltcHJvdmUgdGhlIG1vZHVsZSdzIG1haW50YWluYWJpbGl0eSBieSByZWR1Y2luZyB0aGUgc3RvcmFnZVxuLy9cdFx0cGF0aHMgdG8gYSBzaW5nbGUgbWVjaGFuaXNtLlxuLy9cdDMuIFVzZSB0aGUgc2FtZSBzaW5nbGUgbWVjaGFuaXNtIHRvIHN1cHBvcnQgXCJwcml2YXRlXCIgYW5kIFwidXNlclwiIGRhdGEuXG4vL1x0NC4gX05ldmVyXyBleHBvc2UgXCJwcml2YXRlXCIgZGF0YSB0byB1c2VyIGNvZGUgKFRPRE86IERyb3AgX2RhdGEsIF9yZW1vdmVEYXRhKVxuLy9cdDUuIEF2b2lkIGV4cG9zaW5nIGltcGxlbWVudGF0aW9uIGRldGFpbHMgb24gdXNlciBvYmplY3RzIChlZy4gZXhwYW5kbyBwcm9wZXJ0aWVzKVxuLy9cdDYuIFByb3ZpZGUgYSBjbGVhciBwYXRoIGZvciBpbXBsZW1lbnRhdGlvbiB1cGdyYWRlIHRvIFdlYWtNYXAgaW4gMjAxNFxuXG52YXIgcmJyYWNlID0gL14oPzpcXHtbXFx3XFxXXSpcXH18XFxbW1xcd1xcV10qXFxdKSQvLFxuXHRybXVsdGlEYXNoID0gL1tBLVpdL2c7XG5cbmZ1bmN0aW9uIGdldERhdGEoIGRhdGEgKSB7XG5cdGlmICggZGF0YSA9PT0gXCJ0cnVlXCIgKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRpZiAoIGRhdGEgPT09IFwiZmFsc2VcIiApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRpZiAoIGRhdGEgPT09IFwibnVsbFwiICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gT25seSBjb252ZXJ0IHRvIGEgbnVtYmVyIGlmIGl0IGRvZXNuJ3QgY2hhbmdlIHRoZSBzdHJpbmdcblx0aWYgKCBkYXRhID09PSArZGF0YSArIFwiXCIgKSB7XG5cdFx0cmV0dXJuICtkYXRhO1xuXHR9XG5cblx0aWYgKCByYnJhY2UudGVzdCggZGF0YSApICkge1xuXHRcdHJldHVybiBKU09OLnBhcnNlKCBkYXRhICk7XG5cdH1cblxuXHRyZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gZGF0YUF0dHIoIGVsZW0sIGtleSwgZGF0YSApIHtcblx0dmFyIG5hbWU7XG5cblx0Ly8gSWYgbm90aGluZyB3YXMgZm91bmQgaW50ZXJuYWxseSwgdHJ5IHRvIGZldGNoIGFueVxuXHQvLyBkYXRhIGZyb20gdGhlIEhUTUw1IGRhdGEtKiBhdHRyaWJ1dGVcblx0aWYgKCBkYXRhID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRuYW1lID0gXCJkYXRhLVwiICsga2V5LnJlcGxhY2UoIHJtdWx0aURhc2gsIFwiLSQmXCIgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdGRhdGEgPSBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApO1xuXG5cdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGRhdGEgPSBnZXREYXRhKCBkYXRhICk7XG5cdFx0XHR9IGNhdGNoICggZSApIHt9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB3ZSBzZXQgdGhlIGRhdGEgc28gaXQgaXNuJ3QgY2hhbmdlZCBsYXRlclxuXHRcdFx0ZGF0YVVzZXIuc2V0KCBlbGVtLCBrZXksIGRhdGEgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGRhdGE7XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0aGFzRGF0YTogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRhdGFVc2VyLmhhc0RhdGEoIGVsZW0gKSB8fCBkYXRhUHJpdi5oYXNEYXRhKCBlbGVtICk7XG5cdH0sXG5cblx0ZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFVc2VyLmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdGRhdGFVc2VyLnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9LFxuXG5cdC8vIFRPRE86IE5vdyB0aGF0IGFsbCBjYWxscyB0byBfZGF0YSBhbmQgX3JlbW92ZURhdGEgaGF2ZSBiZWVuIHJlcGxhY2VkXG5cdC8vIHdpdGggZGlyZWN0IGNhbGxzIHRvIGRhdGFQcml2IG1ldGhvZHMsIHRoZXNlIGNhbiBiZSBkZXByZWNhdGVkLlxuXHRfZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFQcml2LmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xuXHR9LFxuXG5cdF9yZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGRhdGE6IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdHZhciBpLCBuYW1lLCBkYXRhLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdGF0dHJzID0gZWxlbSAmJiBlbGVtLmF0dHJpYnV0ZXM7XG5cblx0XHQvLyBHZXRzIGFsbCB2YWx1ZXNcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB0aGlzLmxlbmd0aCApIHtcblx0XHRcdFx0ZGF0YSA9IGRhdGFVc2VyLmdldCggZWxlbSApO1xuXG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAhZGF0YVByaXYuZ2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiICkgKSB7XG5cdFx0XHRcdFx0aSA9IGF0dHJzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgMTEgb25seVxuXHRcdFx0XHRcdFx0Ly8gVGhlIGF0dHJzIGVsZW1lbnRzIGNhbiBiZSBudWxsICgjMTQ4OTQpXG5cdFx0XHRcdFx0XHRpZiAoIGF0dHJzWyBpIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG5hbWUgPSBhdHRyc1sgaSBdLm5hbWU7XG5cdFx0XHRcdFx0XHRcdGlmICggbmFtZS5pbmRleE9mKCBcImRhdGEtXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0XHRcdFx0XHRuYW1lID0gY2FtZWxDYXNlKCBuYW1lLnNsaWNlKCA1ICkgKTtcblx0XHRcdFx0XHRcdFx0XHRkYXRhQXR0ciggZWxlbSwgbmFtZSwgZGF0YVsgbmFtZSBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0cyBtdWx0aXBsZSB2YWx1ZXNcblx0XHRpZiAoIHR5cGVvZiBrZXkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGF0YVVzZXIuc2V0KCB0aGlzLCBrZXkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZGF0YTtcblxuXHRcdFx0Ly8gVGhlIGNhbGxpbmcgalF1ZXJ5IG9iamVjdCAoZWxlbWVudCBtYXRjaGVzKSBpcyBub3QgZW1wdHlcblx0XHRcdC8vIChhbmQgdGhlcmVmb3JlIGhhcyBhbiBlbGVtZW50IGFwcGVhcnMgYXQgdGhpc1sgMCBdKSBhbmQgdGhlXG5cdFx0XHQvLyBgdmFsdWVgIHBhcmFtZXRlciB3YXMgbm90IHVuZGVmaW5lZC4gQW4gZW1wdHkgalF1ZXJ5IG9iamVjdFxuXHRcdFx0Ly8gd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgZm9yIGVsZW0gPSB0aGlzWyAwIF0gd2hpY2ggd2lsbFxuXHRcdFx0Ly8gdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFuIGF0dGVtcHQgdG8gcmVhZCBhIGRhdGEgY2FjaGUgaXMgbWFkZS5cblx0XHRcdGlmICggZWxlbSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gZ2V0IGRhdGEgZnJvbSB0aGUgY2FjaGVcblx0XHRcdFx0Ly8gVGhlIGtleSB3aWxsIGFsd2F5cyBiZSBjYW1lbENhc2VkIGluIERhdGFcblx0XHRcdFx0ZGF0YSA9IGRhdGFVc2VyLmdldCggZWxlbSwga2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBcImRpc2NvdmVyXCIgdGhlIGRhdGEgaW5cblx0XHRcdFx0Ly8gSFRNTDUgY3VzdG9tIGRhdGEtKiBhdHRyc1xuXHRcdFx0XHRkYXRhID0gZGF0YUF0dHIoIGVsZW0sIGtleSApO1xuXHRcdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFdlIHRyaWVkIHJlYWxseSBoYXJkLCBidXQgdGhlIGRhdGEgZG9lc24ndCBleGlzdC5cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgdGhlIGRhdGEuLi5cblx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0Ly8gV2UgYWx3YXlzIHN0b3JlIHRoZSBjYW1lbENhc2VkIGtleVxuXHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSwgdmFsdWUgKTtcblx0XHRcdH0gKTtcblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEsIG51bGwsIHRydWUgKTtcblx0fSxcblxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbigga2V5ICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0ZGF0YVVzZXIucmVtb3ZlKCB0aGlzLCBrZXkgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgcXVldWU7XG5cblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHR0eXBlID0gKCB0eXBlIHx8IFwiZnhcIiApICsgXCJxdWV1ZVwiO1xuXHRcdFx0cXVldWUgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIHR5cGUgKTtcblxuXHRcdFx0Ly8gU3BlZWQgdXAgZGVxdWV1ZSBieSBnZXR0aW5nIG91dCBxdWlja2x5IGlmIHRoaXMgaXMganVzdCBhIGxvb2t1cFxuXHRcdFx0aWYgKCBkYXRhICkge1xuXHRcdFx0XHRpZiAoICFxdWV1ZSB8fCBBcnJheS5pc0FycmF5KCBkYXRhICkgKSB7XG5cdFx0XHRcdFx0cXVldWUgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIHR5cGUsIGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEgKSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHF1ZXVlLnB1c2goIGRhdGEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHF1ZXVlIHx8IFtdO1xuXHRcdH1cblx0fSxcblxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIGVsZW0sIHR5cGUgKSxcblx0XHRcdHN0YXJ0TGVuZ3RoID0gcXVldWUubGVuZ3RoLFxuXHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpLFxuXHRcdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIHR5cGUgKSxcblx0XHRcdG5leHQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIGVsZW0sIHR5cGUgKTtcblx0XHRcdH07XG5cblx0XHQvLyBJZiB0aGUgZnggcXVldWUgaXMgZGVxdWV1ZWQsIGFsd2F5cyByZW1vdmUgdGhlIHByb2dyZXNzIHNlbnRpbmVsXG5cdFx0aWYgKCBmbiA9PT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCk7XG5cdFx0XHRzdGFydExlbmd0aC0tO1xuXHRcdH1cblxuXHRcdGlmICggZm4gKSB7XG5cblx0XHRcdC8vIEFkZCBhIHByb2dyZXNzIHNlbnRpbmVsIHRvIHByZXZlbnQgdGhlIGZ4IHF1ZXVlIGZyb20gYmVpbmdcblx0XHRcdC8vIGF1dG9tYXRpY2FsbHkgZGVxdWV1ZWRcblx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICkge1xuXHRcdFx0XHRxdWV1ZS51bnNoaWZ0KCBcImlucHJvZ3Jlc3NcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDbGVhciB1cCB0aGUgbGFzdCBxdWV1ZSBzdG9wIGZ1bmN0aW9uXG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdGZuLmNhbGwoIGVsZW0sIG5leHQsIGhvb2tzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhc3RhcnRMZW5ndGggJiYgaG9va3MgKSB7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIE5vdCBwdWJsaWMgLSBnZW5lcmF0ZSBhIHF1ZXVlSG9va3Mgb2JqZWN0LCBvciByZXR1cm4gdGhlIGN1cnJlbnQgb25lXG5cdF9xdWV1ZUhvb2tzOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHR2YXIga2V5ID0gdHlwZSArIFwicXVldWVIb29rc1wiO1xuXHRcdHJldHVybiBkYXRhUHJpdi5nZXQoIGVsZW0sIGtleSApIHx8IGRhdGFQcml2LmFjY2VzcyggZWxlbSwga2V5LCB7XG5cdFx0XHRlbXB0eTogalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICkuYWRkKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBbIHR5cGUgKyBcInF1ZXVlXCIsIGtleSBdICk7XG5cdFx0XHR9IClcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRxdWV1ZTogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHNldHRlciA9IDI7XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZGF0YSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gXCJmeFwiO1xuXHRcdFx0c2V0dGVyLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoIDwgc2V0dGVyICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5xdWV1ZSggdGhpc1sgMCBdLCB0eXBlICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRhdGEgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzIDpcblx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgZGF0YSApO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSBhIGhvb2tzIGZvciB0aGlzIHF1ZXVlXG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggdGhpcywgdHlwZSApO1xuXG5cdFx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICYmIHF1ZXVlWyAwIF0gIT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0fSxcblx0ZGVxdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdH0gKTtcblx0fSxcblx0Y2xlYXJRdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHR9LFxuXG5cdC8vIEdldCBhIHByb21pc2UgcmVzb2x2ZWQgd2hlbiBxdWV1ZXMgb2YgYSBjZXJ0YWluIHR5cGVcblx0Ly8gYXJlIGVtcHRpZWQgKGZ4IGlzIHRoZSB0eXBlIGJ5IGRlZmF1bHQpXG5cdHByb21pc2U6IGZ1bmN0aW9uKCB0eXBlLCBvYmogKSB7XG5cdFx0dmFyIHRtcCxcblx0XHRcdGNvdW50ID0gMSxcblx0XHRcdGRlZmVyID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRlbGVtZW50cyA9IHRoaXMsXG5cdFx0XHRpID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRyZXNvbHZlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggISggLS1jb3VudCApICkge1xuXHRcdFx0XHRcdGRlZmVyLnJlc29sdmVXaXRoKCBlbGVtZW50cywgWyBlbGVtZW50cyBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0b2JqID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0dG1wID0gZGF0YVByaXYuZ2V0KCBlbGVtZW50c1sgaSBdLCB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgKTtcblx0XHRcdGlmICggdG1wICYmIHRtcC5lbXB0eSApIHtcblx0XHRcdFx0Y291bnQrKztcblx0XHRcdFx0dG1wLmVtcHR5LmFkZCggcmVzb2x2ZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXNvbHZlKCk7XG5cdFx0cmV0dXJuIGRlZmVyLnByb21pc2UoIG9iaiApO1xuXHR9XG59ICk7XG52YXIgcG51bSA9ICggL1srLV0/KD86XFxkKlxcLnwpXFxkKyg/OltlRV1bKy1dP1xcZCt8KS8gKS5zb3VyY2U7XG5cbnZhciByY3NzTnVtID0gbmV3IFJlZ0V4cCggXCJeKD86KFsrLV0pPXwpKFwiICsgcG51bSArIFwiKShbYS16JV0qKSRcIiwgXCJpXCIgKTtcblxuXG52YXIgY3NzRXhwYW5kID0gWyBcIlRvcFwiLCBcIlJpZ2h0XCIsIFwiQm90dG9tXCIsIFwiTGVmdFwiIF07XG5cbnZhciBkb2N1bWVudEVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cblxuXG5cdHZhciBpc0F0dGFjaGVkID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblx0XHR9LFxuXHRcdGNvbXBvc2VkID0geyBjb21wb3NlZDogdHJ1ZSB9O1xuXG5cdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSssIEVkZ2UgMTIgLSAxOCssIGlPUyAxMC4wIC0gMTAuMiBvbmx5XG5cdC8vIENoZWNrIGF0dGFjaG1lbnQgYWNyb3NzIHNoYWRvdyBET00gYm91bmRhcmllcyB3aGVuIHBvc3NpYmxlIChnaC0zNTA0KVxuXHQvLyBTdXBwb3J0OiBpT1MgMTAuMC0xMC4yIG9ubHlcblx0Ly8gRWFybHkgaU9TIDEwIHZlcnNpb25zIHN1cHBvcnQgYGF0dGFjaFNoYWRvd2AgYnV0IG5vdCBgZ2V0Um9vdE5vZGVgLFxuXHQvLyBsZWFkaW5nIHRvIGVycm9ycy4gV2UgbmVlZCB0byBjaGVjayBmb3IgYGdldFJvb3ROb2RlYC5cblx0aWYgKCBkb2N1bWVudEVsZW1lbnQuZ2V0Um9vdE5vZGUgKSB7XG5cdFx0aXNBdHRhY2hlZCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgfHxcblx0XHRcdFx0ZWxlbS5nZXRSb290Tm9kZSggY29tcG9zZWQgKSA9PT0gZWxlbS5vd25lckRvY3VtZW50O1xuXHRcdH07XG5cdH1cbnZhciBpc0hpZGRlbldpdGhpblRyZWUgPSBmdW5jdGlvbiggZWxlbSwgZWwgKSB7XG5cblx0XHQvLyBpc0hpZGRlbldpdGhpblRyZWUgbWlnaHQgYmUgY2FsbGVkIGZyb20galF1ZXJ5I2ZpbHRlciBmdW5jdGlvbjtcblx0XHQvLyBpbiB0aGF0IGNhc2UsIGVsZW1lbnQgd2lsbCBiZSBzZWNvbmQgYXJndW1lbnRcblx0XHRlbGVtID0gZWwgfHwgZWxlbTtcblxuXHRcdC8vIElubGluZSBzdHlsZSB0cnVtcHMgYWxsXG5cdFx0cmV0dXJuIGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJub25lXCIgfHxcblx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiAmJlxuXG5cdFx0XHQvLyBPdGhlcndpc2UsIGNoZWNrIGNvbXB1dGVkIHN0eWxlXG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDMgLSA0NVxuXHRcdFx0Ly8gRGlzY29ubmVjdGVkIGVsZW1lbnRzIGNhbiBoYXZlIGNvbXB1dGVkIGRpc3BsYXk6IG5vbmUsIHNvIGZpcnN0IGNvbmZpcm0gdGhhdCBlbGVtIGlzXG5cdFx0XHQvLyBpbiB0aGUgZG9jdW1lbnQuXG5cdFx0XHRpc0F0dGFjaGVkKCBlbGVtICkgJiZcblxuXHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSA9PT0gXCJub25lXCI7XG5cdH07XG5cblxuXG5mdW5jdGlvbiBhZGp1c3RDU1MoIGVsZW0sIHByb3AsIHZhbHVlUGFydHMsIHR3ZWVuICkge1xuXHR2YXIgYWRqdXN0ZWQsIHNjYWxlLFxuXHRcdG1heEl0ZXJhdGlvbnMgPSAyMCxcblx0XHRjdXJyZW50VmFsdWUgPSB0d2VlbiA/XG5cdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuLmN1cigpO1xuXHRcdFx0fSA6XG5cdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AsIFwiXCIgKTtcblx0XHRcdH0sXG5cdFx0aW5pdGlhbCA9IGN1cnJlbnRWYWx1ZSgpLFxuXHRcdHVuaXQgPSB2YWx1ZVBhcnRzICYmIHZhbHVlUGFydHNbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKSxcblxuXHRcdC8vIFN0YXJ0aW5nIHZhbHVlIGNvbXB1dGF0aW9uIGlzIHJlcXVpcmVkIGZvciBwb3RlbnRpYWwgdW5pdCBtaXNtYXRjaGVzXG5cdFx0aW5pdGlhbEluVW5pdCA9IGVsZW0ubm9kZVR5cGUgJiZcblx0XHRcdCggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdIHx8IHVuaXQgIT09IFwicHhcIiAmJiAraW5pdGlhbCApICYmXG5cdFx0XHRyY3NzTnVtLmV4ZWMoIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AgKSApO1xuXG5cdGlmICggaW5pdGlhbEluVW5pdCAmJiBpbml0aWFsSW5Vbml0WyAzIF0gIT09IHVuaXQgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NTRcblx0XHQvLyBIYWx2ZSB0aGUgaXRlcmF0aW9uIHRhcmdldCB2YWx1ZSB0byBwcmV2ZW50IGludGVyZmVyZW5jZSBmcm9tIENTUyB1cHBlciBib3VuZHMgKGdoLTIxNDQpXG5cdFx0aW5pdGlhbCA9IGluaXRpYWwgLyAyO1xuXG5cdFx0Ly8gVHJ1c3QgdW5pdHMgcmVwb3J0ZWQgYnkgalF1ZXJ5LmNzc1xuXHRcdHVuaXQgPSB1bml0IHx8IGluaXRpYWxJblVuaXRbIDMgXTtcblxuXHRcdC8vIEl0ZXJhdGl2ZWx5IGFwcHJveGltYXRlIGZyb20gYSBub256ZXJvIHN0YXJ0aW5nIHBvaW50XG5cdFx0aW5pdGlhbEluVW5pdCA9ICtpbml0aWFsIHx8IDE7XG5cblx0XHR3aGlsZSAoIG1heEl0ZXJhdGlvbnMtLSApIHtcblxuXHRcdFx0Ly8gRXZhbHVhdGUgYW5kIHVwZGF0ZSBvdXIgYmVzdCBndWVzcyAoZG91YmxpbmcgZ3Vlc3NlcyB0aGF0IHplcm8gb3V0KS5cblx0XHRcdC8vIEZpbmlzaCBpZiB0aGUgc2NhbGUgZXF1YWxzIG9yIGNyb3NzZXMgMSAobWFraW5nIHRoZSBvbGQqbmV3IHByb2R1Y3Qgbm9uLXBvc2l0aXZlKS5cblx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgaW5pdGlhbEluVW5pdCArIHVuaXQgKTtcblx0XHRcdGlmICggKCAxIC0gc2NhbGUgKSAqICggMSAtICggc2NhbGUgPSBjdXJyZW50VmFsdWUoKSAvIGluaXRpYWwgfHwgMC41ICkgKSA8PSAwICkge1xuXHRcdFx0XHRtYXhJdGVyYXRpb25zID0gMDtcblx0XHRcdH1cblx0XHRcdGluaXRpYWxJblVuaXQgPSBpbml0aWFsSW5Vbml0IC8gc2NhbGU7XG5cblx0XHR9XG5cblx0XHRpbml0aWFsSW5Vbml0ID0gaW5pdGlhbEluVW5pdCAqIDI7XG5cdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBpbml0aWFsSW5Vbml0ICsgdW5pdCApO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHdlIHVwZGF0ZSB0aGUgdHdlZW4gcHJvcGVydGllcyBsYXRlciBvblxuXHRcdHZhbHVlUGFydHMgPSB2YWx1ZVBhcnRzIHx8IFtdO1xuXHR9XG5cblx0aWYgKCB2YWx1ZVBhcnRzICkge1xuXHRcdGluaXRpYWxJblVuaXQgPSAraW5pdGlhbEluVW5pdCB8fCAraW5pdGlhbCB8fCAwO1xuXG5cdFx0Ly8gQXBwbHkgcmVsYXRpdmUgb2Zmc2V0ICgrPS8tPSkgaWYgc3BlY2lmaWVkXG5cdFx0YWRqdXN0ZWQgPSB2YWx1ZVBhcnRzWyAxIF0gP1xuXHRcdFx0aW5pdGlhbEluVW5pdCArICggdmFsdWVQYXJ0c1sgMSBdICsgMSApICogdmFsdWVQYXJ0c1sgMiBdIDpcblx0XHRcdCt2YWx1ZVBhcnRzWyAyIF07XG5cdFx0aWYgKCB0d2VlbiApIHtcblx0XHRcdHR3ZWVuLnVuaXQgPSB1bml0O1xuXHRcdFx0dHdlZW4uc3RhcnQgPSBpbml0aWFsSW5Vbml0O1xuXHRcdFx0dHdlZW4uZW5kID0gYWRqdXN0ZWQ7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBhZGp1c3RlZDtcbn1cblxuXG52YXIgZGVmYXVsdERpc3BsYXlNYXAgPSB7fTtcblxuZnVuY3Rpb24gZ2V0RGVmYXVsdERpc3BsYXkoIGVsZW0gKSB7XG5cdHZhciB0ZW1wLFxuXHRcdGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudCxcblx0XHRub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUsXG5cdFx0ZGlzcGxheSA9IGRlZmF1bHREaXNwbGF5TWFwWyBub2RlTmFtZSBdO1xuXG5cdGlmICggZGlzcGxheSApIHtcblx0XHRyZXR1cm4gZGlzcGxheTtcblx0fVxuXG5cdHRlbXAgPSBkb2MuYm9keS5hcHBlbmRDaGlsZCggZG9jLmNyZWF0ZUVsZW1lbnQoIG5vZGVOYW1lICkgKTtcblx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIHRlbXAsIFwiZGlzcGxheVwiICk7XG5cblx0dGVtcC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCB0ZW1wICk7XG5cblx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRkaXNwbGF5ID0gXCJibG9ja1wiO1xuXHR9XG5cdGRlZmF1bHREaXNwbGF5TWFwWyBub2RlTmFtZSBdID0gZGlzcGxheTtcblxuXHRyZXR1cm4gZGlzcGxheTtcbn1cblxuZnVuY3Rpb24gc2hvd0hpZGUoIGVsZW1lbnRzLCBzaG93ICkge1xuXHR2YXIgZGlzcGxheSwgZWxlbSxcblx0XHR2YWx1ZXMgPSBbXSxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gZWxlbWVudHMubGVuZ3RoO1xuXG5cdC8vIERldGVybWluZSBuZXcgZGlzcGxheSB2YWx1ZSBmb3IgZWxlbWVudHMgdGhhdCBuZWVkIHRvIGNoYW5nZVxuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGVsZW0gPSBlbGVtZW50c1sgaW5kZXggXTtcblx0XHRpZiAoICFlbGVtLnN0eWxlICkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0ZGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheTtcblx0XHRpZiAoIHNob3cgKSB7XG5cblx0XHRcdC8vIFNpbmNlIHdlIGZvcmNlIHZpc2liaWxpdHkgdXBvbiBjYXNjYWRlLWhpZGRlbiBlbGVtZW50cywgYW4gaW1tZWRpYXRlIChhbmQgc2xvdylcblx0XHRcdC8vIGNoZWNrIGlzIHJlcXVpcmVkIGluIHRoaXMgZmlyc3QgbG9vcCB1bmxlc3Mgd2UgaGF2ZSBhIG5vbmVtcHR5IGRpc3BsYXkgdmFsdWUgKGVpdGhlclxuXHRcdFx0Ly8gaW5saW5lIG9yIGFib3V0LXRvLWJlLXJlc3RvcmVkKVxuXHRcdFx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImRpc3BsYXlcIiApIHx8IG51bGw7XG5cdFx0XHRcdGlmICggIXZhbHVlc1sgaW5kZXggXSApIHtcblx0XHRcdFx0XHRlbGVtLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiAmJiBpc0hpZGRlbldpdGhpblRyZWUoIGVsZW0gKSApIHtcblx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID0gZ2V0RGVmYXVsdERpc3BsYXkoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKCBkaXNwbGF5ICE9PSBcIm5vbmVcIiApIHtcblx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID0gXCJub25lXCI7XG5cblx0XHRcdFx0Ly8gUmVtZW1iZXIgd2hhdCB3ZSdyZSBvdmVyd3JpdGluZ1xuXHRcdFx0XHRkYXRhUHJpdi5zZXQoIGVsZW0sIFwiZGlzcGxheVwiLCBkaXNwbGF5ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gU2V0IHRoZSBkaXNwbGF5IG9mIHRoZSBlbGVtZW50cyBpbiBhIHNlY29uZCBsb29wIHRvIGF2b2lkIGNvbnN0YW50IHJlZmxvd1xuXHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGlmICggdmFsdWVzWyBpbmRleCBdICE9IG51bGwgKSB7XG5cdFx0XHRlbGVtZW50c1sgaW5kZXggXS5zdHlsZS5kaXNwbGF5ID0gdmFsdWVzWyBpbmRleCBdO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50cztcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRzaG93OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMsIHRydWUgKTtcblx0fSxcblx0aGlkZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzICk7XG5cdH0sXG5cdHRvZ2dsZTogZnVuY3Rpb24oIHN0YXRlICkge1xuXHRcdGlmICggdHlwZW9mIHN0YXRlID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdHJldHVybiBzdGF0ZSA/IHRoaXMuc2hvdygpIDogdGhpcy5oaWRlKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGlzSGlkZGVuV2l0aGluVHJlZSggdGhpcyApICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5zaG93KCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5oaWRlKCk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9XG59ICk7XG52YXIgcmNoZWNrYWJsZVR5cGUgPSAoIC9eKD86Y2hlY2tib3h8cmFkaW8pJC9pICk7XG5cbnZhciBydGFnTmFtZSA9ICggLzwoW2Etel1bXlxcL1xcMD5cXHgyMFxcdFxcclxcblxcZl0qKS9pICk7XG5cbnZhciByc2NyaXB0VHlwZSA9ICggL14kfF5tb2R1bGUkfFxcLyg/OmphdmF8ZWNtYSlzY3JpcHQvaSApO1xuXG5cblxuKCBmdW5jdGlvbigpIHtcblx0dmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuXHRcdGRpdiA9IGZyYWdtZW50LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKSxcblx0XHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHlcblx0Ly8gQ2hlY2sgc3RhdGUgbG9zdCBpZiB0aGUgbmFtZSBpcyBzZXQgKCMxMTIxNylcblx0Ly8gU3VwcG9ydDogV2luZG93cyBXZWIgQXBwcyAoV1dBKVxuXHQvLyBgbmFtZWAgYW5kIGB0eXBlYCBtdXN0IHVzZSAuc2V0QXR0cmlidXRlIGZvciBXV0EgKCMxNDkwMSlcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJyYWRpb1wiICk7XG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJjaGVja2VkXCIsIFwiY2hlY2tlZFwiICk7XG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwidFwiICk7XG5cblx0ZGl2LmFwcGVuZENoaWxkKCBpbnB1dCApO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjEgb25seVxuXHQvLyBPbGRlciBXZWJLaXQgZG9lc24ndCBjbG9uZSBjaGVja2VkIHN0YXRlIGNvcnJlY3RseSBpbiBmcmFnbWVudHNcblx0c3VwcG9ydC5jaGVja0Nsb25lID0gZGl2LmNsb25lTm9kZSggdHJ1ZSApLmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5jaGVja2VkO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBNYWtlIHN1cmUgdGV4dGFyZWEgKGFuZCBjaGVja2JveCkgZGVmYXVsdFZhbHVlIGlzIHByb3Blcmx5IGNsb25lZFxuXHRkaXYuaW5uZXJIVE1MID0gXCI8dGV4dGFyZWE+eDwvdGV4dGFyZWE+XCI7XG5cdHN1cHBvcnQubm9DbG9uZUNoZWNrZWQgPSAhIWRpdi5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuZGVmYXVsdFZhbHVlO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdC8vIElFIDw9OSByZXBsYWNlcyA8b3B0aW9uPiB0YWdzIHdpdGggdGhlaXIgY29udGVudHMgd2hlbiBpbnNlcnRlZCBvdXRzaWRlIG9mXG5cdC8vIHRoZSBzZWxlY3QgZWxlbWVudC5cblx0ZGl2LmlubmVySFRNTCA9IFwiPG9wdGlvbj48L29wdGlvbj5cIjtcblx0c3VwcG9ydC5vcHRpb24gPSAhIWRpdi5sYXN0Q2hpbGQ7XG59ICkoKTtcblxuXG4vLyBXZSBoYXZlIHRvIGNsb3NlIHRoZXNlIHRhZ3MgdG8gc3VwcG9ydCBYSFRNTCAoIzEzMjAwKVxudmFyIHdyYXBNYXAgPSB7XG5cblx0Ly8gWEhUTUwgcGFyc2VycyBkbyBub3QgbWFnaWNhbGx5IGluc2VydCBlbGVtZW50cyBpbiB0aGVcblx0Ly8gc2FtZSB3YXkgdGhhdCB0YWcgc291cCBwYXJzZXJzIGRvLiBTbyB3ZSBjYW5ub3Qgc2hvcnRlblxuXHQvLyB0aGlzIGJ5IG9taXR0aW5nIDx0Ym9keT4gb3Igb3RoZXIgcmVxdWlyZWQgZWxlbWVudHMuXG5cdHRoZWFkOiBbIDEsIFwiPHRhYmxlPlwiLCBcIjwvdGFibGU+XCIgXSxcblx0Y29sOiBbIDIsIFwiPHRhYmxlPjxjb2xncm91cD5cIiwgXCI8L2NvbGdyb3VwPjwvdGFibGU+XCIgXSxcblx0dHI6IFsgMiwgXCI8dGFibGU+PHRib2R5PlwiLCBcIjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuXHR0ZDogWyAzLCBcIjx0YWJsZT48dGJvZHk+PHRyPlwiLCBcIjwvdHI+PC90Ym9keT48L3RhYmxlPlwiIF0sXG5cblx0X2RlZmF1bHQ6IFsgMCwgXCJcIiwgXCJcIiBdXG59O1xuXG53cmFwTWFwLnRib2R5ID0gd3JhcE1hcC50Zm9vdCA9IHdyYXBNYXAuY29sZ3JvdXAgPSB3cmFwTWFwLmNhcHRpb24gPSB3cmFwTWFwLnRoZWFkO1xud3JhcE1hcC50aCA9IHdyYXBNYXAudGQ7XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5pZiAoICFzdXBwb3J0Lm9wdGlvbiApIHtcblx0d3JhcE1hcC5vcHRncm91cCA9IHdyYXBNYXAub3B0aW9uID0gWyAxLCBcIjxzZWxlY3QgbXVsdGlwbGU9J211bHRpcGxlJz5cIiwgXCI8L3NlbGVjdD5cIiBdO1xufVxuXG5cbmZ1bmN0aW9uIGdldEFsbCggY29udGV4dCwgdGFnICkge1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0Ly8gVXNlIHR5cGVvZiB0byBhdm9pZCB6ZXJvLWFyZ3VtZW50IG1ldGhvZCBpbnZvY2F0aW9uIG9uIGhvc3Qgb2JqZWN0cyAoIzE1MTUxKVxuXHR2YXIgcmV0O1xuXG5cdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0cmV0ID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnIHx8IFwiKlwiICk7XG5cblx0fSBlbHNlIGlmICggdHlwZW9mIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRyZXQgPSBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyB8fCBcIipcIiApO1xuXG5cdH0gZWxzZSB7XG5cdFx0cmV0ID0gW107XG5cdH1cblxuXHRpZiAoIHRhZyA9PT0gdW5kZWZpbmVkIHx8IHRhZyAmJiBub2RlTmFtZSggY29udGV4dCwgdGFnICkgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5tZXJnZSggWyBjb250ZXh0IF0sIHJldCApO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn1cblxuXG4vLyBNYXJrIHNjcmlwdHMgYXMgaGF2aW5nIGFscmVhZHkgYmVlbiBldmFsdWF0ZWRcbmZ1bmN0aW9uIHNldEdsb2JhbEV2YWwoIGVsZW1zLCByZWZFbGVtZW50cyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdGRhdGFQcml2LnNldChcblx0XHRcdGVsZW1zWyBpIF0sXG5cdFx0XHRcImdsb2JhbEV2YWxcIixcblx0XHRcdCFyZWZFbGVtZW50cyB8fCBkYXRhUHJpdi5nZXQoIHJlZkVsZW1lbnRzWyBpIF0sIFwiZ2xvYmFsRXZhbFwiIClcblx0XHQpO1xuXHR9XG59XG5cblxudmFyIHJodG1sID0gLzx8JiM/XFx3KzsvO1xuXG5mdW5jdGlvbiBidWlsZEZyYWdtZW50KCBlbGVtcywgY29udGV4dCwgc2NyaXB0cywgc2VsZWN0aW9uLCBpZ25vcmVkICkge1xuXHR2YXIgZWxlbSwgdG1wLCB0YWcsIHdyYXAsIGF0dGFjaGVkLCBqLFxuXHRcdGZyYWdtZW50ID0gY29udGV4dC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0bm9kZXMgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsID0gZWxlbXMubGVuZ3RoO1xuXG5cdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRlbGVtID0gZWxlbXNbIGkgXTtcblxuXHRcdGlmICggZWxlbSB8fCBlbGVtID09PSAwICkge1xuXG5cdFx0XHQvLyBBZGQgbm9kZXMgZGlyZWN0bHlcblx0XHRcdGlmICggdG9UeXBlKCBlbGVtICkgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgZWxlbS5ub2RlVHlwZSA/IFsgZWxlbSBdIDogZWxlbSApO1xuXG5cdFx0XHQvLyBDb252ZXJ0IG5vbi1odG1sIGludG8gYSB0ZXh0IG5vZGVcblx0XHRcdH0gZWxzZSBpZiAoICFyaHRtbC50ZXN0KCBlbGVtICkgKSB7XG5cdFx0XHRcdG5vZGVzLnB1c2goIGNvbnRleHQuY3JlYXRlVGV4dE5vZGUoIGVsZW0gKSApO1xuXG5cdFx0XHQvLyBDb252ZXJ0IGh0bWwgaW50byBET00gbm9kZXNcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRtcCA9IHRtcCB8fCBmcmFnbWVudC5hcHBlbmRDaGlsZCggY29udGV4dC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKTtcblxuXHRcdFx0XHQvLyBEZXNlcmlhbGl6ZSBhIHN0YW5kYXJkIHJlcHJlc2VudGF0aW9uXG5cdFx0XHRcdHRhZyA9ICggcnRhZ05hbWUuZXhlYyggZWxlbSApIHx8IFsgXCJcIiwgXCJcIiBdIClbIDEgXS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHR3cmFwID0gd3JhcE1hcFsgdGFnIF0gfHwgd3JhcE1hcC5fZGVmYXVsdDtcblx0XHRcdFx0dG1wLmlubmVySFRNTCA9IHdyYXBbIDEgXSArIGpRdWVyeS5odG1sUHJlZmlsdGVyKCBlbGVtICkgKyB3cmFwWyAyIF07XG5cblx0XHRcdFx0Ly8gRGVzY2VuZCB0aHJvdWdoIHdyYXBwZXJzIHRvIHRoZSByaWdodCBjb250ZW50XG5cdFx0XHRcdGogPSB3cmFwWyAwIF07XG5cdFx0XHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0XHRcdHRtcCA9IHRtcC5sYXN0Q2hpbGQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCB0bXAuY2hpbGROb2RlcyApO1xuXG5cdFx0XHRcdC8vIFJlbWVtYmVyIHRoZSB0b3AtbGV2ZWwgY29udGFpbmVyXG5cdFx0XHRcdHRtcCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cblx0XHRcdFx0Ly8gRW5zdXJlIHRoZSBjcmVhdGVkIG5vZGVzIGFyZSBvcnBoYW5lZCAoIzEyMzkyKVxuXHRcdFx0XHR0bXAudGV4dENvbnRlbnQgPSBcIlwiO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJlbW92ZSB3cmFwcGVyIGZyb20gZnJhZ21lbnRcblx0ZnJhZ21lbnQudGV4dENvbnRlbnQgPSBcIlwiO1xuXG5cdGkgPSAwO1xuXHR3aGlsZSAoICggZWxlbSA9IG5vZGVzWyBpKysgXSApICkge1xuXG5cdFx0Ly8gU2tpcCBlbGVtZW50cyBhbHJlYWR5IGluIHRoZSBjb250ZXh0IGNvbGxlY3Rpb24gKHRyYWMtNDA4Nylcblx0XHRpZiAoIHNlbGVjdGlvbiAmJiBqUXVlcnkuaW5BcnJheSggZWxlbSwgc2VsZWN0aW9uICkgPiAtMSApIHtcblx0XHRcdGlmICggaWdub3JlZCApIHtcblx0XHRcdFx0aWdub3JlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRhdHRhY2hlZCA9IGlzQXR0YWNoZWQoIGVsZW0gKTtcblxuXHRcdC8vIEFwcGVuZCB0byBmcmFnbWVudFxuXHRcdHRtcCA9IGdldEFsbCggZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGVsZW0gKSwgXCJzY3JpcHRcIiApO1xuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGlmICggYXR0YWNoZWQgKSB7XG5cdFx0XHRzZXRHbG9iYWxFdmFsKCB0bXAgKTtcblx0XHR9XG5cblx0XHQvLyBDYXB0dXJlIGV4ZWN1dGFibGVzXG5cdFx0aWYgKCBzY3JpcHRzICkge1xuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRtcFsgaisrIF0gKSApIHtcblx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBlbGVtLnR5cGUgfHwgXCJcIiApICkge1xuXHRcdFx0XHRcdHNjcmlwdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGZyYWdtZW50O1xufVxuXG5cbnZhciBydHlwZW5hbWVzcGFjZSA9IC9eKFteLl0qKSg/OlxcLiguKyl8KS87XG5cbmZ1bmN0aW9uIHJldHVyblRydWUoKSB7XG5cdHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcblx0cmV0dXJuIGZhbHNlO1xufVxuXG4vLyBTdXBwb3J0OiBJRSA8PTkgLSAxMStcbi8vIGZvY3VzKCkgYW5kIGJsdXIoKSBhcmUgYXN5bmNocm9ub3VzLCBleGNlcHQgd2hlbiB0aGV5IGFyZSBuby1vcC5cbi8vIFNvIGV4cGVjdCBmb2N1cyB0byBiZSBzeW5jaHJvbm91cyB3aGVuIHRoZSBlbGVtZW50IGlzIGFscmVhZHkgYWN0aXZlLFxuLy8gYW5kIGJsdXIgdG8gYmUgc3luY2hyb25vdXMgd2hlbiB0aGUgZWxlbWVudCBpcyBub3QgYWxyZWFkeSBhY3RpdmUuXG4vLyAoZm9jdXMgYW5kIGJsdXIgYXJlIGFsd2F5cyBzeW5jaHJvbm91cyBpbiBvdGhlciBzdXBwb3J0ZWQgYnJvd3NlcnMsXG4vLyB0aGlzIGp1c3QgZGVmaW5lcyB3aGVuIHdlIGNhbiBjb3VudCBvbiBpdCkuXG5mdW5jdGlvbiBleHBlY3RTeW5jKCBlbGVtLCB0eXBlICkge1xuXHRyZXR1cm4gKCBlbGVtID09PSBzYWZlQWN0aXZlRWxlbWVudCgpICkgPT09ICggdHlwZSA9PT0gXCJmb2N1c1wiICk7XG59XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4vLyBBY2Nlc3NpbmcgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBjYW4gdGhyb3cgdW5leHBlY3RlZGx5XG4vLyBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTMzOTNcbmZ1bmN0aW9uIHNhZmVBY3RpdmVFbGVtZW50KCkge1xuXHR0cnkge1xuXHRcdHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXHR9IGNhdGNoICggZXJyICkgeyB9XG59XG5cbmZ1bmN0aW9uIG9uKCBlbGVtLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCBvbmUgKSB7XG5cdHZhciBvcmlnRm4sIHR5cGU7XG5cblx0Ly8gVHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXG5cdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gKCB0eXBlcy1PYmplY3QsIHNlbGVjdG9yLCBkYXRhIClcblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcy1PYmplY3QsIGRhdGEgKVxuXHRcdFx0ZGF0YSA9IGRhdGEgfHwgc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdG9uKCBlbGVtLCB0eXBlLCBzZWxlY3RvciwgZGF0YSwgdHlwZXNbIHR5cGUgXSwgb25lICk7XG5cdFx0fVxuXHRcdHJldHVybiBlbGVtO1xuXHR9XG5cblx0aWYgKCBkYXRhID09IG51bGwgJiYgZm4gPT0gbnVsbCApIHtcblxuXHRcdC8vICggdHlwZXMsIGZuIClcblx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdGRhdGEgPSBzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0fSBlbHNlIGlmICggZm4gPT0gbnVsbCApIHtcblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcywgc2VsZWN0b3IsIGZuIClcblx0XHRcdGZuID0gZGF0YTtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gKCB0eXBlcywgZGF0YSwgZm4gKVxuXHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdGZuID0gcmV0dXJuRmFsc2U7XG5cdH0gZWxzZSBpZiAoICFmbiApIHtcblx0XHRyZXR1cm4gZWxlbTtcblx0fVxuXG5cdGlmICggb25lID09PSAxICkge1xuXHRcdG9yaWdGbiA9IGZuO1xuXHRcdGZuID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0XHQvLyBDYW4gdXNlIGFuIGVtcHR5IHNldCwgc2luY2UgZXZlbnQgY29udGFpbnMgdGhlIGluZm9cblx0XHRcdGpRdWVyeSgpLm9mZiggZXZlbnQgKTtcblx0XHRcdHJldHVybiBvcmlnRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH07XG5cblx0XHQvLyBVc2Ugc2FtZSBndWlkIHNvIGNhbGxlciBjYW4gcmVtb3ZlIHVzaW5nIG9yaWdGblxuXHRcdGZuLmd1aWQgPSBvcmlnRm4uZ3VpZCB8fCAoIG9yaWdGbi5ndWlkID0galF1ZXJ5Lmd1aWQrKyApO1xuXHR9XG5cdHJldHVybiBlbGVtLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdGpRdWVyeS5ldmVudC5hZGQoIHRoaXMsIHR5cGVzLCBmbiwgZGF0YSwgc2VsZWN0b3IgKTtcblx0fSApO1xufVxuXG4vKlxuICogSGVscGVyIGZ1bmN0aW9ucyBmb3IgbWFuYWdpbmcgZXZlbnRzIC0tIG5vdCBwYXJ0IG9mIHRoZSBwdWJsaWMgaW50ZXJmYWNlLlxuICogUHJvcHMgdG8gRGVhbiBFZHdhcmRzJyBhZGRFdmVudCBsaWJyYXJ5IGZvciBtYW55IG9mIHRoZSBpZGVhcy5cbiAqL1xualF1ZXJ5LmV2ZW50ID0ge1xuXG5cdGdsb2JhbDoge30sXG5cblx0YWRkOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIGRhdGEsIHNlbGVjdG9yICkge1xuXG5cdFx0dmFyIGhhbmRsZU9iakluLCBldmVudEhhbmRsZSwgdG1wLFxuXHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFQcml2LmdldCggZWxlbSApO1xuXG5cdFx0Ly8gT25seSBhdHRhY2ggZXZlbnRzIHRvIG9iamVjdHMgdGhhdCBhY2NlcHQgZGF0YVxuXHRcdGlmICggIWFjY2VwdERhdGEoIGVsZW0gKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYW4gb2JqZWN0IG9mIGN1c3RvbSBkYXRhIGluIGxpZXUgb2YgdGhlIGhhbmRsZXJcblx0XHRpZiAoIGhhbmRsZXIuaGFuZGxlciApIHtcblx0XHRcdGhhbmRsZU9iakluID0gaGFuZGxlcjtcblx0XHRcdGhhbmRsZXIgPSBoYW5kbGVPYmpJbi5oYW5kbGVyO1xuXHRcdFx0c2VsZWN0b3IgPSBoYW5kbGVPYmpJbi5zZWxlY3Rvcjtcblx0XHR9XG5cblx0XHQvLyBFbnN1cmUgdGhhdCBpbnZhbGlkIHNlbGVjdG9ycyB0aHJvdyBleGNlcHRpb25zIGF0IGF0dGFjaCB0aW1lXG5cdFx0Ly8gRXZhbHVhdGUgYWdhaW5zdCBkb2N1bWVudEVsZW1lbnQgaW4gY2FzZSBlbGVtIGlzIGEgbm9uLWVsZW1lbnQgbm9kZSAoZS5nLiwgZG9jdW1lbnQpXG5cdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggZG9jdW1lbnRFbGVtZW50LCBzZWxlY3RvciApO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBoYW5kbGVyIGhhcyBhIHVuaXF1ZSBJRCwgdXNlZCB0byBmaW5kL3JlbW92ZSBpdCBsYXRlclxuXHRcdGlmICggIWhhbmRsZXIuZ3VpZCApIHtcblx0XHRcdGhhbmRsZXIuZ3VpZCA9IGpRdWVyeS5ndWlkKys7XG5cdFx0fVxuXG5cdFx0Ly8gSW5pdCB0aGUgZWxlbWVudCdzIGV2ZW50IHN0cnVjdHVyZSBhbmQgbWFpbiBoYW5kbGVyLCBpZiB0aGlzIGlzIHRoZSBmaXJzdFxuXHRcdGlmICggISggZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzICkgKSB7XG5cdFx0XHRldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgPSBPYmplY3QuY3JlYXRlKCBudWxsICk7XG5cdFx0fVxuXHRcdGlmICggISggZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgKSApIHtcblx0XHRcdGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlID0gZnVuY3Rpb24oIGUgKSB7XG5cblx0XHRcdFx0Ly8gRGlzY2FyZCB0aGUgc2Vjb25kIGV2ZW50IG9mIGEgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoKSBhbmRcblx0XHRcdFx0Ly8gd2hlbiBhbiBldmVudCBpcyBjYWxsZWQgYWZ0ZXIgYSBwYWdlIGhhcyB1bmxvYWRlZFxuXHRcdFx0XHRyZXR1cm4gdHlwZW9mIGpRdWVyeSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICE9PSBlLnR5cGUgP1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5kaXNwYXRjaC5hcHBseSggZWxlbSwgYXJndW1lbnRzICkgOiB1bmRlZmluZWQ7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIEhhbmRsZSBtdWx0aXBsZSBldmVudHMgc2VwYXJhdGVkIGJ5IGEgc3BhY2Vcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVGhlcmUgKm11c3QqIGJlIGEgdHlwZSwgbm8gYXR0YWNoaW5nIG5hbWVzcGFjZS1vbmx5IGhhbmRsZXJzXG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgZXZlbnQgY2hhbmdlcyBpdHMgdHlwZSwgdXNlIHRoZSBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzIGZvciB0aGUgY2hhbmdlZCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gSWYgc2VsZWN0b3IgZGVmaW5lZCwgZGV0ZXJtaW5lIHNwZWNpYWwgZXZlbnQgYXBpIHR5cGUsIG90aGVyd2lzZSBnaXZlbiB0eXBlXG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cblx0XHRcdC8vIFVwZGF0ZSBzcGVjaWFsIGJhc2VkIG9uIG5ld2x5IHJlc2V0IHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBoYW5kbGVPYmogaXMgcGFzc2VkIHRvIGFsbCBldmVudCBoYW5kbGVyc1xuXHRcdFx0aGFuZGxlT2JqID0galF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRvcmlnVHlwZTogb3JpZ1R5cGUsXG5cdFx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRcdGhhbmRsZXI6IGhhbmRsZXIsXG5cdFx0XHRcdGd1aWQ6IGhhbmRsZXIuZ3VpZCxcblx0XHRcdFx0c2VsZWN0b3I6IHNlbGVjdG9yLFxuXHRcdFx0XHRuZWVkc0NvbnRleHQ6IHNlbGVjdG9yICYmIGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApLFxuXHRcdFx0XHRuYW1lc3BhY2U6IG5hbWVzcGFjZXMuam9pbiggXCIuXCIgKVxuXHRcdFx0fSwgaGFuZGxlT2JqSW4gKTtcblxuXHRcdFx0Ly8gSW5pdCB0aGUgZXZlbnQgaGFuZGxlciBxdWV1ZSBpZiB3ZSdyZSB0aGUgZmlyc3Rcblx0XHRcdGlmICggISggaGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSApICkge1xuXHRcdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdID0gW107XG5cdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQgPSAwO1xuXG5cdFx0XHRcdC8vIE9ubHkgdXNlIGFkZEV2ZW50TGlzdGVuZXIgaWYgdGhlIHNwZWNpYWwgZXZlbnRzIGhhbmRsZXIgcmV0dXJucyBmYWxzZVxuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnNldHVwIHx8XG5cdFx0XHRcdFx0c3BlY2lhbC5zZXR1cC5jYWxsKCBlbGVtLCBkYXRhLCBuYW1lc3BhY2VzLCBldmVudEhhbmRsZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGlmICggZWxlbS5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBldmVudEhhbmRsZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHNwZWNpYWwuYWRkICkge1xuXHRcdFx0XHRzcGVjaWFsLmFkZC5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblxuXHRcdFx0XHRpZiAoICFoYW5kbGVPYmouaGFuZGxlci5ndWlkICkge1xuXHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyLmd1aWQgPSBoYW5kbGVyLmd1aWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHRvIHRoZSBlbGVtZW50J3MgaGFuZGxlciBsaXN0LCBkZWxlZ2F0ZXMgaW4gZnJvbnRcblx0XHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaGFuZGxlcnMuZGVsZWdhdGVDb3VudCsrLCAwLCBoYW5kbGVPYmogKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGV2ZW50cyBoYXZlIGV2ZXIgYmVlbiB1c2VkLCBmb3IgZXZlbnQgb3B0aW1pemF0aW9uXG5cdFx0XHRqUXVlcnkuZXZlbnQuZ2xvYmFsWyB0eXBlIF0gPSB0cnVlO1xuXHRcdH1cblxuXHR9LFxuXG5cdC8vIERldGFjaCBhbiBldmVudCBvciBzZXQgb2YgZXZlbnRzIGZyb20gYW4gZWxlbWVudFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgc2VsZWN0b3IsIG1hcHBlZFR5cGVzICkge1xuXG5cdFx0dmFyIGosIG9yaWdDb3VudCwgdG1wLFxuXHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKSAmJiBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdGlmICggIWVsZW1EYXRhIHx8ICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE9uY2UgZm9yIGVhY2ggdHlwZS5uYW1lc3BhY2UgaW4gdHlwZXM7IHR5cGUgbWF5IGJlIG9taXR0ZWRcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVW5iaW5kIGFsbCBldmVudHMgKG9uIHRoaXMgbmFtZXNwYWNlLCBpZiBwcm92aWRlZCkgZm9yIHRoZSBlbGVtZW50XG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICsgdHlwZXNbIHQgXSwgaGFuZGxlciwgc2VsZWN0b3IsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdIHx8IFtdO1xuXHRcdFx0dG1wID0gdG1wWyAyIF0gJiZcblx0XHRcdFx0bmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbiggXCJcXFxcLig/Oi4qXFxcXC58KVwiICkgKyBcIihcXFxcLnwkKVwiICk7XG5cblx0XHRcdC8vIFJlbW92ZSBtYXRjaGluZyBldmVudHNcblx0XHRcdG9yaWdDb3VudCA9IGogPSBoYW5kbGVycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGogXTtcblxuXHRcdFx0XHRpZiAoICggbWFwcGVkVHlwZXMgfHwgb3JpZ1R5cGUgPT09IGhhbmRsZU9iai5vcmlnVHlwZSApICYmXG5cdFx0XHRcdFx0KCAhaGFuZGxlciB8fCBoYW5kbGVyLmd1aWQgPT09IGhhbmRsZU9iai5ndWlkICkgJiZcblx0XHRcdFx0XHQoICF0bXAgfHwgdG1wLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApICYmXG5cdFx0XHRcdFx0KCAhc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09IGhhbmRsZU9iai5zZWxlY3RvciB8fFxuXHRcdFx0XHRcdFx0c2VsZWN0b3IgPT09IFwiKipcIiAmJiBoYW5kbGVPYmouc2VsZWN0b3IgKSApIHtcblx0XHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGosIDEgKTtcblxuXHRcdFx0XHRcdGlmICggaGFuZGxlT2JqLnNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudC0tO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHNwZWNpYWwucmVtb3ZlICkge1xuXHRcdFx0XHRcdFx0c3BlY2lhbC5yZW1vdmUuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbW92ZSBnZW5lcmljIGV2ZW50IGhhbmRsZXIgaWYgd2UgcmVtb3ZlZCBzb21ldGhpbmcgYW5kIG5vIG1vcmUgaGFuZGxlcnMgZXhpc3Rcblx0XHRcdC8vIChhdm9pZHMgcG90ZW50aWFsIGZvciBlbmRsZXNzIHJlY3Vyc2lvbiBkdXJpbmcgcmVtb3ZhbCBvZiBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzKVxuXHRcdFx0aWYgKCBvcmlnQ291bnQgJiYgIWhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC50ZWFyZG93biB8fFxuXHRcdFx0XHRcdHNwZWNpYWwudGVhcmRvd24uY2FsbCggZWxlbSwgbmFtZXNwYWNlcywgZWxlbURhdGEuaGFuZGxlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBlbGVtRGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRlbGV0ZSBldmVudHNbIHR5cGUgXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgZGF0YSBhbmQgdGhlIGV4cGFuZG8gaWYgaXQncyBubyBsb25nZXIgdXNlZFxuXHRcdGlmICggalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGV2ZW50cyApICkge1xuXHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBcImhhbmRsZSBldmVudHNcIiApO1xuXHRcdH1cblx0fSxcblxuXHRkaXNwYXRjaDogZnVuY3Rpb24oIG5hdGl2ZUV2ZW50ICkge1xuXG5cdFx0dmFyIGksIGosIHJldCwgbWF0Y2hlZCwgaGFuZGxlT2JqLCBoYW5kbGVyUXVldWUsXG5cdFx0XHRhcmdzID0gbmV3IEFycmF5KCBhcmd1bWVudHMubGVuZ3RoICksXG5cblx0XHRcdC8vIE1ha2UgYSB3cml0YWJsZSBqUXVlcnkuRXZlbnQgZnJvbSB0aGUgbmF0aXZlIGV2ZW50IG9iamVjdFxuXHRcdFx0ZXZlbnQgPSBqUXVlcnkuZXZlbnQuZml4KCBuYXRpdmVFdmVudCApLFxuXG5cdFx0XHRoYW5kbGVycyA9IChcblx0XHRcdFx0ZGF0YVByaXYuZ2V0KCB0aGlzLCBcImV2ZW50c1wiICkgfHwgT2JqZWN0LmNyZWF0ZSggbnVsbCApXG5cdFx0XHQpWyBldmVudC50eXBlIF0gfHwgW10sXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGV2ZW50LnR5cGUgXSB8fCB7fTtcblxuXHRcdC8vIFVzZSB0aGUgZml4LWVkIGpRdWVyeS5FdmVudCByYXRoZXIgdGhhbiB0aGUgKHJlYWQtb25seSkgbmF0aXZlIGV2ZW50XG5cdFx0YXJnc1sgMCBdID0gZXZlbnQ7XG5cblx0XHRmb3IgKCBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyApIHtcblx0XHRcdGFyZ3NbIGkgXSA9IGFyZ3VtZW50c1sgaSBdO1xuXHRcdH1cblxuXHRcdGV2ZW50LmRlbGVnYXRlVGFyZ2V0ID0gdGhpcztcblxuXHRcdC8vIENhbGwgdGhlIHByZURpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZSwgYW5kIGxldCBpdCBiYWlsIGlmIGRlc2lyZWRcblx0XHRpZiAoIHNwZWNpYWwucHJlRGlzcGF0Y2ggJiYgc3BlY2lhbC5wcmVEaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgaGFuZGxlcnNcblx0XHRoYW5kbGVyUXVldWUgPSBqUXVlcnkuZXZlbnQuaGFuZGxlcnMuY2FsbCggdGhpcywgZXZlbnQsIGhhbmRsZXJzICk7XG5cblx0XHQvLyBSdW4gZGVsZWdhdGVzIGZpcnN0OyB0aGV5IG1heSB3YW50IHRvIHN0b3AgcHJvcGFnYXRpb24gYmVuZWF0aCB1c1xuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKCBtYXRjaGVkID0gaGFuZGxlclF1ZXVlWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0ZXZlbnQuY3VycmVudFRhcmdldCA9IG1hdGNoZWQuZWxlbTtcblxuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoICggaGFuZGxlT2JqID0gbWF0Y2hlZC5oYW5kbGVyc1sgaisrIF0gKSAmJlxuXHRcdFx0XHQhZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblxuXHRcdFx0XHQvLyBJZiB0aGUgZXZlbnQgaXMgbmFtZXNwYWNlZCwgdGhlbiBlYWNoIGhhbmRsZXIgaXMgb25seSBpbnZva2VkIGlmIGl0IGlzXG5cdFx0XHRcdC8vIHNwZWNpYWxseSB1bml2ZXJzYWwgb3IgaXRzIG5hbWVzcGFjZXMgYXJlIGEgc3VwZXJzZXQgb2YgdGhlIGV2ZW50J3MuXG5cdFx0XHRcdGlmICggIWV2ZW50LnJuYW1lc3BhY2UgfHwgaGFuZGxlT2JqLm5hbWVzcGFjZSA9PT0gZmFsc2UgfHxcblx0XHRcdFx0XHRldmVudC5ybmFtZXNwYWNlLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApIHtcblxuXHRcdFx0XHRcdGV2ZW50LmhhbmRsZU9iaiA9IGhhbmRsZU9iajtcblx0XHRcdFx0XHRldmVudC5kYXRhID0gaGFuZGxlT2JqLmRhdGE7XG5cblx0XHRcdFx0XHRyZXQgPSAoICggalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGhhbmRsZU9iai5vcmlnVHlwZSBdIHx8IHt9ICkuaGFuZGxlIHx8XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlciApLmFwcGx5KCBtYXRjaGVkLmVsZW0sIGFyZ3MgKTtcblxuXHRcdFx0XHRcdGlmICggcmV0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICggZXZlbnQucmVzdWx0ID0gcmV0ICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsIHRoZSBwb3N0RGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlXG5cdFx0aWYgKCBzcGVjaWFsLnBvc3REaXNwYXRjaCApIHtcblx0XHRcdHNwZWNpYWwucG9zdERpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHRoYW5kbGVyczogZnVuY3Rpb24oIGV2ZW50LCBoYW5kbGVycyApIHtcblx0XHR2YXIgaSwgaGFuZGxlT2JqLCBzZWwsIG1hdGNoZWRIYW5kbGVycywgbWF0Y2hlZFNlbGVjdG9ycyxcblx0XHRcdGhhbmRsZXJRdWV1ZSA9IFtdLFxuXHRcdFx0ZGVsZWdhdGVDb3VudCA9IGhhbmRsZXJzLmRlbGVnYXRlQ291bnQsXG5cdFx0XHRjdXIgPSBldmVudC50YXJnZXQ7XG5cblx0XHQvLyBGaW5kIGRlbGVnYXRlIGhhbmRsZXJzXG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50ICYmXG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OVxuXHRcdFx0Ly8gQmxhY2staG9sZSBTVkcgPHVzZT4gaW5zdGFuY2UgdHJlZXMgKHRyYWMtMTMxODApXG5cdFx0XHRjdXIubm9kZVR5cGUgJiZcblxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTQyXG5cdFx0XHQvLyBTdXBwcmVzcyBzcGVjLXZpb2xhdGluZyBjbGlja3MgaW5kaWNhdGluZyBhIG5vbi1wcmltYXJ5IHBvaW50ZXIgYnV0dG9uICh0cmFjLTM4NjEpXG5cdFx0XHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudC10eXBlLWNsaWNrXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSBvbmx5XG5cdFx0XHQvLyAuLi5idXQgbm90IGFycm93IGtleSBcImNsaWNrc1wiIG9mIHJhZGlvIGlucHV0cywgd2hpY2ggY2FuIGhhdmUgYGJ1dHRvbmAgLTEgKGdoLTIzNDMpXG5cdFx0XHQhKCBldmVudC50eXBlID09PSBcImNsaWNrXCIgJiYgZXZlbnQuYnV0dG9uID49IDEgKSApIHtcblxuXHRcdFx0Zm9yICggOyBjdXIgIT09IHRoaXM7IGN1ciA9IGN1ci5wYXJlbnROb2RlIHx8IHRoaXMgKSB7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgY2hlY2sgbm9uLWVsZW1lbnRzICgjMTMyMDgpXG5cdFx0XHRcdC8vIERvbid0IHByb2Nlc3MgY2xpY2tzIG9uIGRpc2FibGVkIGVsZW1lbnRzICgjNjkxMSwgIzgxNjUsICMxMTM4MiwgIzExNzY0KVxuXHRcdFx0XHRpZiAoIGN1ci5ub2RlVHlwZSA9PT0gMSAmJiAhKCBldmVudC50eXBlID09PSBcImNsaWNrXCIgJiYgY3VyLmRpc2FibGVkID09PSB0cnVlICkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlZEhhbmRsZXJzID0gW107XG5cdFx0XHRcdFx0bWF0Y2hlZFNlbGVjdG9ycyA9IHt9O1xuXHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgZGVsZWdhdGVDb3VudDsgaSsrICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGkgXTtcblxuXHRcdFx0XHRcdFx0Ly8gRG9uJ3QgY29uZmxpY3Qgd2l0aCBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKCMxMzIwMylcblx0XHRcdFx0XHRcdHNlbCA9IGhhbmRsZU9iai5zZWxlY3RvciArIFwiIFwiO1xuXG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdID0gaGFuZGxlT2JqLm5lZWRzQ29udGV4dCA/XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5KCBzZWwsIHRoaXMgKS5pbmRleCggY3VyICkgPiAtMSA6XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmZpbmQoIHNlbCwgdGhpcywgbnVsbCwgWyBjdXIgXSApLmxlbmd0aDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZWRIYW5kbGVycy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBtYXRjaGVkSGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goIHsgZWxlbTogY3VyLCBoYW5kbGVyczogbWF0Y2hlZEhhbmRsZXJzIH0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBZGQgdGhlIHJlbWFpbmluZyAoZGlyZWN0bHktYm91bmQpIGhhbmRsZXJzXG5cdFx0Y3VyID0gdGhpcztcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgPCBoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBoYW5kbGVycy5zbGljZSggZGVsZWdhdGVDb3VudCApIH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaGFuZGxlclF1ZXVlO1xuXHR9LFxuXG5cdGFkZFByb3A6IGZ1bmN0aW9uKCBuYW1lLCBob29rICkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggalF1ZXJ5LkV2ZW50LnByb3RvdHlwZSwgbmFtZSwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblxuXHRcdFx0Z2V0OiBpc0Z1bmN0aW9uKCBob29rICkgP1xuXHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBob29rKCB0aGlzLm9yaWdpbmFsRXZlbnQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gOlxuXHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLm9yaWdpbmFsRXZlbnRbIG5hbWUgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsIG5hbWUsIHtcblx0XHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR2YWx1ZTogdmFsdWVcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRmaXg6IGZ1bmN0aW9uKCBvcmlnaW5hbEV2ZW50ICkge1xuXHRcdHJldHVybiBvcmlnaW5hbEV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cblx0XHRcdG9yaWdpbmFsRXZlbnQgOlxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggb3JpZ2luYWxFdmVudCApO1xuXHR9LFxuXG5cdHNwZWNpYWw6IHtcblx0XHRsb2FkOiB7XG5cblx0XHRcdC8vIFByZXZlbnQgdHJpZ2dlcmVkIGltYWdlLmxvYWQgZXZlbnRzIGZyb20gYnViYmxpbmcgdG8gd2luZG93LmxvYWRcblx0XHRcdG5vQnViYmxlOiB0cnVlXG5cdFx0fSxcblx0XHRjbGljazoge1xuXG5cdFx0XHQvLyBVdGlsaXplIG5hdGl2ZSBldmVudCB0byBlbnN1cmUgY29ycmVjdCBzdGF0ZSBmb3IgY2hlY2thYmxlIGlucHV0c1xuXHRcdFx0c2V0dXA6IGZ1bmN0aW9uKCBkYXRhICkge1xuXG5cdFx0XHRcdC8vIEZvciBtdXR1YWwgY29tcHJlc3NpYmlsaXR5IHdpdGggX2RlZmF1bHQsIHJlcGxhY2UgYHRoaXNgIGFjY2VzcyB3aXRoIGEgbG9jYWwgdmFyLlxuXHRcdFx0XHQvLyBgfHwgZGF0YWAgaXMgZGVhZCBjb2RlIG1lYW50IG9ubHkgdG8gcHJlc2VydmUgdGhlIHZhcmlhYmxlIHRocm91Z2ggbWluaWZpY2F0aW9uLlxuXHRcdFx0XHR2YXIgZWwgPSB0aGlzIHx8IGRhdGE7XG5cblx0XHRcdFx0Ly8gQ2xhaW0gdGhlIGZpcnN0IGhhbmRsZXJcblx0XHRcdFx0aWYgKCByY2hlY2thYmxlVHlwZS50ZXN0KCBlbC50eXBlICkgJiZcblx0XHRcdFx0XHRlbC5jbGljayAmJiBub2RlTmFtZSggZWwsIFwiaW5wdXRcIiApICkge1xuXG5cdFx0XHRcdFx0Ly8gZGF0YVByaXYuc2V0KCBlbCwgXCJjbGlja1wiLCAuLi4gKVxuXHRcdFx0XHRcdGxldmVyYWdlTmF0aXZlKCBlbCwgXCJjbGlja1wiLCByZXR1cm5UcnVlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXR1cm4gZmFsc2UgdG8gYWxsb3cgbm9ybWFsIHByb2Nlc3NpbmcgaW4gdGhlIGNhbGxlclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9LFxuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oIGRhdGEgKSB7XG5cblx0XHRcdFx0Ly8gRm9yIG11dHVhbCBjb21wcmVzc2liaWxpdHkgd2l0aCBfZGVmYXVsdCwgcmVwbGFjZSBgdGhpc2AgYWNjZXNzIHdpdGggYSBsb2NhbCB2YXIuXG5cdFx0XHRcdC8vIGB8fCBkYXRhYCBpcyBkZWFkIGNvZGUgbWVhbnQgb25seSB0byBwcmVzZXJ2ZSB0aGUgdmFyaWFibGUgdGhyb3VnaCBtaW5pZmljYXRpb24uXG5cdFx0XHRcdHZhciBlbCA9IHRoaXMgfHwgZGF0YTtcblxuXHRcdFx0XHQvLyBGb3JjZSBzZXR1cCBiZWZvcmUgdHJpZ2dlcmluZyBhIGNsaWNrXG5cdFx0XHRcdGlmICggcmNoZWNrYWJsZVR5cGUudGVzdCggZWwudHlwZSApICYmXG5cdFx0XHRcdFx0ZWwuY2xpY2sgJiYgbm9kZU5hbWUoIGVsLCBcImlucHV0XCIgKSApIHtcblxuXHRcdFx0XHRcdGxldmVyYWdlTmF0aXZlKCBlbCwgXCJjbGlja1wiICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXR1cm4gbm9uLWZhbHNlIHRvIGFsbG93IG5vcm1hbCBldmVudC1wYXRoIHByb3BhZ2F0aW9uXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRm9yIGNyb3NzLWJyb3dzZXIgY29uc2lzdGVuY3ksIHN1cHByZXNzIG5hdGl2ZSAuY2xpY2soKSBvbiBsaW5rc1xuXHRcdFx0Ly8gQWxzbyBwcmV2ZW50IGl0IGlmIHdlJ3JlIGN1cnJlbnRseSBpbnNpZGUgYSBsZXZlcmFnZWQgbmF0aXZlLWV2ZW50IHN0YWNrXG5cdFx0XHRfZGVmYXVsdDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuXHRcdFx0XHRyZXR1cm4gcmNoZWNrYWJsZVR5cGUudGVzdCggdGFyZ2V0LnR5cGUgKSAmJlxuXHRcdFx0XHRcdHRhcmdldC5jbGljayAmJiBub2RlTmFtZSggdGFyZ2V0LCBcImlucHV0XCIgKSAmJlxuXHRcdFx0XHRcdGRhdGFQcml2LmdldCggdGFyZ2V0LCBcImNsaWNrXCIgKSB8fFxuXHRcdFx0XHRcdG5vZGVOYW1lKCB0YXJnZXQsIFwiYVwiICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGJlZm9yZXVubG9hZDoge1xuXHRcdFx0cG9zdERpc3BhdGNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCAyMCtcblx0XHRcdFx0Ly8gRmlyZWZveCBkb2Vzbid0IGFsZXJ0IGlmIHRoZSByZXR1cm5WYWx1ZSBmaWVsZCBpcyBub3Qgc2V0LlxuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCAhPT0gdW5kZWZpbmVkICYmIGV2ZW50Lm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0ZXZlbnQub3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZSA9IGV2ZW50LnJlc3VsdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuLy8gRW5zdXJlIHRoZSBwcmVzZW5jZSBvZiBhbiBldmVudCBsaXN0ZW5lciB0aGF0IGhhbmRsZXMgbWFudWFsbHktdHJpZ2dlcmVkXG4vLyBzeW50aGV0aWMgZXZlbnRzIGJ5IGludGVycnVwdGluZyBwcm9ncmVzcyB1bnRpbCByZWludm9rZWQgaW4gcmVzcG9uc2UgdG9cbi8vICpuYXRpdmUqIGV2ZW50cyB0aGF0IGl0IGZpcmVzIGRpcmVjdGx5LCBlbnN1cmluZyB0aGF0IHN0YXRlIGNoYW5nZXMgaGF2ZVxuLy8gYWxyZWFkeSBvY2N1cnJlZCBiZWZvcmUgb3RoZXIgbGlzdGVuZXJzIGFyZSBpbnZva2VkLlxuZnVuY3Rpb24gbGV2ZXJhZ2VOYXRpdmUoIGVsLCB0eXBlLCBleHBlY3RTeW5jICkge1xuXG5cdC8vIE1pc3NpbmcgZXhwZWN0U3luYyBpbmRpY2F0ZXMgYSB0cmlnZ2VyIGNhbGwsIHdoaWNoIG11c3QgZm9yY2Ugc2V0dXAgdGhyb3VnaCBqUXVlcnkuZXZlbnQuYWRkXG5cdGlmICggIWV4cGVjdFN5bmMgKSB7XG5cdFx0aWYgKCBkYXRhUHJpdi5nZXQoIGVsLCB0eXBlICkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIGVsLCB0eXBlLCByZXR1cm5UcnVlICk7XG5cdFx0fVxuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFJlZ2lzdGVyIHRoZSBjb250cm9sbGVyIGFzIGEgc3BlY2lhbCB1bml2ZXJzYWwgaGFuZGxlciBmb3IgYWxsIGV2ZW50IG5hbWVzcGFjZXNcblx0ZGF0YVByaXYuc2V0KCBlbCwgdHlwZSwgZmFsc2UgKTtcblx0alF1ZXJ5LmV2ZW50LmFkZCggZWwsIHR5cGUsIHtcblx0XHRuYW1lc3BhY2U6IGZhbHNlLFxuXHRcdGhhbmRsZXI6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciBub3RBc3luYywgcmVzdWx0LFxuXHRcdFx0XHRzYXZlZCA9IGRhdGFQcml2LmdldCggdGhpcywgdHlwZSApO1xuXG5cdFx0XHRpZiAoICggZXZlbnQuaXNUcmlnZ2VyICYgMSApICYmIHRoaXNbIHR5cGUgXSApIHtcblxuXHRcdFx0XHQvLyBJbnRlcnJ1cHQgcHJvY2Vzc2luZyBvZiB0aGUgb3V0ZXIgc3ludGhldGljIC50cmlnZ2VyKCllZCBldmVudFxuXHRcdFx0XHQvLyBTYXZlZCBkYXRhIHNob3VsZCBiZSBmYWxzZSBpbiBzdWNoIGNhc2VzLCBidXQgbWlnaHQgYmUgYSBsZWZ0b3ZlciBjYXB0dXJlIG9iamVjdFxuXHRcdFx0XHQvLyBmcm9tIGFuIGFzeW5jIG5hdGl2ZSBoYW5kbGVyIChnaC00MzUwKVxuXHRcdFx0XHRpZiAoICFzYXZlZC5sZW5ndGggKSB7XG5cblx0XHRcdFx0XHQvLyBTdG9yZSBhcmd1bWVudHMgZm9yIHVzZSB3aGVuIGhhbmRsaW5nIHRoZSBpbm5lciBuYXRpdmUgZXZlbnRcblx0XHRcdFx0XHQvLyBUaGVyZSB3aWxsIGFsd2F5cyBiZSBhdCBsZWFzdCBvbmUgYXJndW1lbnQgKGFuIGV2ZW50IG9iamVjdCksIHNvIHRoaXMgYXJyYXlcblx0XHRcdFx0XHQvLyB3aWxsIG5vdCBiZSBjb25mdXNlZCB3aXRoIGEgbGVmdG92ZXIgY2FwdHVyZSBvYmplY3QuXG5cdFx0XHRcdFx0c2F2ZWQgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIHR5cGUsIHNhdmVkICk7XG5cblx0XHRcdFx0XHQvLyBUcmlnZ2VyIHRoZSBuYXRpdmUgZXZlbnQgYW5kIGNhcHR1cmUgaXRzIHJlc3VsdFxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExK1xuXHRcdFx0XHRcdC8vIGZvY3VzKCkgYW5kIGJsdXIoKSBhcmUgYXN5bmNocm9ub3VzXG5cdFx0XHRcdFx0bm90QXN5bmMgPSBleHBlY3RTeW5jKCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdFx0dGhpc1sgdHlwZSBdKCk7XG5cdFx0XHRcdFx0cmVzdWx0ID0gZGF0YVByaXYuZ2V0KCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdFx0aWYgKCBzYXZlZCAhPT0gcmVzdWx0IHx8IG5vdEFzeW5jICkge1xuXHRcdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCB0eXBlLCBmYWxzZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXN1bHQgPSB7fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBzYXZlZCAhPT0gcmVzdWx0ICkge1xuXG5cdFx0XHRcdFx0XHQvLyBDYW5jZWwgdGhlIG91dGVyIHN5bnRoZXRpYyBldmVudFxuXHRcdFx0XHRcdFx0ZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgODYrXG5cdFx0XHRcdFx0XHQvLyBJbiBDaHJvbWUsIGlmIGFuIGVsZW1lbnQgaGF2aW5nIGEgZm9jdXNvdXQgaGFuZGxlciBpcyBibHVycmVkIGJ5XG5cdFx0XHRcdFx0XHQvLyBjbGlja2luZyBvdXRzaWRlIG9mIGl0LCBpdCBpbnZva2VzIHRoZSBoYW5kbGVyIHN5bmNocm9ub3VzbHkuIElmXG5cdFx0XHRcdFx0XHQvLyB0aGF0IGhhbmRsZXIgY2FsbHMgYC5yZW1vdmUoKWAgb24gdGhlIGVsZW1lbnQsIHRoZSBkYXRhIGlzIGNsZWFyZWQsXG5cdFx0XHRcdFx0XHQvLyBsZWF2aW5nIGByZXN1bHRgIHVuZGVmaW5lZC4gV2UgbmVlZCB0byBndWFyZCBhZ2FpbnN0IHRoaXMuXG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0ICYmIHJlc3VsdC52YWx1ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgdGhpcyBpcyBhbiBpbm5lciBzeW50aGV0aWMgZXZlbnQgZm9yIGFuIGV2ZW50IHdpdGggYSBidWJibGluZyBzdXJyb2dhdGVcblx0XHRcdFx0Ly8gKGZvY3VzIG9yIGJsdXIpLCBhc3N1bWUgdGhhdCB0aGUgc3Vycm9nYXRlIGFscmVhZHkgcHJvcGFnYXRlZCBmcm9tIHRyaWdnZXJpbmcgdGhlXG5cdFx0XHRcdC8vIG5hdGl2ZSBldmVudCBhbmQgcHJldmVudCB0aGF0IGZyb20gaGFwcGVuaW5nIGFnYWluIGhlcmUuXG5cdFx0XHRcdC8vIFRoaXMgdGVjaG5pY2FsbHkgZ2V0cyB0aGUgb3JkZXJpbmcgd3Jvbmcgdy5yLnQuIHRvIGAudHJpZ2dlcigpYCAoaW4gd2hpY2ggdGhlXG5cdFx0XHRcdC8vIGJ1YmJsaW5nIHN1cnJvZ2F0ZSBwcm9wYWdhdGVzICphZnRlciogdGhlIG5vbi1idWJibGluZyBiYXNlKSwgYnV0IHRoYXQgc2VlbXNcblx0XHRcdFx0Ly8gbGVzcyBiYWQgdGhhbiBkdXBsaWNhdGlvbi5cblx0XHRcdFx0fSBlbHNlIGlmICggKCBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9ICkuZGVsZWdhdGVUeXBlICkge1xuXHRcdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoaXMgaXMgYSBuYXRpdmUgZXZlbnQgdHJpZ2dlcmVkIGFib3ZlLCBldmVyeXRoaW5nIGlzIG5vdyBpbiBvcmRlclxuXHRcdFx0Ly8gRmlyZSBhbiBpbm5lciBzeW50aGV0aWMgZXZlbnQgd2l0aCB0aGUgb3JpZ2luYWwgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCBzYXZlZC5sZW5ndGggKSB7XG5cblx0XHRcdFx0Ly8gLi4uYW5kIGNhcHR1cmUgdGhlIHJlc3VsdFxuXHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIHR5cGUsIHtcblx0XHRcdFx0XHR2YWx1ZTogalF1ZXJ5LmV2ZW50LnRyaWdnZXIoXG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExK1xuXHRcdFx0XHRcdFx0Ly8gRXh0ZW5kIHdpdGggdGhlIHByb3RvdHlwZSB0byByZXNldCB0aGUgYWJvdmUgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKClcblx0XHRcdFx0XHRcdGpRdWVyeS5leHRlbmQoIHNhdmVkWyAwIF0sIGpRdWVyeS5FdmVudC5wcm90b3R5cGUgKSxcblx0XHRcdFx0XHRcdHNhdmVkLnNsaWNlKCAxICksXG5cdFx0XHRcdFx0XHR0aGlzXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0Ly8gQWJvcnQgaGFuZGxpbmcgb2YgdGhlIG5hdGl2ZSBldmVudFxuXHRcdFx0XHRldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gKTtcbn1cblxualF1ZXJ5LnJlbW92ZUV2ZW50ID0gZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGhhbmRsZSApIHtcblxuXHQvLyBUaGlzIFwiaWZcIiBpcyBuZWVkZWQgZm9yIHBsYWluIG9iamVjdHNcblx0aWYgKCBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0ZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBoYW5kbGUgKTtcblx0fVxufTtcblxualF1ZXJ5LkV2ZW50ID0gZnVuY3Rpb24oIHNyYywgcHJvcHMgKSB7XG5cblx0Ly8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IHRoZSAnbmV3JyBrZXl3b3JkXG5cdGlmICggISggdGhpcyBpbnN0YW5jZW9mIGpRdWVyeS5FdmVudCApICkge1xuXHRcdHJldHVybiBuZXcgalF1ZXJ5LkV2ZW50KCBzcmMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBFdmVudCBvYmplY3Rcblx0aWYgKCBzcmMgJiYgc3JjLnR5cGUgKSB7XG5cdFx0dGhpcy5vcmlnaW5hbEV2ZW50ID0gc3JjO1xuXHRcdHRoaXMudHlwZSA9IHNyYy50eXBlO1xuXG5cdFx0Ly8gRXZlbnRzIGJ1YmJsaW5nIHVwIHRoZSBkb2N1bWVudCBtYXkgaGF2ZSBiZWVuIG1hcmtlZCBhcyBwcmV2ZW50ZWRcblx0XHQvLyBieSBhIGhhbmRsZXIgbG93ZXIgZG93biB0aGUgdHJlZTsgcmVmbGVjdCB0aGUgY29ycmVjdCB2YWx1ZS5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHNyYy5kZWZhdWx0UHJldmVudGVkIHx8XG5cdFx0XHRcdHNyYy5kZWZhdWx0UHJldmVudGVkID09PSB1bmRlZmluZWQgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHlcblx0XHRcdFx0c3JjLnJldHVyblZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRyZXR1cm5UcnVlIDpcblx0XHRcdHJldHVybkZhbHNlO1xuXG5cdFx0Ly8gQ3JlYXRlIHRhcmdldCBwcm9wZXJ0aWVzXG5cdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDw9NiAtIDcgb25seVxuXHRcdC8vIFRhcmdldCBzaG91bGQgbm90IGJlIGEgdGV4dCBub2RlICgjNTA0LCAjMTMxNDMpXG5cdFx0dGhpcy50YXJnZXQgPSAoIHNyYy50YXJnZXQgJiYgc3JjLnRhcmdldC5ub2RlVHlwZSA9PT0gMyApID9cblx0XHRcdHNyYy50YXJnZXQucGFyZW50Tm9kZSA6XG5cdFx0XHRzcmMudGFyZ2V0O1xuXG5cdFx0dGhpcy5jdXJyZW50VGFyZ2V0ID0gc3JjLmN1cnJlbnRUYXJnZXQ7XG5cdFx0dGhpcy5yZWxhdGVkVGFyZ2V0ID0gc3JjLnJlbGF0ZWRUYXJnZXQ7XG5cblx0Ly8gRXZlbnQgdHlwZVxuXHR9IGVsc2Uge1xuXHRcdHRoaXMudHlwZSA9IHNyYztcblx0fVxuXG5cdC8vIFB1dCBleHBsaWNpdGx5IHByb3ZpZGVkIHByb3BlcnRpZXMgb250byB0aGUgZXZlbnQgb2JqZWN0XG5cdGlmICggcHJvcHMgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdGhpcywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIENyZWF0ZSBhIHRpbWVzdGFtcCBpZiBpbmNvbWluZyBldmVudCBkb2Vzbid0IGhhdmUgb25lXG5cdHRoaXMudGltZVN0YW1wID0gc3JjICYmIHNyYy50aW1lU3RhbXAgfHwgRGF0ZS5ub3coKTtcblxuXHQvLyBNYXJrIGl0IGFzIGZpeGVkXG5cdHRoaXNbIGpRdWVyeS5leHBhbmRvIF0gPSB0cnVlO1xufTtcblxuLy8galF1ZXJ5LkV2ZW50IGlzIGJhc2VkIG9uIERPTTMgRXZlbnRzIGFzIHNwZWNpZmllZCBieSB0aGUgRUNNQVNjcmlwdCBMYW5ndWFnZSBCaW5kaW5nXG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvMjAwMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwMzAzMzEvZWNtYS1zY3JpcHQtYmluZGluZy5odG1sXG5qUXVlcnkuRXZlbnQucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LkV2ZW50LFxuXHRpc0RlZmF1bHRQcmV2ZW50ZWQ6IHJldHVybkZhbHNlLFxuXHRpc1Byb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblx0aXNTaW11bGF0ZWQ6IGZhbHNlLFxuXG5cdHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cdH0sXG5cdHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdH1cblxuXHRcdHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH1cbn07XG5cbi8vIEluY2x1ZGVzIGFsbCBjb21tb24gZXZlbnQgcHJvcHMgaW5jbHVkaW5nIEtleUV2ZW50IGFuZCBNb3VzZUV2ZW50IHNwZWNpZmljIHByb3BzXG5qUXVlcnkuZWFjaCgge1xuXHRhbHRLZXk6IHRydWUsXG5cdGJ1YmJsZXM6IHRydWUsXG5cdGNhbmNlbGFibGU6IHRydWUsXG5cdGNoYW5nZWRUb3VjaGVzOiB0cnVlLFxuXHRjdHJsS2V5OiB0cnVlLFxuXHRkZXRhaWw6IHRydWUsXG5cdGV2ZW50UGhhc2U6IHRydWUsXG5cdG1ldGFLZXk6IHRydWUsXG5cdHBhZ2VYOiB0cnVlLFxuXHRwYWdlWTogdHJ1ZSxcblx0c2hpZnRLZXk6IHRydWUsXG5cdHZpZXc6IHRydWUsXG5cdFwiY2hhclwiOiB0cnVlLFxuXHRjb2RlOiB0cnVlLFxuXHRjaGFyQ29kZTogdHJ1ZSxcblx0a2V5OiB0cnVlLFxuXHRrZXlDb2RlOiB0cnVlLFxuXHRidXR0b246IHRydWUsXG5cdGJ1dHRvbnM6IHRydWUsXG5cdGNsaWVudFg6IHRydWUsXG5cdGNsaWVudFk6IHRydWUsXG5cdG9mZnNldFg6IHRydWUsXG5cdG9mZnNldFk6IHRydWUsXG5cdHBvaW50ZXJJZDogdHJ1ZSxcblx0cG9pbnRlclR5cGU6IHRydWUsXG5cdHNjcmVlblg6IHRydWUsXG5cdHNjcmVlblk6IHRydWUsXG5cdHRhcmdldFRvdWNoZXM6IHRydWUsXG5cdHRvRWxlbWVudDogdHJ1ZSxcblx0dG91Y2hlczogdHJ1ZSxcblx0d2hpY2g6IHRydWVcbn0sIGpRdWVyeS5ldmVudC5hZGRQcm9wICk7XG5cbmpRdWVyeS5lYWNoKCB7IGZvY3VzOiBcImZvY3VzaW5cIiwgYmx1cjogXCJmb2N1c291dFwiIH0sIGZ1bmN0aW9uKCB0eXBlLCBkZWxlZ2F0ZVR5cGUgKSB7XG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gPSB7XG5cblx0XHQvLyBVdGlsaXplIG5hdGl2ZSBldmVudCBpZiBwb3NzaWJsZSBzbyBibHVyL2ZvY3VzIHNlcXVlbmNlIGlzIGNvcnJlY3Rcblx0XHRzZXR1cDogZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIENsYWltIHRoZSBmaXJzdCBoYW5kbGVyXG5cdFx0XHQvLyBkYXRhUHJpdi5zZXQoIHRoaXMsIFwiZm9jdXNcIiwgLi4uIClcblx0XHRcdC8vIGRhdGFQcml2LnNldCggdGhpcywgXCJibHVyXCIsIC4uLiApXG5cdFx0XHRsZXZlcmFnZU5hdGl2ZSggdGhpcywgdHlwZSwgZXhwZWN0U3luYyApO1xuXG5cdFx0XHQvLyBSZXR1cm4gZmFsc2UgdG8gYWxsb3cgbm9ybWFsIHByb2Nlc3NpbmcgaW4gdGhlIGNhbGxlclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEZvcmNlIHNldHVwIGJlZm9yZSB0cmlnZ2VyXG5cdFx0XHRsZXZlcmFnZU5hdGl2ZSggdGhpcywgdHlwZSApO1xuXG5cdFx0XHQvLyBSZXR1cm4gbm9uLWZhbHNlIHRvIGFsbG93IG5vcm1hbCBldmVudC1wYXRoIHByb3BhZ2F0aW9uXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0Ly8gU3VwcHJlc3MgbmF0aXZlIGZvY3VzIG9yIGJsdXIgYXMgaXQncyBhbHJlYWR5IGJlaW5nIGZpcmVkXG5cdFx0Ly8gaW4gbGV2ZXJhZ2VOYXRpdmUuXG5cdFx0X2RlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdGRlbGVnYXRlVHlwZTogZGVsZWdhdGVUeXBlXG5cdH07XG59ICk7XG5cbi8vIENyZWF0ZSBtb3VzZWVudGVyL2xlYXZlIGV2ZW50cyB1c2luZyBtb3VzZW92ZXIvb3V0IGFuZCBldmVudC10aW1lIGNoZWNrc1xuLy8gc28gdGhhdCBldmVudCBkZWxlZ2F0aW9uIHdvcmtzIGluIGpRdWVyeS5cbi8vIERvIHRoZSBzYW1lIGZvciBwb2ludGVyZW50ZXIvcG9pbnRlcmxlYXZlIGFuZCBwb2ludGVyb3Zlci9wb2ludGVyb3V0XG4vL1xuLy8gU3VwcG9ydDogU2FmYXJpIDcgb25seVxuLy8gU2FmYXJpIHNlbmRzIG1vdXNlZW50ZXIgdG9vIG9mdGVuOyBzZWU6XG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NzAyNThcbi8vIGZvciB0aGUgZGVzY3JpcHRpb24gb2YgdGhlIGJ1ZyAoaXQgZXhpc3RlZCBpbiBvbGRlciBDaHJvbWUgdmVyc2lvbnMgYXMgd2VsbCkuXG5qUXVlcnkuZWFjaCgge1xuXHRtb3VzZWVudGVyOiBcIm1vdXNlb3ZlclwiLFxuXHRtb3VzZWxlYXZlOiBcIm1vdXNlb3V0XCIsXG5cdHBvaW50ZXJlbnRlcjogXCJwb2ludGVyb3ZlclwiLFxuXHRwb2ludGVybGVhdmU6IFwicG9pbnRlcm91dFwiXG59LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgb3JpZyBdID0ge1xuXHRcdGRlbGVnYXRlVHlwZTogZml4LFxuXHRcdGJpbmRUeXBlOiBmaXgsXG5cblx0XHRoYW5kbGU6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciByZXQsXG5cdFx0XHRcdHRhcmdldCA9IHRoaXMsXG5cdFx0XHRcdHJlbGF0ZWQgPSBldmVudC5yZWxhdGVkVGFyZ2V0LFxuXHRcdFx0XHRoYW5kbGVPYmogPSBldmVudC5oYW5kbGVPYmo7XG5cblx0XHRcdC8vIEZvciBtb3VzZWVudGVyL2xlYXZlIGNhbGwgdGhlIGhhbmRsZXIgaWYgcmVsYXRlZCBpcyBvdXRzaWRlIHRoZSB0YXJnZXQuXG5cdFx0XHQvLyBOQjogTm8gcmVsYXRlZFRhcmdldCBpZiB0aGUgbW91c2UgbGVmdC9lbnRlcmVkIHRoZSBicm93c2VyIHdpbmRvd1xuXHRcdFx0aWYgKCAhcmVsYXRlZCB8fCAoIHJlbGF0ZWQgIT09IHRhcmdldCAmJiAhalF1ZXJ5LmNvbnRhaW5zKCB0YXJnZXQsIHJlbGF0ZWQgKSApICkge1xuXHRcdFx0XHRldmVudC50eXBlID0gaGFuZGxlT2JqLm9yaWdUeXBlO1xuXHRcdFx0XHRyZXQgPSBoYW5kbGVPYmouaGFuZGxlci5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBmaXg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblx0fTtcbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdG9uOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0fSxcblx0b25lOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIDEgKTtcblx0fSxcblx0b2ZmOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBmbiApIHtcblx0XHR2YXIgaGFuZGxlT2JqLCB0eXBlO1xuXHRcdGlmICggdHlwZXMgJiYgdHlwZXMucHJldmVudERlZmF1bHQgJiYgdHlwZXMuaGFuZGxlT2JqICkge1xuXG5cdFx0XHQvLyAoIGV2ZW50ICkgIGRpc3BhdGNoZWQgalF1ZXJ5LkV2ZW50XG5cdFx0XHRoYW5kbGVPYmogPSB0eXBlcy5oYW5kbGVPYmo7XG5cdFx0XHRqUXVlcnkoIHR5cGVzLmRlbGVnYXRlVGFyZ2V0ICkub2ZmKFxuXHRcdFx0XHRoYW5kbGVPYmoubmFtZXNwYWNlID9cblx0XHRcdFx0XHRoYW5kbGVPYmoub3JpZ1R5cGUgKyBcIi5cIiArIGhhbmRsZU9iai5uYW1lc3BhY2UgOlxuXHRcdFx0XHRcdGhhbmRsZU9iai5vcmlnVHlwZSxcblx0XHRcdFx0aGFuZGxlT2JqLnNlbGVjdG9yLFxuXHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlclxuXHRcdFx0KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcy1vYmplY3QgWywgc2VsZWN0b3JdIClcblx0XHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRcdHRoaXMub2ZmKCB0eXBlLCBzZWxlY3RvciwgdHlwZXNbIHR5cGUgXSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggc2VsZWN0b3IgPT09IGZhbHNlIHx8IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzIFssIGZuXSApXG5cdFx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCB0aGlzLCB0eXBlcywgZm4sIHNlbGVjdG9yICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cblxudmFyXG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMCAtIDExLCBFZGdlIDEyIC0gMTMgb25seVxuXHQvLyBJbiBJRS9FZGdlIHVzaW5nIHJlZ2V4IGdyb3VwcyBoZXJlIGNhdXNlcyBzZXZlcmUgc2xvd2Rvd25zLlxuXHQvLyBTZWUgaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2svZGV0YWlscy8xNzM2NTEyL1xuXHRybm9Jbm5lcmh0bWwgPSAvPHNjcmlwdHw8c3R5bGV8PGxpbmsvaSxcblxuXHQvLyBjaGVja2VkPVwiY2hlY2tlZFwiIG9yIGNoZWNrZWRcblx0cmNoZWNrZWQgPSAvY2hlY2tlZFxccyooPzpbXj1dfD1cXHMqLmNoZWNrZWQuKS9pLFxuXHRyY2xlYW5TY3JpcHQgPSAvXlxccyo8ISg/OlxcW0NEQVRBXFxbfC0tKXwoPzpcXF1cXF18LS0pPlxccyokL2c7XG5cbi8vIFByZWZlciBhIHRib2R5IG92ZXIgaXRzIHBhcmVudCB0YWJsZSBmb3IgY29udGFpbmluZyBuZXcgcm93c1xuZnVuY3Rpb24gbWFuaXB1bGF0aW9uVGFyZ2V0KCBlbGVtLCBjb250ZW50ICkge1xuXHRpZiAoIG5vZGVOYW1lKCBlbGVtLCBcInRhYmxlXCIgKSAmJlxuXHRcdG5vZGVOYW1lKCBjb250ZW50Lm5vZGVUeXBlICE9PSAxMSA/IGNvbnRlbnQgOiBjb250ZW50LmZpcnN0Q2hpbGQsIFwidHJcIiApICkge1xuXG5cdFx0cmV0dXJuIGpRdWVyeSggZWxlbSApLmNoaWxkcmVuKCBcInRib2R5XCIgKVsgMCBdIHx8IGVsZW07XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxuLy8gUmVwbGFjZS9yZXN0b3JlIHRoZSB0eXBlIGF0dHJpYnV0ZSBvZiBzY3JpcHQgZWxlbWVudHMgZm9yIHNhZmUgRE9NIG1hbmlwdWxhdGlvblxuZnVuY3Rpb24gZGlzYWJsZVNjcmlwdCggZWxlbSApIHtcblx0ZWxlbS50eXBlID0gKCBlbGVtLmdldEF0dHJpYnV0ZSggXCJ0eXBlXCIgKSAhPT0gbnVsbCApICsgXCIvXCIgKyBlbGVtLnR5cGU7XG5cdHJldHVybiBlbGVtO1xufVxuZnVuY3Rpb24gcmVzdG9yZVNjcmlwdCggZWxlbSApIHtcblx0aWYgKCAoIGVsZW0udHlwZSB8fCBcIlwiICkuc2xpY2UoIDAsIDUgKSA9PT0gXCJ0cnVlL1wiICkge1xuXHRcdGVsZW0udHlwZSA9IGVsZW0udHlwZS5zbGljZSggNSApO1xuXHR9IGVsc2Uge1xuXHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBcInR5cGVcIiApO1xuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbmZ1bmN0aW9uIGNsb25lQ29weUV2ZW50KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBpLCBsLCB0eXBlLCBwZGF0YU9sZCwgdWRhdGFPbGQsIHVkYXRhQ3VyLCBldmVudHM7XG5cblx0aWYgKCBkZXN0Lm5vZGVUeXBlICE9PSAxICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIDEuIENvcHkgcHJpdmF0ZSBkYXRhOiBldmVudHMsIGhhbmRsZXJzLCBldGMuXG5cdGlmICggZGF0YVByaXYuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0cGRhdGFPbGQgPSBkYXRhUHJpdi5nZXQoIHNyYyApO1xuXHRcdGV2ZW50cyA9IHBkYXRhT2xkLmV2ZW50cztcblxuXHRcdGlmICggZXZlbnRzICkge1xuXHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBkZXN0LCBcImhhbmRsZSBldmVudHNcIiApO1xuXG5cdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBldmVudHNbIHR5cGUgXS5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggZGVzdCwgdHlwZSwgZXZlbnRzWyB0eXBlIF1bIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gMi4gQ29weSB1c2VyIGRhdGFcblx0aWYgKCBkYXRhVXNlci5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHR1ZGF0YU9sZCA9IGRhdGFVc2VyLmFjY2Vzcyggc3JjICk7XG5cdFx0dWRhdGFDdXIgPSBqUXVlcnkuZXh0ZW5kKCB7fSwgdWRhdGFPbGQgKTtcblxuXHRcdGRhdGFVc2VyLnNldCggZGVzdCwgdWRhdGFDdXIgKTtcblx0fVxufVxuXG4vLyBGaXggSUUgYnVncywgc2VlIHN1cHBvcnQgdGVzdHNcbmZ1bmN0aW9uIGZpeElucHV0KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBub2RlTmFtZSA9IGRlc3Qubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHQvLyBGYWlscyB0byBwZXJzaXN0IHRoZSBjaGVja2VkIHN0YXRlIG9mIGEgY2xvbmVkIGNoZWNrYm94IG9yIHJhZGlvIGJ1dHRvbi5cblx0aWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmIHJjaGVja2FibGVUeXBlLnRlc3QoIHNyYy50eXBlICkgKSB7XG5cdFx0ZGVzdC5jaGVja2VkID0gc3JjLmNoZWNrZWQ7XG5cblx0Ly8gRmFpbHMgdG8gcmV0dXJuIHRoZSBzZWxlY3RlZCBvcHRpb24gdG8gdGhlIGRlZmF1bHQgc2VsZWN0ZWQgc3RhdGUgd2hlbiBjbG9uaW5nIG9wdGlvbnNcblx0fSBlbHNlIGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiB8fCBub2RlTmFtZSA9PT0gXCJ0ZXh0YXJlYVwiICkge1xuXHRcdGRlc3QuZGVmYXVsdFZhbHVlID0gc3JjLmRlZmF1bHRWYWx1ZTtcblx0fVxufVxuXG5mdW5jdGlvbiBkb21NYW5pcCggY29sbGVjdGlvbiwgYXJncywgY2FsbGJhY2ssIGlnbm9yZWQgKSB7XG5cblx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRhcmdzID0gZmxhdCggYXJncyApO1xuXG5cdHZhciBmcmFnbWVudCwgZmlyc3QsIHNjcmlwdHMsIGhhc1NjcmlwdHMsIG5vZGUsIGRvYyxcblx0XHRpID0gMCxcblx0XHRsID0gY29sbGVjdGlvbi5sZW5ndGgsXG5cdFx0aU5vQ2xvbmUgPSBsIC0gMSxcblx0XHR2YWx1ZSA9IGFyZ3NbIDAgXSxcblx0XHR2YWx1ZUlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdC8vIFdlIGNhbid0IGNsb25lTm9kZSBmcmFnbWVudHMgdGhhdCBjb250YWluIGNoZWNrZWQsIGluIFdlYktpdFxuXHRpZiAoIHZhbHVlSXNGdW5jdGlvbiB8fFxuXHRcdFx0KCBsID4gMSAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0IXN1cHBvcnQuY2hlY2tDbG9uZSAmJiByY2hlY2tlZC50ZXN0KCB2YWx1ZSApICkgKSB7XG5cdFx0cmV0dXJuIGNvbGxlY3Rpb24uZWFjaCggZnVuY3Rpb24oIGluZGV4ICkge1xuXHRcdFx0dmFyIHNlbGYgPSBjb2xsZWN0aW9uLmVxKCBpbmRleCApO1xuXHRcdFx0aWYgKCB2YWx1ZUlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdGFyZ3NbIDAgXSA9IHZhbHVlLmNhbGwoIHRoaXMsIGluZGV4LCBzZWxmLmh0bWwoKSApO1xuXHRcdFx0fVxuXHRcdFx0ZG9tTWFuaXAoIHNlbGYsIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICk7XG5cdFx0fSApO1xuXHR9XG5cblx0aWYgKCBsICkge1xuXHRcdGZyYWdtZW50ID0gYnVpbGRGcmFnbWVudCggYXJncywgY29sbGVjdGlvblsgMCBdLm93bmVyRG9jdW1lbnQsIGZhbHNlLCBjb2xsZWN0aW9uLCBpZ25vcmVkICk7XG5cdFx0Zmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0aWYgKCBmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdGZyYWdtZW50ID0gZmlyc3Q7XG5cdFx0fVxuXG5cdFx0Ly8gUmVxdWlyZSBlaXRoZXIgbmV3IGNvbnRlbnQgb3IgYW4gaW50ZXJlc3QgaW4gaWdub3JlZCBlbGVtZW50cyB0byBpbnZva2UgdGhlIGNhbGxiYWNrXG5cdFx0aWYgKCBmaXJzdCB8fCBpZ25vcmVkICkge1xuXHRcdFx0c2NyaXB0cyA9IGpRdWVyeS5tYXAoIGdldEFsbCggZnJhZ21lbnQsIFwic2NyaXB0XCIgKSwgZGlzYWJsZVNjcmlwdCApO1xuXHRcdFx0aGFzU2NyaXB0cyA9IHNjcmlwdHMubGVuZ3RoO1xuXG5cdFx0XHQvLyBVc2UgdGhlIG9yaWdpbmFsIGZyYWdtZW50IGZvciB0aGUgbGFzdCBpdGVtXG5cdFx0XHQvLyBpbnN0ZWFkIG9mIHRoZSBmaXJzdCBiZWNhdXNlIGl0IGNhbiBlbmQgdXBcblx0XHRcdC8vIGJlaW5nIGVtcHRpZWQgaW5jb3JyZWN0bHkgaW4gY2VydGFpbiBzaXR1YXRpb25zICgjODA3MCkuXG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdG5vZGUgPSBmcmFnbWVudDtcblxuXHRcdFx0XHRpZiAoIGkgIT09IGlOb0Nsb25lICkge1xuXHRcdFx0XHRcdG5vZGUgPSBqUXVlcnkuY2xvbmUoIG5vZGUsIHRydWUsIHRydWUgKTtcblxuXHRcdFx0XHRcdC8vIEtlZXAgcmVmZXJlbmNlcyB0byBjbG9uZWQgc2NyaXB0cyBmb3IgbGF0ZXIgcmVzdG9yYXRpb25cblx0XHRcdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBzY3JpcHRzLCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNhbGxiYWNrLmNhbGwoIGNvbGxlY3Rpb25bIGkgXSwgbm9kZSwgaSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cdFx0XHRcdGRvYyA9IHNjcmlwdHNbIHNjcmlwdHMubGVuZ3RoIC0gMSBdLm93bmVyRG9jdW1lbnQ7XG5cblx0XHRcdFx0Ly8gUmVlbmFibGUgc2NyaXB0c1xuXHRcdFx0XHRqUXVlcnkubWFwKCBzY3JpcHRzLCByZXN0b3JlU2NyaXB0ICk7XG5cblx0XHRcdFx0Ly8gRXZhbHVhdGUgZXhlY3V0YWJsZSBzY3JpcHRzIG9uIGZpcnN0IGRvY3VtZW50IGluc2VydGlvblxuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGhhc1NjcmlwdHM7IGkrKyApIHtcblx0XHRcdFx0XHRub2RlID0gc2NyaXB0c1sgaSBdO1xuXHRcdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggbm9kZS50eXBlIHx8IFwiXCIgKSAmJlxuXHRcdFx0XHRcdFx0IWRhdGFQcml2LmFjY2Vzcyggbm9kZSwgXCJnbG9iYWxFdmFsXCIgKSAmJlxuXHRcdFx0XHRcdFx0alF1ZXJ5LmNvbnRhaW5zKCBkb2MsIG5vZGUgKSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBub2RlLnNyYyAmJiAoIG5vZGUudHlwZSB8fCBcIlwiICkudG9Mb3dlckNhc2UoKSAgIT09IFwibW9kdWxlXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gT3B0aW9uYWwgQUpBWCBkZXBlbmRlbmN5LCBidXQgd29uJ3QgcnVuIHNjcmlwdHMgaWYgbm90IHByZXNlbnRcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuX2V2YWxVcmwgJiYgIW5vZGUubm9Nb2R1bGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5Ll9ldmFsVXJsKCBub2RlLnNyYywge1xuXHRcdFx0XHRcdFx0XHRcdFx0bm9uY2U6IG5vZGUubm9uY2UgfHwgbm9kZS5nZXRBdHRyaWJ1dGUoIFwibm9uY2VcIiApXG5cdFx0XHRcdFx0XHRcdFx0fSwgZG9jICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdERPTUV2YWwoIG5vZGUudGV4dENvbnRlbnQucmVwbGFjZSggcmNsZWFuU2NyaXB0LCBcIlwiICksIG5vZGUsIGRvYyApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjb2xsZWN0aW9uO1xufVxuXG5mdW5jdGlvbiByZW1vdmUoIGVsZW0sIHNlbGVjdG9yLCBrZWVwRGF0YSApIHtcblx0dmFyIG5vZGUsXG5cdFx0bm9kZXMgPSBzZWxlY3RvciA/IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBlbGVtICkgOiBlbGVtLFxuXHRcdGkgPSAwO1xuXG5cdGZvciAoIDsgKCBub2RlID0gbm9kZXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRpZiAoICFrZWVwRGF0YSAmJiBub2RlLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBub2RlICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIG5vZGUucGFyZW50Tm9kZSApIHtcblx0XHRcdGlmICgga2VlcERhdGEgJiYgaXNBdHRhY2hlZCggbm9kZSApICkge1xuXHRcdFx0XHRzZXRHbG9iYWxFdmFsKCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0fVxuXHRcdFx0bm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBub2RlICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0aHRtbFByZWZpbHRlcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0cmV0dXJuIGh0bWw7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCBlbGVtLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHR2YXIgaSwgbCwgc3JjRWxlbWVudHMsIGRlc3RFbGVtZW50cyxcblx0XHRcdGNsb25lID0gZWxlbS5jbG9uZU5vZGUoIHRydWUgKSxcblx0XHRcdGluUGFnZSA9IGlzQXR0YWNoZWQoIGVsZW0gKTtcblxuXHRcdC8vIEZpeCBJRSBjbG9uaW5nIGlzc3Vlc1xuXHRcdGlmICggIXN1cHBvcnQubm9DbG9uZUNoZWNrZWQgJiYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGVsZW0ubm9kZVR5cGUgPT09IDExICkgJiZcblx0XHRcdFx0IWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXG5cdFx0XHQvLyBXZSBlc2NoZXcgU2l6emxlIGhlcmUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnM6IGh0dHBzOi8vanNwZXJmLmNvbS9nZXRhbGwtdnMtc2l6emxlLzJcblx0XHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUgKTtcblx0XHRcdHNyY0VsZW1lbnRzID0gZ2V0QWxsKCBlbGVtICk7XG5cblx0XHRcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRmaXhJbnB1dCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDb3B5IHRoZSBldmVudHMgZnJvbSB0aGUgb3JpZ2luYWwgdG8gdGhlIGNsb25lXG5cdFx0aWYgKCBkYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0aWYgKCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdFx0c3JjRWxlbWVudHMgPSBzcmNFbGVtZW50cyB8fCBnZXRBbGwoIGVsZW0gKTtcblx0XHRcdFx0ZGVzdEVsZW1lbnRzID0gZGVzdEVsZW1lbnRzIHx8IGdldEFsbCggY2xvbmUgKTtcblxuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRjbG9uZUNvcHlFdmVudCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIGVsZW0sIGNsb25lICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUsIFwic2NyaXB0XCIgKTtcblx0XHRpZiAoIGRlc3RFbGVtZW50cy5sZW5ndGggPiAwICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggZGVzdEVsZW1lbnRzLCAhaW5QYWdlICYmIGdldEFsbCggZWxlbSwgXCJzY3JpcHRcIiApICk7XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIHRoZSBjbG9uZWQgc2V0XG5cdFx0cmV0dXJuIGNsb25lO1xuXHR9LFxuXG5cdGNsZWFuRGF0YTogZnVuY3Rpb24oIGVsZW1zICkge1xuXHRcdHZhciBkYXRhLCBlbGVtLCB0eXBlLFxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IGVsZW1zWyBpIF0gKSAhPT0gdW5kZWZpbmVkOyBpKysgKSB7XG5cdFx0XHRpZiAoIGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblx0XHRcdFx0aWYgKCAoIGRhdGEgPSBlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gKSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0Zm9yICggdHlwZSBpbiBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsWyB0eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFRoaXMgaXMgYSBzaG9ydGN1dCB0byBhdm9pZCBqUXVlcnkuZXZlbnQucmVtb3ZlJ3Mgb3ZlcmhlYWRcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGRhdGEuaGFuZGxlICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1K1xuXHRcdFx0XHRcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuXHRcdFx0XHRcdGVsZW1bIGRhdGFQcml2LmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSApIHtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDUrXG5cdFx0XHRcdFx0Ly8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXG5cdFx0XHRcdFx0ZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZGV0YWNoOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IsIHRydWUgKTtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gcmVtb3ZlKCB0aGlzLCBzZWxlY3RvciApO1xuXHR9LFxuXG5cdHRleHQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGpRdWVyeS50ZXh0KCB0aGlzICkgOlxuXHRcdFx0XHR0aGlzLmVtcHR5KCkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fSxcblxuXHRhcHBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG5cdFx0XHRcdHRhcmdldC5hcHBlbmRDaGlsZCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRwcmVwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0YXJnZXQuZmlyc3RDaGlsZCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRiZWZvcmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGFmdGVyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcy5uZXh0U2libGluZyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGVsZW0sXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKCBlbGVtID0gdGhpc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXG5cdFx0XHRcdC8vIFJlbW92ZSBhbnkgcmVtYWluaW5nIG5vZGVzXG5cdFx0XHRcdGVsZW0udGV4dENvbnRlbnQgPSBcIlwiO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiggZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0ZGF0YUFuZEV2ZW50cyA9IGRhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGZhbHNlIDogZGF0YUFuZEV2ZW50cztcblx0XHRkZWVwRGF0YUFuZEV2ZW50cyA9IGRlZXBEYXRhQW5kRXZlbnRzID09IG51bGwgPyBkYXRhQW5kRXZlbnRzIDogZGVlcERhdGFBbmRFdmVudHM7XG5cblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5jbG9uZSggdGhpcywgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKTtcblx0XHR9ICk7XG5cdH0sXG5cblx0aHRtbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBlbGVtID0gdGhpc1sgMCBdIHx8IHt9LFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0bCA9IHRoaXMubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uaW5uZXJIVE1MO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZWUgaWYgd2UgY2FuIHRha2UgYSBzaG9ydGN1dCBhbmQganVzdCB1c2UgaW5uZXJIVE1MXG5cdFx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiAhcm5vSW5uZXJodG1sLnRlc3QoIHZhbHVlICkgJiZcblx0XHRcdFx0IXdyYXBNYXBbICggcnRhZ05hbWUuZXhlYyggdmFsdWUgKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKSBdICkge1xuXG5cdFx0XHRcdHZhbHVlID0galF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIHZhbHVlICk7XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRlbGVtID0gdGhpc1sgaSBdIHx8IHt9O1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgZWxlbWVudCBub2RlcyBhbmQgcHJldmVudCBtZW1vcnkgbGVha3Ncblx0XHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XG5cdFx0XHRcdFx0XHRcdGVsZW0uaW5uZXJIVE1MID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZWxlbSA9IDA7XG5cblx0XHRcdFx0Ly8gSWYgdXNpbmcgaW5uZXJIVE1MIHRocm93cyBhbiBleGNlcHRpb24sIHVzZSB0aGUgZmFsbGJhY2sgbWV0aG9kXG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge31cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHR0aGlzLmVtcHR5KCkuYXBwZW5kKCB2YWx1ZSApO1xuXHRcdFx0fVxuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0cmVwbGFjZVdpdGg6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpZ25vcmVkID0gW107XG5cblx0XHQvLyBNYWtlIHRoZSBjaGFuZ2VzLCByZXBsYWNpbmcgZWFjaCBub24taWdub3JlZCBjb250ZXh0IGVsZW1lbnQgd2l0aCB0aGUgbmV3IGNvbnRlbnRcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuXG5cdFx0XHRpZiAoIGpRdWVyeS5pbkFycmF5KCB0aGlzLCBpZ25vcmVkICkgPCAwICkge1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIHRoaXMgKSApO1xuXHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblx0XHRcdFx0XHRwYXJlbnQucmVwbGFjZUNoaWxkKCBlbGVtLCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEZvcmNlIGNhbGxiYWNrIGludm9jYXRpb25cblx0XHR9LCBpZ25vcmVkICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIHtcblx0YXBwZW5kVG86IFwiYXBwZW5kXCIsXG5cdHByZXBlbmRUbzogXCJwcmVwZW5kXCIsXG5cdGluc2VydEJlZm9yZTogXCJiZWZvcmVcIixcblx0aW5zZXJ0QWZ0ZXI6IFwiYWZ0ZXJcIixcblx0cmVwbGFjZUFsbDogXCJyZXBsYWNlV2l0aFwiXG59LCBmdW5jdGlvbiggbmFtZSwgb3JpZ2luYWwgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBlbGVtcyxcblx0XHRcdHJldCA9IFtdLFxuXHRcdFx0aW5zZXJ0ID0galF1ZXJ5KCBzZWxlY3RvciApLFxuXHRcdFx0bGFzdCA9IGluc2VydC5sZW5ndGggLSAxLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7IGkgPD0gbGFzdDsgaSsrICkge1xuXHRcdFx0ZWxlbXMgPSBpID09PSBsYXN0ID8gdGhpcyA6IHRoaXMuY2xvbmUoIHRydWUgKTtcblx0XHRcdGpRdWVyeSggaW5zZXJ0WyBpIF0gKVsgb3JpZ2luYWwgXSggZWxlbXMgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHQvLyAuZ2V0KCkgYmVjYXVzZSBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRwdXNoLmFwcGx5KCByZXQsIGVsZW1zLmdldCgpICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCByZXQgKTtcblx0fTtcbn0gKTtcbnZhciBybnVtbm9ucHggPSBuZXcgUmVnRXhwKCBcIl4oXCIgKyBwbnVtICsgXCIpKD8hcHgpW2EteiVdKyRcIiwgXCJpXCIgKTtcblxudmFyIGdldFN0eWxlcyA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5LCBGaXJlZm94IDw9MzAgKCMxNTA5OCwgIzE0MTUwKVxuXHRcdC8vIElFIHRocm93cyBvbiBlbGVtZW50cyBjcmVhdGVkIGluIHBvcHVwc1xuXHRcdC8vIEZGIG1lYW53aGlsZSB0aHJvd3Mgb24gZnJhbWUgZWxlbWVudHMgdGhyb3VnaCBcImRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGVcIlxuXHRcdHZhciB2aWV3ID0gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuXG5cdFx0aWYgKCAhdmlldyB8fCAhdmlldy5vcGVuZXIgKSB7XG5cdFx0XHR2aWV3ID0gd2luZG93O1xuXHRcdH1cblxuXHRcdHJldHVybiB2aWV3LmdldENvbXB1dGVkU3R5bGUoIGVsZW0gKTtcblx0fTtcblxudmFyIHN3YXAgPSBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgY2FsbGJhY2sgKSB7XG5cdHZhciByZXQsIG5hbWUsXG5cdFx0b2xkID0ge307XG5cblx0Ly8gUmVtZW1iZXIgdGhlIG9sZCB2YWx1ZXMsIGFuZCBpbnNlcnQgdGhlIG5ldyBvbmVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRvbGRbIG5hbWUgXSA9IGVsZW0uc3R5bGVbIG5hbWUgXTtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvcHRpb25zWyBuYW1lIF07XG5cdH1cblxuXHRyZXQgPSBjYWxsYmFjay5jYWxsKCBlbGVtICk7XG5cblx0Ly8gUmV2ZXJ0IHRoZSBvbGQgdmFsdWVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvbGRbIG5hbWUgXTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59O1xuXG5cbnZhciByYm94U3R5bGUgPSBuZXcgUmVnRXhwKCBjc3NFeHBhbmQuam9pbiggXCJ8XCIgKSwgXCJpXCIgKTtcblxuXG5cbiggZnVuY3Rpb24oKSB7XG5cblx0Ly8gRXhlY3V0aW5nIGJvdGggcGl4ZWxQb3NpdGlvbiAmIGJveFNpemluZ1JlbGlhYmxlIHRlc3RzIHJlcXVpcmUgb25seSBvbmUgbGF5b3V0XG5cdC8vIHNvIHRoZXkncmUgZXhlY3V0ZWQgYXQgdGhlIHNhbWUgdGltZSB0byBzYXZlIHRoZSBzZWNvbmQgY29tcHV0YXRpb24uXG5cdGZ1bmN0aW9uIGNvbXB1dGVTdHlsZVRlc3RzKCkge1xuXG5cdFx0Ly8gVGhpcyBpcyBhIHNpbmdsZXRvbiwgd2UgbmVlZCB0byBleGVjdXRlIGl0IG9ubHkgb25jZVxuXHRcdGlmICggIWRpdiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246YWJzb2x1dGU7bGVmdDotMTExMTFweDt3aWR0aDo2MHB4O1wiICtcblx0XHRcdFwibWFyZ2luLXRvcDoxcHg7cGFkZGluZzowO2JvcmRlcjowXCI7XG5cdFx0ZGl2LnN0eWxlLmNzc1RleHQgPVxuXHRcdFx0XCJwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmJsb2NrO2JveC1zaXppbmc6Ym9yZGVyLWJveDtvdmVyZmxvdzpzY3JvbGw7XCIgK1xuXHRcdFx0XCJtYXJnaW46YXV0bztib3JkZXI6MXB4O3BhZGRpbmc6MXB4O1wiICtcblx0XHRcdFwid2lkdGg6NjAlO3RvcDoxJVwiO1xuXHRcdGRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZCggY29udGFpbmVyICkuYXBwZW5kQ2hpbGQoIGRpdiApO1xuXG5cdFx0dmFyIGRpdlN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoIGRpdiApO1xuXHRcdHBpeGVsUG9zaXRpb25WYWwgPSBkaXZTdHlsZS50b3AgIT09IFwiMSVcIjtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIEZpcmVmb3ggPD0zIC0gNDRcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnRWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdlN0eWxlLm1hcmdpbkxlZnQgKSA9PT0gMTI7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5LCBTYWZhcmkgPD05LjEgLSAxMC4xLCBpT1MgPD03LjAgLSA5LjNcblx0XHQvLyBTb21lIHN0eWxlcyBjb21lIGJhY2sgd2l0aCBwZXJjZW50YWdlIHZhbHVlcywgZXZlbiB0aG91Z2ggdGhleSBzaG91bGRuJ3Rcblx0XHRkaXYuc3R5bGUucmlnaHQgPSBcIjYwJVwiO1xuXHRcdHBpeGVsQm94U3R5bGVzVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS5yaWdodCApID09PSAzNjtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5XG5cdFx0Ly8gRGV0ZWN0IG1pc3JlcG9ydGluZyBvZiBjb250ZW50IGRpbWVuc2lvbnMgZm9yIGJveC1zaXppbmc6Ym9yZGVyLWJveCBlbGVtZW50c1xuXHRcdGJveFNpemluZ1JlbGlhYmxlVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS53aWR0aCApID09PSAzNjtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgb25seVxuXHRcdC8vIERldGVjdCBvdmVyZmxvdzpzY3JvbGwgc2NyZXdpbmVzcyAoZ2gtMzY5OSlcblx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD02NFxuXHRcdC8vIERvbid0IGdldCB0cmlja2VkIHdoZW4gem9vbSBhZmZlY3RzIG9mZnNldFdpZHRoIChnaC00MDI5KVxuXHRcdGRpdi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcblx0XHRzY3JvbGxib3hTaXplVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXYub2Zmc2V0V2lkdGggLyAzICkgPT09IDEyO1xuXG5cdFx0ZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKCBjb250YWluZXIgKTtcblxuXHRcdC8vIE51bGxpZnkgdGhlIGRpdiBzbyBpdCB3b3VsZG4ndCBiZSBzdG9yZWQgaW4gdGhlIG1lbW9yeSBhbmRcblx0XHQvLyBpdCB3aWxsIGFsc28gYmUgYSBzaWduIHRoYXQgY2hlY2tzIGFscmVhZHkgcGVyZm9ybWVkXG5cdFx0ZGl2ID0gbnVsbDtcblx0fVxuXG5cdGZ1bmN0aW9uIHJvdW5kUGl4ZWxNZWFzdXJlcyggbWVhc3VyZSApIHtcblx0XHRyZXR1cm4gTWF0aC5yb3VuZCggcGFyc2VGbG9hdCggbWVhc3VyZSApICk7XG5cdH1cblxuXHR2YXIgcGl4ZWxQb3NpdGlvblZhbCwgYm94U2l6aW5nUmVsaWFibGVWYWwsIHNjcm9sbGJveFNpemVWYWwsIHBpeGVsQm94U3R5bGVzVmFsLFxuXHRcdHJlbGlhYmxlVHJEaW1lbnNpb25zVmFsLCByZWxpYWJsZU1hcmdpbkxlZnRWYWwsXG5cdFx0Y29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLFxuXHRcdGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblxuXHQvLyBGaW5pc2ggZWFybHkgaW4gbGltaXRlZCAobm9uLWJyb3dzZXIpIGVudmlyb25tZW50c1xuXHRpZiAoICFkaXYuc3R5bGUgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHQvLyBTdHlsZSBvZiBjbG9uZWQgZWxlbWVudCBhZmZlY3RzIHNvdXJjZSBlbGVtZW50IGNsb25lZCAoIzg5MDgpXG5cdGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiY29udGVudC1ib3hcIjtcblx0ZGl2LmNsb25lTm9kZSggdHJ1ZSApLnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJcIjtcblx0c3VwcG9ydC5jbGVhckNsb25lU3R5bGUgPSBkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPT09IFwiY29udGVudC1ib3hcIjtcblxuXHRqUXVlcnkuZXh0ZW5kKCBzdXBwb3J0LCB7XG5cdFx0Ym94U2l6aW5nUmVsaWFibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBib3hTaXppbmdSZWxpYWJsZVZhbDtcblx0XHR9LFxuXHRcdHBpeGVsQm94U3R5bGVzOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcGl4ZWxCb3hTdHlsZXNWYWw7XG5cdFx0fSxcblx0XHRwaXhlbFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcGl4ZWxQb3NpdGlvblZhbDtcblx0XHR9LFxuXHRcdHJlbGlhYmxlTWFyZ2luTGVmdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHJlbGlhYmxlTWFyZ2luTGVmdFZhbDtcblx0XHR9LFxuXHRcdHNjcm9sbGJveFNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBzY3JvbGxib3hTaXplVmFsO1xuXHRcdH0sXG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTErLCBFZGdlIDE1IC0gMTgrXG5cdFx0Ly8gSUUvRWRnZSBtaXNyZXBvcnQgYGdldENvbXB1dGVkU3R5bGVgIG9mIHRhYmxlIHJvd3Mgd2l0aCB3aWR0aC9oZWlnaHRcblx0XHQvLyBzZXQgaW4gQ1NTIHdoaWxlIGBvZmZzZXQqYCBwcm9wZXJ0aWVzIHJlcG9ydCBjb3JyZWN0IHZhbHVlcy5cblx0XHQvLyBCZWhhdmlvciBpbiBJRSA5IGlzIG1vcmUgc3VidGxlIHRoYW4gaW4gbmV3ZXIgdmVyc2lvbnMgJiBpdCBwYXNzZXNcblx0XHQvLyBzb21lIHZlcnNpb25zIG9mIHRoaXMgdGVzdDsgbWFrZSBzdXJlIG5vdCB0byBtYWtlIGl0IHBhc3MgdGhlcmUhXG5cdFx0Ly9cblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDcwK1xuXHRcdC8vIE9ubHkgRmlyZWZveCBpbmNsdWRlcyBib3JkZXIgd2lkdGhzXG5cdFx0Ly8gaW4gY29tcHV0ZWQgZGltZW5zaW9ucy4gKGdoLTQ1MjkpXG5cdFx0cmVsaWFibGVUckRpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHRhYmxlLCB0ciwgdHJDaGlsZCwgdHJTdHlsZTtcblx0XHRcdGlmICggcmVsaWFibGVUckRpbWVuc2lvbnNWYWwgPT0gbnVsbCApIHtcblx0XHRcdFx0dGFibGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInRhYmxlXCIgKTtcblx0XHRcdFx0dHIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInRyXCIgKTtcblx0XHRcdFx0dHJDaGlsZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblxuXHRcdFx0XHR0YWJsZS5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0Oi0xMTExMXB4O2JvcmRlci1jb2xsYXBzZTpzZXBhcmF0ZVwiO1xuXHRcdFx0XHR0ci5zdHlsZS5jc3NUZXh0ID0gXCJib3JkZXI6MXB4IHNvbGlkXCI7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDg2K1xuXHRcdFx0XHQvLyBIZWlnaHQgc2V0IHRocm91Z2ggY3NzVGV4dCBkb2VzIG5vdCBnZXQgYXBwbGllZC5cblx0XHRcdFx0Ly8gQ29tcHV0ZWQgaGVpZ2h0IHRoZW4gY29tZXMgYmFjayBhcyAwLlxuXHRcdFx0XHR0ci5zdHlsZS5oZWlnaHQgPSBcIjFweFwiO1xuXHRcdFx0XHR0ckNoaWxkLnN0eWxlLmhlaWdodCA9IFwiOXB4XCI7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA4IENocm9tZSA4Nitcblx0XHRcdFx0Ly8gSW4gb3VyIGJvZHlCYWNrZ3JvdW5kLmh0bWwgaWZyYW1lLFxuXHRcdFx0XHQvLyBkaXNwbGF5IGZvciBhbGwgZGl2IGVsZW1lbnRzIGlzIHNldCB0byBcImlubGluZVwiLFxuXHRcdFx0XHQvLyB3aGljaCBjYXVzZXMgYSBwcm9ibGVtIG9ubHkgaW4gQW5kcm9pZCA4IENocm9tZSA4Ni5cblx0XHRcdFx0Ly8gRW5zdXJpbmcgdGhlIGRpdiBpcyBkaXNwbGF5OiBibG9ja1xuXHRcdFx0XHQvLyBnZXRzIGFyb3VuZCB0aGlzIGlzc3VlLlxuXHRcdFx0XHR0ckNoaWxkLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG5cblx0XHRcdFx0ZG9jdW1lbnRFbGVtZW50XG5cdFx0XHRcdFx0LmFwcGVuZENoaWxkKCB0YWJsZSApXG5cdFx0XHRcdFx0LmFwcGVuZENoaWxkKCB0ciApXG5cdFx0XHRcdFx0LmFwcGVuZENoaWxkKCB0ckNoaWxkICk7XG5cblx0XHRcdFx0dHJTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCB0ciApO1xuXHRcdFx0XHRyZWxpYWJsZVRyRGltZW5zaW9uc1ZhbCA9ICggcGFyc2VJbnQoIHRyU3R5bGUuaGVpZ2h0LCAxMCApICtcblx0XHRcdFx0XHRwYXJzZUludCggdHJTdHlsZS5ib3JkZXJUb3BXaWR0aCwgMTAgKSArXG5cdFx0XHRcdFx0cGFyc2VJbnQoIHRyU3R5bGUuYm9yZGVyQm90dG9tV2lkdGgsIDEwICkgKSA9PT0gdHIub2Zmc2V0SGVpZ2h0O1xuXG5cdFx0XHRcdGRvY3VtZW50RWxlbWVudC5yZW1vdmVDaGlsZCggdGFibGUgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZWxpYWJsZVRyRGltZW5zaW9uc1ZhbDtcblx0XHR9XG5cdH0gKTtcbn0gKSgpO1xuXG5cbmZ1bmN0aW9uIGN1ckNTUyggZWxlbSwgbmFtZSwgY29tcHV0ZWQgKSB7XG5cdHZhciB3aWR0aCwgbWluV2lkdGgsIG1heFdpZHRoLCByZXQsXG5cblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDUxK1xuXHRcdC8vIFJldHJpZXZpbmcgc3R5bGUgYmVmb3JlIGNvbXB1dGVkIHNvbWVob3dcblx0XHQvLyBmaXhlcyBhbiBpc3N1ZSB3aXRoIGdldHRpbmcgd3JvbmcgdmFsdWVzXG5cdFx0Ly8gb24gZGV0YWNoZWQgZWxlbWVudHNcblx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0Y29tcHV0ZWQgPSBjb21wdXRlZCB8fCBnZXRTdHlsZXMoIGVsZW0gKTtcblxuXHQvLyBnZXRQcm9wZXJ0eVZhbHVlIGlzIG5lZWRlZCBmb3I6XG5cdC8vICAgLmNzcygnZmlsdGVyJykgKElFIDkgb25seSwgIzEyNTM3KVxuXHQvLyAgIC5jc3MoJy0tY3VzdG9tUHJvcGVydHkpICgjMzE0NClcblx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRyZXQgPSBjb21wdXRlZC5nZXRQcm9wZXJ0eVZhbHVlKCBuYW1lICkgfHwgY29tcHV0ZWRbIG5hbWUgXTtcblxuXHRcdGlmICggcmV0ID09PSBcIlwiICYmICFpc0F0dGFjaGVkKCBlbGVtICkgKSB7XG5cdFx0XHRyZXQgPSBqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBBIHRyaWJ1dGUgdG8gdGhlIFwiYXdlc29tZSBoYWNrIGJ5IERlYW4gRWR3YXJkc1wiXG5cdFx0Ly8gQW5kcm9pZCBCcm93c2VyIHJldHVybnMgcGVyY2VudGFnZSBmb3Igc29tZSB2YWx1ZXMsXG5cdFx0Ly8gYnV0IHdpZHRoIHNlZW1zIHRvIGJlIHJlbGlhYmx5IHBpeGVscy5cblx0XHQvLyBUaGlzIGlzIGFnYWluc3QgdGhlIENTU09NIGRyYWZ0IHNwZWM6XG5cdFx0Ly8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNyZXNvbHZlZC12YWx1ZXNcblx0XHRpZiAoICFzdXBwb3J0LnBpeGVsQm94U3R5bGVzKCkgJiYgcm51bW5vbnB4LnRlc3QoIHJldCApICYmIHJib3hTdHlsZS50ZXN0KCBuYW1lICkgKSB7XG5cblx0XHRcdC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZXNcblx0XHRcdHdpZHRoID0gc3R5bGUud2lkdGg7XG5cdFx0XHRtaW5XaWR0aCA9IHN0eWxlLm1pbldpZHRoO1xuXHRcdFx0bWF4V2lkdGggPSBzdHlsZS5tYXhXaWR0aDtcblxuXHRcdFx0Ly8gUHV0IGluIHRoZSBuZXcgdmFsdWVzIHRvIGdldCBhIGNvbXB1dGVkIHZhbHVlIG91dFxuXHRcdFx0c3R5bGUubWluV2lkdGggPSBzdHlsZS5tYXhXaWR0aCA9IHN0eWxlLndpZHRoID0gcmV0O1xuXHRcdFx0cmV0ID0gY29tcHV0ZWQud2lkdGg7XG5cblx0XHRcdC8vIFJldmVydCB0aGUgY2hhbmdlZCB2YWx1ZXNcblx0XHRcdHN0eWxlLndpZHRoID0gd2lkdGg7XG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IG1pbldpZHRoO1xuXHRcdFx0c3R5bGUubWF4V2lkdGggPSBtYXhXaWR0aDtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcmV0ICE9PSB1bmRlZmluZWQgP1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHRcdC8vIElFIHJldHVybnMgekluZGV4IHZhbHVlIGFzIGFuIGludGVnZXIuXG5cdFx0cmV0ICsgXCJcIiA6XG5cdFx0cmV0O1xufVxuXG5cbmZ1bmN0aW9uIGFkZEdldEhvb2tJZiggY29uZGl0aW9uRm4sIGhvb2tGbiApIHtcblxuXHQvLyBEZWZpbmUgdGhlIGhvb2ssIHdlJ2xsIGNoZWNrIG9uIHRoZSBmaXJzdCBydW4gaWYgaXQncyByZWFsbHkgbmVlZGVkLlxuXHRyZXR1cm4ge1xuXHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGNvbmRpdGlvbkZuKCkgKSB7XG5cblx0XHRcdFx0Ly8gSG9vayBub3QgbmVlZGVkIChvciBpdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgaXQgZHVlXG5cdFx0XHRcdC8vIHRvIG1pc3NpbmcgZGVwZW5kZW5jeSksIHJlbW92ZSBpdC5cblx0XHRcdFx0ZGVsZXRlIHRoaXMuZ2V0O1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIEhvb2sgbmVlZGVkOyByZWRlZmluZSBpdCBzbyB0aGF0IHRoZSBzdXBwb3J0IHRlc3QgaXMgbm90IGV4ZWN1dGVkIGFnYWluLlxuXHRcdFx0cmV0dXJuICggdGhpcy5nZXQgPSBob29rRm4gKS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fVxuXHR9O1xufVxuXG5cbnZhciBjc3NQcmVmaXhlcyA9IFsgXCJXZWJraXRcIiwgXCJNb3pcIiwgXCJtc1wiIF0sXG5cdGVtcHR5U3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkuc3R5bGUsXG5cdHZlbmRvclByb3BzID0ge307XG5cbi8vIFJldHVybiBhIHZlbmRvci1wcmVmaXhlZCBwcm9wZXJ0eSBvciB1bmRlZmluZWRcbmZ1bmN0aW9uIHZlbmRvclByb3BOYW1lKCBuYW1lICkge1xuXG5cdC8vIENoZWNrIGZvciB2ZW5kb3IgcHJlZml4ZWQgbmFtZXNcblx0dmFyIGNhcE5hbWUgPSBuYW1lWyAwIF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoIDEgKSxcblx0XHRpID0gY3NzUHJlZml4ZXMubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdG5hbWUgPSBjc3NQcmVmaXhlc1sgaSBdICsgY2FwTmFtZTtcblx0XHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcblx0XHRcdHJldHVybiBuYW1lO1xuXHRcdH1cblx0fVxufVxuXG4vLyBSZXR1cm4gYSBwb3RlbnRpYWxseS1tYXBwZWQgalF1ZXJ5LmNzc1Byb3BzIG9yIHZlbmRvciBwcmVmaXhlZCBwcm9wZXJ0eVxuZnVuY3Rpb24gZmluYWxQcm9wTmFtZSggbmFtZSApIHtcblx0dmFyIGZpbmFsID0galF1ZXJ5LmNzc1Byb3BzWyBuYW1lIF0gfHwgdmVuZG9yUHJvcHNbIG5hbWUgXTtcblxuXHRpZiAoIGZpbmFsICkge1xuXHRcdHJldHVybiBmaW5hbDtcblx0fVxuXHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcblx0XHRyZXR1cm4gbmFtZTtcblx0fVxuXHRyZXR1cm4gdmVuZG9yUHJvcHNbIG5hbWUgXSA9IHZlbmRvclByb3BOYW1lKCBuYW1lICkgfHwgbmFtZTtcbn1cblxuXG52YXJcblxuXHQvLyBTd2FwcGFibGUgaWYgZGlzcGxheSBpcyBub25lIG9yIHN0YXJ0cyB3aXRoIHRhYmxlXG5cdC8vIGV4Y2VwdCBcInRhYmxlXCIsIFwidGFibGUtY2VsbFwiLCBvciBcInRhYmxlLWNhcHRpb25cIlxuXHQvLyBTZWUgaGVyZSBmb3IgZGlzcGxheSB2YWx1ZXM6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvQ1NTL2Rpc3BsYXlcblx0cmRpc3BsYXlzd2FwID0gL14obm9uZXx0YWJsZSg/IS1jW2VhXSkuKykvLFxuXHRyY3VzdG9tUHJvcCA9IC9eLS0vLFxuXHRjc3NTaG93ID0geyBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLCB2aXNpYmlsaXR5OiBcImhpZGRlblwiLCBkaXNwbGF5OiBcImJsb2NrXCIgfSxcblx0Y3NzTm9ybWFsVHJhbnNmb3JtID0ge1xuXHRcdGxldHRlclNwYWNpbmc6IFwiMFwiLFxuXHRcdGZvbnRXZWlnaHQ6IFwiNDAwXCJcblx0fTtcblxuZnVuY3Rpb24gc2V0UG9zaXRpdmVOdW1iZXIoIF9lbGVtLCB2YWx1ZSwgc3VidHJhY3QgKSB7XG5cblx0Ly8gQW55IHJlbGF0aXZlICgrLy0pIHZhbHVlcyBoYXZlIGFscmVhZHkgYmVlblxuXHQvLyBub3JtYWxpemVkIGF0IHRoaXMgcG9pbnRcblx0dmFyIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICk7XG5cdHJldHVybiBtYXRjaGVzID9cblxuXHRcdC8vIEd1YXJkIGFnYWluc3QgdW5kZWZpbmVkIFwic3VidHJhY3RcIiwgZS5nLiwgd2hlbiB1c2VkIGFzIGluIGNzc0hvb2tzXG5cdFx0TWF0aC5tYXgoIDAsIG1hdGNoZXNbIDIgXSAtICggc3VidHJhY3QgfHwgMCApICkgKyAoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSA6XG5cdFx0dmFsdWU7XG59XG5cbmZ1bmN0aW9uIGJveE1vZGVsQWRqdXN0bWVudCggZWxlbSwgZGltZW5zaW9uLCBib3gsIGlzQm9yZGVyQm94LCBzdHlsZXMsIGNvbXB1dGVkVmFsICkge1xuXHR2YXIgaSA9IGRpbWVuc2lvbiA9PT0gXCJ3aWR0aFwiID8gMSA6IDAsXG5cdFx0ZXh0cmEgPSAwLFxuXHRcdGRlbHRhID0gMDtcblxuXHQvLyBBZGp1c3RtZW50IG1heSBub3QgYmUgbmVjZXNzYXJ5XG5cdGlmICggYm94ID09PSAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICkgKSB7XG5cdFx0cmV0dXJuIDA7XG5cdH1cblxuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgKSB7XG5cblx0XHQvLyBCb3RoIGJveCBtb2RlbHMgZXhjbHVkZSBtYXJnaW5cblx0XHRpZiAoIGJveCA9PT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdGRlbHRhICs9IGpRdWVyeS5jc3MoIGVsZW0sIGJveCArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHR9XG5cblx0XHQvLyBJZiB3ZSBnZXQgaGVyZSB3aXRoIGEgY29udGVudC1ib3gsIHdlJ3JlIHNlZWtpbmcgXCJwYWRkaW5nXCIgb3IgXCJib3JkZXJcIiBvciBcIm1hcmdpblwiXG5cdFx0aWYgKCAhaXNCb3JkZXJCb3ggKSB7XG5cblx0XHRcdC8vIEFkZCBwYWRkaW5nXG5cdFx0XHRkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblxuXHRcdFx0Ly8gRm9yIFwiYm9yZGVyXCIgb3IgXCJtYXJnaW5cIiwgYWRkIGJvcmRlclxuXHRcdFx0aWYgKCBib3ggIT09IFwicGFkZGluZ1wiICkge1xuXHRcdFx0XHRkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXG5cdFx0XHQvLyBCdXQgc3RpbGwga2VlcCB0cmFjayBvZiBpdCBvdGhlcndpc2Vcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGV4dHJhICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cblx0XHQvLyBJZiB3ZSBnZXQgaGVyZSB3aXRoIGEgYm9yZGVyLWJveCAoY29udGVudCArIHBhZGRpbmcgKyBib3JkZXIpLCB3ZSdyZSBzZWVraW5nIFwiY29udGVudFwiIG9yXG5cdFx0Ly8gXCJwYWRkaW5nXCIgb3IgXCJtYXJnaW5cIlxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIEZvciBcImNvbnRlbnRcIiwgc3VidHJhY3QgcGFkZGluZ1xuXHRcdFx0aWYgKCBib3ggPT09IFwiY29udGVudFwiICkge1xuXHRcdFx0XHRkZWx0YSAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yIFwiY29udGVudFwiIG9yIFwicGFkZGluZ1wiLCBzdWJ0cmFjdCBib3JkZXJcblx0XHRcdGlmICggYm94ICE9PSBcIm1hcmdpblwiICkge1xuXHRcdFx0XHRkZWx0YSAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIEFjY291bnQgZm9yIHBvc2l0aXZlIGNvbnRlbnQtYm94IHNjcm9sbCBndXR0ZXIgd2hlbiByZXF1ZXN0ZWQgYnkgcHJvdmlkaW5nIGNvbXB1dGVkVmFsXG5cdGlmICggIWlzQm9yZGVyQm94ICYmIGNvbXB1dGVkVmFsID49IDAgKSB7XG5cblx0XHQvLyBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgaXMgYSByb3VuZGVkIHN1bSBvZiBjb250ZW50LCBwYWRkaW5nLCBzY3JvbGwgZ3V0dGVyLCBhbmQgYm9yZGVyXG5cdFx0Ly8gQXNzdW1pbmcgaW50ZWdlciBzY3JvbGwgZ3V0dGVyLCBzdWJ0cmFjdCB0aGUgcmVzdCBhbmQgcm91bmQgZG93blxuXHRcdGRlbHRhICs9IE1hdGgubWF4KCAwLCBNYXRoLmNlaWwoXG5cdFx0XHRlbGVtWyBcIm9mZnNldFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApIF0gLVxuXHRcdFx0Y29tcHV0ZWRWYWwgLVxuXHRcdFx0ZGVsdGEgLVxuXHRcdFx0ZXh0cmEgLVxuXHRcdFx0MC41XG5cblx0XHQvLyBJZiBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgaXMgdW5rbm93biwgdGhlbiB3ZSBjYW4ndCBkZXRlcm1pbmUgY29udGVudC1ib3ggc2Nyb2xsIGd1dHRlclxuXHRcdC8vIFVzZSBhbiBleHBsaWNpdCB6ZXJvIHRvIGF2b2lkIE5hTiAoZ2gtMzk2NClcblx0XHQpICkgfHwgMDtcblx0fVxuXG5cdHJldHVybiBkZWx0YTtcbn1cblxuZnVuY3Rpb24gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgZGltZW5zaW9uLCBleHRyYSApIHtcblxuXHQvLyBTdGFydCB3aXRoIGNvbXB1dGVkIHN0eWxlXG5cdHZhciBzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcblxuXHRcdC8vIFRvIGF2b2lkIGZvcmNpbmcgYSByZWZsb3csIG9ubHkgZmV0Y2ggYm94U2l6aW5nIGlmIHdlIG5lZWQgaXQgKGdoLTQzMjIpLlxuXHRcdC8vIEZha2UgY29udGVudC1ib3ggdW50aWwgd2Uga25vdyBpdCdzIG5lZWRlZCB0byBrbm93IHRoZSB0cnVlIHZhbHVlLlxuXHRcdGJveFNpemluZ05lZWRlZCA9ICFzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgfHwgZXh0cmEsXG5cdFx0aXNCb3JkZXJCb3ggPSBib3hTaXppbmdOZWVkZWQgJiZcblx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCIsXG5cdFx0dmFsdWVJc0JvcmRlckJveCA9IGlzQm9yZGVyQm94LFxuXG5cdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBkaW1lbnNpb24sIHN0eWxlcyApLFxuXHRcdG9mZnNldFByb3AgPSBcIm9mZnNldFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApO1xuXG5cdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD01NFxuXHQvLyBSZXR1cm4gYSBjb25mb3VuZGluZyBub24tcGl4ZWwgdmFsdWUgb3IgZmVpZ24gaWdub3JhbmNlLCBhcyBhcHByb3ByaWF0ZS5cblx0aWYgKCBybnVtbm9ucHgudGVzdCggdmFsICkgKSB7XG5cdFx0aWYgKCAhZXh0cmEgKSB7XG5cdFx0XHRyZXR1cm4gdmFsO1xuXHRcdH1cblx0XHR2YWwgPSBcImF1dG9cIjtcblx0fVxuXG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHlcblx0Ly8gVXNlIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBmb3Igd2hlbiBib3ggc2l6aW5nIGlzIHVucmVsaWFibGUuXG5cdC8vIEluIHRob3NlIGNhc2VzLCB0aGUgY29tcHV0ZWQgdmFsdWUgY2FuIGJlIHRydXN0ZWQgdG8gYmUgYm9yZGVyLWJveC5cblx0aWYgKCAoICFzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgJiYgaXNCb3JkZXJCb3ggfHxcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDEwIC0gMTErLCBFZGdlIDE1IC0gMTgrXG5cdFx0Ly8gSUUvRWRnZSBtaXNyZXBvcnQgYGdldENvbXB1dGVkU3R5bGVgIG9mIHRhYmxlIHJvd3Mgd2l0aCB3aWR0aC9oZWlnaHRcblx0XHQvLyBzZXQgaW4gQ1NTIHdoaWxlIGBvZmZzZXQqYCBwcm9wZXJ0aWVzIHJlcG9ydCBjb3JyZWN0IHZhbHVlcy5cblx0XHQvLyBJbnRlcmVzdGluZ2x5LCBpbiBzb21lIGNhc2VzIElFIDkgZG9lc24ndCBzdWZmZXIgZnJvbSB0aGlzIGlzc3VlLlxuXHRcdCFzdXBwb3J0LnJlbGlhYmxlVHJEaW1lbnNpb25zKCkgJiYgbm9kZU5hbWUoIGVsZW0sIFwidHJcIiApIHx8XG5cblx0XHQvLyBGYWxsIGJhY2sgdG8gb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IHdoZW4gdmFsdWUgaXMgXCJhdXRvXCJcblx0XHQvLyBUaGlzIGhhcHBlbnMgZm9yIGlubGluZSBlbGVtZW50cyB3aXRoIG5vIGV4cGxpY2l0IHNldHRpbmcgKGdoLTM1NzEpXG5cdFx0dmFsID09PSBcImF1dG9cIiB8fFxuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMSAtIDQuMyBvbmx5XG5cdFx0Ly8gQWxzbyB1c2Ugb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGZvciBtaXNyZXBvcnRlZCBpbmxpbmUgZGltZW5zaW9ucyAoZ2gtMzYwMilcblx0XHQhcGFyc2VGbG9hdCggdmFsICkgJiYgalF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJpbmxpbmVcIiApICYmXG5cblx0XHQvLyBNYWtlIHN1cmUgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSAmIGNvbm5lY3RlZFxuXHRcdGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKSB7XG5cblx0XHRpc0JvcmRlckJveCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCI7XG5cblx0XHQvLyBXaGVyZSBhdmFpbGFibGUsIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBhcHByb3hpbWF0ZSBib3JkZXIgYm94IGRpbWVuc2lvbnMuXG5cdFx0Ly8gV2hlcmUgbm90IGF2YWlsYWJsZSAoZS5nLiwgU1ZHKSwgYXNzdW1lIHVucmVsaWFibGUgYm94LXNpemluZyBhbmQgaW50ZXJwcmV0IHRoZVxuXHRcdC8vIHJldHJpZXZlZCB2YWx1ZSBhcyBhIGNvbnRlbnQgYm94IGRpbWVuc2lvbi5cblx0XHR2YWx1ZUlzQm9yZGVyQm94ID0gb2Zmc2V0UHJvcCBpbiBlbGVtO1xuXHRcdGlmICggdmFsdWVJc0JvcmRlckJveCApIHtcblx0XHRcdHZhbCA9IGVsZW1bIG9mZnNldFByb3AgXTtcblx0XHR9XG5cdH1cblxuXHQvLyBOb3JtYWxpemUgXCJcIiBhbmQgYXV0b1xuXHR2YWwgPSBwYXJzZUZsb2F0KCB2YWwgKSB8fCAwO1xuXG5cdC8vIEFkanVzdCBmb3IgdGhlIGVsZW1lbnQncyBib3ggbW9kZWxcblx0cmV0dXJuICggdmFsICtcblx0XHRib3hNb2RlbEFkanVzdG1lbnQoXG5cdFx0XHRlbGVtLFxuXHRcdFx0ZGltZW5zaW9uLFxuXHRcdFx0ZXh0cmEgfHwgKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApLFxuXHRcdFx0dmFsdWVJc0JvcmRlckJveCxcblx0XHRcdHN0eWxlcyxcblxuXHRcdFx0Ly8gUHJvdmlkZSB0aGUgY3VycmVudCBjb21wdXRlZCBzaXplIHRvIHJlcXVlc3Qgc2Nyb2xsIGd1dHRlciBjYWxjdWxhdGlvbiAoZ2gtMzU4OSlcblx0XHRcdHZhbFxuXHRcdClcblx0KSArIFwicHhcIjtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIEFkZCBpbiBzdHlsZSBwcm9wZXJ0eSBob29rcyBmb3Igb3ZlcnJpZGluZyB0aGUgZGVmYXVsdFxuXHQvLyBiZWhhdmlvciBvZiBnZXR0aW5nIGFuZCBzZXR0aW5nIGEgc3R5bGUgcHJvcGVydHlcblx0Y3NzSG9va3M6IHtcblx0XHRvcGFjaXR5OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHRcdC8vIFdlIHNob3VsZCBhbHdheXMgZ2V0IGEgbnVtYmVyIGJhY2sgZnJvbSBvcGFjaXR5XG5cdFx0XHRcdFx0dmFyIHJldCA9IGN1ckNTUyggZWxlbSwgXCJvcGFjaXR5XCIgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmV0ID09PSBcIlwiID8gXCIxXCIgOiByZXQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gRG9uJ3QgYXV0b21hdGljYWxseSBhZGQgXCJweFwiIHRvIHRoZXNlIHBvc3NpYmx5LXVuaXRsZXNzIHByb3BlcnRpZXNcblx0Y3NzTnVtYmVyOiB7XG5cdFx0XCJhbmltYXRpb25JdGVyYXRpb25Db3VudFwiOiB0cnVlLFxuXHRcdFwiY29sdW1uQ291bnRcIjogdHJ1ZSxcblx0XHRcImZpbGxPcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJmbGV4R3Jvd1wiOiB0cnVlLFxuXHRcdFwiZmxleFNocmlua1wiOiB0cnVlLFxuXHRcdFwiZm9udFdlaWdodFwiOiB0cnVlLFxuXHRcdFwiZ3JpZEFyZWFcIjogdHJ1ZSxcblx0XHRcImdyaWRDb2x1bW5cIjogdHJ1ZSxcblx0XHRcImdyaWRDb2x1bW5FbmRcIjogdHJ1ZSxcblx0XHRcImdyaWRDb2x1bW5TdGFydFwiOiB0cnVlLFxuXHRcdFwiZ3JpZFJvd1wiOiB0cnVlLFxuXHRcdFwiZ3JpZFJvd0VuZFwiOiB0cnVlLFxuXHRcdFwiZ3JpZFJvd1N0YXJ0XCI6IHRydWUsXG5cdFx0XCJsaW5lSGVpZ2h0XCI6IHRydWUsXG5cdFx0XCJvcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJvcmRlclwiOiB0cnVlLFxuXHRcdFwib3JwaGFuc1wiOiB0cnVlLFxuXHRcdFwid2lkb3dzXCI6IHRydWUsXG5cdFx0XCJ6SW5kZXhcIjogdHJ1ZSxcblx0XHRcInpvb21cIjogdHJ1ZVxuXHR9LFxuXG5cdC8vIEFkZCBpbiBwcm9wZXJ0aWVzIHdob3NlIG5hbWVzIHlvdSB3aXNoIHRvIGZpeCBiZWZvcmVcblx0Ly8gc2V0dGluZyBvciBnZXR0aW5nIHRoZSB2YWx1ZVxuXHRjc3NQcm9wczoge30sXG5cblx0Ly8gR2V0IGFuZCBzZXQgdGhlIHN0eWxlIHByb3BlcnR5IG9uIGEgRE9NIE5vZGVcblx0c3R5bGU6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSwgZXh0cmEgKSB7XG5cblx0XHQvLyBEb24ndCBzZXQgc3R5bGVzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoICFlbGVtIHx8IGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCB8fCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWVcblx0XHR2YXIgcmV0LCB0eXBlLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0gY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KCBuYW1lICksXG5cdFx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XG5cdFx0Ly8gd2FudCB0byBxdWVyeSB0aGUgdmFsdWUgaWYgaXQgaXMgYSBDU1MgY3VzdG9tIHByb3BlcnR5XG5cdFx0Ly8gc2luY2UgdGhleSBhcmUgdXNlci1kZWZpbmVkLlxuXHRcdGlmICggIWlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdG5hbWUgPSBmaW5hbFByb3BOYW1lKCBvcmlnTmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIEdldHMgaG9vayBmb3IgdGhlIHByZWZpeGVkIHZlcnNpb24sIHRoZW4gdW5wcmVmaXhlZCB2ZXJzaW9uXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBDaGVjayBpZiB3ZSdyZSBzZXR0aW5nIGEgdmFsdWVcblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG5cdFx0XHQvLyBDb252ZXJ0IFwiKz1cIiBvciBcIi09XCIgdG8gcmVsYXRpdmUgbnVtYmVycyAoIzczNDUpXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgJiYgKCByZXQgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJiByZXRbIDEgXSApIHtcblx0XHRcdFx0dmFsdWUgPSBhZGp1c3RDU1MoIGVsZW0sIG5hbWUsIHJldCApO1xuXG5cdFx0XHRcdC8vIEZpeGVzIGJ1ZyAjOTIzN1xuXHRcdFx0XHR0eXBlID0gXCJudW1iZXJcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgbnVsbCBhbmQgTmFOIHZhbHVlcyBhcmVuJ3Qgc2V0ICgjNzExNilcblx0XHRcdGlmICggdmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSAhPT0gdmFsdWUgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBudW1iZXIgd2FzIHBhc3NlZCBpbiwgYWRkIHRoZSB1bml0IChleGNlcHQgZm9yIGNlcnRhaW4gQ1NTIHByb3BlcnRpZXMpXG5cdFx0XHQvLyBUaGUgaXNDdXN0b21Qcm9wIGNoZWNrIGNhbiBiZSByZW1vdmVkIGluIGpRdWVyeSA0LjAgd2hlbiB3ZSBvbmx5IGF1dG8tYXBwZW5kXG5cdFx0XHQvLyBcInB4XCIgdG8gYSBmZXcgaGFyZGNvZGVkIHZhbHVlcy5cblx0XHRcdGlmICggdHlwZSA9PT0gXCJudW1iZXJcIiAmJiAhaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0XHR2YWx1ZSArPSByZXQgJiYgcmV0WyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBvcmlnTmFtZSBdID8gXCJcIiA6IFwicHhcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBiYWNrZ3JvdW5kLSogcHJvcHMgYWZmZWN0IG9yaWdpbmFsIGNsb25lJ3MgdmFsdWVzXG5cdFx0XHRpZiAoICFzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSAmJiB2YWx1ZSA9PT0gXCJcIiAmJiBuYW1lLmluZGV4T2YoIFwiYmFja2dyb3VuZFwiICkgPT09IDAgKSB7XG5cdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSBcImluaGVyaXRcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCwgdXNlIHRoYXQgdmFsdWUsIG90aGVyd2lzZSBqdXN0IHNldCB0aGUgc3BlY2lmaWVkIHZhbHVlXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHxcblx0XHRcdFx0KCB2YWx1ZSA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGlmICggaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0XHRcdHN0eWxlLnNldFByb3BlcnR5KCBuYW1lLCB2YWx1ZSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIG5vbi1jb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIGZhbHNlLCBleHRyYSApICkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdGhlcndpc2UganVzdCBnZXQgdGhlIHZhbHVlIGZyb20gdGhlIHN0eWxlIG9iamVjdFxuXHRcdFx0cmV0dXJuIHN0eWxlWyBuYW1lIF07XG5cdFx0fVxuXHR9LFxuXG5cdGNzczogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGV4dHJhLCBzdHlsZXMgKSB7XG5cdFx0dmFyIHZhbCwgbnVtLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0gY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KCBuYW1lICk7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XG5cdFx0Ly8gd2FudCB0byBtb2RpZnkgdGhlIHZhbHVlIGlmIGl0IGlzIGEgQ1NTIGN1c3RvbSBwcm9wZXJ0eVxuXHRcdC8vIHNpbmNlIHRoZXkgYXJlIHVzZXItZGVmaW5lZC5cblx0XHRpZiAoICFpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRuYW1lID0gZmluYWxQcm9wTmFtZSggb3JpZ05hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBUcnkgcHJlZml4ZWQgbmFtZSBmb2xsb3dlZCBieSB0aGUgdW5wcmVmaXhlZCBuYW1lXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbCA9IGhvb2tzLmdldCggZWxlbSwgdHJ1ZSwgZXh0cmEgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2UsIGlmIGEgd2F5IHRvIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZXhpc3RzLCB1c2UgdGhhdFxuXHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIG5hbWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgXCJub3JtYWxcIiB0byBjb21wdXRlZCB2YWx1ZVxuXHRcdGlmICggdmFsID09PSBcIm5vcm1hbFwiICYmIG5hbWUgaW4gY3NzTm9ybWFsVHJhbnNmb3JtICkge1xuXHRcdFx0dmFsID0gY3NzTm9ybWFsVHJhbnNmb3JtWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBudW1lcmljIGlmIGZvcmNlZCBvciBhIHF1YWxpZmllciB3YXMgcHJvdmlkZWQgYW5kIHZhbCBsb29rcyBudW1lcmljXG5cdFx0aWYgKCBleHRyYSA9PT0gXCJcIiB8fCBleHRyYSApIHtcblx0XHRcdG51bSA9IHBhcnNlRmxvYXQoIHZhbCApO1xuXHRcdFx0cmV0dXJuIGV4dHJhID09PSB0cnVlIHx8IGlzRmluaXRlKCBudW0gKSA/IG51bSB8fCAwIDogdmFsO1xuXHRcdH1cblxuXHRcdHJldHVybiB2YWw7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJoZWlnaHRcIiwgXCJ3aWR0aFwiIF0sIGZ1bmN0aW9uKCBfaSwgZGltZW5zaW9uICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIGRpbWVuc2lvbiBdID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkLCBleHRyYSApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHRcdFx0Ly8gQ2VydGFpbiBlbGVtZW50cyBjYW4gaGF2ZSBkaW1lbnNpb24gaW5mbyBpZiB3ZSBpbnZpc2libHkgc2hvdyB0aGVtXG5cdFx0XHRcdC8vIGJ1dCBpdCBtdXN0IGhhdmUgYSBjdXJyZW50IGRpc3BsYXkgc3R5bGUgdGhhdCB3b3VsZCBiZW5lZml0XG5cdFx0XHRcdHJldHVybiByZGlzcGxheXN3YXAudGVzdCggalF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSApICYmXG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgOCtcblx0XHRcdFx0XHQvLyBUYWJsZSBjb2x1bW5zIGluIFNhZmFyaSBoYXZlIG5vbi16ZXJvIG9mZnNldFdpZHRoICYgemVyb1xuXHRcdFx0XHRcdC8vIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIHVubGVzcyBkaXNwbGF5IGlzIGNoYW5nZWQuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdFx0XHRcdFx0Ly8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYSBkaXNjb25uZWN0ZWQgbm9kZVxuXHRcdFx0XHRcdC8vIGluIElFIHRocm93cyBhbiBlcnJvci5cblx0XHRcdFx0XHQoICFlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoIHx8ICFlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoICkgP1xuXHRcdFx0XHRcdHN3YXAoIGVsZW0sIGNzc1Nob3csIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIGRpbWVuc2lvbiwgZXh0cmEgKTtcblx0XHRcdFx0XHR9ICkgOlxuXHRcdFx0XHRcdGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIGRpbWVuc2lvbiwgZXh0cmEgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIGV4dHJhICkge1xuXHRcdFx0dmFyIG1hdGNoZXMsXG5cdFx0XHRcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApLFxuXG5cdFx0XHRcdC8vIE9ubHkgcmVhZCBzdHlsZXMucG9zaXRpb24gaWYgdGhlIHRlc3QgaGFzIGEgY2hhbmNlIHRvIGZhaWxcblx0XHRcdFx0Ly8gdG8gYXZvaWQgZm9yY2luZyBhIHJlZmxvdy5cblx0XHRcdFx0c2Nyb2xsYm94U2l6ZUJ1Z2d5ID0gIXN1cHBvcnQuc2Nyb2xsYm94U2l6ZSgpICYmXG5cdFx0XHRcdFx0c3R5bGVzLnBvc2l0aW9uID09PSBcImFic29sdXRlXCIsXG5cblx0XHRcdFx0Ly8gVG8gYXZvaWQgZm9yY2luZyBhIHJlZmxvdywgb25seSBmZXRjaCBib3hTaXppbmcgaWYgd2UgbmVlZCBpdCAoZ2gtMzk5MSlcblx0XHRcdFx0Ym94U2l6aW5nTmVlZGVkID0gc2Nyb2xsYm94U2l6ZUJ1Z2d5IHx8IGV4dHJhLFxuXHRcdFx0XHRpc0JvcmRlckJveCA9IGJveFNpemluZ05lZWRlZCAmJlxuXHRcdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCIsXG5cdFx0XHRcdHN1YnRyYWN0ID0gZXh0cmEgP1xuXHRcdFx0XHRcdGJveE1vZGVsQWRqdXN0bWVudChcblx0XHRcdFx0XHRcdGVsZW0sXG5cdFx0XHRcdFx0XHRkaW1lbnNpb24sXG5cdFx0XHRcdFx0XHRleHRyYSxcblx0XHRcdFx0XHRcdGlzQm9yZGVyQm94LFxuXHRcdFx0XHRcdFx0c3R5bGVzXG5cdFx0XHRcdFx0KSA6XG5cdFx0XHRcdFx0MDtcblxuXHRcdFx0Ly8gQWNjb3VudCBmb3IgdW5yZWxpYWJsZSBib3JkZXItYm94IGRpbWVuc2lvbnMgYnkgY29tcGFyaW5nIG9mZnNldCogdG8gY29tcHV0ZWQgYW5kXG5cdFx0XHQvLyBmYWtpbmcgYSBjb250ZW50LWJveCB0byBnZXQgYm9yZGVyIGFuZCBwYWRkaW5nIChnaC0zNjk5KVxuXHRcdFx0aWYgKCBpc0JvcmRlckJveCAmJiBzY3JvbGxib3hTaXplQnVnZ3kgKSB7XG5cdFx0XHRcdHN1YnRyYWN0IC09IE1hdGguY2VpbChcblx0XHRcdFx0XHRlbGVtWyBcIm9mZnNldFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApIF0gLVxuXHRcdFx0XHRcdHBhcnNlRmxvYXQoIHN0eWxlc1sgZGltZW5zaW9uIF0gKSAtXG5cdFx0XHRcdFx0Ym94TW9kZWxBZGp1c3RtZW50KCBlbGVtLCBkaW1lbnNpb24sIFwiYm9yZGVyXCIsIGZhbHNlLCBzdHlsZXMgKSAtXG5cdFx0XHRcdFx0MC41XG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnZlcnQgdG8gcGl4ZWxzIGlmIHZhbHVlIGFkanVzdG1lbnQgaXMgbmVlZGVkXG5cdFx0XHRpZiAoIHN1YnRyYWN0ICYmICggbWF0Y2hlcyA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKSApICYmXG5cdFx0XHRcdCggbWF0Y2hlc1sgMyBdIHx8IFwicHhcIiApICE9PSBcInB4XCIgKSB7XG5cblx0XHRcdFx0ZWxlbS5zdHlsZVsgZGltZW5zaW9uIF0gPSB2YWx1ZTtcblx0XHRcdFx0dmFsdWUgPSBqUXVlcnkuY3NzKCBlbGVtLCBkaW1lbnNpb24gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKTtcblx0XHR9XG5cdH07XG59ICk7XG5cbmpRdWVyeS5jc3NIb29rcy5tYXJnaW5MZWZ0ID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnJlbGlhYmxlTWFyZ2luTGVmdCxcblx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRyZXR1cm4gKCBwYXJzZUZsb2F0KCBjdXJDU1MoIGVsZW0sIFwibWFyZ2luTGVmdFwiICkgKSB8fFxuXHRcdFx0XHRlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgLVxuXHRcdFx0XHRcdHN3YXAoIGVsZW0sIHsgbWFyZ2luTGVmdDogMCB9LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG5cdFx0XHRcdFx0fSApXG5cdFx0XHQpICsgXCJweFwiO1xuXHRcdH1cblx0fVxuKTtcblxuLy8gVGhlc2UgaG9va3MgYXJlIHVzZWQgYnkgYW5pbWF0ZSB0byBleHBhbmQgcHJvcGVydGllc1xualF1ZXJ5LmVhY2goIHtcblx0bWFyZ2luOiBcIlwiLFxuXHRwYWRkaW5nOiBcIlwiLFxuXHRib3JkZXI6IFwiV2lkdGhcIlxufSwgZnVuY3Rpb24oIHByZWZpeCwgc3VmZml4ICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdID0ge1xuXHRcdGV4cGFuZDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGkgPSAwLFxuXHRcdFx0XHRleHBhbmRlZCA9IHt9LFxuXG5cdFx0XHRcdC8vIEFzc3VtZXMgYSBzaW5nbGUgbnVtYmVyIGlmIG5vdCBhIHN0cmluZ1xuXHRcdFx0XHRwYXJ0cyA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlLnNwbGl0KCBcIiBcIiApIDogWyB2YWx1ZSBdO1xuXG5cdFx0XHRmb3IgKCA7IGkgPCA0OyBpKysgKSB7XG5cdFx0XHRcdGV4cGFuZGVkWyBwcmVmaXggKyBjc3NFeHBhbmRbIGkgXSArIHN1ZmZpeCBdID1cblx0XHRcdFx0XHRwYXJ0c1sgaSBdIHx8IHBhcnRzWyBpIC0gMiBdIHx8IHBhcnRzWyAwIF07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBleHBhbmRlZDtcblx0XHR9XG5cdH07XG5cblx0aWYgKCBwcmVmaXggIT09IFwibWFyZ2luXCIgKSB7XG5cdFx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXS5zZXQgPSBzZXRQb3NpdGl2ZU51bWJlcjtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGNzczogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdHZhciBzdHlsZXMsIGxlbixcblx0XHRcdFx0bWFwID0ge30sXG5cdFx0XHRcdGkgPSAwO1xuXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG5hbWUgKSApIHtcblx0XHRcdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICk7XG5cdFx0XHRcdGxlbiA9IG5hbWUubGVuZ3RoO1xuXG5cdFx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdG1hcFsgbmFtZVsgaSBdIF0gPSBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lWyBpIF0sIGZhbHNlLCBzdHlsZXMgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBtYXA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lLCB2YWx1ZSApIDpcblx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApO1xuXHRcdH0sIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9XG59ICk7XG5cblxuZnVuY3Rpb24gVHdlZW4oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICkge1xuXHRyZXR1cm4gbmV3IFR3ZWVuLnByb3RvdHlwZS5pbml0KCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApO1xufVxualF1ZXJ5LlR3ZWVuID0gVHdlZW47XG5cblR3ZWVuLnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IFR3ZWVuLFxuXHRpbml0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcsIHVuaXQgKSB7XG5cdFx0dGhpcy5lbGVtID0gZWxlbTtcblx0XHR0aGlzLnByb3AgPSBwcm9wO1xuXHRcdHRoaXMuZWFzaW5nID0gZWFzaW5nIHx8IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHQ7XG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0XHR0aGlzLnN0YXJ0ID0gdGhpcy5ub3cgPSB0aGlzLmN1cigpO1xuXHRcdHRoaXMuZW5kID0gZW5kO1xuXHRcdHRoaXMudW5pdCA9IHVuaXQgfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdH0sXG5cdGN1cjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdHJldHVybiBob29rcyAmJiBob29rcy5nZXQgP1xuXHRcdFx0aG9va3MuZ2V0KCB0aGlzICkgOlxuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LmdldCggdGhpcyApO1xuXHR9LFxuXHRydW46IGZ1bmN0aW9uKCBwZXJjZW50ICkge1xuXHRcdHZhciBlYXNlZCxcblx0XHRcdGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmR1cmF0aW9uICkge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IGpRdWVyeS5lYXNpbmdbIHRoaXMuZWFzaW5nIF0oXG5cdFx0XHRcdHBlcmNlbnQsIHRoaXMub3B0aW9ucy5kdXJhdGlvbiAqIHBlcmNlbnQsIDAsIDEsIHRoaXMub3B0aW9ucy5kdXJhdGlvblxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IHBlcmNlbnQ7XG5cdFx0fVxuXHRcdHRoaXMubm93ID0gKCB0aGlzLmVuZCAtIHRoaXMuc3RhcnQgKSAqIGVhc2VkICsgdGhpcy5zdGFydDtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnN0ZXAgKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKCB0aGlzLmVsZW0sIHRoaXMubm93LCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBob29rcy5zZXQgKSB7XG5cdFx0XHRob29rcy5zZXQoIHRoaXMgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LnNldCggdGhpcyApO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufTtcblxuVHdlZW4ucHJvdG90eXBlLmluaXQucHJvdG90eXBlID0gVHdlZW4ucHJvdG90eXBlO1xuXG5Ud2Vlbi5wcm9wSG9va3MgPSB7XG5cdF9kZWZhdWx0OiB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0XHR2YXIgcmVzdWx0O1xuXG5cdFx0XHQvLyBVc2UgYSBwcm9wZXJ0eSBvbiB0aGUgZWxlbWVudCBkaXJlY3RseSB3aGVuIGl0IGlzIG5vdCBhIERPTSBlbGVtZW50LFxuXHRcdFx0Ly8gb3Igd2hlbiB0aGVyZSBpcyBubyBtYXRjaGluZyBzdHlsZSBwcm9wZXJ0eSB0aGF0IGV4aXN0cy5cblx0XHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAhPT0gMSB8fFxuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gIT0gbnVsbCAmJiB0d2Vlbi5lbGVtLnN0eWxlWyB0d2Vlbi5wcm9wIF0gPT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUGFzc2luZyBhbiBlbXB0eSBzdHJpbmcgYXMgYSAzcmQgcGFyYW1ldGVyIHRvIC5jc3Mgd2lsbCBhdXRvbWF0aWNhbGx5XG5cdFx0XHQvLyBhdHRlbXB0IGEgcGFyc2VGbG9hdCBhbmQgZmFsbGJhY2sgdG8gYSBzdHJpbmcgaWYgdGhlIHBhcnNlIGZhaWxzLlxuXHRcdFx0Ly8gU2ltcGxlIHZhbHVlcyBzdWNoIGFzIFwiMTBweFwiIGFyZSBwYXJzZWQgdG8gRmxvYXQ7XG5cdFx0XHQvLyBjb21wbGV4IHZhbHVlcyBzdWNoIGFzIFwicm90YXRlKDFyYWQpXCIgYXJlIHJldHVybmVkIGFzLWlzLlxuXHRcdFx0cmVzdWx0ID0galF1ZXJ5LmNzcyggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgXCJcIiApO1xuXG5cdFx0XHQvLyBFbXB0eSBzdHJpbmdzLCBudWxsLCB1bmRlZmluZWQgYW5kIFwiYXV0b1wiIGFyZSBjb252ZXJ0ZWQgdG8gMC5cblx0XHRcdHJldHVybiAhcmVzdWx0IHx8IHJlc3VsdCA9PT0gXCJhdXRvXCIgPyAwIDogcmVzdWx0O1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cblx0XHRcdC8vIFVzZSBzdGVwIGhvb2sgZm9yIGJhY2sgY29tcGF0LlxuXHRcdFx0Ly8gVXNlIGNzc0hvb2sgaWYgaXRzIHRoZXJlLlxuXHRcdFx0Ly8gVXNlIC5zdHlsZSBpZiBhdmFpbGFibGUgYW5kIHVzZSBwbGFpbiBwcm9wZXJ0aWVzIHdoZXJlIGF2YWlsYWJsZS5cblx0XHRcdGlmICggalF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSApIHtcblx0XHRcdFx0alF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSggdHdlZW4gKTtcblx0XHRcdH0gZWxzZSBpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKFxuXHRcdFx0XHRqUXVlcnkuY3NzSG9va3NbIHR3ZWVuLnByb3AgXSB8fFxuXHRcdFx0XHRcdHR3ZWVuLmVsZW0uc3R5bGVbIGZpbmFsUHJvcE5hbWUoIHR3ZWVuLnByb3AgKSBdICE9IG51bGwgKSApIHtcblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCB0d2Vlbi5ub3cgKyB0d2Vlbi51bml0ICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuLy8gUGFuaWMgYmFzZWQgYXBwcm9hY2ggdG8gc2V0dGluZyB0aGluZ3Mgb24gZGlzY29ubmVjdGVkIG5vZGVzXG5Ud2Vlbi5wcm9wSG9va3Muc2Nyb2xsVG9wID0gVHdlZW4ucHJvcEhvb2tzLnNjcm9sbExlZnQgPSB7XG5cdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAmJiB0d2Vlbi5lbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkuZWFzaW5nID0ge1xuXHRsaW5lYXI6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiBwO1xuXHR9LFxuXHRzd2luZzogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIDAuNSAtIE1hdGguY29zKCBwICogTWF0aC5QSSApIC8gMjtcblx0fSxcblx0X2RlZmF1bHQ6IFwic3dpbmdcIlxufTtcblxualF1ZXJ5LmZ4ID0gVHdlZW4ucHJvdG90eXBlLmluaXQ7XG5cbi8vIEJhY2sgY29tcGF0IDwxLjggZXh0ZW5zaW9uIHBvaW50XG5qUXVlcnkuZnguc3RlcCA9IHt9O1xuXG5cblxuXG52YXJcblx0ZnhOb3csIGluUHJvZ3Jlc3MsXG5cdHJmeHR5cGVzID0gL14oPzp0b2dnbGV8c2hvd3xoaWRlKSQvLFxuXHRycnVuID0gL3F1ZXVlSG9va3MkLztcblxuZnVuY3Rpb24gc2NoZWR1bGUoKSB7XG5cdGlmICggaW5Qcm9ncmVzcyApIHtcblx0XHRpZiAoIGRvY3VtZW50LmhpZGRlbiA9PT0gZmFsc2UgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSApIHtcblx0XHRcdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIHNjaGVkdWxlICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBzY2hlZHVsZSwgalF1ZXJ5LmZ4LmludGVydmFsICk7XG5cdFx0fVxuXG5cdFx0alF1ZXJ5LmZ4LnRpY2soKTtcblx0fVxufVxuXG4vLyBBbmltYXRpb25zIGNyZWF0ZWQgc3luY2hyb25vdXNseSB3aWxsIHJ1biBzeW5jaHJvbm91c2x5XG5mdW5jdGlvbiBjcmVhdGVGeE5vdygpIHtcblx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdGZ4Tm93ID0gdW5kZWZpbmVkO1xuXHR9ICk7XG5cdHJldHVybiAoIGZ4Tm93ID0gRGF0ZS5ub3coKSApO1xufVxuXG4vLyBHZW5lcmF0ZSBwYXJhbWV0ZXJzIHRvIGNyZWF0ZSBhIHN0YW5kYXJkIGFuaW1hdGlvblxuZnVuY3Rpb24gZ2VuRngoIHR5cGUsIGluY2x1ZGVXaWR0aCApIHtcblx0dmFyIHdoaWNoLFxuXHRcdGkgPSAwLFxuXHRcdGF0dHJzID0geyBoZWlnaHQ6IHR5cGUgfTtcblxuXHQvLyBJZiB3ZSBpbmNsdWRlIHdpZHRoLCBzdGVwIHZhbHVlIGlzIDEgdG8gZG8gYWxsIGNzc0V4cGFuZCB2YWx1ZXMsXG5cdC8vIG90aGVyd2lzZSBzdGVwIHZhbHVlIGlzIDIgdG8gc2tpcCBvdmVyIExlZnQgYW5kIFJpZ2h0XG5cdGluY2x1ZGVXaWR0aCA9IGluY2x1ZGVXaWR0aCA/IDEgOiAwO1xuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgLSBpbmNsdWRlV2lkdGggKSB7XG5cdFx0d2hpY2ggPSBjc3NFeHBhbmRbIGkgXTtcblx0XHRhdHRyc1sgXCJtYXJnaW5cIiArIHdoaWNoIF0gPSBhdHRyc1sgXCJwYWRkaW5nXCIgKyB3aGljaCBdID0gdHlwZTtcblx0fVxuXG5cdGlmICggaW5jbHVkZVdpZHRoICkge1xuXHRcdGF0dHJzLm9wYWNpdHkgPSBhdHRycy53aWR0aCA9IHR5cGU7XG5cdH1cblxuXHRyZXR1cm4gYXR0cnM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVR3ZWVuKCB2YWx1ZSwgcHJvcCwgYW5pbWF0aW9uICkge1xuXHR2YXIgdHdlZW4sXG5cdFx0Y29sbGVjdGlvbiA9ICggQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW10gKS5jb25jYXQoIEFuaW1hdGlvbi50d2VlbmVyc1sgXCIqXCIgXSApLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoICggdHdlZW4gPSBjb2xsZWN0aW9uWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgcHJvcCwgdmFsdWUgKSApICkge1xuXG5cdFx0XHQvLyBXZSdyZSBkb25lIHdpdGggdGhpcyBwcm9wZXJ0eVxuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0UHJlZmlsdGVyKCBlbGVtLCBwcm9wcywgb3B0cyApIHtcblx0dmFyIHByb3AsIHZhbHVlLCB0b2dnbGUsIGhvb2tzLCBvbGRmaXJlLCBwcm9wVHdlZW4sIHJlc3RvcmVEaXNwbGF5LCBkaXNwbGF5LFxuXHRcdGlzQm94ID0gXCJ3aWR0aFwiIGluIHByb3BzIHx8IFwiaGVpZ2h0XCIgaW4gcHJvcHMsXG5cdFx0YW5pbSA9IHRoaXMsXG5cdFx0b3JpZyA9IHt9LFxuXHRcdHN0eWxlID0gZWxlbS5zdHlsZSxcblx0XHRoaWRkZW4gPSBlbGVtLm5vZGVUeXBlICYmIGlzSGlkZGVuV2l0aGluVHJlZSggZWxlbSApLFxuXHRcdGRhdGFTaG93ID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImZ4c2hvd1wiICk7XG5cblx0Ly8gUXVldWUtc2tpcHBpbmcgYW5pbWF0aW9ucyBoaWphY2sgdGhlIGZ4IGhvb2tzXG5cdGlmICggIW9wdHMucXVldWUgKSB7XG5cdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIFwiZnhcIiApO1xuXHRcdGlmICggaG9va3MudW5xdWV1ZWQgPT0gbnVsbCApIHtcblx0XHRcdGhvb2tzLnVucXVldWVkID0gMDtcblx0XHRcdG9sZGZpcmUgPSBob29rcy5lbXB0eS5maXJlO1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICFob29rcy51bnF1ZXVlZCApIHtcblx0XHRcdFx0XHRvbGRmaXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHRcdGhvb2tzLnVucXVldWVkKys7XG5cblx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEVuc3VyZSB0aGUgY29tcGxldGUgaGFuZGxlciBpcyBjYWxsZWQgYmVmb3JlIHRoaXMgY29tcGxldGVzXG5cdFx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGhvb2tzLnVucXVldWVkLS07XG5cdFx0XHRcdGlmICggIWpRdWVyeS5xdWV1ZSggZWxlbSwgXCJmeFwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIERldGVjdCBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRmb3IgKCBwcm9wIGluIHByb3BzICkge1xuXHRcdHZhbHVlID0gcHJvcHNbIHByb3AgXTtcblx0XHRpZiAoIHJmeHR5cGVzLnRlc3QoIHZhbHVlICkgKSB7XG5cdFx0XHRkZWxldGUgcHJvcHNbIHByb3AgXTtcblx0XHRcdHRvZ2dsZSA9IHRvZ2dsZSB8fCB2YWx1ZSA9PT0gXCJ0b2dnbGVcIjtcblx0XHRcdGlmICggdmFsdWUgPT09ICggaGlkZGVuID8gXCJoaWRlXCIgOiBcInNob3dcIiApICkge1xuXG5cdFx0XHRcdC8vIFByZXRlbmQgdG8gYmUgaGlkZGVuIGlmIHRoaXMgaXMgYSBcInNob3dcIiBhbmRcblx0XHRcdFx0Ly8gdGhlcmUgaXMgc3RpbGwgZGF0YSBmcm9tIGEgc3RvcHBlZCBzaG93L2hpZGVcblx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gXCJzaG93XCIgJiYgZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGhpZGRlbiA9IHRydWU7XG5cblx0XHRcdFx0Ly8gSWdub3JlIGFsbCBvdGhlciBuby1vcCBzaG93L2hpZGUgZGF0YVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRvcmlnWyBwcm9wIF0gPSBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdIHx8IGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCApO1xuXHRcdH1cblx0fVxuXG5cdC8vIEJhaWwgb3V0IGlmIHRoaXMgaXMgYSBuby1vcCBsaWtlIC5oaWRlKCkuaGlkZSgpXG5cdHByb3BUd2VlbiA9ICFqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcHMgKTtcblx0aWYgKCAhcHJvcFR3ZWVuICYmIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBvcmlnICkgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gUmVzdHJpY3QgXCJvdmVyZmxvd1wiIGFuZCBcImRpc3BsYXlcIiBzdHlsZXMgZHVyaW5nIGJveCBhbmltYXRpb25zXG5cdGlmICggaXNCb3ggJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExLCBFZGdlIDEyIC0gMTVcblx0XHQvLyBSZWNvcmQgYWxsIDMgb3ZlcmZsb3cgYXR0cmlidXRlcyBiZWNhdXNlIElFIGRvZXMgbm90IGluZmVyIHRoZSBzaG9ydGhhbmRcblx0XHQvLyBmcm9tIGlkZW50aWNhbGx5LXZhbHVlZCBvdmVyZmxvd1ggYW5kIG92ZXJmbG93WSBhbmQgRWRnZSBqdXN0IG1pcnJvcnNcblx0XHQvLyB0aGUgb3ZlcmZsb3dYIHZhbHVlIHRoZXJlLlxuXHRcdG9wdHMub3ZlcmZsb3cgPSBbIHN0eWxlLm92ZXJmbG93LCBzdHlsZS5vdmVyZmxvd1gsIHN0eWxlLm92ZXJmbG93WSBdO1xuXG5cdFx0Ly8gSWRlbnRpZnkgYSBkaXNwbGF5IHR5cGUsIHByZWZlcnJpbmcgb2xkIHNob3cvaGlkZSBkYXRhIG92ZXIgdGhlIENTUyBjYXNjYWRlXG5cdFx0cmVzdG9yZURpc3BsYXkgPSBkYXRhU2hvdyAmJiBkYXRhU2hvdy5kaXNwbGF5O1xuXHRcdGlmICggcmVzdG9yZURpc3BsYXkgPT0gbnVsbCApIHtcblx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdH1cblx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0aWYgKCByZXN0b3JlRGlzcGxheSApIHtcblx0XHRcdFx0ZGlzcGxheSA9IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBHZXQgbm9uZW1wdHkgdmFsdWUocykgYnkgdGVtcG9yYXJpbHkgZm9yY2luZyB2aXNpYmlsaXR5XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSwgdHJ1ZSApO1xuXHRcdFx0XHRyZXN0b3JlRGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheSB8fCByZXN0b3JlRGlzcGxheTtcblx0XHRcdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFuaW1hdGUgaW5saW5lIGVsZW1lbnRzIGFzIGlubGluZS1ibG9ja1xuXHRcdGlmICggZGlzcGxheSA9PT0gXCJpbmxpbmVcIiB8fCBkaXNwbGF5ID09PSBcImlubGluZS1ibG9ja1wiICYmIHJlc3RvcmVEaXNwbGF5ICE9IG51bGwgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5jc3MoIGVsZW0sIFwiZmxvYXRcIiApID09PSBcIm5vbmVcIiApIHtcblxuXHRcdFx0XHQvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBkaXNwbGF5IHZhbHVlIGF0IHRoZSBlbmQgb2YgcHVyZSBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRcdFx0XHRpZiAoICFwcm9wVHdlZW4gKSB7XG5cdFx0XHRcdFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHN0eWxlLmRpc3BsYXkgPSByZXN0b3JlRGlzcGxheTtcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0aWYgKCByZXN0b3JlRGlzcGxheSA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0ZGlzcGxheSA9IHN0eWxlLmRpc3BsYXk7XG5cdFx0XHRcdFx0XHRyZXN0b3JlRGlzcGxheSA9IGRpc3BsYXkgPT09IFwibm9uZVwiID8gXCJcIiA6IGRpc3BsYXk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmICggb3B0cy5vdmVyZmxvdyApIHtcblx0XHRzdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG5cdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXHRcdFx0c3R5bGUub3ZlcmZsb3cgPSBvcHRzLm92ZXJmbG93WyAwIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1ggPSBvcHRzLm92ZXJmbG93WyAxIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1kgPSBvcHRzLm92ZXJmbG93WyAyIF07XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gSW1wbGVtZW50IHNob3cvaGlkZSBhbmltYXRpb25zXG5cdHByb3BUd2VlbiA9IGZhbHNlO1xuXHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cblx0XHQvLyBHZW5lcmFsIHNob3cvaGlkZSBzZXR1cCBmb3IgdGhpcyBlbGVtZW50IGFuaW1hdGlvblxuXHRcdGlmICggIXByb3BUd2VlbiApIHtcblx0XHRcdGlmICggZGF0YVNob3cgKSB7XG5cdFx0XHRcdGlmICggXCJoaWRkZW5cIiBpbiBkYXRhU2hvdyApIHtcblx0XHRcdFx0XHRoaWRkZW4gPSBkYXRhU2hvdy5oaWRkZW47XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRhdGFTaG93ID0gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBcImZ4c2hvd1wiLCB7IGRpc3BsYXk6IHJlc3RvcmVEaXNwbGF5IH0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RvcmUgaGlkZGVuL3Zpc2libGUgZm9yIHRvZ2dsZSBzbyBgLnN0b3AoKS50b2dnbGUoKWAgXCJyZXZlcnNlc1wiXG5cdFx0XHRpZiAoIHRvZ2dsZSApIHtcblx0XHRcdFx0ZGF0YVNob3cuaGlkZGVuID0gIWhpZGRlbjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2hvdyBlbGVtZW50cyBiZWZvcmUgYW5pbWF0aW5nIHRoZW1cblx0XHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0sIHRydWUgKTtcblx0XHRcdH1cblxuXHRcdFx0LyogZXNsaW50LWRpc2FibGUgbm8tbG9vcC1mdW5jICovXG5cblx0XHRcdGFuaW0uZG9uZSggZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0LyogZXNsaW50LWVuYWJsZSBuby1sb29wLWZ1bmMgKi9cblxuXHRcdFx0XHQvLyBUaGUgZmluYWwgc3RlcCBvZiBhIFwiaGlkZVwiIGFuaW1hdGlvbiBpcyBhY3R1YWxseSBoaWRpbmcgdGhlIGVsZW1lbnRcblx0XHRcdFx0aWYgKCAhaGlkZGVuICkge1xuXHRcdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJmeHNob3dcIiApO1xuXHRcdFx0XHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBvcmlnWyBwcm9wIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdC8vIFBlci1wcm9wZXJ0eSBzZXR1cFxuXHRcdHByb3BUd2VlbiA9IGNyZWF0ZVR3ZWVuKCBoaWRkZW4gPyBkYXRhU2hvd1sgcHJvcCBdIDogMCwgcHJvcCwgYW5pbSApO1xuXHRcdGlmICggISggcHJvcCBpbiBkYXRhU2hvdyApICkge1xuXHRcdFx0ZGF0YVNob3dbIHByb3AgXSA9IHByb3BUd2Vlbi5zdGFydDtcblx0XHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0XHRwcm9wVHdlZW4uZW5kID0gcHJvcFR3ZWVuLnN0YXJ0O1xuXHRcdFx0XHRwcm9wVHdlZW4uc3RhcnQgPSAwO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBwcm9wRmlsdGVyKCBwcm9wcywgc3BlY2lhbEVhc2luZyApIHtcblx0dmFyIGluZGV4LCBuYW1lLCBlYXNpbmcsIHZhbHVlLCBob29rcztcblxuXHQvLyBjYW1lbENhc2UsIHNwZWNpYWxFYXNpbmcgYW5kIGV4cGFuZCBjc3NIb29rIHBhc3Ncblx0Zm9yICggaW5kZXggaW4gcHJvcHMgKSB7XG5cdFx0bmFtZSA9IGNhbWVsQ2FzZSggaW5kZXggKTtcblx0XHRlYXNpbmcgPSBzcGVjaWFsRWFzaW5nWyBuYW1lIF07XG5cdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRlYXNpbmcgPSB2YWx1ZVsgMSBdO1xuXHRcdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyAwIF07XG5cdFx0fVxuXG5cdFx0aWYgKCBpbmRleCAhPT0gbmFtZSApIHtcblx0XHRcdHByb3BzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgaW5kZXggXTtcblx0XHR9XG5cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdO1xuXHRcdGlmICggaG9va3MgJiYgXCJleHBhbmRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbHVlID0gaG9va3MuZXhwYW5kKCB2YWx1ZSApO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBuYW1lIF07XG5cblx0XHRcdC8vIE5vdCBxdWl0ZSAkLmV4dGVuZCwgdGhpcyB3b24ndCBvdmVyd3JpdGUgZXhpc3Rpbmcga2V5cy5cblx0XHRcdC8vIFJldXNpbmcgJ2luZGV4JyBiZWNhdXNlIHdlIGhhdmUgdGhlIGNvcnJlY3QgXCJuYW1lXCJcblx0XHRcdGZvciAoIGluZGV4IGluIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICEoIGluZGV4IGluIHByb3BzICkgKSB7XG5cdFx0XHRcdFx0cHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgaW5kZXggXTtcblx0XHRcdFx0XHRzcGVjaWFsRWFzaW5nWyBpbmRleCBdID0gZWFzaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNwZWNpYWxFYXNpbmdbIG5hbWUgXSA9IGVhc2luZztcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gQW5pbWF0aW9uKCBlbGVtLCBwcm9wZXJ0aWVzLCBvcHRpb25zICkge1xuXHR2YXIgcmVzdWx0LFxuXHRcdHN0b3BwZWQsXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzLmxlbmd0aCxcblx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIERvbid0IG1hdGNoIGVsZW0gaW4gdGhlIDphbmltYXRlZCBzZWxlY3RvclxuXHRcdFx0ZGVsZXRlIHRpY2suZWxlbTtcblx0XHR9ICksXG5cdFx0dGljayA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBzdG9wcGVkICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR2YXIgY3VycmVudFRpbWUgPSBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0XHRyZW1haW5pbmcgPSBNYXRoLm1heCggMCwgYW5pbWF0aW9uLnN0YXJ0VGltZSArIGFuaW1hdGlvbi5kdXJhdGlvbiAtIGN1cnJlbnRUaW1lICksXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCAyLjMgb25seVxuXHRcdFx0XHQvLyBBcmNoYWljIGNyYXNoIGJ1ZyB3b24ndCBhbGxvdyB1cyB0byB1c2UgYDEgLSAoIDAuNSB8fCAwIClgICgjMTI0OTcpXG5cdFx0XHRcdHRlbXAgPSByZW1haW5pbmcgLyBhbmltYXRpb24uZHVyYXRpb24gfHwgMCxcblx0XHRcdFx0cGVyY2VudCA9IDEgLSB0ZW1wLFxuXHRcdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRcdGxlbmd0aCA9IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoO1xuXG5cdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggcGVyY2VudCApO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgcGVyY2VudCwgcmVtYWluaW5nIF0gKTtcblxuXHRcdFx0Ly8gSWYgdGhlcmUncyBtb3JlIHRvIGRvLCB5aWVsZFxuXHRcdFx0aWYgKCBwZXJjZW50IDwgMSAmJiBsZW5ndGggKSB7XG5cdFx0XHRcdHJldHVybiByZW1haW5pbmc7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoaXMgd2FzIGFuIGVtcHR5IGFuaW1hdGlvbiwgc3ludGhlc2l6ZSBhIGZpbmFsIHByb2dyZXNzIG5vdGlmaWNhdGlvblxuXHRcdFx0aWYgKCAhbGVuZ3RoICkge1xuXHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlc29sdmUgdGhlIGFuaW1hdGlvbiBhbmQgcmVwb3J0IGl0cyBjb25jbHVzaW9uXG5cdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24gXSApO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cdFx0YW5pbWF0aW9uID0gZGVmZXJyZWQucHJvbWlzZSgge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdHByb3BzOiBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcGVydGllcyApLFxuXHRcdFx0b3B0czogalF1ZXJ5LmV4dGVuZCggdHJ1ZSwge1xuXHRcdFx0XHRzcGVjaWFsRWFzaW5nOiB7fSxcblx0XHRcdFx0ZWFzaW5nOiBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0XG5cdFx0XHR9LCBvcHRpb25zICksXG5cdFx0XHRvcmlnaW5hbFByb3BlcnRpZXM6IHByb3BlcnRpZXMsXG5cdFx0XHRvcmlnaW5hbE9wdGlvbnM6IG9wdGlvbnMsXG5cdFx0XHRzdGFydFRpbWU6IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcblx0XHRcdHR3ZWVuczogW10sXG5cdFx0XHRjcmVhdGVUd2VlbjogZnVuY3Rpb24oIHByb3AsIGVuZCApIHtcblx0XHRcdFx0dmFyIHR3ZWVuID0galF1ZXJ5LlR3ZWVuKCBlbGVtLCBhbmltYXRpb24ub3B0cywgcHJvcCwgZW5kLFxuXHRcdFx0XHRcdGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmdbIHByb3AgXSB8fCBhbmltYXRpb24ub3B0cy5lYXNpbmcgKTtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVucy5wdXNoKCB0d2VlbiApO1xuXHRcdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0XHR9LFxuXHRcdFx0c3RvcDogZnVuY3Rpb24oIGdvdG9FbmQgKSB7XG5cdFx0XHRcdHZhciBpbmRleCA9IDAsXG5cblx0XHRcdFx0XHQvLyBJZiB3ZSBhcmUgZ29pbmcgdG8gdGhlIGVuZCwgd2Ugd2FudCB0byBydW4gYWxsIHRoZSB0d2VlbnNcblx0XHRcdFx0XHQvLyBvdGhlcndpc2Ugd2Ugc2tpcCB0aGlzIHBhcnRcblx0XHRcdFx0XHRsZW5ndGggPSBnb3RvRW5kID8gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGggOiAwO1xuXHRcdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3RvcHBlZCA9IHRydWU7XG5cdFx0XHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIDEgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlc29sdmUgd2hlbiB3ZSBwbGF5ZWQgdGhlIGxhc3QgZnJhbWU7IG90aGVyd2lzZSwgcmVqZWN0XG5cdFx0XHRcdGlmICggZ290b0VuZCApIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cdFx0fSApLFxuXHRcdHByb3BzID0gYW5pbWF0aW9uLnByb3BzO1xuXG5cdHByb3BGaWx0ZXIoIHByb3BzLCBhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nICk7XG5cblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRyZXN1bHQgPSBBbmltYXRpb24ucHJlZmlsdGVyc1sgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIGVsZW0sIHByb3BzLCBhbmltYXRpb24ub3B0cyApO1xuXHRcdGlmICggcmVzdWx0ICkge1xuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCByZXN1bHQuc3RvcCApICkge1xuXHRcdFx0XHRqUXVlcnkuX3F1ZXVlSG9va3MoIGFuaW1hdGlvbi5lbGVtLCBhbmltYXRpb24ub3B0cy5xdWV1ZSApLnN0b3AgPVxuXHRcdFx0XHRcdHJlc3VsdC5zdG9wLmJpbmQoIHJlc3VsdCApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9XG5cdH1cblxuXHRqUXVlcnkubWFwKCBwcm9wcywgY3JlYXRlVHdlZW4sIGFuaW1hdGlvbiApO1xuXG5cdGlmICggaXNGdW5jdGlvbiggYW5pbWF0aW9uLm9wdHMuc3RhcnQgKSApIHtcblx0XHRhbmltYXRpb24ub3B0cy5zdGFydC5jYWxsKCBlbGVtLCBhbmltYXRpb24gKTtcblx0fVxuXG5cdC8vIEF0dGFjaCBjYWxsYmFja3MgZnJvbSBvcHRpb25zXG5cdGFuaW1hdGlvblxuXHRcdC5wcm9ncmVzcyggYW5pbWF0aW9uLm9wdHMucHJvZ3Jlc3MgKVxuXHRcdC5kb25lKCBhbmltYXRpb24ub3B0cy5kb25lLCBhbmltYXRpb24ub3B0cy5jb21wbGV0ZSApXG5cdFx0LmZhaWwoIGFuaW1hdGlvbi5vcHRzLmZhaWwgKVxuXHRcdC5hbHdheXMoIGFuaW1hdGlvbi5vcHRzLmFsd2F5cyApO1xuXG5cdGpRdWVyeS5meC50aW1lcihcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aWNrLCB7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0YW5pbTogYW5pbWF0aW9uLFxuXHRcdFx0cXVldWU6IGFuaW1hdGlvbi5vcHRzLnF1ZXVlXG5cdFx0fSApXG5cdCk7XG5cblx0cmV0dXJuIGFuaW1hdGlvbjtcbn1cblxualF1ZXJ5LkFuaW1hdGlvbiA9IGpRdWVyeS5leHRlbmQoIEFuaW1hdGlvbiwge1xuXG5cdHR3ZWVuZXJzOiB7XG5cdFx0XCIqXCI6IFsgZnVuY3Rpb24oIHByb3AsIHZhbHVlICkge1xuXHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5jcmVhdGVUd2VlbiggcHJvcCwgdmFsdWUgKTtcblx0XHRcdGFkanVzdENTUyggdHdlZW4uZWxlbSwgcHJvcCwgcmNzc051bS5leGVjKCB2YWx1ZSApLCB0d2VlbiApO1xuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH0gXVxuXHR9LFxuXG5cdHR3ZWVuZXI6IGZ1bmN0aW9uKCBwcm9wcywgY2FsbGJhY2sgKSB7XG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBwcm9wcyApICkge1xuXHRcdFx0Y2FsbGJhY2sgPSBwcm9wcztcblx0XHRcdHByb3BzID0gWyBcIipcIiBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwcm9wcyA9IHByb3BzLm1hdGNoKCBybm90aHRtbHdoaXRlICk7XG5cdFx0fVxuXG5cdFx0dmFyIHByb3AsXG5cdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0cHJvcCA9IHByb3BzWyBpbmRleCBdO1xuXHRcdFx0QW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gPSBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXTtcblx0XHRcdEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9LFxuXG5cdHByZWZpbHRlcnM6IFsgZGVmYXVsdFByZWZpbHRlciBdLFxuXG5cdHByZWZpbHRlcjogZnVuY3Rpb24oIGNhbGxiYWNrLCBwcmVwZW5kICkge1xuXHRcdGlmICggcHJlcGVuZCApIHtcblx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnB1c2goIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cbmpRdWVyeS5zcGVlZCA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBmbiApIHtcblx0dmFyIG9wdCA9IHNwZWVkICYmIHR5cGVvZiBzcGVlZCA9PT0gXCJvYmplY3RcIiA/IGpRdWVyeS5leHRlbmQoIHt9LCBzcGVlZCApIDoge1xuXHRcdGNvbXBsZXRlOiBmbiB8fCAhZm4gJiYgZWFzaW5nIHx8XG5cdFx0XHRpc0Z1bmN0aW9uKCBzcGVlZCApICYmIHNwZWVkLFxuXHRcdGR1cmF0aW9uOiBzcGVlZCxcblx0XHRlYXNpbmc6IGZuICYmIGVhc2luZyB8fCBlYXNpbmcgJiYgIWlzRnVuY3Rpb24oIGVhc2luZyApICYmIGVhc2luZ1xuXHR9O1xuXG5cdC8vIEdvIHRvIHRoZSBlbmQgc3RhdGUgaWYgZnggYXJlIG9mZlxuXHRpZiAoIGpRdWVyeS5meC5vZmYgKSB7XG5cdFx0b3B0LmR1cmF0aW9uID0gMDtcblxuXHR9IGVsc2Uge1xuXHRcdGlmICggdHlwZW9mIG9wdC5kdXJhdGlvbiAhPT0gXCJudW1iZXJcIiApIHtcblx0XHRcdGlmICggb3B0LmR1cmF0aW9uIGluIGpRdWVyeS5meC5zcGVlZHMgKSB7XG5cdFx0XHRcdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5zcGVlZHNbIG9wdC5kdXJhdGlvbiBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvcHQuZHVyYXRpb24gPSBqUXVlcnkuZnguc3BlZWRzLl9kZWZhdWx0O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIE5vcm1hbGl6ZSBvcHQucXVldWUgLSB0cnVlL3VuZGVmaW5lZC9udWxsIC0+IFwiZnhcIlxuXHRpZiAoIG9wdC5xdWV1ZSA9PSBudWxsIHx8IG9wdC5xdWV1ZSA9PT0gdHJ1ZSApIHtcblx0XHRvcHQucXVldWUgPSBcImZ4XCI7XG5cdH1cblxuXHQvLyBRdWV1ZWluZ1xuXHRvcHQub2xkID0gb3B0LmNvbXBsZXRlO1xuXG5cdG9wdC5jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggaXNGdW5jdGlvbiggb3B0Lm9sZCApICkge1xuXHRcdFx0b3B0Lm9sZC5jYWxsKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHQucXVldWUgKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgb3B0LnF1ZXVlICk7XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiBvcHQ7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGZhZGVUbzogZnVuY3Rpb24oIHNwZWVkLCB0bywgZWFzaW5nLCBjYWxsYmFjayApIHtcblxuXHRcdC8vIFNob3cgYW55IGhpZGRlbiBlbGVtZW50cyBhZnRlciBzZXR0aW5nIG9wYWNpdHkgdG8gMFxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggaXNIaWRkZW5XaXRoaW5UcmVlICkuY3NzKCBcIm9wYWNpdHlcIiwgMCApLnNob3coKVxuXG5cdFx0XHQvLyBBbmltYXRlIHRvIHRoZSB2YWx1ZSBzcGVjaWZpZWRcblx0XHRcdC5lbmQoKS5hbmltYXRlKCB7IG9wYWNpdHk6IHRvIH0sIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH0sXG5cdGFuaW1hdGU6IGZ1bmN0aW9uKCBwcm9wLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHR2YXIgZW1wdHkgPSBqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcCApLFxuXHRcdFx0b3B0YWxsID0galF1ZXJ5LnNwZWVkKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApLFxuXHRcdFx0ZG9BbmltYXRpb24gPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBPcGVyYXRlIG9uIGEgY29weSBvZiBwcm9wIHNvIHBlci1wcm9wZXJ0eSBlYXNpbmcgd29uJ3QgYmUgbG9zdFxuXHRcdFx0XHR2YXIgYW5pbSA9IEFuaW1hdGlvbiggdGhpcywgalF1ZXJ5LmV4dGVuZCgge30sIHByb3AgKSwgb3B0YWxsICk7XG5cblx0XHRcdFx0Ly8gRW1wdHkgYW5pbWF0aW9ucywgb3IgZmluaXNoaW5nIHJlc29sdmVzIGltbWVkaWF0ZWx5XG5cdFx0XHRcdGlmICggZW1wdHkgfHwgZGF0YVByaXYuZ2V0KCB0aGlzLCBcImZpbmlzaFwiICkgKSB7XG5cdFx0XHRcdFx0YW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRkb0FuaW1hdGlvbi5maW5pc2ggPSBkb0FuaW1hdGlvbjtcblxuXHRcdHJldHVybiBlbXB0eSB8fCBvcHRhbGwucXVldWUgPT09IGZhbHNlID9cblx0XHRcdHRoaXMuZWFjaCggZG9BbmltYXRpb24gKSA6XG5cdFx0XHR0aGlzLnF1ZXVlKCBvcHRhbGwucXVldWUsIGRvQW5pbWF0aW9uICk7XG5cdH0sXG5cdHN0b3A6IGZ1bmN0aW9uKCB0eXBlLCBjbGVhclF1ZXVlLCBnb3RvRW5kICkge1xuXHRcdHZhciBzdG9wUXVldWUgPSBmdW5jdGlvbiggaG9va3MgKSB7XG5cdFx0XHR2YXIgc3RvcCA9IGhvb2tzLnN0b3A7XG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdHN0b3AoIGdvdG9FbmQgKTtcblx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGdvdG9FbmQgPSBjbGVhclF1ZXVlO1xuXHRcdFx0Y2xlYXJRdWV1ZSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGNsZWFyUXVldWUgKSB7XG5cdFx0XHR0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBkZXF1ZXVlID0gdHJ1ZSxcblx0XHRcdFx0aW5kZXggPSB0eXBlICE9IG51bGwgJiYgdHlwZSArIFwicXVldWVIb29rc1wiLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICk7XG5cblx0XHRcdGlmICggaW5kZXggKSB7XG5cdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgKSB7XG5cdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAoIGluZGV4IGluIGRhdGEgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCAmJiBycnVuLnRlc3QoIGluZGV4ICkgKSB7XG5cdFx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJlxuXHRcdFx0XHRcdCggdHlwZSA9PSBudWxsIHx8IHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApICkge1xuXG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggZ290b0VuZCApO1xuXHRcdFx0XHRcdGRlcXVldWUgPSBmYWxzZTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXJ0IHRoZSBuZXh0IGluIHRoZSBxdWV1ZSBpZiB0aGUgbGFzdCBzdGVwIHdhc24ndCBmb3JjZWQuXG5cdFx0XHQvLyBUaW1lcnMgY3VycmVudGx5IHdpbGwgY2FsbCB0aGVpciBjb21wbGV0ZSBjYWxsYmFja3MsIHdoaWNoXG5cdFx0XHQvLyB3aWxsIGRlcXVldWUgYnV0IG9ubHkgaWYgdGhleSB3ZXJlIGdvdG9FbmQuXG5cdFx0XHRpZiAoIGRlcXVldWUgfHwgIWdvdG9FbmQgKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXHRmaW5pc2g6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdGlmICggdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGluZGV4LFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICksXG5cdFx0XHRcdHF1ZXVlID0gZGF0YVsgdHlwZSArIFwicXVldWVcIiBdLFxuXHRcdFx0XHRob29rcyA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlSG9va3NcIiBdLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRsZW5ndGggPSBxdWV1ZSA/IHF1ZXVlLmxlbmd0aCA6IDA7XG5cblx0XHRcdC8vIEVuYWJsZSBmaW5pc2hpbmcgZmxhZyBvbiBwcml2YXRlIGRhdGFcblx0XHRcdGRhdGEuZmluaXNoID0gdHJ1ZTtcblxuXHRcdFx0Ly8gRW1wdHkgdGhlIHF1ZXVlIGZpcnN0XG5cdFx0XHRqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIFtdICk7XG5cblx0XHRcdGlmICggaG9va3MgJiYgaG9va3Muc3RvcCApIHtcblx0XHRcdFx0aG9va3Muc3RvcC5jYWxsKCB0aGlzLCB0cnVlICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhY3RpdmUgYW5pbWF0aW9ucywgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmIHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApIHtcblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb29rIGZvciBhbnkgYW5pbWF0aW9ucyBpbiB0aGUgb2xkIHF1ZXVlIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0aWYgKCBxdWV1ZVsgaW5kZXggXSAmJiBxdWV1ZVsgaW5kZXggXS5maW5pc2ggKSB7XG5cdFx0XHRcdFx0cXVldWVbIGluZGV4IF0uZmluaXNoLmNhbGwoIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUdXJuIG9mZiBmaW5pc2hpbmcgZmxhZ1xuXHRcdFx0ZGVsZXRlIGRhdGEuZmluaXNoO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcInRvZ2dsZVwiLCBcInNob3dcIiwgXCJoaWRlXCIgXSwgZnVuY3Rpb24oIF9pLCBuYW1lICkge1xuXHR2YXIgY3NzRm4gPSBqUXVlcnkuZm5bIG5hbWUgXTtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHNwZWVkID09IG51bGwgfHwgdHlwZW9mIHNwZWVkID09PSBcImJvb2xlYW5cIiA/XG5cdFx0XHRjc3NGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICkgOlxuXHRcdFx0dGhpcy5hbmltYXRlKCBnZW5GeCggbmFtZSwgdHJ1ZSApLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSApO1xuXG4vLyBHZW5lcmF0ZSBzaG9ydGN1dHMgZm9yIGN1c3RvbSBhbmltYXRpb25zXG5qUXVlcnkuZWFjaCgge1xuXHRzbGlkZURvd246IGdlbkZ4KCBcInNob3dcIiApLFxuXHRzbGlkZVVwOiBnZW5GeCggXCJoaWRlXCIgKSxcblx0c2xpZGVUb2dnbGU6IGdlbkZ4KCBcInRvZ2dsZVwiICksXG5cdGZhZGVJbjogeyBvcGFjaXR5OiBcInNob3dcIiB9LFxuXHRmYWRlT3V0OiB7IG9wYWNpdHk6IFwiaGlkZVwiIH0sXG5cdGZhZGVUb2dnbGU6IHsgb3BhY2l0eTogXCJ0b2dnbGVcIiB9XG59LCBmdW5jdGlvbiggbmFtZSwgcHJvcHMgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLmFuaW1hdGUoIHByb3BzLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSApO1xuXG5qUXVlcnkudGltZXJzID0gW107XG5qUXVlcnkuZngudGljayA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgdGltZXIsXG5cdFx0aSA9IDAsXG5cdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycztcblxuXHRmeE5vdyA9IERhdGUubm93KCk7XG5cblx0Zm9yICggOyBpIDwgdGltZXJzLmxlbmd0aDsgaSsrICkge1xuXHRcdHRpbWVyID0gdGltZXJzWyBpIF07XG5cblx0XHQvLyBSdW4gdGhlIHRpbWVyIGFuZCBzYWZlbHkgcmVtb3ZlIGl0IHdoZW4gZG9uZSAoYWxsb3dpbmcgZm9yIGV4dGVybmFsIHJlbW92YWwpXG5cdFx0aWYgKCAhdGltZXIoKSAmJiB0aW1lcnNbIGkgXSA9PT0gdGltZXIgKSB7XG5cdFx0XHR0aW1lcnMuc3BsaWNlKCBpLS0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoICF0aW1lcnMubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5meC5zdG9wKCk7XG5cdH1cblx0ZnhOb3cgPSB1bmRlZmluZWQ7XG59O1xuXG5qUXVlcnkuZngudGltZXIgPSBmdW5jdGlvbiggdGltZXIgKSB7XG5cdGpRdWVyeS50aW1lcnMucHVzaCggdGltZXIgKTtcblx0alF1ZXJ5LmZ4LnN0YXJ0KCk7XG59O1xuXG5qUXVlcnkuZnguaW50ZXJ2YWwgPSAxMztcbmpRdWVyeS5meC5zdGFydCA9IGZ1bmN0aW9uKCkge1xuXHRpZiAoIGluUHJvZ3Jlc3MgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aW5Qcm9ncmVzcyA9IHRydWU7XG5cdHNjaGVkdWxlKCk7XG59O1xuXG5qUXVlcnkuZnguc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRpblByb2dyZXNzID0gbnVsbDtcbn07XG5cbmpRdWVyeS5meC5zcGVlZHMgPSB7XG5cdHNsb3c6IDYwMCxcblx0ZmFzdDogMjAwLFxuXG5cdC8vIERlZmF1bHQgc3BlZWRcblx0X2RlZmF1bHQ6IDQwMFxufTtcblxuXG4vLyBCYXNlZCBvZmYgb2YgdGhlIHBsdWdpbiBieSBDbGludCBIZWxmZXJzLCB3aXRoIHBlcm1pc3Npb24uXG4vLyBodHRwczovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxMDAzMjQwMTQ3NDcvaHR0cDovL2JsaW5kc2lnbmFscy5jb20vaW5kZXgucGhwLzIwMDkvMDcvanF1ZXJ5LWRlbGF5L1xualF1ZXJ5LmZuLmRlbGF5ID0gZnVuY3Rpb24oIHRpbWUsIHR5cGUgKSB7XG5cdHRpbWUgPSBqUXVlcnkuZnggPyBqUXVlcnkuZnguc3BlZWRzWyB0aW1lIF0gfHwgdGltZSA6IHRpbWU7XG5cdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSwgZnVuY3Rpb24oIG5leHQsIGhvb2tzICkge1xuXHRcdHZhciB0aW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoIG5leHQsIHRpbWUgKTtcblx0XHRob29rcy5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0ICk7XG5cdFx0fTtcblx0fSApO1xufTtcblxuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKSxcblx0XHRzZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInNlbGVjdFwiICksXG5cdFx0b3B0ID0gc2VsZWN0LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcIm9wdGlvblwiICkgKTtcblxuXHRpbnB1dC50eXBlID0gXCJjaGVja2JveFwiO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjMgb25seVxuXHQvLyBEZWZhdWx0IHZhbHVlIGZvciBhIGNoZWNrYm94IHNob3VsZCBiZSBcIm9uXCJcblx0c3VwcG9ydC5jaGVja09uID0gaW5wdXQudmFsdWUgIT09IFwiXCI7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIE11c3QgYWNjZXNzIHNlbGVjdGVkSW5kZXggdG8gbWFrZSBkZWZhdWx0IG9wdGlvbnMgc2VsZWN0XG5cdHN1cHBvcnQub3B0U2VsZWN0ZWQgPSBvcHQuc2VsZWN0ZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIEFuIGlucHV0IGxvc2VzIGl0cyB2YWx1ZSBhZnRlciBiZWNvbWluZyBhIHJhZGlvXG5cdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cdGlucHV0LnZhbHVlID0gXCJ0XCI7XG5cdGlucHV0LnR5cGUgPSBcInJhZGlvXCI7XG5cdHN1cHBvcnQucmFkaW9WYWx1ZSA9IGlucHV0LnZhbHVlID09PSBcInRcIjtcbn0gKSgpO1xuXG5cbnZhciBib29sSG9vayxcblx0YXR0ckhhbmRsZSA9IGpRdWVyeS5leHByLmF0dHJIYW5kbGU7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0YXR0cjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5hdHRyLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCB0aGlzLCBuYW1lICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0YXR0cjogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciByZXQsIGhvb2tzLFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gRG9uJ3QgZ2V0L3NldCBhdHRyaWJ1dGVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRmFsbGJhY2sgdG8gcHJvcCB3aGVuIGF0dHJpYnV0ZXMgYXJlIG5vdCBzdXBwb3J0ZWRcblx0XHRpZiAoIHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSA9PT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucHJvcCggZWxlbSwgbmFtZSwgdmFsdWUgKTtcblx0XHR9XG5cblx0XHQvLyBBdHRyaWJ1dGUgaG9va3MgYXJlIGRldGVybWluZWQgYnkgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uXG5cdFx0Ly8gR3JhYiBuZWNlc3NhcnkgaG9vayBpZiBvbmUgaXMgZGVmaW5lZFxuXHRcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXHRcdFx0aG9va3MgPSBqUXVlcnkuYXR0ckhvb2tzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSB8fFxuXHRcdFx0XHQoIGpRdWVyeS5leHByLm1hdGNoLmJvb2wudGVzdCggbmFtZSApID8gYm9vbEhvb2sgOiB1bmRlZmluZWQgKTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHZhbHVlID09PSBudWxsICkge1xuXHRcdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCB2YWx1ZSArIFwiXCIgKTtcblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHRyZXQgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHQvLyBOb24tZXhpc3RlbnQgYXR0cmlidXRlcyByZXR1cm4gbnVsbCwgd2Ugbm9ybWFsaXplIHRvIHVuZGVmaW5lZFxuXHRcdHJldHVybiByZXQgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHJldDtcblx0fSxcblxuXHRhdHRySG9va3M6IHtcblx0XHR0eXBlOiB7XG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhc3VwcG9ydC5yYWRpb1ZhbHVlICYmIHZhbHVlID09PSBcInJhZGlvXCIgJiZcblx0XHRcdFx0XHRub2RlTmFtZSggZWxlbSwgXCJpbnB1dFwiICkgKSB7XG5cdFx0XHRcdFx0dmFyIHZhbCA9IGVsZW0udmFsdWU7XG5cdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCB2YWx1ZSApO1xuXHRcdFx0XHRcdGlmICggdmFsICkge1xuXHRcdFx0XHRcdFx0ZWxlbS52YWx1ZSA9IHZhbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHR2YXIgbmFtZSxcblx0XHRcdGkgPSAwLFxuXG5cdFx0XHQvLyBBdHRyaWJ1dGUgbmFtZXMgY2FuIGNvbnRhaW4gbm9uLUhUTUwgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzXG5cdFx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNhdHRyaWJ1dGVzLTJcblx0XHRcdGF0dHJOYW1lcyA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICk7XG5cblx0XHRpZiAoIGF0dHJOYW1lcyAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0d2hpbGUgKCAoIG5hbWUgPSBhdHRyTmFtZXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBuYW1lICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIEhvb2tzIGZvciBib29sZWFuIGF0dHJpYnV0ZXNcbmJvb2xIb29rID0ge1xuXHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgbmFtZSApIHtcblx0XHRpZiAoIHZhbHVlID09PSBmYWxzZSApIHtcblxuXHRcdFx0Ly8gUmVtb3ZlIGJvb2xlYW4gYXR0cmlidXRlcyB3aGVuIHNldCB0byBmYWxzZVxuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cbn07XG5cbmpRdWVyeS5lYWNoKCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnNvdXJjZS5tYXRjaCggL1xcdysvZyApLCBmdW5jdGlvbiggX2ksIG5hbWUgKSB7XG5cdHZhciBnZXR0ZXIgPSBhdHRySGFuZGxlWyBuYW1lIF0gfHwgalF1ZXJ5LmZpbmQuYXR0cjtcblxuXHRhdHRySGFuZGxlWyBuYW1lIF0gPSBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0dmFyIHJldCwgaGFuZGxlLFxuXHRcdFx0bG93ZXJjYXNlTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHRcdGlmICggIWlzWE1MICkge1xuXG5cdFx0XHQvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wIGJ5IHRlbXBvcmFyaWx5IHJlbW92aW5nIHRoaXMgZnVuY3Rpb24gZnJvbSB0aGUgZ2V0dGVyXG5cdFx0XHRoYW5kbGUgPSBhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF07XG5cdFx0XHRhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF0gPSByZXQ7XG5cdFx0XHRyZXQgPSBnZXR0ZXIoIGVsZW0sIG5hbWUsIGlzWE1MICkgIT0gbnVsbCA/XG5cdFx0XHRcdGxvd2VyY2FzZU5hbWUgOlxuXHRcdFx0XHRudWxsO1xuXHRcdFx0YXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdID0gaGFuZGxlO1xuXHRcdH1cblx0XHRyZXR1cm4gcmV0O1xuXHR9O1xufSApO1xuXG5cblxuXG52YXIgcmZvY3VzYWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdHJjbGlja2FibGUgPSAvXig/OmF8YXJlYSkkL2k7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0cHJvcDogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5wcm9wLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVQcm9wOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGRlbGV0ZSB0aGlzWyBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWUgXTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHRwcm9wOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBEb24ndCBnZXQvc2V0IHByb3BlcnRpZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gRml4IG5hbWUgYW5kIGF0dGFjaCBob29rc1xuXHRcdFx0bmFtZSA9IGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZTtcblx0XHRcdGhvb2tzID0galF1ZXJ5LnByb3BIb29rc1sgbmFtZSBdO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAoIGVsZW1bIG5hbWUgXSA9IHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkgKSAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGVsZW1bIG5hbWUgXTtcblx0fSxcblxuXHRwcm9wSG9va3M6IHtcblx0XHR0YWJJbmRleDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdFx0XHRcdC8vIGVsZW0udGFiSW5kZXggZG9lc24ndCBhbHdheXMgcmV0dXJuIHRoZVxuXHRcdFx0XHQvLyBjb3JyZWN0IHZhbHVlIHdoZW4gaXQgaGFzbid0IGJlZW4gZXhwbGljaXRseSBzZXRcblx0XHRcdFx0Ly8gaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTQxMTE2MjMzMzQ3L2h0dHA6Ly9mbHVpZHByb2plY3Qub3JnL2Jsb2cvMjAwOC8wMS8wOS9nZXR0aW5nLXNldHRpbmctYW5kLXJlbW92aW5nLXRhYmluZGV4LXZhbHVlcy13aXRoLWphdmFzY3JpcHQvXG5cdFx0XHRcdC8vIFVzZSBwcm9wZXIgYXR0cmlidXRlIHJldHJpZXZhbCgjMTIwNzIpXG5cdFx0XHRcdHZhciB0YWJpbmRleCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidGFiaW5kZXhcIiApO1xuXG5cdFx0XHRcdGlmICggdGFiaW5kZXggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBhcnNlSW50KCB0YWJpbmRleCwgMTAgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRyZm9jdXNhYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSB8fFxuXHRcdFx0XHRcdHJjbGlja2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApICYmXG5cdFx0XHRcdFx0ZWxlbS5ocmVmXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRwcm9wRml4OiB7XG5cdFx0XCJmb3JcIjogXCJodG1sRm9yXCIsXG5cdFx0XCJjbGFzc1wiOiBcImNsYXNzTmFtZVwiXG5cdH1cbn0gKTtcblxuLy8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG4vLyBBY2Nlc3NpbmcgdGhlIHNlbGVjdGVkSW5kZXggcHJvcGVydHlcbi8vIGZvcmNlcyB0aGUgYnJvd3NlciB0byByZXNwZWN0IHNldHRpbmcgc2VsZWN0ZWRcbi8vIG9uIHRoZSBvcHRpb25cbi8vIFRoZSBnZXR0ZXIgZW5zdXJlcyBhIGRlZmF1bHQgb3B0aW9uIGlzIHNlbGVjdGVkXG4vLyB3aGVuIGluIGFuIG9wdGdyb3VwXG4vLyBlc2xpbnQgcnVsZSBcIm5vLXVudXNlZC1leHByZXNzaW9uc1wiIGlzIGRpc2FibGVkIGZvciB0aGlzIGNvZGVcbi8vIHNpbmNlIGl0IGNvbnNpZGVycyBzdWNoIGFjY2Vzc2lvbnMgbm9vcFxuaWYgKCAhc3VwcG9ydC5vcHRTZWxlY3RlZCApIHtcblx0alF1ZXJ5LnByb3BIb29rcy5zZWxlY3RlZCA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvKiBlc2xpbnQgbm8tdW51c2VkLWV4cHJlc3Npb25zOiBcIm9mZlwiICovXG5cblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIHBhcmVudCAmJiBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0LyogZXNsaW50IG5vLXVudXNlZC1leHByZXNzaW9uczogXCJvZmZcIiAqL1xuXG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdHBhcmVudC5zZWxlY3RlZEluZGV4O1xuXG5cdFx0XHRcdGlmICggcGFyZW50LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxualF1ZXJ5LmVhY2goIFtcblx0XCJ0YWJJbmRleFwiLFxuXHRcInJlYWRPbmx5XCIsXG5cdFwibWF4TGVuZ3RoXCIsXG5cdFwiY2VsbFNwYWNpbmdcIixcblx0XCJjZWxsUGFkZGluZ1wiLFxuXHRcInJvd1NwYW5cIixcblx0XCJjb2xTcGFuXCIsXG5cdFwidXNlTWFwXCIsXG5cdFwiZnJhbWVCb3JkZXJcIixcblx0XCJjb250ZW50RWRpdGFibGVcIlxuXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS5wcm9wRml4WyB0aGlzLnRvTG93ZXJDYXNlKCkgXSA9IHRoaXM7XG59ICk7XG5cblxuXG5cblx0Ly8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2UgYWNjb3JkaW5nIHRvIEhUTUwgc3BlY1xuXHQvLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtYW5kLWNvbGxhcHNlLWFzY2lpLXdoaXRlc3BhY2Vcblx0ZnVuY3Rpb24gc3RyaXBBbmRDb2xsYXBzZSggdmFsdWUgKSB7XG5cdFx0dmFyIHRva2VucyA9IHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cdFx0cmV0dXJuIHRva2Vucy5qb2luKCBcIiBcIiApO1xuXHR9XG5cblxuZnVuY3Rpb24gZ2V0Q2xhc3MoIGVsZW0gKSB7XG5cdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSAmJiBlbGVtLmdldEF0dHJpYnV0ZSggXCJjbGFzc1wiICkgfHwgXCJcIjtcbn1cblxuZnVuY3Rpb24gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICkge1xuXHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9XG5cdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXHR9XG5cdHJldHVybiBbXTtcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRhZGRDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmFkZENsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRjbGFzc2VzID0gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICk7XG5cblx0XHRpZiAoIGNsYXNzZXMubGVuZ3RoICkge1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0XHRjdXJWYWx1ZSA9IGdldENsYXNzKCBlbGVtICk7XG5cdFx0XHRcdGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGN1clZhbHVlICkgKyBcIiBcIiApO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBjbGF6eiA9IGNsYXNzZXNbIGorKyBdICkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA8IDAgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciArPSBjbGF6eiArIFwiIFwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoIGN1ciApO1xuXHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjdXJWYWx1ZSwgY2xhenosIGosIGZpbmFsVmFsdWUsXG5cdFx0XHRpID0gMDtcblxuXHRcdGlmICggaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5yZW1vdmVDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB0aGlzLmF0dHIoIFwiY2xhc3NcIiwgXCJcIiApO1xuXHRcdH1cblxuXHRcdGNsYXNzZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcblxuXHRcdGlmICggY2xhc3Nlcy5sZW5ndGggKSB7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcblxuXHRcdFx0XHQvLyBUaGlzIGV4cHJlc3Npb24gaXMgaGVyZSBmb3IgYmV0dGVyIGNvbXByZXNzaWJpbGl0eSAoc2VlIGFkZENsYXNzKVxuXHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmICggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBjdXJWYWx1ZSApICsgXCIgXCIgKTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoICggY2xhenogPSBjbGFzc2VzWyBqKysgXSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgKmFsbCogaW5zdGFuY2VzXG5cdFx0XHRcdFx0XHR3aGlsZSAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgPSBjdXIucmVwbGFjZSggXCIgXCIgKyBjbGF6eiArIFwiIFwiLCBcIiBcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoIGN1ciApO1xuXHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0dG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSwgc3RhdGVWYWwgKSB7XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgdmFsdWUsXG5cdFx0XHRpc1ZhbGlkVmFsdWUgPSB0eXBlID09PSBcInN0cmluZ1wiIHx8IEFycmF5LmlzQXJyYXkoIHZhbHVlICk7XG5cblx0XHRpZiAoIHR5cGVvZiBzdGF0ZVZhbCA9PT0gXCJib29sZWFuXCIgJiYgaXNWYWxpZFZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlVmFsID8gdGhpcy5hZGRDbGFzcyggdmFsdWUgKSA6IHRoaXMucmVtb3ZlQ2xhc3MoIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnRvZ2dsZUNsYXNzKFxuXHRcdFx0XHRcdHZhbHVlLmNhbGwoIHRoaXMsIGksIGdldENsYXNzKCB0aGlzICksIHN0YXRlVmFsICksXG5cdFx0XHRcdFx0c3RhdGVWYWxcblx0XHRcdFx0KTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjbGFzc05hbWUsIGksIHNlbGYsIGNsYXNzTmFtZXM7XG5cblx0XHRcdGlmICggaXNWYWxpZFZhbHVlICkge1xuXG5cdFx0XHRcdC8vIFRvZ2dsZSBpbmRpdmlkdWFsIGNsYXNzIG5hbWVzXG5cdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRzZWxmID0galF1ZXJ5KCB0aGlzICk7XG5cdFx0XHRcdGNsYXNzTmFtZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcblxuXHRcdFx0XHR3aGlsZSAoICggY2xhc3NOYW1lID0gY2xhc3NOYW1lc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHRcdC8vIENoZWNrIGVhY2ggY2xhc3NOYW1lIGdpdmVuLCBzcGFjZSBzZXBhcmF0ZWQgbGlzdFxuXHRcdFx0XHRcdGlmICggc2VsZi5oYXNDbGFzcyggY2xhc3NOYW1lICkgKSB7XG5cdFx0XHRcdFx0XHRzZWxmLnJlbW92ZUNsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2VsZi5hZGRDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdC8vIFRvZ2dsZSB3aG9sZSBjbGFzcyBuYW1lXG5cdFx0XHR9IGVsc2UgaWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0XHRjbGFzc05hbWUgPSBnZXRDbGFzcyggdGhpcyApO1xuXHRcdFx0XHRpZiAoIGNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdC8vIFN0b3JlIGNsYXNzTmFtZSBpZiBzZXRcblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiLCBjbGFzc05hbWUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIHRoZSBlbGVtZW50IGhhcyBhIGNsYXNzIG5hbWUgb3IgaWYgd2UncmUgcGFzc2VkIGBmYWxzZWAsXG5cdFx0XHRcdC8vIHRoZW4gcmVtb3ZlIHRoZSB3aG9sZSBjbGFzc25hbWUgKGlmIHRoZXJlIHdhcyBvbmUsIHRoZSBhYm92ZSBzYXZlZCBpdCkuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBicmluZyBiYWNrIHdoYXRldmVyIHdhcyBwcmV2aW91c2x5IHNhdmVkIChpZiBhbnl0aGluZyksXG5cdFx0XHRcdC8vIGZhbGxpbmcgYmFjayB0byB0aGUgZW1wdHkgc3RyaW5nIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cblx0XHRcdFx0aWYgKCB0aGlzLnNldEF0dHJpYnV0ZSApIHtcblx0XHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLFxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lIHx8IHZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRcdFx0XHRcdFwiXCIgOlxuXHRcdFx0XHRcdFx0XHRkYXRhUHJpdi5nZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiICkgfHwgXCJcIlxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0aGFzQ2xhc3M6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgY2xhc3NOYW1lLCBlbGVtLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRjbGFzc05hbWUgPSBcIiBcIiArIHNlbGVjdG9yICsgXCIgXCI7XG5cdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdCggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBnZXRDbGFzcyggZWxlbSApICkgKyBcIiBcIiApLmluZGV4T2YoIGNsYXNzTmFtZSApID4gLTEgKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSApO1xuXG5cblxuXG52YXIgcnJldHVybiA9IC9cXHIvZztcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHR2YWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgaG9va3MsIHJldCwgdmFsdWVJc0Z1bmN0aW9uLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXTtcblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyBlbGVtLnR5cGUgXSB8fFxuXHRcdFx0XHRcdGpRdWVyeS52YWxIb29rc1sgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdFx0aWYgKCBob29rcyAmJlxuXHRcdFx0XHRcdFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0XHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgXCJ2YWx1ZVwiICkgKSAhPT0gdW5kZWZpbmVkXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXQgPSBlbGVtLnZhbHVlO1xuXG5cdFx0XHRcdC8vIEhhbmRsZSBtb3N0IGNvbW1vbiBzdHJpbmcgY2FzZXNcblx0XHRcdFx0aWYgKCB0eXBlb2YgcmV0ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRcdHJldHVybiByZXQucmVwbGFjZSggcnJldHVybiwgXCJcIiApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSGFuZGxlIGNhc2VzIHdoZXJlIHZhbHVlIGlzIG51bGwvdW5kZWYgb3IgbnVtYmVyXG5cdFx0XHRcdHJldHVybiByZXQgPT0gbnVsbCA/IFwiXCIgOiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YWx1ZUlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHR2YXIgdmFsO1xuXG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB2YWx1ZUlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlLmNhbGwoIHRoaXMsIGksIGpRdWVyeSggdGhpcyApLnZhbCgpICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVHJlYXQgbnVsbC91bmRlZmluZWQgYXMgXCJcIjsgY29udmVydCBudW1iZXJzIHRvIHN0cmluZ1xuXHRcdFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdFx0dmFsID0gXCJcIjtcblxuXHRcdFx0fSBlbHNlIGlmICggdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0dmFsICs9IFwiXCI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIEFycmF5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHR2YWwgPSBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSArIFwiXCI7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblxuXHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIHRoaXMudHlwZSBdIHx8IGpRdWVyeS52YWxIb29rc1sgdGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdC8vIElmIHNldCByZXR1cm5zIHVuZGVmaW5lZCwgZmFsbCBiYWNrIHRvIG5vcm1hbCBzZXR0aW5nXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHwgaG9va3Muc2V0KCB0aGlzLCB2YWwsIFwidmFsdWVcIiApID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0dmFsSG9va3M6IHtcblx0XHRvcHRpb246IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdFx0dmFyIHZhbCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidmFsdWVcIiApO1xuXHRcdFx0XHRyZXR1cm4gdmFsICE9IG51bGwgP1xuXHRcdFx0XHRcdHZhbCA6XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEgb25seVxuXHRcdFx0XHRcdC8vIG9wdGlvbi50ZXh0IHRocm93cyBleGNlcHRpb25zICgjMTQ2ODYsICMxNDg1OClcblx0XHRcdFx0XHQvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZVxuXHRcdFx0XHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI3N0cmlwLWFuZC1jb2xsYXBzZS13aGl0ZXNwYWNlXG5cdFx0XHRcdFx0c3RyaXBBbmRDb2xsYXBzZSggalF1ZXJ5LnRleHQoIGVsZW0gKSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2VsZWN0OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgdmFsdWUsIG9wdGlvbiwgaSxcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdGluZGV4ID0gZWxlbS5zZWxlY3RlZEluZGV4LFxuXHRcdFx0XHRcdG9uZSA9IGVsZW0udHlwZSA9PT0gXCJzZWxlY3Qtb25lXCIsXG5cdFx0XHRcdFx0dmFsdWVzID0gb25lID8gbnVsbCA6IFtdLFxuXHRcdFx0XHRcdG1heCA9IG9uZSA/IGluZGV4ICsgMSA6IG9wdGlvbnMubGVuZ3RoO1xuXG5cdFx0XHRcdGlmICggaW5kZXggPCAwICkge1xuXHRcdFx0XHRcdGkgPSBtYXg7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpID0gb25lID8gaW5kZXggOiAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTG9vcCB0aHJvdWdoIGFsbCB0aGUgc2VsZWN0ZWQgb3B0aW9uc1xuXHRcdFx0XHRmb3IgKCA7IGkgPCBtYXg7IGkrKyApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdC8vIElFOC05IGRvZXNuJ3QgdXBkYXRlIHNlbGVjdGVkIGFmdGVyIGZvcm0gcmVzZXQgKCMyNTUxKVxuXHRcdFx0XHRcdGlmICggKCBvcHRpb24uc2VsZWN0ZWQgfHwgaSA9PT0gaW5kZXggKSAmJlxuXG5cdFx0XHRcdFx0XHRcdC8vIERvbid0IHJldHVybiBvcHRpb25zIHRoYXQgYXJlIGRpc2FibGVkIG9yIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcblx0XHRcdFx0XHRcdFx0IW9wdGlvbi5kaXNhYmxlZCAmJlxuXHRcdFx0XHRcdFx0XHQoICFvcHRpb24ucGFyZW50Tm9kZS5kaXNhYmxlZCB8fFxuXHRcdFx0XHRcdFx0XHRcdCFub2RlTmFtZSggb3B0aW9uLnBhcmVudE5vZGUsIFwib3B0Z3JvdXBcIiApICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEdldCB0aGUgc3BlY2lmaWMgdmFsdWUgZm9yIHRoZSBvcHRpb25cblx0XHRcdFx0XHRcdHZhbHVlID0galF1ZXJ5KCBvcHRpb24gKS52YWwoKTtcblxuXHRcdFx0XHRcdFx0Ly8gV2UgZG9uJ3QgbmVlZCBhbiBhcnJheSBmb3Igb25lIHNlbGVjdHNcblx0XHRcdFx0XHRcdGlmICggb25lICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIE11bHRpLVNlbGVjdHMgcmV0dXJuIGFuIGFycmF5XG5cdFx0XHRcdFx0XHR2YWx1ZXMucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBvcHRpb25TZXQsIG9wdGlvbixcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdHZhbHVlcyA9IGpRdWVyeS5tYWtlQXJyYXkoIHZhbHVlICksXG5cdFx0XHRcdFx0aSA9IG9wdGlvbnMubGVuZ3RoO1xuXG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbmQtYXNzaWduICovXG5cblx0XHRcdFx0XHRpZiAoIG9wdGlvbi5zZWxlY3RlZCA9XG5cdFx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggalF1ZXJ5LnZhbEhvb2tzLm9wdGlvbi5nZXQoIG9wdGlvbiApLCB2YWx1ZXMgKSA+IC0xXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRvcHRpb25TZXQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8qIGVzbGludC1lbmFibGUgbm8tY29uZC1hc3NpZ24gKi9cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEZvcmNlIGJyb3dzZXJzIHRvIGJlaGF2ZSBjb25zaXN0ZW50bHkgd2hlbiBub24tbWF0Y2hpbmcgdmFsdWUgaXMgc2V0XG5cdFx0XHRcdGlmICggIW9wdGlvblNldCApIHtcblx0XHRcdFx0XHRlbGVtLnNlbGVjdGVkSW5kZXggPSAtMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG4vLyBSYWRpb3MgYW5kIGNoZWNrYm94ZXMgZ2V0dGVyL3NldHRlclxualF1ZXJ5LmVhY2goIFsgXCJyYWRpb1wiLCBcImNoZWNrYm94XCIgXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdID0ge1xuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLmNoZWNrZWQgPSBqUXVlcnkuaW5BcnJheSggalF1ZXJ5KCBlbGVtICkudmFsKCksIHZhbHVlICkgPiAtMSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0aWYgKCAhc3VwcG9ydC5jaGVja09uICkge1xuXHRcdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdLmdldCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gbnVsbCA/IFwib25cIiA6IGVsZW0udmFsdWU7XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG4vLyBSZXR1cm4galF1ZXJ5IGZvciBhdHRyaWJ1dGVzLW9ubHkgaW5jbHVzaW9uXG5cblxuc3VwcG9ydC5mb2N1c2luID0gXCJvbmZvY3VzaW5cIiBpbiB3aW5kb3c7XG5cblxudmFyIHJmb2N1c01vcnBoID0gL14oPzpmb2N1c2luZm9jdXN8Zm9jdXNvdXRibHVyKSQvLFxuXHRzdG9wUHJvcGFnYXRpb25DYWxsYmFjayA9IGZ1bmN0aW9uKCBlICkge1xuXHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH07XG5cbmpRdWVyeS5leHRlbmQoIGpRdWVyeS5ldmVudCwge1xuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCBldmVudCwgZGF0YSwgZWxlbSwgb25seUhhbmRsZXJzICkge1xuXG5cdFx0dmFyIGksIGN1ciwgdG1wLCBidWJibGVUeXBlLCBvbnR5cGUsIGhhbmRsZSwgc3BlY2lhbCwgbGFzdEVsZW1lbnQsXG5cdFx0XHRldmVudFBhdGggPSBbIGVsZW0gfHwgZG9jdW1lbnQgXSxcblx0XHRcdHR5cGUgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwidHlwZVwiICkgPyBldmVudC50eXBlIDogZXZlbnQsXG5cdFx0XHRuYW1lc3BhY2VzID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcIm5hbWVzcGFjZVwiICkgPyBldmVudC5uYW1lc3BhY2Uuc3BsaXQoIFwiLlwiICkgOiBbXTtcblxuXHRcdGN1ciA9IGxhc3RFbGVtZW50ID0gdG1wID0gZWxlbSA9IGVsZW0gfHwgZG9jdW1lbnQ7XG5cblx0XHQvLyBEb24ndCBkbyBldmVudHMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIGZvY3VzL2JsdXIgbW9ycGhzIHRvIGZvY3VzaW4vb3V0OyBlbnN1cmUgd2UncmUgbm90IGZpcmluZyB0aGVtIHJpZ2h0IG5vd1xuXHRcdGlmICggcmZvY3VzTW9ycGgudGVzdCggdHlwZSArIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGUuaW5kZXhPZiggXCIuXCIgKSA+IC0xICkge1xuXG5cdFx0XHQvLyBOYW1lc3BhY2VkIHRyaWdnZXI7IGNyZWF0ZSBhIHJlZ2V4cCB0byBtYXRjaCBldmVudCB0eXBlIGluIGhhbmRsZSgpXG5cdFx0XHRuYW1lc3BhY2VzID0gdHlwZS5zcGxpdCggXCIuXCIgKTtcblx0XHRcdHR5cGUgPSBuYW1lc3BhY2VzLnNoaWZ0KCk7XG5cdFx0XHRuYW1lc3BhY2VzLnNvcnQoKTtcblx0XHR9XG5cdFx0b250eXBlID0gdHlwZS5pbmRleE9mKCBcIjpcIiApIDwgMCAmJiBcIm9uXCIgKyB0eXBlO1xuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGEgalF1ZXJ5LkV2ZW50IG9iamVjdCwgT2JqZWN0LCBvciBqdXN0IGFuIGV2ZW50IHR5cGUgc3RyaW5nXG5cdFx0ZXZlbnQgPSBldmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XG5cdFx0XHRldmVudCA6XG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCB0eXBlLCB0eXBlb2YgZXZlbnQgPT09IFwib2JqZWN0XCIgJiYgZXZlbnQgKTtcblxuXHRcdC8vIFRyaWdnZXIgYml0bWFzazogJiAxIGZvciBuYXRpdmUgaGFuZGxlcnM7ICYgMiBmb3IgalF1ZXJ5IChhbHdheXMgdHJ1ZSlcblx0XHRldmVudC5pc1RyaWdnZXIgPSBvbmx5SGFuZGxlcnMgPyAyIDogMztcblx0XHRldmVudC5uYW1lc3BhY2UgPSBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiICk7XG5cdFx0ZXZlbnQucm5hbWVzcGFjZSA9IGV2ZW50Lm5hbWVzcGFjZSA/XG5cdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKCBcIlxcXFwuKD86LipcXFxcLnwpXCIgKSArIFwiKFxcXFwufCQpXCIgKSA6XG5cdFx0XHRudWxsO1xuXG5cdFx0Ly8gQ2xlYW4gdXAgdGhlIGV2ZW50IGluIGNhc2UgaXQgaXMgYmVpbmcgcmV1c2VkXG5cdFx0ZXZlbnQucmVzdWx0ID0gdW5kZWZpbmVkO1xuXHRcdGlmICggIWV2ZW50LnRhcmdldCApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGVsZW07XG5cdFx0fVxuXG5cdFx0Ly8gQ2xvbmUgYW55IGluY29taW5nIGRhdGEgYW5kIHByZXBlbmQgdGhlIGV2ZW50LCBjcmVhdGluZyB0aGUgaGFuZGxlciBhcmcgbGlzdFxuXHRcdGRhdGEgPSBkYXRhID09IG51bGwgP1xuXHRcdFx0WyBldmVudCBdIDpcblx0XHRcdGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEsIFsgZXZlbnQgXSApO1xuXG5cdFx0Ly8gQWxsb3cgc3BlY2lhbCBldmVudHMgdG8gZHJhdyBvdXRzaWRlIHRoZSBsaW5lc1xuXHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiBzcGVjaWFsLnRyaWdnZXIgJiYgc3BlY2lhbC50cmlnZ2VyLmFwcGx5KCBlbGVtLCBkYXRhICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBldmVudCBwcm9wYWdhdGlvbiBwYXRoIGluIGFkdmFuY2UsIHBlciBXM0MgZXZlbnRzIHNwZWMgKCM5OTUxKVxuXHRcdC8vIEJ1YmJsZSB1cCB0byBkb2N1bWVudCwgdGhlbiB0byB3aW5kb3c7IHdhdGNoIGZvciBhIGdsb2JhbCBvd25lckRvY3VtZW50IHZhciAoIzk3MjQpXG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFzcGVjaWFsLm5vQnViYmxlICYmICFpc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRidWJibGVUeXBlID0gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgfHwgdHlwZTtcblx0XHRcdGlmICggIXJmb2N1c01vcnBoLnRlc3QoIGJ1YmJsZVR5cGUgKyB0eXBlICkgKSB7XG5cdFx0XHRcdGN1ciA9IGN1ci5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICggOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaCggY3VyICk7XG5cdFx0XHRcdHRtcCA9IGN1cjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT25seSBhZGQgd2luZG93IGlmIHdlIGdvdCB0byBkb2N1bWVudCAoZS5nLiwgbm90IHBsYWluIG9iaiBvciBkZXRhY2hlZCBET00pXG5cdFx0XHRpZiAoIHRtcCA9PT0gKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQgKSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIHRtcC5kZWZhdWx0VmlldyB8fCB0bXAucGFyZW50V2luZG93IHx8IHdpbmRvdyApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZpcmUgaGFuZGxlcnMgb24gdGhlIGV2ZW50IHBhdGhcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoICggY3VyID0gZXZlbnRQYXRoWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0bGFzdEVsZW1lbnQgPSBjdXI7XG5cdFx0XHRldmVudC50eXBlID0gaSA+IDEgP1xuXHRcdFx0XHRidWJibGVUeXBlIDpcblx0XHRcdFx0c3BlY2lhbC5iaW5kVHlwZSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBqUXVlcnkgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gKCBkYXRhUHJpdi5nZXQoIGN1ciwgXCJldmVudHNcIiApIHx8IE9iamVjdC5jcmVhdGUoIG51bGwgKSApWyBldmVudC50eXBlIF0gJiZcblx0XHRcdFx0ZGF0YVByaXYuZ2V0KCBjdXIsIFwiaGFuZGxlXCIgKTtcblx0XHRcdGlmICggaGFuZGxlICkge1xuXHRcdFx0XHRoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBOYXRpdmUgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gb250eXBlICYmIGN1clsgb250eXBlIF07XG5cdFx0XHRpZiAoIGhhbmRsZSAmJiBoYW5kbGUuYXBwbHkgJiYgYWNjZXB0RGF0YSggY3VyICkgKSB7XG5cdFx0XHRcdGV2ZW50LnJlc3VsdCA9IGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGV2ZW50LnR5cGUgPSB0eXBlO1xuXG5cdFx0Ly8gSWYgbm9ib2R5IHByZXZlbnRlZCB0aGUgZGVmYXVsdCBhY3Rpb24sIGRvIGl0IG5vd1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cblx0XHRcdGlmICggKCAhc3BlY2lhbC5fZGVmYXVsdCB8fFxuXHRcdFx0XHRzcGVjaWFsLl9kZWZhdWx0LmFwcGx5KCBldmVudFBhdGgucG9wKCksIGRhdGEgKSA9PT0gZmFsc2UgKSAmJlxuXHRcdFx0XHRhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cblx0XHRcdFx0Ly8gQ2FsbCBhIG5hdGl2ZSBET00gbWV0aG9kIG9uIHRoZSB0YXJnZXQgd2l0aCB0aGUgc2FtZSBuYW1lIGFzIHRoZSBldmVudC5cblx0XHRcdFx0Ly8gRG9uJ3QgZG8gZGVmYXVsdCBhY3Rpb25zIG9uIHdpbmRvdywgdGhhdCdzIHdoZXJlIGdsb2JhbCB2YXJpYWJsZXMgYmUgKCM2MTcwKVxuXHRcdFx0XHRpZiAoIG9udHlwZSAmJiBpc0Z1bmN0aW9uKCBlbGVtWyB0eXBlIF0gKSAmJiAhaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vIERvbid0IHJlLXRyaWdnZXIgYW4gb25GT08gZXZlbnQgd2hlbiB3ZSBjYWxsIGl0cyBGT08oKSBtZXRob2Rcblx0XHRcdFx0XHR0bXAgPSBlbGVtWyBvbnR5cGUgXTtcblxuXHRcdFx0XHRcdGlmICggdG1wICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSBudWxsO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZXZlbnQgcmUtdHJpZ2dlcmluZyBvZiB0aGUgc2FtZSBldmVudCwgc2luY2Ugd2UgYWxyZWFkeSBidWJibGVkIGl0IGFib3ZlXG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHR5cGU7XG5cblx0XHRcdFx0XHRpZiAoIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRcdFx0XHRsYXN0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBzdG9wUHJvcGFnYXRpb25DYWxsYmFjayApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW1bIHR5cGUgXSgpO1xuXG5cdFx0XHRcdFx0aWYgKCBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0XHRcdFx0bGFzdEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgc3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2sgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IHRtcDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdC8vIFBpZ2d5YmFjayBvbiBhIGRvbm9yIGV2ZW50IHRvIHNpbXVsYXRlIGEgZGlmZmVyZW50IG9uZVxuXHQvLyBVc2VkIG9ubHkgZm9yIGBmb2N1cyhpbiB8IG91dClgIGV2ZW50c1xuXHRzaW11bGF0ZTogZnVuY3Rpb24oIHR5cGUsIGVsZW0sIGV2ZW50ICkge1xuXHRcdHZhciBlID0galF1ZXJ5LmV4dGVuZChcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoKSxcblx0XHRcdGV2ZW50LFxuXHRcdFx0e1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRpc1NpbXVsYXRlZDogdHJ1ZVxuXHRcdFx0fVxuXHRcdCk7XG5cblx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggZSwgbnVsbCwgZWxlbSApO1xuXHR9XG5cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIHRoaXMgKTtcblx0XHR9ICk7XG5cdH0sXG5cdHRyaWdnZXJIYW5kbGVyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXTtcblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIGVsZW0sIHRydWUgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxuXG4vLyBTdXBwb3J0OiBGaXJlZm94IDw9NDRcbi8vIEZpcmVmb3ggZG9lc24ndCBoYXZlIGZvY3VzKGluIHwgb3V0KSBldmVudHNcbi8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njg3Nzg3XG4vL1xuLy8gU3VwcG9ydDogQ2hyb21lIDw9NDggLSA0OSwgU2FmYXJpIDw9OS4wIC0gOS4xXG4vLyBmb2N1cyhpbiB8IG91dCkgZXZlbnRzIGZpcmUgYWZ0ZXIgZm9jdXMgJiBibHVyIGV2ZW50cyxcbi8vIHdoaWNoIGlzIHNwZWMgdmlvbGF0aW9uIC0gaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtZm9jdXNldmVudC1ldmVudC1vcmRlclxuLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NDk4NTdcbmlmICggIXN1cHBvcnQuZm9jdXNpbiApIHtcblx0alF1ZXJ5LmVhY2goIHsgZm9jdXM6IFwiZm9jdXNpblwiLCBibHVyOiBcImZvY3Vzb3V0XCIgfSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblxuXHRcdC8vIEF0dGFjaCBhIHNpbmdsZSBjYXB0dXJpbmcgaGFuZGxlciBvbiB0aGUgZG9jdW1lbnQgd2hpbGUgc29tZW9uZSB3YW50cyBmb2N1c2luL2ZvY3Vzb3V0XG5cdFx0dmFyIGhhbmRsZXIgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQuc2ltdWxhdGUoIGZpeCwgZXZlbnQudGFyZ2V0LCBqUXVlcnkuZXZlbnQuZml4KCBldmVudCApICk7XG5cdFx0fTtcblxuXHRcdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBmaXggXSA9IHtcblx0XHRcdHNldHVwOiBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBIYW5kbGU6IHJlZ3VsYXIgbm9kZXMgKHZpYSBgdGhpcy5vd25lckRvY3VtZW50YCksIHdpbmRvd1xuXHRcdFx0XHQvLyAodmlhIGB0aGlzLmRvY3VtZW50YCkgJiBkb2N1bWVudCAodmlhIGB0aGlzYCkuXG5cdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcy5kb2N1bWVudCB8fCB0aGlzLFxuXHRcdFx0XHRcdGF0dGFjaGVzID0gZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCApO1xuXG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdGRvYy5hZGRFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCwgKCBhdHRhY2hlcyB8fCAwICkgKyAxICk7XG5cdFx0XHR9LFxuXHRcdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMuZG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXggKSAtIDE7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCBhdHRhY2hlcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSApO1xufVxudmFyIGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uO1xuXG52YXIgbm9uY2UgPSB7IGd1aWQ6IERhdGUubm93KCkgfTtcblxudmFyIHJxdWVyeSA9ICggL1xcPy8gKTtcblxuXG5cbi8vIENyb3NzLWJyb3dzZXIgeG1sIHBhcnNpbmdcbmpRdWVyeS5wYXJzZVhNTCA9IGZ1bmN0aW9uKCBkYXRhICkge1xuXHR2YXIgeG1sLCBwYXJzZXJFcnJvckVsZW07XG5cdGlmICggIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seVxuXHQvLyBJRSB0aHJvd3Mgb24gcGFyc2VGcm9tU3RyaW5nIHdpdGggaW52YWxpZCBpbnB1dC5cblx0dHJ5IHtcblx0XHR4bWwgPSAoIG5ldyB3aW5kb3cuRE9NUGFyc2VyKCkgKS5wYXJzZUZyb21TdHJpbmcoIGRhdGEsIFwidGV4dC94bWxcIiApO1xuXHR9IGNhdGNoICggZSApIHt9XG5cblx0cGFyc2VyRXJyb3JFbGVtID0geG1sICYmIHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJwYXJzZXJlcnJvclwiIClbIDAgXTtcblx0aWYgKCAheG1sIHx8IHBhcnNlckVycm9yRWxlbSApIHtcblx0XHRqUXVlcnkuZXJyb3IoIFwiSW52YWxpZCBYTUw6IFwiICsgKFxuXHRcdFx0cGFyc2VyRXJyb3JFbGVtID9cblx0XHRcdFx0alF1ZXJ5Lm1hcCggcGFyc2VyRXJyb3JFbGVtLmNoaWxkTm9kZXMsIGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZWwudGV4dENvbnRlbnQ7XG5cdFx0XHRcdH0gKS5qb2luKCBcIlxcblwiICkgOlxuXHRcdFx0XHRkYXRhXG5cdFx0KSApO1xuXHR9XG5cdHJldHVybiB4bWw7XG59O1xuXG5cbnZhclxuXHRyYnJhY2tldCA9IC9cXFtcXF0kLyxcblx0ckNSTEYgPSAvXFxyP1xcbi9nLFxuXHRyc3VibWl0dGVyVHlwZXMgPSAvXig/OnN1Ym1pdHxidXR0b258aW1hZ2V8cmVzZXR8ZmlsZSkkL2ksXG5cdHJzdWJtaXR0YWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGtleWdlbikvaTtcblxuZnVuY3Rpb24gYnVpbGRQYXJhbXMoIHByZWZpeCwgb2JqLCB0cmFkaXRpb25hbCwgYWRkICkge1xuXHR2YXIgbmFtZTtcblxuXHRpZiAoIEFycmF5LmlzQXJyYXkoIG9iaiApICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIGFycmF5IGl0ZW0uXG5cdFx0alF1ZXJ5LmVhY2goIG9iaiwgZnVuY3Rpb24oIGksIHYgKSB7XG5cdFx0XHRpZiAoIHRyYWRpdGlvbmFsIHx8IHJicmFja2V0LnRlc3QoIHByZWZpeCApICkge1xuXG5cdFx0XHRcdC8vIFRyZWF0IGVhY2ggYXJyYXkgaXRlbSBhcyBhIHNjYWxhci5cblx0XHRcdFx0YWRkKCBwcmVmaXgsIHYgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBJdGVtIGlzIG5vbi1zY2FsYXIgKGFycmF5IG9yIG9iamVjdCksIGVuY29kZSBpdHMgbnVtZXJpYyBpbmRleC5cblx0XHRcdFx0YnVpbGRQYXJhbXMoXG5cdFx0XHRcdFx0cHJlZml4ICsgXCJbXCIgKyAoIHR5cGVvZiB2ID09PSBcIm9iamVjdFwiICYmIHYgIT0gbnVsbCA/IGkgOiBcIlwiICkgKyBcIl1cIixcblx0XHRcdFx0XHR2LFxuXHRcdFx0XHRcdHRyYWRpdGlvbmFsLFxuXHRcdFx0XHRcdGFkZFxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHR9IGVsc2UgaWYgKCAhdHJhZGl0aW9uYWwgJiYgdG9UeXBlKCBvYmogKSA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBvYmplY3QgaXRlbS5cblx0XHRmb3IgKCBuYW1lIGluIG9iaiApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXggKyBcIltcIiArIG5hbWUgKyBcIl1cIiwgb2JqWyBuYW1lIF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBzY2FsYXIgaXRlbS5cblx0XHRhZGQoIHByZWZpeCwgb2JqICk7XG5cdH1cbn1cblxuLy8gU2VyaWFsaXplIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMgb3IgYSBzZXQgb2Zcbi8vIGtleS92YWx1ZXMgaW50byBhIHF1ZXJ5IHN0cmluZ1xualF1ZXJ5LnBhcmFtID0gZnVuY3Rpb24oIGEsIHRyYWRpdGlvbmFsICkge1xuXHR2YXIgcHJlZml4LFxuXHRcdHMgPSBbXSxcblx0XHRhZGQgPSBmdW5jdGlvbigga2V5LCB2YWx1ZU9yRnVuY3Rpb24gKSB7XG5cblx0XHRcdC8vIElmIHZhbHVlIGlzIGEgZnVuY3Rpb24sIGludm9rZSBpdCBhbmQgdXNlIGl0cyByZXR1cm4gdmFsdWVcblx0XHRcdHZhciB2YWx1ZSA9IGlzRnVuY3Rpb24oIHZhbHVlT3JGdW5jdGlvbiApID9cblx0XHRcdFx0dmFsdWVPckZ1bmN0aW9uKCkgOlxuXHRcdFx0XHR2YWx1ZU9yRnVuY3Rpb247XG5cblx0XHRcdHNbIHMubGVuZ3RoIF0gPSBlbmNvZGVVUklDb21wb25lbnQoIGtleSApICsgXCI9XCIgK1xuXHRcdFx0XHRlbmNvZGVVUklDb21wb25lbnQoIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKTtcblx0XHR9O1xuXG5cdGlmICggYSA9PSBudWxsICkge1xuXHRcdHJldHVybiBcIlwiO1xuXHR9XG5cblx0Ly8gSWYgYW4gYXJyYXkgd2FzIHBhc3NlZCBpbiwgYXNzdW1lIHRoYXQgaXQgaXMgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cy5cblx0aWYgKCBBcnJheS5pc0FycmF5KCBhICkgfHwgKCBhLmpxdWVyeSAmJiAhalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGEgKSApICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIHRoZSBmb3JtIGVsZW1lbnRzXG5cdFx0alF1ZXJ5LmVhY2goIGEsIGZ1bmN0aW9uKCkge1xuXHRcdFx0YWRkKCB0aGlzLm5hbWUsIHRoaXMudmFsdWUgKTtcblx0XHR9ICk7XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIElmIHRyYWRpdGlvbmFsLCBlbmNvZGUgdGhlIFwib2xkXCIgd2F5ICh0aGUgd2F5IDEuMy4yIG9yIG9sZGVyXG5cdFx0Ly8gZGlkIGl0KSwgb3RoZXJ3aXNlIGVuY29kZSBwYXJhbXMgcmVjdXJzaXZlbHkuXG5cdFx0Zm9yICggcHJlZml4IGluIGEgKSB7XG5cdFx0XHRidWlsZFBhcmFtcyggcHJlZml4LCBhWyBwcmVmaXggXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgcmVzdWx0aW5nIHNlcmlhbGl6YXRpb25cblx0cmV0dXJuIHMuam9pbiggXCImXCIgKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0c2VyaWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5LnBhcmFtKCB0aGlzLnNlcmlhbGl6ZUFycmF5KCkgKTtcblx0fSxcblx0c2VyaWFsaXplQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIENhbiBhZGQgcHJvcEhvb2sgZm9yIFwiZWxlbWVudHNcIiB0byBmaWx0ZXIgb3IgYWRkIGZvcm0gZWxlbWVudHNcblx0XHRcdHZhciBlbGVtZW50cyA9IGpRdWVyeS5wcm9wKCB0aGlzLCBcImVsZW1lbnRzXCIgKTtcblx0XHRcdHJldHVybiBlbGVtZW50cyA/IGpRdWVyeS5tYWtlQXJyYXkoIGVsZW1lbnRzICkgOiB0aGlzO1xuXHRcdH0gKS5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cblx0XHRcdC8vIFVzZSAuaXMoIFwiOmRpc2FibGVkXCIgKSBzbyB0aGF0IGZpZWxkc2V0W2Rpc2FibGVkXSB3b3Jrc1xuXHRcdFx0cmV0dXJuIHRoaXMubmFtZSAmJiAhalF1ZXJ5KCB0aGlzICkuaXMoIFwiOmRpc2FibGVkXCIgKSAmJlxuXHRcdFx0XHRyc3VibWl0dGFibGUudGVzdCggdGhpcy5ub2RlTmFtZSApICYmICFyc3VibWl0dGVyVHlwZXMudGVzdCggdHlwZSApICYmXG5cdFx0XHRcdCggdGhpcy5jaGVja2VkIHx8ICFyY2hlY2thYmxlVHlwZS50ZXN0KCB0eXBlICkgKTtcblx0XHR9ICkubWFwKCBmdW5jdGlvbiggX2ksIGVsZW0gKSB7XG5cdFx0XHR2YXIgdmFsID0galF1ZXJ5KCB0aGlzICkudmFsKCk7XG5cblx0XHRcdGlmICggdmFsID09IG51bGwgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsICkge1xuXHRcdFx0XHRcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcblx0XHR9ICkuZ2V0KCk7XG5cdH1cbn0gKTtcblxuXG52YXJcblx0cjIwID0gLyUyMC9nLFxuXHRyaGFzaCA9IC8jLiokLyxcblx0cmFudGlDYWNoZSA9IC8oWz8mXSlfPVteJl0qLyxcblx0cmhlYWRlcnMgPSAvXiguKj8pOlsgXFx0XSooW15cXHJcXG5dKikkL21nLFxuXG5cdC8vICM3NjUzLCAjODEyNSwgIzgxNTI6IGxvY2FsIHByb3RvY29sIGRldGVjdGlvblxuXHRybG9jYWxQcm90b2NvbCA9IC9eKD86YWJvdXR8YXBwfGFwcC1zdG9yYWdlfC4rLWV4dGVuc2lvbnxmaWxlfHJlc3x3aWRnZXQpOiQvLFxuXHRybm9Db250ZW50ID0gL14oPzpHRVR8SEVBRCkkLyxcblx0cnByb3RvY29sID0gL15cXC9cXC8vLFxuXG5cdC8qIFByZWZpbHRlcnNcblx0ICogMSkgVGhleSBhcmUgdXNlZnVsIHRvIGludHJvZHVjZSBjdXN0b20gZGF0YVR5cGVzIChzZWUgYWpheC9qc29ucC5qcyBmb3IgYW4gZXhhbXBsZSlcblx0ICogMikgVGhlc2UgYXJlIGNhbGxlZDpcblx0ICogICAgLSBCRUZPUkUgYXNraW5nIGZvciBhIHRyYW5zcG9ydFxuXHQgKiAgICAtIEFGVEVSIHBhcmFtIHNlcmlhbGl6YXRpb24gKHMuZGF0YSBpcyBhIHN0cmluZyBpZiBzLnByb2Nlc3NEYXRhIGlzIHRydWUpXG5cdCAqIDMpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogNCkgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiA1KSBleGVjdXRpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBjb250aW51ZSBkb3duIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0cHJlZmlsdGVycyA9IHt9LFxuXG5cdC8qIFRyYW5zcG9ydHMgYmluZGluZ3Ncblx0ICogMSkga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiAyKSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDMpIHNlbGVjdGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGdvIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0dHJhbnNwb3J0cyA9IHt9LFxuXG5cdC8vIEF2b2lkIGNvbW1lbnQtcHJvbG9nIGNoYXIgc2VxdWVuY2UgKCMxMDA5OCk7IG11c3QgYXBwZWFzZSBsaW50IGFuZCBldmFkZSBjb21wcmVzc2lvblxuXHRhbGxUeXBlcyA9IFwiKi9cIi5jb25jYXQoIFwiKlwiICksXG5cblx0Ly8gQW5jaG9yIHRhZyBmb3IgcGFyc2luZyB0aGUgZG9jdW1lbnQgb3JpZ2luXG5cdG9yaWdpbkFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cbm9yaWdpbkFuY2hvci5ocmVmID0gbG9jYXRpb24uaHJlZjtcblxuLy8gQmFzZSBcImNvbnN0cnVjdG9yXCIgZm9yIGpRdWVyeS5hamF4UHJlZmlsdGVyIGFuZCBqUXVlcnkuYWpheFRyYW5zcG9ydFxuZnVuY3Rpb24gYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUgKSB7XG5cblx0Ly8gZGF0YVR5cGVFeHByZXNzaW9uIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byBcIipcIlxuXHRyZXR1cm4gZnVuY3Rpb24oIGRhdGFUeXBlRXhwcmVzc2lvbiwgZnVuYyApIHtcblxuXHRcdGlmICggdHlwZW9mIGRhdGFUeXBlRXhwcmVzc2lvbiAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGZ1bmMgPSBkYXRhVHlwZUV4cHJlc3Npb247XG5cdFx0XHRkYXRhVHlwZUV4cHJlc3Npb24gPSBcIipcIjtcblx0XHR9XG5cblx0XHR2YXIgZGF0YVR5cGUsXG5cdFx0XHRpID0gMCxcblx0XHRcdGRhdGFUeXBlcyA9IGRhdGFUeXBlRXhwcmVzc2lvbi50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIGZ1bmMgKSApIHtcblxuXHRcdFx0Ly8gRm9yIGVhY2ggZGF0YVR5cGUgaW4gdGhlIGRhdGFUeXBlRXhwcmVzc2lvblxuXHRcdFx0d2hpbGUgKCAoIGRhdGFUeXBlID0gZGF0YVR5cGVzWyBpKysgXSApICkge1xuXG5cdFx0XHRcdC8vIFByZXBlbmQgaWYgcmVxdWVzdGVkXG5cdFx0XHRcdGlmICggZGF0YVR5cGVbIDAgXSA9PT0gXCIrXCIgKSB7XG5cdFx0XHRcdFx0ZGF0YVR5cGUgPSBkYXRhVHlwZS5zbGljZSggMSApIHx8IFwiKlwiO1xuXHRcdFx0XHRcdCggc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdICkudW5zaGlmdCggZnVuYyApO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBhcHBlbmRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnB1c2goIGZ1bmMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxuLy8gQmFzZSBpbnNwZWN0aW9uIGZ1bmN0aW9uIGZvciBwcmVmaWx0ZXJzIGFuZCB0cmFuc3BvcnRzXG5mdW5jdGlvbiBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlLCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICkge1xuXG5cdHZhciBpbnNwZWN0ZWQgPSB7fSxcblx0XHRzZWVraW5nVHJhbnNwb3J0ID0gKCBzdHJ1Y3R1cmUgPT09IHRyYW5zcG9ydHMgKTtcblxuXHRmdW5jdGlvbiBpbnNwZWN0KCBkYXRhVHlwZSApIHtcblx0XHR2YXIgc2VsZWN0ZWQ7XG5cdFx0aW5zcGVjdGVkWyBkYXRhVHlwZSBdID0gdHJ1ZTtcblx0XHRqUXVlcnkuZWFjaCggc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdLCBmdW5jdGlvbiggXywgcHJlZmlsdGVyT3JGYWN0b3J5ICkge1xuXHRcdFx0dmFyIGRhdGFUeXBlT3JUcmFuc3BvcnQgPSBwcmVmaWx0ZXJPckZhY3RvcnkoIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKTtcblx0XHRcdGlmICggdHlwZW9mIGRhdGFUeXBlT3JUcmFuc3BvcnQgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0IXNlZWtpbmdUcmFuc3BvcnQgJiYgIWluc3BlY3RlZFsgZGF0YVR5cGVPclRyYW5zcG9ydCBdICkge1xuXG5cdFx0XHRcdG9wdGlvbnMuZGF0YVR5cGVzLnVuc2hpZnQoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0aW5zcGVjdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9IGVsc2UgaWYgKCBzZWVraW5nVHJhbnNwb3J0ICkge1xuXHRcdFx0XHRyZXR1cm4gISggc2VsZWN0ZWQgPSBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcdHJldHVybiBzZWxlY3RlZDtcblx0fVxuXG5cdHJldHVybiBpbnNwZWN0KCBvcHRpb25zLmRhdGFUeXBlc1sgMCBdICkgfHwgIWluc3BlY3RlZFsgXCIqXCIgXSAmJiBpbnNwZWN0KCBcIipcIiApO1xufVxuXG4vLyBBIHNwZWNpYWwgZXh0ZW5kIGZvciBhamF4IG9wdGlvbnNcbi8vIHRoYXQgdGFrZXMgXCJmbGF0XCIgb3B0aW9ucyAobm90IHRvIGJlIGRlZXAgZXh0ZW5kZWQpXG4vLyBGaXhlcyAjOTg4N1xuZnVuY3Rpb24gYWpheEV4dGVuZCggdGFyZ2V0LCBzcmMgKSB7XG5cdHZhciBrZXksIGRlZXAsXG5cdFx0ZmxhdE9wdGlvbnMgPSBqUXVlcnkuYWpheFNldHRpbmdzLmZsYXRPcHRpb25zIHx8IHt9O1xuXG5cdGZvciAoIGtleSBpbiBzcmMgKSB7XG5cdFx0aWYgKCBzcmNbIGtleSBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHQoIGZsYXRPcHRpb25zWyBrZXkgXSA/IHRhcmdldCA6ICggZGVlcCB8fCAoIGRlZXAgPSB7fSApICkgKVsga2V5IF0gPSBzcmNbIGtleSBdO1xuXHRcdH1cblx0fVxuXHRpZiAoIGRlZXAgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdHJ1ZSwgdGFyZ2V0LCBkZWVwICk7XG5cdH1cblxuXHRyZXR1cm4gdGFyZ2V0O1xufVxuXG4vKiBIYW5kbGVzIHJlc3BvbnNlcyB0byBhbiBhamF4IHJlcXVlc3Q6XG4gKiAtIGZpbmRzIHRoZSByaWdodCBkYXRhVHlwZSAobWVkaWF0ZXMgYmV0d2VlbiBjb250ZW50LXR5cGUgYW5kIGV4cGVjdGVkIGRhdGFUeXBlKVxuICogLSByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKSB7XG5cblx0dmFyIGN0LCB0eXBlLCBmaW5hbERhdGFUeXBlLCBmaXJzdERhdGFUeXBlLFxuXHRcdGNvbnRlbnRzID0gcy5jb250ZW50cyxcblx0XHRkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcztcblxuXHQvLyBSZW1vdmUgYXV0byBkYXRhVHlwZSBhbmQgZ2V0IGNvbnRlbnQtdHlwZSBpbiB0aGUgcHJvY2Vzc1xuXHR3aGlsZSAoIGRhdGFUeXBlc1sgMCBdID09PSBcIipcIiApIHtcblx0XHRkYXRhVHlwZXMuc2hpZnQoKTtcblx0XHRpZiAoIGN0ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRjdCA9IHMubWltZVR5cGUgfHwganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiQ29udGVudC1UeXBlXCIgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDaGVjayBpZiB3ZSdyZSBkZWFsaW5nIHdpdGggYSBrbm93biBjb250ZW50LXR5cGVcblx0aWYgKCBjdCApIHtcblx0XHRmb3IgKCB0eXBlIGluIGNvbnRlbnRzICkge1xuXHRcdFx0aWYgKCBjb250ZW50c1sgdHlwZSBdICYmIGNvbnRlbnRzWyB0eXBlIF0udGVzdCggY3QgKSApIHtcblx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHR5cGUgKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgYSByZXNwb25zZSBmb3IgdGhlIGV4cGVjdGVkIGRhdGFUeXBlXG5cdGlmICggZGF0YVR5cGVzWyAwIF0gaW4gcmVzcG9uc2VzICkge1xuXHRcdGZpbmFsRGF0YVR5cGUgPSBkYXRhVHlwZXNbIDAgXTtcblx0fSBlbHNlIHtcblxuXHRcdC8vIFRyeSBjb252ZXJ0aWJsZSBkYXRhVHlwZXNcblx0XHRmb3IgKCB0eXBlIGluIHJlc3BvbnNlcyApIHtcblx0XHRcdGlmICggIWRhdGFUeXBlc1sgMCBdIHx8IHMuY29udmVydGVyc1sgdHlwZSArIFwiIFwiICsgZGF0YVR5cGVzWyAwIF0gXSApIHtcblx0XHRcdFx0ZmluYWxEYXRhVHlwZSA9IHR5cGU7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhZmlyc3REYXRhVHlwZSApIHtcblx0XHRcdFx0Zmlyc3REYXRhVHlwZSA9IHR5cGU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gT3IganVzdCB1c2UgZmlyc3Qgb25lXG5cdFx0ZmluYWxEYXRhVHlwZSA9IGZpbmFsRGF0YVR5cGUgfHwgZmlyc3REYXRhVHlwZTtcblx0fVxuXG5cdC8vIElmIHdlIGZvdW5kIGEgZGF0YVR5cGVcblx0Ly8gV2UgYWRkIHRoZSBkYXRhVHlwZSB0byB0aGUgbGlzdCBpZiBuZWVkZWRcblx0Ly8gYW5kIHJldHVybiB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuXHRpZiAoIGZpbmFsRGF0YVR5cGUgKSB7XG5cdFx0aWYgKCBmaW5hbERhdGFUeXBlICE9PSBkYXRhVHlwZXNbIDAgXSApIHtcblx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCBmaW5hbERhdGFUeXBlICk7XG5cdFx0fVxuXHRcdHJldHVybiByZXNwb25zZXNbIGZpbmFsRGF0YVR5cGUgXTtcblx0fVxufVxuXG4vKiBDaGFpbiBjb252ZXJzaW9ucyBnaXZlbiB0aGUgcmVxdWVzdCBhbmQgdGhlIG9yaWdpbmFsIHJlc3BvbnNlXG4gKiBBbHNvIHNldHMgdGhlIHJlc3BvbnNlWFhYIGZpZWxkcyBvbiB0aGUganFYSFIgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICkge1xuXHR2YXIgY29udjIsIGN1cnJlbnQsIGNvbnYsIHRtcCwgcHJldixcblx0XHRjb252ZXJ0ZXJzID0ge30sXG5cblx0XHQvLyBXb3JrIHdpdGggYSBjb3B5IG9mIGRhdGFUeXBlcyBpbiBjYXNlIHdlIG5lZWQgdG8gbW9kaWZ5IGl0IGZvciBjb252ZXJzaW9uXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXMuc2xpY2UoKTtcblxuXHQvLyBDcmVhdGUgY29udmVydGVycyBtYXAgd2l0aCBsb3dlcmNhc2VkIGtleXNcblx0aWYgKCBkYXRhVHlwZXNbIDEgXSApIHtcblx0XHRmb3IgKCBjb252IGluIHMuY29udmVydGVycyApIHtcblx0XHRcdGNvbnZlcnRlcnNbIGNvbnYudG9Mb3dlckNhc2UoKSBdID0gcy5jb252ZXJ0ZXJzWyBjb252IF07XG5cdFx0fVxuXHR9XG5cblx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdC8vIENvbnZlcnQgdG8gZWFjaCBzZXF1ZW50aWFsIGRhdGFUeXBlXG5cdHdoaWxlICggY3VycmVudCApIHtcblxuXHRcdGlmICggcy5yZXNwb25zZUZpZWxkc1sgY3VycmVudCBdICkge1xuXHRcdFx0anFYSFJbIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSBdID0gcmVzcG9uc2U7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgdGhlIGRhdGFGaWx0ZXIgaWYgcHJvdmlkZWRcblx0XHRpZiAoICFwcmV2ICYmIGlzU3VjY2VzcyAmJiBzLmRhdGFGaWx0ZXIgKSB7XG5cdFx0XHRyZXNwb25zZSA9IHMuZGF0YUZpbHRlciggcmVzcG9uc2UsIHMuZGF0YVR5cGUgKTtcblx0XHR9XG5cblx0XHRwcmV2ID0gY3VycmVudDtcblx0XHRjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cblx0XHRpZiAoIGN1cnJlbnQgKSB7XG5cblx0XHRcdC8vIFRoZXJlJ3Mgb25seSB3b3JrIHRvIGRvIGlmIGN1cnJlbnQgZGF0YVR5cGUgaXMgbm9uLWF1dG9cblx0XHRcdGlmICggY3VycmVudCA9PT0gXCIqXCIgKSB7XG5cblx0XHRcdFx0Y3VycmVudCA9IHByZXY7XG5cblx0XHRcdC8vIENvbnZlcnQgcmVzcG9uc2UgaWYgcHJldiBkYXRhVHlwZSBpcyBub24tYXV0byBhbmQgZGlmZmVycyBmcm9tIGN1cnJlbnRcblx0XHRcdH0gZWxzZSBpZiAoIHByZXYgIT09IFwiKlwiICYmIHByZXYgIT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU2VlayBhIGRpcmVjdCBjb252ZXJ0ZXJcblx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIHByZXYgKyBcIiBcIiArIGN1cnJlbnQgXSB8fCBjb252ZXJ0ZXJzWyBcIiogXCIgKyBjdXJyZW50IF07XG5cblx0XHRcdFx0Ly8gSWYgbm9uZSBmb3VuZCwgc2VlayBhIHBhaXJcblx0XHRcdFx0aWYgKCAhY29udiApIHtcblx0XHRcdFx0XHRmb3IgKCBjb252MiBpbiBjb252ZXJ0ZXJzICkge1xuXG5cdFx0XHRcdFx0XHQvLyBJZiBjb252MiBvdXRwdXRzIGN1cnJlbnRcblx0XHRcdFx0XHRcdHRtcCA9IGNvbnYyLnNwbGl0KCBcIiBcIiApO1xuXHRcdFx0XHRcdFx0aWYgKCB0bXBbIDEgXSA9PT0gY3VycmVudCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBJZiBwcmV2IGNhbiBiZSBjb252ZXJ0ZWQgdG8gYWNjZXB0ZWQgaW5wdXRcblx0XHRcdFx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIHByZXYgKyBcIiBcIiArIHRtcFsgMCBdIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRjb252ZXJ0ZXJzWyBcIiogXCIgKyB0bXBbIDAgXSBdO1xuXHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBDb25kZW5zZSBlcXVpdmFsZW5jZSBjb252ZXJ0ZXJzXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBjb252ID09PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIGNvbnYyIF07XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBPdGhlcndpc2UsIGluc2VydCB0aGUgaW50ZXJtZWRpYXRlIGRhdGFUeXBlXG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggY29udmVydGVyc1sgY29udjIgXSAhPT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnQgPSB0bXBbIDAgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0bXBbIDEgXSApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFwcGx5IGNvbnZlcnRlciAoaWYgbm90IGFuIGVxdWl2YWxlbmNlKVxuXHRcdFx0XHRpZiAoIGNvbnYgIT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHQvLyBVbmxlc3MgZXJyb3JzIGFyZSBhbGxvd2VkIHRvIGJ1YmJsZSwgY2F0Y2ggYW5kIHJldHVybiB0aGVtXG5cdFx0XHRcdFx0aWYgKCBjb252ICYmIHMudGhyb3dzICkge1xuXHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0XHRzdGF0ZTogXCJwYXJzZXJlcnJvclwiLFxuXHRcdFx0XHRcdFx0XHRcdGVycm9yOiBjb252ID8gZSA6IFwiTm8gY29udmVyc2lvbiBmcm9tIFwiICsgcHJldiArIFwiIHRvIFwiICsgY3VycmVudFxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB7IHN0YXRlOiBcInN1Y2Nlc3NcIiwgZGF0YTogcmVzcG9uc2UgfTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIENvdW50ZXIgZm9yIGhvbGRpbmcgdGhlIG51bWJlciBvZiBhY3RpdmUgcXVlcmllc1xuXHRhY3RpdmU6IDAsXG5cblx0Ly8gTGFzdC1Nb2RpZmllZCBoZWFkZXIgY2FjaGUgZm9yIG5leHQgcmVxdWVzdFxuXHRsYXN0TW9kaWZpZWQ6IHt9LFxuXHRldGFnOiB7fSxcblxuXHRhamF4U2V0dGluZ3M6IHtcblx0XHR1cmw6IGxvY2F0aW9uLmhyZWYsXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRpc0xvY2FsOiBybG9jYWxQcm90b2NvbC50ZXN0KCBsb2NhdGlvbi5wcm90b2NvbCApLFxuXHRcdGdsb2JhbDogdHJ1ZSxcblx0XHRwcm9jZXNzRGF0YTogdHJ1ZSxcblx0XHRhc3luYzogdHJ1ZSxcblx0XHRjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9VVRGLThcIixcblxuXHRcdC8qXG5cdFx0dGltZW91dDogMCxcblx0XHRkYXRhOiBudWxsLFxuXHRcdGRhdGFUeXBlOiBudWxsLFxuXHRcdHVzZXJuYW1lOiBudWxsLFxuXHRcdHBhc3N3b3JkOiBudWxsLFxuXHRcdGNhY2hlOiBudWxsLFxuXHRcdHRocm93czogZmFsc2UsXG5cdFx0dHJhZGl0aW9uYWw6IGZhbHNlLFxuXHRcdGhlYWRlcnM6IHt9LFxuXHRcdCovXG5cblx0XHRhY2NlcHRzOiB7XG5cdFx0XHRcIipcIjogYWxsVHlwZXMsXG5cdFx0XHR0ZXh0OiBcInRleHQvcGxhaW5cIixcblx0XHRcdGh0bWw6IFwidGV4dC9odG1sXCIsXG5cdFx0XHR4bWw6IFwiYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbFwiLFxuXHRcdFx0anNvbjogXCJhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2phdmFzY3JpcHRcIlxuXHRcdH0sXG5cblx0XHRjb250ZW50czoge1xuXHRcdFx0eG1sOiAvXFxieG1sXFxiLyxcblx0XHRcdGh0bWw6IC9cXGJodG1sLyxcblx0XHRcdGpzb246IC9cXGJqc29uXFxiL1xuXHRcdH0sXG5cblx0XHRyZXNwb25zZUZpZWxkczoge1xuXHRcdFx0eG1sOiBcInJlc3BvbnNlWE1MXCIsXG5cdFx0XHR0ZXh0OiBcInJlc3BvbnNlVGV4dFwiLFxuXHRcdFx0anNvbjogXCJyZXNwb25zZUpTT05cIlxuXHRcdH0sXG5cblx0XHQvLyBEYXRhIGNvbnZlcnRlcnNcblx0XHQvLyBLZXlzIHNlcGFyYXRlIHNvdXJjZSAob3IgY2F0Y2hhbGwgXCIqXCIpIGFuZCBkZXN0aW5hdGlvbiB0eXBlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXG5cdFx0Y29udmVydGVyczoge1xuXG5cdFx0XHQvLyBDb252ZXJ0IGFueXRoaW5nIHRvIHRleHRcblx0XHRcdFwiKiB0ZXh0XCI6IFN0cmluZyxcblxuXHRcdFx0Ly8gVGV4dCB0byBodG1sICh0cnVlID0gbm8gdHJhbnNmb3JtYXRpb24pXG5cdFx0XHRcInRleHQgaHRtbFwiOiB0cnVlLFxuXG5cdFx0XHQvLyBFdmFsdWF0ZSB0ZXh0IGFzIGEganNvbiBleHByZXNzaW9uXG5cdFx0XHRcInRleHQganNvblwiOiBKU09OLnBhcnNlLFxuXG5cdFx0XHQvLyBQYXJzZSB0ZXh0IGFzIHhtbFxuXHRcdFx0XCJ0ZXh0IHhtbFwiOiBqUXVlcnkucGFyc2VYTUxcblx0XHR9LFxuXG5cdFx0Ly8gRm9yIG9wdGlvbnMgdGhhdCBzaG91bGRuJ3QgYmUgZGVlcCBleHRlbmRlZDpcblx0XHQvLyB5b3UgY2FuIGFkZCB5b3VyIG93biBjdXN0b20gb3B0aW9ucyBoZXJlIGlmXG5cdFx0Ly8gYW5kIHdoZW4geW91IGNyZWF0ZSBvbmUgdGhhdCBzaG91bGRuJ3QgYmVcblx0XHQvLyBkZWVwIGV4dGVuZGVkIChzZWUgYWpheEV4dGVuZClcblx0XHRmbGF0T3B0aW9uczoge1xuXHRcdFx0dXJsOiB0cnVlLFxuXHRcdFx0Y29udGV4dDogdHJ1ZVxuXHRcdH1cblx0fSxcblxuXHQvLyBDcmVhdGVzIGEgZnVsbCBmbGVkZ2VkIHNldHRpbmdzIG9iamVjdCBpbnRvIHRhcmdldFxuXHQvLyB3aXRoIGJvdGggYWpheFNldHRpbmdzIGFuZCBzZXR0aW5ncyBmaWVsZHMuXG5cdC8vIElmIHRhcmdldCBpcyBvbWl0dGVkLCB3cml0ZXMgaW50byBhamF4U2V0dGluZ3MuXG5cdGFqYXhTZXR1cDogZnVuY3Rpb24oIHRhcmdldCwgc2V0dGluZ3MgKSB7XG5cdFx0cmV0dXJuIHNldHRpbmdzID9cblxuXHRcdFx0Ly8gQnVpbGRpbmcgYSBzZXR0aW5ncyBvYmplY3Rcblx0XHRcdGFqYXhFeHRlbmQoIGFqYXhFeHRlbmQoIHRhcmdldCwgalF1ZXJ5LmFqYXhTZXR0aW5ncyApLCBzZXR0aW5ncyApIDpcblxuXHRcdFx0Ly8gRXh0ZW5kaW5nIGFqYXhTZXR0aW5nc1xuXHRcdFx0YWpheEV4dGVuZCggalF1ZXJ5LmFqYXhTZXR0aW5ncywgdGFyZ2V0ICk7XG5cdH0sXG5cblx0YWpheFByZWZpbHRlcjogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzICksXG5cdGFqYXhUcmFuc3BvcnQ6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cyApLFxuXG5cdC8vIE1haW4gbWV0aG9kXG5cdGFqYXg6IGZ1bmN0aW9uKCB1cmwsIG9wdGlvbnMgKSB7XG5cblx0XHQvLyBJZiB1cmwgaXMgYW4gb2JqZWN0LCBzaW11bGF0ZSBwcmUtMS41IHNpZ25hdHVyZVxuXHRcdGlmICggdHlwZW9mIHVybCA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdG9wdGlvbnMgPSB1cmw7XG5cdFx0XHR1cmwgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gRm9yY2Ugb3B0aW9ucyB0byBiZSBhbiBvYmplY3Rcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdHZhciB0cmFuc3BvcnQsXG5cblx0XHRcdC8vIFVSTCB3aXRob3V0IGFudGktY2FjaGUgcGFyYW1cblx0XHRcdGNhY2hlVVJMLFxuXG5cdFx0XHQvLyBSZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcsXG5cdFx0XHRyZXNwb25zZUhlYWRlcnMsXG5cblx0XHRcdC8vIHRpbWVvdXQgaGFuZGxlXG5cdFx0XHR0aW1lb3V0VGltZXIsXG5cblx0XHRcdC8vIFVybCBjbGVhbnVwIHZhclxuXHRcdFx0dXJsQW5jaG9yLFxuXG5cdFx0XHQvLyBSZXF1ZXN0IHN0YXRlIChiZWNvbWVzIGZhbHNlIHVwb24gc2VuZCBhbmQgdHJ1ZSB1cG9uIGNvbXBsZXRpb24pXG5cdFx0XHRjb21wbGV0ZWQsXG5cblx0XHRcdC8vIFRvIGtub3cgaWYgZ2xvYmFsIGV2ZW50cyBhcmUgdG8gYmUgZGlzcGF0Y2hlZFxuXHRcdFx0ZmlyZUdsb2JhbHMsXG5cblx0XHRcdC8vIExvb3AgdmFyaWFibGVcblx0XHRcdGksXG5cblx0XHRcdC8vIHVuY2FjaGVkIHBhcnQgb2YgdGhlIHVybFxuXHRcdFx0dW5jYWNoZWQsXG5cblx0XHRcdC8vIENyZWF0ZSB0aGUgZmluYWwgb3B0aW9ucyBvYmplY3Rcblx0XHRcdHMgPSBqUXVlcnkuYWpheFNldHVwKCB7fSwgb3B0aW9ucyApLFxuXG5cdFx0XHQvLyBDYWxsYmFja3MgY29udGV4dFxuXHRcdFx0Y2FsbGJhY2tDb250ZXh0ID0gcy5jb250ZXh0IHx8IHMsXG5cblx0XHRcdC8vIENvbnRleHQgZm9yIGdsb2JhbCBldmVudHMgaXMgY2FsbGJhY2tDb250ZXh0IGlmIGl0IGlzIGEgRE9NIG5vZGUgb3IgalF1ZXJ5IGNvbGxlY3Rpb25cblx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dCA9IHMuY29udGV4dCAmJlxuXHRcdFx0XHQoIGNhbGxiYWNrQ29udGV4dC5ub2RlVHlwZSB8fCBjYWxsYmFja0NvbnRleHQuanF1ZXJ5ICkgP1xuXHRcdFx0XHRqUXVlcnkoIGNhbGxiYWNrQ29udGV4dCApIDpcblx0XHRcdFx0alF1ZXJ5LmV2ZW50LFxuXG5cdFx0XHQvLyBEZWZlcnJlZHNcblx0XHRcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRjb21wbGV0ZURlZmVycmVkID0galF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRzdGF0dXNDb2RlID0gcy5zdGF0dXNDb2RlIHx8IHt9LFxuXG5cdFx0XHQvLyBIZWFkZXJzICh0aGV5IGFyZSBzZW50IGFsbCBhdCBvbmNlKVxuXHRcdFx0cmVxdWVzdEhlYWRlcnMgPSB7fSxcblx0XHRcdHJlcXVlc3RIZWFkZXJzTmFtZXMgPSB7fSxcblxuXHRcdFx0Ly8gRGVmYXVsdCBhYm9ydCBtZXNzYWdlXG5cdFx0XHRzdHJBYm9ydCA9IFwiY2FuY2VsZWRcIixcblxuXHRcdFx0Ly8gRmFrZSB4aHJcblx0XHRcdGpxWEhSID0ge1xuXHRcdFx0XHRyZWFkeVN0YXRlOiAwLFxuXG5cdFx0XHRcdC8vIEJ1aWxkcyBoZWFkZXJzIGhhc2h0YWJsZSBpZiBuZWVkZWRcblx0XHRcdFx0Z2V0UmVzcG9uc2VIZWFkZXI6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRcdFx0dmFyIG1hdGNoO1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRcdFx0aWYgKCAhcmVzcG9uc2VIZWFkZXJzICkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnMgPSB7fTtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAoIG1hdGNoID0gcmhlYWRlcnMuZXhlYyggcmVzcG9uc2VIZWFkZXJzU3RyaW5nICkgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnNbIG1hdGNoWyAxIF0udG9Mb3dlckNhc2UoKSArIFwiIFwiIF0gPVxuXHRcdFx0XHRcdFx0XHRcdFx0KCByZXNwb25zZUhlYWRlcnNbIG1hdGNoWyAxIF0udG9Mb3dlckNhc2UoKSArIFwiIFwiIF0gfHwgW10gKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuY29uY2F0KCBtYXRjaFsgMiBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG1hdGNoID0gcmVzcG9uc2VIZWFkZXJzWyBrZXkudG9Mb3dlckNhc2UoKSArIFwiIFwiIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBtYXRjaCA9PSBudWxsID8gbnVsbCA6IG1hdGNoLmpvaW4oIFwiLCBcIiApO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFJhdyBzdHJpbmdcblx0XHRcdFx0Z2V0QWxsUmVzcG9uc2VIZWFkZXJzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gY29tcGxldGVkID8gcmVzcG9uc2VIZWFkZXJzU3RyaW5nIDogbnVsbDtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYWNoZXMgdGhlIGhlYWRlclxuXHRcdFx0XHRzZXRSZXF1ZXN0SGVhZGVyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdG5hbWUgPSByZXF1ZXN0SGVhZGVyc05hbWVzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSA9XG5cdFx0XHRcdFx0XHRcdHJlcXVlc3RIZWFkZXJzTmFtZXNbIG5hbWUudG9Mb3dlckNhc2UoKSBdIHx8IG5hbWU7XG5cdFx0XHRcdFx0XHRyZXF1ZXN0SGVhZGVyc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlcyByZXNwb25zZSBjb250ZW50LXR5cGUgaGVhZGVyXG5cdFx0XHRcdG92ZXJyaWRlTWltZVR5cGU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRzLm1pbWVUeXBlID0gdHlwZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdFx0c3RhdHVzQ29kZTogZnVuY3Rpb24oIG1hcCApIHtcblx0XHRcdFx0XHR2YXIgY29kZTtcblx0XHRcdFx0XHRpZiAoIG1hcCApIHtcblx0XHRcdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEV4ZWN1dGUgdGhlIGFwcHJvcHJpYXRlIGNhbGxiYWNrc1xuXHRcdFx0XHRcdFx0XHRqcVhIUi5hbHdheXMoIG1hcFsganFYSFIuc3RhdHVzIF0gKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gTGF6eS1hZGQgdGhlIG5ldyBjYWxsYmFja3MgaW4gYSB3YXkgdGhhdCBwcmVzZXJ2ZXMgb2xkIG9uZXNcblx0XHRcdFx0XHRcdFx0Zm9yICggY29kZSBpbiBtYXAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdHVzQ29kZVsgY29kZSBdID0gWyBzdGF0dXNDb2RlWyBjb2RlIF0sIG1hcFsgY29kZSBdIF07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FuY2VsIHRoZSByZXF1ZXN0XG5cdFx0XHRcdGFib3J0OiBmdW5jdGlvbiggc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHR2YXIgZmluYWxUZXh0ID0gc3RhdHVzVGV4dCB8fCBzdHJBYm9ydDtcblx0XHRcdFx0XHRpZiAoIHRyYW5zcG9ydCApIHtcblx0XHRcdFx0XHRcdHRyYW5zcG9ydC5hYm9ydCggZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRvbmUoIDAsIGZpbmFsVGV4dCApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0Ly8gQXR0YWNoIGRlZmVycmVkc1xuXHRcdGRlZmVycmVkLnByb21pc2UoIGpxWEhSICk7XG5cblx0XHQvLyBBZGQgcHJvdG9jb2wgaWYgbm90IHByb3ZpZGVkIChwcmVmaWx0ZXJzIG1pZ2h0IGV4cGVjdCBpdClcblx0XHQvLyBIYW5kbGUgZmFsc3kgdXJsIGluIHRoZSBzZXR0aW5ncyBvYmplY3QgKCMxMDA5MzogY29uc2lzdGVuY3kgd2l0aCBvbGQgc2lnbmF0dXJlKVxuXHRcdC8vIFdlIGFsc28gdXNlIHRoZSB1cmwgcGFyYW1ldGVyIGlmIGF2YWlsYWJsZVxuXHRcdHMudXJsID0gKCAoIHVybCB8fCBzLnVybCB8fCBsb2NhdGlvbi5ocmVmICkgKyBcIlwiIClcblx0XHRcdC5yZXBsYWNlKCBycHJvdG9jb2wsIGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICk7XG5cblx0XHQvLyBBbGlhcyBtZXRob2Qgb3B0aW9uIHRvIHR5cGUgYXMgcGVyIHRpY2tldCAjMTIwMDRcblx0XHRzLnR5cGUgPSBvcHRpb25zLm1ldGhvZCB8fCBvcHRpb25zLnR5cGUgfHwgcy5tZXRob2QgfHwgcy50eXBlO1xuXG5cdFx0Ly8gRXh0cmFjdCBkYXRhVHlwZXMgbGlzdFxuXHRcdHMuZGF0YVR5cGVzID0gKCBzLmRhdGFUeXBlIHx8IFwiKlwiICkudG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXG5cdFx0Ly8gQSBjcm9zcy1kb21haW4gcmVxdWVzdCBpcyBpbiBvcmRlciB3aGVuIHRoZSBvcmlnaW4gZG9lc24ndCBtYXRjaCB0aGUgY3VycmVudCBvcmlnaW4uXG5cdFx0aWYgKCBzLmNyb3NzRG9tYWluID09IG51bGwgKSB7XG5cdFx0XHR1cmxBbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTggLSAxMSwgRWRnZSAxMiAtIDE1XG5cdFx0XHQvLyBJRSB0aHJvd3MgZXhjZXB0aW9uIG9uIGFjY2Vzc2luZyB0aGUgaHJlZiBwcm9wZXJ0eSBpZiB1cmwgaXMgbWFsZm9ybWVkLFxuXHRcdFx0Ly8gZS5nLiBodHRwOi8vZXhhbXBsZS5jb206ODB4L1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dXJsQW5jaG9yLmhyZWYgPSBzLnVybDtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTggLSAxMSBvbmx5XG5cdFx0XHRcdC8vIEFuY2hvcidzIGhvc3QgcHJvcGVydHkgaXNuJ3QgY29ycmVjdGx5IHNldCB3aGVuIHMudXJsIGlzIHJlbGF0aXZlXG5cdFx0XHRcdHVybEFuY2hvci5ocmVmID0gdXJsQW5jaG9yLmhyZWY7XG5cdFx0XHRcdHMuY3Jvc3NEb21haW4gPSBvcmlnaW5BbmNob3IucHJvdG9jb2wgKyBcIi8vXCIgKyBvcmlnaW5BbmNob3IuaG9zdCAhPT1cblx0XHRcdFx0XHR1cmxBbmNob3IucHJvdG9jb2wgKyBcIi8vXCIgKyB1cmxBbmNob3IuaG9zdDtcblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdC8vIElmIHRoZXJlIGlzIGFuIGVycm9yIHBhcnNpbmcgdGhlIFVSTCwgYXNzdW1lIGl0IGlzIGNyb3NzRG9tYWluLFxuXHRcdFx0XHQvLyBpdCBjYW4gYmUgcmVqZWN0ZWQgYnkgdGhlIHRyYW5zcG9ydCBpZiBpdCBpcyBpbnZhbGlkXG5cdFx0XHRcdHMuY3Jvc3NEb21haW4gPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgZGF0YSBpZiBub3QgYWxyZWFkeSBhIHN0cmluZ1xuXHRcdGlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiYgdHlwZW9mIHMuZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHMuZGF0YSA9IGpRdWVyeS5wYXJhbSggcy5kYXRhLCBzLnRyYWRpdGlvbmFsICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgcHJlZmlsdGVyc1xuXHRcdGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG5cdFx0Ly8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYSBwcmVmaWx0ZXIsIHN0b3AgdGhlcmVcblx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdHJldHVybiBqcVhIUjtcblx0XHR9XG5cblx0XHQvLyBXZSBjYW4gZmlyZSBnbG9iYWwgZXZlbnRzIGFzIG9mIG5vdyBpZiBhc2tlZCB0b1xuXHRcdC8vIERvbid0IGZpcmUgZXZlbnRzIGlmIGpRdWVyeS5ldmVudCBpcyB1bmRlZmluZWQgaW4gYW4gQU1ELXVzYWdlIHNjZW5hcmlvICgjMTUxMTgpXG5cdFx0ZmlyZUdsb2JhbHMgPSBqUXVlcnkuZXZlbnQgJiYgcy5nbG9iYWw7XG5cblx0XHQvLyBXYXRjaCBmb3IgYSBuZXcgc2V0IG9mIHJlcXVlc3RzXG5cdFx0aWYgKCBmaXJlR2xvYmFscyAmJiBqUXVlcnkuYWN0aXZlKysgPT09IDAgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXCJhamF4U3RhcnRcIiApO1xuXHRcdH1cblxuXHRcdC8vIFVwcGVyY2FzZSB0aGUgdHlwZVxuXHRcdHMudHlwZSA9IHMudHlwZS50b1VwcGVyQ2FzZSgpO1xuXG5cdFx0Ly8gRGV0ZXJtaW5lIGlmIHJlcXVlc3QgaGFzIGNvbnRlbnRcblx0XHRzLmhhc0NvbnRlbnQgPSAhcm5vQ29udGVudC50ZXN0KCBzLnR5cGUgKTtcblxuXHRcdC8vIFNhdmUgdGhlIFVSTCBpbiBjYXNlIHdlJ3JlIHRveWluZyB3aXRoIHRoZSBJZi1Nb2RpZmllZC1TaW5jZVxuXHRcdC8vIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciBsYXRlciBvblxuXHRcdC8vIFJlbW92ZSBoYXNoIHRvIHNpbXBsaWZ5IHVybCBtYW5pcHVsYXRpb25cblx0XHRjYWNoZVVSTCA9IHMudXJsLnJlcGxhY2UoIHJoYXNoLCBcIlwiICk7XG5cblx0XHQvLyBNb3JlIG9wdGlvbnMgaGFuZGxpbmcgZm9yIHJlcXVlc3RzIHdpdGggbm8gY29udGVudFxuXHRcdGlmICggIXMuaGFzQ29udGVudCApIHtcblxuXHRcdFx0Ly8gUmVtZW1iZXIgdGhlIGhhc2ggc28gd2UgY2FuIHB1dCBpdCBiYWNrXG5cdFx0XHR1bmNhY2hlZCA9IHMudXJsLnNsaWNlKCBjYWNoZVVSTC5sZW5ndGggKTtcblxuXHRcdFx0Ly8gSWYgZGF0YSBpcyBhdmFpbGFibGUgYW5kIHNob3VsZCBiZSBwcm9jZXNzZWQsIGFwcGVuZCBkYXRhIHRvIHVybFxuXHRcdFx0aWYgKCBzLmRhdGEgJiYgKCBzLnByb2Nlc3NEYXRhIHx8IHR5cGVvZiBzLmRhdGEgPT09IFwic3RyaW5nXCIgKSApIHtcblx0XHRcdFx0Y2FjaGVVUkwgKz0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuZGF0YTtcblxuXHRcdFx0XHQvLyAjOTY4MjogcmVtb3ZlIGRhdGEgc28gdGhhdCBpdCdzIG5vdCB1c2VkIGluIGFuIGV2ZW50dWFsIHJldHJ5XG5cdFx0XHRcdGRlbGV0ZSBzLmRhdGE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBvciB1cGRhdGUgYW50aS1jYWNoZSBwYXJhbSBpZiBuZWVkZWRcblx0XHRcdGlmICggcy5jYWNoZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdGNhY2hlVVJMID0gY2FjaGVVUkwucmVwbGFjZSggcmFudGlDYWNoZSwgXCIkMVwiICk7XG5cdFx0XHRcdHVuY2FjaGVkID0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIFwiXz1cIiArICggbm9uY2UuZ3VpZCsrICkgK1xuXHRcdFx0XHRcdHVuY2FjaGVkO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQdXQgaGFzaCBhbmQgYW50aS1jYWNoZSBvbiB0aGUgVVJMIHRoYXQgd2lsbCBiZSByZXF1ZXN0ZWQgKGdoLTE3MzIpXG5cdFx0XHRzLnVybCA9IGNhY2hlVVJMICsgdW5jYWNoZWQ7XG5cblx0XHQvLyBDaGFuZ2UgJyUyMCcgdG8gJysnIGlmIHRoaXMgaXMgZW5jb2RlZCBmb3JtIGJvZHkgY29udGVudCAoZ2gtMjY1OClcblx0XHR9IGVsc2UgaWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJlxuXHRcdFx0KCBzLmNvbnRlbnRUeXBlIHx8IFwiXCIgKS5pbmRleE9mKCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiICkgPT09IDAgKSB7XG5cdFx0XHRzLmRhdGEgPSBzLmRhdGEucmVwbGFjZSggcjIwLCBcIitcIiApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTW9kaWZpZWQtU2luY2VcIiwgalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApIHtcblx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Ob25lLU1hdGNoXCIsIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBjb3JyZWN0IGhlYWRlciwgaWYgZGF0YSBpcyBiZWluZyBzZW50XG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5oYXNDb250ZW50ICYmIHMuY29udGVudFR5cGUgIT09IGZhbHNlIHx8IG9wdGlvbnMuY29udGVudFR5cGUgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiLCBzLmNvbnRlbnRUeXBlICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBBY2NlcHRzIGhlYWRlciBmb3IgdGhlIHNlcnZlciwgZGVwZW5kaW5nIG9uIHRoZSBkYXRhVHlwZVxuXHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoXG5cdFx0XHRcIkFjY2VwdFwiLFxuXHRcdFx0cy5kYXRhVHlwZXNbIDAgXSAmJiBzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSA/XG5cdFx0XHRcdHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbIDAgXSBdICtcblx0XHRcdFx0XHQoIHMuZGF0YVR5cGVzWyAwIF0gIT09IFwiKlwiID8gXCIsIFwiICsgYWxsVHlwZXMgKyBcIjsgcT0wLjAxXCIgOiBcIlwiICkgOlxuXHRcdFx0XHRzLmFjY2VwdHNbIFwiKlwiIF1cblx0XHQpO1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIGhlYWRlcnMgb3B0aW9uXG5cdFx0Zm9yICggaSBpbiBzLmhlYWRlcnMgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBzLmhlYWRlcnNbIGkgXSApO1xuXHRcdH1cblxuXHRcdC8vIEFsbG93IGN1c3RvbSBoZWFkZXJzL21pbWV0eXBlcyBhbmQgZWFybHkgYWJvcnRcblx0XHRpZiAoIHMuYmVmb3JlU2VuZCAmJlxuXHRcdFx0KCBzLmJlZm9yZVNlbmQuY2FsbCggY2FsbGJhY2tDb250ZXh0LCBqcVhIUiwgcyApID09PSBmYWxzZSB8fCBjb21wbGV0ZWQgKSApIHtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgbm90IGRvbmUgYWxyZWFkeSBhbmQgcmV0dXJuXG5cdFx0XHRyZXR1cm4ganFYSFIuYWJvcnQoKTtcblx0XHR9XG5cblx0XHQvLyBBYm9ydGluZyBpcyBubyBsb25nZXIgYSBjYW5jZWxsYXRpb25cblx0XHRzdHJBYm9ydCA9IFwiYWJvcnRcIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tzIG9uIGRlZmVycmVkc1xuXHRcdGNvbXBsZXRlRGVmZXJyZWQuYWRkKCBzLmNvbXBsZXRlICk7XG5cdFx0anFYSFIuZG9uZSggcy5zdWNjZXNzICk7XG5cdFx0anFYSFIuZmFpbCggcy5lcnJvciApO1xuXG5cdFx0Ly8gR2V0IHRyYW5zcG9ydFxuXHRcdHRyYW5zcG9ydCA9IGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG5cdFx0Ly8gSWYgbm8gdHJhbnNwb3J0LCB3ZSBhdXRvLWFib3J0XG5cdFx0aWYgKCAhdHJhbnNwb3J0ICkge1xuXHRcdFx0ZG9uZSggLTEsIFwiTm8gVHJhbnNwb3J0XCIgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IDE7XG5cblx0XHRcdC8vIFNlbmQgZ2xvYmFsIGV2ZW50XG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4U2VuZFwiLCBbIGpxWEhSLCBzIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYWpheFNlbmQsIHN0b3AgdGhlcmVcblx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRyZXR1cm4ganFYSFI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRpbWVvdXRcblx0XHRcdGlmICggcy5hc3luYyAmJiBzLnRpbWVvdXQgPiAwICkge1xuXHRcdFx0XHR0aW1lb3V0VGltZXIgPSB3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0anFYSFIuYWJvcnQoIFwidGltZW91dFwiICk7XG5cdFx0XHRcdH0sIHMudGltZW91dCApO1xuXHRcdFx0fVxuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRjb21wbGV0ZWQgPSBmYWxzZTtcblx0XHRcdFx0dHJhbnNwb3J0LnNlbmQoIHJlcXVlc3RIZWFkZXJzLCBkb25lICk7XG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHQvLyBSZXRocm93IHBvc3QtY29tcGxldGlvbiBleGNlcHRpb25zXG5cdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBQcm9wYWdhdGUgb3RoZXJzIGFzIHJlc3VsdHNcblx0XHRcdFx0ZG9uZSggLTEsIGUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsYmFjayBmb3Igd2hlbiBldmVyeXRoaW5nIGlzIGRvbmVcblx0XHRmdW5jdGlvbiBkb25lKCBzdGF0dXMsIG5hdGl2ZVN0YXR1c1RleHQsIHJlc3BvbnNlcywgaGVhZGVycyApIHtcblx0XHRcdHZhciBpc1N1Y2Nlc3MsIHN1Y2Nlc3MsIGVycm9yLCByZXNwb25zZSwgbW9kaWZpZWQsXG5cdFx0XHRcdHN0YXR1c1RleHQgPSBuYXRpdmVTdGF0dXNUZXh0O1xuXG5cdFx0XHQvLyBJZ25vcmUgcmVwZWF0IGludm9jYXRpb25zXG5cdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb21wbGV0ZWQgPSB0cnVlO1xuXG5cdFx0XHQvLyBDbGVhciB0aW1lb3V0IGlmIGl0IGV4aXN0c1xuXHRcdFx0aWYgKCB0aW1lb3V0VGltZXIgKSB7XG5cdFx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoIHRpbWVvdXRUaW1lciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBEZXJlZmVyZW5jZSB0cmFuc3BvcnQgZm9yIGVhcmx5IGdhcmJhZ2UgY29sbGVjdGlvblxuXHRcdFx0Ly8gKG5vIG1hdHRlciBob3cgbG9uZyB0aGUganFYSFIgb2JqZWN0IHdpbGwgYmUgdXNlZClcblx0XHRcdHRyYW5zcG9ydCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0Ly8gQ2FjaGUgcmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nID0gaGVhZGVycyB8fCBcIlwiO1xuXG5cdFx0XHQvLyBTZXQgcmVhZHlTdGF0ZVxuXHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IHN0YXR1cyA+IDAgPyA0IDogMDtcblxuXHRcdFx0Ly8gRGV0ZXJtaW5lIGlmIHN1Y2Nlc3NmdWxcblx0XHRcdGlzU3VjY2VzcyA9IHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwIHx8IHN0YXR1cyA9PT0gMzA0O1xuXG5cdFx0XHQvLyBHZXQgcmVzcG9uc2UgZGF0YVxuXHRcdFx0aWYgKCByZXNwb25zZXMgKSB7XG5cdFx0XHRcdHJlc3BvbnNlID0gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBVc2UgYSBub29wIGNvbnZlcnRlciBmb3IgbWlzc2luZyBzY3JpcHQgYnV0IG5vdCBpZiBqc29ucFxuXHRcdFx0aWYgKCAhaXNTdWNjZXNzICYmXG5cdFx0XHRcdGpRdWVyeS5pbkFycmF5KCBcInNjcmlwdFwiLCBzLmRhdGFUeXBlcyApID4gLTEgJiZcblx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIFwianNvblwiLCBzLmRhdGFUeXBlcyApIDwgMCApIHtcblx0XHRcdFx0cy5jb252ZXJ0ZXJzWyBcInRleHQgc2NyaXB0XCIgXSA9IGZ1bmN0aW9uKCkge307XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnZlcnQgbm8gbWF0dGVyIHdoYXQgKHRoYXQgd2F5IHJlc3BvbnNlWFhYIGZpZWxkcyBhcmUgYWx3YXlzIHNldClcblx0XHRcdHJlc3BvbnNlID0gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICk7XG5cblx0XHRcdC8vIElmIHN1Y2Nlc3NmdWwsIGhhbmRsZSB0eXBlIGNoYWluaW5nXG5cdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcblxuXHRcdFx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdFx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcblx0XHRcdFx0XHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkxhc3QtTW9kaWZpZWRcIiApO1xuXHRcdFx0XHRcdGlmICggbW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiZXRhZ1wiICk7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gaWYgbm8gY29udGVudFxuXHRcdFx0XHRpZiAoIHN0YXR1cyA9PT0gMjA0IHx8IHMudHlwZSA9PT0gXCJIRUFEXCIgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm9jb250ZW50XCI7XG5cblx0XHRcdFx0Ly8gaWYgbm90IG1vZGlmaWVkXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHN0YXR1cyA9PT0gMzA0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIm5vdG1vZGlmaWVkXCI7XG5cblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBkYXRhLCBsZXQncyBjb252ZXJ0IGl0XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IHJlc3BvbnNlLnN0YXRlO1xuXHRcdFx0XHRcdHN1Y2Nlc3MgPSByZXNwb25zZS5kYXRhO1xuXHRcdFx0XHRcdGVycm9yID0gcmVzcG9uc2UuZXJyb3I7XG5cdFx0XHRcdFx0aXNTdWNjZXNzID0gIWVycm9yO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEV4dHJhY3QgZXJyb3IgZnJvbSBzdGF0dXNUZXh0IGFuZCBub3JtYWxpemUgZm9yIG5vbi1hYm9ydHNcblx0XHRcdFx0ZXJyb3IgPSBzdGF0dXNUZXh0O1xuXHRcdFx0XHRpZiAoIHN0YXR1cyB8fCAhc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJlcnJvclwiO1xuXHRcdFx0XHRcdGlmICggc3RhdHVzIDwgMCApIHtcblx0XHRcdFx0XHRcdHN0YXR1cyA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCBkYXRhIGZvciB0aGUgZmFrZSB4aHIgb2JqZWN0XG5cdFx0XHRqcVhIUi5zdGF0dXMgPSBzdGF0dXM7XG5cdFx0XHRqcVhIUi5zdGF0dXNUZXh0ID0gKCBuYXRpdmVTdGF0dXNUZXh0IHx8IHN0YXR1c1RleHQgKSArIFwiXCI7XG5cblx0XHRcdC8vIFN1Y2Nlc3MvRXJyb3Jcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIHN1Y2Nlc3MsIHN0YXR1c1RleHQsIGpxWEhSIF0gKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCwgZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0anFYSFIuc3RhdHVzQ29kZSggc3RhdHVzQ29kZSApO1xuXHRcdFx0c3RhdHVzQ29kZSA9IHVuZGVmaW5lZDtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIGlzU3VjY2VzcyA/IFwiYWpheFN1Y2Nlc3NcIiA6IFwiYWpheEVycm9yXCIsXG5cdFx0XHRcdFx0WyBqcVhIUiwgcywgaXNTdWNjZXNzID8gc3VjY2VzcyA6IGVycm9yIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29tcGxldGVcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQuZmlyZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCBdICk7XG5cblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhDb21wbGV0ZVwiLCBbIGpxWEhSLCBzIF0gKTtcblxuXHRcdFx0XHQvLyBIYW5kbGUgdGhlIGdsb2JhbCBBSkFYIGNvdW50ZXJcblx0XHRcdFx0aWYgKCAhKCAtLWpRdWVyeS5hY3RpdmUgKSApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXCJhamF4U3RvcFwiICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4ganFYSFI7XG5cdH0sXG5cblx0Z2V0SlNPTjogZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgZGF0YSwgY2FsbGJhY2ssIFwianNvblwiICk7XG5cdH0sXG5cblx0Z2V0U2NyaXB0OiBmdW5jdGlvbiggdXJsLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCB1bmRlZmluZWQsIGNhbGxiYWNrLCBcInNjcmlwdFwiICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJnZXRcIiwgXCJwb3N0XCIgXSwgZnVuY3Rpb24oIF9pLCBtZXRob2QgKSB7XG5cdGpRdWVyeVsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjaywgdHlwZSApIHtcblxuXHRcdC8vIFNoaWZ0IGFyZ3VtZW50cyBpZiBkYXRhIGFyZ3VtZW50IHdhcyBvbWl0dGVkXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBkYXRhICkgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBjYWxsYmFjaztcblx0XHRcdGNhbGxiYWNrID0gZGF0YTtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gVGhlIHVybCBjYW4gYmUgYW4gb3B0aW9ucyBvYmplY3QgKHdoaWNoIHRoZW4gbXVzdCBoYXZlIC51cmwpXG5cdFx0cmV0dXJuIGpRdWVyeS5hamF4KCBqUXVlcnkuZXh0ZW5kKCB7XG5cdFx0XHR1cmw6IHVybCxcblx0XHRcdHR5cGU6IG1ldGhvZCxcblx0XHRcdGRhdGFUeXBlOiB0eXBlLFxuXHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdHN1Y2Nlc3M6IGNhbGxiYWNrXG5cdFx0fSwgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIHVybCApICYmIHVybCApICk7XG5cdH07XG59ICk7XG5cbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBmdW5jdGlvbiggcyApIHtcblx0dmFyIGk7XG5cdGZvciAoIGkgaW4gcy5oZWFkZXJzICkge1xuXHRcdGlmICggaS50b0xvd2VyQ2FzZSgpID09PSBcImNvbnRlbnQtdHlwZVwiICkge1xuXHRcdFx0cy5jb250ZW50VHlwZSA9IHMuaGVhZGVyc1sgaSBdIHx8IFwiXCI7XG5cdFx0fVxuXHR9XG59ICk7XG5cblxualF1ZXJ5Ll9ldmFsVXJsID0gZnVuY3Rpb24oIHVybCwgb3B0aW9ucywgZG9jICkge1xuXHRyZXR1cm4galF1ZXJ5LmFqYXgoIHtcblx0XHR1cmw6IHVybCxcblxuXHRcdC8vIE1ha2UgdGhpcyBleHBsaWNpdCwgc2luY2UgdXNlciBjYW4gb3ZlcnJpZGUgdGhpcyB0aHJvdWdoIGFqYXhTZXR1cCAoIzExMjY0KVxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0ZGF0YVR5cGU6IFwic2NyaXB0XCIsXG5cdFx0Y2FjaGU6IHRydWUsXG5cdFx0YXN5bmM6IGZhbHNlLFxuXHRcdGdsb2JhbDogZmFsc2UsXG5cblx0XHQvLyBPbmx5IGV2YWx1YXRlIHRoZSByZXNwb25zZSBpZiBpdCBpcyBzdWNjZXNzZnVsIChnaC00MTI2KVxuXHRcdC8vIGRhdGFGaWx0ZXIgaXMgbm90IGludm9rZWQgZm9yIGZhaWx1cmUgcmVzcG9uc2VzLCBzbyB1c2luZyBpdCBpbnN0ZWFkXG5cdFx0Ly8gb2YgdGhlIGRlZmF1bHQgY29udmVydGVyIGlzIGtsdWRneSBidXQgaXQgd29ya3MuXG5cdFx0Y29udmVydGVyczoge1xuXHRcdFx0XCJ0ZXh0IHNjcmlwdFwiOiBmdW5jdGlvbigpIHt9XG5cdFx0fSxcblx0XHRkYXRhRmlsdGVyOiBmdW5jdGlvbiggcmVzcG9uc2UgKSB7XG5cdFx0XHRqUXVlcnkuZ2xvYmFsRXZhbCggcmVzcG9uc2UsIG9wdGlvbnMsIGRvYyApO1xuXHRcdH1cblx0fSApO1xufTtcblxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHdyYXBBbGw6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciB3cmFwO1xuXG5cdFx0aWYgKCB0aGlzWyAwIF0gKSB7XG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdFx0aHRtbCA9IGh0bWwuY2FsbCggdGhpc1sgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRoZSBlbGVtZW50cyB0byB3cmFwIHRoZSB0YXJnZXQgYXJvdW5kXG5cdFx0XHR3cmFwID0galF1ZXJ5KCBodG1sLCB0aGlzWyAwIF0ub3duZXJEb2N1bWVudCApLmVxKCAwICkuY2xvbmUoIHRydWUgKTtcblxuXHRcdFx0aWYgKCB0aGlzWyAwIF0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0d3JhcC5pbnNlcnRCZWZvcmUoIHRoaXNbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHR3cmFwLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBlbGVtID0gdGhpcztcblxuXHRcdFx0XHR3aGlsZSAoIGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQgKSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZWxlbTtcblx0XHRcdH0gKS5hcHBlbmQoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR3cmFwSW5uZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdGlmICggaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBJbm5lciggaHRtbC5jYWxsKCB0aGlzLCBpICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWxmID0galF1ZXJ5KCB0aGlzICksXG5cdFx0XHRcdGNvbnRlbnRzID0gc2VsZi5jb250ZW50cygpO1xuXG5cdFx0XHRpZiAoIGNvbnRlbnRzLmxlbmd0aCApIHtcblx0XHRcdFx0Y29udGVudHMud3JhcEFsbCggaHRtbCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZWxmLmFwcGVuZCggaHRtbCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHR3cmFwOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgaHRtbElzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCBodG1sICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBBbGwoIGh0bWxJc0Z1bmN0aW9uID8gaHRtbC5jYWxsKCB0aGlzLCBpICkgOiBodG1sICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdHVud3JhcDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHRoaXMucGFyZW50KCBzZWxlY3RvciApLm5vdCggXCJib2R5XCIgKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLnJlcGxhY2VXaXRoKCB0aGlzLmNoaWxkTm9kZXMgKTtcblx0XHR9ICk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuZXhwci5wc2V1ZG9zLmhpZGRlbiA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4gIWpRdWVyeS5leHByLnBzZXVkb3MudmlzaWJsZSggZWxlbSApO1xufTtcbmpRdWVyeS5leHByLnBzZXVkb3MudmlzaWJsZSA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4gISEoIGVsZW0ub2Zmc2V0V2lkdGggfHwgZWxlbS5vZmZzZXRIZWlnaHQgfHwgZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApO1xufTtcblxuXG5cblxualF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIgPSBmdW5jdGlvbigpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gbmV3IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpO1xuXHR9IGNhdGNoICggZSApIHt9XG59O1xuXG52YXIgeGhyU3VjY2Vzc1N0YXR1cyA9IHtcblxuXHRcdC8vIEZpbGUgcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgY29kZSAwLCBhc3N1bWUgMjAwXG5cdFx0MDogMjAwLFxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHQvLyAjMTQ1MDogc29tZXRpbWVzIElFIHJldHVybnMgMTIyMyB3aGVuIGl0IHNob3VsZCBiZSAyMDRcblx0XHQxMjIzOiAyMDRcblx0fSxcblx0eGhyU3VwcG9ydGVkID0galF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIoKTtcblxuc3VwcG9ydC5jb3JzID0gISF4aHJTdXBwb3J0ZWQgJiYgKCBcIndpdGhDcmVkZW50aWFsc1wiIGluIHhoclN1cHBvcnRlZCApO1xuc3VwcG9ydC5hamF4ID0geGhyU3VwcG9ydGVkID0gISF4aHJTdXBwb3J0ZWQ7XG5cbmpRdWVyeS5hamF4VHJhbnNwb3J0KCBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0dmFyIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrO1xuXG5cdC8vIENyb3NzIGRvbWFpbiBvbmx5IGFsbG93ZWQgaWYgc3VwcG9ydGVkIHRocm91Z2ggWE1MSHR0cFJlcXVlc3Rcblx0aWYgKCBzdXBwb3J0LmNvcnMgfHwgeGhyU3VwcG9ydGVkICYmICFvcHRpb25zLmNyb3NzRG9tYWluICkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggaGVhZGVycywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHZhciBpLFxuXHRcdFx0XHRcdHhociA9IG9wdGlvbnMueGhyKCk7XG5cblx0XHRcdFx0eGhyLm9wZW4oXG5cdFx0XHRcdFx0b3B0aW9ucy50eXBlLFxuXHRcdFx0XHRcdG9wdGlvbnMudXJsLFxuXHRcdFx0XHRcdG9wdGlvbnMuYXN5bmMsXG5cdFx0XHRcdFx0b3B0aW9ucy51c2VybmFtZSxcblx0XHRcdFx0XHRvcHRpb25zLnBhc3N3b3JkXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0Ly8gQXBwbHkgY3VzdG9tIGZpZWxkcyBpZiBwcm92aWRlZFxuXHRcdFx0XHRpZiAoIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdGZvciAoIGkgaW4gb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0XHR4aHJbIGkgXSA9IG9wdGlvbnMueGhyRmllbGRzWyBpIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGUgbWltZSB0eXBlIGlmIG5lZWRlZFxuXHRcdFx0XHRpZiAoIG9wdGlvbnMubWltZVR5cGUgJiYgeGhyLm92ZXJyaWRlTWltZVR5cGUgKSB7XG5cdFx0XHRcdFx0eGhyLm92ZXJyaWRlTWltZVR5cGUoIG9wdGlvbnMubWltZVR5cGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFgtUmVxdWVzdGVkLVdpdGggaGVhZGVyXG5cdFx0XHRcdC8vIEZvciBjcm9zcy1kb21haW4gcmVxdWVzdHMsIHNlZWluZyBhcyBjb25kaXRpb25zIGZvciBhIHByZWZsaWdodCBhcmVcblx0XHRcdFx0Ly8gYWtpbiB0byBhIGppZ3NhdyBwdXp6bGUsIHdlIHNpbXBseSBuZXZlciBzZXQgaXQgdG8gYmUgc3VyZS5cblx0XHRcdFx0Ly8gKGl0IGNhbiBhbHdheXMgYmUgc2V0IG9uIGEgcGVyLXJlcXVlc3QgYmFzaXMgb3IgZXZlbiB1c2luZyBhamF4U2V0dXApXG5cdFx0XHRcdC8vIEZvciBzYW1lLWRvbWFpbiByZXF1ZXN0cywgd29uJ3QgY2hhbmdlIGhlYWRlciBpZiBhbHJlYWR5IHByb3ZpZGVkLlxuXHRcdFx0XHRpZiAoICFvcHRpb25zLmNyb3NzRG9tYWluICYmICFoZWFkZXJzWyBcIlgtUmVxdWVzdGVkLVdpdGhcIiBdICkge1xuXHRcdFx0XHRcdGhlYWRlcnNbIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiIF0gPSBcIlhNTEh0dHBSZXF1ZXN0XCI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTZXQgaGVhZGVyc1xuXHRcdFx0XHRmb3IgKCBpIGluIGhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoIGksIGhlYWRlcnNbIGkgXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ2FsbGJhY2tcblx0XHRcdFx0Y2FsbGJhY2sgPSBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayA9IGVycm9yQ2FsbGJhY2sgPSB4aHIub25sb2FkID1cblx0XHRcdFx0XHRcdFx0XHR4aHIub25lcnJvciA9IHhoci5vbmFib3J0ID0geGhyLm9udGltZW91dCA9XG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiYWJvcnRcIiApIHtcblx0XHRcdFx0XHRcdFx0XHR4aHIuYWJvcnQoKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJlcnJvclwiICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHRcdFx0XHQvLyBPbiBhIG1hbnVhbCBuYXRpdmUgYWJvcnQsIElFOSB0aHJvd3Ncblx0XHRcdFx0XHRcdFx0XHQvLyBlcnJvcnMgb24gYW55IHByb3BlcnR5IGFjY2VzcyB0aGF0IGlzIG5vdCByZWFkeVN0YXRlXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlb2YgeGhyLnN0YXR1cyAhPT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCAwLCBcImVycm9yXCIgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRmlsZTogcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgMDsgc2VlICM4NjA1LCAjMTQyMDdcblx0XHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHRcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyU3VjY2Vzc1N0YXR1c1sgeGhyLnN0YXR1cyBdIHx8IHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dCxcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHRcdFx0XHRcdC8vIElFOSBoYXMgbm8gWEhSMiBidXQgdGhyb3dzIG9uIGJpbmFyeSAodHJhYy0xMTQyNilcblx0XHRcdFx0XHRcdFx0XHRcdC8vIEZvciBYSFIyIG5vbi10ZXh0LCBsZXQgdGhlIGNhbGxlciBoYW5kbGUgaXQgKGdoLTI0OTgpXG5cdFx0XHRcdFx0XHRcdFx0XHQoIHhoci5yZXNwb25zZVR5cGUgfHwgXCJ0ZXh0XCIgKSAhPT0gXCJ0ZXh0XCIgIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgeGhyLnJlc3BvbnNlVGV4dCAhPT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgYmluYXJ5OiB4aHIucmVzcG9uc2UgfSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgdGV4dDogeGhyLnJlc3BvbnNlVGV4dCB9LFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG5cdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Ly8gTGlzdGVuIHRvIGV2ZW50c1xuXHRcdFx0XHR4aHIub25sb2FkID0gY2FsbGJhY2soKTtcblx0XHRcdFx0ZXJyb3JDYWxsYmFjayA9IHhoci5vbmVycm9yID0geGhyLm9udGltZW91dCA9IGNhbGxiYWNrKCBcImVycm9yXCIgKTtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA5IG9ubHlcblx0XHRcdFx0Ly8gVXNlIG9ucmVhZHlzdGF0ZWNoYW5nZSB0byByZXBsYWNlIG9uYWJvcnRcblx0XHRcdFx0Ly8gdG8gaGFuZGxlIHVuY2F1Z2h0IGFib3J0c1xuXHRcdFx0XHRpZiAoIHhoci5vbmFib3J0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0eGhyLm9uYWJvcnQgPSBlcnJvckNhbGxiYWNrO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdFx0Ly8gQ2hlY2sgcmVhZHlTdGF0ZSBiZWZvcmUgdGltZW91dCBhcyBpdCBjaGFuZ2VzXG5cdFx0XHRcdFx0XHRpZiAoIHhoci5yZWFkeVN0YXRlID09PSA0ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFsbG93IG9uZXJyb3IgdG8gYmUgY2FsbGVkIGZpcnN0LFxuXHRcdFx0XHRcdFx0XHQvLyBidXQgdGhhdCB3aWxsIG5vdCBoYW5kbGUgYSBuYXRpdmUgYWJvcnRcblx0XHRcdFx0XHRcdFx0Ly8gQWxzbywgc2F2ZSBlcnJvckNhbGxiYWNrIHRvIGEgdmFyaWFibGVcblx0XHRcdFx0XHRcdFx0Ly8gYXMgeGhyLm9uZXJyb3IgY2Fubm90IGJlIGFjY2Vzc2VkXG5cdFx0XHRcdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZXJyb3JDYWxsYmFjaygpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDcmVhdGUgdGhlIGFib3J0IGNhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gY2FsbGJhY2soIFwiYWJvcnRcIiApO1xuXG5cdFx0XHRcdHRyeSB7XG5cblx0XHRcdFx0XHQvLyBEbyBzZW5kIHRoZSByZXF1ZXN0ICh0aGlzIG1heSByYWlzZSBhbiBleGNlcHRpb24pXG5cdFx0XHRcdFx0eGhyLnNlbmQoIG9wdGlvbnMuaGFzQ29udGVudCAmJiBvcHRpb25zLmRhdGEgfHwgbnVsbCApO1xuXHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdC8vICMxNDY4MzogT25seSByZXRocm93IGlmIHRoaXMgaGFzbid0IGJlZW4gbm90aWZpZWQgYXMgYW4gZXJyb3IgeWV0XG5cdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gUHJldmVudCBhdXRvLWV4ZWN1dGlvbiBvZiBzY3JpcHRzIHdoZW4gbm8gZXhwbGljaXQgZGF0YVR5cGUgd2FzIHByb3ZpZGVkIChTZWUgZ2gtMjQzMilcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBmdW5jdGlvbiggcyApIHtcblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHMuY29udGVudHMuc2NyaXB0ID0gZmFsc2U7XG5cdH1cbn0gKTtcblxuLy8gSW5zdGFsbCBzY3JpcHQgZGF0YVR5cGVcbmpRdWVyeS5hamF4U2V0dXAoIHtcblx0YWNjZXB0czoge1xuXHRcdHNjcmlwdDogXCJ0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHQsIFwiICtcblx0XHRcdFwiYXBwbGljYXRpb24vZWNtYXNjcmlwdCwgYXBwbGljYXRpb24veC1lY21hc2NyaXB0XCJcblx0fSxcblx0Y29udGVudHM6IHtcblx0XHRzY3JpcHQ6IC9cXGIoPzpqYXZhfGVjbWEpc2NyaXB0XFxiL1xuXHR9LFxuXHRjb252ZXJ0ZXJzOiB7XG5cdFx0XCJ0ZXh0IHNjcmlwdFwiOiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCB0ZXh0ICk7XG5cdFx0XHRyZXR1cm4gdGV4dDtcblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gSGFuZGxlIGNhY2hlJ3Mgc3BlY2lhbCBjYXNlIGFuZCBjcm9zc0RvbWFpblxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXHRpZiAoIHMuY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRzLmNhY2hlID0gZmFsc2U7XG5cdH1cblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHMudHlwZSA9IFwiR0VUXCI7XG5cdH1cbn0gKTtcblxuLy8gQmluZCBzY3JpcHQgdGFnIGhhY2sgdHJhbnNwb3J0XG5qUXVlcnkuYWpheFRyYW5zcG9ydCggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cblx0Ly8gVGhpcyB0cmFuc3BvcnQgb25seSBkZWFscyB3aXRoIGNyb3NzIGRvbWFpbiBvciBmb3JjZWQtYnktYXR0cnMgcmVxdWVzdHNcblx0aWYgKCBzLmNyb3NzRG9tYWluIHx8IHMuc2NyaXB0QXR0cnMgKSB7XG5cdFx0dmFyIHNjcmlwdCwgY2FsbGJhY2s7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBfLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0c2NyaXB0ID0galF1ZXJ5KCBcIjxzY3JpcHQ+XCIgKVxuXHRcdFx0XHRcdC5hdHRyKCBzLnNjcmlwdEF0dHJzIHx8IHt9IClcblx0XHRcdFx0XHQucHJvcCggeyBjaGFyc2V0OiBzLnNjcmlwdENoYXJzZXQsIHNyYzogcy51cmwgfSApXG5cdFx0XHRcdFx0Lm9uKCBcImxvYWQgZXJyb3JcIiwgY2FsbGJhY2sgPSBmdW5jdGlvbiggZXZ0ICkge1xuXHRcdFx0XHRcdFx0c2NyaXB0LnJlbW92ZSgpO1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBudWxsO1xuXHRcdFx0XHRcdFx0aWYgKCBldnQgKSB7XG5cdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCBldnQudHlwZSA9PT0gXCJlcnJvclwiID8gNDA0IDogMjAwLCBldnQudHlwZSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHQvLyBVc2UgbmF0aXZlIERPTSBtYW5pcHVsYXRpb24gdG8gYXZvaWQgb3VyIGRvbU1hbmlwIEFKQVggdHJpY2tlcnlcblx0XHRcdFx0ZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCggc2NyaXB0WyAwIF0gKTtcblx0XHRcdH0sXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxudmFyIG9sZENhbGxiYWNrcyA9IFtdLFxuXHRyanNvbnAgPSAvKD0pXFw/KD89JnwkKXxcXD9cXD8vO1xuXG4vLyBEZWZhdWx0IGpzb25wIHNldHRpbmdzXG5qUXVlcnkuYWpheFNldHVwKCB7XG5cdGpzb25wOiBcImNhbGxiYWNrXCIsXG5cdGpzb25wQ2FsbGJhY2s6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjYWxsYmFjayA9IG9sZENhbGxiYWNrcy5wb3AoKSB8fCAoIGpRdWVyeS5leHBhbmRvICsgXCJfXCIgKyAoIG5vbmNlLmd1aWQrKyApICk7XG5cdFx0dGhpc1sgY2FsbGJhY2sgXSA9IHRydWU7XG5cdFx0cmV0dXJuIGNhbGxiYWNrO1xuXHR9XG59ICk7XG5cbi8vIERldGVjdCwgbm9ybWFsaXplIG9wdGlvbnMgYW5kIGluc3RhbGwgY2FsbGJhY2tzIGZvciBqc29ucCByZXF1ZXN0c1xualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwianNvbiBqc29ucFwiLCBmdW5jdGlvbiggcywgb3JpZ2luYWxTZXR0aW5ncywganFYSFIgKSB7XG5cblx0dmFyIGNhbGxiYWNrTmFtZSwgb3ZlcndyaXR0ZW4sIHJlc3BvbnNlQ29udGFpbmVyLFxuXHRcdGpzb25Qcm9wID0gcy5qc29ucCAhPT0gZmFsc2UgJiYgKCByanNvbnAudGVzdCggcy51cmwgKSA/XG5cdFx0XHRcInVybFwiIDpcblx0XHRcdHR5cGVvZiBzLmRhdGEgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0KCBzLmNvbnRlbnRUeXBlIHx8IFwiXCIgKVxuXHRcdFx0XHRcdC5pbmRleE9mKCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiICkgPT09IDAgJiZcblx0XHRcdFx0cmpzb25wLnRlc3QoIHMuZGF0YSApICYmIFwiZGF0YVwiXG5cdFx0KTtcblxuXHQvLyBIYW5kbGUgaWZmIHRoZSBleHBlY3RlZCBkYXRhIHR5cGUgaXMgXCJqc29ucFwiIG9yIHdlIGhhdmUgYSBwYXJhbWV0ZXIgdG8gc2V0XG5cdGlmICgganNvblByb3AgfHwgcy5kYXRhVHlwZXNbIDAgXSA9PT0gXCJqc29ucFwiICkge1xuXG5cdFx0Ly8gR2V0IGNhbGxiYWNrIG5hbWUsIHJlbWVtYmVyaW5nIHByZWV4aXN0aW5nIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBpdFxuXHRcdGNhbGxiYWNrTmFtZSA9IHMuanNvbnBDYWxsYmFjayA9IGlzRnVuY3Rpb24oIHMuanNvbnBDYWxsYmFjayApID9cblx0XHRcdHMuanNvbnBDYWxsYmFjaygpIDpcblx0XHRcdHMuanNvbnBDYWxsYmFjaztcblxuXHRcdC8vIEluc2VydCBjYWxsYmFjayBpbnRvIHVybCBvciBmb3JtIGRhdGFcblx0XHRpZiAoIGpzb25Qcm9wICkge1xuXHRcdFx0c1sganNvblByb3AgXSA9IHNbIGpzb25Qcm9wIF0ucmVwbGFjZSggcmpzb25wLCBcIiQxXCIgKyBjYWxsYmFja05hbWUgKTtcblx0XHR9IGVsc2UgaWYgKCBzLmpzb25wICE9PSBmYWxzZSApIHtcblx0XHRcdHMudXJsICs9ICggcnF1ZXJ5LnRlc3QoIHMudXJsICkgPyBcIiZcIiA6IFwiP1wiICkgKyBzLmpzb25wICsgXCI9XCIgKyBjYWxsYmFja05hbWU7XG5cdFx0fVxuXG5cdFx0Ly8gVXNlIGRhdGEgY29udmVydGVyIHRvIHJldHJpZXZlIGpzb24gYWZ0ZXIgc2NyaXB0IGV4ZWN1dGlvblxuXHRcdHMuY29udmVydGVyc1sgXCJzY3JpcHQganNvblwiIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIXJlc3BvbnNlQ29udGFpbmVyICkge1xuXHRcdFx0XHRqUXVlcnkuZXJyb3IoIGNhbGxiYWNrTmFtZSArIFwiIHdhcyBub3QgY2FsbGVkXCIgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXNwb25zZUNvbnRhaW5lclsgMCBdO1xuXHRcdH07XG5cblx0XHQvLyBGb3JjZSBqc29uIGRhdGFUeXBlXG5cdFx0cy5kYXRhVHlwZXNbIDAgXSA9IFwianNvblwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja1xuXHRcdG92ZXJ3cml0dGVuID0gd2luZG93WyBjYWxsYmFja05hbWUgXTtcblx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IGFyZ3VtZW50cztcblx0XHR9O1xuXG5cdFx0Ly8gQ2xlYW4tdXAgZnVuY3Rpb24gKGZpcmVzIGFmdGVyIGNvbnZlcnRlcnMpXG5cdFx0anFYSFIuYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gSWYgcHJldmlvdXMgdmFsdWUgZGlkbid0IGV4aXN0IC0gcmVtb3ZlIGl0XG5cdFx0XHRpZiAoIG92ZXJ3cml0dGVuID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGpRdWVyeSggd2luZG93ICkucmVtb3ZlUHJvcCggY2FsbGJhY2tOYW1lICk7XG5cblx0XHRcdC8vIE90aGVyd2lzZSByZXN0b3JlIHByZWV4aXN0aW5nIHZhbHVlXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gb3ZlcndyaXR0ZW47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNhdmUgYmFjayBhcyBmcmVlXG5cdFx0XHRpZiAoIHNbIGNhbGxiYWNrTmFtZSBdICkge1xuXG5cdFx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHJlLXVzaW5nIHRoZSBvcHRpb25zIGRvZXNuJ3Qgc2NyZXcgdGhpbmdzIGFyb3VuZFxuXHRcdFx0XHRzLmpzb25wQ2FsbGJhY2sgPSBvcmlnaW5hbFNldHRpbmdzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHRcdFx0Ly8gU2F2ZSB0aGUgY2FsbGJhY2sgbmFtZSBmb3IgZnV0dXJlIHVzZVxuXHRcdFx0XHRvbGRDYWxsYmFja3MucHVzaCggY2FsbGJhY2tOYW1lICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENhbGwgaWYgaXQgd2FzIGEgZnVuY3Rpb24gYW5kIHdlIGhhdmUgYSByZXNwb25zZVxuXHRcdFx0aWYgKCByZXNwb25zZUNvbnRhaW5lciAmJiBpc0Z1bmN0aW9uKCBvdmVyd3JpdHRlbiApICkge1xuXHRcdFx0XHRvdmVyd3JpdHRlbiggcmVzcG9uc2VDb250YWluZXJbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IG92ZXJ3cml0dGVuID0gdW5kZWZpbmVkO1xuXHRcdH0gKTtcblxuXHRcdC8vIERlbGVnYXRlIHRvIHNjcmlwdFxuXHRcdHJldHVybiBcInNjcmlwdFwiO1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFN1cHBvcnQ6IFNhZmFyaSA4IG9ubHlcbi8vIEluIFNhZmFyaSA4IGRvY3VtZW50cyBjcmVhdGVkIHZpYSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnRcbi8vIGNvbGxhcHNlIHNpYmxpbmcgZm9ybXM6IHRoZSBzZWNvbmQgb25lIGJlY29tZXMgYSBjaGlsZCBvZiB0aGUgZmlyc3Qgb25lLlxuLy8gQmVjYXVzZSBvZiB0aGF0LCB0aGlzIHNlY3VyaXR5IG1lYXN1cmUgaGFzIHRvIGJlIGRpc2FibGVkIGluIFNhZmFyaSA4LlxuLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNzMzN1xuc3VwcG9ydC5jcmVhdGVIVE1MRG9jdW1lbnQgPSAoIGZ1bmN0aW9uKCkge1xuXHR2YXIgYm9keSA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCggXCJcIiApLmJvZHk7XG5cdGJvZHkuaW5uZXJIVE1MID0gXCI8Zm9ybT48L2Zvcm0+PGZvcm0+PC9mb3JtPlwiO1xuXHRyZXR1cm4gYm9keS5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMjtcbn0gKSgpO1xuXG5cbi8vIEFyZ3VtZW50IFwiZGF0YVwiIHNob3VsZCBiZSBzdHJpbmcgb2YgaHRtbFxuLy8gY29udGV4dCAob3B0aW9uYWwpOiBJZiBzcGVjaWZpZWQsIHRoZSBmcmFnbWVudCB3aWxsIGJlIGNyZWF0ZWQgaW4gdGhpcyBjb250ZXh0LFxuLy8gZGVmYXVsdHMgdG8gZG9jdW1lbnRcbi8vIGtlZXBTY3JpcHRzIChvcHRpb25hbCk6IElmIHRydWUsIHdpbGwgaW5jbHVkZSBzY3JpcHRzIHBhc3NlZCBpbiB0aGUgaHRtbCBzdHJpbmdcbmpRdWVyeS5wYXJzZUhUTUwgPSBmdW5jdGlvbiggZGF0YSwgY29udGV4dCwga2VlcFNjcmlwdHMgKSB7XG5cdGlmICggdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIFtdO1xuXHR9XG5cdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdGtlZXBTY3JpcHRzID0gY29udGV4dDtcblx0XHRjb250ZXh0ID0gZmFsc2U7XG5cdH1cblxuXHR2YXIgYmFzZSwgcGFyc2VkLCBzY3JpcHRzO1xuXG5cdGlmICggIWNvbnRleHQgKSB7XG5cblx0XHQvLyBTdG9wIHNjcmlwdHMgb3IgaW5saW5lIGV2ZW50IGhhbmRsZXJzIGZyb20gYmVpbmcgZXhlY3V0ZWQgaW1tZWRpYXRlbHlcblx0XHQvLyBieSB1c2luZyBkb2N1bWVudC5pbXBsZW1lbnRhdGlvblxuXHRcdGlmICggc3VwcG9ydC5jcmVhdGVIVE1MRG9jdW1lbnQgKSB7XG5cdFx0XHRjb250ZXh0ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCBcIlwiICk7XG5cblx0XHRcdC8vIFNldCB0aGUgYmFzZSBocmVmIGZvciB0aGUgY3JlYXRlZCBkb2N1bWVudFxuXHRcdFx0Ly8gc28gYW55IHBhcnNlZCBlbGVtZW50cyB3aXRoIFVSTHNcblx0XHRcdC8vIGFyZSBiYXNlZCBvbiB0aGUgZG9jdW1lbnQncyBVUkwgKGdoLTI5NjUpXG5cdFx0XHRiYXNlID0gY29udGV4dC5jcmVhdGVFbGVtZW50KCBcImJhc2VcIiApO1xuXHRcdFx0YmFzZS5ocmVmID0gZG9jdW1lbnQubG9jYXRpb24uaHJlZjtcblx0XHRcdGNvbnRleHQuaGVhZC5hcHBlbmRDaGlsZCggYmFzZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb250ZXh0ID0gZG9jdW1lbnQ7XG5cdFx0fVxuXHR9XG5cblx0cGFyc2VkID0gcnNpbmdsZVRhZy5leGVjKCBkYXRhICk7XG5cdHNjcmlwdHMgPSAha2VlcFNjcmlwdHMgJiYgW107XG5cblx0Ly8gU2luZ2xlIHRhZ1xuXHRpZiAoIHBhcnNlZCApIHtcblx0XHRyZXR1cm4gWyBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIHBhcnNlZFsgMSBdICkgXTtcblx0fVxuXG5cdHBhcnNlZCA9IGJ1aWxkRnJhZ21lbnQoIFsgZGF0YSBdLCBjb250ZXh0LCBzY3JpcHRzICk7XG5cblx0aWYgKCBzY3JpcHRzICYmIHNjcmlwdHMubGVuZ3RoICkge1xuXHRcdGpRdWVyeSggc2NyaXB0cyApLnJlbW92ZSgpO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5tZXJnZSggW10sIHBhcnNlZC5jaGlsZE5vZGVzICk7XG59O1xuXG5cbi8qKlxuICogTG9hZCBhIHVybCBpbnRvIGEgcGFnZVxuICovXG5qUXVlcnkuZm4ubG9hZCA9IGZ1bmN0aW9uKCB1cmwsIHBhcmFtcywgY2FsbGJhY2sgKSB7XG5cdHZhciBzZWxlY3RvciwgdHlwZSwgcmVzcG9uc2UsXG5cdFx0c2VsZiA9IHRoaXMsXG5cdFx0b2ZmID0gdXJsLmluZGV4T2YoIFwiIFwiICk7XG5cblx0aWYgKCBvZmYgPiAtMSApIHtcblx0XHRzZWxlY3RvciA9IHN0cmlwQW5kQ29sbGFwc2UoIHVybC5zbGljZSggb2ZmICkgKTtcblx0XHR1cmwgPSB1cmwuc2xpY2UoIDAsIG9mZiApO1xuXHR9XG5cblx0Ly8gSWYgaXQncyBhIGZ1bmN0aW9uXG5cdGlmICggaXNGdW5jdGlvbiggcGFyYW1zICkgKSB7XG5cblx0XHQvLyBXZSBhc3N1bWUgdGhhdCBpdCdzIHRoZSBjYWxsYmFja1xuXHRcdGNhbGxiYWNrID0gcGFyYW1zO1xuXHRcdHBhcmFtcyA9IHVuZGVmaW5lZDtcblxuXHQvLyBPdGhlcndpc2UsIGJ1aWxkIGEgcGFyYW0gc3RyaW5nXG5cdH0gZWxzZSBpZiAoIHBhcmFtcyAmJiB0eXBlb2YgcGFyYW1zID09PSBcIm9iamVjdFwiICkge1xuXHRcdHR5cGUgPSBcIlBPU1RcIjtcblx0fVxuXG5cdC8vIElmIHdlIGhhdmUgZWxlbWVudHMgdG8gbW9kaWZ5LCBtYWtlIHRoZSByZXF1ZXN0XG5cdGlmICggc2VsZi5sZW5ndGggPiAwICkge1xuXHRcdGpRdWVyeS5hamF4KCB7XG5cdFx0XHR1cmw6IHVybCxcblxuXHRcdFx0Ly8gSWYgXCJ0eXBlXCIgdmFyaWFibGUgaXMgdW5kZWZpbmVkLCB0aGVuIFwiR0VUXCIgbWV0aG9kIHdpbGwgYmUgdXNlZC5cblx0XHRcdC8vIE1ha2UgdmFsdWUgb2YgdGhpcyBmaWVsZCBleHBsaWNpdCBzaW5jZVxuXHRcdFx0Ly8gdXNlciBjYW4gb3ZlcnJpZGUgaXQgdGhyb3VnaCBhamF4U2V0dXAgbWV0aG9kXG5cdFx0XHR0eXBlOiB0eXBlIHx8IFwiR0VUXCIsXG5cdFx0XHRkYXRhVHlwZTogXCJodG1sXCIsXG5cdFx0XHRkYXRhOiBwYXJhbXNcblx0XHR9ICkuZG9uZSggZnVuY3Rpb24oIHJlc3BvbnNlVGV4dCApIHtcblxuXHRcdFx0Ly8gU2F2ZSByZXNwb25zZSBmb3IgdXNlIGluIGNvbXBsZXRlIGNhbGxiYWNrXG5cdFx0XHRyZXNwb25zZSA9IGFyZ3VtZW50cztcblxuXHRcdFx0c2VsZi5odG1sKCBzZWxlY3RvciA/XG5cblx0XHRcdFx0Ly8gSWYgYSBzZWxlY3RvciB3YXMgc3BlY2lmaWVkLCBsb2NhdGUgdGhlIHJpZ2h0IGVsZW1lbnRzIGluIGEgZHVtbXkgZGl2XG5cdFx0XHRcdC8vIEV4Y2x1ZGUgc2NyaXB0cyB0byBhdm9pZCBJRSAnUGVybWlzc2lvbiBEZW5pZWQnIGVycm9yc1xuXHRcdFx0XHRqUXVlcnkoIFwiPGRpdj5cIiApLmFwcGVuZCggalF1ZXJ5LnBhcnNlSFRNTCggcmVzcG9uc2VUZXh0ICkgKS5maW5kKCBzZWxlY3RvciApIDpcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgdXNlIHRoZSBmdWxsIHJlc3VsdFxuXHRcdFx0XHRyZXNwb25zZVRleHQgKTtcblxuXHRcdC8vIElmIHRoZSByZXF1ZXN0IHN1Y2NlZWRzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXCJkYXRhXCIsIFwic3RhdHVzXCIsIFwianFYSFJcIlxuXHRcdC8vIGJ1dCB0aGV5IGFyZSBpZ25vcmVkIGJlY2F1c2UgcmVzcG9uc2Ugd2FzIHNldCBhYm92ZS5cblx0XHQvLyBJZiBpdCBmYWlscywgdGhpcyBmdW5jdGlvbiBnZXRzIFwianFYSFJcIiwgXCJzdGF0dXNcIiwgXCJlcnJvclwiXG5cdFx0fSApLmFsd2F5cyggY2FsbGJhY2sgJiYgZnVuY3Rpb24oIGpxWEhSLCBzdGF0dXMgKSB7XG5cdFx0XHRzZWxmLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRjYWxsYmFjay5hcHBseSggdGhpcywgcmVzcG9uc2UgfHwgWyBqcVhIUi5yZXNwb25zZVRleHQsIHN0YXR1cywganFYSFIgXSApO1xuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fVxuXG5cdHJldHVybiB0aGlzO1xufTtcblxuXG5cblxualF1ZXJ5LmV4cHIucHNldWRvcy5hbmltYXRlZCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4galF1ZXJ5LmdyZXAoIGpRdWVyeS50aW1lcnMsIGZ1bmN0aW9uKCBmbiApIHtcblx0XHRyZXR1cm4gZWxlbSA9PT0gZm4uZWxlbTtcblx0fSApLmxlbmd0aDtcbn07XG5cblxuXG5cbmpRdWVyeS5vZmZzZXQgPSB7XG5cdHNldE9mZnNldDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGkgKSB7XG5cdFx0dmFyIGN1clBvc2l0aW9uLCBjdXJMZWZ0LCBjdXJDU1NUb3AsIGN1clRvcCwgY3VyT2Zmc2V0LCBjdXJDU1NMZWZ0LCBjYWxjdWxhdGVQb3NpdGlvbixcblx0XHRcdHBvc2l0aW9uID0galF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICksXG5cdFx0XHRjdXJFbGVtID0galF1ZXJ5KCBlbGVtICksXG5cdFx0XHRwcm9wcyA9IHt9O1xuXG5cdFx0Ly8gU2V0IHBvc2l0aW9uIGZpcnN0LCBpbi1jYXNlIHRvcC9sZWZ0IGFyZSBzZXQgZXZlbiBvbiBzdGF0aWMgZWxlbVxuXHRcdGlmICggcG9zaXRpb24gPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRlbGVtLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuXHRcdH1cblxuXHRcdGN1ck9mZnNldCA9IGN1ckVsZW0ub2Zmc2V0KCk7XG5cdFx0Y3VyQ1NTVG9wID0galF1ZXJ5LmNzcyggZWxlbSwgXCJ0b3BcIiApO1xuXHRcdGN1ckNTU0xlZnQgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImxlZnRcIiApO1xuXHRcdGNhbGN1bGF0ZVBvc2l0aW9uID0gKCBwb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiIHx8IHBvc2l0aW9uID09PSBcImZpeGVkXCIgKSAmJlxuXHRcdFx0KCBjdXJDU1NUb3AgKyBjdXJDU1NMZWZ0ICkuaW5kZXhPZiggXCJhdXRvXCIgKSA+IC0xO1xuXG5cdFx0Ly8gTmVlZCB0byBiZSBhYmxlIHRvIGNhbGN1bGF0ZSBwb3NpdGlvbiBpZiBlaXRoZXJcblx0XHQvLyB0b3Agb3IgbGVmdCBpcyBhdXRvIGFuZCBwb3NpdGlvbiBpcyBlaXRoZXIgYWJzb2x1dGUgb3IgZml4ZWRcblx0XHRpZiAoIGNhbGN1bGF0ZVBvc2l0aW9uICkge1xuXHRcdFx0Y3VyUG9zaXRpb24gPSBjdXJFbGVtLnBvc2l0aW9uKCk7XG5cdFx0XHRjdXJUb3AgPSBjdXJQb3NpdGlvbi50b3A7XG5cdFx0XHRjdXJMZWZ0ID0gY3VyUG9zaXRpb24ubGVmdDtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJUb3AgPSBwYXJzZUZsb2F0KCBjdXJDU1NUb3AgKSB8fCAwO1xuXHRcdFx0Y3VyTGVmdCA9IHBhcnNlRmxvYXQoIGN1ckNTU0xlZnQgKSB8fCAwO1xuXHRcdH1cblxuXHRcdGlmICggaXNGdW5jdGlvbiggb3B0aW9ucyApICkge1xuXG5cdFx0XHQvLyBVc2UgalF1ZXJ5LmV4dGVuZCBoZXJlIHRvIGFsbG93IG1vZGlmaWNhdGlvbiBvZiBjb29yZGluYXRlcyBhcmd1bWVudCAoZ2gtMTg0OClcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zLmNhbGwoIGVsZW0sIGksIGpRdWVyeS5leHRlbmQoIHt9LCBjdXJPZmZzZXQgKSApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0aW9ucy50b3AgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLnRvcCA9ICggb3B0aW9ucy50b3AgLSBjdXJPZmZzZXQudG9wICkgKyBjdXJUb3A7XG5cdFx0fVxuXHRcdGlmICggb3B0aW9ucy5sZWZ0ICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy5sZWZ0ID0gKCBvcHRpb25zLmxlZnQgLSBjdXJPZmZzZXQubGVmdCApICsgY3VyTGVmdDtcblx0XHR9XG5cblx0XHRpZiAoIFwidXNpbmdcIiBpbiBvcHRpb25zICkge1xuXHRcdFx0b3B0aW9ucy51c2luZy5jYWxsKCBlbGVtLCBwcm9wcyApO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1ckVsZW0uY3NzKCBwcm9wcyApO1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdC8vIG9mZnNldCgpIHJlbGF0ZXMgYW4gZWxlbWVudCdzIGJvcmRlciBib3ggdG8gdGhlIGRvY3VtZW50IG9yaWdpblxuXHRvZmZzZXQ6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdFx0Ly8gUHJlc2VydmUgY2hhaW5pbmcgZm9yIHNldHRlclxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiBvcHRpb25zID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHR0aGlzIDpcblx0XHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0XHRqUXVlcnkub2Zmc2V0LnNldE9mZnNldCggdGhpcywgb3B0aW9ucywgaSApO1xuXHRcdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0dmFyIHJlY3QsIHdpbixcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF07XG5cblx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiB6ZXJvcyBmb3IgZGlzY29ubmVjdGVkIGFuZCBoaWRkZW4gKGRpc3BsYXk6IG5vbmUpIGVsZW1lbnRzIChnaC0yMzEwKVxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHRcdC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGFcblx0XHQvLyBkaXNjb25uZWN0ZWQgbm9kZSBpbiBJRSB0aHJvd3MgYW4gZXJyb3Jcblx0XHRpZiAoICFlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cdFx0fVxuXG5cdFx0Ly8gR2V0IGRvY3VtZW50LXJlbGF0aXZlIHBvc2l0aW9uIGJ5IGFkZGluZyB2aWV3cG9ydCBzY3JvbGwgdG8gdmlld3BvcnQtcmVsYXRpdmUgZ0JDUlxuXHRcdHJlY3QgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdHdpbiA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldztcblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiByZWN0LnRvcCArIHdpbi5wYWdlWU9mZnNldCxcblx0XHRcdGxlZnQ6IHJlY3QubGVmdCArIHdpbi5wYWdlWE9mZnNldFxuXHRcdH07XG5cdH0sXG5cblx0Ly8gcG9zaXRpb24oKSByZWxhdGVzIGFuIGVsZW1lbnQncyBtYXJnaW4gYm94IHRvIGl0cyBvZmZzZXQgcGFyZW50J3MgcGFkZGluZyBib3hcblx0Ly8gVGhpcyBjb3JyZXNwb25kcyB0byB0aGUgYmVoYXZpb3Igb2YgQ1NTIGFic29sdXRlIHBvc2l0aW9uaW5nXG5cdHBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoICF0aGlzWyAwIF0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIG9mZnNldFBhcmVudCwgb2Zmc2V0LCBkb2MsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0cGFyZW50T2Zmc2V0ID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblxuXHRcdC8vIHBvc2l0aW9uOmZpeGVkIGVsZW1lbnRzIGFyZSBvZmZzZXQgZnJvbSB0aGUgdmlld3BvcnQsIHdoaWNoIGl0c2VsZiBhbHdheXMgaGFzIHplcm8gb2Zmc2V0XG5cdFx0aWYgKCBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSA9PT0gXCJmaXhlZFwiICkge1xuXG5cdFx0XHQvLyBBc3N1bWUgcG9zaXRpb246Zml4ZWQgaW1wbGllcyBhdmFpbGFiaWxpdHkgb2YgZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG5cdFx0XHRvZmZzZXQgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdG9mZnNldCA9IHRoaXMub2Zmc2V0KCk7XG5cblx0XHRcdC8vIEFjY291bnQgZm9yIHRoZSAqcmVhbCogb2Zmc2V0IHBhcmVudCwgd2hpY2ggY2FuIGJlIHRoZSBkb2N1bWVudCBvciBpdHMgcm9vdCBlbGVtZW50XG5cdFx0XHQvLyB3aGVuIGEgc3RhdGljYWxseSBwb3NpdGlvbmVkIGVsZW1lbnQgaXMgaWRlbnRpZmllZFxuXHRcdFx0ZG9jID0gZWxlbS5vd25lckRvY3VtZW50O1xuXHRcdFx0b2Zmc2V0UGFyZW50ID0gZWxlbS5vZmZzZXRQYXJlbnQgfHwgZG9jLmRvY3VtZW50RWxlbWVudDtcblx0XHRcdHdoaWxlICggb2Zmc2V0UGFyZW50ICYmXG5cdFx0XHRcdCggb2Zmc2V0UGFyZW50ID09PSBkb2MuYm9keSB8fCBvZmZzZXRQYXJlbnQgPT09IGRvYy5kb2N1bWVudEVsZW1lbnQgKSAmJlxuXHRcdFx0XHRqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwicG9zaXRpb25cIiApID09PSBcInN0YXRpY1wiICkge1xuXG5cdFx0XHRcdG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBvZmZzZXRQYXJlbnQgJiYgb2Zmc2V0UGFyZW50ICE9PSBlbGVtICYmIG9mZnNldFBhcmVudC5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHQvLyBJbmNvcnBvcmF0ZSBib3JkZXJzIGludG8gaXRzIG9mZnNldCwgc2luY2UgdGhleSBhcmUgb3V0c2lkZSBpdHMgY29udGVudCBvcmlnaW5cblx0XHRcdFx0cGFyZW50T2Zmc2V0ID0galF1ZXJ5KCBvZmZzZXRQYXJlbnQgKS5vZmZzZXQoKTtcblx0XHRcdFx0cGFyZW50T2Zmc2V0LnRvcCArPSBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwiYm9yZGVyVG9wV2lkdGhcIiwgdHJ1ZSApO1xuXHRcdFx0XHRwYXJlbnRPZmZzZXQubGVmdCArPSBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwiYm9yZGVyTGVmdFdpZHRoXCIsIHRydWUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTdWJ0cmFjdCBwYXJlbnQgb2Zmc2V0cyBhbmQgZWxlbWVudCBtYXJnaW5zXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogb2Zmc2V0LnRvcCAtIHBhcmVudE9mZnNldC50b3AgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpblRvcFwiLCB0cnVlICksXG5cdFx0XHRsZWZ0OiBvZmZzZXQubGVmdCAtIHBhcmVudE9mZnNldC5sZWZ0IC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5MZWZ0XCIsIHRydWUgKVxuXHRcdH07XG5cdH0sXG5cblx0Ly8gVGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gZG9jdW1lbnRFbGVtZW50IGluIHRoZSBmb2xsb3dpbmcgY2FzZXM6XG5cdC8vIDEpIEZvciB0aGUgZWxlbWVudCBpbnNpZGUgdGhlIGlmcmFtZSB3aXRob3V0IG9mZnNldFBhcmVudCwgdGhpcyBtZXRob2Qgd2lsbCByZXR1cm5cblx0Ly8gICAgZG9jdW1lbnRFbGVtZW50IG9mIHRoZSBwYXJlbnQgd2luZG93XG5cdC8vIDIpIEZvciB0aGUgaGlkZGVuIG9yIGRldGFjaGVkIGVsZW1lbnRcblx0Ly8gMykgRm9yIGJvZHkgb3IgaHRtbCBlbGVtZW50LCBpLmUuIGluIGNhc2Ugb2YgdGhlIGh0bWwgbm9kZSAtIGl0IHdpbGwgcmV0dXJuIGl0c2VsZlxuXHQvL1xuXHQvLyBidXQgdGhvc2UgZXhjZXB0aW9ucyB3ZXJlIG5ldmVyIHByZXNlbnRlZCBhcyBhIHJlYWwgbGlmZSB1c2UtY2FzZXNcblx0Ly8gYW5kIG1pZ2h0IGJlIGNvbnNpZGVyZWQgYXMgbW9yZSBwcmVmZXJhYmxlIHJlc3VsdHMuXG5cdC8vXG5cdC8vIFRoaXMgbG9naWMsIGhvd2V2ZXIsIGlzIG5vdCBndWFyYW50ZWVkIGFuZCBjYW4gY2hhbmdlIGF0IGFueSBwb2ludCBpbiB0aGUgZnV0dXJlXG5cdG9mZnNldFBhcmVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudDtcblxuXHRcdFx0d2hpbGUgKCBvZmZzZXRQYXJlbnQgJiYgalF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcInBvc2l0aW9uXCIgKSA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdFx0b2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50Lm9mZnNldFBhcmVudDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG9mZnNldFBhcmVudCB8fCBkb2N1bWVudEVsZW1lbnQ7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbi8vIENyZWF0ZSBzY3JvbGxMZWZ0IGFuZCBzY3JvbGxUb3AgbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgc2Nyb2xsTGVmdDogXCJwYWdlWE9mZnNldFwiLCBzY3JvbGxUb3A6IFwicGFnZVlPZmZzZXRcIiB9LCBmdW5jdGlvbiggbWV0aG9kLCBwcm9wICkge1xuXHR2YXIgdG9wID0gXCJwYWdlWU9mZnNldFwiID09PSBwcm9wO1xuXG5cdGpRdWVyeS5mblsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdmFsICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBtZXRob2QsIHZhbCApIHtcblxuXHRcdFx0Ly8gQ29hbGVzY2UgZG9jdW1lbnRzIGFuZCB3aW5kb3dzXG5cdFx0XHR2YXIgd2luO1xuXHRcdFx0aWYgKCBpc1dpbmRvdyggZWxlbSApICkge1xuXHRcdFx0XHR3aW4gPSBlbGVtO1xuXHRcdFx0fSBlbHNlIGlmICggZWxlbS5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0d2luID0gZWxlbS5kZWZhdWx0Vmlldztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHdpbiA/IHdpblsgcHJvcCBdIDogZWxlbVsgbWV0aG9kIF07XG5cdFx0XHR9XG5cblx0XHRcdGlmICggd2luICkge1xuXHRcdFx0XHR3aW4uc2Nyb2xsVG8oXG5cdFx0XHRcdFx0IXRvcCA/IHZhbCA6IHdpbi5wYWdlWE9mZnNldCxcblx0XHRcdFx0XHR0b3AgPyB2YWwgOiB3aW4ucGFnZVlPZmZzZXRcblx0XHRcdFx0KTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbVsgbWV0aG9kIF0gPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSwgbWV0aG9kLCB2YWwsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fTtcbn0gKTtcblxuLy8gU3VwcG9ydDogU2FmYXJpIDw9NyAtIDkuMSwgQ2hyb21lIDw9MzcgLSA0OVxuLy8gQWRkIHRoZSB0b3AvbGVmdCBjc3NIb29rcyB1c2luZyBqUXVlcnkuZm4ucG9zaXRpb25cbi8vIFdlYmtpdCBidWc6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yOTA4NFxuLy8gQmxpbmsgYnVnOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD01ODkzNDdcbi8vIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyBwZXJjZW50IHdoZW4gc3BlY2lmaWVkIGZvciB0b3AvbGVmdC9ib3R0b20vcmlnaHQ7XG4vLyByYXRoZXIgdGhhbiBtYWtlIHRoZSBjc3MgbW9kdWxlIGRlcGVuZCBvbiB0aGUgb2Zmc2V0IG1vZHVsZSwganVzdCBjaGVjayBmb3IgaXQgaGVyZVxualF1ZXJ5LmVhY2goIFsgXCJ0b3BcIiwgXCJsZWZ0XCIgXSwgZnVuY3Rpb24oIF9pLCBwcm9wICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByb3AgXSA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5waXhlbFBvc2l0aW9uLFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGNvbXB1dGVkID0gY3VyQ1NTKCBlbGVtLCBwcm9wICk7XG5cblx0XHRcdFx0Ly8gSWYgY3VyQ1NTIHJldHVybnMgcGVyY2VudGFnZSwgZmFsbGJhY2sgdG8gb2Zmc2V0XG5cdFx0XHRcdHJldHVybiBybnVtbm9ucHgudGVzdCggY29tcHV0ZWQgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5KCBlbGVtICkucG9zaXRpb24oKVsgcHJvcCBdICsgXCJweFwiIDpcblx0XHRcdFx0XHRjb21wdXRlZDtcblx0XHRcdH1cblx0XHR9XG5cdCk7XG59ICk7XG5cblxuLy8gQ3JlYXRlIGlubmVySGVpZ2h0LCBpbm5lcldpZHRoLCBoZWlnaHQsIHdpZHRoLCBvdXRlckhlaWdodCBhbmQgb3V0ZXJXaWR0aCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBIZWlnaHQ6IFwiaGVpZ2h0XCIsIFdpZHRoOiBcIndpZHRoXCIgfSwgZnVuY3Rpb24oIG5hbWUsIHR5cGUgKSB7XG5cdGpRdWVyeS5lYWNoKCB7XG5cdFx0cGFkZGluZzogXCJpbm5lclwiICsgbmFtZSxcblx0XHRjb250ZW50OiB0eXBlLFxuXHRcdFwiXCI6IFwib3V0ZXJcIiArIG5hbWVcblx0fSwgZnVuY3Rpb24oIGRlZmF1bHRFeHRyYSwgZnVuY05hbWUgKSB7XG5cblx0XHQvLyBNYXJnaW4gaXMgb25seSBmb3Igb3V0ZXJIZWlnaHQsIG91dGVyV2lkdGhcblx0XHRqUXVlcnkuZm5bIGZ1bmNOYW1lIF0gPSBmdW5jdGlvbiggbWFyZ2luLCB2YWx1ZSApIHtcblx0XHRcdHZhciBjaGFpbmFibGUgPSBhcmd1bWVudHMubGVuZ3RoICYmICggZGVmYXVsdEV4dHJhIHx8IHR5cGVvZiBtYXJnaW4gIT09IFwiYm9vbGVhblwiICksXG5cdFx0XHRcdGV4dHJhID0gZGVmYXVsdEV4dHJhIHx8ICggbWFyZ2luID09PSB0cnVlIHx8IHZhbHVlID09PSB0cnVlID8gXCJtYXJnaW5cIiA6IFwiYm9yZGVyXCIgKTtcblxuXHRcdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIHR5cGUsIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgZG9jO1xuXG5cdFx0XHRcdGlmICggaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vICQoIHdpbmRvdyApLm91dGVyV2lkdGgvSGVpZ2h0IHJldHVybiB3L2ggaW5jbHVkaW5nIHNjcm9sbGJhcnMgKGdoLTE3MjkpXG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmNOYW1lLmluZGV4T2YoIFwib3V0ZXJcIiApID09PSAwID9cblx0XHRcdFx0XHRcdGVsZW1bIFwiaW5uZXJcIiArIG5hbWUgXSA6XG5cdFx0XHRcdFx0XHRlbGVtLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFsgXCJjbGllbnRcIiArIG5hbWUgXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEdldCBkb2N1bWVudCB3aWR0aCBvciBoZWlnaHRcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdGRvYyA9IGVsZW0uZG9jdW1lbnRFbGVtZW50O1xuXG5cdFx0XHRcdFx0Ly8gRWl0aGVyIHNjcm9sbFtXaWR0aC9IZWlnaHRdIG9yIG9mZnNldFtXaWR0aC9IZWlnaHRdIG9yIGNsaWVudFtXaWR0aC9IZWlnaHRdLFxuXHRcdFx0XHRcdC8vIHdoaWNoZXZlciBpcyBncmVhdGVzdFxuXHRcdFx0XHRcdHJldHVybiBNYXRoLm1heChcblx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJzY3JvbGxcIiArIG5hbWUgXSwgZG9jWyBcInNjcm9sbFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcIm9mZnNldFwiICsgbmFtZSBdLCBkb2NbIFwib2Zmc2V0XCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRkb2NbIFwiY2xpZW50XCIgKyBuYW1lIF1cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXG5cdFx0XHRcdFx0Ly8gR2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudCwgcmVxdWVzdGluZyBidXQgbm90IGZvcmNpbmcgcGFyc2VGbG9hdFxuXHRcdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIHR5cGUsIGV4dHJhICkgOlxuXG5cdFx0XHRcdFx0Ly8gU2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudFxuXHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgdHlwZSwgdmFsdWUsIGV4dHJhICk7XG5cdFx0XHR9LCB0eXBlLCBjaGFpbmFibGUgPyBtYXJnaW4gOiB1bmRlZmluZWQsIGNoYWluYWJsZSApO1xuXHRcdH07XG5cdH0gKTtcbn0gKTtcblxuXG5qUXVlcnkuZWFjaCggW1xuXHRcImFqYXhTdGFydFwiLFxuXHRcImFqYXhTdG9wXCIsXG5cdFwiYWpheENvbXBsZXRlXCIsXG5cdFwiYWpheEVycm9yXCIsXG5cdFwiYWpheFN1Y2Nlc3NcIixcblx0XCJhamF4U2VuZFwiXG5dLCBmdW5jdGlvbiggX2ksIHR5cGUgKSB7XG5cdGpRdWVyeS5mblsgdHlwZSBdID0gZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlLCBmbiApO1xuXHR9O1xufSApO1xuXG5cblxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0YmluZDogZnVuY3Rpb24oIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIG51bGwsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuYmluZDogZnVuY3Rpb24oIHR5cGVzLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vZmYoIHR5cGVzLCBudWxsLCBmbiApO1xuXHR9LFxuXG5cdGRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBmbiApIHtcblxuXHRcdC8vICggbmFtZXNwYWNlICkgb3IgKCBzZWxlY3RvciwgdHlwZXMgWywgZm5dIClcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/XG5cdFx0XHR0aGlzLm9mZiggc2VsZWN0b3IsIFwiKipcIiApIDpcblx0XHRcdHRoaXMub2ZmKCB0eXBlcywgc2VsZWN0b3IgfHwgXCIqKlwiLCBmbiApO1xuXHR9LFxuXG5cdGhvdmVyOiBmdW5jdGlvbiggZm5PdmVyLCBmbk91dCApIHtcblx0XHRyZXR1cm4gdGhpcy5tb3VzZWVudGVyKCBmbk92ZXIgKS5tb3VzZWxlYXZlKCBmbk91dCB8fCBmbk92ZXIgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaChcblx0KCBcImJsdXIgZm9jdXMgZm9jdXNpbiBmb2N1c291dCByZXNpemUgc2Nyb2xsIGNsaWNrIGRibGNsaWNrIFwiICtcblx0XCJtb3VzZWRvd24gbW91c2V1cCBtb3VzZW1vdmUgbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlZW50ZXIgbW91c2VsZWF2ZSBcIiArXG5cdFwiY2hhbmdlIHNlbGVjdCBzdWJtaXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBjb250ZXh0bWVudVwiICkuc3BsaXQoIFwiIFwiICksXG5cdGZ1bmN0aW9uKCBfaSwgbmFtZSApIHtcblxuXHRcdC8vIEhhbmRsZSBldmVudCBiaW5kaW5nXG5cdFx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggZGF0YSwgZm4gKSB7XG5cdFx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDAgP1xuXHRcdFx0XHR0aGlzLm9uKCBuYW1lLCBudWxsLCBkYXRhLCBmbiApIDpcblx0XHRcdFx0dGhpcy50cmlnZ2VyKCBuYW1lICk7XG5cdFx0fTtcblx0fVxuKTtcblxuXG5cblxuLy8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5XG4vLyBNYWtlIHN1cmUgd2UgdHJpbSBCT00gYW5kIE5CU1BcbnZhciBydHJpbSA9IC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZztcblxuLy8gQmluZCBhIGZ1bmN0aW9uIHRvIGEgY29udGV4dCwgb3B0aW9uYWxseSBwYXJ0aWFsbHkgYXBwbHlpbmcgYW55XG4vLyBhcmd1bWVudHMuXG4vLyBqUXVlcnkucHJveHkgaXMgZGVwcmVjYXRlZCB0byBwcm9tb3RlIHN0YW5kYXJkcyAoc3BlY2lmaWNhbGx5IEZ1bmN0aW9uI2JpbmQpXG4vLyBIb3dldmVyLCBpdCBpcyBub3Qgc2xhdGVkIGZvciByZW1vdmFsIGFueSB0aW1lIHNvb25cbmpRdWVyeS5wcm94eSA9IGZ1bmN0aW9uKCBmbiwgY29udGV4dCApIHtcblx0dmFyIHRtcCwgYXJncywgcHJveHk7XG5cblx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHR0bXAgPSBmblsgY29udGV4dCBdO1xuXHRcdGNvbnRleHQgPSBmbjtcblx0XHRmbiA9IHRtcDtcblx0fVxuXG5cdC8vIFF1aWNrIGNoZWNrIHRvIGRldGVybWluZSBpZiB0YXJnZXQgaXMgY2FsbGFibGUsIGluIHRoZSBzcGVjXG5cdC8vIHRoaXMgdGhyb3dzIGEgVHlwZUVycm9yLCBidXQgd2Ugd2lsbCBqdXN0IHJldHVybiB1bmRlZmluZWQuXG5cdGlmICggIWlzRnVuY3Rpb24oIGZuICkgKSB7XG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0fVxuXG5cdC8vIFNpbXVsYXRlZCBiaW5kXG5cdGFyZ3MgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMsIDIgKTtcblx0cHJveHkgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZm4uYXBwbHkoIGNvbnRleHQgfHwgdGhpcywgYXJncy5jb25jYXQoIHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApICkgKTtcblx0fTtcblxuXHQvLyBTZXQgdGhlIGd1aWQgb2YgdW5pcXVlIGhhbmRsZXIgdG8gdGhlIHNhbWUgb2Ygb3JpZ2luYWwgaGFuZGxlciwgc28gaXQgY2FuIGJlIHJlbW92ZWRcblx0cHJveHkuZ3VpZCA9IGZuLmd1aWQgPSBmbi5ndWlkIHx8IGpRdWVyeS5ndWlkKys7XG5cblx0cmV0dXJuIHByb3h5O1xufTtcblxualF1ZXJ5LmhvbGRSZWFkeSA9IGZ1bmN0aW9uKCBob2xkICkge1xuXHRpZiAoIGhvbGQgKSB7XG5cdFx0alF1ZXJ5LnJlYWR5V2FpdCsrO1xuXHR9IGVsc2Uge1xuXHRcdGpRdWVyeS5yZWFkeSggdHJ1ZSApO1xuXHR9XG59O1xualF1ZXJ5LmlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xualF1ZXJ5LnBhcnNlSlNPTiA9IEpTT04ucGFyc2U7XG5qUXVlcnkubm9kZU5hbWUgPSBub2RlTmFtZTtcbmpRdWVyeS5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbmpRdWVyeS5pc1dpbmRvdyA9IGlzV2luZG93O1xualF1ZXJ5LmNhbWVsQ2FzZSA9IGNhbWVsQ2FzZTtcbmpRdWVyeS50eXBlID0gdG9UeXBlO1xuXG5qUXVlcnkubm93ID0gRGF0ZS5ub3c7XG5cbmpRdWVyeS5pc051bWVyaWMgPSBmdW5jdGlvbiggb2JqICkge1xuXG5cdC8vIEFzIG9mIGpRdWVyeSAzLjAsIGlzTnVtZXJpYyBpcyBsaW1pdGVkIHRvXG5cdC8vIHN0cmluZ3MgYW5kIG51bWJlcnMgKHByaW1pdGl2ZXMgb3Igb2JqZWN0cylcblx0Ly8gdGhhdCBjYW4gYmUgY29lcmNlZCB0byBmaW5pdGUgbnVtYmVycyAoZ2gtMjY2Milcblx0dmFyIHR5cGUgPSBqUXVlcnkudHlwZSggb2JqICk7XG5cdHJldHVybiAoIHR5cGUgPT09IFwibnVtYmVyXCIgfHwgdHlwZSA9PT0gXCJzdHJpbmdcIiApICYmXG5cblx0XHQvLyBwYXJzZUZsb2F0IE5hTnMgbnVtZXJpYy1jYXN0IGZhbHNlIHBvc2l0aXZlcyAoXCJcIilcblx0XHQvLyAuLi5idXQgbWlzaW50ZXJwcmV0cyBsZWFkaW5nLW51bWJlciBzdHJpbmdzLCBwYXJ0aWN1bGFybHkgaGV4IGxpdGVyYWxzIChcIjB4Li4uXCIpXG5cdFx0Ly8gc3VidHJhY3Rpb24gZm9yY2VzIGluZmluaXRpZXMgdG8gTmFOXG5cdFx0IWlzTmFOKCBvYmogLSBwYXJzZUZsb2F0KCBvYmogKSApO1xufTtcblxualF1ZXJ5LnRyaW0gPSBmdW5jdGlvbiggdGV4dCApIHtcblx0cmV0dXJuIHRleHQgPT0gbnVsbCA/XG5cdFx0XCJcIiA6XG5cdFx0KCB0ZXh0ICsgXCJcIiApLnJlcGxhY2UoIHJ0cmltLCBcIlwiICk7XG59O1xuXG5cblxuLy8gUmVnaXN0ZXIgYXMgYSBuYW1lZCBBTUQgbW9kdWxlLCBzaW5jZSBqUXVlcnkgY2FuIGJlIGNvbmNhdGVuYXRlZCB3aXRoIG90aGVyXG4vLyBmaWxlcyB0aGF0IG1heSB1c2UgZGVmaW5lLCBidXQgbm90IHZpYSBhIHByb3BlciBjb25jYXRlbmF0aW9uIHNjcmlwdCB0aGF0XG4vLyB1bmRlcnN0YW5kcyBhbm9ueW1vdXMgQU1EIG1vZHVsZXMuIEEgbmFtZWQgQU1EIGlzIHNhZmVzdCBhbmQgbW9zdCByb2J1c3Rcbi8vIHdheSB0byByZWdpc3Rlci4gTG93ZXJjYXNlIGpxdWVyeSBpcyB1c2VkIGJlY2F1c2UgQU1EIG1vZHVsZSBuYW1lcyBhcmVcbi8vIGRlcml2ZWQgZnJvbSBmaWxlIG5hbWVzLCBhbmQgalF1ZXJ5IGlzIG5vcm1hbGx5IGRlbGl2ZXJlZCBpbiBhIGxvd2VyY2FzZVxuLy8gZmlsZSBuYW1lLiBEbyB0aGlzIGFmdGVyIGNyZWF0aW5nIHRoZSBnbG9iYWwgc28gdGhhdCBpZiBhbiBBTUQgbW9kdWxlIHdhbnRzXG4vLyB0byBjYWxsIG5vQ29uZmxpY3QgdG8gaGlkZSB0aGlzIHZlcnNpb24gb2YgalF1ZXJ5LCBpdCB3aWxsIHdvcmsuXG5cbi8vIE5vdGUgdGhhdCBmb3IgbWF4aW11bSBwb3J0YWJpbGl0eSwgbGlicmFyaWVzIHRoYXQgYXJlIG5vdCBqUXVlcnkgc2hvdWxkXG4vLyBkZWNsYXJlIHRoZW1zZWx2ZXMgYXMgYW5vbnltb3VzIG1vZHVsZXMsIGFuZCBhdm9pZCBzZXR0aW5nIGEgZ2xvYmFsIGlmIGFuXG4vLyBBTUQgbG9hZGVyIGlzIHByZXNlbnQuIGpRdWVyeSBpcyBhIHNwZWNpYWwgY2FzZS4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2pyYnVya2UvcmVxdWlyZWpzL3dpa2kvVXBkYXRpbmctZXhpc3RpbmctbGlicmFyaWVzI3dpa2ktYW5vblxuXG5pZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXHRkZWZpbmUoIFwianF1ZXJ5XCIsIFtdLCBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5O1xuXHR9ICk7XG59XG5cblxuXG5cbnZhclxuXG5cdC8vIE1hcCBvdmVyIGpRdWVyeSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfalF1ZXJ5ID0gd2luZG93LmpRdWVyeSxcblxuXHQvLyBNYXAgb3ZlciB0aGUgJCBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfJCA9IHdpbmRvdy4kO1xuXG5qUXVlcnkubm9Db25mbGljdCA9IGZ1bmN0aW9uKCBkZWVwICkge1xuXHRpZiAoIHdpbmRvdy4kID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LiQgPSBfJDtcblx0fVxuXG5cdGlmICggZGVlcCAmJiB3aW5kb3cualF1ZXJ5ID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LmpRdWVyeSA9IF9qUXVlcnk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5O1xufTtcblxuLy8gRXhwb3NlIGpRdWVyeSBhbmQgJCBpZGVudGlmaWVycywgZXZlbiBpbiBBTURcbi8vICgjNzEwMiNjb21tZW50OjEwLCBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9wdWxsLzU1Nylcbi8vIGFuZCBDb21tb25KUyBmb3IgYnJvd3NlciBlbXVsYXRvcnMgKCMxMzU2NilcbmlmICggdHlwZW9mIG5vR2xvYmFsID09PSBcInVuZGVmaW5lZFwiICkge1xuXHR3aW5kb3cualF1ZXJ5ID0gd2luZG93LiQgPSBqUXVlcnk7XG59XG5cblxuXG5cbnJldHVybiBqUXVlcnk7XG59ICk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/jquery/dist/jquery.js\n");

/***/ }),

/***/ "./resources/sass/app.scss":
/*!*********************************!*\
  !*** ./resources/sass/app.scss ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvc2Fzcy9hcHAuc2Nzcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvc2Fzcy9hcHAuc2Nzcz9hODBiIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/sass/app.scss\n");

/***/ }),

/***/ "./node_modules/sweetalert2/dist/sweetalert2.all.js":
/*!**********************************************************!*\
  !*** ./node_modules/sweetalert2/dist/sweetalert2.all.js ***!
  \**********************************************************/
/***/ (function(module) {

eval("/*!\n* sweetalert2 v11.4.17\n* Released under the MIT License.\n*/\n(function (global, factory) {\n   true ? module.exports = factory() :\n  0;\n}(this, function () { 'use strict';\n\n  const consolePrefix = 'SweetAlert2:';\n  /**\n   * Filter the unique values into a new array\n   * @param arr\n   */\n\n  const uniqueArray = arr => {\n    const result = [];\n\n    for (let i = 0; i < arr.length; i++) {\n      if (result.indexOf(arr[i]) === -1) {\n        result.push(arr[i]);\n      }\n    }\n\n    return result;\n  };\n  /**\n   * Capitalize the first letter of a string\n   * @param {string} str\n   * @returns {string}\n   */\n\n  const capitalizeFirstLetter = str => str.charAt(0).toUpperCase() + str.slice(1);\n  /**\n   * @param {NodeList | HTMLCollection | NamedNodeMap | DOMTokenList} nodeList\n   * @returns {array}\n   */\n\n  const toArray = nodeList => Array.prototype.slice.call(nodeList);\n  /**\n   * Standardize console warnings\n   * @param {string | array} message\n   */\n\n  const warn = message => {\n    console.warn(\"\".concat(consolePrefix, \" \").concat(typeof message === 'object' ? message.join(' ') : message));\n  };\n  /**\n   * Standardize console errors\n   * @param {string} message\n   */\n\n  const error = message => {\n    console.error(\"\".concat(consolePrefix, \" \").concat(message));\n  };\n  /**\n   * Private global state for `warnOnce`\n   * @type {Array}\n   * @private\n   */\n\n  const previousWarnOnceMessages = [];\n  /**\n   * Show a console warning, but only if it hasn't already been shown\n   * @param {string} message\n   */\n\n  const warnOnce = message => {\n    if (!previousWarnOnceMessages.includes(message)) {\n      previousWarnOnceMessages.push(message);\n      warn(message);\n    }\n  };\n  /**\n   * Show a one-time console warning about deprecated params/methods\n   */\n\n  const warnAboutDeprecation = (deprecatedParam, useInstead) => {\n    warnOnce(\"\\\"\".concat(deprecatedParam, \"\\\" is deprecated and will be removed in the next major release. Please use \\\"\").concat(useInstead, \"\\\" instead.\"));\n  };\n  /**\n   * If `arg` is a function, call it (with no arguments or context) and return the result.\n   * Otherwise, just pass the value through\n   * @param arg\n   */\n\n  const callIfFunction = arg => typeof arg === 'function' ? arg() : arg;\n  const hasToPromiseFn = arg => arg && typeof arg.toPromise === 'function';\n  const asPromise = arg => hasToPromiseFn(arg) ? arg.toPromise() : Promise.resolve(arg);\n  const isPromise = arg => arg && Promise.resolve(arg) === arg;\n  const getRandomElement = arr => arr[Math.floor(Math.random() * arr.length)];\n\n  const defaultParams = {\n    title: '',\n    titleText: '',\n    text: '',\n    html: '',\n    footer: '',\n    icon: undefined,\n    iconColor: undefined,\n    iconHtml: undefined,\n    template: undefined,\n    toast: false,\n    showClass: {\n      popup: 'swal2-show',\n      backdrop: 'swal2-backdrop-show',\n      icon: 'swal2-icon-show'\n    },\n    hideClass: {\n      popup: 'swal2-hide',\n      backdrop: 'swal2-backdrop-hide',\n      icon: 'swal2-icon-hide'\n    },\n    customClass: {},\n    target: 'body',\n    color: undefined,\n    backdrop: true,\n    heightAuto: true,\n    allowOutsideClick: true,\n    allowEscapeKey: true,\n    allowEnterKey: true,\n    stopKeydownPropagation: true,\n    keydownListenerCapture: false,\n    showConfirmButton: true,\n    showDenyButton: false,\n    showCancelButton: false,\n    preConfirm: undefined,\n    preDeny: undefined,\n    confirmButtonText: 'OK',\n    confirmButtonAriaLabel: '',\n    confirmButtonColor: undefined,\n    denyButtonText: 'No',\n    denyButtonAriaLabel: '',\n    denyButtonColor: undefined,\n    cancelButtonText: 'Cancel',\n    cancelButtonAriaLabel: '',\n    cancelButtonColor: undefined,\n    buttonsStyling: true,\n    reverseButtons: false,\n    focusConfirm: true,\n    focusDeny: false,\n    focusCancel: false,\n    returnFocus: true,\n    showCloseButton: false,\n    closeButtonHtml: '&times;',\n    closeButtonAriaLabel: 'Close this dialog',\n    loaderHtml: '',\n    showLoaderOnConfirm: false,\n    showLoaderOnDeny: false,\n    imageUrl: undefined,\n    imageWidth: undefined,\n    imageHeight: undefined,\n    imageAlt: '',\n    timer: undefined,\n    timerProgressBar: false,\n    width: undefined,\n    padding: undefined,\n    background: undefined,\n    input: undefined,\n    inputPlaceholder: '',\n    inputLabel: '',\n    inputValue: '',\n    inputOptions: {},\n    inputAutoTrim: true,\n    inputAttributes: {},\n    inputValidator: undefined,\n    returnInputValueOnDeny: false,\n    validationMessage: undefined,\n    grow: false,\n    position: 'center',\n    progressSteps: [],\n    currentProgressStep: undefined,\n    progressStepsDistance: undefined,\n    willOpen: undefined,\n    didOpen: undefined,\n    didRender: undefined,\n    willClose: undefined,\n    didClose: undefined,\n    didDestroy: undefined,\n    scrollbarPadding: true\n  };\n  const updatableParams = ['allowEscapeKey', 'allowOutsideClick', 'background', 'buttonsStyling', 'cancelButtonAriaLabel', 'cancelButtonColor', 'cancelButtonText', 'closeButtonAriaLabel', 'closeButtonHtml', 'color', 'confirmButtonAriaLabel', 'confirmButtonColor', 'confirmButtonText', 'currentProgressStep', 'customClass', 'denyButtonAriaLabel', 'denyButtonColor', 'denyButtonText', 'didClose', 'didDestroy', 'footer', 'hideClass', 'html', 'icon', 'iconColor', 'iconHtml', 'imageAlt', 'imageHeight', 'imageUrl', 'imageWidth', 'preConfirm', 'preDeny', 'progressSteps', 'returnFocus', 'reverseButtons', 'showCancelButton', 'showCloseButton', 'showConfirmButton', 'showDenyButton', 'text', 'title', 'titleText', 'willClose'];\n  const deprecatedParams = {};\n  const toastIncompatibleParams = ['allowOutsideClick', 'allowEnterKey', 'backdrop', 'focusConfirm', 'focusDeny', 'focusCancel', 'returnFocus', 'heightAuto', 'keydownListenerCapture'];\n  /**\n   * Is valid parameter\n   * @param {string} paramName\n   */\n\n  const isValidParameter = paramName => {\n    return Object.prototype.hasOwnProperty.call(defaultParams, paramName);\n  };\n  /**\n   * Is valid parameter for Swal.update() method\n   * @param {string} paramName\n   */\n\n  const isUpdatableParameter = paramName => {\n    return updatableParams.indexOf(paramName) !== -1;\n  };\n  /**\n   * Is deprecated parameter\n   * @param {string} paramName\n   */\n\n  const isDeprecatedParameter = paramName => {\n    return deprecatedParams[paramName];\n  };\n\n  const checkIfParamIsValid = param => {\n    if (!isValidParameter(param)) {\n      warn(\"Unknown parameter \\\"\".concat(param, \"\\\"\"));\n    }\n  };\n\n  const checkIfToastParamIsValid = param => {\n    if (toastIncompatibleParams.includes(param)) {\n      warn(\"The parameter \\\"\".concat(param, \"\\\" is incompatible with toasts\"));\n    }\n  };\n\n  const checkIfParamIsDeprecated = param => {\n    if (isDeprecatedParameter(param)) {\n      warnAboutDeprecation(param, isDeprecatedParameter(param));\n    }\n  };\n  /**\n   * Show relevant warnings for given params\n   *\n   * @param params\n   */\n\n\n  const showWarningsForParams = params => {\n    if (!params.backdrop && params.allowOutsideClick) {\n      warn('\"allowOutsideClick\" parameter requires `backdrop` parameter to be set to `true`');\n    }\n\n    for (const param in params) {\n      checkIfParamIsValid(param);\n\n      if (params.toast) {\n        checkIfToastParamIsValid(param);\n      }\n\n      checkIfParamIsDeprecated(param);\n    }\n  };\n\n  const swalPrefix = 'swal2-';\n  /**\n   * @param {string[]} items\n   * @returns {object}\n   */\n\n  const prefix = items => {\n    const result = {};\n\n    for (const i in items) {\n      result[items[i]] = swalPrefix + items[i];\n    }\n\n    return result;\n  };\n  const swalClasses = prefix(['container', 'shown', 'height-auto', 'iosfix', 'popup', 'modal', 'no-backdrop', 'no-transition', 'toast', 'toast-shown', 'show', 'hide', 'close', 'title', 'html-container', 'actions', 'confirm', 'deny', 'cancel', 'default-outline', 'footer', 'icon', 'icon-content', 'image', 'input', 'file', 'range', 'select', 'radio', 'checkbox', 'label', 'textarea', 'inputerror', 'input-label', 'validation-message', 'progress-steps', 'active-progress-step', 'progress-step', 'progress-step-line', 'loader', 'loading', 'styled', 'top', 'top-start', 'top-end', 'top-left', 'top-right', 'center', 'center-start', 'center-end', 'center-left', 'center-right', 'bottom', 'bottom-start', 'bottom-end', 'bottom-left', 'bottom-right', 'grow-row', 'grow-column', 'grow-fullscreen', 'rtl', 'timer-progress-bar', 'timer-progress-bar-container', 'scrollbar-measure', 'icon-success', 'icon-warning', 'icon-info', 'icon-question', 'icon-error', 'no-war']);\n  const iconTypes = prefix(['success', 'warning', 'info', 'question', 'error']);\n\n  /**\n   * Gets the popup container which contains the backdrop and the popup itself.\n   *\n   * @returns {HTMLElement | null}\n   */\n\n  const getContainer = () => document.body.querySelector(\".\".concat(swalClasses.container));\n  /**\n   * @param {string} selectorString\n   * @returns {HTMLElement | null}\n   */\n\n  const elementBySelector = selectorString => {\n    const container = getContainer();\n    return container ? container.querySelector(selectorString) : null;\n  };\n  /**\n   * @param {string} className\n   * @returns {HTMLElement | null}\n   */\n\n  const elementByClass = className => {\n    return elementBySelector(\".\".concat(className));\n  };\n  /**\n   * @returns {HTMLElement | null}\n   */\n\n\n  const getPopup = () => elementByClass(swalClasses.popup);\n  /**\n   * @returns {HTMLElement | null}\n   */\n\n  const getIcon = () => elementByClass(swalClasses.icon);\n  /**\n   * @returns {HTMLElement | null}\n   */\n\n  const getTitle = () => elementByClass(swalClasses.title);\n  /**\n   * @returns {HTMLElement | null}\n   */\n\n  const getHtmlContainer = () => elementByClass(swalClasses['html-container']);\n  /**\n   * @returns {HTMLElement | null}\n   */\n\n  const getImage = () => elementByClass(swalClasses.image);\n  /**\n   * @returns {HTMLElement | null}\n   */\n\n  const getProgressSteps = () => elementByClass(swalClasses['progress-steps']);\n  /**\n   * @returns {HTMLElement | null}\n   */\n\n  const getValidationMessage = () => elementByClass(swalClasses['validation-message']);\n  /**\n   * @returns {HTMLElement | null}\n   */\n\n  const getConfirmButton = () => elementBySelector(\".\".concat(swalClasses.actions, \" .\").concat(swalClasses.confirm));\n  /**\n   * @returns {HTMLElement | null}\n   */\n\n  const getDenyButton = () => elementBySelector(\".\".concat(swalClasses.actions, \" .\").concat(swalClasses.deny));\n  /**\n   * @returns {HTMLElement | null}\n   */\n\n  const getInputLabel = () => elementByClass(swalClasses['input-label']);\n  /**\n   * @returns {HTMLElement | null}\n   */\n\n  const getLoader = () => elementBySelector(\".\".concat(swalClasses.loader));\n  /**\n   * @returns {HTMLElement | null}\n   */\n\n  const getCancelButton = () => elementBySelector(\".\".concat(swalClasses.actions, \" .\").concat(swalClasses.cancel));\n  /**\n   * @returns {HTMLElement | null}\n   */\n\n  const getActions = () => elementByClass(swalClasses.actions);\n  /**\n   * @returns {HTMLElement | null}\n   */\n\n  const getFooter = () => elementByClass(swalClasses.footer);\n  /**\n   * @returns {HTMLElement | null}\n   */\n\n  const getTimerProgressBar = () => elementByClass(swalClasses['timer-progress-bar']);\n  /**\n   * @returns {HTMLElement | null}\n   */\n\n  const getCloseButton = () => elementByClass(swalClasses.close); // https://github.com/jkup/focusable/blob/master/index.js\n\n  const focusable = \"\\n  a[href],\\n  area[href],\\n  input:not([disabled]),\\n  select:not([disabled]),\\n  textarea:not([disabled]),\\n  button:not([disabled]),\\n  iframe,\\n  object,\\n  embed,\\n  [tabindex=\\\"0\\\"],\\n  [contenteditable],\\n  audio[controls],\\n  video[controls],\\n  summary\\n\";\n  /**\n   * @returns {HTMLElement[]}\n   */\n\n  const getFocusableElements = () => {\n    const focusableElementsWithTabindex = toArray(getPopup().querySelectorAll('[tabindex]:not([tabindex=\"-1\"]):not([tabindex=\"0\"])')) // sort according to tabindex\n    .sort((a, b) => {\n      const tabindexA = parseInt(a.getAttribute('tabindex'));\n      const tabindexB = parseInt(b.getAttribute('tabindex'));\n\n      if (tabindexA > tabindexB) {\n        return 1;\n      } else if (tabindexA < tabindexB) {\n        return -1;\n      }\n\n      return 0;\n    });\n    const otherFocusableElements = toArray(getPopup().querySelectorAll(focusable)).filter(el => el.getAttribute('tabindex') !== '-1');\n    return uniqueArray(focusableElementsWithTabindex.concat(otherFocusableElements)).filter(el => isVisible(el));\n  };\n  /**\n   * @returns {boolean}\n   */\n\n  const isModal = () => {\n    return hasClass(document.body, swalClasses.shown) && !hasClass(document.body, swalClasses['toast-shown']) && !hasClass(document.body, swalClasses['no-backdrop']);\n  };\n  /**\n   * @returns {boolean}\n   */\n\n  const isToast = () => {\n    return getPopup() && hasClass(getPopup(), swalClasses.toast);\n  };\n  /**\n   * @returns {boolean}\n   */\n\n  const isLoading = () => {\n    return getPopup().hasAttribute('data-loading');\n  };\n\n  const states = {\n    previousBodyPadding: null\n  };\n  /**\n   * Securely set innerHTML of an element\n   * https://github.com/sweetalert2/sweetalert2/issues/1926\n   *\n   * @param {HTMLElement} elem\n   * @param {string} html\n   */\n\n  const setInnerHtml = (elem, html) => {\n    elem.textContent = '';\n\n    if (html) {\n      const parser = new DOMParser();\n      const parsed = parser.parseFromString(html, \"text/html\");\n      toArray(parsed.querySelector('head').childNodes).forEach(child => {\n        elem.appendChild(child);\n      });\n      toArray(parsed.querySelector('body').childNodes).forEach(child => {\n        elem.appendChild(child);\n      });\n    }\n  };\n  /**\n   * @param {HTMLElement} elem\n   * @param {string} className\n   * @returns {boolean}\n   */\n\n  const hasClass = (elem, className) => {\n    if (!className) {\n      return false;\n    }\n\n    const classList = className.split(/\\s+/);\n\n    for (let i = 0; i < classList.length; i++) {\n      if (!elem.classList.contains(classList[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n  /**\n   * @param {HTMLElement} elem\n   * @param {SweetAlertOptions} params\n   */\n\n  const removeCustomClasses = (elem, params) => {\n    toArray(elem.classList).forEach(className => {\n      if (!Object.values(swalClasses).includes(className) && !Object.values(iconTypes).includes(className) && !Object.values(params.showClass).includes(className)) {\n        elem.classList.remove(className);\n      }\n    });\n  };\n  /**\n   * @param {HTMLElement} elem\n   * @param {SweetAlertOptions} params\n   * @param {string} className\n   */\n\n\n  const applyCustomClass = (elem, params, className) => {\n    removeCustomClasses(elem, params);\n\n    if (params.customClass && params.customClass[className]) {\n      if (typeof params.customClass[className] !== 'string' && !params.customClass[className].forEach) {\n        return warn(\"Invalid type of customClass.\".concat(className, \"! Expected string or iterable object, got \\\"\").concat(typeof params.customClass[className], \"\\\"\"));\n      }\n\n      addClass(elem, params.customClass[className]);\n    }\n  };\n  /**\n   * @param {HTMLElement} popup\n   * @param {import('./renderers/renderInput').InputClass} inputClass\n   * @returns {HTMLInputElement | null}\n   */\n\n  const getInput = (popup, inputClass) => {\n    if (!inputClass) {\n      return null;\n    }\n\n    switch (inputClass) {\n      case 'select':\n      case 'textarea':\n      case 'file':\n        return popup.querySelector(\".\".concat(swalClasses.popup, \" > .\").concat(swalClasses[inputClass]));\n\n      case 'checkbox':\n        return popup.querySelector(\".\".concat(swalClasses.popup, \" > .\").concat(swalClasses.checkbox, \" input\"));\n\n      case 'radio':\n        return popup.querySelector(\".\".concat(swalClasses.popup, \" > .\").concat(swalClasses.radio, \" input:checked\")) || popup.querySelector(\".\".concat(swalClasses.popup, \" > .\").concat(swalClasses.radio, \" input:first-child\"));\n\n      case 'range':\n        return popup.querySelector(\".\".concat(swalClasses.popup, \" > .\").concat(swalClasses.range, \" input\"));\n\n      default:\n        return popup.querySelector(\".\".concat(swalClasses.popup, \" > .\").concat(swalClasses.input));\n    }\n  };\n  /**\n   * @param {HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement} input\n   */\n\n  const focusInput = input => {\n    input.focus(); // place cursor at end of text in text input\n\n    if (input.type !== 'file') {\n      // http://stackoverflow.com/a/2345915\n      const val = input.value;\n      input.value = '';\n      input.value = val;\n    }\n  };\n  /**\n   * @param {HTMLElement | HTMLElement[] | null} target\n   * @param {string | string[] | readonly string[]} classList\n   * @param {boolean} condition\n   */\n\n  const toggleClass = (target, classList, condition) => {\n    if (!target || !classList) {\n      return;\n    }\n\n    if (typeof classList === 'string') {\n      classList = classList.split(/\\s+/).filter(Boolean);\n    }\n\n    classList.forEach(className => {\n      if (Array.isArray(target)) {\n        target.forEach(elem => {\n          condition ? elem.classList.add(className) : elem.classList.remove(className);\n        });\n      } else {\n        condition ? target.classList.add(className) : target.classList.remove(className);\n      }\n    });\n  };\n  /**\n   * @param {HTMLElement | HTMLElement[] | null} target\n   * @param {string | string[] | readonly string[]} classList\n   */\n\n  const addClass = (target, classList) => {\n    toggleClass(target, classList, true);\n  };\n  /**\n   * @param {HTMLElement | HTMLElement[] | null} target\n   * @param {string | string[] | readonly string[]} classList\n   */\n\n  const removeClass = (target, classList) => {\n    toggleClass(target, classList, false);\n  };\n  /**\n   * Get direct child of an element by class name\n   *\n   * @param {HTMLElement} elem\n   * @param {string} className\n   * @returns {HTMLElement | null}\n   */\n\n  const getDirectChildByClass = (elem, className) => {\n    const childNodes = toArray(elem.childNodes);\n\n    for (let i = 0; i < childNodes.length; i++) {\n      if (hasClass(childNodes[i], className)) {\n        return childNodes[i];\n      }\n    }\n  };\n  /**\n   * @param {HTMLElement} elem\n   * @param {string} property\n   * @param {*} value\n   */\n\n  const applyNumericalStyle = (elem, property, value) => {\n    if (value === \"\".concat(parseInt(value))) {\n      value = parseInt(value);\n    }\n\n    if (value || parseInt(value) === 0) {\n      elem.style[property] = typeof value === 'number' ? \"\".concat(value, \"px\") : value;\n    } else {\n      elem.style.removeProperty(property);\n    }\n  };\n  /**\n   * @param {HTMLElement} elem\n   * @param {string} display\n   */\n\n  const show = function (elem) {\n    let display = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'flex';\n    elem.style.display = display;\n  };\n  /**\n   * @param {HTMLElement} elem\n   */\n\n  const hide = elem => {\n    elem.style.display = 'none';\n  };\n  /**\n   * @param {HTMLElement} parent\n   * @param {string} selector\n   * @param {string} property\n   * @param {string} value\n   */\n\n  const setStyle = (parent, selector, property, value) => {\n    /** @type {HTMLElement} */\n    const el = parent.querySelector(selector);\n\n    if (el) {\n      el.style[property] = value;\n    }\n  };\n  /**\n   * @param {HTMLElement} elem\n   * @param {any} condition\n   * @param {string} display\n   */\n\n  const toggle = function (elem, condition) {\n    let display = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'flex';\n    condition ? show(elem, display) : hide(elem);\n  };\n  /**\n   * borrowed from jquery $(elem).is(':visible') implementation\n   *\n   * @param {HTMLElement} elem\n   * @returns {boolean}\n   */\n\n  const isVisible = elem => !!(elem && (elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length));\n  /**\n   * @returns {boolean}\n   */\n\n  const allButtonsAreHidden = () => !isVisible(getConfirmButton()) && !isVisible(getDenyButton()) && !isVisible(getCancelButton());\n  /**\n   * @returns {boolean}\n   */\n\n  const isScrollable = elem => !!(elem.scrollHeight > elem.clientHeight);\n  /**\n   * borrowed from https://stackoverflow.com/a/46352119\n   *\n   * @param {HTMLElement} elem\n   * @returns {boolean}\n   */\n\n  const hasCssAnimation = elem => {\n    const style = window.getComputedStyle(elem);\n    const animDuration = parseFloat(style.getPropertyValue('animation-duration') || '0');\n    const transDuration = parseFloat(style.getPropertyValue('transition-duration') || '0');\n    return animDuration > 0 || transDuration > 0;\n  };\n  /**\n   * @param {number} timer\n   * @param {boolean} reset\n   */\n\n  const animateTimerProgressBar = function (timer) {\n    let reset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const timerProgressBar = getTimerProgressBar();\n\n    if (isVisible(timerProgressBar)) {\n      if (reset) {\n        timerProgressBar.style.transition = 'none';\n        timerProgressBar.style.width = '100%';\n      }\n\n      setTimeout(() => {\n        timerProgressBar.style.transition = \"width \".concat(timer / 1000, \"s linear\");\n        timerProgressBar.style.width = '0%';\n      }, 10);\n    }\n  };\n  const stopTimerProgressBar = () => {\n    const timerProgressBar = getTimerProgressBar();\n    const timerProgressBarWidth = parseInt(window.getComputedStyle(timerProgressBar).width);\n    timerProgressBar.style.removeProperty('transition');\n    timerProgressBar.style.width = '100%';\n    const timerProgressBarFullWidth = parseInt(window.getComputedStyle(timerProgressBar).width);\n    const timerProgressBarPercent = timerProgressBarWidth / timerProgressBarFullWidth * 100;\n    timerProgressBar.style.removeProperty('transition');\n    timerProgressBar.style.width = \"\".concat(timerProgressBarPercent, \"%\");\n  };\n\n  /**\n   * Detect Node env\n   *\n   * @returns {boolean}\n   */\n  const isNodeEnv = () => typeof window === 'undefined' || typeof document === 'undefined';\n\n  const RESTORE_FOCUS_TIMEOUT = 100;\n\n  /** @type {GlobalState} */\n\n  const globalState = {};\n\n  const focusPreviousActiveElement = () => {\n    if (globalState.previousActiveElement instanceof HTMLElement) {\n      globalState.previousActiveElement.focus();\n      globalState.previousActiveElement = null;\n    } else if (document.body) {\n      document.body.focus();\n    }\n  };\n  /**\n   * Restore previous active (focused) element\n   *\n   * @param {boolean} returnFocus\n   * @returns {Promise}\n   */\n\n\n  const restoreActiveElement = returnFocus => {\n    return new Promise(resolve => {\n      if (!returnFocus) {\n        return resolve();\n      }\n\n      const x = window.scrollX;\n      const y = window.scrollY;\n      globalState.restoreFocusTimeout = setTimeout(() => {\n        focusPreviousActiveElement();\n        resolve();\n      }, RESTORE_FOCUS_TIMEOUT); // issues/900\n\n      window.scrollTo(x, y);\n    });\n  };\n\n  const sweetHTML = \"\\n <div aria-labelledby=\\\"\".concat(swalClasses.title, \"\\\" aria-describedby=\\\"\").concat(swalClasses['html-container'], \"\\\" class=\\\"\").concat(swalClasses.popup, \"\\\" tabindex=\\\"-1\\\">\\n   <button type=\\\"button\\\" class=\\\"\").concat(swalClasses.close, \"\\\"></button>\\n   <ul class=\\\"\").concat(swalClasses['progress-steps'], \"\\\"></ul>\\n   <div class=\\\"\").concat(swalClasses.icon, \"\\\"></div>\\n   <img class=\\\"\").concat(swalClasses.image, \"\\\" />\\n   <h2 class=\\\"\").concat(swalClasses.title, \"\\\" id=\\\"\").concat(swalClasses.title, \"\\\"></h2>\\n   <div class=\\\"\").concat(swalClasses['html-container'], \"\\\" id=\\\"\").concat(swalClasses['html-container'], \"\\\"></div>\\n   <input class=\\\"\").concat(swalClasses.input, \"\\\" />\\n   <input type=\\\"file\\\" class=\\\"\").concat(swalClasses.file, \"\\\" />\\n   <div class=\\\"\").concat(swalClasses.range, \"\\\">\\n     <input type=\\\"range\\\" />\\n     <output></output>\\n   </div>\\n   <select class=\\\"\").concat(swalClasses.select, \"\\\"></select>\\n   <div class=\\\"\").concat(swalClasses.radio, \"\\\"></div>\\n   <label for=\\\"\").concat(swalClasses.checkbox, \"\\\" class=\\\"\").concat(swalClasses.checkbox, \"\\\">\\n     <input type=\\\"checkbox\\\" />\\n     <span class=\\\"\").concat(swalClasses.label, \"\\\"></span>\\n   </label>\\n   <textarea class=\\\"\").concat(swalClasses.textarea, \"\\\"></textarea>\\n   <div class=\\\"\").concat(swalClasses['validation-message'], \"\\\" id=\\\"\").concat(swalClasses['validation-message'], \"\\\"></div>\\n   <div class=\\\"\").concat(swalClasses.actions, \"\\\">\\n     <div class=\\\"\").concat(swalClasses.loader, \"\\\"></div>\\n     <button type=\\\"button\\\" class=\\\"\").concat(swalClasses.confirm, \"\\\"></button>\\n     <button type=\\\"button\\\" class=\\\"\").concat(swalClasses.deny, \"\\\"></button>\\n     <button type=\\\"button\\\" class=\\\"\").concat(swalClasses.cancel, \"\\\"></button>\\n   </div>\\n   <div class=\\\"\").concat(swalClasses.footer, \"\\\"></div>\\n   <div class=\\\"\").concat(swalClasses['timer-progress-bar-container'], \"\\\">\\n     <div class=\\\"\").concat(swalClasses['timer-progress-bar'], \"\\\"></div>\\n   </div>\\n </div>\\n\").replace(/(^|\\n)\\s*/g, '');\n  /**\n   * @returns {boolean}\n   */\n\n  const resetOldContainer = () => {\n    const oldContainer = getContainer();\n\n    if (!oldContainer) {\n      return false;\n    }\n\n    oldContainer.remove();\n    removeClass([document.documentElement, document.body], [swalClasses['no-backdrop'], swalClasses['toast-shown'], swalClasses['has-column']]);\n    return true;\n  };\n\n  const resetValidationMessage = () => {\n    globalState.currentInstance.resetValidationMessage();\n  };\n\n  const addInputChangeListeners = () => {\n    const popup = getPopup();\n    const input = getDirectChildByClass(popup, swalClasses.input);\n    const file = getDirectChildByClass(popup, swalClasses.file);\n    /** @type {HTMLInputElement} */\n\n    const range = popup.querySelector(\".\".concat(swalClasses.range, \" input\"));\n    /** @type {HTMLOutputElement} */\n\n    const rangeOutput = popup.querySelector(\".\".concat(swalClasses.range, \" output\"));\n    const select = getDirectChildByClass(popup, swalClasses.select);\n    /** @type {HTMLInputElement} */\n\n    const checkbox = popup.querySelector(\".\".concat(swalClasses.checkbox, \" input\"));\n    const textarea = getDirectChildByClass(popup, swalClasses.textarea);\n    input.oninput = resetValidationMessage;\n    file.onchange = resetValidationMessage;\n    select.onchange = resetValidationMessage;\n    checkbox.onchange = resetValidationMessage;\n    textarea.oninput = resetValidationMessage;\n\n    range.oninput = () => {\n      resetValidationMessage();\n      rangeOutput.value = range.value;\n    };\n\n    range.onchange = () => {\n      resetValidationMessage();\n      rangeOutput.value = range.value;\n    };\n  };\n  /**\n   * @param {string | HTMLElement} target\n   * @returns {HTMLElement}\n   */\n\n\n  const getTarget = target => typeof target === 'string' ? document.querySelector(target) : target;\n  /**\n   * @param {SweetAlertOptions} params\n   */\n\n\n  const setupAccessibility = params => {\n    const popup = getPopup();\n    popup.setAttribute('role', params.toast ? 'alert' : 'dialog');\n    popup.setAttribute('aria-live', params.toast ? 'polite' : 'assertive');\n\n    if (!params.toast) {\n      popup.setAttribute('aria-modal', 'true');\n    }\n  };\n  /**\n   * @param {HTMLElement} targetElement\n   */\n\n\n  const setupRTL = targetElement => {\n    if (window.getComputedStyle(targetElement).direction === 'rtl') {\n      addClass(getContainer(), swalClasses.rtl);\n    }\n  };\n  /**\n   * Add modal + backdrop + no-war message for Russians to DOM\n   *\n   * @param {SweetAlertOptions} params\n   */\n\n\n  const init = params => {\n    // Clean up the old popup container if it exists\n    const oldContainerExisted = resetOldContainer();\n    /* istanbul ignore if */\n\n    if (isNodeEnv()) {\n      error('SweetAlert2 requires document to initialize');\n      return;\n    }\n\n    const container = document.createElement('div');\n    container.className = swalClasses.container;\n\n    if (oldContainerExisted) {\n      addClass(container, swalClasses['no-transition']);\n    }\n\n    setInnerHtml(container, sweetHTML);\n    const targetElement = getTarget(params.target);\n    targetElement.appendChild(container);\n    setupAccessibility(params);\n    setupRTL(targetElement);\n    addInputChangeListeners();\n    noWarMessageForRussians(container, params);\n  };\n  /**\n   * @param {HTMLElement} container\n   * @param {SweetAlertOptions} params\n   */\n\n  const noWarMessageForRussians = (container, params) => {\n    if (params.toast) {\n      return;\n    } // This message is targeted at people who are corrupted by propaganda, everybody else\n    // is already against war either silently or actively.\n    //\n    // The point is to wrap the truth-bomb into a patriotic title so they will actually click it\n    // and listen to the uncomfortable truth about the war from the people they love or respect.\n\n\n    const message = getRandomElement([{\n      text: '  <br>     ',\n      // Arnold is loved in Russia by all people including those who are for this war\n      // His speech might change the mind of those who are brainwashed by propaganda\n      youtubeId: 'fWClXZd9c78'\n    }, {\n      text: '  <br>    ',\n      // In this video one of the most famous Russian nationalist leaders, Dmitry Demushkin,\n      // explains that this war has no sense and produces the exact opposite result of what\n      // it was intended to do.\n      youtubeId: '_RjBNkn88yA'\n    }, {\n      text: '   <br>    ',\n      // In this video Igor Girkin, who played a key role in the annexation of Crimea,\n      // explains that this war has failed already and all possible outcomes are bad for Russia.\n      youtubeId: 'yUmzQT4C8JY'\n    }, {\n      text: '   <br>  -  ',\n      youtubeId: 'hkCYb6edUrQ'\n    }, {\n      text: '   <br>    ',\n      youtubeId: 'w4-_8BJKfpk'\n    }, {\n      text: '   <br>     ',\n      youtubeId: 'saK5UTKroDA'\n    }]); // The message will only be shown to Russian users visiting Russian sites\n\n    if (navigator.language === 'ru' && location.host.match(/\\.(ru|su|xn--p1ai)$/)) {\n      const noWar = document.createElement('div');\n      noWar.className = swalClasses['no-war'];\n      setInnerHtml(noWar, \"<a href=\\\"https://www.youtube.com/watch?v=\".concat(message.youtubeId, \"\\\" target=\\\"_blank\\\">\").concat(message.text, \"</a>\"));\n      container.appendChild(noWar);\n      container.style.paddingTop = '4em';\n    }\n  };\n\n  /**\n   * @param {HTMLElement | object | string} param\n   * @param {HTMLElement} target\n   */\n\n  const parseHtmlToContainer = (param, target) => {\n    // DOM element\n    if (param instanceof HTMLElement) {\n      target.appendChild(param);\n    } // Object\n    else if (typeof param === 'object') {\n      handleObject(param, target);\n    } // Plain string\n    else if (param) {\n      setInnerHtml(target, param);\n    }\n  };\n  /**\n   * @param {object} param\n   * @param {HTMLElement} target\n   */\n\n  const handleObject = (param, target) => {\n    // JQuery element(s)\n    if (param.jquery) {\n      handleJqueryElem(target, param);\n    } // For other objects use their string representation\n    else {\n      setInnerHtml(target, param.toString());\n    }\n  };\n  /**\n   * @param {HTMLElement} target\n   * @param {HTMLElement} elem\n   */\n\n\n  const handleJqueryElem = (target, elem) => {\n    target.textContent = '';\n\n    if (0 in elem) {\n      for (let i = 0; (i in elem); i++) {\n        target.appendChild(elem[i].cloneNode(true));\n      }\n    } else {\n      target.appendChild(elem.cloneNode(true));\n    }\n  };\n\n  /**\n   * @returns {'webkitAnimationEnd' | 'animationend' | false}\n   */\n\n  const animationEndEvent = (() => {\n    // Prevent run in Node env\n\n    /* istanbul ignore if */\n    if (isNodeEnv()) {\n      return false;\n    }\n\n    const testEl = document.createElement('div');\n    const transEndEventNames = {\n      WebkitAnimation: 'webkitAnimationEnd',\n      // Chrome, Safari and Opera\n      animation: 'animationend' // Standard syntax\n\n    };\n\n    for (const i in transEndEventNames) {\n      if (Object.prototype.hasOwnProperty.call(transEndEventNames, i) && typeof testEl.style[i] !== 'undefined') {\n        return transEndEventNames[i];\n      }\n    }\n\n    return false;\n  })();\n\n  /**\n   * Measure scrollbar width for padding body during modal show/hide\n   * https://github.com/twbs/bootstrap/blob/master/js/src/modal.js\n   *\n   * @returns {number}\n   */\n\n  const measureScrollbar = () => {\n    const scrollDiv = document.createElement('div');\n    scrollDiv.className = swalClasses['scrollbar-measure'];\n    document.body.appendChild(scrollDiv);\n    const scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;\n    document.body.removeChild(scrollDiv);\n    return scrollbarWidth;\n  };\n\n  /**\n   * @param {SweetAlert2} instance\n   * @param {SweetAlertOptions} params\n   */\n\n  const renderActions = (instance, params) => {\n    const actions = getActions();\n    const loader = getLoader(); // Actions (buttons) wrapper\n\n    if (!params.showConfirmButton && !params.showDenyButton && !params.showCancelButton) {\n      hide(actions);\n    } else {\n      show(actions);\n    } // Custom class\n\n\n    applyCustomClass(actions, params, 'actions'); // Render all the buttons\n\n    renderButtons(actions, loader, params); // Loader\n\n    setInnerHtml(loader, params.loaderHtml);\n    applyCustomClass(loader, params, 'loader');\n  };\n  /**\n   * @param {HTMLElement} actions\n   * @param {HTMLElement} loader\n   * @param {SweetAlertOptions} params\n   */\n\n  function renderButtons(actions, loader, params) {\n    const confirmButton = getConfirmButton();\n    const denyButton = getDenyButton();\n    const cancelButton = getCancelButton(); // Render buttons\n\n    renderButton(confirmButton, 'confirm', params);\n    renderButton(denyButton, 'deny', params);\n    renderButton(cancelButton, 'cancel', params);\n    handleButtonsStyling(confirmButton, denyButton, cancelButton, params);\n\n    if (params.reverseButtons) {\n      if (params.toast) {\n        actions.insertBefore(cancelButton, confirmButton);\n        actions.insertBefore(denyButton, confirmButton);\n      } else {\n        actions.insertBefore(cancelButton, loader);\n        actions.insertBefore(denyButton, loader);\n        actions.insertBefore(confirmButton, loader);\n      }\n    }\n  }\n  /**\n   * @param {HTMLElement} confirmButton\n   * @param {HTMLElement} denyButton\n   * @param {HTMLElement} cancelButton\n   * @param {SweetAlertOptions} params\n   */\n\n\n  function handleButtonsStyling(confirmButton, denyButton, cancelButton, params) {\n    if (!params.buttonsStyling) {\n      return removeClass([confirmButton, denyButton, cancelButton], swalClasses.styled);\n    }\n\n    addClass([confirmButton, denyButton, cancelButton], swalClasses.styled); // Buttons background colors\n\n    if (params.confirmButtonColor) {\n      confirmButton.style.backgroundColor = params.confirmButtonColor;\n      addClass(confirmButton, swalClasses['default-outline']);\n    }\n\n    if (params.denyButtonColor) {\n      denyButton.style.backgroundColor = params.denyButtonColor;\n      addClass(denyButton, swalClasses['default-outline']);\n    }\n\n    if (params.cancelButtonColor) {\n      cancelButton.style.backgroundColor = params.cancelButtonColor;\n      addClass(cancelButton, swalClasses['default-outline']);\n    }\n  }\n  /**\n   * @param {HTMLElement} button\n   * @param {'confirm' | 'deny' | 'cancel'} buttonType\n   * @param {SweetAlertOptions} params\n   */\n\n\n  function renderButton(button, buttonType, params) {\n    toggle(button, params[\"show\".concat(capitalizeFirstLetter(buttonType), \"Button\")], 'inline-block');\n    setInnerHtml(button, params[\"\".concat(buttonType, \"ButtonText\")]); // Set caption text\n\n    button.setAttribute('aria-label', params[\"\".concat(buttonType, \"ButtonAriaLabel\")]); // ARIA label\n    // Add buttons custom classes\n\n    button.className = swalClasses[buttonType];\n    applyCustomClass(button, params, \"\".concat(buttonType, \"Button\"));\n    addClass(button, params[\"\".concat(buttonType, \"ButtonClass\")]);\n  }\n\n  /**\n   * @param {SweetAlert2} instance\n   * @param {SweetAlertOptions} params\n   */\n\n  const renderContainer = (instance, params) => {\n    const container = getContainer();\n\n    if (!container) {\n      return;\n    }\n\n    handleBackdropParam(container, params.backdrop);\n    handlePositionParam(container, params.position);\n    handleGrowParam(container, params.grow); // Custom class\n\n    applyCustomClass(container, params, 'container');\n  };\n  /**\n   * @param {HTMLElement} container\n   * @param {SweetAlertOptions['backdrop']} backdrop\n   */\n\n  function handleBackdropParam(container, backdrop) {\n    if (typeof backdrop === 'string') {\n      container.style.background = backdrop;\n    } else if (!backdrop) {\n      addClass([document.documentElement, document.body], swalClasses['no-backdrop']);\n    }\n  }\n  /**\n   * @param {HTMLElement} container\n   * @param {SweetAlertOptions['position']} position\n   */\n\n\n  function handlePositionParam(container, position) {\n    if (position in swalClasses) {\n      addClass(container, swalClasses[position]);\n    } else {\n      warn('The \"position\" parameter is not valid, defaulting to \"center\"');\n      addClass(container, swalClasses.center);\n    }\n  }\n  /**\n   * @param {HTMLElement} container\n   * @param {SweetAlertOptions['grow']} grow\n   */\n\n\n  function handleGrowParam(container, grow) {\n    if (grow && typeof grow === 'string') {\n      const growClass = \"grow-\".concat(grow);\n\n      if (growClass in swalClasses) {\n        addClass(container, swalClasses[growClass]);\n      }\n    }\n  }\n\n  /**\n   * This module contains `WeakMap`s for each effectively-\"private  property\" that a `Swal` has.\n   * For example, to set the private property \"foo\" of `this` to \"bar\", you can `privateProps.foo.set(this, 'bar')`\n   * This is the approach that Babel will probably take to implement private methods/fields\n   *   https://github.com/tc39/proposal-private-methods\n   *   https://github.com/babel/babel/pull/7555\n   * Once we have the changes from that PR in Babel, and our core class fits reasonable in *one module*\n   *   then we can use that language feature.\n   */\n  var privateProps = {\n    awaitingPromise: new WeakMap(),\n    promise: new WeakMap(),\n    innerParams: new WeakMap(),\n    domCache: new WeakMap()\n  };\n\n  /// <reference path=\"../../../../sweetalert2.d.ts\"/>\n  /** @type {InputClass[]} */\n\n  const inputClasses = ['input', 'file', 'range', 'select', 'radio', 'checkbox', 'textarea'];\n  /**\n   * @param {SweetAlert2} instance\n   * @param {SweetAlertOptions} params\n   */\n\n  const renderInput = (instance, params) => {\n    const popup = getPopup();\n    const innerParams = privateProps.innerParams.get(instance);\n    const rerender = !innerParams || params.input !== innerParams.input;\n    inputClasses.forEach(inputClass => {\n      const inputContainer = getDirectChildByClass(popup, swalClasses[inputClass]); // set attributes\n\n      setAttributes(inputClass, params.inputAttributes); // set class\n\n      inputContainer.className = swalClasses[inputClass];\n\n      if (rerender) {\n        hide(inputContainer);\n      }\n    });\n\n    if (params.input) {\n      if (rerender) {\n        showInput(params);\n      } // set custom class\n\n\n      setCustomClass(params);\n    }\n  };\n  /**\n   * @param {SweetAlertOptions} params\n   */\n\n  const showInput = params => {\n    if (!renderInputType[params.input]) {\n      return error(\"Unexpected type of input! Expected \\\"text\\\", \\\"email\\\", \\\"password\\\", \\\"number\\\", \\\"tel\\\", \\\"select\\\", \\\"radio\\\", \\\"checkbox\\\", \\\"textarea\\\", \\\"file\\\" or \\\"url\\\", got \\\"\".concat(params.input, \"\\\"\"));\n    }\n\n    const inputContainer = getInputContainer(params.input);\n    const input = renderInputType[params.input](inputContainer, params);\n    show(inputContainer); // input autofocus\n\n    setTimeout(() => {\n      focusInput(input);\n    });\n  };\n  /**\n   * @param {HTMLInputElement} input\n   */\n\n\n  const removeAttributes = input => {\n    for (let i = 0; i < input.attributes.length; i++) {\n      const attrName = input.attributes[i].name;\n\n      if (!['type', 'value', 'style'].includes(attrName)) {\n        input.removeAttribute(attrName);\n      }\n    }\n  };\n  /**\n   * @param {InputClass} inputClass\n   * @param {SweetAlertOptions['inputAttributes']} inputAttributes\n   */\n\n\n  const setAttributes = (inputClass, inputAttributes) => {\n    const input = getInput(getPopup(), inputClass);\n\n    if (!input) {\n      return;\n    }\n\n    removeAttributes(input);\n\n    for (const attr in inputAttributes) {\n      input.setAttribute(attr, inputAttributes[attr]);\n    }\n  };\n  /**\n   * @param {SweetAlertOptions} params\n   */\n\n\n  const setCustomClass = params => {\n    const inputContainer = getInputContainer(params.input);\n\n    if (typeof params.customClass === 'object') {\n      addClass(inputContainer, params.customClass.input);\n    }\n  };\n  /**\n   * @param {HTMLInputElement | HTMLTextAreaElement} input\n   * @param {SweetAlertOptions} params\n   */\n\n\n  const setInputPlaceholder = (input, params) => {\n    if (!input.placeholder || params.inputPlaceholder) {\n      input.placeholder = params.inputPlaceholder;\n    }\n  };\n  /**\n   * @param {Input} input\n   * @param {Input} prependTo\n   * @param {SweetAlertOptions} params\n   */\n\n\n  const setInputLabel = (input, prependTo, params) => {\n    if (params.inputLabel) {\n      input.id = swalClasses.input;\n      const label = document.createElement('label');\n      const labelClass = swalClasses['input-label'];\n      label.setAttribute('for', input.id);\n      label.className = labelClass;\n\n      if (typeof params.customClass === 'object') {\n        addClass(label, params.customClass.inputLabel);\n      }\n\n      label.innerText = params.inputLabel;\n      prependTo.insertAdjacentElement('beforebegin', label);\n    }\n  };\n  /**\n   * @param {SweetAlertOptions['input']} inputType\n   * @returns {HTMLElement}\n   */\n\n\n  const getInputContainer = inputType => {\n    return getDirectChildByClass(getPopup(), swalClasses[inputType] || swalClasses.input);\n  };\n  /**\n   * @param {HTMLInputElement | HTMLOutputElement | HTMLTextAreaElement} input\n   * @param {SweetAlertOptions['inputValue']} inputValue\n   */\n\n\n  const checkAndSetInputValue = (input, inputValue) => {\n    if (['string', 'number'].includes(typeof inputValue)) {\n      input.value = \"\".concat(inputValue);\n    } else if (!isPromise(inputValue)) {\n      warn(\"Unexpected type of inputValue! Expected \\\"string\\\", \\\"number\\\" or \\\"Promise\\\", got \\\"\".concat(typeof inputValue, \"\\\"\"));\n    }\n  };\n  /** @type Record<string, (input: Input | HTMLElement, params: SweetAlertOptions) => Input> */\n\n\n  const renderInputType = {};\n  /**\n   * @param {HTMLInputElement} input\n   * @param {SweetAlertOptions} params\n   * @returns {HTMLInputElement}\n   */\n\n  renderInputType.text = renderInputType.email = renderInputType.password = renderInputType.number = renderInputType.tel = renderInputType.url = (input, params) => {\n    checkAndSetInputValue(input, params.inputValue);\n    setInputLabel(input, input, params);\n    setInputPlaceholder(input, params);\n    input.type = params.input;\n    return input;\n  };\n  /**\n   * @param {HTMLInputElement} input\n   * @param {SweetAlertOptions} params\n   * @returns {HTMLInputElement}\n   */\n\n\n  renderInputType.file = (input, params) => {\n    setInputLabel(input, input, params);\n    setInputPlaceholder(input, params);\n    return input;\n  };\n  /**\n   * @param {HTMLInputElement} range\n   * @param {SweetAlertOptions} params\n   * @returns {HTMLInputElement}\n   */\n\n\n  renderInputType.range = (range, params) => {\n    const rangeInput = range.querySelector('input');\n    const rangeOutput = range.querySelector('output');\n    checkAndSetInputValue(rangeInput, params.inputValue);\n    rangeInput.type = params.input;\n    checkAndSetInputValue(rangeOutput, params.inputValue);\n    setInputLabel(rangeInput, range, params);\n    return range;\n  };\n  /**\n   * @param {HTMLSelectElement} select\n   * @param {SweetAlertOptions} params\n   * @returns {HTMLSelectElement}\n   */\n\n\n  renderInputType.select = (select, params) => {\n    select.textContent = '';\n\n    if (params.inputPlaceholder) {\n      const placeholder = document.createElement('option');\n      setInnerHtml(placeholder, params.inputPlaceholder);\n      placeholder.value = '';\n      placeholder.disabled = true;\n      placeholder.selected = true;\n      select.appendChild(placeholder);\n    }\n\n    setInputLabel(select, select, params);\n    return select;\n  };\n  /**\n   * @param {HTMLInputElement} radio\n   * @returns {HTMLInputElement}\n   */\n\n\n  renderInputType.radio = radio => {\n    radio.textContent = '';\n    return radio;\n  };\n  /**\n   * @param {HTMLLabelElement} checkboxContainer\n   * @param {SweetAlertOptions} params\n   * @returns {HTMLInputElement}\n   */\n\n\n  renderInputType.checkbox = (checkboxContainer, params) => {\n    const checkbox = getInput(getPopup(), 'checkbox');\n    checkbox.value = '1';\n    checkbox.id = swalClasses.checkbox;\n    checkbox.checked = Boolean(params.inputValue);\n    const label = checkboxContainer.querySelector('span');\n    setInnerHtml(label, params.inputPlaceholder);\n    return checkbox;\n  };\n  /**\n   * @param {HTMLTextAreaElement} textarea\n   * @param {SweetAlertOptions} params\n   * @returns {HTMLTextAreaElement}\n   */\n\n\n  renderInputType.textarea = (textarea, params) => {\n    checkAndSetInputValue(textarea, params.inputValue);\n    setInputPlaceholder(textarea, params);\n    setInputLabel(textarea, textarea, params);\n    /**\n     * @param {HTMLElement} el\n     * @returns {number}\n     */\n\n    const getMargin = el => parseInt(window.getComputedStyle(el).marginLeft) + parseInt(window.getComputedStyle(el).marginRight); // https://github.com/sweetalert2/sweetalert2/issues/2291\n\n\n    setTimeout(() => {\n      // https://github.com/sweetalert2/sweetalert2/issues/1699\n      if ('MutationObserver' in window) {\n        const initialPopupWidth = parseInt(window.getComputedStyle(getPopup()).width);\n\n        const textareaResizeHandler = () => {\n          const textareaWidth = textarea.offsetWidth + getMargin(textarea);\n\n          if (textareaWidth > initialPopupWidth) {\n            getPopup().style.width = \"\".concat(textareaWidth, \"px\");\n          } else {\n            getPopup().style.width = null;\n          }\n        };\n\n        new MutationObserver(textareaResizeHandler).observe(textarea, {\n          attributes: true,\n          attributeFilter: ['style']\n        });\n      }\n    });\n    return textarea;\n  };\n\n  /**\n   * @param {SweetAlert2} instance\n   * @param {SweetAlertOptions} params\n   */\n\n  const renderContent = (instance, params) => {\n    const htmlContainer = getHtmlContainer();\n    applyCustomClass(htmlContainer, params, 'htmlContainer'); // Content as HTML\n\n    if (params.html) {\n      parseHtmlToContainer(params.html, htmlContainer);\n      show(htmlContainer, 'block');\n    } // Content as plain text\n    else if (params.text) {\n      htmlContainer.textContent = params.text;\n      show(htmlContainer, 'block');\n    } // No content\n    else {\n      hide(htmlContainer);\n    }\n\n    renderInput(instance, params);\n  };\n\n  /**\n   * @param {SweetAlert2} instance\n   * @param {SweetAlertOptions} params\n   */\n\n  const renderFooter = (instance, params) => {\n    const footer = getFooter();\n    toggle(footer, params.footer);\n\n    if (params.footer) {\n      parseHtmlToContainer(params.footer, footer);\n    } // Custom class\n\n\n    applyCustomClass(footer, params, 'footer');\n  };\n\n  /**\n   * @param {SweetAlert2} instance\n   * @param {SweetAlertOptions} params\n   */\n\n  const renderCloseButton = (instance, params) => {\n    const closeButton = getCloseButton();\n    setInnerHtml(closeButton, params.closeButtonHtml); // Custom class\n\n    applyCustomClass(closeButton, params, 'closeButton');\n    toggle(closeButton, params.showCloseButton);\n    closeButton.setAttribute('aria-label', params.closeButtonAriaLabel);\n  };\n\n  /**\n   * @param {SweetAlert2} instance\n   * @param {SweetAlertOptions} params\n   */\n\n  const renderIcon = (instance, params) => {\n    const innerParams = privateProps.innerParams.get(instance);\n    const icon = getIcon(); // if the given icon already rendered, apply the styling without re-rendering the icon\n\n    if (innerParams && params.icon === innerParams.icon) {\n      // Custom or default content\n      setContent(icon, params);\n      applyStyles(icon, params);\n      return;\n    }\n\n    if (!params.icon && !params.iconHtml) {\n      hide(icon);\n      return;\n    }\n\n    if (params.icon && Object.keys(iconTypes).indexOf(params.icon) === -1) {\n      error(\"Unknown icon! Expected \\\"success\\\", \\\"error\\\", \\\"warning\\\", \\\"info\\\" or \\\"question\\\", got \\\"\".concat(params.icon, \"\\\"\"));\n      hide(icon);\n      return;\n    }\n\n    show(icon); // Custom or default content\n\n    setContent(icon, params);\n    applyStyles(icon, params); // Animate icon\n\n    addClass(icon, params.showClass.icon);\n  };\n  /**\n   * @param {HTMLElement} icon\n   * @param {SweetAlertOptions} params\n   */\n\n  const applyStyles = (icon, params) => {\n    for (const iconType in iconTypes) {\n      if (params.icon !== iconType) {\n        removeClass(icon, iconTypes[iconType]);\n      }\n    }\n\n    addClass(icon, iconTypes[params.icon]); // Icon color\n\n    setColor(icon, params); // Success icon background color\n\n    adjustSuccessIconBackgroundColor(); // Custom class\n\n    applyCustomClass(icon, params, 'icon');\n  }; // Adjust success icon background color to match the popup background color\n\n\n  const adjustSuccessIconBackgroundColor = () => {\n    const popup = getPopup();\n    const popupBackgroundColor = window.getComputedStyle(popup).getPropertyValue('background-color');\n    /** @type {NodeListOf<HTMLElement>} */\n\n    const successIconParts = popup.querySelectorAll('[class^=swal2-success-circular-line], .swal2-success-fix');\n\n    for (let i = 0; i < successIconParts.length; i++) {\n      successIconParts[i].style.backgroundColor = popupBackgroundColor;\n    }\n  };\n\n  const successIconHtml = \"\\n  <div class=\\\"swal2-success-circular-line-left\\\"></div>\\n  <span class=\\\"swal2-success-line-tip\\\"></span> <span class=\\\"swal2-success-line-long\\\"></span>\\n  <div class=\\\"swal2-success-ring\\\"></div> <div class=\\\"swal2-success-fix\\\"></div>\\n  <div class=\\\"swal2-success-circular-line-right\\\"></div>\\n\";\n  const errorIconHtml = \"\\n  <span class=\\\"swal2-x-mark\\\">\\n    <span class=\\\"swal2-x-mark-line-left\\\"></span>\\n    <span class=\\\"swal2-x-mark-line-right\\\"></span>\\n  </span>\\n\";\n  /**\n   * @param {HTMLElement} icon\n   * @param {SweetAlertOptions} params\n   */\n\n  const setContent = (icon, params) => {\n    let oldContent = icon.innerHTML;\n    let newContent;\n\n    if (params.iconHtml) {\n      newContent = iconContent(params.iconHtml);\n    } else if (params.icon === 'success') {\n      newContent = successIconHtml;\n      oldContent = oldContent.replace(/ style=\".*?\"/g, ''); // undo adjustSuccessIconBackgroundColor()\n    } else if (params.icon === 'error') {\n      newContent = errorIconHtml;\n    } else {\n      const defaultIconHtml = {\n        question: '?',\n        warning: '!',\n        info: 'i'\n      };\n      newContent = iconContent(defaultIconHtml[params.icon]);\n    }\n\n    if (oldContent.trim() !== newContent.trim()) {\n      setInnerHtml(icon, newContent);\n    }\n  };\n  /**\n   * @param {HTMLElement} icon\n   * @param {SweetAlertOptions} params\n   */\n\n\n  const setColor = (icon, params) => {\n    if (!params.iconColor) {\n      return;\n    }\n\n    icon.style.color = params.iconColor;\n    icon.style.borderColor = params.iconColor;\n\n    for (const sel of ['.swal2-success-line-tip', '.swal2-success-line-long', '.swal2-x-mark-line-left', '.swal2-x-mark-line-right']) {\n      setStyle(icon, sel, 'backgroundColor', params.iconColor);\n    }\n\n    setStyle(icon, '.swal2-success-ring', 'borderColor', params.iconColor);\n  };\n  /**\n   * @param {string} content\n   * @returns {string}\n   */\n\n\n  const iconContent = content => \"<div class=\\\"\".concat(swalClasses['icon-content'], \"\\\">\").concat(content, \"</div>\");\n\n  /**\n   * @param {SweetAlert2} instance\n   * @param {SweetAlertOptions} params\n   */\n\n  const renderImage = (instance, params) => {\n    const image = getImage();\n\n    if (!params.imageUrl) {\n      return hide(image);\n    }\n\n    show(image, ''); // Src, alt\n\n    image.setAttribute('src', params.imageUrl);\n    image.setAttribute('alt', params.imageAlt); // Width, height\n\n    applyNumericalStyle(image, 'width', params.imageWidth);\n    applyNumericalStyle(image, 'height', params.imageHeight); // Class\n\n    image.className = swalClasses.image;\n    applyCustomClass(image, params, 'image');\n  };\n\n  /**\n   * @param {SweetAlert2} instance\n   * @param {SweetAlertOptions} params\n   */\n\n  const renderProgressSteps = (instance, params) => {\n    const progressStepsContainer = getProgressSteps();\n\n    if (!params.progressSteps || params.progressSteps.length === 0) {\n      return hide(progressStepsContainer);\n    }\n\n    show(progressStepsContainer);\n    progressStepsContainer.textContent = '';\n\n    if (params.currentProgressStep >= params.progressSteps.length) {\n      warn('Invalid currentProgressStep parameter, it should be less than progressSteps.length ' + '(currentProgressStep like JS arrays starts from 0)');\n    }\n\n    params.progressSteps.forEach((step, index) => {\n      const stepEl = createStepElement(step);\n      progressStepsContainer.appendChild(stepEl);\n\n      if (index === params.currentProgressStep) {\n        addClass(stepEl, swalClasses['active-progress-step']);\n      }\n\n      if (index !== params.progressSteps.length - 1) {\n        const lineEl = createLineElement(params);\n        progressStepsContainer.appendChild(lineEl);\n      }\n    });\n  };\n  /**\n   * @param {string} step\n   * @returns {HTMLLIElement}\n   */\n\n  const createStepElement = step => {\n    const stepEl = document.createElement('li');\n    addClass(stepEl, swalClasses['progress-step']);\n    setInnerHtml(stepEl, step);\n    return stepEl;\n  };\n  /**\n   * @param {SweetAlertOptions} params\n   * @returns {HTMLLIElement}\n   */\n\n\n  const createLineElement = params => {\n    const lineEl = document.createElement('li');\n    addClass(lineEl, swalClasses['progress-step-line']);\n\n    if (params.progressStepsDistance) {\n      applyNumericalStyle(lineEl, 'width', params.progressStepsDistance);\n    }\n\n    return lineEl;\n  };\n\n  /**\n   * @param {SweetAlert2} instance\n   * @param {SweetAlertOptions} params\n   */\n\n  const renderTitle = (instance, params) => {\n    const title = getTitle();\n    toggle(title, params.title || params.titleText, 'block');\n\n    if (params.title) {\n      parseHtmlToContainer(params.title, title);\n    }\n\n    if (params.titleText) {\n      title.innerText = params.titleText;\n    } // Custom class\n\n\n    applyCustomClass(title, params, 'title');\n  };\n\n  /**\n   * @param {SweetAlert2} instance\n   * @param {SweetAlertOptions} params\n   */\n\n  const renderPopup = (instance, params) => {\n    const container = getContainer();\n    const popup = getPopup(); // Width\n    // https://github.com/sweetalert2/sweetalert2/issues/2170\n\n    if (params.toast) {\n      applyNumericalStyle(container, 'width', params.width);\n      popup.style.width = '100%';\n      popup.insertBefore(getLoader(), getIcon());\n    } else {\n      applyNumericalStyle(popup, 'width', params.width);\n    } // Padding\n\n\n    applyNumericalStyle(popup, 'padding', params.padding); // Color\n\n    if (params.color) {\n      popup.style.color = params.color;\n    } // Background\n\n\n    if (params.background) {\n      popup.style.background = params.background;\n    }\n\n    hide(getValidationMessage()); // Classes\n\n    addClasses(popup, params);\n  };\n  /**\n   * @param {HTMLElement} popup\n   * @param {SweetAlertOptions} params\n   */\n\n  const addClasses = (popup, params) => {\n    // Default Class + showClass when updating Swal.update({})\n    popup.className = \"\".concat(swalClasses.popup, \" \").concat(isVisible(popup) ? params.showClass.popup : '');\n\n    if (params.toast) {\n      addClass([document.documentElement, document.body], swalClasses['toast-shown']);\n      addClass(popup, swalClasses.toast);\n    } else {\n      addClass(popup, swalClasses.modal);\n    } // Custom class\n\n\n    applyCustomClass(popup, params, 'popup');\n\n    if (typeof params.customClass === 'string') {\n      addClass(popup, params.customClass);\n    } // Icon class (#1842)\n\n\n    if (params.icon) {\n      addClass(popup, swalClasses[\"icon-\".concat(params.icon)]);\n    }\n  };\n\n  /**\n   * @param {SweetAlert2} instance\n   * @param {SweetAlertOptions} params\n   */\n\n  const render = (instance, params) => {\n    renderPopup(instance, params);\n    renderContainer(instance, params);\n    renderProgressSteps(instance, params);\n    renderIcon(instance, params);\n    renderImage(instance, params);\n    renderTitle(instance, params);\n    renderCloseButton(instance, params);\n    renderContent(instance, params);\n    renderActions(instance, params);\n    renderFooter(instance, params);\n\n    if (typeof params.didRender === 'function') {\n      params.didRender(getPopup());\n    }\n  };\n\n  const DismissReason = Object.freeze({\n    cancel: 'cancel',\n    backdrop: 'backdrop',\n    close: 'close',\n    esc: 'esc',\n    timer: 'timer'\n  });\n\n  // Adding aria-hidden=\"true\" to elements outside of the active modal dialog ensures that\n  // elements not within the active modal dialog will not be surfaced if a user opens a screen\n  // readers list of elements (headings, form controls, landmarks, etc.) in the document.\n\n  const setAriaHidden = () => {\n    const bodyChildren = toArray(document.body.children);\n    bodyChildren.forEach(el => {\n      if (el === getContainer() || el.contains(getContainer())) {\n        return;\n      }\n\n      if (el.hasAttribute('aria-hidden')) {\n        el.setAttribute('data-previous-aria-hidden', el.getAttribute('aria-hidden'));\n      }\n\n      el.setAttribute('aria-hidden', 'true');\n    });\n  };\n  const unsetAriaHidden = () => {\n    const bodyChildren = toArray(document.body.children);\n    bodyChildren.forEach(el => {\n      if (el.hasAttribute('data-previous-aria-hidden')) {\n        el.setAttribute('aria-hidden', el.getAttribute('data-previous-aria-hidden'));\n        el.removeAttribute('data-previous-aria-hidden');\n      } else {\n        el.removeAttribute('aria-hidden');\n      }\n    });\n  };\n\n  const swalStringParams = ['swal-title', 'swal-html', 'swal-footer'];\n  const getTemplateParams = params => {\n    const template = typeof params.template === 'string' ? document.querySelector(params.template) : params.template;\n\n    if (!template) {\n      return {};\n    }\n    /** @type {DocumentFragment} */\n\n\n    const templateContent = template.content;\n    showWarningsForElements(templateContent);\n    const result = Object.assign(getSwalParams(templateContent), getSwalButtons(templateContent), getSwalImage(templateContent), getSwalIcon(templateContent), getSwalInput(templateContent), getSwalStringParams(templateContent, swalStringParams));\n    return result;\n  };\n  /**\n   * @param {DocumentFragment} templateContent\n   */\n\n  const getSwalParams = templateContent => {\n    const result = {};\n    toArray(templateContent.querySelectorAll('swal-param')).forEach(param => {\n      showWarningsForAttributes(param, ['name', 'value']);\n      const paramName = param.getAttribute('name');\n      const value = param.getAttribute('value');\n\n      if (typeof defaultParams[paramName] === 'boolean' && value === 'false') {\n        result[paramName] = false;\n      }\n\n      if (typeof defaultParams[paramName] === 'object') {\n        result[paramName] = JSON.parse(value);\n      }\n    });\n    return result;\n  };\n  /**\n   * @param {DocumentFragment} templateContent\n   */\n\n\n  const getSwalButtons = templateContent => {\n    const result = {};\n    toArray(templateContent.querySelectorAll('swal-button')).forEach(button => {\n      showWarningsForAttributes(button, ['type', 'color', 'aria-label']);\n      const type = button.getAttribute('type');\n      result[\"\".concat(type, \"ButtonText\")] = button.innerHTML;\n      result[\"show\".concat(capitalizeFirstLetter(type), \"Button\")] = true;\n\n      if (button.hasAttribute('color')) {\n        result[\"\".concat(type, \"ButtonColor\")] = button.getAttribute('color');\n      }\n\n      if (button.hasAttribute('aria-label')) {\n        result[\"\".concat(type, \"ButtonAriaLabel\")] = button.getAttribute('aria-label');\n      }\n    });\n    return result;\n  };\n  /**\n   * @param {DocumentFragment} templateContent\n   */\n\n\n  const getSwalImage = templateContent => {\n    const result = {};\n    /** @type {HTMLElement} */\n\n    const image = templateContent.querySelector('swal-image');\n\n    if (image) {\n      showWarningsForAttributes(image, ['src', 'width', 'height', 'alt']);\n\n      if (image.hasAttribute('src')) {\n        result.imageUrl = image.getAttribute('src');\n      }\n\n      if (image.hasAttribute('width')) {\n        result.imageWidth = image.getAttribute('width');\n      }\n\n      if (image.hasAttribute('height')) {\n        result.imageHeight = image.getAttribute('height');\n      }\n\n      if (image.hasAttribute('alt')) {\n        result.imageAlt = image.getAttribute('alt');\n      }\n    }\n\n    return result;\n  };\n  /**\n   * @param {DocumentFragment} templateContent\n   */\n\n\n  const getSwalIcon = templateContent => {\n    const result = {};\n    /** @type {HTMLElement} */\n\n    const icon = templateContent.querySelector('swal-icon');\n\n    if (icon) {\n      showWarningsForAttributes(icon, ['type', 'color']);\n\n      if (icon.hasAttribute('type')) {\n        result.icon = icon.getAttribute('type');\n      }\n\n      if (icon.hasAttribute('color')) {\n        result.iconColor = icon.getAttribute('color');\n      }\n\n      result.iconHtml = icon.innerHTML;\n    }\n\n    return result;\n  };\n  /**\n   * @param {DocumentFragment} templateContent\n   */\n\n\n  const getSwalInput = templateContent => {\n    const result = {};\n    /** @type {HTMLElement} */\n\n    const input = templateContent.querySelector('swal-input');\n\n    if (input) {\n      showWarningsForAttributes(input, ['type', 'label', 'placeholder', 'value']);\n      result.input = input.getAttribute('type') || 'text';\n\n      if (input.hasAttribute('label')) {\n        result.inputLabel = input.getAttribute('label');\n      }\n\n      if (input.hasAttribute('placeholder')) {\n        result.inputPlaceholder = input.getAttribute('placeholder');\n      }\n\n      if (input.hasAttribute('value')) {\n        result.inputValue = input.getAttribute('value');\n      }\n    }\n\n    const inputOptions = templateContent.querySelectorAll('swal-input-option');\n\n    if (inputOptions.length) {\n      result.inputOptions = {};\n      toArray(inputOptions).forEach(option => {\n        showWarningsForAttributes(option, ['value']);\n        const optionValue = option.getAttribute('value');\n        const optionName = option.innerHTML;\n        result.inputOptions[optionValue] = optionName;\n      });\n    }\n\n    return result;\n  };\n  /**\n   * @param {DocumentFragment} templateContent\n   * @param {string[]} paramNames\n   */\n\n\n  const getSwalStringParams = (templateContent, paramNames) => {\n    const result = {};\n\n    for (const i in paramNames) {\n      const paramName = paramNames[i];\n      /** @type {HTMLElement} */\n\n      const tag = templateContent.querySelector(paramName);\n\n      if (tag) {\n        showWarningsForAttributes(tag, []);\n        result[paramName.replace(/^swal-/, '')] = tag.innerHTML.trim();\n      }\n    }\n\n    return result;\n  };\n  /**\n   * @param {DocumentFragment} templateContent\n   */\n\n\n  const showWarningsForElements = templateContent => {\n    const allowedElements = swalStringParams.concat(['swal-param', 'swal-button', 'swal-image', 'swal-icon', 'swal-input', 'swal-input-option']);\n    toArray(templateContent.children).forEach(el => {\n      const tagName = el.tagName.toLowerCase();\n\n      if (allowedElements.indexOf(tagName) === -1) {\n        warn(\"Unrecognized element <\".concat(tagName, \">\"));\n      }\n    });\n  };\n  /**\n   * @param {HTMLElement} el\n   * @param {string[]} allowedAttributes\n   */\n\n\n  const showWarningsForAttributes = (el, allowedAttributes) => {\n    toArray(el.attributes).forEach(attribute => {\n      if (allowedAttributes.indexOf(attribute.name) === -1) {\n        warn([\"Unrecognized attribute \\\"\".concat(attribute.name, \"\\\" on <\").concat(el.tagName.toLowerCase(), \">.\"), \"\".concat(allowedAttributes.length ? \"Allowed attributes are: \".concat(allowedAttributes.join(', ')) : 'To set the value, use HTML within the element.')]);\n      }\n    });\n  };\n\n  var defaultInputValidators = {\n    /**\n     * @param {string} string\n     * @param {string} validationMessage\n     * @returns {Promise<void | string>}\n     */\n    email: (string, validationMessage) => {\n      return /^[a-zA-Z0-9.+_-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z0-9-]{2,24}$/.test(string) ? Promise.resolve() : Promise.resolve(validationMessage || 'Invalid email address');\n    },\n\n    /**\n     * @param {string} string\n     * @param {string} validationMessage\n     * @returns {Promise<void | string>}\n     */\n    url: (string, validationMessage) => {\n      // taken from https://stackoverflow.com/a/3809435 with a small change from #1306 and #2013\n      return /^https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-z]{2,63}\\b([-a-zA-Z0-9@:%_+.~#?&/=]*)$/.test(string) ? Promise.resolve() : Promise.resolve(validationMessage || 'Invalid URL');\n    }\n  };\n\n  /**\n   * @param {SweetAlertOptions} params\n   */\n\n  function setDefaultInputValidators(params) {\n    // Use default `inputValidator` for supported input types if not provided\n    if (!params.inputValidator) {\n      Object.keys(defaultInputValidators).forEach(key => {\n        if (params.input === key) {\n          params.inputValidator = defaultInputValidators[key];\n        }\n      });\n    }\n  }\n  /**\n   * @param {SweetAlertOptions} params\n   */\n\n\n  function validateCustomTargetElement(params) {\n    // Determine if the custom target element is valid\n    if (!params.target || typeof params.target === 'string' && !document.querySelector(params.target) || typeof params.target !== 'string' && !params.target.appendChild) {\n      warn('Target parameter is not valid, defaulting to \"body\"');\n      params.target = 'body';\n    }\n  }\n  /**\n   * Set type, text and actions on popup\n   *\n   * @param {SweetAlertOptions} params\n   */\n\n\n  function setParameters(params) {\n    setDefaultInputValidators(params); // showLoaderOnConfirm && preConfirm\n\n    if (params.showLoaderOnConfirm && !params.preConfirm) {\n      warn('showLoaderOnConfirm is set to true, but preConfirm is not defined.\\n' + 'showLoaderOnConfirm should be used together with preConfirm, see usage example:\\n' + 'https://sweetalert2.github.io/#ajax-request');\n    }\n\n    validateCustomTargetElement(params); // Replace newlines with <br> in title\n\n    if (typeof params.title === 'string') {\n      params.title = params.title.split('\\n').join('<br />');\n    }\n\n    init(params);\n  }\n\n  class Timer {\n    constructor(callback, delay) {\n      this.callback = callback;\n      this.remaining = delay;\n      this.running = false;\n      this.start();\n    }\n\n    start() {\n      if (!this.running) {\n        this.running = true;\n        this.started = new Date();\n        this.id = setTimeout(this.callback, this.remaining);\n      }\n\n      return this.remaining;\n    }\n\n    stop() {\n      if (this.running) {\n        this.running = false;\n        clearTimeout(this.id);\n        this.remaining -= new Date().getTime() - this.started.getTime();\n      }\n\n      return this.remaining;\n    }\n\n    increase(n) {\n      const running = this.running;\n\n      if (running) {\n        this.stop();\n      }\n\n      this.remaining += n;\n\n      if (running) {\n        this.start();\n      }\n\n      return this.remaining;\n    }\n\n    getTimerLeft() {\n      if (this.running) {\n        this.stop();\n        this.start();\n      }\n\n      return this.remaining;\n    }\n\n    isRunning() {\n      return this.running;\n    }\n\n  }\n\n  const fixScrollbar = () => {\n    // for queues, do not do this more than once\n    if (states.previousBodyPadding !== null) {\n      return;\n    } // if the body has overflow\n\n\n    if (document.body.scrollHeight > window.innerHeight) {\n      // add padding so the content doesn't shift after removal of scrollbar\n      states.previousBodyPadding = parseInt(window.getComputedStyle(document.body).getPropertyValue('padding-right'));\n      document.body.style.paddingRight = \"\".concat(states.previousBodyPadding + measureScrollbar(), \"px\");\n    }\n  };\n  const undoScrollbar = () => {\n    if (states.previousBodyPadding !== null) {\n      document.body.style.paddingRight = \"\".concat(states.previousBodyPadding, \"px\");\n      states.previousBodyPadding = null;\n    }\n  };\n\n  /* istanbul ignore file */\n\n  const iOSfix = () => {\n    const iOS = // @ts-ignore\n    /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream || navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1;\n\n    if (iOS && !hasClass(document.body, swalClasses.iosfix)) {\n      const offset = document.body.scrollTop;\n      document.body.style.top = \"\".concat(offset * -1, \"px\");\n      addClass(document.body, swalClasses.iosfix);\n      lockBodyScroll();\n      addBottomPaddingForTallPopups();\n    }\n  };\n  /**\n   * https://github.com/sweetalert2/sweetalert2/issues/1948\n   */\n\n  const addBottomPaddingForTallPopups = () => {\n    const ua = navigator.userAgent;\n    const iOS = !!ua.match(/iPad/i) || !!ua.match(/iPhone/i);\n    const webkit = !!ua.match(/WebKit/i);\n    const iOSSafari = iOS && webkit && !ua.match(/CriOS/i);\n\n    if (iOSSafari) {\n      const bottomPanelHeight = 44;\n\n      if (getPopup().scrollHeight > window.innerHeight - bottomPanelHeight) {\n        getContainer().style.paddingBottom = \"\".concat(bottomPanelHeight, \"px\");\n      }\n    }\n  };\n  /**\n   * https://github.com/sweetalert2/sweetalert2/issues/1246\n   */\n\n\n  const lockBodyScroll = () => {\n    const container = getContainer();\n    let preventTouchMove;\n\n    container.ontouchstart = e => {\n      preventTouchMove = shouldPreventTouchMove(e);\n    };\n\n    container.ontouchmove = e => {\n      if (preventTouchMove) {\n        e.preventDefault();\n        e.stopPropagation();\n      }\n    };\n  };\n\n  const shouldPreventTouchMove = event => {\n    const target = event.target;\n    const container = getContainer();\n\n    if (isStylus(event) || isZoom(event)) {\n      return false;\n    }\n\n    if (target === container) {\n      return true;\n    }\n\n    if (!isScrollable(container) && target.tagName !== 'INPUT' && // #1603\n    target.tagName !== 'TEXTAREA' && // #2266\n    !(isScrollable(getHtmlContainer()) && // #1944\n    getHtmlContainer().contains(target))) {\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   * https://github.com/sweetalert2/sweetalert2/issues/1786\n   *\n   * @param {*} event\n   * @returns {boolean}\n   */\n\n\n  const isStylus = event => {\n    return event.touches && event.touches.length && event.touches[0].touchType === 'stylus';\n  };\n  /**\n   * https://github.com/sweetalert2/sweetalert2/issues/1891\n   *\n   * @param {TouchEvent} event\n   * @returns {boolean}\n   */\n\n\n  const isZoom = event => {\n    return event.touches && event.touches.length > 1;\n  };\n\n  const undoIOSfix = () => {\n    if (hasClass(document.body, swalClasses.iosfix)) {\n      const offset = parseInt(document.body.style.top, 10);\n      removeClass(document.body, swalClasses.iosfix);\n      document.body.style.top = '';\n      document.body.scrollTop = offset * -1;\n    }\n  };\n\n  const SHOW_CLASS_TIMEOUT = 10;\n  /**\n   * Open popup, add necessary classes and styles, fix scrollbar\n   *\n   * @param params\n   */\n\n  const openPopup = params => {\n    const container = getContainer();\n    const popup = getPopup();\n\n    if (typeof params.willOpen === 'function') {\n      params.willOpen(popup);\n    }\n\n    const bodyStyles = window.getComputedStyle(document.body);\n    const initialBodyOverflow = bodyStyles.overflowY;\n    addClasses$1(container, popup, params); // scrolling is 'hidden' until animation is done, after that 'auto'\n\n    setTimeout(() => {\n      setScrollingVisibility(container, popup);\n    }, SHOW_CLASS_TIMEOUT);\n\n    if (isModal()) {\n      fixScrollContainer(container, params.scrollbarPadding, initialBodyOverflow);\n      setAriaHidden();\n    }\n\n    if (!isToast() && !globalState.previousActiveElement) {\n      globalState.previousActiveElement = document.activeElement;\n    }\n\n    if (typeof params.didOpen === 'function') {\n      setTimeout(() => params.didOpen(popup));\n    }\n\n    removeClass(container, swalClasses['no-transition']);\n  };\n\n  const swalOpenAnimationFinished = event => {\n    const popup = getPopup();\n\n    if (event.target !== popup) {\n      return;\n    }\n\n    const container = getContainer();\n    popup.removeEventListener(animationEndEvent, swalOpenAnimationFinished);\n    container.style.overflowY = 'auto';\n  };\n\n  const setScrollingVisibility = (container, popup) => {\n    if (animationEndEvent && hasCssAnimation(popup)) {\n      container.style.overflowY = 'hidden';\n      popup.addEventListener(animationEndEvent, swalOpenAnimationFinished);\n    } else {\n      container.style.overflowY = 'auto';\n    }\n  };\n\n  const fixScrollContainer = (container, scrollbarPadding, initialBodyOverflow) => {\n    iOSfix();\n\n    if (scrollbarPadding && initialBodyOverflow !== 'hidden') {\n      fixScrollbar();\n    } // sweetalert2/issues/1247\n\n\n    setTimeout(() => {\n      container.scrollTop = 0;\n    });\n  };\n\n  const addClasses$1 = (container, popup, params) => {\n    addClass(container, params.showClass.backdrop); // this workaround with opacity is needed for https://github.com/sweetalert2/sweetalert2/issues/2059\n\n    popup.style.setProperty('opacity', '0', 'important');\n    show(popup, 'grid');\n    setTimeout(() => {\n      // Animate popup right after showing it\n      addClass(popup, params.showClass.popup); // and remove the opacity workaround\n\n      popup.style.removeProperty('opacity');\n    }, SHOW_CLASS_TIMEOUT); // 10ms in order to fix #2062\n\n    addClass([document.documentElement, document.body], swalClasses.shown);\n\n    if (params.heightAuto && params.backdrop && !params.toast) {\n      addClass([document.documentElement, document.body], swalClasses['height-auto']);\n    }\n  };\n\n  /**\n   * Shows loader (spinner), this is useful with AJAX requests.\n   * By default the loader be shown instead of the \"Confirm\" button.\n   */\n\n  const showLoading = buttonToReplace => {\n    let popup = getPopup();\n\n    if (!popup) {\n      new Swal(); // eslint-disable-line no-new\n    }\n\n    popup = getPopup();\n    const loader = getLoader();\n\n    if (isToast()) {\n      hide(getIcon());\n    } else {\n      replaceButton(popup, buttonToReplace);\n    }\n\n    show(loader);\n    popup.setAttribute('data-loading', 'true');\n    popup.setAttribute('aria-busy', 'true');\n    popup.focus();\n  };\n\n  const replaceButton = (popup, buttonToReplace) => {\n    const actions = getActions();\n    const loader = getLoader();\n\n    if (!buttonToReplace && isVisible(getConfirmButton())) {\n      buttonToReplace = getConfirmButton();\n    }\n\n    show(actions);\n\n    if (buttonToReplace) {\n      hide(buttonToReplace);\n      loader.setAttribute('data-button-to-replace', buttonToReplace.className);\n    }\n\n    loader.parentNode.insertBefore(loader, buttonToReplace);\n    addClass([popup, actions], swalClasses.loading);\n  };\n\n  const handleInputOptionsAndValue = (instance, params) => {\n    if (params.input === 'select' || params.input === 'radio') {\n      handleInputOptions(instance, params);\n    } else if (['text', 'email', 'number', 'tel', 'textarea'].includes(params.input) && (hasToPromiseFn(params.inputValue) || isPromise(params.inputValue))) {\n      showLoading(getConfirmButton());\n      handleInputValue(instance, params);\n    }\n  };\n  const getInputValue = (instance, innerParams) => {\n    const input = instance.getInput();\n\n    if (!input) {\n      return null;\n    }\n\n    switch (innerParams.input) {\n      case 'checkbox':\n        return getCheckboxValue(input);\n\n      case 'radio':\n        return getRadioValue(input);\n\n      case 'file':\n        return getFileValue(input);\n\n      default:\n        return innerParams.inputAutoTrim ? input.value.trim() : input.value;\n    }\n  };\n\n  const getCheckboxValue = input => input.checked ? 1 : 0;\n\n  const getRadioValue = input => input.checked ? input.value : null;\n\n  const getFileValue = input => input.files.length ? input.getAttribute('multiple') !== null ? input.files : input.files[0] : null;\n\n  const handleInputOptions = (instance, params) => {\n    const popup = getPopup();\n\n    const processInputOptions = inputOptions => populateInputOptions[params.input](popup, formatInputOptions(inputOptions), params);\n\n    if (hasToPromiseFn(params.inputOptions) || isPromise(params.inputOptions)) {\n      showLoading(getConfirmButton());\n      asPromise(params.inputOptions).then(inputOptions => {\n        instance.hideLoading();\n        processInputOptions(inputOptions);\n      });\n    } else if (typeof params.inputOptions === 'object') {\n      processInputOptions(params.inputOptions);\n    } else {\n      error(\"Unexpected type of inputOptions! Expected object, Map or Promise, got \".concat(typeof params.inputOptions));\n    }\n  };\n\n  const handleInputValue = (instance, params) => {\n    const input = instance.getInput();\n    hide(input);\n    asPromise(params.inputValue).then(inputValue => {\n      input.value = params.input === 'number' ? parseFloat(inputValue) || 0 : \"\".concat(inputValue);\n      show(input);\n      input.focus();\n      instance.hideLoading();\n    }).catch(err => {\n      error(\"Error in inputValue promise: \".concat(err));\n      input.value = '';\n      show(input);\n      input.focus();\n      instance.hideLoading();\n    });\n  };\n\n  const populateInputOptions = {\n    select: (popup, inputOptions, params) => {\n      const select = getDirectChildByClass(popup, swalClasses.select);\n\n      const renderOption = (parent, optionLabel, optionValue) => {\n        const option = document.createElement('option');\n        option.value = optionValue;\n        setInnerHtml(option, optionLabel);\n        option.selected = isSelected(optionValue, params.inputValue);\n        parent.appendChild(option);\n      };\n\n      inputOptions.forEach(inputOption => {\n        const optionValue = inputOption[0];\n        const optionLabel = inputOption[1]; // <optgroup> spec:\n        // https://www.w3.org/TR/html401/interact/forms.html#h-17.6\n        // \"...all OPTGROUP elements must be specified directly within a SELECT element (i.e., groups may not be nested)...\"\n        // check whether this is a <optgroup>\n\n        if (Array.isArray(optionLabel)) {\n          // if it is an array, then it is an <optgroup>\n          const optgroup = document.createElement('optgroup');\n          optgroup.label = optionValue;\n          optgroup.disabled = false; // not configurable for now\n\n          select.appendChild(optgroup);\n          optionLabel.forEach(o => renderOption(optgroup, o[1], o[0]));\n        } else {\n          // case of <option>\n          renderOption(select, optionLabel, optionValue);\n        }\n      });\n      select.focus();\n    },\n    radio: (popup, inputOptions, params) => {\n      const radio = getDirectChildByClass(popup, swalClasses.radio);\n      inputOptions.forEach(inputOption => {\n        const radioValue = inputOption[0];\n        const radioLabel = inputOption[1];\n        const radioInput = document.createElement('input');\n        const radioLabelElement = document.createElement('label');\n        radioInput.type = 'radio';\n        radioInput.name = swalClasses.radio;\n        radioInput.value = radioValue;\n\n        if (isSelected(radioValue, params.inputValue)) {\n          radioInput.checked = true;\n        }\n\n        const label = document.createElement('span');\n        setInnerHtml(label, radioLabel);\n        label.className = swalClasses.label;\n        radioLabelElement.appendChild(radioInput);\n        radioLabelElement.appendChild(label);\n        radio.appendChild(radioLabelElement);\n      });\n      const radios = radio.querySelectorAll('input');\n\n      if (radios.length) {\n        radios[0].focus();\n      }\n    }\n  };\n  /**\n   * Converts `inputOptions` into an array of `[value, label]`s\n   * @param inputOptions\n   */\n\n  const formatInputOptions = inputOptions => {\n    const result = [];\n\n    if (typeof Map !== 'undefined' && inputOptions instanceof Map) {\n      inputOptions.forEach((value, key) => {\n        let valueFormatted = value;\n\n        if (typeof valueFormatted === 'object') {\n          // case of <optgroup>\n          valueFormatted = formatInputOptions(valueFormatted);\n        }\n\n        result.push([key, valueFormatted]);\n      });\n    } else {\n      Object.keys(inputOptions).forEach(key => {\n        let valueFormatted = inputOptions[key];\n\n        if (typeof valueFormatted === 'object') {\n          // case of <optgroup>\n          valueFormatted = formatInputOptions(valueFormatted);\n        }\n\n        result.push([key, valueFormatted]);\n      });\n    }\n\n    return result;\n  };\n\n  const isSelected = (optionValue, inputValue) => {\n    return inputValue && inputValue.toString() === optionValue.toString();\n  };\n\n  /**\n   * Hides loader and shows back the button which was hidden by .showLoading()\n   */\n\n  function hideLoading() {\n    // do nothing if popup is closed\n    const innerParams = privateProps.innerParams.get(this);\n\n    if (!innerParams) {\n      return;\n    }\n\n    const domCache = privateProps.domCache.get(this);\n    hide(domCache.loader);\n\n    if (isToast()) {\n      if (innerParams.icon) {\n        show(getIcon());\n      }\n    } else {\n      showRelatedButton(domCache);\n    }\n\n    removeClass([domCache.popup, domCache.actions], swalClasses.loading);\n    domCache.popup.removeAttribute('aria-busy');\n    domCache.popup.removeAttribute('data-loading');\n    domCache.confirmButton.disabled = false;\n    domCache.denyButton.disabled = false;\n    domCache.cancelButton.disabled = false;\n  }\n\n  const showRelatedButton = domCache => {\n    const buttonToReplace = domCache.popup.getElementsByClassName(domCache.loader.getAttribute('data-button-to-replace'));\n\n    if (buttonToReplace.length) {\n      show(buttonToReplace[0], 'inline-block');\n    } else if (allButtonsAreHidden()) {\n      hide(domCache.actions);\n    }\n  };\n\n  /**\n   * Gets the input DOM node, this method works with input parameter.\n   * @returns {HTMLElement | null}\n   */\n\n  function getInput$1(instance) {\n    const innerParams = privateProps.innerParams.get(instance || this);\n    const domCache = privateProps.domCache.get(instance || this);\n\n    if (!domCache) {\n      return null;\n    }\n\n    return getInput(domCache.popup, innerParams.input);\n  }\n\n  /**\n   * This module contains `WeakMap`s for each effectively-\"private  property\" that a `Swal` has.\n   * For example, to set the private property \"foo\" of `this` to \"bar\", you can `privateProps.foo.set(this, 'bar')`\n   * This is the approach that Babel will probably take to implement private methods/fields\n   *   https://github.com/tc39/proposal-private-methods\n   *   https://github.com/babel/babel/pull/7555\n   * Once we have the changes from that PR in Babel, and our core class fits reasonable in *one module*\n   *   then we can use that language feature.\n   */\n  var privateMethods = {\n    swalPromiseResolve: new WeakMap(),\n    swalPromiseReject: new WeakMap()\n  };\n\n  /*\n   * Global function to determine if SweetAlert2 popup is shown\n   */\n\n  const isVisible$1 = () => {\n    return isVisible(getPopup());\n  };\n  /*\n   * Global function to click 'Confirm' button\n   */\n\n  const clickConfirm = () => getConfirmButton() && getConfirmButton().click();\n  /*\n   * Global function to click 'Deny' button\n   */\n\n  const clickDeny = () => getDenyButton() && getDenyButton().click();\n  /*\n   * Global function to click 'Cancel' button\n   */\n\n  const clickCancel = () => getCancelButton() && getCancelButton().click();\n\n  /**\n   * @param {GlobalState} globalState\n   */\n\n  const removeKeydownHandler = globalState => {\n    if (globalState.keydownTarget && globalState.keydownHandlerAdded) {\n      globalState.keydownTarget.removeEventListener('keydown', globalState.keydownHandler, {\n        capture: globalState.keydownListenerCapture\n      });\n      globalState.keydownHandlerAdded = false;\n    }\n  };\n  /**\n   * @param {SweetAlert2} instance\n   * @param {GlobalState} globalState\n   * @param {SweetAlertOptions} innerParams\n   * @param {*} dismissWith\n   */\n\n  const addKeydownHandler = (instance, globalState, innerParams, dismissWith) => {\n    removeKeydownHandler(globalState);\n\n    if (!innerParams.toast) {\n      globalState.keydownHandler = e => keydownHandler(instance, e, dismissWith);\n\n      globalState.keydownTarget = innerParams.keydownListenerCapture ? window : getPopup();\n      globalState.keydownListenerCapture = innerParams.keydownListenerCapture;\n      globalState.keydownTarget.addEventListener('keydown', globalState.keydownHandler, {\n        capture: globalState.keydownListenerCapture\n      });\n      globalState.keydownHandlerAdded = true;\n    }\n  };\n  /**\n   * @param {SweetAlertOptions} innerParams\n   * @param {number} index\n   * @param {number} increment\n   */\n\n  const setFocus = (innerParams, index, increment) => {\n    const focusableElements = getFocusableElements(); // search for visible elements and select the next possible match\n\n    if (focusableElements.length) {\n      index = index + increment; // rollover to first item\n\n      if (index === focusableElements.length) {\n        index = 0; // go to last item\n      } else if (index === -1) {\n        index = focusableElements.length - 1;\n      }\n\n      return focusableElements[index].focus();\n    } // no visible focusable elements, focus the popup\n\n\n    getPopup().focus();\n  };\n  const arrowKeysNextButton = ['ArrowRight', 'ArrowDown'];\n  const arrowKeysPreviousButton = ['ArrowLeft', 'ArrowUp'];\n  /**\n   * @param {SweetAlert2} instance\n   * @param {KeyboardEvent} e\n   * @param {function} dismissWith\n   */\n\n  const keydownHandler = (instance, e, dismissWith) => {\n    const innerParams = privateProps.innerParams.get(instance);\n\n    if (!innerParams) {\n      return; // This instance has already been destroyed\n    } // Ignore keydown during IME composition\n    // https://developer.mozilla.org/en-US/docs/Web/API/Document/keydown_event#ignoring_keydown_during_ime_composition\n    // https://github.com/sweetalert2/sweetalert2/issues/720\n    // https://github.com/sweetalert2/sweetalert2/issues/2406\n\n\n    if (e.isComposing || e.keyCode === 229) {\n      return;\n    }\n\n    if (innerParams.stopKeydownPropagation) {\n      e.stopPropagation();\n    } // ENTER\n\n\n    if (e.key === 'Enter') {\n      handleEnter(instance, e, innerParams);\n    } // TAB\n    else if (e.key === 'Tab') {\n      handleTab(e, innerParams);\n    } // ARROWS - switch focus between buttons\n    else if ([...arrowKeysNextButton, ...arrowKeysPreviousButton].includes(e.key)) {\n      handleArrows(e.key);\n    } // ESC\n    else if (e.key === 'Escape') {\n      handleEsc(e, innerParams, dismissWith);\n    }\n  };\n  /**\n   * @param {SweetAlert2} instance\n   * @param {KeyboardEvent} e\n   * @param {SweetAlertOptions} innerParams\n   */\n\n\n  const handleEnter = (instance, e, innerParams) => {\n    // https://github.com/sweetalert2/sweetalert2/issues/2386\n    if (!callIfFunction(innerParams.allowEnterKey)) {\n      return;\n    }\n\n    if (e.target && instance.getInput() && e.target instanceof HTMLElement && e.target.outerHTML === instance.getInput().outerHTML) {\n      if (['textarea', 'file'].includes(innerParams.input)) {\n        return; // do not submit\n      }\n\n      clickConfirm();\n      e.preventDefault();\n    }\n  };\n  /**\n   * @param {KeyboardEvent} e\n   * @param {SweetAlertOptions} innerParams\n   */\n\n\n  const handleTab = (e, innerParams) => {\n    const targetElement = e.target;\n    const focusableElements = getFocusableElements();\n    let btnIndex = -1;\n\n    for (let i = 0; i < focusableElements.length; i++) {\n      if (targetElement === focusableElements[i]) {\n        btnIndex = i;\n        break;\n      }\n    } // Cycle to the next button\n\n\n    if (!e.shiftKey) {\n      setFocus(innerParams, btnIndex, 1);\n    } // Cycle to the prev button\n    else {\n      setFocus(innerParams, btnIndex, -1);\n    }\n\n    e.stopPropagation();\n    e.preventDefault();\n  };\n  /**\n   * @param {string} key\n   */\n\n\n  const handleArrows = key => {\n    const confirmButton = getConfirmButton();\n    const denyButton = getDenyButton();\n    const cancelButton = getCancelButton();\n\n    if (document.activeElement instanceof HTMLElement && ![confirmButton, denyButton, cancelButton].includes(document.activeElement)) {\n      return;\n    }\n\n    const sibling = arrowKeysNextButton.includes(key) ? 'nextElementSibling' : 'previousElementSibling';\n    let buttonToFocus = document.activeElement;\n\n    for (let i = 0; i < getActions().children.length; i++) {\n      buttonToFocus = buttonToFocus[sibling];\n\n      if (!buttonToFocus) {\n        return;\n      }\n\n      if (buttonToFocus instanceof HTMLButtonElement && isVisible(buttonToFocus)) {\n        break;\n      }\n    }\n\n    if (buttonToFocus instanceof HTMLButtonElement) {\n      buttonToFocus.focus();\n    }\n  };\n  /**\n   * @param {KeyboardEvent} e\n   * @param {SweetAlertOptions} innerParams\n   * @param {function} dismissWith\n   */\n\n\n  const handleEsc = (e, innerParams, dismissWith) => {\n    if (callIfFunction(innerParams.allowEscapeKey)) {\n      e.preventDefault();\n      dismissWith(DismissReason.esc);\n    }\n  };\n\n  /*\n   * Instance method to close sweetAlert\n   */\n\n  function removePopupAndResetState(instance, container, returnFocus, didClose) {\n    if (isToast()) {\n      triggerDidCloseAndDispose(instance, didClose);\n    } else {\n      restoreActiveElement(returnFocus).then(() => triggerDidCloseAndDispose(instance, didClose));\n      removeKeydownHandler(globalState);\n    }\n\n    const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent); // workaround for #2088\n    // for some reason removing the container in Safari will scroll the document to bottom\n\n    if (isSafari) {\n      container.setAttribute('style', 'display:none !important');\n      container.removeAttribute('class');\n      container.innerHTML = '';\n    } else {\n      container.remove();\n    }\n\n    if (isModal()) {\n      undoScrollbar();\n      undoIOSfix();\n      unsetAriaHidden();\n    }\n\n    removeBodyClasses();\n  }\n\n  function removeBodyClasses() {\n    removeClass([document.documentElement, document.body], [swalClasses.shown, swalClasses['height-auto'], swalClasses['no-backdrop'], swalClasses['toast-shown']]);\n  }\n\n  function close(resolveValue) {\n    resolveValue = prepareResolveValue(resolveValue);\n    const swalPromiseResolve = privateMethods.swalPromiseResolve.get(this);\n    const didClose = triggerClosePopup(this);\n\n    if (this.isAwaitingPromise()) {\n      // A swal awaiting for a promise (after a click on Confirm or Deny) cannot be dismissed anymore #2335\n      if (!resolveValue.isDismissed) {\n        handleAwaitingPromise(this);\n        swalPromiseResolve(resolveValue);\n      }\n    } else if (didClose) {\n      // Resolve Swal promise\n      swalPromiseResolve(resolveValue);\n    }\n  }\n  function isAwaitingPromise() {\n    return !!privateProps.awaitingPromise.get(this);\n  }\n\n  const triggerClosePopup = instance => {\n    const popup = getPopup();\n\n    if (!popup) {\n      return false;\n    }\n\n    const innerParams = privateProps.innerParams.get(instance);\n\n    if (!innerParams || hasClass(popup, innerParams.hideClass.popup)) {\n      return false;\n    }\n\n    removeClass(popup, innerParams.showClass.popup);\n    addClass(popup, innerParams.hideClass.popup);\n    const backdrop = getContainer();\n    removeClass(backdrop, innerParams.showClass.backdrop);\n    addClass(backdrop, innerParams.hideClass.backdrop);\n    handlePopupAnimation(instance, popup, innerParams);\n    return true;\n  };\n\n  function rejectPromise(error) {\n    const rejectPromise = privateMethods.swalPromiseReject.get(this);\n    handleAwaitingPromise(this);\n\n    if (rejectPromise) {\n      // Reject Swal promise\n      rejectPromise(error);\n    }\n  }\n  const handleAwaitingPromise = instance => {\n    if (instance.isAwaitingPromise()) {\n      privateProps.awaitingPromise.delete(instance); // The instance might have been previously partly destroyed, we must resume the destroy process in this case #2335\n\n      if (!privateProps.innerParams.get(instance)) {\n        instance._destroy();\n      }\n    }\n  };\n\n  const prepareResolveValue = resolveValue => {\n    // When user calls Swal.close()\n    if (typeof resolveValue === 'undefined') {\n      return {\n        isConfirmed: false,\n        isDenied: false,\n        isDismissed: true\n      };\n    }\n\n    return Object.assign({\n      isConfirmed: false,\n      isDenied: false,\n      isDismissed: false\n    }, resolveValue);\n  };\n\n  const handlePopupAnimation = (instance, popup, innerParams) => {\n    const container = getContainer(); // If animation is supported, animate\n\n    const animationIsSupported = animationEndEvent && hasCssAnimation(popup);\n\n    if (typeof innerParams.willClose === 'function') {\n      innerParams.willClose(popup);\n    }\n\n    if (animationIsSupported) {\n      animatePopup(instance, popup, container, innerParams.returnFocus, innerParams.didClose);\n    } else {\n      // Otherwise, remove immediately\n      removePopupAndResetState(instance, container, innerParams.returnFocus, innerParams.didClose);\n    }\n  };\n\n  const animatePopup = (instance, popup, container, returnFocus, didClose) => {\n    globalState.swalCloseEventFinishedCallback = removePopupAndResetState.bind(null, instance, container, returnFocus, didClose);\n    popup.addEventListener(animationEndEvent, function (e) {\n      if (e.target === popup) {\n        globalState.swalCloseEventFinishedCallback();\n        delete globalState.swalCloseEventFinishedCallback;\n      }\n    });\n  };\n\n  const triggerDidCloseAndDispose = (instance, didClose) => {\n    setTimeout(() => {\n      if (typeof didClose === 'function') {\n        didClose.bind(instance.params)();\n      }\n\n      instance._destroy();\n    });\n  };\n\n  function setButtonsDisabled(instance, buttons, disabled) {\n    const domCache = privateProps.domCache.get(instance);\n    buttons.forEach(button => {\n      domCache[button].disabled = disabled;\n    });\n  }\n\n  function setInputDisabled(input, disabled) {\n    if (!input) {\n      return false;\n    }\n\n    if (input.type === 'radio') {\n      const radiosContainer = input.parentNode.parentNode;\n      const radios = radiosContainer.querySelectorAll('input');\n\n      for (let i = 0; i < radios.length; i++) {\n        radios[i].disabled = disabled;\n      }\n    } else {\n      input.disabled = disabled;\n    }\n  }\n\n  function enableButtons() {\n    setButtonsDisabled(this, ['confirmButton', 'denyButton', 'cancelButton'], false);\n  }\n  function disableButtons() {\n    setButtonsDisabled(this, ['confirmButton', 'denyButton', 'cancelButton'], true);\n  }\n  function enableInput() {\n    return setInputDisabled(this.getInput(), false);\n  }\n  function disableInput() {\n    return setInputDisabled(this.getInput(), true);\n  }\n\n  function showValidationMessage(error) {\n    const domCache = privateProps.domCache.get(this);\n    const params = privateProps.innerParams.get(this);\n    setInnerHtml(domCache.validationMessage, error);\n    domCache.validationMessage.className = swalClasses['validation-message'];\n\n    if (params.customClass && params.customClass.validationMessage) {\n      addClass(domCache.validationMessage, params.customClass.validationMessage);\n    }\n\n    show(domCache.validationMessage);\n    const input = this.getInput();\n\n    if (input) {\n      input.setAttribute('aria-invalid', true);\n      input.setAttribute('aria-describedby', swalClasses['validation-message']);\n      focusInput(input);\n      addClass(input, swalClasses.inputerror);\n    }\n  } // Hide block with validation message\n\n  function resetValidationMessage$1() {\n    const domCache = privateProps.domCache.get(this);\n\n    if (domCache.validationMessage) {\n      hide(domCache.validationMessage);\n    }\n\n    const input = this.getInput();\n\n    if (input) {\n      input.removeAttribute('aria-invalid');\n      input.removeAttribute('aria-describedby');\n      removeClass(input, swalClasses.inputerror);\n    }\n  }\n\n  function getProgressSteps$1() {\n    const domCache = privateProps.domCache.get(this);\n    return domCache.progressSteps;\n  }\n\n  /**\n   * Updates popup parameters.\n   */\n\n  function update(params) {\n    const popup = getPopup();\n    const innerParams = privateProps.innerParams.get(this);\n\n    if (!popup || hasClass(popup, innerParams.hideClass.popup)) {\n      return warn(\"You're trying to update the closed or closing popup, that won't work. Use the update() method in preConfirm parameter or show a new popup.\");\n    }\n\n    const validUpdatableParams = filterValidParams(params);\n    const updatedParams = Object.assign({}, innerParams, validUpdatableParams);\n    render(this, updatedParams);\n    privateProps.innerParams.set(this, updatedParams);\n    Object.defineProperties(this, {\n      params: {\n        value: Object.assign({}, this.params, params),\n        writable: false,\n        enumerable: true\n      }\n    });\n  }\n\n  const filterValidParams = params => {\n    const validUpdatableParams = {};\n    Object.keys(params).forEach(param => {\n      if (isUpdatableParameter(param)) {\n        validUpdatableParams[param] = params[param];\n      } else {\n        warn(\"Invalid parameter to update: \".concat(param));\n      }\n    });\n    return validUpdatableParams;\n  };\n\n  function _destroy() {\n    const domCache = privateProps.domCache.get(this);\n    const innerParams = privateProps.innerParams.get(this);\n\n    if (!innerParams) {\n      disposeWeakMaps(this); // The WeakMaps might have been partly destroyed, we must recall it to dispose any remaining WeakMaps #2335\n\n      return; // This instance has already been destroyed\n    } // Check if there is another Swal closing\n\n\n    if (domCache.popup && globalState.swalCloseEventFinishedCallback) {\n      globalState.swalCloseEventFinishedCallback();\n      delete globalState.swalCloseEventFinishedCallback;\n    }\n\n    if (typeof innerParams.didDestroy === 'function') {\n      innerParams.didDestroy();\n    }\n\n    disposeSwal(this);\n  }\n  /**\n   * @param {SweetAlert2} instance\n   */\n\n  const disposeSwal = instance => {\n    disposeWeakMaps(instance); // Unset this.params so GC will dispose it (#1569)\n    // @ts-ignore\n\n    delete instance.params; // Unset globalState props so GC will dispose globalState (#1569)\n\n    delete globalState.keydownHandler;\n    delete globalState.keydownTarget; // Unset currentInstance\n\n    delete globalState.currentInstance;\n  };\n  /**\n   * @param {SweetAlert2} instance\n   */\n\n\n  const disposeWeakMaps = instance => {\n    // If the current instance is awaiting a promise result, we keep the privateMethods to call them once the promise result is retrieved #2335\n    // @ts-ignore\n    if (instance.isAwaitingPromise()) {\n      unsetWeakMaps(privateProps, instance);\n      privateProps.awaitingPromise.set(instance, true);\n    } else {\n      unsetWeakMaps(privateMethods, instance);\n      unsetWeakMaps(privateProps, instance);\n    }\n  };\n  /**\n   * @param {object} obj\n   * @param {SweetAlert2} instance\n   */\n\n\n  const unsetWeakMaps = (obj, instance) => {\n    for (const i in obj) {\n      obj[i].delete(instance);\n    }\n  };\n\n\n\n  var instanceMethods = /*#__PURE__*/Object.freeze({\n    hideLoading: hideLoading,\n    disableLoading: hideLoading,\n    getInput: getInput$1,\n    close: close,\n    isAwaitingPromise: isAwaitingPromise,\n    rejectPromise: rejectPromise,\n    handleAwaitingPromise: handleAwaitingPromise,\n    closePopup: close,\n    closeModal: close,\n    closeToast: close,\n    enableButtons: enableButtons,\n    disableButtons: disableButtons,\n    enableInput: enableInput,\n    disableInput: disableInput,\n    showValidationMessage: showValidationMessage,\n    resetValidationMessage: resetValidationMessage$1,\n    getProgressSteps: getProgressSteps$1,\n    update: update,\n    _destroy: _destroy\n  });\n\n  const handleConfirmButtonClick = instance => {\n    const innerParams = privateProps.innerParams.get(instance);\n    instance.disableButtons();\n\n    if (innerParams.input) {\n      handleConfirmOrDenyWithInput(instance, 'confirm');\n    } else {\n      confirm(instance, true);\n    }\n  };\n  const handleDenyButtonClick = instance => {\n    const innerParams = privateProps.innerParams.get(instance);\n    instance.disableButtons();\n\n    if (innerParams.returnInputValueOnDeny) {\n      handleConfirmOrDenyWithInput(instance, 'deny');\n    } else {\n      deny(instance, false);\n    }\n  };\n  const handleCancelButtonClick = (instance, dismissWith) => {\n    instance.disableButtons();\n    dismissWith(DismissReason.cancel);\n  };\n\n  const handleConfirmOrDenyWithInput = (instance, type\n  /* 'confirm' | 'deny' */\n  ) => {\n    const innerParams = privateProps.innerParams.get(instance);\n\n    if (!innerParams.input) {\n      return error(\"The \\\"input\\\" parameter is needed to be set when using returnInputValueOn\".concat(capitalizeFirstLetter(type)));\n    }\n\n    const inputValue = getInputValue(instance, innerParams);\n\n    if (innerParams.inputValidator) {\n      handleInputValidator(instance, inputValue, type);\n    } else if (!instance.getInput().checkValidity()) {\n      instance.enableButtons();\n      instance.showValidationMessage(innerParams.validationMessage);\n    } else if (type === 'deny') {\n      deny(instance, inputValue);\n    } else {\n      confirm(instance, inputValue);\n    }\n  };\n\n  const handleInputValidator = (instance, inputValue, type\n  /* 'confirm' | 'deny' */\n  ) => {\n    const innerParams = privateProps.innerParams.get(instance);\n    instance.disableInput();\n    const validationPromise = Promise.resolve().then(() => asPromise(innerParams.inputValidator(inputValue, innerParams.validationMessage)));\n    validationPromise.then(validationMessage => {\n      instance.enableButtons();\n      instance.enableInput();\n\n      if (validationMessage) {\n        instance.showValidationMessage(validationMessage);\n      } else if (type === 'deny') {\n        deny(instance, inputValue);\n      } else {\n        confirm(instance, inputValue);\n      }\n    });\n  };\n\n  const deny = (instance, value) => {\n    const innerParams = privateProps.innerParams.get(instance || undefined);\n\n    if (innerParams.showLoaderOnDeny) {\n      showLoading(getDenyButton());\n    }\n\n    if (innerParams.preDeny) {\n      privateProps.awaitingPromise.set(instance || undefined, true); // Flagging the instance as awaiting a promise so it's own promise's reject/resolve methods doesn't get destroyed until the result from this preDeny's promise is received\n\n      const preDenyPromise = Promise.resolve().then(() => asPromise(innerParams.preDeny(value, innerParams.validationMessage)));\n      preDenyPromise.then(preDenyValue => {\n        if (preDenyValue === false) {\n          instance.hideLoading();\n          handleAwaitingPromise(instance);\n        } else {\n          instance.closePopup({\n            isDenied: true,\n            value: typeof preDenyValue === 'undefined' ? value : preDenyValue\n          });\n        }\n      }).catch(error$$1 => rejectWith(instance || undefined, error$$1));\n    } else {\n      instance.closePopup({\n        isDenied: true,\n        value\n      });\n    }\n  };\n\n  const succeedWith = (instance, value) => {\n    instance.closePopup({\n      isConfirmed: true,\n      value\n    });\n  };\n\n  const rejectWith = (instance, error$$1) => {\n    instance.rejectPromise(error$$1);\n  };\n\n  const confirm = (instance, value) => {\n    const innerParams = privateProps.innerParams.get(instance || undefined);\n\n    if (innerParams.showLoaderOnConfirm) {\n      showLoading();\n    }\n\n    if (innerParams.preConfirm) {\n      instance.resetValidationMessage();\n      privateProps.awaitingPromise.set(instance || undefined, true); // Flagging the instance as awaiting a promise so it's own promise's reject/resolve methods doesn't get destroyed until the result from this preConfirm's promise is received\n\n      const preConfirmPromise = Promise.resolve().then(() => asPromise(innerParams.preConfirm(value, innerParams.validationMessage)));\n      preConfirmPromise.then(preConfirmValue => {\n        if (isVisible(getValidationMessage()) || preConfirmValue === false) {\n          instance.hideLoading();\n          handleAwaitingPromise(instance);\n        } else {\n          succeedWith(instance, typeof preConfirmValue === 'undefined' ? value : preConfirmValue);\n        }\n      }).catch(error$$1 => rejectWith(instance || undefined, error$$1));\n    } else {\n      succeedWith(instance, value);\n    }\n  };\n\n  const handlePopupClick = (instance, domCache, dismissWith) => {\n    const innerParams = privateProps.innerParams.get(instance);\n\n    if (innerParams.toast) {\n      handleToastClick(instance, domCache, dismissWith);\n    } else {\n      // Ignore click events that had mousedown on the popup but mouseup on the container\n      // This can happen when the user drags a slider\n      handleModalMousedown(domCache); // Ignore click events that had mousedown on the container but mouseup on the popup\n\n      handleContainerMousedown(domCache);\n      handleModalClick(instance, domCache, dismissWith);\n    }\n  };\n\n  const handleToastClick = (instance, domCache, dismissWith) => {\n    // Closing toast by internal click\n    domCache.popup.onclick = () => {\n      const innerParams = privateProps.innerParams.get(instance);\n\n      if (innerParams && (isAnyButtonShown(innerParams) || innerParams.timer || innerParams.input)) {\n        return;\n      }\n\n      dismissWith(DismissReason.close);\n    };\n  };\n  /**\n   * @param {*} innerParams\n   * @returns {boolean}\n   */\n\n\n  const isAnyButtonShown = innerParams => {\n    return innerParams.showConfirmButton || innerParams.showDenyButton || innerParams.showCancelButton || innerParams.showCloseButton;\n  };\n\n  let ignoreOutsideClick = false;\n\n  const handleModalMousedown = domCache => {\n    domCache.popup.onmousedown = () => {\n      domCache.container.onmouseup = function (e) {\n        domCache.container.onmouseup = undefined; // We only check if the mouseup target is the container because usually it doesn't\n        // have any other direct children aside of the popup\n\n        if (e.target === domCache.container) {\n          ignoreOutsideClick = true;\n        }\n      };\n    };\n  };\n\n  const handleContainerMousedown = domCache => {\n    domCache.container.onmousedown = () => {\n      domCache.popup.onmouseup = function (e) {\n        domCache.popup.onmouseup = undefined; // We also need to check if the mouseup target is a child of the popup\n\n        if (e.target === domCache.popup || domCache.popup.contains(e.target)) {\n          ignoreOutsideClick = true;\n        }\n      };\n    };\n  };\n\n  const handleModalClick = (instance, domCache, dismissWith) => {\n    domCache.container.onclick = e => {\n      const innerParams = privateProps.innerParams.get(instance);\n\n      if (ignoreOutsideClick) {\n        ignoreOutsideClick = false;\n        return;\n      }\n\n      if (e.target === domCache.container && callIfFunction(innerParams.allowOutsideClick)) {\n        dismissWith(DismissReason.backdrop);\n      }\n    };\n  };\n\n  const isJqueryElement = elem => typeof elem === 'object' && elem.jquery;\n\n  const isElement = elem => elem instanceof Element || isJqueryElement(elem);\n\n  const argsToParams = args => {\n    const params = {};\n\n    if (typeof args[0] === 'object' && !isElement(args[0])) {\n      Object.assign(params, args[0]);\n    } else {\n      ['title', 'html', 'icon'].forEach((name, index) => {\n        const arg = args[index];\n\n        if (typeof arg === 'string' || isElement(arg)) {\n          params[name] = arg;\n        } else if (arg !== undefined) {\n          error(\"Unexpected type of \".concat(name, \"! Expected \\\"string\\\" or \\\"Element\\\", got \").concat(typeof arg));\n        }\n      });\n    }\n\n    return params;\n  };\n\n  function fire() {\n    const Swal = this; // eslint-disable-line @typescript-eslint/no-this-alias\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return new Swal(...args);\n  }\n\n  /**\n   * Returns an extended version of `Swal` containing `params` as defaults.\n   * Useful for reusing Swal configuration.\n   *\n   * For example:\n   *\n   * Before:\n   * const textPromptOptions = { input: 'text', showCancelButton: true }\n   * const {value: firstName} = await Swal.fire({ ...textPromptOptions, title: 'What is your first name?' })\n   * const {value: lastName} = await Swal.fire({ ...textPromptOptions, title: 'What is your last name?' })\n   *\n   * After:\n   * const TextPrompt = Swal.mixin({ input: 'text', showCancelButton: true })\n   * const {value: firstName} = await TextPrompt('What is your first name?')\n   * const {value: lastName} = await TextPrompt('What is your last name?')\n   *\n   * @param mixinParams\n   */\n  function mixin(mixinParams) {\n    class MixinSwal extends this {\n      _main(params, priorityMixinParams) {\n        return super._main(params, Object.assign({}, mixinParams, priorityMixinParams));\n      }\n\n    }\n\n    return MixinSwal;\n  }\n\n  /**\n   * If `timer` parameter is set, returns number of milliseconds of timer remained.\n   * Otherwise, returns undefined.\n   */\n\n  const getTimerLeft = () => {\n    return globalState.timeout && globalState.timeout.getTimerLeft();\n  };\n  /**\n   * Stop timer. Returns number of milliseconds of timer remained.\n   * If `timer` parameter isn't set, returns undefined.\n   */\n\n  const stopTimer = () => {\n    if (globalState.timeout) {\n      stopTimerProgressBar();\n      return globalState.timeout.stop();\n    }\n  };\n  /**\n   * Resume timer. Returns number of milliseconds of timer remained.\n   * If `timer` parameter isn't set, returns undefined.\n   */\n\n  const resumeTimer = () => {\n    if (globalState.timeout) {\n      const remaining = globalState.timeout.start();\n      animateTimerProgressBar(remaining);\n      return remaining;\n    }\n  };\n  /**\n   * Resume timer. Returns number of milliseconds of timer remained.\n   * If `timer` parameter isn't set, returns undefined.\n   */\n\n  const toggleTimer = () => {\n    const timer = globalState.timeout;\n    return timer && (timer.running ? stopTimer() : resumeTimer());\n  };\n  /**\n   * Increase timer. Returns number of milliseconds of an updated timer.\n   * If `timer` parameter isn't set, returns undefined.\n   */\n\n  const increaseTimer = n => {\n    if (globalState.timeout) {\n      const remaining = globalState.timeout.increase(n);\n      animateTimerProgressBar(remaining, true);\n      return remaining;\n    }\n  };\n  /**\n   * Check if timer is running. Returns true if timer is running\n   * or false if timer is paused or stopped.\n   * If `timer` parameter isn't set, returns undefined\n   */\n\n  const isTimerRunning = () => {\n    return globalState.timeout && globalState.timeout.isRunning();\n  };\n\n  let bodyClickListenerAdded = false;\n  const clickHandlers = {};\n  function bindClickHandler() {\n    let attr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'data-swal-template';\n    clickHandlers[attr] = this;\n\n    if (!bodyClickListenerAdded) {\n      document.body.addEventListener('click', bodyClickListener);\n      bodyClickListenerAdded = true;\n    }\n  }\n\n  const bodyClickListener = event => {\n    for (let el = event.target; el && el !== document; el = el.parentNode) {\n      for (const attr in clickHandlers) {\n        const template = el.getAttribute(attr);\n\n        if (template) {\n          clickHandlers[attr].fire({\n            template\n          });\n          return;\n        }\n      }\n    }\n  };\n\n\n\n  var staticMethods = /*#__PURE__*/Object.freeze({\n    isValidParameter: isValidParameter,\n    isUpdatableParameter: isUpdatableParameter,\n    isDeprecatedParameter: isDeprecatedParameter,\n    argsToParams: argsToParams,\n    isVisible: isVisible$1,\n    clickConfirm: clickConfirm,\n    clickDeny: clickDeny,\n    clickCancel: clickCancel,\n    getContainer: getContainer,\n    getPopup: getPopup,\n    getTitle: getTitle,\n    getHtmlContainer: getHtmlContainer,\n    getImage: getImage,\n    getIcon: getIcon,\n    getInputLabel: getInputLabel,\n    getCloseButton: getCloseButton,\n    getActions: getActions,\n    getConfirmButton: getConfirmButton,\n    getDenyButton: getDenyButton,\n    getCancelButton: getCancelButton,\n    getLoader: getLoader,\n    getFooter: getFooter,\n    getTimerProgressBar: getTimerProgressBar,\n    getFocusableElements: getFocusableElements,\n    getValidationMessage: getValidationMessage,\n    isLoading: isLoading,\n    fire: fire,\n    mixin: mixin,\n    showLoading: showLoading,\n    enableLoading: showLoading,\n    getTimerLeft: getTimerLeft,\n    stopTimer: stopTimer,\n    resumeTimer: resumeTimer,\n    toggleTimer: toggleTimer,\n    increaseTimer: increaseTimer,\n    isTimerRunning: isTimerRunning,\n    bindClickHandler: bindClickHandler\n  });\n\n  let currentInstance;\n\n  class SweetAlert {\n    constructor() {\n      // Prevent run in Node env\n      if (typeof window === 'undefined') {\n        return;\n      }\n\n      currentInstance = this; // @ts-ignore\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      const outerParams = Object.freeze(this.constructor.argsToParams(args));\n      Object.defineProperties(this, {\n        params: {\n          value: outerParams,\n          writable: false,\n          enumerable: true,\n          configurable: true\n        }\n      }); // @ts-ignore\n\n      const promise = currentInstance._main(currentInstance.params);\n\n      privateProps.promise.set(this, promise);\n    }\n\n    _main(userParams) {\n      let mixinParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      showWarningsForParams(Object.assign({}, mixinParams, userParams));\n\n      if (globalState.currentInstance) {\n        // @ts-ignore\n        globalState.currentInstance._destroy();\n\n        if (isModal()) {\n          unsetAriaHidden();\n        }\n      }\n\n      globalState.currentInstance = currentInstance;\n      const innerParams = prepareParams(userParams, mixinParams);\n      setParameters(innerParams);\n      Object.freeze(innerParams); // clear the previous timer\n\n      if (globalState.timeout) {\n        globalState.timeout.stop();\n        delete globalState.timeout;\n      } // clear the restore focus timeout\n\n\n      clearTimeout(globalState.restoreFocusTimeout);\n      const domCache = populateDomCache(currentInstance);\n      render(currentInstance, innerParams);\n      privateProps.innerParams.set(currentInstance, innerParams);\n      return swalPromise(currentInstance, domCache, innerParams);\n    } // `catch` cannot be the name of a module export, so we define our thenable methods here instead\n\n\n    then(onFulfilled) {\n      const promise = privateProps.promise.get(this);\n      return promise.then(onFulfilled);\n    }\n\n    finally(onFinally) {\n      const promise = privateProps.promise.get(this);\n      return promise.finally(onFinally);\n    }\n\n  }\n\n  const swalPromise = (instance, domCache, innerParams) => {\n    return new Promise((resolve, reject) => {\n      // functions to handle all closings/dismissals\n      const dismissWith = dismiss => {\n        instance.closePopup({\n          isDismissed: true,\n          dismiss\n        });\n      };\n\n      privateMethods.swalPromiseResolve.set(instance, resolve);\n      privateMethods.swalPromiseReject.set(instance, reject);\n\n      domCache.confirmButton.onclick = () => handleConfirmButtonClick(instance);\n\n      domCache.denyButton.onclick = () => handleDenyButtonClick(instance);\n\n      domCache.cancelButton.onclick = () => handleCancelButtonClick(instance, dismissWith);\n\n      domCache.closeButton.onclick = () => dismissWith(DismissReason.close);\n\n      handlePopupClick(instance, domCache, dismissWith);\n      addKeydownHandler(instance, globalState, innerParams, dismissWith);\n      handleInputOptionsAndValue(instance, innerParams);\n      openPopup(innerParams);\n      setupTimer(globalState, innerParams, dismissWith);\n      initFocus(domCache, innerParams); // Scroll container to top on open (#1247, #1946)\n\n      setTimeout(() => {\n        domCache.container.scrollTop = 0;\n      });\n    });\n  };\n\n  const prepareParams = (userParams, mixinParams) => {\n    const templateParams = getTemplateParams(userParams);\n    const params = Object.assign({}, defaultParams, mixinParams, templateParams, userParams); // precedence is described in #2131\n\n    params.showClass = Object.assign({}, defaultParams.showClass, params.showClass);\n    params.hideClass = Object.assign({}, defaultParams.hideClass, params.hideClass);\n    return params;\n  };\n  /**\n   * @param {SweetAlert2} instance\n   * @returns {DomCache}\n   */\n\n\n  const populateDomCache = instance => {\n    const domCache = {\n      popup: getPopup(),\n      container: getContainer(),\n      actions: getActions(),\n      confirmButton: getConfirmButton(),\n      denyButton: getDenyButton(),\n      cancelButton: getCancelButton(),\n      loader: getLoader(),\n      closeButton: getCloseButton(),\n      validationMessage: getValidationMessage(),\n      progressSteps: getProgressSteps()\n    };\n    privateProps.domCache.set(instance, domCache);\n    return domCache;\n  };\n  /**\n   * @param {GlobalState} globalState\n   * @param {SweetAlertOptions} innerParams\n   * @param {function} dismissWith\n   */\n\n\n  const setupTimer = (globalState$$1, innerParams, dismissWith) => {\n    const timerProgressBar = getTimerProgressBar();\n    hide(timerProgressBar);\n\n    if (innerParams.timer) {\n      globalState$$1.timeout = new Timer(() => {\n        dismissWith('timer');\n        delete globalState$$1.timeout;\n      }, innerParams.timer);\n\n      if (innerParams.timerProgressBar) {\n        show(timerProgressBar);\n        applyCustomClass(timerProgressBar, innerParams, 'timerProgressBar');\n        setTimeout(() => {\n          if (globalState$$1.timeout && globalState$$1.timeout.running) {\n            // timer can be already stopped or unset at this point\n            animateTimerProgressBar(innerParams.timer);\n          }\n        });\n      }\n    }\n  };\n  /**\n   * @param {DomCache} domCache\n   * @param {SweetAlertOptions} innerParams\n   */\n\n\n  const initFocus = (domCache, innerParams) => {\n    if (innerParams.toast) {\n      return;\n    }\n\n    if (!callIfFunction(innerParams.allowEnterKey)) {\n      return blurActiveElement();\n    }\n\n    if (!focusButton(domCache, innerParams)) {\n      setFocus(innerParams, -1, 1);\n    }\n  };\n  /**\n   * @param {DomCache} domCache\n   * @param {SweetAlertOptions} innerParams\n   * @returns {boolean}\n   */\n\n\n  const focusButton = (domCache, innerParams) => {\n    if (innerParams.focusDeny && isVisible(domCache.denyButton)) {\n      domCache.denyButton.focus();\n      return true;\n    }\n\n    if (innerParams.focusCancel && isVisible(domCache.cancelButton)) {\n      domCache.cancelButton.focus();\n      return true;\n    }\n\n    if (innerParams.focusConfirm && isVisible(domCache.confirmButton)) {\n      domCache.confirmButton.focus();\n      return true;\n    }\n\n    return false;\n  };\n\n  const blurActiveElement = () => {\n    if (document.activeElement instanceof HTMLElement && typeof document.activeElement.blur === 'function') {\n      document.activeElement.blur();\n    }\n  }; // Assign instance methods from src/instanceMethods/*.js to prototype\n\n\n  Object.assign(SweetAlert.prototype, instanceMethods); // Assign static methods from src/staticMethods/*.js to constructor\n\n  Object.assign(SweetAlert, staticMethods); // Proxy to instance methods to constructor, for now, for backwards compatibility\n\n  Object.keys(instanceMethods).forEach(key => {\n    SweetAlert[key] = function () {\n      if (currentInstance) {\n        return currentInstance[key](...arguments);\n      }\n    };\n  });\n  SweetAlert.DismissReason = DismissReason;\n  SweetAlert.version = '11.4.17';\n\n  const Swal = SweetAlert; // @ts-ignore\n\n  Swal.default = Swal;\n\n  return Swal;\n\n}));\nif (typeof this !== 'undefined' && this.Sweetalert2){  this.swal = this.sweetAlert = this.Swal = this.SweetAlert = this.Sweetalert2}\n\n\"undefined\"!=typeof document&&function(e,t){var n=e.createElement(\"style\");if(e.getElementsByTagName(\"head\")[0].appendChild(n),n.styleSheet)n.styleSheet.disabled||(n.styleSheet.cssText=t);else try{n.innerHTML=t}catch(e){n.innerText=t}}(document,\".swal2-popup.swal2-toast{box-sizing:border-box;grid-column:1/4!important;grid-row:1/4!important;grid-template-columns:1fr 99fr 1fr;padding:1em;overflow-y:hidden;background:#fff;box-shadow:0 0 1px hsla(0deg,0%,0%,.075),0 1px 2px hsla(0deg,0%,0%,.075),1px 2px 4px hsla(0deg,0%,0%,.075),1px 3px 8px hsla(0deg,0%,0%,.075),2px 4px 16px hsla(0deg,0%,0%,.075);pointer-events:all}.swal2-popup.swal2-toast>*{grid-column:2}.swal2-popup.swal2-toast .swal2-title{margin:.5em 1em;padding:0;font-size:1em;text-align:initial}.swal2-popup.swal2-toast .swal2-loading{justify-content:center}.swal2-popup.swal2-toast .swal2-input{height:2em;margin:.5em;font-size:1em}.swal2-popup.swal2-toast .swal2-validation-message{font-size:1em}.swal2-popup.swal2-toast .swal2-footer{margin:.5em 0 0;padding:.5em 0 0;font-size:.8em}.swal2-popup.swal2-toast .swal2-close{grid-column:3/3;grid-row:1/99;align-self:center;width:.8em;height:.8em;margin:0;font-size:2em}.swal2-popup.swal2-toast .swal2-html-container{margin:.5em 1em;padding:0;font-size:1em;text-align:initial}.swal2-popup.swal2-toast .swal2-html-container:empty{padding:0}.swal2-popup.swal2-toast .swal2-loader{grid-column:1;grid-row:1/99;align-self:center;width:2em;height:2em;margin:.25em}.swal2-popup.swal2-toast .swal2-icon{grid-column:1;grid-row:1/99;align-self:center;width:2em;min-width:2em;height:2em;margin:0 .5em 0 0}.swal2-popup.swal2-toast .swal2-icon .swal2-icon-content{display:flex;align-items:center;font-size:1.8em;font-weight:700}.swal2-popup.swal2-toast .swal2-icon.swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-popup.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line]{top:.875em;width:1.375em}.swal2-popup.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=left]{left:.3125em}.swal2-popup.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=right]{right:.3125em}.swal2-popup.swal2-toast .swal2-actions{justify-content:flex-start;height:auto;margin:0;margin-top:.5em;padding:0 .5em}.swal2-popup.swal2-toast .swal2-styled{margin:.25em .5em;padding:.4em .6em;font-size:1em}.swal2-popup.swal2-toast .swal2-success{border-color:#a5dc86}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-circular-line]{position:absolute;width:1.6em;height:3em;transform:rotate(45deg);border-radius:50%}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=left]{top:-.8em;left:-.5em;transform:rotate(-45deg);transform-origin:2em 2em;border-radius:4em 0 0 4em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=right]{top:-.25em;left:.9375em;transform-origin:0 1.5em;border-radius:0 4em 4em 0}.swal2-popup.swal2-toast .swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-popup.swal2-toast .swal2-success .swal2-success-fix{top:0;left:.4375em;width:.4375em;height:2.6875em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-line]{height:.3125em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-line][class$=tip]{top:1.125em;left:.1875em;width:.75em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-line][class$=long]{top:.9375em;right:.1875em;width:1.375em}.swal2-popup.swal2-toast .swal2-success.swal2-icon-show .swal2-success-line-tip{-webkit-animation:swal2-toast-animate-success-line-tip .75s;animation:swal2-toast-animate-success-line-tip .75s}.swal2-popup.swal2-toast .swal2-success.swal2-icon-show .swal2-success-line-long{-webkit-animation:swal2-toast-animate-success-line-long .75s;animation:swal2-toast-animate-success-line-long .75s}.swal2-popup.swal2-toast.swal2-show{-webkit-animation:swal2-toast-show .5s;animation:swal2-toast-show .5s}.swal2-popup.swal2-toast.swal2-hide{-webkit-animation:swal2-toast-hide .1s forwards;animation:swal2-toast-hide .1s forwards}.swal2-container{display:grid;position:fixed;z-index:1060;top:0;right:0;bottom:0;left:0;box-sizing:border-box;grid-template-areas:\\\"top-start     top            top-end\\\" \\\"center-start  center         center-end\\\" \\\"bottom-start  bottom-center  bottom-end\\\";grid-template-rows:minmax(-webkit-min-content,auto) minmax(-webkit-min-content,auto) minmax(-webkit-min-content,auto);grid-template-rows:minmax(min-content,auto) minmax(min-content,auto) minmax(min-content,auto);height:100%;padding:.625em;overflow-x:hidden;transition:background-color .1s;-webkit-overflow-scrolling:touch}.swal2-container.swal2-backdrop-show,.swal2-container.swal2-noanimation{background:rgba(0,0,0,.4)}.swal2-container.swal2-backdrop-hide{background:0 0!important}.swal2-container.swal2-bottom-start,.swal2-container.swal2-center-start,.swal2-container.swal2-top-start{grid-template-columns:minmax(0,1fr) auto auto}.swal2-container.swal2-bottom,.swal2-container.swal2-center,.swal2-container.swal2-top{grid-template-columns:auto minmax(0,1fr) auto}.swal2-container.swal2-bottom-end,.swal2-container.swal2-center-end,.swal2-container.swal2-top-end{grid-template-columns:auto auto minmax(0,1fr)}.swal2-container.swal2-top-start>.swal2-popup{align-self:start}.swal2-container.swal2-top>.swal2-popup{grid-column:2;align-self:start;justify-self:center}.swal2-container.swal2-top-end>.swal2-popup,.swal2-container.swal2-top-right>.swal2-popup{grid-column:3;align-self:start;justify-self:end}.swal2-container.swal2-center-left>.swal2-popup,.swal2-container.swal2-center-start>.swal2-popup{grid-row:2;align-self:center}.swal2-container.swal2-center>.swal2-popup{grid-column:2;grid-row:2;align-self:center;justify-self:center}.swal2-container.swal2-center-end>.swal2-popup,.swal2-container.swal2-center-right>.swal2-popup{grid-column:3;grid-row:2;align-self:center;justify-self:end}.swal2-container.swal2-bottom-left>.swal2-popup,.swal2-container.swal2-bottom-start>.swal2-popup{grid-column:1;grid-row:3;align-self:end}.swal2-container.swal2-bottom>.swal2-popup{grid-column:2;grid-row:3;justify-self:center;align-self:end}.swal2-container.swal2-bottom-end>.swal2-popup,.swal2-container.swal2-bottom-right>.swal2-popup{grid-column:3;grid-row:3;align-self:end;justify-self:end}.swal2-container.swal2-grow-fullscreen>.swal2-popup,.swal2-container.swal2-grow-row>.swal2-popup{grid-column:1/4;width:100%}.swal2-container.swal2-grow-column>.swal2-popup,.swal2-container.swal2-grow-fullscreen>.swal2-popup{grid-row:1/4;align-self:stretch}.swal2-container.swal2-no-transition{transition:none!important}.swal2-popup{display:none;position:relative;box-sizing:border-box;grid-template-columns:minmax(0,100%);width:32em;max-width:100%;padding:0 0 1.25em;border:none;border-radius:5px;background:#fff;color:#545454;font-family:inherit;font-size:1rem}.swal2-popup:focus{outline:0}.swal2-popup.swal2-loading{overflow-y:hidden}.swal2-title{position:relative;max-width:100%;margin:0;padding:.8em 1em 0;color:inherit;font-size:1.875em;font-weight:600;text-align:center;text-transform:none;word-wrap:break-word}.swal2-actions{display:flex;z-index:1;box-sizing:border-box;flex-wrap:wrap;align-items:center;justify-content:center;width:auto;margin:1.25em auto 0;padding:0}.swal2-actions:not(.swal2-loading) .swal2-styled[disabled]{opacity:.4}.swal2-actions:not(.swal2-loading) .swal2-styled:hover{background-image:linear-gradient(rgba(0,0,0,.1),rgba(0,0,0,.1))}.swal2-actions:not(.swal2-loading) .swal2-styled:active{background-image:linear-gradient(rgba(0,0,0,.2),rgba(0,0,0,.2))}.swal2-loader{display:none;align-items:center;justify-content:center;width:2.2em;height:2.2em;margin:0 1.875em;-webkit-animation:swal2-rotate-loading 1.5s linear 0s infinite normal;animation:swal2-rotate-loading 1.5s linear 0s infinite normal;border-width:.25em;border-style:solid;border-radius:100%;border-color:#2778c4 transparent #2778c4 transparent}.swal2-styled{margin:.3125em;padding:.625em 1.1em;transition:box-shadow .1s;box-shadow:0 0 0 3px transparent;font-weight:500}.swal2-styled:not([disabled]){cursor:pointer}.swal2-styled.swal2-confirm{border:0;border-radius:.25em;background:initial;background-color:#7066e0;color:#fff;font-size:1em}.swal2-styled.swal2-confirm:focus{box-shadow:0 0 0 3px rgba(112,102,224,.5)}.swal2-styled.swal2-deny{border:0;border-radius:.25em;background:initial;background-color:#dc3741;color:#fff;font-size:1em}.swal2-styled.swal2-deny:focus{box-shadow:0 0 0 3px rgba(220,55,65,.5)}.swal2-styled.swal2-cancel{border:0;border-radius:.25em;background:initial;background-color:#6e7881;color:#fff;font-size:1em}.swal2-styled.swal2-cancel:focus{box-shadow:0 0 0 3px rgba(110,120,129,.5)}.swal2-styled.swal2-default-outline:focus{box-shadow:0 0 0 3px rgba(100,150,200,.5)}.swal2-styled:focus{outline:0}.swal2-styled::-moz-focus-inner{border:0}.swal2-footer{justify-content:center;margin:1em 0 0;padding:1em 1em 0;border-top:1px solid #eee;color:inherit;font-size:1em}.swal2-timer-progress-bar-container{position:absolute;right:0;bottom:0;left:0;grid-column:auto!important;overflow:hidden;border-bottom-right-radius:5px;border-bottom-left-radius:5px}.swal2-timer-progress-bar{width:100%;height:.25em;background:rgba(0,0,0,.2)}.swal2-image{max-width:100%;margin:2em auto 1em}.swal2-close{z-index:2;align-items:center;justify-content:center;width:1.2em;height:1.2em;margin-top:0;margin-right:0;margin-bottom:-1.2em;padding:0;overflow:hidden;transition:color .1s,box-shadow .1s;border:none;border-radius:5px;background:0 0;color:#ccc;font-family:serif;font-family:monospace;font-size:2.5em;cursor:pointer;justify-self:end}.swal2-close:hover{transform:none;background:0 0;color:#f27474}.swal2-close:focus{outline:0;box-shadow:inset 0 0 0 3px rgba(100,150,200,.5)}.swal2-close::-moz-focus-inner{border:0}.swal2-html-container{z-index:1;justify-content:center;margin:1em 1.6em .3em;padding:0;overflow:auto;color:inherit;font-size:1.125em;font-weight:400;line-height:normal;text-align:center;word-wrap:break-word;word-break:break-word}.swal2-checkbox,.swal2-file,.swal2-input,.swal2-radio,.swal2-select,.swal2-textarea{margin:1em 2em 3px}.swal2-file,.swal2-input,.swal2-textarea{box-sizing:border-box;width:auto;transition:border-color .1s,box-shadow .1s;border:1px solid #d9d9d9;border-radius:.1875em;background:0 0;box-shadow:inset 0 1px 1px rgba(0,0,0,.06),0 0 0 3px transparent;color:inherit;font-size:1.125em}.swal2-file.swal2-inputerror,.swal2-input.swal2-inputerror,.swal2-textarea.swal2-inputerror{border-color:#f27474!important;box-shadow:0 0 2px #f27474!important}.swal2-file:focus,.swal2-input:focus,.swal2-textarea:focus{border:1px solid #b4dbed;outline:0;box-shadow:inset 0 1px 1px rgba(0,0,0,.06),0 0 0 3px rgba(100,150,200,.5)}.swal2-file::-moz-placeholder,.swal2-input::-moz-placeholder,.swal2-textarea::-moz-placeholder{color:#ccc}.swal2-file:-ms-input-placeholder,.swal2-input:-ms-input-placeholder,.swal2-textarea:-ms-input-placeholder{color:#ccc}.swal2-file::placeholder,.swal2-input::placeholder,.swal2-textarea::placeholder{color:#ccc}.swal2-range{margin:1em 2em 3px;background:#fff}.swal2-range input{width:80%}.swal2-range output{width:20%;color:inherit;font-weight:600;text-align:center}.swal2-range input,.swal2-range output{height:2.625em;padding:0;font-size:1.125em;line-height:2.625em}.swal2-input{height:2.625em;padding:0 .75em}.swal2-file{width:75%;margin-right:auto;margin-left:auto;background:0 0;font-size:1.125em}.swal2-textarea{height:6.75em;padding:.75em}.swal2-select{min-width:50%;max-width:100%;padding:.375em .625em;background:0 0;color:inherit;font-size:1.125em}.swal2-checkbox,.swal2-radio{align-items:center;justify-content:center;background:#fff;color:inherit}.swal2-checkbox label,.swal2-radio label{margin:0 .6em;font-size:1.125em}.swal2-checkbox input,.swal2-radio input{flex-shrink:0;margin:0 .4em}.swal2-input-label{display:flex;justify-content:center;margin:1em auto 0}.swal2-validation-message{align-items:center;justify-content:center;margin:1em 0 0;padding:.625em;overflow:hidden;background:#f0f0f0;color:#666;font-size:1em;font-weight:300}.swal2-validation-message::before{content:\\\"!\\\";display:inline-block;width:1.5em;min-width:1.5em;height:1.5em;margin:0 .625em;border-radius:50%;background-color:#f27474;color:#fff;font-weight:600;line-height:1.5em;text-align:center}.swal2-icon{position:relative;box-sizing:content-box;justify-content:center;width:5em;height:5em;margin:2.5em auto .6em;border:.25em solid transparent;border-radius:50%;border-color:#000;font-family:inherit;line-height:5em;cursor:default;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.swal2-icon .swal2-icon-content{display:flex;align-items:center;font-size:3.75em}.swal2-icon.swal2-error{border-color:#f27474;color:#f27474}.swal2-icon.swal2-error .swal2-x-mark{position:relative;flex-grow:1}.swal2-icon.swal2-error [class^=swal2-x-mark-line]{display:block;position:absolute;top:2.3125em;width:2.9375em;height:.3125em;border-radius:.125em;background-color:#f27474}.swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=left]{left:1.0625em;transform:rotate(45deg)}.swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=right]{right:1em;transform:rotate(-45deg)}.swal2-icon.swal2-error.swal2-icon-show{-webkit-animation:swal2-animate-error-icon .5s;animation:swal2-animate-error-icon .5s}.swal2-icon.swal2-error.swal2-icon-show .swal2-x-mark{-webkit-animation:swal2-animate-error-x-mark .5s;animation:swal2-animate-error-x-mark .5s}.swal2-icon.swal2-warning{border-color:#facea8;color:#f8bb86}.swal2-icon.swal2-warning.swal2-icon-show{-webkit-animation:swal2-animate-error-icon .5s;animation:swal2-animate-error-icon .5s}.swal2-icon.swal2-warning.swal2-icon-show .swal2-icon-content{-webkit-animation:swal2-animate-i-mark .5s;animation:swal2-animate-i-mark .5s}.swal2-icon.swal2-info{border-color:#9de0f6;color:#3fc3ee}.swal2-icon.swal2-info.swal2-icon-show{-webkit-animation:swal2-animate-error-icon .5s;animation:swal2-animate-error-icon .5s}.swal2-icon.swal2-info.swal2-icon-show .swal2-icon-content{-webkit-animation:swal2-animate-i-mark .8s;animation:swal2-animate-i-mark .8s}.swal2-icon.swal2-question{border-color:#c9dae1;color:#87adbd}.swal2-icon.swal2-question.swal2-icon-show{-webkit-animation:swal2-animate-error-icon .5s;animation:swal2-animate-error-icon .5s}.swal2-icon.swal2-question.swal2-icon-show .swal2-icon-content{-webkit-animation:swal2-animate-question-mark .8s;animation:swal2-animate-question-mark .8s}.swal2-icon.swal2-success{border-color:#a5dc86;color:#a5dc86}.swal2-icon.swal2-success [class^=swal2-success-circular-line]{position:absolute;width:3.75em;height:7.5em;transform:rotate(45deg);border-radius:50%}.swal2-icon.swal2-success [class^=swal2-success-circular-line][class$=left]{top:-.4375em;left:-2.0635em;transform:rotate(-45deg);transform-origin:3.75em 3.75em;border-radius:7.5em 0 0 7.5em}.swal2-icon.swal2-success [class^=swal2-success-circular-line][class$=right]{top:-.6875em;left:1.875em;transform:rotate(-45deg);transform-origin:0 3.75em;border-radius:0 7.5em 7.5em 0}.swal2-icon.swal2-success .swal2-success-ring{position:absolute;z-index:2;top:-.25em;left:-.25em;box-sizing:content-box;width:100%;height:100%;border:.25em solid rgba(165,220,134,.3);border-radius:50%}.swal2-icon.swal2-success .swal2-success-fix{position:absolute;z-index:1;top:.5em;left:1.625em;width:.4375em;height:5.625em;transform:rotate(-45deg)}.swal2-icon.swal2-success [class^=swal2-success-line]{display:block;position:absolute;z-index:2;height:.3125em;border-radius:.125em;background-color:#a5dc86}.swal2-icon.swal2-success [class^=swal2-success-line][class$=tip]{top:2.875em;left:.8125em;width:1.5625em;transform:rotate(45deg)}.swal2-icon.swal2-success [class^=swal2-success-line][class$=long]{top:2.375em;right:.5em;width:2.9375em;transform:rotate(-45deg)}.swal2-icon.swal2-success.swal2-icon-show .swal2-success-line-tip{-webkit-animation:swal2-animate-success-line-tip .75s;animation:swal2-animate-success-line-tip .75s}.swal2-icon.swal2-success.swal2-icon-show .swal2-success-line-long{-webkit-animation:swal2-animate-success-line-long .75s;animation:swal2-animate-success-line-long .75s}.swal2-icon.swal2-success.swal2-icon-show .swal2-success-circular-line-right{-webkit-animation:swal2-rotate-success-circular-line 4.25s ease-in;animation:swal2-rotate-success-circular-line 4.25s ease-in}.swal2-progress-steps{flex-wrap:wrap;align-items:center;max-width:100%;margin:1.25em auto;padding:0;background:0 0;font-weight:600}.swal2-progress-steps li{display:inline-block;position:relative}.swal2-progress-steps .swal2-progress-step{z-index:20;flex-shrink:0;width:2em;height:2em;border-radius:2em;background:#2778c4;color:#fff;line-height:2em;text-align:center}.swal2-progress-steps .swal2-progress-step.swal2-active-progress-step{background:#2778c4}.swal2-progress-steps .swal2-progress-step.swal2-active-progress-step~.swal2-progress-step{background:#add8e6;color:#fff}.swal2-progress-steps .swal2-progress-step.swal2-active-progress-step~.swal2-progress-step-line{background:#add8e6}.swal2-progress-steps .swal2-progress-step-line{z-index:10;flex-shrink:0;width:2.5em;height:.4em;margin:0 -1px;background:#2778c4}[class^=swal2]{-webkit-tap-highlight-color:transparent}.swal2-show{-webkit-animation:swal2-show .3s;animation:swal2-show .3s}.swal2-hide{-webkit-animation:swal2-hide .15s forwards;animation:swal2-hide .15s forwards}.swal2-noanimation{transition:none}.swal2-scrollbar-measure{position:absolute;top:-9999px;width:50px;height:50px;overflow:scroll}.swal2-rtl .swal2-close{margin-right:initial;margin-left:0}.swal2-rtl .swal2-timer-progress-bar{right:0;left:auto}.swal2-no-war{display:flex;position:fixed;z-index:1061;top:0;left:0;align-items:center;justify-content:center;width:100%;height:3.375em;background:#20232a;color:#fff;text-align:center}.swal2-no-war a{color:#61dafb;text-decoration:none}.swal2-no-war a:hover{text-decoration:underline}@-webkit-keyframes swal2-toast-show{0%{transform:translateY(-.625em) rotateZ(2deg)}33%{transform:translateY(0) rotateZ(-2deg)}66%{transform:translateY(.3125em) rotateZ(2deg)}100%{transform:translateY(0) rotateZ(0)}}@keyframes swal2-toast-show{0%{transform:translateY(-.625em) rotateZ(2deg)}33%{transform:translateY(0) rotateZ(-2deg)}66%{transform:translateY(.3125em) rotateZ(2deg)}100%{transform:translateY(0) rotateZ(0)}}@-webkit-keyframes swal2-toast-hide{100%{transform:rotateZ(1deg);opacity:0}}@keyframes swal2-toast-hide{100%{transform:rotateZ(1deg);opacity:0}}@-webkit-keyframes swal2-toast-animate-success-line-tip{0%{top:.5625em;left:.0625em;width:0}54%{top:.125em;left:.125em;width:0}70%{top:.625em;left:-.25em;width:1.625em}84%{top:1.0625em;left:.75em;width:.5em}100%{top:1.125em;left:.1875em;width:.75em}}@keyframes swal2-toast-animate-success-line-tip{0%{top:.5625em;left:.0625em;width:0}54%{top:.125em;left:.125em;width:0}70%{top:.625em;left:-.25em;width:1.625em}84%{top:1.0625em;left:.75em;width:.5em}100%{top:1.125em;left:.1875em;width:.75em}}@-webkit-keyframes swal2-toast-animate-success-line-long{0%{top:1.625em;right:1.375em;width:0}65%{top:1.25em;right:.9375em;width:0}84%{top:.9375em;right:0;width:1.125em}100%{top:.9375em;right:.1875em;width:1.375em}}@keyframes swal2-toast-animate-success-line-long{0%{top:1.625em;right:1.375em;width:0}65%{top:1.25em;right:.9375em;width:0}84%{top:.9375em;right:0;width:1.125em}100%{top:.9375em;right:.1875em;width:1.375em}}@-webkit-keyframes swal2-show{0%{transform:scale(.7)}45%{transform:scale(1.05)}80%{transform:scale(.95)}100%{transform:scale(1)}}@keyframes swal2-show{0%{transform:scale(.7)}45%{transform:scale(1.05)}80%{transform:scale(.95)}100%{transform:scale(1)}}@-webkit-keyframes swal2-hide{0%{transform:scale(1);opacity:1}100%{transform:scale(.5);opacity:0}}@keyframes swal2-hide{0%{transform:scale(1);opacity:1}100%{transform:scale(.5);opacity:0}}@-webkit-keyframes swal2-animate-success-line-tip{0%{top:1.1875em;left:.0625em;width:0}54%{top:1.0625em;left:.125em;width:0}70%{top:2.1875em;left:-.375em;width:3.125em}84%{top:3em;left:1.3125em;width:1.0625em}100%{top:2.8125em;left:.8125em;width:1.5625em}}@keyframes swal2-animate-success-line-tip{0%{top:1.1875em;left:.0625em;width:0}54%{top:1.0625em;left:.125em;width:0}70%{top:2.1875em;left:-.375em;width:3.125em}84%{top:3em;left:1.3125em;width:1.0625em}100%{top:2.8125em;left:.8125em;width:1.5625em}}@-webkit-keyframes swal2-animate-success-line-long{0%{top:3.375em;right:2.875em;width:0}65%{top:3.375em;right:2.875em;width:0}84%{top:2.1875em;right:0;width:3.4375em}100%{top:2.375em;right:.5em;width:2.9375em}}@keyframes swal2-animate-success-line-long{0%{top:3.375em;right:2.875em;width:0}65%{top:3.375em;right:2.875em;width:0}84%{top:2.1875em;right:0;width:3.4375em}100%{top:2.375em;right:.5em;width:2.9375em}}@-webkit-keyframes swal2-rotate-success-circular-line{0%{transform:rotate(-45deg)}5%{transform:rotate(-45deg)}12%{transform:rotate(-405deg)}100%{transform:rotate(-405deg)}}@keyframes swal2-rotate-success-circular-line{0%{transform:rotate(-45deg)}5%{transform:rotate(-45deg)}12%{transform:rotate(-405deg)}100%{transform:rotate(-405deg)}}@-webkit-keyframes swal2-animate-error-x-mark{0%{margin-top:1.625em;transform:scale(.4);opacity:0}50%{margin-top:1.625em;transform:scale(.4);opacity:0}80%{margin-top:-.375em;transform:scale(1.15)}100%{margin-top:0;transform:scale(1);opacity:1}}@keyframes swal2-animate-error-x-mark{0%{margin-top:1.625em;transform:scale(.4);opacity:0}50%{margin-top:1.625em;transform:scale(.4);opacity:0}80%{margin-top:-.375em;transform:scale(1.15)}100%{margin-top:0;transform:scale(1);opacity:1}}@-webkit-keyframes swal2-animate-error-icon{0%{transform:rotateX(100deg);opacity:0}100%{transform:rotateX(0);opacity:1}}@keyframes swal2-animate-error-icon{0%{transform:rotateX(100deg);opacity:0}100%{transform:rotateX(0);opacity:1}}@-webkit-keyframes swal2-rotate-loading{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}@keyframes swal2-rotate-loading{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}@-webkit-keyframes swal2-animate-question-mark{0%{transform:rotateY(-360deg)}100%{transform:rotateY(0)}}@keyframes swal2-animate-question-mark{0%{transform:rotateY(-360deg)}100%{transform:rotateY(0)}}@-webkit-keyframes swal2-animate-i-mark{0%{transform:rotateZ(45deg);opacity:0}25%{transform:rotateZ(-25deg);opacity:.4}50%{transform:rotateZ(15deg);opacity:.8}75%{transform:rotateZ(-5deg);opacity:1}100%{transform:rotateX(0);opacity:1}}@keyframes swal2-animate-i-mark{0%{transform:rotateZ(45deg);opacity:0}25%{transform:rotateZ(-25deg);opacity:.4}50%{transform:rotateZ(15deg);opacity:.8}75%{transform:rotateZ(-5deg);opacity:1}100%{transform:rotateX(0);opacity:1}}body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown){overflow:hidden}body.swal2-height-auto{height:auto!important}body.swal2-no-backdrop .swal2-container{background-color:transparent!important;pointer-events:none}body.swal2-no-backdrop .swal2-container .swal2-popup{pointer-events:all}body.swal2-no-backdrop .swal2-container .swal2-modal{box-shadow:0 0 10px rgba(0,0,0,.4)}@media print{body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown){overflow-y:scroll!important}body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown)>[aria-hidden=true]{display:none}body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown) .swal2-container{position:static!important}}body.swal2-toast-shown .swal2-container{box-sizing:border-box;width:360px;max-width:100%;background-color:transparent;pointer-events:none}body.swal2-toast-shown .swal2-container.swal2-top{top:0;right:auto;bottom:auto;left:50%;transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-top-end,body.swal2-toast-shown .swal2-container.swal2-top-right{top:0;right:0;bottom:auto;left:auto}body.swal2-toast-shown .swal2-container.swal2-top-left,body.swal2-toast-shown .swal2-container.swal2-top-start{top:0;right:auto;bottom:auto;left:0}body.swal2-toast-shown .swal2-container.swal2-center-left,body.swal2-toast-shown .swal2-container.swal2-center-start{top:50%;right:auto;bottom:auto;left:0;transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-center{top:50%;right:auto;bottom:auto;left:50%;transform:translate(-50%,-50%)}body.swal2-toast-shown .swal2-container.swal2-center-end,body.swal2-toast-shown .swal2-container.swal2-center-right{top:50%;right:0;bottom:auto;left:auto;transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-left,body.swal2-toast-shown .swal2-container.swal2-bottom-start{top:auto;right:auto;bottom:0;left:0}body.swal2-toast-shown .swal2-container.swal2-bottom{top:auto;right:auto;bottom:0;left:50%;transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-end,body.swal2-toast-shown .swal2-container.swal2-bottom-right{top:auto;right:0;bottom:0;left:auto}\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3dlZXRhbGVydDIvZGlzdC9zd2VldGFsZXJ0Mi5hbGwuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsS0FBNEQ7QUFDOUQsRUFBRSxDQUN5RDtBQUMzRCxDQUFDLHFCQUFxQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQSxhQUFhLHlEQUF5RDtBQUN0RSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCLGVBQWU7QUFDZjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7OztBQUdBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBLGtFQUFrRTs7QUFFbEU7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUIsYUFBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGFBQWEsbUJBQW1CO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixhQUFhLG1CQUFtQjtBQUNoQyxhQUFhLFFBQVE7QUFDckI7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUIsYUFBYSw4Q0FBOEM7QUFDM0QsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNERBQTREO0FBQ3pFOztBQUVBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvQ0FBb0M7QUFDakQsYUFBYSx1Q0FBdUM7QUFDcEQsYUFBYSxTQUFTO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYSxvQ0FBb0M7QUFDakQsYUFBYSx1Q0FBdUM7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9DQUFvQztBQUNqRCxhQUFhLHVDQUF1QztBQUNwRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUIsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGFBQWEsUUFBUTtBQUNyQixhQUFhLEdBQUc7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixhQUFhLFFBQVE7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjs7QUFFQTtBQUNBLGVBQWUsYUFBYTtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGFBQWEsS0FBSztBQUNsQixhQUFhLFFBQVE7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUIsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7O0FBRUEsYUFBYSxhQUFhOztBQUUxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsZUFBZTtBQUNmOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLDBCQUEwQjs7QUFFakM7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtCQUFrQjs7QUFFakM7QUFDQSxlQUFlLG1CQUFtQjs7QUFFbEM7QUFDQTtBQUNBLGVBQWUsa0JBQWtCOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHNCQUFzQjtBQUNuQyxlQUFlO0FBQ2Y7OztBQUdBO0FBQ0E7QUFDQSxhQUFhLG1CQUFtQjtBQUNoQzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUIsYUFBYSxtQkFBbUI7QUFDaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLLElBQUk7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsK0JBQStCO0FBQzVDLGFBQWEsYUFBYTtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxhQUFhO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUIsYUFBYSxhQUFhO0FBQzFCOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLGFBQWE7QUFDbkM7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGFBQWE7QUFDMUIsYUFBYSxtQkFBbUI7QUFDaEM7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07OztBQUdOLGtEQUFrRDs7QUFFbEQsNENBQTRDOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixhQUFhLGFBQWE7QUFDMUIsYUFBYSxtQkFBbUI7QUFDaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNENBQTRDOztBQUU1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixhQUFhLGFBQWE7QUFDMUIsYUFBYSxhQUFhO0FBQzFCLGFBQWEsbUJBQW1CO0FBQ2hDOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2RUFBNkU7O0FBRTdFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixhQUFhLCtCQUErQjtBQUM1QyxhQUFhLG1CQUFtQjtBQUNoQzs7O0FBR0E7QUFDQTtBQUNBLHVFQUF1RTs7QUFFdkUseUZBQXlGO0FBQ3pGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGFBQWEsbUJBQW1CO0FBQ2hDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNkM7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixhQUFhLCtCQUErQjtBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUIsYUFBYSwrQkFBK0I7QUFDNUM7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGFBQWEsMkJBQTJCO0FBQ3hDOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGNBQWM7O0FBRTNCO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUIsYUFBYSxtQkFBbUI7QUFDaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRjs7QUFFcEYseURBQXlEOztBQUV6RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtQkFBbUI7QUFDaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0I7OztBQUdBO0FBQ0Esb0JBQW9CLDZCQUE2QjtBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekIsYUFBYSxzQ0FBc0M7QUFDbkQ7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFtQjtBQUNoQzs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx3Q0FBd0M7QUFDckQsYUFBYSxtQkFBbUI7QUFDaEM7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxtQkFBbUI7QUFDaEM7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw0QkFBNEI7QUFDekMsZUFBZTtBQUNmOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNERBQTREO0FBQ3pFLGFBQWEsaUNBQWlDO0FBQzlDOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQixhQUFhLG1CQUFtQjtBQUNoQyxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CLGFBQWEsbUJBQW1CO0FBQ2hDLGVBQWU7QUFDZjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0IsYUFBYSxtQkFBbUI7QUFDaEMsZUFBZTtBQUNmOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDLGFBQWEsbUJBQW1CO0FBQ2hDLGVBQWU7QUFDZjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0IsZUFBZTtBQUNmOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0IsYUFBYSxtQkFBbUI7QUFDaEMsZUFBZTtBQUNmOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEscUJBQXFCO0FBQ2xDLGFBQWEsbUJBQW1CO0FBQ2hDLGVBQWU7QUFDZjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixpQkFBaUI7QUFDakI7O0FBRUEsa0lBQWtJOzs7QUFHbEk7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixhQUFhLG1CQUFtQjtBQUNoQzs7QUFFQTtBQUNBO0FBQ0EsOERBQThEOztBQUU5RDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGFBQWEsbUJBQW1CO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTs7QUFFQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixhQUFhLG1CQUFtQjtBQUNoQzs7QUFFQTtBQUNBO0FBQ0EsdURBQXVEOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixhQUFhLG1CQUFtQjtBQUNoQzs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7O0FBRWhCO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUIsYUFBYSxtQkFBbUI7QUFDaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRDQUE0Qzs7QUFFNUMsNEJBQTRCOztBQUU1Qix3Q0FBd0M7O0FBRXhDO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0EsZUFBZSx5QkFBeUI7O0FBRXhDOztBQUVBLG9CQUFvQiw2QkFBNkI7QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixhQUFhLG1CQUFtQjtBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLDREQUE0RDtBQUM1RCxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixhQUFhLG1CQUFtQjtBQUNoQzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjs7O0FBR0E7O0FBRUE7QUFDQSxhQUFhLGFBQWE7QUFDMUIsYUFBYSxtQkFBbUI7QUFDaEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCOztBQUVyQjtBQUNBLGdEQUFnRDs7QUFFaEQ7QUFDQSw4REFBOEQ7O0FBRTlEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixhQUFhLG1CQUFtQjtBQUNoQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtQkFBbUI7QUFDaEMsZUFBZTtBQUNmOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGFBQWE7QUFDMUIsYUFBYSxtQkFBbUI7QUFDaEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTs7QUFFQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixhQUFhLG1CQUFtQjtBQUNoQzs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTs7O0FBR04sMkRBQTJEOztBQUUzRDtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBOztBQUVBLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGFBQWEsbUJBQW1CO0FBQ2hDOztBQUVBO0FBQ0EsNkRBQTZEO0FBQzdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07OztBQUdOOztBQUVBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixhQUFhLG1CQUFtQjtBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrQkFBa0I7OztBQUdqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQjs7O0FBR0E7QUFDQTtBQUNBLGVBQWUsYUFBYTs7QUFFNUI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQjs7O0FBR0E7QUFDQTtBQUNBLGVBQWUsYUFBYTs7QUFFNUI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0I7OztBQUdBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7O0FBRTVCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CLGFBQWEsVUFBVTtBQUN2Qjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLGFBQWE7O0FBRTlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0I7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGFBQWEsVUFBVTtBQUN2Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLDZEQUE2RCxLQUFLO0FBQ2xFLEtBQUs7O0FBRUw7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsTUFBTSxRQUFRLEtBQUs7QUFDM0U7QUFDQTs7QUFFQTtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDOzs7QUFHQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBOztBQUVBLHlDQUF5Qzs7QUFFekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsR0FBRztBQUNoQixlQUFlO0FBQ2Y7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QixlQUFlO0FBQ2Y7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLG9EQUFvRDs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7O0FBRS9DO0FBQ0EsS0FBSyx1QkFBdUI7O0FBRTVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxhQUFhLGFBQWE7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUIsYUFBYSxhQUFhO0FBQzFCLGFBQWEsbUJBQW1CO0FBQ2hDLGFBQWEsR0FBRztBQUNoQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFtQjtBQUNoQyxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0Esc0RBQXNEOztBQUV0RDtBQUNBLGlDQUFpQzs7QUFFakM7QUFDQSxtQkFBbUI7QUFDbkIsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGFBQWEsZUFBZTtBQUM1QixhQUFhLFVBQVU7QUFDdkI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZCxNQUFNO0FBQ047QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUIsYUFBYSxlQUFlO0FBQzVCLGFBQWEsbUJBQW1CO0FBQ2hDOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QixhQUFhLG1CQUFtQjtBQUNoQzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLDhCQUE4QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0Isa0NBQWtDO0FBQ3REOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCLGFBQWEsbUJBQW1CO0FBQ2hDLGFBQWEsVUFBVTtBQUN2Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBLGlGQUFpRjtBQUNqRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxzQ0FBc0M7O0FBRXRDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2Qjs7QUFFN0IsY0FBYztBQUNkLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUI7O0FBRUE7QUFDQSwrQkFBK0I7QUFDL0I7O0FBRUEsNEJBQTRCOztBQUU1QjtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLGFBQWE7QUFDMUI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUVBQXFFOztBQUVyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxRUFBcUU7O0FBRXJFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEdBQUc7QUFDaEIsZUFBZTtBQUNmOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHVCQUF1Qjs7QUFFdkIsd0VBQXdFLGFBQWE7QUFDckY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLFlBQVksa0JBQWtCLG9CQUFvQix5REFBeUQ7QUFDM0csWUFBWSxpQkFBaUIsb0JBQW9CLHdEQUF3RDtBQUN6RztBQUNBO0FBQ0EscUNBQXFDLHVDQUF1QztBQUM1RSxZQUFZLGtCQUFrQjtBQUM5QixZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0MsdUJBQXVCO0FBQ3ZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCOztBQUU5QiwwRUFBMEUsYUFBYTtBQUN2RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLEdBQUc7O0FBRVY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDOztBQUU1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDOztBQUV4QztBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLDJEQUEyRDs7QUFFOUYsdUNBQXVDO0FBQ3ZDLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUIsZUFBZTtBQUNmOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGFBQWEsbUJBQW1CO0FBQ2hDLGFBQWEsVUFBVTtBQUN2Qjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsbUJBQW1CO0FBQ2hDOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QixhQUFhLG1CQUFtQjtBQUNoQyxlQUFlO0FBQ2Y7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMLHdEQUF3RDs7QUFFeEQsNENBQTRDOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQSwyQkFBMkI7O0FBRTNCOztBQUVBOztBQUVBLENBQUM7QUFDRCx1REFBdUQsU0FBUyxHQUFHLGVBQWUsR0FBRyxTQUFTLEdBQUcsZUFBZTs7QUFFaEgsNENBQTRDLCtCQUErQixpSEFBaUgsU0FBUyxjQUFjLFNBQVMsZUFBZSxvQ0FBb0Msc0JBQXNCLDBCQUEwQix1QkFBdUIsbUNBQW1DLFlBQVksa0JBQWtCLGdCQUFnQixnTEFBZ0wsbUJBQW1CLDJCQUEyQixjQUFjLHNDQUFzQyxnQkFBZ0IsVUFBVSxjQUFjLG1CQUFtQix3Q0FBd0MsdUJBQXVCLHNDQUFzQyxXQUFXLFlBQVksY0FBYyxtREFBbUQsY0FBYyx1Q0FBdUMsZ0JBQWdCLGlCQUFpQixlQUFlLHNDQUFzQyxnQkFBZ0IsY0FBYyxrQkFBa0IsV0FBVyxZQUFZLFNBQVMsY0FBYywrQ0FBK0MsZ0JBQWdCLFVBQVUsY0FBYyxtQkFBbUIscURBQXFELFVBQVUsdUNBQXVDLGNBQWMsY0FBYyxrQkFBa0IsVUFBVSxXQUFXLGFBQWEscUNBQXFDLGNBQWMsY0FBYyxrQkFBa0IsVUFBVSxjQUFjLFdBQVcsa0JBQWtCLHlEQUF5RCxhQUFhLG1CQUFtQixnQkFBZ0IsZ0JBQWdCLHVFQUF1RSxVQUFVLFdBQVcsNEVBQTRFLFdBQVcsY0FBYyx5RkFBeUYsYUFBYSwwRkFBMEYsY0FBYyx3Q0FBd0MsMkJBQTJCLFlBQVksU0FBUyxnQkFBZ0IsZUFBZSx1Q0FBdUMsa0JBQWtCLGtCQUFrQixjQUFjLHdDQUF3QyxxQkFBcUIsNkVBQTZFLGtCQUFrQixZQUFZLFdBQVcsd0JBQXdCLGtCQUFrQiwwRkFBMEYsVUFBVSxXQUFXLHlCQUF5Qix5QkFBeUIsMEJBQTBCLDJGQUEyRixXQUFXLGFBQWEseUJBQXlCLDBCQUEwQiw0REFBNEQsVUFBVSxXQUFXLDJEQUEyRCxNQUFNLGFBQWEsY0FBYyxnQkFBZ0Isb0VBQW9FLGVBQWUsZ0ZBQWdGLFlBQVksYUFBYSxZQUFZLGlGQUFpRixZQUFZLGNBQWMsY0FBYyxnRkFBZ0YsNERBQTRELG9EQUFvRCxpRkFBaUYsNkRBQTZELHFEQUFxRCxvQ0FBb0MsdUNBQXVDLCtCQUErQixvQ0FBb0MsZ0RBQWdELHdDQUF3QyxpQkFBaUIsYUFBYSxlQUFlLGFBQWEsTUFBTSxRQUFRLFNBQVMsT0FBTyxzQkFBc0IscUpBQXFKLHNIQUFzSCw4RkFBOEYsWUFBWSxlQUFlLGtCQUFrQixnQ0FBZ0MsaUNBQWlDLHdFQUF3RSwwQkFBMEIscUNBQXFDLHlCQUF5Qix5R0FBeUcsOENBQThDLHVGQUF1Riw4Q0FBOEMsbUdBQW1HLDhDQUE4Qyw4Q0FBOEMsaUJBQWlCLHdDQUF3QyxjQUFjLGlCQUFpQixvQkFBb0IsMEZBQTBGLGNBQWMsaUJBQWlCLGlCQUFpQixpR0FBaUcsV0FBVyxrQkFBa0IsMkNBQTJDLGNBQWMsV0FBVyxrQkFBa0Isb0JBQW9CLGdHQUFnRyxjQUFjLFdBQVcsa0JBQWtCLGlCQUFpQixpR0FBaUcsY0FBYyxXQUFXLGVBQWUsMkNBQTJDLGNBQWMsV0FBVyxvQkFBb0IsZUFBZSxnR0FBZ0csY0FBYyxXQUFXLGVBQWUsaUJBQWlCLGlHQUFpRyxnQkFBZ0IsV0FBVyxvR0FBb0csYUFBYSxtQkFBbUIscUNBQXFDLDBCQUEwQixhQUFhLGFBQWEsa0JBQWtCLHNCQUFzQixxQ0FBcUMsV0FBVyxlQUFlLG1CQUFtQixZQUFZLGtCQUFrQixnQkFBZ0IsY0FBYyxvQkFBb0IsZUFBZSxtQkFBbUIsVUFBVSwyQkFBMkIsa0JBQWtCLGFBQWEsa0JBQWtCLGVBQWUsU0FBUyxtQkFBbUIsY0FBYyxrQkFBa0IsZ0JBQWdCLGtCQUFrQixvQkFBb0IscUJBQXFCLGVBQWUsYUFBYSxVQUFVLHNCQUFzQixlQUFlLG1CQUFtQix1QkFBdUIsV0FBVyxxQkFBcUIsVUFBVSwyREFBMkQsV0FBVyx1REFBdUQsZ0VBQWdFLHdEQUF3RCxnRUFBZ0UsY0FBYyxhQUFhLG1CQUFtQix1QkFBdUIsWUFBWSxhQUFhLGlCQUFpQixzRUFBc0UsOERBQThELG1CQUFtQixtQkFBbUIsbUJBQW1CLHFEQUFxRCxjQUFjLGVBQWUscUJBQXFCLDBCQUEwQixpQ0FBaUMsZ0JBQWdCLDhCQUE4QixlQUFlLDRCQUE0QixTQUFTLG9CQUFvQixtQkFBbUIseUJBQXlCLFdBQVcsY0FBYyxrQ0FBa0MsMENBQTBDLHlCQUF5QixTQUFTLG9CQUFvQixtQkFBbUIseUJBQXlCLFdBQVcsY0FBYywrQkFBK0Isd0NBQXdDLDJCQUEyQixTQUFTLG9CQUFvQixtQkFBbUIseUJBQXlCLFdBQVcsY0FBYyxpQ0FBaUMsMENBQTBDLDBDQUEwQywwQ0FBMEMsb0JBQW9CLFVBQVUsZ0NBQWdDLFNBQVMsY0FBYyx1QkFBdUIsZUFBZSxrQkFBa0IsMEJBQTBCLGNBQWMsY0FBYyxvQ0FBb0Msa0JBQWtCLFFBQVEsU0FBUyxPQUFPLDJCQUEyQixnQkFBZ0IsK0JBQStCLDhCQUE4QiwwQkFBMEIsV0FBVyxhQUFhLDBCQUEwQixhQUFhLGVBQWUsb0JBQW9CLGFBQWEsVUFBVSxtQkFBbUIsdUJBQXVCLFlBQVksYUFBYSxhQUFhLGVBQWUscUJBQXFCLFVBQVUsZ0JBQWdCLG9DQUFvQyxZQUFZLGtCQUFrQixlQUFlLFdBQVcsa0JBQWtCLHNCQUFzQixnQkFBZ0IsZUFBZSxpQkFBaUIsbUJBQW1CLGVBQWUsZUFBZSxjQUFjLG1CQUFtQixVQUFVLGdEQUFnRCwrQkFBK0IsU0FBUyxzQkFBc0IsVUFBVSx1QkFBdUIsc0JBQXNCLFVBQVUsY0FBYyxjQUFjLGtCQUFrQixnQkFBZ0IsbUJBQW1CLGtCQUFrQixxQkFBcUIsc0JBQXNCLG9GQUFvRixtQkFBbUIseUNBQXlDLHNCQUFzQixXQUFXLDJDQUEyQyx5QkFBeUIsc0JBQXNCLGVBQWUsaUVBQWlFLGNBQWMsa0JBQWtCLDRGQUE0RiwrQkFBK0IscUNBQXFDLDJEQUEyRCx5QkFBeUIsVUFBVSwwRUFBMEUsK0ZBQStGLFdBQVcsMkdBQTJHLFdBQVcsZ0ZBQWdGLFdBQVcsYUFBYSxtQkFBbUIsZ0JBQWdCLG1CQUFtQixVQUFVLG9CQUFvQixVQUFVLGNBQWMsZ0JBQWdCLGtCQUFrQix1Q0FBdUMsZUFBZSxVQUFVLGtCQUFrQixvQkFBb0IsYUFBYSxlQUFlLGdCQUFnQixZQUFZLFVBQVUsa0JBQWtCLGlCQUFpQixlQUFlLGtCQUFrQixnQkFBZ0IsY0FBYyxjQUFjLGNBQWMsY0FBYyxlQUFlLHNCQUFzQixlQUFlLGNBQWMsa0JBQWtCLDZCQUE2QixtQkFBbUIsdUJBQXVCLGdCQUFnQixjQUFjLHlDQUF5QyxjQUFjLGtCQUFrQix5Q0FBeUMsY0FBYyxjQUFjLG1CQUFtQixhQUFhLHVCQUF1QixrQkFBa0IsMEJBQTBCLG1CQUFtQix1QkFBdUIsZUFBZSxlQUFlLGdCQUFnQixtQkFBbUIsV0FBVyxjQUFjLGdCQUFnQixrQ0FBa0MsY0FBYyxxQkFBcUIsWUFBWSxnQkFBZ0IsYUFBYSxnQkFBZ0Isa0JBQWtCLHlCQUF5QixXQUFXLGdCQUFnQixrQkFBa0Isa0JBQWtCLFlBQVksa0JBQWtCLHVCQUF1Qix1QkFBdUIsVUFBVSxXQUFXLHVCQUF1QiwrQkFBK0Isa0JBQWtCLGtCQUFrQixvQkFBb0IsZ0JBQWdCLGVBQWUseUJBQXlCLHNCQUFzQixxQkFBcUIsaUJBQWlCLGdDQUFnQyxhQUFhLG1CQUFtQixpQkFBaUIsd0JBQXdCLHFCQUFxQixjQUFjLHNDQUFzQyxrQkFBa0IsWUFBWSxtREFBbUQsY0FBYyxrQkFBa0IsYUFBYSxlQUFlLGVBQWUscUJBQXFCLHlCQUF5QixnRUFBZ0UsY0FBYyx3QkFBd0IsaUVBQWlFLFVBQVUseUJBQXlCLHdDQUF3QywrQ0FBK0MsdUNBQXVDLHNEQUFzRCxpREFBaUQseUNBQXlDLDBCQUEwQixxQkFBcUIsY0FBYywwQ0FBMEMsK0NBQStDLHVDQUF1Qyw4REFBOEQsMkNBQTJDLG1DQUFtQyx1QkFBdUIscUJBQXFCLGNBQWMsdUNBQXVDLCtDQUErQyx1Q0FBdUMsMkRBQTJELDJDQUEyQyxtQ0FBbUMsMkJBQTJCLHFCQUFxQixjQUFjLDJDQUEyQywrQ0FBK0MsdUNBQXVDLCtEQUErRCxrREFBa0QsMENBQTBDLDBCQUEwQixxQkFBcUIsY0FBYywrREFBK0Qsa0JBQWtCLGFBQWEsYUFBYSx3QkFBd0Isa0JBQWtCLDRFQUE0RSxhQUFhLGVBQWUseUJBQXlCLCtCQUErQiw4QkFBOEIsNkVBQTZFLGFBQWEsYUFBYSx5QkFBeUIsMEJBQTBCLDhCQUE4Qiw4Q0FBOEMsa0JBQWtCLFVBQVUsV0FBVyxZQUFZLHVCQUF1QixXQUFXLFlBQVksd0NBQXdDLGtCQUFrQiw2Q0FBNkMsa0JBQWtCLFVBQVUsU0FBUyxhQUFhLGNBQWMsZUFBZSx5QkFBeUIsc0RBQXNELGNBQWMsa0JBQWtCLFVBQVUsZUFBZSxxQkFBcUIseUJBQXlCLGtFQUFrRSxZQUFZLGFBQWEsZUFBZSx3QkFBd0IsbUVBQW1FLFlBQVksV0FBVyxlQUFlLHlCQUF5QixrRUFBa0Usc0RBQXNELDhDQUE4QyxtRUFBbUUsdURBQXVELCtDQUErQyw2RUFBNkUsbUVBQW1FLDJEQUEyRCxzQkFBc0IsZUFBZSxtQkFBbUIsZUFBZSxtQkFBbUIsVUFBVSxlQUFlLGdCQUFnQix5QkFBeUIscUJBQXFCLGtCQUFrQiwyQ0FBMkMsV0FBVyxjQUFjLFVBQVUsV0FBVyxrQkFBa0IsbUJBQW1CLFdBQVcsZ0JBQWdCLGtCQUFrQixzRUFBc0UsbUJBQW1CLDJGQUEyRixtQkFBbUIsV0FBVyxnR0FBZ0csbUJBQW1CLGdEQUFnRCxXQUFXLGNBQWMsWUFBWSxZQUFZLGNBQWMsbUJBQW1CLGVBQWUsd0NBQXdDLFlBQVksaUNBQWlDLHlCQUF5QixZQUFZLDJDQUEyQyxtQ0FBbUMsbUJBQW1CLGdCQUFnQix5QkFBeUIsa0JBQWtCLFlBQVksV0FBVyxZQUFZLGdCQUFnQix3QkFBd0IscUJBQXFCLGNBQWMscUNBQXFDLFFBQVEsVUFBVSxjQUFjLGFBQWEsZUFBZSxhQUFhLE1BQU0sT0FBTyxtQkFBbUIsdUJBQXVCLFdBQVcsZUFBZSxtQkFBbUIsV0FBVyxrQkFBa0IsZ0JBQWdCLGNBQWMscUJBQXFCLHNCQUFzQiwwQkFBMEIsb0NBQW9DLEdBQUcsNENBQTRDLElBQUksdUNBQXVDLElBQUksNENBQTRDLEtBQUssb0NBQW9DLDRCQUE0QixHQUFHLDRDQUE0QyxJQUFJLHVDQUF1QyxJQUFJLDRDQUE0QyxLQUFLLG9DQUFvQyxvQ0FBb0MsS0FBSyx3QkFBd0IsV0FBVyw0QkFBNEIsS0FBSyx3QkFBd0IsV0FBVyx3REFBd0QsR0FBRyxZQUFZLGFBQWEsUUFBUSxJQUFJLFdBQVcsWUFBWSxRQUFRLElBQUksV0FBVyxZQUFZLGNBQWMsSUFBSSxhQUFhLFdBQVcsV0FBVyxLQUFLLFlBQVksYUFBYSxhQUFhLGdEQUFnRCxHQUFHLFlBQVksYUFBYSxRQUFRLElBQUksV0FBVyxZQUFZLFFBQVEsSUFBSSxXQUFXLFlBQVksY0FBYyxJQUFJLGFBQWEsV0FBVyxXQUFXLEtBQUssWUFBWSxhQUFhLGFBQWEseURBQXlELEdBQUcsWUFBWSxjQUFjLFFBQVEsSUFBSSxXQUFXLGNBQWMsUUFBUSxJQUFJLFlBQVksUUFBUSxjQUFjLEtBQUssWUFBWSxjQUFjLGVBQWUsaURBQWlELEdBQUcsWUFBWSxjQUFjLFFBQVEsSUFBSSxXQUFXLGNBQWMsUUFBUSxJQUFJLFlBQVksUUFBUSxjQUFjLEtBQUssWUFBWSxjQUFjLGVBQWUsOEJBQThCLEdBQUcsb0JBQW9CLElBQUksc0JBQXNCLElBQUkscUJBQXFCLEtBQUssb0JBQW9CLHNCQUFzQixHQUFHLG9CQUFvQixJQUFJLHNCQUFzQixJQUFJLHFCQUFxQixLQUFLLG9CQUFvQiw4QkFBOEIsR0FBRyxtQkFBbUIsVUFBVSxLQUFLLG9CQUFvQixXQUFXLHNCQUFzQixHQUFHLG1CQUFtQixVQUFVLEtBQUssb0JBQW9CLFdBQVcsa0RBQWtELEdBQUcsYUFBYSxhQUFhLFFBQVEsSUFBSSxhQUFhLFlBQVksUUFBUSxJQUFJLGFBQWEsYUFBYSxjQUFjLElBQUksUUFBUSxjQUFjLGVBQWUsS0FBSyxhQUFhLGFBQWEsZ0JBQWdCLDBDQUEwQyxHQUFHLGFBQWEsYUFBYSxRQUFRLElBQUksYUFBYSxZQUFZLFFBQVEsSUFBSSxhQUFhLGFBQWEsY0FBYyxJQUFJLFFBQVEsY0FBYyxlQUFlLEtBQUssYUFBYSxhQUFhLGdCQUFnQixtREFBbUQsR0FBRyxZQUFZLGNBQWMsUUFBUSxJQUFJLFlBQVksY0FBYyxRQUFRLElBQUksYUFBYSxRQUFRLGVBQWUsS0FBSyxZQUFZLFdBQVcsZ0JBQWdCLDJDQUEyQyxHQUFHLFlBQVksY0FBYyxRQUFRLElBQUksWUFBWSxjQUFjLFFBQVEsSUFBSSxhQUFhLFFBQVEsZUFBZSxLQUFLLFlBQVksV0FBVyxnQkFBZ0Isc0RBQXNELEdBQUcseUJBQXlCLEdBQUcseUJBQXlCLElBQUksMEJBQTBCLEtBQUssMkJBQTJCLDhDQUE4QyxHQUFHLHlCQUF5QixHQUFHLHlCQUF5QixJQUFJLDBCQUEwQixLQUFLLDJCQUEyQiw4Q0FBOEMsR0FBRyxtQkFBbUIsb0JBQW9CLFVBQVUsSUFBSSxtQkFBbUIsb0JBQW9CLFVBQVUsSUFBSSxtQkFBbUIsc0JBQXNCLEtBQUssYUFBYSxtQkFBbUIsV0FBVyxzQ0FBc0MsR0FBRyxtQkFBbUIsb0JBQW9CLFVBQVUsSUFBSSxtQkFBbUIsb0JBQW9CLFVBQVUsSUFBSSxtQkFBbUIsc0JBQXNCLEtBQUssYUFBYSxtQkFBbUIsV0FBVyw0Q0FBNEMsR0FBRywwQkFBMEIsVUFBVSxLQUFLLHFCQUFxQixXQUFXLG9DQUFvQyxHQUFHLDBCQUEwQixVQUFVLEtBQUsscUJBQXFCLFdBQVcsd0NBQXdDLEdBQUcsb0JBQW9CLEtBQUssMEJBQTBCLGdDQUFnQyxHQUFHLG9CQUFvQixLQUFLLDBCQUEwQiwrQ0FBK0MsR0FBRywyQkFBMkIsS0FBSyxzQkFBc0IsdUNBQXVDLEdBQUcsMkJBQTJCLEtBQUssc0JBQXNCLHdDQUF3QyxHQUFHLHlCQUF5QixVQUFVLElBQUksMEJBQTBCLFdBQVcsSUFBSSx5QkFBeUIsV0FBVyxJQUFJLHlCQUF5QixVQUFVLEtBQUsscUJBQXFCLFdBQVcsZ0NBQWdDLEdBQUcseUJBQXlCLFVBQVUsSUFBSSwwQkFBMEIsV0FBVyxJQUFJLHlCQUF5QixXQUFXLElBQUkseUJBQXlCLFVBQVUsS0FBSyxxQkFBcUIsV0FBVyxpRUFBaUUsZ0JBQWdCLHVCQUF1QixzQkFBc0Isd0NBQXdDLHVDQUF1QyxvQkFBb0IscURBQXFELG1CQUFtQixxREFBcUQsbUNBQW1DLGFBQWEsaUVBQWlFLDRCQUE0QixvRkFBb0YsYUFBYSxrRkFBa0YsMkJBQTJCLHdDQUF3QyxzQkFBc0IsWUFBWSxlQUFlLDZCQUE2QixvQkFBb0Isa0RBQWtELE1BQU0sV0FBVyxZQUFZLFNBQVMsMkJBQTJCLDhHQUE4RyxNQUFNLFFBQVEsWUFBWSxVQUFVLCtHQUErRyxNQUFNLFdBQVcsWUFBWSxPQUFPLHFIQUFxSCxRQUFRLFdBQVcsWUFBWSxPQUFPLDJCQUEyQixxREFBcUQsUUFBUSxXQUFXLFlBQVksU0FBUywrQkFBK0Isb0hBQW9ILFFBQVEsUUFBUSxZQUFZLFVBQVUsMkJBQTJCLHFIQUFxSCxTQUFTLFdBQVcsU0FBUyxPQUFPLHFEQUFxRCxTQUFTLFdBQVcsU0FBUyxTQUFTLDJCQUEyQixvSEFBb0gsU0FBUyxRQUFRLFNBQVMsVUFBVSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zd2VldGFsZXJ0Mi9kaXN0L3N3ZWV0YWxlcnQyLmFsbC5qcz8xMzFkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuKiBzd2VldGFsZXJ0MiB2MTEuNC4xN1xuKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4qL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAoZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC5Td2VldGFsZXJ0MiA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIGNvbnN0IGNvbnNvbGVQcmVmaXggPSAnU3dlZXRBbGVydDI6JztcbiAgLyoqXG4gICAqIEZpbHRlciB0aGUgdW5pcXVlIHZhbHVlcyBpbnRvIGEgbmV3IGFycmF5XG4gICAqIEBwYXJhbSBhcnJcbiAgICovXG5cbiAgY29uc3QgdW5pcXVlQXJyYXkgPSBhcnIgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZXN1bHQuaW5kZXhPZihhcnJbaV0pID09PSAtMSkge1xuICAgICAgICByZXN1bHQucHVzaChhcnJbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIC8qKlxuICAgKiBDYXBpdGFsaXplIHRoZSBmaXJzdCBsZXR0ZXIgb2YgYSBzdHJpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cblxuICBjb25zdCBjYXBpdGFsaXplRmlyc3RMZXR0ZXIgPSBzdHIgPT4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xuICAvKipcbiAgICogQHBhcmFtIHtOb2RlTGlzdCB8IEhUTUxDb2xsZWN0aW9uIHwgTmFtZWROb2RlTWFwIHwgRE9NVG9rZW5MaXN0fSBub2RlTGlzdFxuICAgKiBAcmV0dXJucyB7YXJyYXl9XG4gICAqL1xuXG4gIGNvbnN0IHRvQXJyYXkgPSBub2RlTGlzdCA9PiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChub2RlTGlzdCk7XG4gIC8qKlxuICAgKiBTdGFuZGFyZGl6ZSBjb25zb2xlIHdhcm5pbmdzXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgYXJyYXl9IG1lc3NhZ2VcbiAgICovXG5cbiAgY29uc3Qgd2FybiA9IG1lc3NhZ2UgPT4ge1xuICAgIGNvbnNvbGUud2FybihcIlwiLmNvbmNhdChjb25zb2xlUHJlZml4LCBcIiBcIikuY29uY2F0KHR5cGVvZiBtZXNzYWdlID09PSAnb2JqZWN0JyA/IG1lc3NhZ2Uuam9pbignICcpIDogbWVzc2FnZSkpO1xuICB9O1xuICAvKipcbiAgICogU3RhbmRhcmRpemUgY29uc29sZSBlcnJvcnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VcbiAgICovXG5cbiAgY29uc3QgZXJyb3IgPSBtZXNzYWdlID0+IHtcbiAgICBjb25zb2xlLmVycm9yKFwiXCIuY29uY2F0KGNvbnNvbGVQcmVmaXgsIFwiIFwiKS5jb25jYXQobWVzc2FnZSkpO1xuICB9O1xuICAvKipcbiAgICogUHJpdmF0ZSBnbG9iYWwgc3RhdGUgZm9yIGB3YXJuT25jZWBcbiAgICogQHR5cGUge0FycmF5fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICBjb25zdCBwcmV2aW91c1dhcm5PbmNlTWVzc2FnZXMgPSBbXTtcbiAgLyoqXG4gICAqIFNob3cgYSBjb25zb2xlIHdhcm5pbmcsIGJ1dCBvbmx5IGlmIGl0IGhhc24ndCBhbHJlYWR5IGJlZW4gc2hvd25cbiAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VcbiAgICovXG5cbiAgY29uc3Qgd2Fybk9uY2UgPSBtZXNzYWdlID0+IHtcbiAgICBpZiAoIXByZXZpb3VzV2Fybk9uY2VNZXNzYWdlcy5pbmNsdWRlcyhtZXNzYWdlKSkge1xuICAgICAgcHJldmlvdXNXYXJuT25jZU1lc3NhZ2VzLnB1c2gobWVzc2FnZSk7XG4gICAgICB3YXJuKG1lc3NhZ2UpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIFNob3cgYSBvbmUtdGltZSBjb25zb2xlIHdhcm5pbmcgYWJvdXQgZGVwcmVjYXRlZCBwYXJhbXMvbWV0aG9kc1xuICAgKi9cblxuICBjb25zdCB3YXJuQWJvdXREZXByZWNhdGlvbiA9IChkZXByZWNhdGVkUGFyYW0sIHVzZUluc3RlYWQpID0+IHtcbiAgICB3YXJuT25jZShcIlxcXCJcIi5jb25jYXQoZGVwcmVjYXRlZFBhcmFtLCBcIlxcXCIgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuIFBsZWFzZSB1c2UgXFxcIlwiKS5jb25jYXQodXNlSW5zdGVhZCwgXCJcXFwiIGluc3RlYWQuXCIpKTtcbiAgfTtcbiAgLyoqXG4gICAqIElmIGBhcmdgIGlzIGEgZnVuY3Rpb24sIGNhbGwgaXQgKHdpdGggbm8gYXJndW1lbnRzIG9yIGNvbnRleHQpIGFuZCByZXR1cm4gdGhlIHJlc3VsdC5cbiAgICogT3RoZXJ3aXNlLCBqdXN0IHBhc3MgdGhlIHZhbHVlIHRocm91Z2hcbiAgICogQHBhcmFtIGFyZ1xuICAgKi9cblxuICBjb25zdCBjYWxsSWZGdW5jdGlvbiA9IGFyZyA9PiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nID8gYXJnKCkgOiBhcmc7XG4gIGNvbnN0IGhhc1RvUHJvbWlzZUZuID0gYXJnID0+IGFyZyAmJiB0eXBlb2YgYXJnLnRvUHJvbWlzZSA9PT0gJ2Z1bmN0aW9uJztcbiAgY29uc3QgYXNQcm9taXNlID0gYXJnID0+IGhhc1RvUHJvbWlzZUZuKGFyZykgPyBhcmcudG9Qcm9taXNlKCkgOiBQcm9taXNlLnJlc29sdmUoYXJnKTtcbiAgY29uc3QgaXNQcm9taXNlID0gYXJnID0+IGFyZyAmJiBQcm9taXNlLnJlc29sdmUoYXJnKSA9PT0gYXJnO1xuICBjb25zdCBnZXRSYW5kb21FbGVtZW50ID0gYXJyID0+IGFycltNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBhcnIubGVuZ3RoKV07XG5cbiAgY29uc3QgZGVmYXVsdFBhcmFtcyA9IHtcbiAgICB0aXRsZTogJycsXG4gICAgdGl0bGVUZXh0OiAnJyxcbiAgICB0ZXh0OiAnJyxcbiAgICBodG1sOiAnJyxcbiAgICBmb290ZXI6ICcnLFxuICAgIGljb246IHVuZGVmaW5lZCxcbiAgICBpY29uQ29sb3I6IHVuZGVmaW5lZCxcbiAgICBpY29uSHRtbDogdW5kZWZpbmVkLFxuICAgIHRlbXBsYXRlOiB1bmRlZmluZWQsXG4gICAgdG9hc3Q6IGZhbHNlLFxuICAgIHNob3dDbGFzczoge1xuICAgICAgcG9wdXA6ICdzd2FsMi1zaG93JyxcbiAgICAgIGJhY2tkcm9wOiAnc3dhbDItYmFja2Ryb3Atc2hvdycsXG4gICAgICBpY29uOiAnc3dhbDItaWNvbi1zaG93J1xuICAgIH0sXG4gICAgaGlkZUNsYXNzOiB7XG4gICAgICBwb3B1cDogJ3N3YWwyLWhpZGUnLFxuICAgICAgYmFja2Ryb3A6ICdzd2FsMi1iYWNrZHJvcC1oaWRlJyxcbiAgICAgIGljb246ICdzd2FsMi1pY29uLWhpZGUnXG4gICAgfSxcbiAgICBjdXN0b21DbGFzczoge30sXG4gICAgdGFyZ2V0OiAnYm9keScsXG4gICAgY29sb3I6IHVuZGVmaW5lZCxcbiAgICBiYWNrZHJvcDogdHJ1ZSxcbiAgICBoZWlnaHRBdXRvOiB0cnVlLFxuICAgIGFsbG93T3V0c2lkZUNsaWNrOiB0cnVlLFxuICAgIGFsbG93RXNjYXBlS2V5OiB0cnVlLFxuICAgIGFsbG93RW50ZXJLZXk6IHRydWUsXG4gICAgc3RvcEtleWRvd25Qcm9wYWdhdGlvbjogdHJ1ZSxcbiAgICBrZXlkb3duTGlzdGVuZXJDYXB0dXJlOiBmYWxzZSxcbiAgICBzaG93Q29uZmlybUJ1dHRvbjogdHJ1ZSxcbiAgICBzaG93RGVueUJ1dHRvbjogZmFsc2UsXG4gICAgc2hvd0NhbmNlbEJ1dHRvbjogZmFsc2UsXG4gICAgcHJlQ29uZmlybTogdW5kZWZpbmVkLFxuICAgIHByZURlbnk6IHVuZGVmaW5lZCxcbiAgICBjb25maXJtQnV0dG9uVGV4dDogJ09LJyxcbiAgICBjb25maXJtQnV0dG9uQXJpYUxhYmVsOiAnJyxcbiAgICBjb25maXJtQnV0dG9uQ29sb3I6IHVuZGVmaW5lZCxcbiAgICBkZW55QnV0dG9uVGV4dDogJ05vJyxcbiAgICBkZW55QnV0dG9uQXJpYUxhYmVsOiAnJyxcbiAgICBkZW55QnV0dG9uQ29sb3I6IHVuZGVmaW5lZCxcbiAgICBjYW5jZWxCdXR0b25UZXh0OiAnQ2FuY2VsJyxcbiAgICBjYW5jZWxCdXR0b25BcmlhTGFiZWw6ICcnLFxuICAgIGNhbmNlbEJ1dHRvbkNvbG9yOiB1bmRlZmluZWQsXG4gICAgYnV0dG9uc1N0eWxpbmc6IHRydWUsXG4gICAgcmV2ZXJzZUJ1dHRvbnM6IGZhbHNlLFxuICAgIGZvY3VzQ29uZmlybTogdHJ1ZSxcbiAgICBmb2N1c0Rlbnk6IGZhbHNlLFxuICAgIGZvY3VzQ2FuY2VsOiBmYWxzZSxcbiAgICByZXR1cm5Gb2N1czogdHJ1ZSxcbiAgICBzaG93Q2xvc2VCdXR0b246IGZhbHNlLFxuICAgIGNsb3NlQnV0dG9uSHRtbDogJyZ0aW1lczsnLFxuICAgIGNsb3NlQnV0dG9uQXJpYUxhYmVsOiAnQ2xvc2UgdGhpcyBkaWFsb2cnLFxuICAgIGxvYWRlckh0bWw6ICcnLFxuICAgIHNob3dMb2FkZXJPbkNvbmZpcm06IGZhbHNlLFxuICAgIHNob3dMb2FkZXJPbkRlbnk6IGZhbHNlLFxuICAgIGltYWdlVXJsOiB1bmRlZmluZWQsXG4gICAgaW1hZ2VXaWR0aDogdW5kZWZpbmVkLFxuICAgIGltYWdlSGVpZ2h0OiB1bmRlZmluZWQsXG4gICAgaW1hZ2VBbHQ6ICcnLFxuICAgIHRpbWVyOiB1bmRlZmluZWQsXG4gICAgdGltZXJQcm9ncmVzc0JhcjogZmFsc2UsXG4gICAgd2lkdGg6IHVuZGVmaW5lZCxcbiAgICBwYWRkaW5nOiB1bmRlZmluZWQsXG4gICAgYmFja2dyb3VuZDogdW5kZWZpbmVkLFxuICAgIGlucHV0OiB1bmRlZmluZWQsXG4gICAgaW5wdXRQbGFjZWhvbGRlcjogJycsXG4gICAgaW5wdXRMYWJlbDogJycsXG4gICAgaW5wdXRWYWx1ZTogJycsXG4gICAgaW5wdXRPcHRpb25zOiB7fSxcbiAgICBpbnB1dEF1dG9UcmltOiB0cnVlLFxuICAgIGlucHV0QXR0cmlidXRlczoge30sXG4gICAgaW5wdXRWYWxpZGF0b3I6IHVuZGVmaW5lZCxcbiAgICByZXR1cm5JbnB1dFZhbHVlT25EZW55OiBmYWxzZSxcbiAgICB2YWxpZGF0aW9uTWVzc2FnZTogdW5kZWZpbmVkLFxuICAgIGdyb3c6IGZhbHNlLFxuICAgIHBvc2l0aW9uOiAnY2VudGVyJyxcbiAgICBwcm9ncmVzc1N0ZXBzOiBbXSxcbiAgICBjdXJyZW50UHJvZ3Jlc3NTdGVwOiB1bmRlZmluZWQsXG4gICAgcHJvZ3Jlc3NTdGVwc0Rpc3RhbmNlOiB1bmRlZmluZWQsXG4gICAgd2lsbE9wZW46IHVuZGVmaW5lZCxcbiAgICBkaWRPcGVuOiB1bmRlZmluZWQsXG4gICAgZGlkUmVuZGVyOiB1bmRlZmluZWQsXG4gICAgd2lsbENsb3NlOiB1bmRlZmluZWQsXG4gICAgZGlkQ2xvc2U6IHVuZGVmaW5lZCxcbiAgICBkaWREZXN0cm95OiB1bmRlZmluZWQsXG4gICAgc2Nyb2xsYmFyUGFkZGluZzogdHJ1ZVxuICB9O1xuICBjb25zdCB1cGRhdGFibGVQYXJhbXMgPSBbJ2FsbG93RXNjYXBlS2V5JywgJ2FsbG93T3V0c2lkZUNsaWNrJywgJ2JhY2tncm91bmQnLCAnYnV0dG9uc1N0eWxpbmcnLCAnY2FuY2VsQnV0dG9uQXJpYUxhYmVsJywgJ2NhbmNlbEJ1dHRvbkNvbG9yJywgJ2NhbmNlbEJ1dHRvblRleHQnLCAnY2xvc2VCdXR0b25BcmlhTGFiZWwnLCAnY2xvc2VCdXR0b25IdG1sJywgJ2NvbG9yJywgJ2NvbmZpcm1CdXR0b25BcmlhTGFiZWwnLCAnY29uZmlybUJ1dHRvbkNvbG9yJywgJ2NvbmZpcm1CdXR0b25UZXh0JywgJ2N1cnJlbnRQcm9ncmVzc1N0ZXAnLCAnY3VzdG9tQ2xhc3MnLCAnZGVueUJ1dHRvbkFyaWFMYWJlbCcsICdkZW55QnV0dG9uQ29sb3InLCAnZGVueUJ1dHRvblRleHQnLCAnZGlkQ2xvc2UnLCAnZGlkRGVzdHJveScsICdmb290ZXInLCAnaGlkZUNsYXNzJywgJ2h0bWwnLCAnaWNvbicsICdpY29uQ29sb3InLCAnaWNvbkh0bWwnLCAnaW1hZ2VBbHQnLCAnaW1hZ2VIZWlnaHQnLCAnaW1hZ2VVcmwnLCAnaW1hZ2VXaWR0aCcsICdwcmVDb25maXJtJywgJ3ByZURlbnknLCAncHJvZ3Jlc3NTdGVwcycsICdyZXR1cm5Gb2N1cycsICdyZXZlcnNlQnV0dG9ucycsICdzaG93Q2FuY2VsQnV0dG9uJywgJ3Nob3dDbG9zZUJ1dHRvbicsICdzaG93Q29uZmlybUJ1dHRvbicsICdzaG93RGVueUJ1dHRvbicsICd0ZXh0JywgJ3RpdGxlJywgJ3RpdGxlVGV4dCcsICd3aWxsQ2xvc2UnXTtcbiAgY29uc3QgZGVwcmVjYXRlZFBhcmFtcyA9IHt9O1xuICBjb25zdCB0b2FzdEluY29tcGF0aWJsZVBhcmFtcyA9IFsnYWxsb3dPdXRzaWRlQ2xpY2snLCAnYWxsb3dFbnRlcktleScsICdiYWNrZHJvcCcsICdmb2N1c0NvbmZpcm0nLCAnZm9jdXNEZW55JywgJ2ZvY3VzQ2FuY2VsJywgJ3JldHVybkZvY3VzJywgJ2hlaWdodEF1dG8nLCAna2V5ZG93bkxpc3RlbmVyQ2FwdHVyZSddO1xuICAvKipcbiAgICogSXMgdmFsaWQgcGFyYW1ldGVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbU5hbWVcbiAgICovXG5cbiAgY29uc3QgaXNWYWxpZFBhcmFtZXRlciA9IHBhcmFtTmFtZSA9PiB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkZWZhdWx0UGFyYW1zLCBwYXJhbU5hbWUpO1xuICB9O1xuICAvKipcbiAgICogSXMgdmFsaWQgcGFyYW1ldGVyIGZvciBTd2FsLnVwZGF0ZSgpIG1ldGhvZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1OYW1lXG4gICAqL1xuXG4gIGNvbnN0IGlzVXBkYXRhYmxlUGFyYW1ldGVyID0gcGFyYW1OYW1lID0+IHtcbiAgICByZXR1cm4gdXBkYXRhYmxlUGFyYW1zLmluZGV4T2YocGFyYW1OYW1lKSAhPT0gLTE7XG4gIH07XG4gIC8qKlxuICAgKiBJcyBkZXByZWNhdGVkIHBhcmFtZXRlclxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1OYW1lXG4gICAqL1xuXG4gIGNvbnN0IGlzRGVwcmVjYXRlZFBhcmFtZXRlciA9IHBhcmFtTmFtZSA9PiB7XG4gICAgcmV0dXJuIGRlcHJlY2F0ZWRQYXJhbXNbcGFyYW1OYW1lXTtcbiAgfTtcblxuICBjb25zdCBjaGVja0lmUGFyYW1Jc1ZhbGlkID0gcGFyYW0gPT4ge1xuICAgIGlmICghaXNWYWxpZFBhcmFtZXRlcihwYXJhbSkpIHtcbiAgICAgIHdhcm4oXCJVbmtub3duIHBhcmFtZXRlciBcXFwiXCIuY29uY2F0KHBhcmFtLCBcIlxcXCJcIikpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBjaGVja0lmVG9hc3RQYXJhbUlzVmFsaWQgPSBwYXJhbSA9PiB7XG4gICAgaWYgKHRvYXN0SW5jb21wYXRpYmxlUGFyYW1zLmluY2x1ZGVzKHBhcmFtKSkge1xuICAgICAgd2FybihcIlRoZSBwYXJhbWV0ZXIgXFxcIlwiLmNvbmNhdChwYXJhbSwgXCJcXFwiIGlzIGluY29tcGF0aWJsZSB3aXRoIHRvYXN0c1wiKSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGNoZWNrSWZQYXJhbUlzRGVwcmVjYXRlZCA9IHBhcmFtID0+IHtcbiAgICBpZiAoaXNEZXByZWNhdGVkUGFyYW1ldGVyKHBhcmFtKSkge1xuICAgICAgd2FybkFib3V0RGVwcmVjYXRpb24ocGFyYW0sIGlzRGVwcmVjYXRlZFBhcmFtZXRlcihwYXJhbSkpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIFNob3cgcmVsZXZhbnQgd2FybmluZ3MgZm9yIGdpdmVuIHBhcmFtc1xuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqL1xuXG5cbiAgY29uc3Qgc2hvd1dhcm5pbmdzRm9yUGFyYW1zID0gcGFyYW1zID0+IHtcbiAgICBpZiAoIXBhcmFtcy5iYWNrZHJvcCAmJiBwYXJhbXMuYWxsb3dPdXRzaWRlQ2xpY2spIHtcbiAgICAgIHdhcm4oJ1wiYWxsb3dPdXRzaWRlQ2xpY2tcIiBwYXJhbWV0ZXIgcmVxdWlyZXMgYGJhY2tkcm9wYCBwYXJhbWV0ZXIgdG8gYmUgc2V0IHRvIGB0cnVlYCcpO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgcGFyYW0gaW4gcGFyYW1zKSB7XG4gICAgICBjaGVja0lmUGFyYW1Jc1ZhbGlkKHBhcmFtKTtcblxuICAgICAgaWYgKHBhcmFtcy50b2FzdCkge1xuICAgICAgICBjaGVja0lmVG9hc3RQYXJhbUlzVmFsaWQocGFyYW0pO1xuICAgICAgfVxuXG4gICAgICBjaGVja0lmUGFyYW1Jc0RlcHJlY2F0ZWQocGFyYW0pO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBzd2FsUHJlZml4ID0gJ3N3YWwyLSc7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBpdGVtc1xuICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgKi9cblxuICBjb25zdCBwcmVmaXggPSBpdGVtcyA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG5cbiAgICBmb3IgKGNvbnN0IGkgaW4gaXRlbXMpIHtcbiAgICAgIHJlc3VsdFtpdGVtc1tpXV0gPSBzd2FsUHJlZml4ICsgaXRlbXNbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgY29uc3Qgc3dhbENsYXNzZXMgPSBwcmVmaXgoWydjb250YWluZXInLCAnc2hvd24nLCAnaGVpZ2h0LWF1dG8nLCAnaW9zZml4JywgJ3BvcHVwJywgJ21vZGFsJywgJ25vLWJhY2tkcm9wJywgJ25vLXRyYW5zaXRpb24nLCAndG9hc3QnLCAndG9hc3Qtc2hvd24nLCAnc2hvdycsICdoaWRlJywgJ2Nsb3NlJywgJ3RpdGxlJywgJ2h0bWwtY29udGFpbmVyJywgJ2FjdGlvbnMnLCAnY29uZmlybScsICdkZW55JywgJ2NhbmNlbCcsICdkZWZhdWx0LW91dGxpbmUnLCAnZm9vdGVyJywgJ2ljb24nLCAnaWNvbi1jb250ZW50JywgJ2ltYWdlJywgJ2lucHV0JywgJ2ZpbGUnLCAncmFuZ2UnLCAnc2VsZWN0JywgJ3JhZGlvJywgJ2NoZWNrYm94JywgJ2xhYmVsJywgJ3RleHRhcmVhJywgJ2lucHV0ZXJyb3InLCAnaW5wdXQtbGFiZWwnLCAndmFsaWRhdGlvbi1tZXNzYWdlJywgJ3Byb2dyZXNzLXN0ZXBzJywgJ2FjdGl2ZS1wcm9ncmVzcy1zdGVwJywgJ3Byb2dyZXNzLXN0ZXAnLCAncHJvZ3Jlc3Mtc3RlcC1saW5lJywgJ2xvYWRlcicsICdsb2FkaW5nJywgJ3N0eWxlZCcsICd0b3AnLCAndG9wLXN0YXJ0JywgJ3RvcC1lbmQnLCAndG9wLWxlZnQnLCAndG9wLXJpZ2h0JywgJ2NlbnRlcicsICdjZW50ZXItc3RhcnQnLCAnY2VudGVyLWVuZCcsICdjZW50ZXItbGVmdCcsICdjZW50ZXItcmlnaHQnLCAnYm90dG9tJywgJ2JvdHRvbS1zdGFydCcsICdib3R0b20tZW5kJywgJ2JvdHRvbS1sZWZ0JywgJ2JvdHRvbS1yaWdodCcsICdncm93LXJvdycsICdncm93LWNvbHVtbicsICdncm93LWZ1bGxzY3JlZW4nLCAncnRsJywgJ3RpbWVyLXByb2dyZXNzLWJhcicsICd0aW1lci1wcm9ncmVzcy1iYXItY29udGFpbmVyJywgJ3Njcm9sbGJhci1tZWFzdXJlJywgJ2ljb24tc3VjY2VzcycsICdpY29uLXdhcm5pbmcnLCAnaWNvbi1pbmZvJywgJ2ljb24tcXVlc3Rpb24nLCAnaWNvbi1lcnJvcicsICduby13YXInXSk7XG4gIGNvbnN0IGljb25UeXBlcyA9IHByZWZpeChbJ3N1Y2Nlc3MnLCAnd2FybmluZycsICdpbmZvJywgJ3F1ZXN0aW9uJywgJ2Vycm9yJ10pO1xuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBwb3B1cCBjb250YWluZXIgd2hpY2ggY29udGFpbnMgdGhlIGJhY2tkcm9wIGFuZCB0aGUgcG9wdXAgaXRzZWxmLlxuICAgKlxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCBudWxsfVxuICAgKi9cblxuICBjb25zdCBnZXRDb250YWluZXIgPSAoKSA9PiBkb2N1bWVudC5ib2R5LnF1ZXJ5U2VsZWN0b3IoXCIuXCIuY29uY2F0KHN3YWxDbGFzc2VzLmNvbnRhaW5lcikpO1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yU3RyaW5nXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudCB8IG51bGx9XG4gICAqL1xuXG4gIGNvbnN0IGVsZW1lbnRCeVNlbGVjdG9yID0gc2VsZWN0b3JTdHJpbmcgPT4ge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IGdldENvbnRhaW5lcigpO1xuICAgIHJldHVybiBjb250YWluZXIgPyBjb250YWluZXIucXVlcnlTZWxlY3RvcihzZWxlY3RvclN0cmluZykgOiBudWxsO1xuICB9O1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCBudWxsfVxuICAgKi9cblxuICBjb25zdCBlbGVtZW50QnlDbGFzcyA9IGNsYXNzTmFtZSA9PiB7XG4gICAgcmV0dXJuIGVsZW1lbnRCeVNlbGVjdG9yKFwiLlwiLmNvbmNhdChjbGFzc05hbWUpKTtcbiAgfTtcbiAgLyoqXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudCB8IG51bGx9XG4gICAqL1xuXG5cbiAgY29uc3QgZ2V0UG9wdXAgPSAoKSA9PiBlbGVtZW50QnlDbGFzcyhzd2FsQ2xhc3Nlcy5wb3B1cCk7XG4gIC8qKlxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCBudWxsfVxuICAgKi9cblxuICBjb25zdCBnZXRJY29uID0gKCkgPT4gZWxlbWVudEJ5Q2xhc3Moc3dhbENsYXNzZXMuaWNvbik7XG4gIC8qKlxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCBudWxsfVxuICAgKi9cblxuICBjb25zdCBnZXRUaXRsZSA9ICgpID0+IGVsZW1lbnRCeUNsYXNzKHN3YWxDbGFzc2VzLnRpdGxlKTtcbiAgLyoqXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudCB8IG51bGx9XG4gICAqL1xuXG4gIGNvbnN0IGdldEh0bWxDb250YWluZXIgPSAoKSA9PiBlbGVtZW50QnlDbGFzcyhzd2FsQ2xhc3Nlc1snaHRtbC1jb250YWluZXInXSk7XG4gIC8qKlxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCBudWxsfVxuICAgKi9cblxuICBjb25zdCBnZXRJbWFnZSA9ICgpID0+IGVsZW1lbnRCeUNsYXNzKHN3YWxDbGFzc2VzLmltYWdlKTtcbiAgLyoqXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudCB8IG51bGx9XG4gICAqL1xuXG4gIGNvbnN0IGdldFByb2dyZXNzU3RlcHMgPSAoKSA9PiBlbGVtZW50QnlDbGFzcyhzd2FsQ2xhc3Nlc1sncHJvZ3Jlc3Mtc3RlcHMnXSk7XG4gIC8qKlxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCBudWxsfVxuICAgKi9cblxuICBjb25zdCBnZXRWYWxpZGF0aW9uTWVzc2FnZSA9ICgpID0+IGVsZW1lbnRCeUNsYXNzKHN3YWxDbGFzc2VzWyd2YWxpZGF0aW9uLW1lc3NhZ2UnXSk7XG4gIC8qKlxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCBudWxsfVxuICAgKi9cblxuICBjb25zdCBnZXRDb25maXJtQnV0dG9uID0gKCkgPT4gZWxlbWVudEJ5U2VsZWN0b3IoXCIuXCIuY29uY2F0KHN3YWxDbGFzc2VzLmFjdGlvbnMsIFwiIC5cIikuY29uY2F0KHN3YWxDbGFzc2VzLmNvbmZpcm0pKTtcbiAgLyoqXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudCB8IG51bGx9XG4gICAqL1xuXG4gIGNvbnN0IGdldERlbnlCdXR0b24gPSAoKSA9PiBlbGVtZW50QnlTZWxlY3RvcihcIi5cIi5jb25jYXQoc3dhbENsYXNzZXMuYWN0aW9ucywgXCIgLlwiKS5jb25jYXQoc3dhbENsYXNzZXMuZGVueSkpO1xuICAvKipcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50IHwgbnVsbH1cbiAgICovXG5cbiAgY29uc3QgZ2V0SW5wdXRMYWJlbCA9ICgpID0+IGVsZW1lbnRCeUNsYXNzKHN3YWxDbGFzc2VzWydpbnB1dC1sYWJlbCddKTtcbiAgLyoqXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudCB8IG51bGx9XG4gICAqL1xuXG4gIGNvbnN0IGdldExvYWRlciA9ICgpID0+IGVsZW1lbnRCeVNlbGVjdG9yKFwiLlwiLmNvbmNhdChzd2FsQ2xhc3Nlcy5sb2FkZXIpKTtcbiAgLyoqXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudCB8IG51bGx9XG4gICAqL1xuXG4gIGNvbnN0IGdldENhbmNlbEJ1dHRvbiA9ICgpID0+IGVsZW1lbnRCeVNlbGVjdG9yKFwiLlwiLmNvbmNhdChzd2FsQ2xhc3Nlcy5hY3Rpb25zLCBcIiAuXCIpLmNvbmNhdChzd2FsQ2xhc3Nlcy5jYW5jZWwpKTtcbiAgLyoqXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudCB8IG51bGx9XG4gICAqL1xuXG4gIGNvbnN0IGdldEFjdGlvbnMgPSAoKSA9PiBlbGVtZW50QnlDbGFzcyhzd2FsQ2xhc3Nlcy5hY3Rpb25zKTtcbiAgLyoqXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudCB8IG51bGx9XG4gICAqL1xuXG4gIGNvbnN0IGdldEZvb3RlciA9ICgpID0+IGVsZW1lbnRCeUNsYXNzKHN3YWxDbGFzc2VzLmZvb3Rlcik7XG4gIC8qKlxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCBudWxsfVxuICAgKi9cblxuICBjb25zdCBnZXRUaW1lclByb2dyZXNzQmFyID0gKCkgPT4gZWxlbWVudEJ5Q2xhc3Moc3dhbENsYXNzZXNbJ3RpbWVyLXByb2dyZXNzLWJhciddKTtcbiAgLyoqXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudCB8IG51bGx9XG4gICAqL1xuXG4gIGNvbnN0IGdldENsb3NlQnV0dG9uID0gKCkgPT4gZWxlbWVudEJ5Q2xhc3Moc3dhbENsYXNzZXMuY2xvc2UpOyAvLyBodHRwczovL2dpdGh1Yi5jb20vamt1cC9mb2N1c2FibGUvYmxvYi9tYXN0ZXIvaW5kZXguanNcblxuICBjb25zdCBmb2N1c2FibGUgPSBcIlxcbiAgYVtocmVmXSxcXG4gIGFyZWFbaHJlZl0sXFxuICBpbnB1dDpub3QoW2Rpc2FibGVkXSksXFxuICBzZWxlY3Q6bm90KFtkaXNhYmxlZF0pLFxcbiAgdGV4dGFyZWE6bm90KFtkaXNhYmxlZF0pLFxcbiAgYnV0dG9uOm5vdChbZGlzYWJsZWRdKSxcXG4gIGlmcmFtZSxcXG4gIG9iamVjdCxcXG4gIGVtYmVkLFxcbiAgW3RhYmluZGV4PVxcXCIwXFxcIl0sXFxuICBbY29udGVudGVkaXRhYmxlXSxcXG4gIGF1ZGlvW2NvbnRyb2xzXSxcXG4gIHZpZGVvW2NvbnRyb2xzXSxcXG4gIHN1bW1hcnlcXG5cIjtcbiAgLyoqXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudFtdfVxuICAgKi9cblxuICBjb25zdCBnZXRGb2N1c2FibGVFbGVtZW50cyA9ICgpID0+IHtcbiAgICBjb25zdCBmb2N1c2FibGVFbGVtZW50c1dpdGhUYWJpbmRleCA9IHRvQXJyYXkoZ2V0UG9wdXAoKS5xdWVyeVNlbGVjdG9yQWxsKCdbdGFiaW5kZXhdOm5vdChbdGFiaW5kZXg9XCItMVwiXSk6bm90KFt0YWJpbmRleD1cIjBcIl0pJykpIC8vIHNvcnQgYWNjb3JkaW5nIHRvIHRhYmluZGV4XG4gICAgLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgIGNvbnN0IHRhYmluZGV4QSA9IHBhcnNlSW50KGEuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpKTtcbiAgICAgIGNvbnN0IHRhYmluZGV4QiA9IHBhcnNlSW50KGIuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpKTtcblxuICAgICAgaWYgKHRhYmluZGV4QSA+IHRhYmluZGV4Qikge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH0gZWxzZSBpZiAodGFiaW5kZXhBIDwgdGFiaW5kZXhCKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDA7XG4gICAgfSk7XG4gICAgY29uc3Qgb3RoZXJGb2N1c2FibGVFbGVtZW50cyA9IHRvQXJyYXkoZ2V0UG9wdXAoKS5xdWVyeVNlbGVjdG9yQWxsKGZvY3VzYWJsZSkpLmZpbHRlcihlbCA9PiBlbC5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JykgIT09ICctMScpO1xuICAgIHJldHVybiB1bmlxdWVBcnJheShmb2N1c2FibGVFbGVtZW50c1dpdGhUYWJpbmRleC5jb25jYXQob3RoZXJGb2N1c2FibGVFbGVtZW50cykpLmZpbHRlcihlbCA9PiBpc1Zpc2libGUoZWwpKTtcbiAgfTtcbiAgLyoqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cblxuICBjb25zdCBpc01vZGFsID0gKCkgPT4ge1xuICAgIHJldHVybiBoYXNDbGFzcyhkb2N1bWVudC5ib2R5LCBzd2FsQ2xhc3Nlcy5zaG93bikgJiYgIWhhc0NsYXNzKGRvY3VtZW50LmJvZHksIHN3YWxDbGFzc2VzWyd0b2FzdC1zaG93biddKSAmJiAhaGFzQ2xhc3MoZG9jdW1lbnQuYm9keSwgc3dhbENsYXNzZXNbJ25vLWJhY2tkcm9wJ10pO1xuICB9O1xuICAvKipcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuXG4gIGNvbnN0IGlzVG9hc3QgPSAoKSA9PiB7XG4gICAgcmV0dXJuIGdldFBvcHVwKCkgJiYgaGFzQ2xhc3MoZ2V0UG9wdXAoKSwgc3dhbENsYXNzZXMudG9hc3QpO1xuICB9O1xuICAvKipcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuXG4gIGNvbnN0IGlzTG9hZGluZyA9ICgpID0+IHtcbiAgICByZXR1cm4gZ2V0UG9wdXAoKS5oYXNBdHRyaWJ1dGUoJ2RhdGEtbG9hZGluZycpO1xuICB9O1xuXG4gIGNvbnN0IHN0YXRlcyA9IHtcbiAgICBwcmV2aW91c0JvZHlQYWRkaW5nOiBudWxsXG4gIH07XG4gIC8qKlxuICAgKiBTZWN1cmVseSBzZXQgaW5uZXJIVE1MIG9mIGFuIGVsZW1lbnRcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL3N3ZWV0YWxlcnQyL3N3ZWV0YWxlcnQyL2lzc3Vlcy8xOTI2XG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1cbiAgICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcbiAgICovXG5cbiAgY29uc3Qgc2V0SW5uZXJIdG1sID0gKGVsZW0sIGh0bWwpID0+IHtcbiAgICBlbGVtLnRleHRDb250ZW50ID0gJyc7XG5cbiAgICBpZiAoaHRtbCkge1xuICAgICAgY29uc3QgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhodG1sLCBcInRleHQvaHRtbFwiKTtcbiAgICAgIHRvQXJyYXkocGFyc2VkLnF1ZXJ5U2VsZWN0b3IoJ2hlYWQnKS5jaGlsZE5vZGVzKS5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgZWxlbS5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICB9KTtcbiAgICAgIHRvQXJyYXkocGFyc2VkLnF1ZXJ5U2VsZWN0b3IoJ2JvZHknKS5jaGlsZE5vZGVzKS5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgZWxlbS5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuXG4gIGNvbnN0IGhhc0NsYXNzID0gKGVsZW0sIGNsYXNzTmFtZSkgPT4ge1xuICAgIGlmICghY2xhc3NOYW1lKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgY2xhc3NMaXN0ID0gY2xhc3NOYW1lLnNwbGl0KC9cXHMrLyk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNsYXNzTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFlbGVtLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc0xpc3RbaV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1cbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gICAqL1xuXG4gIGNvbnN0IHJlbW92ZUN1c3RvbUNsYXNzZXMgPSAoZWxlbSwgcGFyYW1zKSA9PiB7XG4gICAgdG9BcnJheShlbGVtLmNsYXNzTGlzdCkuZm9yRWFjaChjbGFzc05hbWUgPT4ge1xuICAgICAgaWYgKCFPYmplY3QudmFsdWVzKHN3YWxDbGFzc2VzKS5pbmNsdWRlcyhjbGFzc05hbWUpICYmICFPYmplY3QudmFsdWVzKGljb25UeXBlcykuaW5jbHVkZXMoY2xhc3NOYW1lKSAmJiAhT2JqZWN0LnZhbHVlcyhwYXJhbXMuc2hvd0NsYXNzKS5pbmNsdWRlcyhjbGFzc05hbWUpKSB7XG4gICAgICAgIGVsZW0uY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbVxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKi9cblxuXG4gIGNvbnN0IGFwcGx5Q3VzdG9tQ2xhc3MgPSAoZWxlbSwgcGFyYW1zLCBjbGFzc05hbWUpID0+IHtcbiAgICByZW1vdmVDdXN0b21DbGFzc2VzKGVsZW0sIHBhcmFtcyk7XG5cbiAgICBpZiAocGFyYW1zLmN1c3RvbUNsYXNzICYmIHBhcmFtcy5jdXN0b21DbGFzc1tjbGFzc05hbWVdKSB7XG4gICAgICBpZiAodHlwZW9mIHBhcmFtcy5jdXN0b21DbGFzc1tjbGFzc05hbWVdICE9PSAnc3RyaW5nJyAmJiAhcGFyYW1zLmN1c3RvbUNsYXNzW2NsYXNzTmFtZV0uZm9yRWFjaCkge1xuICAgICAgICByZXR1cm4gd2FybihcIkludmFsaWQgdHlwZSBvZiBjdXN0b21DbGFzcy5cIi5jb25jYXQoY2xhc3NOYW1lLCBcIiEgRXhwZWN0ZWQgc3RyaW5nIG9yIGl0ZXJhYmxlIG9iamVjdCwgZ290IFxcXCJcIikuY29uY2F0KHR5cGVvZiBwYXJhbXMuY3VzdG9tQ2xhc3NbY2xhc3NOYW1lXSwgXCJcXFwiXCIpKTtcbiAgICAgIH1cblxuICAgICAgYWRkQ2xhc3MoZWxlbSwgcGFyYW1zLmN1c3RvbUNsYXNzW2NsYXNzTmFtZV0pO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHVwXG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuL3JlbmRlcmVycy9yZW5kZXJJbnB1dCcpLklucHV0Q2xhc3N9IGlucHV0Q2xhc3NcbiAgICogQHJldHVybnMge0hUTUxJbnB1dEVsZW1lbnQgfCBudWxsfVxuICAgKi9cblxuICBjb25zdCBnZXRJbnB1dCA9IChwb3B1cCwgaW5wdXRDbGFzcykgPT4ge1xuICAgIGlmICghaW5wdXRDbGFzcykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgc3dpdGNoIChpbnB1dENsYXNzKSB7XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgY2FzZSAnZmlsZSc6XG4gICAgICAgIHJldHVybiBwb3B1cC5xdWVyeVNlbGVjdG9yKFwiLlwiLmNvbmNhdChzd2FsQ2xhc3Nlcy5wb3B1cCwgXCIgPiAuXCIpLmNvbmNhdChzd2FsQ2xhc3Nlc1tpbnB1dENsYXNzXSkpO1xuXG4gICAgICBjYXNlICdjaGVja2JveCc6XG4gICAgICAgIHJldHVybiBwb3B1cC5xdWVyeVNlbGVjdG9yKFwiLlwiLmNvbmNhdChzd2FsQ2xhc3Nlcy5wb3B1cCwgXCIgPiAuXCIpLmNvbmNhdChzd2FsQ2xhc3Nlcy5jaGVja2JveCwgXCIgaW5wdXRcIikpO1xuXG4gICAgICBjYXNlICdyYWRpbyc6XG4gICAgICAgIHJldHVybiBwb3B1cC5xdWVyeVNlbGVjdG9yKFwiLlwiLmNvbmNhdChzd2FsQ2xhc3Nlcy5wb3B1cCwgXCIgPiAuXCIpLmNvbmNhdChzd2FsQ2xhc3Nlcy5yYWRpbywgXCIgaW5wdXQ6Y2hlY2tlZFwiKSkgfHwgcG9wdXAucXVlcnlTZWxlY3RvcihcIi5cIi5jb25jYXQoc3dhbENsYXNzZXMucG9wdXAsIFwiID4gLlwiKS5jb25jYXQoc3dhbENsYXNzZXMucmFkaW8sIFwiIGlucHV0OmZpcnN0LWNoaWxkXCIpKTtcblxuICAgICAgY2FzZSAncmFuZ2UnOlxuICAgICAgICByZXR1cm4gcG9wdXAucXVlcnlTZWxlY3RvcihcIi5cIi5jb25jYXQoc3dhbENsYXNzZXMucG9wdXAsIFwiID4gLlwiKS5jb25jYXQoc3dhbENsYXNzZXMucmFuZ2UsIFwiIGlucHV0XCIpKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHBvcHVwLnF1ZXJ5U2VsZWN0b3IoXCIuXCIuY29uY2F0KHN3YWxDbGFzc2VzLnBvcHVwLCBcIiA+IC5cIikuY29uY2F0KHN3YWxDbGFzc2VzLmlucHV0KSk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50IHwgSFRNTFRleHRBcmVhRWxlbWVudCB8IEhUTUxTZWxlY3RFbGVtZW50fSBpbnB1dFxuICAgKi9cblxuICBjb25zdCBmb2N1c0lucHV0ID0gaW5wdXQgPT4ge1xuICAgIGlucHV0LmZvY3VzKCk7IC8vIHBsYWNlIGN1cnNvciBhdCBlbmQgb2YgdGV4dCBpbiB0ZXh0IGlucHV0XG5cbiAgICBpZiAoaW5wdXQudHlwZSAhPT0gJ2ZpbGUnKSB7XG4gICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMzQ1OTE1XG4gICAgICBjb25zdCB2YWwgPSBpbnB1dC52YWx1ZTtcbiAgICAgIGlucHV0LnZhbHVlID0gJyc7XG4gICAgICBpbnB1dC52YWx1ZSA9IHZhbDtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50IHwgSFRNTEVsZW1lbnRbXSB8IG51bGx9IHRhcmdldFxuICAgKiBAcGFyYW0ge3N0cmluZyB8IHN0cmluZ1tdIHwgcmVhZG9ubHkgc3RyaW5nW119IGNsYXNzTGlzdFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNvbmRpdGlvblxuICAgKi9cblxuICBjb25zdCB0b2dnbGVDbGFzcyA9ICh0YXJnZXQsIGNsYXNzTGlzdCwgY29uZGl0aW9uKSA9PiB7XG4gICAgaWYgKCF0YXJnZXQgfHwgIWNsYXNzTGlzdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY2xhc3NMaXN0ID09PSAnc3RyaW5nJykge1xuICAgICAgY2xhc3NMaXN0ID0gY2xhc3NMaXN0LnNwbGl0KC9cXHMrLykuZmlsdGVyKEJvb2xlYW4pO1xuICAgIH1cblxuICAgIGNsYXNzTGlzdC5mb3JFYWNoKGNsYXNzTmFtZSA9PiB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgICAgIHRhcmdldC5mb3JFYWNoKGVsZW0gPT4ge1xuICAgICAgICAgIGNvbmRpdGlvbiA/IGVsZW0uY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpIDogZWxlbS5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uZGl0aW9uID8gdGFyZ2V0LmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKSA6IHRhcmdldC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50IHwgSFRNTEVsZW1lbnRbXSB8IG51bGx9IHRhcmdldFxuICAgKiBAcGFyYW0ge3N0cmluZyB8IHN0cmluZ1tdIHwgcmVhZG9ubHkgc3RyaW5nW119IGNsYXNzTGlzdFxuICAgKi9cblxuICBjb25zdCBhZGRDbGFzcyA9ICh0YXJnZXQsIGNsYXNzTGlzdCkgPT4ge1xuICAgIHRvZ2dsZUNsYXNzKHRhcmdldCwgY2xhc3NMaXN0LCB0cnVlKTtcbiAgfTtcbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnQgfCBIVE1MRWxlbWVudFtdIHwgbnVsbH0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgc3RyaW5nW10gfCByZWFkb25seSBzdHJpbmdbXX0gY2xhc3NMaXN0XG4gICAqL1xuXG4gIGNvbnN0IHJlbW92ZUNsYXNzID0gKHRhcmdldCwgY2xhc3NMaXN0KSA9PiB7XG4gICAgdG9nZ2xlQ2xhc3ModGFyZ2V0LCBjbGFzc0xpc3QsIGZhbHNlKTtcbiAgfTtcbiAgLyoqXG4gICAqIEdldCBkaXJlY3QgY2hpbGQgb2YgYW4gZWxlbWVudCBieSBjbGFzcyBuYW1lXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCBudWxsfVxuICAgKi9cblxuICBjb25zdCBnZXREaXJlY3RDaGlsZEJ5Q2xhc3MgPSAoZWxlbSwgY2xhc3NOYW1lKSA9PiB7XG4gICAgY29uc3QgY2hpbGROb2RlcyA9IHRvQXJyYXkoZWxlbS5jaGlsZE5vZGVzKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGhhc0NsYXNzKGNoaWxkTm9kZXNbaV0sIGNsYXNzTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkTm9kZXNbaV07XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKi9cblxuICBjb25zdCBhcHBseU51bWVyaWNhbFN0eWxlID0gKGVsZW0sIHByb3BlcnR5LCB2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PT0gXCJcIi5jb25jYXQocGFyc2VJbnQodmFsdWUpKSkge1xuICAgICAgdmFsdWUgPSBwYXJzZUludCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlIHx8IHBhcnNlSW50KHZhbHVlKSA9PT0gMCkge1xuICAgICAgZWxlbS5zdHlsZVtwcm9wZXJ0eV0gPSB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInID8gXCJcIi5jb25jYXQodmFsdWUsIFwicHhcIikgOiB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShwcm9wZXJ0eSk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGlzcGxheVxuICAgKi9cblxuICBjb25zdCBzaG93ID0gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICBsZXQgZGlzcGxheSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ2ZsZXgnO1xuICAgIGVsZW0uc3R5bGUuZGlzcGxheSA9IGRpc3BsYXk7XG4gIH07XG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtXG4gICAqL1xuXG4gIGNvbnN0IGhpZGUgPSBlbGVtID0+IHtcbiAgICBlbGVtLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIH07XG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICovXG5cbiAgY29uc3Qgc2V0U3R5bGUgPSAocGFyZW50LCBzZWxlY3RvciwgcHJvcGVydHksIHZhbHVlKSA9PiB7XG4gICAgLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi9cbiAgICBjb25zdCBlbCA9IHBhcmVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcblxuICAgIGlmIChlbCkge1xuICAgICAgZWwuc3R5bGVbcHJvcGVydHldID0gdmFsdWU7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbVxuICAgKiBAcGFyYW0ge2FueX0gY29uZGl0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwbGF5XG4gICAqL1xuXG4gIGNvbnN0IHRvZ2dsZSA9IGZ1bmN0aW9uIChlbGVtLCBjb25kaXRpb24pIHtcbiAgICBsZXQgZGlzcGxheSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogJ2ZsZXgnO1xuICAgIGNvbmRpdGlvbiA/IHNob3coZWxlbSwgZGlzcGxheSkgOiBoaWRlKGVsZW0pO1xuICB9O1xuICAvKipcbiAgICogYm9ycm93ZWQgZnJvbSBqcXVlcnkgJChlbGVtKS5pcygnOnZpc2libGUnKSBpbXBsZW1lbnRhdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cblxuICBjb25zdCBpc1Zpc2libGUgPSBlbGVtID0+ICEhKGVsZW0gJiYgKGVsZW0ub2Zmc2V0V2lkdGggfHwgZWxlbS5vZmZzZXRIZWlnaHQgfHwgZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCkpO1xuICAvKipcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuXG4gIGNvbnN0IGFsbEJ1dHRvbnNBcmVIaWRkZW4gPSAoKSA9PiAhaXNWaXNpYmxlKGdldENvbmZpcm1CdXR0b24oKSkgJiYgIWlzVmlzaWJsZShnZXREZW55QnV0dG9uKCkpICYmICFpc1Zpc2libGUoZ2V0Q2FuY2VsQnV0dG9uKCkpO1xuICAvKipcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuXG4gIGNvbnN0IGlzU2Nyb2xsYWJsZSA9IGVsZW0gPT4gISEoZWxlbS5zY3JvbGxIZWlnaHQgPiBlbGVtLmNsaWVudEhlaWdodCk7XG4gIC8qKlxuICAgKiBib3Jyb3dlZCBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80NjM1MjExOVxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cblxuICBjb25zdCBoYXNDc3NBbmltYXRpb24gPSBlbGVtID0+IHtcbiAgICBjb25zdCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW0pO1xuICAgIGNvbnN0IGFuaW1EdXJhdGlvbiA9IHBhcnNlRmxvYXQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnYW5pbWF0aW9uLWR1cmF0aW9uJykgfHwgJzAnKTtcbiAgICBjb25zdCB0cmFuc0R1cmF0aW9uID0gcGFyc2VGbG9hdChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCd0cmFuc2l0aW9uLWR1cmF0aW9uJykgfHwgJzAnKTtcbiAgICByZXR1cm4gYW5pbUR1cmF0aW9uID4gMCB8fCB0cmFuc0R1cmF0aW9uID4gMDtcbiAgfTtcbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlc2V0XG4gICAqL1xuXG4gIGNvbnN0IGFuaW1hdGVUaW1lclByb2dyZXNzQmFyID0gZnVuY3Rpb24gKHRpbWVyKSB7XG4gICAgbGV0IHJlc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICBjb25zdCB0aW1lclByb2dyZXNzQmFyID0gZ2V0VGltZXJQcm9ncmVzc0JhcigpO1xuXG4gICAgaWYgKGlzVmlzaWJsZSh0aW1lclByb2dyZXNzQmFyKSkge1xuICAgICAgaWYgKHJlc2V0KSB7XG4gICAgICAgIHRpbWVyUHJvZ3Jlc3NCYXIuc3R5bGUudHJhbnNpdGlvbiA9ICdub25lJztcbiAgICAgICAgdGltZXJQcm9ncmVzc0Jhci5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICAgIH1cblxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRpbWVyUHJvZ3Jlc3NCYXIuc3R5bGUudHJhbnNpdGlvbiA9IFwid2lkdGggXCIuY29uY2F0KHRpbWVyIC8gMTAwMCwgXCJzIGxpbmVhclwiKTtcbiAgICAgICAgdGltZXJQcm9ncmVzc0Jhci5zdHlsZS53aWR0aCA9ICcwJSc7XG4gICAgICB9LCAxMCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBzdG9wVGltZXJQcm9ncmVzc0JhciA9ICgpID0+IHtcbiAgICBjb25zdCB0aW1lclByb2dyZXNzQmFyID0gZ2V0VGltZXJQcm9ncmVzc0JhcigpO1xuICAgIGNvbnN0IHRpbWVyUHJvZ3Jlc3NCYXJXaWR0aCA9IHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRpbWVyUHJvZ3Jlc3NCYXIpLndpZHRoKTtcbiAgICB0aW1lclByb2dyZXNzQmFyLnN0eWxlLnJlbW92ZVByb3BlcnR5KCd0cmFuc2l0aW9uJyk7XG4gICAgdGltZXJQcm9ncmVzc0Jhci5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICBjb25zdCB0aW1lclByb2dyZXNzQmFyRnVsbFdpZHRoID0gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUodGltZXJQcm9ncmVzc0Jhcikud2lkdGgpO1xuICAgIGNvbnN0IHRpbWVyUHJvZ3Jlc3NCYXJQZXJjZW50ID0gdGltZXJQcm9ncmVzc0JhcldpZHRoIC8gdGltZXJQcm9ncmVzc0JhckZ1bGxXaWR0aCAqIDEwMDtcbiAgICB0aW1lclByb2dyZXNzQmFyLnN0eWxlLnJlbW92ZVByb3BlcnR5KCd0cmFuc2l0aW9uJyk7XG4gICAgdGltZXJQcm9ncmVzc0Jhci5zdHlsZS53aWR0aCA9IFwiXCIuY29uY2F0KHRpbWVyUHJvZ3Jlc3NCYXJQZXJjZW50LCBcIiVcIik7XG4gIH07XG5cbiAgLyoqXG4gICAqIERldGVjdCBOb2RlIGVudlxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGNvbnN0IGlzTm9kZUVudiA9ICgpID0+IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCc7XG5cbiAgY29uc3QgUkVTVE9SRV9GT0NVU19USU1FT1VUID0gMTAwO1xuXG4gIC8qKiBAdHlwZSB7R2xvYmFsU3RhdGV9ICovXG5cbiAgY29uc3QgZ2xvYmFsU3RhdGUgPSB7fTtcblxuICBjb25zdCBmb2N1c1ByZXZpb3VzQWN0aXZlRWxlbWVudCA9ICgpID0+IHtcbiAgICBpZiAoZ2xvYmFsU3RhdGUucHJldmlvdXNBY3RpdmVFbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgIGdsb2JhbFN0YXRlLnByZXZpb3VzQWN0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgICAgZ2xvYmFsU3RhdGUucHJldmlvdXNBY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50LmJvZHkpIHtcbiAgICAgIGRvY3VtZW50LmJvZHkuZm9jdXMoKTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBSZXN0b3JlIHByZXZpb3VzIGFjdGl2ZSAoZm9jdXNlZCkgZWxlbWVudFxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJldHVybkZvY3VzXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cblxuXG4gIGNvbnN0IHJlc3RvcmVBY3RpdmVFbGVtZW50ID0gcmV0dXJuRm9jdXMgPT4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGlmICghcmV0dXJuRm9jdXMpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgeCA9IHdpbmRvdy5zY3JvbGxYO1xuICAgICAgY29uc3QgeSA9IHdpbmRvdy5zY3JvbGxZO1xuICAgICAgZ2xvYmFsU3RhdGUucmVzdG9yZUZvY3VzVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBmb2N1c1ByZXZpb3VzQWN0aXZlRWxlbWVudCgpO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9LCBSRVNUT1JFX0ZPQ1VTX1RJTUVPVVQpOyAvLyBpc3N1ZXMvOTAwXG5cbiAgICAgIHdpbmRvdy5zY3JvbGxUbyh4LCB5KTtcbiAgICB9KTtcbiAgfTtcblxuICBjb25zdCBzd2VldEhUTUwgPSBcIlxcbiA8ZGl2IGFyaWEtbGFiZWxsZWRieT1cXFwiXCIuY29uY2F0KHN3YWxDbGFzc2VzLnRpdGxlLCBcIlxcXCIgYXJpYS1kZXNjcmliZWRieT1cXFwiXCIpLmNvbmNhdChzd2FsQ2xhc3Nlc1snaHRtbC1jb250YWluZXInXSwgXCJcXFwiIGNsYXNzPVxcXCJcIikuY29uY2F0KHN3YWxDbGFzc2VzLnBvcHVwLCBcIlxcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIj5cXG4gICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcIlwiKS5jb25jYXQoc3dhbENsYXNzZXMuY2xvc2UsIFwiXFxcIj48L2J1dHRvbj5cXG4gICA8dWwgY2xhc3M9XFxcIlwiKS5jb25jYXQoc3dhbENsYXNzZXNbJ3Byb2dyZXNzLXN0ZXBzJ10sIFwiXFxcIj48L3VsPlxcbiAgIDxkaXYgY2xhc3M9XFxcIlwiKS5jb25jYXQoc3dhbENsYXNzZXMuaWNvbiwgXCJcXFwiPjwvZGl2PlxcbiAgIDxpbWcgY2xhc3M9XFxcIlwiKS5jb25jYXQoc3dhbENsYXNzZXMuaW1hZ2UsIFwiXFxcIiAvPlxcbiAgIDxoMiBjbGFzcz1cXFwiXCIpLmNvbmNhdChzd2FsQ2xhc3Nlcy50aXRsZSwgXCJcXFwiIGlkPVxcXCJcIikuY29uY2F0KHN3YWxDbGFzc2VzLnRpdGxlLCBcIlxcXCI+PC9oMj5cXG4gICA8ZGl2IGNsYXNzPVxcXCJcIikuY29uY2F0KHN3YWxDbGFzc2VzWydodG1sLWNvbnRhaW5lciddLCBcIlxcXCIgaWQ9XFxcIlwiKS5jb25jYXQoc3dhbENsYXNzZXNbJ2h0bWwtY29udGFpbmVyJ10sIFwiXFxcIj48L2Rpdj5cXG4gICA8aW5wdXQgY2xhc3M9XFxcIlwiKS5jb25jYXQoc3dhbENsYXNzZXMuaW5wdXQsIFwiXFxcIiAvPlxcbiAgIDxpbnB1dCB0eXBlPVxcXCJmaWxlXFxcIiBjbGFzcz1cXFwiXCIpLmNvbmNhdChzd2FsQ2xhc3Nlcy5maWxlLCBcIlxcXCIgLz5cXG4gICA8ZGl2IGNsYXNzPVxcXCJcIikuY29uY2F0KHN3YWxDbGFzc2VzLnJhbmdlLCBcIlxcXCI+XFxuICAgICA8aW5wdXQgdHlwZT1cXFwicmFuZ2VcXFwiIC8+XFxuICAgICA8b3V0cHV0Pjwvb3V0cHV0PlxcbiAgIDwvZGl2PlxcbiAgIDxzZWxlY3QgY2xhc3M9XFxcIlwiKS5jb25jYXQoc3dhbENsYXNzZXMuc2VsZWN0LCBcIlxcXCI+PC9zZWxlY3Q+XFxuICAgPGRpdiBjbGFzcz1cXFwiXCIpLmNvbmNhdChzd2FsQ2xhc3Nlcy5yYWRpbywgXCJcXFwiPjwvZGl2PlxcbiAgIDxsYWJlbCBmb3I9XFxcIlwiKS5jb25jYXQoc3dhbENsYXNzZXMuY2hlY2tib3gsIFwiXFxcIiBjbGFzcz1cXFwiXCIpLmNvbmNhdChzd2FsQ2xhc3Nlcy5jaGVja2JveCwgXCJcXFwiPlxcbiAgICAgPGlucHV0IHR5cGU9XFxcImNoZWNrYm94XFxcIiAvPlxcbiAgICAgPHNwYW4gY2xhc3M9XFxcIlwiKS5jb25jYXQoc3dhbENsYXNzZXMubGFiZWwsIFwiXFxcIj48L3NwYW4+XFxuICAgPC9sYWJlbD5cXG4gICA8dGV4dGFyZWEgY2xhc3M9XFxcIlwiKS5jb25jYXQoc3dhbENsYXNzZXMudGV4dGFyZWEsIFwiXFxcIj48L3RleHRhcmVhPlxcbiAgIDxkaXYgY2xhc3M9XFxcIlwiKS5jb25jYXQoc3dhbENsYXNzZXNbJ3ZhbGlkYXRpb24tbWVzc2FnZSddLCBcIlxcXCIgaWQ9XFxcIlwiKS5jb25jYXQoc3dhbENsYXNzZXNbJ3ZhbGlkYXRpb24tbWVzc2FnZSddLCBcIlxcXCI+PC9kaXY+XFxuICAgPGRpdiBjbGFzcz1cXFwiXCIpLmNvbmNhdChzd2FsQ2xhc3Nlcy5hY3Rpb25zLCBcIlxcXCI+XFxuICAgICA8ZGl2IGNsYXNzPVxcXCJcIikuY29uY2F0KHN3YWxDbGFzc2VzLmxvYWRlciwgXCJcXFwiPjwvZGl2PlxcbiAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJcIikuY29uY2F0KHN3YWxDbGFzc2VzLmNvbmZpcm0sIFwiXFxcIj48L2J1dHRvbj5cXG4gICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiXCIpLmNvbmNhdChzd2FsQ2xhc3Nlcy5kZW55LCBcIlxcXCI+PC9idXR0b24+XFxuICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcIlwiKS5jb25jYXQoc3dhbENsYXNzZXMuY2FuY2VsLCBcIlxcXCI+PC9idXR0b24+XFxuICAgPC9kaXY+XFxuICAgPGRpdiBjbGFzcz1cXFwiXCIpLmNvbmNhdChzd2FsQ2xhc3Nlcy5mb290ZXIsIFwiXFxcIj48L2Rpdj5cXG4gICA8ZGl2IGNsYXNzPVxcXCJcIikuY29uY2F0KHN3YWxDbGFzc2VzWyd0aW1lci1wcm9ncmVzcy1iYXItY29udGFpbmVyJ10sIFwiXFxcIj5cXG4gICAgIDxkaXYgY2xhc3M9XFxcIlwiKS5jb25jYXQoc3dhbENsYXNzZXNbJ3RpbWVyLXByb2dyZXNzLWJhciddLCBcIlxcXCI+PC9kaXY+XFxuICAgPC9kaXY+XFxuIDwvZGl2PlxcblwiKS5yZXBsYWNlKC8oXnxcXG4pXFxzKi9nLCAnJyk7XG4gIC8qKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG5cbiAgY29uc3QgcmVzZXRPbGRDb250YWluZXIgPSAoKSA9PiB7XG4gICAgY29uc3Qgb2xkQ29udGFpbmVyID0gZ2V0Q29udGFpbmVyKCk7XG5cbiAgICBpZiAoIW9sZENvbnRhaW5lcikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIG9sZENvbnRhaW5lci5yZW1vdmUoKTtcbiAgICByZW1vdmVDbGFzcyhbZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBkb2N1bWVudC5ib2R5XSwgW3N3YWxDbGFzc2VzWyduby1iYWNrZHJvcCddLCBzd2FsQ2xhc3Nlc1sndG9hc3Qtc2hvd24nXSwgc3dhbENsYXNzZXNbJ2hhcy1jb2x1bW4nXV0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIGNvbnN0IHJlc2V0VmFsaWRhdGlvbk1lc3NhZ2UgPSAoKSA9PiB7XG4gICAgZ2xvYmFsU3RhdGUuY3VycmVudEluc3RhbmNlLnJlc2V0VmFsaWRhdGlvbk1lc3NhZ2UoKTtcbiAgfTtcblxuICBjb25zdCBhZGRJbnB1dENoYW5nZUxpc3RlbmVycyA9ICgpID0+IHtcbiAgICBjb25zdCBwb3B1cCA9IGdldFBvcHVwKCk7XG4gICAgY29uc3QgaW5wdXQgPSBnZXREaXJlY3RDaGlsZEJ5Q2xhc3MocG9wdXAsIHN3YWxDbGFzc2VzLmlucHV0KTtcbiAgICBjb25zdCBmaWxlID0gZ2V0RGlyZWN0Q2hpbGRCeUNsYXNzKHBvcHVwLCBzd2FsQ2xhc3Nlcy5maWxlKTtcbiAgICAvKiogQHR5cGUge0hUTUxJbnB1dEVsZW1lbnR9ICovXG5cbiAgICBjb25zdCByYW5nZSA9IHBvcHVwLnF1ZXJ5U2VsZWN0b3IoXCIuXCIuY29uY2F0KHN3YWxDbGFzc2VzLnJhbmdlLCBcIiBpbnB1dFwiKSk7XG4gICAgLyoqIEB0eXBlIHtIVE1MT3V0cHV0RWxlbWVudH0gKi9cblxuICAgIGNvbnN0IHJhbmdlT3V0cHV0ID0gcG9wdXAucXVlcnlTZWxlY3RvcihcIi5cIi5jb25jYXQoc3dhbENsYXNzZXMucmFuZ2UsIFwiIG91dHB1dFwiKSk7XG4gICAgY29uc3Qgc2VsZWN0ID0gZ2V0RGlyZWN0Q2hpbGRCeUNsYXNzKHBvcHVwLCBzd2FsQ2xhc3Nlcy5zZWxlY3QpO1xuICAgIC8qKiBAdHlwZSB7SFRNTElucHV0RWxlbWVudH0gKi9cblxuICAgIGNvbnN0IGNoZWNrYm94ID0gcG9wdXAucXVlcnlTZWxlY3RvcihcIi5cIi5jb25jYXQoc3dhbENsYXNzZXMuY2hlY2tib3gsIFwiIGlucHV0XCIpKTtcbiAgICBjb25zdCB0ZXh0YXJlYSA9IGdldERpcmVjdENoaWxkQnlDbGFzcyhwb3B1cCwgc3dhbENsYXNzZXMudGV4dGFyZWEpO1xuICAgIGlucHV0Lm9uaW5wdXQgPSByZXNldFZhbGlkYXRpb25NZXNzYWdlO1xuICAgIGZpbGUub25jaGFuZ2UgPSByZXNldFZhbGlkYXRpb25NZXNzYWdlO1xuICAgIHNlbGVjdC5vbmNoYW5nZSA9IHJlc2V0VmFsaWRhdGlvbk1lc3NhZ2U7XG4gICAgY2hlY2tib3gub25jaGFuZ2UgPSByZXNldFZhbGlkYXRpb25NZXNzYWdlO1xuICAgIHRleHRhcmVhLm9uaW5wdXQgPSByZXNldFZhbGlkYXRpb25NZXNzYWdlO1xuXG4gICAgcmFuZ2Uub25pbnB1dCA9ICgpID0+IHtcbiAgICAgIHJlc2V0VmFsaWRhdGlvbk1lc3NhZ2UoKTtcbiAgICAgIHJhbmdlT3V0cHV0LnZhbHVlID0gcmFuZ2UudmFsdWU7XG4gICAgfTtcblxuICAgIHJhbmdlLm9uY2hhbmdlID0gKCkgPT4ge1xuICAgICAgcmVzZXRWYWxpZGF0aW9uTWVzc2FnZSgpO1xuICAgICAgcmFuZ2VPdXRwdXQudmFsdWUgPSByYW5nZS52YWx1ZTtcbiAgICB9O1xuICB9O1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmcgfCBIVE1MRWxlbWVudH0gdGFyZ2V0XG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH1cbiAgICovXG5cblxuICBjb25zdCBnZXRUYXJnZXQgPSB0YXJnZXQgPT4gdHlwZW9mIHRhcmdldCA9PT0gJ3N0cmluZycgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCkgOiB0YXJnZXQ7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAgICovXG5cblxuICBjb25zdCBzZXR1cEFjY2Vzc2liaWxpdHkgPSBwYXJhbXMgPT4ge1xuICAgIGNvbnN0IHBvcHVwID0gZ2V0UG9wdXAoKTtcbiAgICBwb3B1cC5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCBwYXJhbXMudG9hc3QgPyAnYWxlcnQnIDogJ2RpYWxvZycpO1xuICAgIHBvcHVwLnNldEF0dHJpYnV0ZSgnYXJpYS1saXZlJywgcGFyYW1zLnRvYXN0ID8gJ3BvbGl0ZScgOiAnYXNzZXJ0aXZlJyk7XG5cbiAgICBpZiAoIXBhcmFtcy50b2FzdCkge1xuICAgICAgcG9wdXAuc2V0QXR0cmlidXRlKCdhcmlhLW1vZGFsJywgJ3RydWUnKTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXRFbGVtZW50XG4gICAqL1xuXG5cbiAgY29uc3Qgc2V0dXBSVEwgPSB0YXJnZXRFbGVtZW50ID0+IHtcbiAgICBpZiAod2luZG93LmdldENvbXB1dGVkU3R5bGUodGFyZ2V0RWxlbWVudCkuZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgICAgYWRkQ2xhc3MoZ2V0Q29udGFpbmVyKCksIHN3YWxDbGFzc2VzLnJ0bCk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogQWRkIG1vZGFsICsgYmFja2Ryb3AgKyBuby13YXIgbWVzc2FnZSBmb3IgUnVzc2lhbnMgdG8gRE9NXG4gICAqXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICAgKi9cblxuXG4gIGNvbnN0IGluaXQgPSBwYXJhbXMgPT4ge1xuICAgIC8vIENsZWFuIHVwIHRoZSBvbGQgcG9wdXAgY29udGFpbmVyIGlmIGl0IGV4aXN0c1xuICAgIGNvbnN0IG9sZENvbnRhaW5lckV4aXN0ZWQgPSByZXNldE9sZENvbnRhaW5lcigpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuXG4gICAgaWYgKGlzTm9kZUVudigpKSB7XG4gICAgICBlcnJvcignU3dlZXRBbGVydDIgcmVxdWlyZXMgZG9jdW1lbnQgdG8gaW5pdGlhbGl6ZScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnRhaW5lci5jbGFzc05hbWUgPSBzd2FsQ2xhc3Nlcy5jb250YWluZXI7XG5cbiAgICBpZiAob2xkQ29udGFpbmVyRXhpc3RlZCkge1xuICAgICAgYWRkQ2xhc3MoY29udGFpbmVyLCBzd2FsQ2xhc3Nlc1snbm8tdHJhbnNpdGlvbiddKTtcbiAgICB9XG5cbiAgICBzZXRJbm5lckh0bWwoY29udGFpbmVyLCBzd2VldEhUTUwpO1xuICAgIGNvbnN0IHRhcmdldEVsZW1lbnQgPSBnZXRUYXJnZXQocGFyYW1zLnRhcmdldCk7XG4gICAgdGFyZ2V0RWxlbWVudC5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuICAgIHNldHVwQWNjZXNzaWJpbGl0eShwYXJhbXMpO1xuICAgIHNldHVwUlRMKHRhcmdldEVsZW1lbnQpO1xuICAgIGFkZElucHV0Q2hhbmdlTGlzdGVuZXJzKCk7XG4gICAgbm9XYXJNZXNzYWdlRm9yUnVzc2lhbnMoY29udGFpbmVyLCBwYXJhbXMpO1xuICB9O1xuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICAgKi9cblxuICBjb25zdCBub1dhck1lc3NhZ2VGb3JSdXNzaWFucyA9IChjb250YWluZXIsIHBhcmFtcykgPT4ge1xuICAgIGlmIChwYXJhbXMudG9hc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFRoaXMgbWVzc2FnZSBpcyB0YXJnZXRlZCBhdCBwZW9wbGUgd2hvIGFyZSBjb3JydXB0ZWQgYnkgcHJvcGFnYW5kYSwgZXZlcnlib2R5IGVsc2VcbiAgICAvLyBpcyBhbHJlYWR5IGFnYWluc3Qgd2FyIGVpdGhlciBzaWxlbnRseSBvciBhY3RpdmVseS5cbiAgICAvL1xuICAgIC8vIFRoZSBwb2ludCBpcyB0byB3cmFwIHRoZSB0cnV0aC1ib21iIGludG8gYSBwYXRyaW90aWMgdGl0bGUgc28gdGhleSB3aWxsIGFjdHVhbGx5IGNsaWNrIGl0XG4gICAgLy8gYW5kIGxpc3RlbiB0byB0aGUgdW5jb21mb3J0YWJsZSB0cnV0aCBhYm91dCB0aGUgd2FyIGZyb20gdGhlIHBlb3BsZSB0aGV5IGxvdmUgb3IgcmVzcGVjdC5cblxuXG4gICAgY29uc3QgbWVzc2FnZSA9IGdldFJhbmRvbUVsZW1lbnQoW3tcbiAgICAgIHRleHQ6ICfQqNCS0JDQoNCm0JXQndCV0JPQk9CV0KAg0L7QsdGA0LDRgtC40LvRgdGPIDxicj4g0Log0KDQo9Ch0KHQmtCe0JzQoyDQndCQ0KDQntCU0KMg0L4g0LLQvtC50L3QtScsXG4gICAgICAvLyBBcm5vbGQgaXMgbG92ZWQgaW4gUnVzc2lhIGJ5IGFsbCBwZW9wbGUgaW5jbHVkaW5nIHRob3NlIHdobyBhcmUgZm9yIHRoaXMgd2FyXG4gICAgICAvLyBIaXMgc3BlZWNoIG1pZ2h0IGNoYW5nZSB0aGUgbWluZCBvZiB0aG9zZSB3aG8gYXJlIGJyYWlud2FzaGVkIGJ5IHByb3BhZ2FuZGFcbiAgICAgIHlvdXR1YmVJZDogJ2ZXQ2xYWmQ5Yzc4J1xuICAgIH0sIHtcbiAgICAgIHRleHQ6ICfQoNCj0KHQodCa0JjQmSDQn9CQ0KLQoNCY0J7QoiA8YnI+INC+0YLQutGA0YvQuyDQs9C70LDQstC90YPRjiDRgtCw0LnQvdGDINGB0L/QtdGG0L7Qv9C10YDQsNGG0LjQuCcsXG4gICAgICAvLyBJbiB0aGlzIHZpZGVvIG9uZSBvZiB0aGUgbW9zdCBmYW1vdXMgUnVzc2lhbiBuYXRpb25hbGlzdCBsZWFkZXJzLCBEbWl0cnkgRGVtdXNoa2luLFxuICAgICAgLy8gZXhwbGFpbnMgdGhhdCB0aGlzIHdhciBoYXMgbm8gc2Vuc2UgYW5kIHByb2R1Y2VzIHRoZSBleGFjdCBvcHBvc2l0ZSByZXN1bHQgb2Ygd2hhdFxuICAgICAgLy8gaXQgd2FzIGludGVuZGVkIHRvIGRvLlxuICAgICAgeW91dHViZUlkOiAnX1JqQk5rbjg4eUEnXG4gICAgfSwge1xuICAgICAgdGV4dDogJ9CT0JXQoNCe0Jkg0J3QntCS0J7QoNCe0KHQodCY0Jgg0KHQotCg0JXQm9Ca0J7QkiA8YnI+INC00LDQuyDQvtGG0LXQvdC60YMg0YXQvtC00YMg0YHQv9C10YbQvtC/0LXRgNCw0YbQuNC4JyxcbiAgICAgIC8vIEluIHRoaXMgdmlkZW8gSWdvciBHaXJraW4sIHdobyBwbGF5ZWQgYSBrZXkgcm9sZSBpbiB0aGUgYW5uZXhhdGlvbiBvZiBDcmltZWEsXG4gICAgICAvLyBleHBsYWlucyB0aGF0IHRoaXMgd2FyIGhhcyBmYWlsZWQgYWxyZWFkeSBhbmQgYWxsIHBvc3NpYmxlIG91dGNvbWVzIGFyZSBiYWQgZm9yIFJ1c3NpYS5cbiAgICAgIHlvdXR1YmVJZDogJ3lVbXpRVDRDOEpZJ1xuICAgIH0sIHtcbiAgICAgIHRleHQ6ICfQpNCY0J3QodCa0JjQmSDQlNCg0KPQkyDQoNCe0KHQodCY0JggPGJyPiDQs9C+0LLQvtGA0LjRgiDQn9CeLdCg0KPQodCh0JrQmCDQviDRgdC/0LXRhtC+0L/QtdGA0LDRhtC40LgnLFxuICAgICAgeW91dHViZUlkOiAnaGtDWWI2ZWRVclEnXG4gICAgfSwge1xuICAgICAgdGV4dDogJ9Cu0KDQmNCZINCf0J7QlNCe0JvQr9Ca0JAg0YfQtdGB0YLQvdC+IDxicj4g0L4g0LPQtdC90LXRgNCw0LvQsNGFINCg0KPQodCh0JrQntCZINCQ0KDQnNCY0JgnLFxuICAgICAgeW91dHViZUlkOiAndzQtXzhCSktmcGsnXG4gICAgfSwge1xuICAgICAgdGV4dDogJ9Cf0L7Qu9C60L7QstC90LjQuiDQpNCh0JEg0KHQotCg0JXQm9Ca0J7QkiA8YnI+INC+0LEg0YPRgdC/0LXRhdCw0YUg0KDQntCh0KHQmNCYINCyINGB0L/QtdGG0L7Qv9C10YDQsNGG0LjQuCcsXG4gICAgICB5b3V0dWJlSWQ6ICdzYUs1VVRLcm9EQSdcbiAgICB9XSk7IC8vIFRoZSBtZXNzYWdlIHdpbGwgb25seSBiZSBzaG93biB0byBSdXNzaWFuIHVzZXJzIHZpc2l0aW5nIFJ1c3NpYW4gc2l0ZXNcblxuICAgIGlmIChuYXZpZ2F0b3IubGFuZ3VhZ2UgPT09ICdydScgJiYgbG9jYXRpb24uaG9zdC5tYXRjaCgvXFwuKHJ1fHN1fHhuLS1wMWFpKSQvKSkge1xuICAgICAgY29uc3Qgbm9XYXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIG5vV2FyLmNsYXNzTmFtZSA9IHN3YWxDbGFzc2VzWyduby13YXInXTtcbiAgICAgIHNldElubmVySHRtbChub1dhciwgXCI8YSBocmVmPVxcXCJodHRwczovL3d3dy55b3V0dWJlLmNvbS93YXRjaD92PVwiLmNvbmNhdChtZXNzYWdlLnlvdXR1YmVJZCwgXCJcXFwiIHRhcmdldD1cXFwiX2JsYW5rXFxcIj5cIikuY29uY2F0KG1lc3NhZ2UudGV4dCwgXCI8L2E+XCIpKTtcbiAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChub1dhcik7XG4gICAgICBjb250YWluZXIuc3R5bGUucGFkZGluZ1RvcCA9ICc0ZW0nO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudCB8IG9iamVjdCB8IHN0cmluZ30gcGFyYW1cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0XG4gICAqL1xuXG4gIGNvbnN0IHBhcnNlSHRtbFRvQ29udGFpbmVyID0gKHBhcmFtLCB0YXJnZXQpID0+IHtcbiAgICAvLyBET00gZWxlbWVudFxuICAgIGlmIChwYXJhbSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICB0YXJnZXQuYXBwZW5kQ2hpbGQocGFyYW0pO1xuICAgIH0gLy8gT2JqZWN0XG4gICAgZWxzZSBpZiAodHlwZW9mIHBhcmFtID09PSAnb2JqZWN0Jykge1xuICAgICAgaGFuZGxlT2JqZWN0KHBhcmFtLCB0YXJnZXQpO1xuICAgIH0gLy8gUGxhaW4gc3RyaW5nXG4gICAgZWxzZSBpZiAocGFyYW0pIHtcbiAgICAgIHNldElubmVySHRtbCh0YXJnZXQsIHBhcmFtKTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0XG4gICAqL1xuXG4gIGNvbnN0IGhhbmRsZU9iamVjdCA9IChwYXJhbSwgdGFyZ2V0KSA9PiB7XG4gICAgLy8gSlF1ZXJ5IGVsZW1lbnQocylcbiAgICBpZiAocGFyYW0uanF1ZXJ5KSB7XG4gICAgICBoYW5kbGVKcXVlcnlFbGVtKHRhcmdldCwgcGFyYW0pO1xuICAgIH0gLy8gRm9yIG90aGVyIG9iamVjdHMgdXNlIHRoZWlyIHN0cmluZyByZXByZXNlbnRhdGlvblxuICAgIGVsc2Uge1xuICAgICAgc2V0SW5uZXJIdG1sKHRhcmdldCwgcGFyYW0udG9TdHJpbmcoKSk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1cbiAgICovXG5cblxuICBjb25zdCBoYW5kbGVKcXVlcnlFbGVtID0gKHRhcmdldCwgZWxlbSkgPT4ge1xuICAgIHRhcmdldC50ZXh0Q29udGVudCA9ICcnO1xuXG4gICAgaWYgKDAgaW4gZWxlbSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IChpIGluIGVsZW0pOyBpKyspIHtcbiAgICAgICAgdGFyZ2V0LmFwcGVuZENoaWxkKGVsZW1baV0uY2xvbmVOb2RlKHRydWUpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGFyZ2V0LmFwcGVuZENoaWxkKGVsZW0uY2xvbmVOb2RlKHRydWUpKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHsnd2Via2l0QW5pbWF0aW9uRW5kJyB8ICdhbmltYXRpb25lbmQnIHwgZmFsc2V9XG4gICAqL1xuXG4gIGNvbnN0IGFuaW1hdGlvbkVuZEV2ZW50ID0gKCgpID0+IHtcbiAgICAvLyBQcmV2ZW50IHJ1biBpbiBOb2RlIGVudlxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzTm9kZUVudigpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgdGVzdEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29uc3QgdHJhbnNFbmRFdmVudE5hbWVzID0ge1xuICAgICAgV2Via2l0QW5pbWF0aW9uOiAnd2Via2l0QW5pbWF0aW9uRW5kJyxcbiAgICAgIC8vIENocm9tZSwgU2FmYXJpIGFuZCBPcGVyYVxuICAgICAgYW5pbWF0aW9uOiAnYW5pbWF0aW9uZW5kJyAvLyBTdGFuZGFyZCBzeW50YXhcblxuICAgIH07XG5cbiAgICBmb3IgKGNvbnN0IGkgaW4gdHJhbnNFbmRFdmVudE5hbWVzKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRyYW5zRW5kRXZlbnROYW1lcywgaSkgJiYgdHlwZW9mIHRlc3RFbC5zdHlsZVtpXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zRW5kRXZlbnROYW1lc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0pKCk7XG5cbiAgLyoqXG4gICAqIE1lYXN1cmUgc2Nyb2xsYmFyIHdpZHRoIGZvciBwYWRkaW5nIGJvZHkgZHVyaW5nIG1vZGFsIHNob3cvaGlkZVxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvanMvc3JjL21vZGFsLmpzXG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuXG4gIGNvbnN0IG1lYXN1cmVTY3JvbGxiYXIgPSAoKSA9PiB7XG4gICAgY29uc3Qgc2Nyb2xsRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgc2Nyb2xsRGl2LmNsYXNzTmFtZSA9IHN3YWxDbGFzc2VzWydzY3JvbGxiYXItbWVhc3VyZSddO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2Nyb2xsRGl2KTtcbiAgICBjb25zdCBzY3JvbGxiYXJXaWR0aCA9IHNjcm9sbERpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCAtIHNjcm9sbERpdi5jbGllbnRXaWR0aDtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHNjcm9sbERpdik7XG4gICAgcmV0dXJuIHNjcm9sbGJhcldpZHRoO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnQyfSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAgICovXG5cbiAgY29uc3QgcmVuZGVyQWN0aW9ucyA9IChpbnN0YW5jZSwgcGFyYW1zKSA9PiB7XG4gICAgY29uc3QgYWN0aW9ucyA9IGdldEFjdGlvbnMoKTtcbiAgICBjb25zdCBsb2FkZXIgPSBnZXRMb2FkZXIoKTsgLy8gQWN0aW9ucyAoYnV0dG9ucykgd3JhcHBlclxuXG4gICAgaWYgKCFwYXJhbXMuc2hvd0NvbmZpcm1CdXR0b24gJiYgIXBhcmFtcy5zaG93RGVueUJ1dHRvbiAmJiAhcGFyYW1zLnNob3dDYW5jZWxCdXR0b24pIHtcbiAgICAgIGhpZGUoYWN0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNob3coYWN0aW9ucyk7XG4gICAgfSAvLyBDdXN0b20gY2xhc3NcblxuXG4gICAgYXBwbHlDdXN0b21DbGFzcyhhY3Rpb25zLCBwYXJhbXMsICdhY3Rpb25zJyk7IC8vIFJlbmRlciBhbGwgdGhlIGJ1dHRvbnNcblxuICAgIHJlbmRlckJ1dHRvbnMoYWN0aW9ucywgbG9hZGVyLCBwYXJhbXMpOyAvLyBMb2FkZXJcblxuICAgIHNldElubmVySHRtbChsb2FkZXIsIHBhcmFtcy5sb2FkZXJIdG1sKTtcbiAgICBhcHBseUN1c3RvbUNsYXNzKGxvYWRlciwgcGFyYW1zLCAnbG9hZGVyJyk7XG4gIH07XG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBhY3Rpb25zXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGxvYWRlclxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAgICovXG5cbiAgZnVuY3Rpb24gcmVuZGVyQnV0dG9ucyhhY3Rpb25zLCBsb2FkZXIsIHBhcmFtcykge1xuICAgIGNvbnN0IGNvbmZpcm1CdXR0b24gPSBnZXRDb25maXJtQnV0dG9uKCk7XG4gICAgY29uc3QgZGVueUJ1dHRvbiA9IGdldERlbnlCdXR0b24oKTtcbiAgICBjb25zdCBjYW5jZWxCdXR0b24gPSBnZXRDYW5jZWxCdXR0b24oKTsgLy8gUmVuZGVyIGJ1dHRvbnNcblxuICAgIHJlbmRlckJ1dHRvbihjb25maXJtQnV0dG9uLCAnY29uZmlybScsIHBhcmFtcyk7XG4gICAgcmVuZGVyQnV0dG9uKGRlbnlCdXR0b24sICdkZW55JywgcGFyYW1zKTtcbiAgICByZW5kZXJCdXR0b24oY2FuY2VsQnV0dG9uLCAnY2FuY2VsJywgcGFyYW1zKTtcbiAgICBoYW5kbGVCdXR0b25zU3R5bGluZyhjb25maXJtQnV0dG9uLCBkZW55QnV0dG9uLCBjYW5jZWxCdXR0b24sIHBhcmFtcyk7XG5cbiAgICBpZiAocGFyYW1zLnJldmVyc2VCdXR0b25zKSB7XG4gICAgICBpZiAocGFyYW1zLnRvYXN0KSB7XG4gICAgICAgIGFjdGlvbnMuaW5zZXJ0QmVmb3JlKGNhbmNlbEJ1dHRvbiwgY29uZmlybUJ1dHRvbik7XG4gICAgICAgIGFjdGlvbnMuaW5zZXJ0QmVmb3JlKGRlbnlCdXR0b24sIGNvbmZpcm1CdXR0b24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0aW9ucy5pbnNlcnRCZWZvcmUoY2FuY2VsQnV0dG9uLCBsb2FkZXIpO1xuICAgICAgICBhY3Rpb25zLmluc2VydEJlZm9yZShkZW55QnV0dG9uLCBsb2FkZXIpO1xuICAgICAgICBhY3Rpb25zLmluc2VydEJlZm9yZShjb25maXJtQnV0dG9uLCBsb2FkZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29uZmlybUJ1dHRvblxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkZW55QnV0dG9uXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNhbmNlbEJ1dHRvblxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAgICovXG5cblxuICBmdW5jdGlvbiBoYW5kbGVCdXR0b25zU3R5bGluZyhjb25maXJtQnV0dG9uLCBkZW55QnV0dG9uLCBjYW5jZWxCdXR0b24sIHBhcmFtcykge1xuICAgIGlmICghcGFyYW1zLmJ1dHRvbnNTdHlsaW5nKSB7XG4gICAgICByZXR1cm4gcmVtb3ZlQ2xhc3MoW2NvbmZpcm1CdXR0b24sIGRlbnlCdXR0b24sIGNhbmNlbEJ1dHRvbl0sIHN3YWxDbGFzc2VzLnN0eWxlZCk7XG4gICAgfVxuXG4gICAgYWRkQ2xhc3MoW2NvbmZpcm1CdXR0b24sIGRlbnlCdXR0b24sIGNhbmNlbEJ1dHRvbl0sIHN3YWxDbGFzc2VzLnN0eWxlZCk7IC8vIEJ1dHRvbnMgYmFja2dyb3VuZCBjb2xvcnNcblxuICAgIGlmIChwYXJhbXMuY29uZmlybUJ1dHRvbkNvbG9yKSB7XG4gICAgICBjb25maXJtQnV0dG9uLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHBhcmFtcy5jb25maXJtQnV0dG9uQ29sb3I7XG4gICAgICBhZGRDbGFzcyhjb25maXJtQnV0dG9uLCBzd2FsQ2xhc3Nlc1snZGVmYXVsdC1vdXRsaW5lJ10pO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMuZGVueUJ1dHRvbkNvbG9yKSB7XG4gICAgICBkZW55QnV0dG9uLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHBhcmFtcy5kZW55QnV0dG9uQ29sb3I7XG4gICAgICBhZGRDbGFzcyhkZW55QnV0dG9uLCBzd2FsQ2xhc3Nlc1snZGVmYXVsdC1vdXRsaW5lJ10pO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMuY2FuY2VsQnV0dG9uQ29sb3IpIHtcbiAgICAgIGNhbmNlbEJ1dHRvbi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBwYXJhbXMuY2FuY2VsQnV0dG9uQ29sb3I7XG4gICAgICBhZGRDbGFzcyhjYW5jZWxCdXR0b24sIHN3YWxDbGFzc2VzWydkZWZhdWx0LW91dGxpbmUnXSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBidXR0b25cbiAgICogQHBhcmFtIHsnY29uZmlybScgfCAnZGVueScgfCAnY2FuY2VsJ30gYnV0dG9uVHlwZVxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAgICovXG5cblxuICBmdW5jdGlvbiByZW5kZXJCdXR0b24oYnV0dG9uLCBidXR0b25UeXBlLCBwYXJhbXMpIHtcbiAgICB0b2dnbGUoYnV0dG9uLCBwYXJhbXNbXCJzaG93XCIuY29uY2F0KGNhcGl0YWxpemVGaXJzdExldHRlcihidXR0b25UeXBlKSwgXCJCdXR0b25cIildLCAnaW5saW5lLWJsb2NrJyk7XG4gICAgc2V0SW5uZXJIdG1sKGJ1dHRvbiwgcGFyYW1zW1wiXCIuY29uY2F0KGJ1dHRvblR5cGUsIFwiQnV0dG9uVGV4dFwiKV0pOyAvLyBTZXQgY2FwdGlvbiB0ZXh0XG5cbiAgICBidXR0b24uc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgcGFyYW1zW1wiXCIuY29uY2F0KGJ1dHRvblR5cGUsIFwiQnV0dG9uQXJpYUxhYmVsXCIpXSk7IC8vIEFSSUEgbGFiZWxcbiAgICAvLyBBZGQgYnV0dG9ucyBjdXN0b20gY2xhc3Nlc1xuXG4gICAgYnV0dG9uLmNsYXNzTmFtZSA9IHN3YWxDbGFzc2VzW2J1dHRvblR5cGVdO1xuICAgIGFwcGx5Q3VzdG9tQ2xhc3MoYnV0dG9uLCBwYXJhbXMsIFwiXCIuY29uY2F0KGJ1dHRvblR5cGUsIFwiQnV0dG9uXCIpKTtcbiAgICBhZGRDbGFzcyhidXR0b24sIHBhcmFtc1tcIlwiLmNvbmNhdChidXR0b25UeXBlLCBcIkJ1dHRvbkNsYXNzXCIpXSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0Mn0gaW5zdGFuY2VcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gICAqL1xuXG4gIGNvbnN0IHJlbmRlckNvbnRhaW5lciA9IChpbnN0YW5jZSwgcGFyYW1zKSA9PiB7XG4gICAgY29uc3QgY29udGFpbmVyID0gZ2V0Q29udGFpbmVyKCk7XG5cbiAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGhhbmRsZUJhY2tkcm9wUGFyYW0oY29udGFpbmVyLCBwYXJhbXMuYmFja2Ryb3ApO1xuICAgIGhhbmRsZVBvc2l0aW9uUGFyYW0oY29udGFpbmVyLCBwYXJhbXMucG9zaXRpb24pO1xuICAgIGhhbmRsZUdyb3dQYXJhbShjb250YWluZXIsIHBhcmFtcy5ncm93KTsgLy8gQ3VzdG9tIGNsYXNzXG5cbiAgICBhcHBseUN1c3RvbUNsYXNzKGNvbnRhaW5lciwgcGFyYW1zLCAnY29udGFpbmVyJyk7XG4gIH07XG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXJcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc1snYmFja2Ryb3AnXX0gYmFja2Ryb3BcbiAgICovXG5cbiAgZnVuY3Rpb24gaGFuZGxlQmFja2Ryb3BQYXJhbShjb250YWluZXIsIGJhY2tkcm9wKSB7XG4gICAgaWYgKHR5cGVvZiBiYWNrZHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnRhaW5lci5zdHlsZS5iYWNrZ3JvdW5kID0gYmFja2Ryb3A7XG4gICAgfSBlbHNlIGlmICghYmFja2Ryb3ApIHtcbiAgICAgIGFkZENsYXNzKFtkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIGRvY3VtZW50LmJvZHldLCBzd2FsQ2xhc3Nlc1snbm8tYmFja2Ryb3AnXSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXJcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc1sncG9zaXRpb24nXX0gcG9zaXRpb25cbiAgICovXG5cblxuICBmdW5jdGlvbiBoYW5kbGVQb3NpdGlvblBhcmFtKGNvbnRhaW5lciwgcG9zaXRpb24pIHtcbiAgICBpZiAocG9zaXRpb24gaW4gc3dhbENsYXNzZXMpIHtcbiAgICAgIGFkZENsYXNzKGNvbnRhaW5lciwgc3dhbENsYXNzZXNbcG9zaXRpb25dKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybignVGhlIFwicG9zaXRpb25cIiBwYXJhbWV0ZXIgaXMgbm90IHZhbGlkLCBkZWZhdWx0aW5nIHRvIFwiY2VudGVyXCInKTtcbiAgICAgIGFkZENsYXNzKGNvbnRhaW5lciwgc3dhbENsYXNzZXMuY2VudGVyKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lclxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zWydncm93J119IGdyb3dcbiAgICovXG5cblxuICBmdW5jdGlvbiBoYW5kbGVHcm93UGFyYW0oY29udGFpbmVyLCBncm93KSB7XG4gICAgaWYgKGdyb3cgJiYgdHlwZW9mIGdyb3cgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBncm93Q2xhc3MgPSBcImdyb3ctXCIuY29uY2F0KGdyb3cpO1xuXG4gICAgICBpZiAoZ3Jvd0NsYXNzIGluIHN3YWxDbGFzc2VzKSB7XG4gICAgICAgIGFkZENsYXNzKGNvbnRhaW5lciwgc3dhbENsYXNzZXNbZ3Jvd0NsYXNzXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgbW9kdWxlIGNvbnRhaW5zIGBXZWFrTWFwYHMgZm9yIGVhY2ggZWZmZWN0aXZlbHktXCJwcml2YXRlICBwcm9wZXJ0eVwiIHRoYXQgYSBgU3dhbGAgaGFzLlxuICAgKiBGb3IgZXhhbXBsZSwgdG8gc2V0IHRoZSBwcml2YXRlIHByb3BlcnR5IFwiZm9vXCIgb2YgYHRoaXNgIHRvIFwiYmFyXCIsIHlvdSBjYW4gYHByaXZhdGVQcm9wcy5mb28uc2V0KHRoaXMsICdiYXInKWBcbiAgICogVGhpcyBpcyB0aGUgYXBwcm9hY2ggdGhhdCBCYWJlbCB3aWxsIHByb2JhYmx5IHRha2UgdG8gaW1wbGVtZW50IHByaXZhdGUgbWV0aG9kcy9maWVsZHNcbiAgICogICBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1wcml2YXRlLW1ldGhvZHNcbiAgICogICBodHRwczovL2dpdGh1Yi5jb20vYmFiZWwvYmFiZWwvcHVsbC83NTU1XG4gICAqIE9uY2Ugd2UgaGF2ZSB0aGUgY2hhbmdlcyBmcm9tIHRoYXQgUFIgaW4gQmFiZWwsIGFuZCBvdXIgY29yZSBjbGFzcyBmaXRzIHJlYXNvbmFibGUgaW4gKm9uZSBtb2R1bGUqXG4gICAqICAgdGhlbiB3ZSBjYW4gdXNlIHRoYXQgbGFuZ3VhZ2UgZmVhdHVyZS5cbiAgICovXG4gIHZhciBwcml2YXRlUHJvcHMgPSB7XG4gICAgYXdhaXRpbmdQcm9taXNlOiBuZXcgV2Vha01hcCgpLFxuICAgIHByb21pc2U6IG5ldyBXZWFrTWFwKCksXG4gICAgaW5uZXJQYXJhbXM6IG5ldyBXZWFrTWFwKCksXG4gICAgZG9tQ2FjaGU6IG5ldyBXZWFrTWFwKClcbiAgfTtcblxuICAvLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vLi4vLi4vLi4vc3dlZXRhbGVydDIuZC50c1wiLz5cbiAgLyoqIEB0eXBlIHtJbnB1dENsYXNzW119ICovXG5cbiAgY29uc3QgaW5wdXRDbGFzc2VzID0gWydpbnB1dCcsICdmaWxlJywgJ3JhbmdlJywgJ3NlbGVjdCcsICdyYWRpbycsICdjaGVja2JveCcsICd0ZXh0YXJlYSddO1xuICAvKipcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0Mn0gaW5zdGFuY2VcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gICAqL1xuXG4gIGNvbnN0IHJlbmRlcklucHV0ID0gKGluc3RhbmNlLCBwYXJhbXMpID0+IHtcbiAgICBjb25zdCBwb3B1cCA9IGdldFBvcHVwKCk7XG4gICAgY29uc3QgaW5uZXJQYXJhbXMgPSBwcml2YXRlUHJvcHMuaW5uZXJQYXJhbXMuZ2V0KGluc3RhbmNlKTtcbiAgICBjb25zdCByZXJlbmRlciA9ICFpbm5lclBhcmFtcyB8fCBwYXJhbXMuaW5wdXQgIT09IGlubmVyUGFyYW1zLmlucHV0O1xuICAgIGlucHV0Q2xhc3Nlcy5mb3JFYWNoKGlucHV0Q2xhc3MgPT4ge1xuICAgICAgY29uc3QgaW5wdXRDb250YWluZXIgPSBnZXREaXJlY3RDaGlsZEJ5Q2xhc3MocG9wdXAsIHN3YWxDbGFzc2VzW2lucHV0Q2xhc3NdKTsgLy8gc2V0IGF0dHJpYnV0ZXNcblxuICAgICAgc2V0QXR0cmlidXRlcyhpbnB1dENsYXNzLCBwYXJhbXMuaW5wdXRBdHRyaWJ1dGVzKTsgLy8gc2V0IGNsYXNzXG5cbiAgICAgIGlucHV0Q29udGFpbmVyLmNsYXNzTmFtZSA9IHN3YWxDbGFzc2VzW2lucHV0Q2xhc3NdO1xuXG4gICAgICBpZiAocmVyZW5kZXIpIHtcbiAgICAgICAgaGlkZShpbnB1dENvbnRhaW5lcik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAocGFyYW1zLmlucHV0KSB7XG4gICAgICBpZiAocmVyZW5kZXIpIHtcbiAgICAgICAgc2hvd0lucHV0KHBhcmFtcyk7XG4gICAgICB9IC8vIHNldCBjdXN0b20gY2xhc3NcblxuXG4gICAgICBzZXRDdXN0b21DbGFzcyhwYXJhbXMpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICAgKi9cblxuICBjb25zdCBzaG93SW5wdXQgPSBwYXJhbXMgPT4ge1xuICAgIGlmICghcmVuZGVySW5wdXRUeXBlW3BhcmFtcy5pbnB1dF0pIHtcbiAgICAgIHJldHVybiBlcnJvcihcIlVuZXhwZWN0ZWQgdHlwZSBvZiBpbnB1dCEgRXhwZWN0ZWQgXFxcInRleHRcXFwiLCBcXFwiZW1haWxcXFwiLCBcXFwicGFzc3dvcmRcXFwiLCBcXFwibnVtYmVyXFxcIiwgXFxcInRlbFxcXCIsIFxcXCJzZWxlY3RcXFwiLCBcXFwicmFkaW9cXFwiLCBcXFwiY2hlY2tib3hcXFwiLCBcXFwidGV4dGFyZWFcXFwiLCBcXFwiZmlsZVxcXCIgb3IgXFxcInVybFxcXCIsIGdvdCBcXFwiXCIuY29uY2F0KHBhcmFtcy5pbnB1dCwgXCJcXFwiXCIpKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbnB1dENvbnRhaW5lciA9IGdldElucHV0Q29udGFpbmVyKHBhcmFtcy5pbnB1dCk7XG4gICAgY29uc3QgaW5wdXQgPSByZW5kZXJJbnB1dFR5cGVbcGFyYW1zLmlucHV0XShpbnB1dENvbnRhaW5lciwgcGFyYW1zKTtcbiAgICBzaG93KGlucHV0Q29udGFpbmVyKTsgLy8gaW5wdXQgYXV0b2ZvY3VzXG5cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGZvY3VzSW5wdXQoaW5wdXQpO1xuICAgIH0pO1xuICB9O1xuICAvKipcbiAgICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50fSBpbnB1dFxuICAgKi9cblxuXG4gIGNvbnN0IHJlbW92ZUF0dHJpYnV0ZXMgPSBpbnB1dCA9PiB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC5hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBhdHRyTmFtZSA9IGlucHV0LmF0dHJpYnV0ZXNbaV0ubmFtZTtcblxuICAgICAgaWYgKCFbJ3R5cGUnLCAndmFsdWUnLCAnc3R5bGUnXS5pbmNsdWRlcyhhdHRyTmFtZSkpIHtcbiAgICAgICAgaW5wdXQucmVtb3ZlQXR0cmlidXRlKGF0dHJOYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBAcGFyYW0ge0lucHV0Q2xhc3N9IGlucHV0Q2xhc3NcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc1snaW5wdXRBdHRyaWJ1dGVzJ119IGlucHV0QXR0cmlidXRlc1xuICAgKi9cblxuXG4gIGNvbnN0IHNldEF0dHJpYnV0ZXMgPSAoaW5wdXRDbGFzcywgaW5wdXRBdHRyaWJ1dGVzKSA9PiB7XG4gICAgY29uc3QgaW5wdXQgPSBnZXRJbnB1dChnZXRQb3B1cCgpLCBpbnB1dENsYXNzKTtcblxuICAgIGlmICghaW5wdXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZW1vdmVBdHRyaWJ1dGVzKGlucHV0KTtcblxuICAgIGZvciAoY29uc3QgYXR0ciBpbiBpbnB1dEF0dHJpYnV0ZXMpIHtcbiAgICAgIGlucHV0LnNldEF0dHJpYnV0ZShhdHRyLCBpbnB1dEF0dHJpYnV0ZXNbYXR0cl0pO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICAgKi9cblxuXG4gIGNvbnN0IHNldEN1c3RvbUNsYXNzID0gcGFyYW1zID0+IHtcbiAgICBjb25zdCBpbnB1dENvbnRhaW5lciA9IGdldElucHV0Q29udGFpbmVyKHBhcmFtcy5pbnB1dCk7XG5cbiAgICBpZiAodHlwZW9mIHBhcmFtcy5jdXN0b21DbGFzcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGFkZENsYXNzKGlucHV0Q29udGFpbmVyLCBwYXJhbXMuY3VzdG9tQ2xhc3MuaW5wdXQpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudCB8IEhUTUxUZXh0QXJlYUVsZW1lbnR9IGlucHV0XG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICAgKi9cblxuXG4gIGNvbnN0IHNldElucHV0UGxhY2Vob2xkZXIgPSAoaW5wdXQsIHBhcmFtcykgPT4ge1xuICAgIGlmICghaW5wdXQucGxhY2Vob2xkZXIgfHwgcGFyYW1zLmlucHV0UGxhY2Vob2xkZXIpIHtcbiAgICAgIGlucHV0LnBsYWNlaG9sZGVyID0gcGFyYW1zLmlucHV0UGxhY2Vob2xkZXI7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogQHBhcmFtIHtJbnB1dH0gaW5wdXRcbiAgICogQHBhcmFtIHtJbnB1dH0gcHJlcGVuZFRvXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICAgKi9cblxuXG4gIGNvbnN0IHNldElucHV0TGFiZWwgPSAoaW5wdXQsIHByZXBlbmRUbywgcGFyYW1zKSA9PiB7XG4gICAgaWYgKHBhcmFtcy5pbnB1dExhYmVsKSB7XG4gICAgICBpbnB1dC5pZCA9IHN3YWxDbGFzc2VzLmlucHV0O1xuICAgICAgY29uc3QgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgICAgY29uc3QgbGFiZWxDbGFzcyA9IHN3YWxDbGFzc2VzWydpbnB1dC1sYWJlbCddO1xuICAgICAgbGFiZWwuc2V0QXR0cmlidXRlKCdmb3InLCBpbnB1dC5pZCk7XG4gICAgICBsYWJlbC5jbGFzc05hbWUgPSBsYWJlbENsYXNzO1xuXG4gICAgICBpZiAodHlwZW9mIHBhcmFtcy5jdXN0b21DbGFzcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYWRkQ2xhc3MobGFiZWwsIHBhcmFtcy5jdXN0b21DbGFzcy5pbnB1dExhYmVsKTtcbiAgICAgIH1cblxuICAgICAgbGFiZWwuaW5uZXJUZXh0ID0gcGFyYW1zLmlucHV0TGFiZWw7XG4gICAgICBwcmVwZW5kVG8uaW5zZXJ0QWRqYWNlbnRFbGVtZW50KCdiZWZvcmViZWdpbicsIGxhYmVsKTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zWydpbnB1dCddfSBpbnB1dFR5cGVcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICAgKi9cblxuXG4gIGNvbnN0IGdldElucHV0Q29udGFpbmVyID0gaW5wdXRUeXBlID0+IHtcbiAgICByZXR1cm4gZ2V0RGlyZWN0Q2hpbGRCeUNsYXNzKGdldFBvcHVwKCksIHN3YWxDbGFzc2VzW2lucHV0VHlwZV0gfHwgc3dhbENsYXNzZXMuaW5wdXQpO1xuICB9O1xuICAvKipcbiAgICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50IHwgSFRNTE91dHB1dEVsZW1lbnQgfCBIVE1MVGV4dEFyZWFFbGVtZW50fSBpbnB1dFxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zWydpbnB1dFZhbHVlJ119IGlucHV0VmFsdWVcbiAgICovXG5cblxuICBjb25zdCBjaGVja0FuZFNldElucHV0VmFsdWUgPSAoaW5wdXQsIGlucHV0VmFsdWUpID0+IHtcbiAgICBpZiAoWydzdHJpbmcnLCAnbnVtYmVyJ10uaW5jbHVkZXModHlwZW9mIGlucHV0VmFsdWUpKSB7XG4gICAgICBpbnB1dC52YWx1ZSA9IFwiXCIuY29uY2F0KGlucHV0VmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoIWlzUHJvbWlzZShpbnB1dFZhbHVlKSkge1xuICAgICAgd2FybihcIlVuZXhwZWN0ZWQgdHlwZSBvZiBpbnB1dFZhbHVlISBFeHBlY3RlZCBcXFwic3RyaW5nXFxcIiwgXFxcIm51bWJlclxcXCIgb3IgXFxcIlByb21pc2VcXFwiLCBnb3QgXFxcIlwiLmNvbmNhdCh0eXBlb2YgaW5wdXRWYWx1ZSwgXCJcXFwiXCIpKTtcbiAgICB9XG4gIH07XG4gIC8qKiBAdHlwZSBSZWNvcmQ8c3RyaW5nLCAoaW5wdXQ6IElucHV0IHwgSFRNTEVsZW1lbnQsIHBhcmFtczogU3dlZXRBbGVydE9wdGlvbnMpID0+IElucHV0PiAqL1xuXG5cbiAgY29uc3QgcmVuZGVySW5wdXRUeXBlID0ge307XG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnR9IGlucHV0XG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICAgKiBAcmV0dXJucyB7SFRNTElucHV0RWxlbWVudH1cbiAgICovXG5cbiAgcmVuZGVySW5wdXRUeXBlLnRleHQgPSByZW5kZXJJbnB1dFR5cGUuZW1haWwgPSByZW5kZXJJbnB1dFR5cGUucGFzc3dvcmQgPSByZW5kZXJJbnB1dFR5cGUubnVtYmVyID0gcmVuZGVySW5wdXRUeXBlLnRlbCA9IHJlbmRlcklucHV0VHlwZS51cmwgPSAoaW5wdXQsIHBhcmFtcykgPT4ge1xuICAgIGNoZWNrQW5kU2V0SW5wdXRWYWx1ZShpbnB1dCwgcGFyYW1zLmlucHV0VmFsdWUpO1xuICAgIHNldElucHV0TGFiZWwoaW5wdXQsIGlucHV0LCBwYXJhbXMpO1xuICAgIHNldElucHV0UGxhY2Vob2xkZXIoaW5wdXQsIHBhcmFtcyk7XG4gICAgaW5wdXQudHlwZSA9IHBhcmFtcy5pbnB1dDtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH07XG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnR9IGlucHV0XG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICAgKiBAcmV0dXJucyB7SFRNTElucHV0RWxlbWVudH1cbiAgICovXG5cblxuICByZW5kZXJJbnB1dFR5cGUuZmlsZSA9IChpbnB1dCwgcGFyYW1zKSA9PiB7XG4gICAgc2V0SW5wdXRMYWJlbChpbnB1dCwgaW5wdXQsIHBhcmFtcyk7XG4gICAgc2V0SW5wdXRQbGFjZWhvbGRlcihpbnB1dCwgcGFyYW1zKTtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH07XG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnR9IHJhbmdlXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICAgKiBAcmV0dXJucyB7SFRNTElucHV0RWxlbWVudH1cbiAgICovXG5cblxuICByZW5kZXJJbnB1dFR5cGUucmFuZ2UgPSAocmFuZ2UsIHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IHJhbmdlSW5wdXQgPSByYW5nZS5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpO1xuICAgIGNvbnN0IHJhbmdlT3V0cHV0ID0gcmFuZ2UucXVlcnlTZWxlY3Rvcignb3V0cHV0Jyk7XG4gICAgY2hlY2tBbmRTZXRJbnB1dFZhbHVlKHJhbmdlSW5wdXQsIHBhcmFtcy5pbnB1dFZhbHVlKTtcbiAgICByYW5nZUlucHV0LnR5cGUgPSBwYXJhbXMuaW5wdXQ7XG4gICAgY2hlY2tBbmRTZXRJbnB1dFZhbHVlKHJhbmdlT3V0cHV0LCBwYXJhbXMuaW5wdXRWYWx1ZSk7XG4gICAgc2V0SW5wdXRMYWJlbChyYW5nZUlucHV0LCByYW5nZSwgcGFyYW1zKTtcbiAgICByZXR1cm4gcmFuZ2U7XG4gIH07XG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxTZWxlY3RFbGVtZW50fSBzZWxlY3RcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gICAqIEByZXR1cm5zIHtIVE1MU2VsZWN0RWxlbWVudH1cbiAgICovXG5cblxuICByZW5kZXJJbnB1dFR5cGUuc2VsZWN0ID0gKHNlbGVjdCwgcGFyYW1zKSA9PiB7XG4gICAgc2VsZWN0LnRleHRDb250ZW50ID0gJyc7XG5cbiAgICBpZiAocGFyYW1zLmlucHV0UGxhY2Vob2xkZXIpIHtcbiAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0aW9uJyk7XG4gICAgICBzZXRJbm5lckh0bWwocGxhY2Vob2xkZXIsIHBhcmFtcy5pbnB1dFBsYWNlaG9sZGVyKTtcbiAgICAgIHBsYWNlaG9sZGVyLnZhbHVlID0gJyc7XG4gICAgICBwbGFjZWhvbGRlci5kaXNhYmxlZCA9IHRydWU7XG4gICAgICBwbGFjZWhvbGRlci5zZWxlY3RlZCA9IHRydWU7XG4gICAgICBzZWxlY3QuYXBwZW5kQ2hpbGQocGxhY2Vob2xkZXIpO1xuICAgIH1cblxuICAgIHNldElucHV0TGFiZWwoc2VsZWN0LCBzZWxlY3QsIHBhcmFtcyk7XG4gICAgcmV0dXJuIHNlbGVjdDtcbiAgfTtcbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudH0gcmFkaW9cbiAgICogQHJldHVybnMge0hUTUxJbnB1dEVsZW1lbnR9XG4gICAqL1xuXG5cbiAgcmVuZGVySW5wdXRUeXBlLnJhZGlvID0gcmFkaW8gPT4ge1xuICAgIHJhZGlvLnRleHRDb250ZW50ID0gJyc7XG4gICAgcmV0dXJuIHJhZGlvO1xuICB9O1xuICAvKipcbiAgICogQHBhcmFtIHtIVE1MTGFiZWxFbGVtZW50fSBjaGVja2JveENvbnRhaW5lclxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAgICogQHJldHVybnMge0hUTUxJbnB1dEVsZW1lbnR9XG4gICAqL1xuXG5cbiAgcmVuZGVySW5wdXRUeXBlLmNoZWNrYm94ID0gKGNoZWNrYm94Q29udGFpbmVyLCBwYXJhbXMpID0+IHtcbiAgICBjb25zdCBjaGVja2JveCA9IGdldElucHV0KGdldFBvcHVwKCksICdjaGVja2JveCcpO1xuICAgIGNoZWNrYm94LnZhbHVlID0gJzEnO1xuICAgIGNoZWNrYm94LmlkID0gc3dhbENsYXNzZXMuY2hlY2tib3g7XG4gICAgY2hlY2tib3guY2hlY2tlZCA9IEJvb2xlYW4ocGFyYW1zLmlucHV0VmFsdWUpO1xuICAgIGNvbnN0IGxhYmVsID0gY2hlY2tib3hDb250YWluZXIucXVlcnlTZWxlY3Rvcignc3BhbicpO1xuICAgIHNldElubmVySHRtbChsYWJlbCwgcGFyYW1zLmlucHV0UGxhY2Vob2xkZXIpO1xuICAgIHJldHVybiBjaGVja2JveDtcbiAgfTtcbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTFRleHRBcmVhRWxlbWVudH0gdGV4dGFyZWFcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gICAqIEByZXR1cm5zIHtIVE1MVGV4dEFyZWFFbGVtZW50fVxuICAgKi9cblxuXG4gIHJlbmRlcklucHV0VHlwZS50ZXh0YXJlYSA9ICh0ZXh0YXJlYSwgcGFyYW1zKSA9PiB7XG4gICAgY2hlY2tBbmRTZXRJbnB1dFZhbHVlKHRleHRhcmVhLCBwYXJhbXMuaW5wdXRWYWx1ZSk7XG4gICAgc2V0SW5wdXRQbGFjZWhvbGRlcih0ZXh0YXJlYSwgcGFyYW1zKTtcbiAgICBzZXRJbnB1dExhYmVsKHRleHRhcmVhLCB0ZXh0YXJlYSwgcGFyYW1zKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG5cbiAgICBjb25zdCBnZXRNYXJnaW4gPSBlbCA9PiBwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCkubWFyZ2luTGVmdCkgKyBwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCkubWFyZ2luUmlnaHQpOyAvLyBodHRwczovL2dpdGh1Yi5jb20vc3dlZXRhbGVydDIvc3dlZXRhbGVydDIvaXNzdWVzLzIyOTFcblxuXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vc3dlZXRhbGVydDIvc3dlZXRhbGVydDIvaXNzdWVzLzE2OTlcbiAgICAgIGlmICgnTXV0YXRpb25PYnNlcnZlcicgaW4gd2luZG93KSB7XG4gICAgICAgIGNvbnN0IGluaXRpYWxQb3B1cFdpZHRoID0gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUoZ2V0UG9wdXAoKSkud2lkdGgpO1xuXG4gICAgICAgIGNvbnN0IHRleHRhcmVhUmVzaXplSGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICBjb25zdCB0ZXh0YXJlYVdpZHRoID0gdGV4dGFyZWEub2Zmc2V0V2lkdGggKyBnZXRNYXJnaW4odGV4dGFyZWEpO1xuXG4gICAgICAgICAgaWYgKHRleHRhcmVhV2lkdGggPiBpbml0aWFsUG9wdXBXaWR0aCkge1xuICAgICAgICAgICAgZ2V0UG9wdXAoKS5zdHlsZS53aWR0aCA9IFwiXCIuY29uY2F0KHRleHRhcmVhV2lkdGgsIFwicHhcIik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldFBvcHVwKCkuc3R5bGUud2lkdGggPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBuZXcgTXV0YXRpb25PYnNlcnZlcih0ZXh0YXJlYVJlc2l6ZUhhbmRsZXIpLm9ic2VydmUodGV4dGFyZWEsIHtcbiAgICAgICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgICAgICAgIGF0dHJpYnV0ZUZpbHRlcjogWydzdHlsZSddXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0ZXh0YXJlYTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0Mn0gaW5zdGFuY2VcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gICAqL1xuXG4gIGNvbnN0IHJlbmRlckNvbnRlbnQgPSAoaW5zdGFuY2UsIHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IGh0bWxDb250YWluZXIgPSBnZXRIdG1sQ29udGFpbmVyKCk7XG4gICAgYXBwbHlDdXN0b21DbGFzcyhodG1sQ29udGFpbmVyLCBwYXJhbXMsICdodG1sQ29udGFpbmVyJyk7IC8vIENvbnRlbnQgYXMgSFRNTFxuXG4gICAgaWYgKHBhcmFtcy5odG1sKSB7XG4gICAgICBwYXJzZUh0bWxUb0NvbnRhaW5lcihwYXJhbXMuaHRtbCwgaHRtbENvbnRhaW5lcik7XG4gICAgICBzaG93KGh0bWxDb250YWluZXIsICdibG9jaycpO1xuICAgIH0gLy8gQ29udGVudCBhcyBwbGFpbiB0ZXh0XG4gICAgZWxzZSBpZiAocGFyYW1zLnRleHQpIHtcbiAgICAgIGh0bWxDb250YWluZXIudGV4dENvbnRlbnQgPSBwYXJhbXMudGV4dDtcbiAgICAgIHNob3coaHRtbENvbnRhaW5lciwgJ2Jsb2NrJyk7XG4gICAgfSAvLyBObyBjb250ZW50XG4gICAgZWxzZSB7XG4gICAgICBoaWRlKGh0bWxDb250YWluZXIpO1xuICAgIH1cblxuICAgIHJlbmRlcklucHV0KGluc3RhbmNlLCBwYXJhbXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnQyfSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAgICovXG5cbiAgY29uc3QgcmVuZGVyRm9vdGVyID0gKGluc3RhbmNlLCBwYXJhbXMpID0+IHtcbiAgICBjb25zdCBmb290ZXIgPSBnZXRGb290ZXIoKTtcbiAgICB0b2dnbGUoZm9vdGVyLCBwYXJhbXMuZm9vdGVyKTtcblxuICAgIGlmIChwYXJhbXMuZm9vdGVyKSB7XG4gICAgICBwYXJzZUh0bWxUb0NvbnRhaW5lcihwYXJhbXMuZm9vdGVyLCBmb290ZXIpO1xuICAgIH0gLy8gQ3VzdG9tIGNsYXNzXG5cblxuICAgIGFwcGx5Q3VzdG9tQ2xhc3MoZm9vdGVyLCBwYXJhbXMsICdmb290ZXInKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0Mn0gaW5zdGFuY2VcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gICAqL1xuXG4gIGNvbnN0IHJlbmRlckNsb3NlQnV0dG9uID0gKGluc3RhbmNlLCBwYXJhbXMpID0+IHtcbiAgICBjb25zdCBjbG9zZUJ1dHRvbiA9IGdldENsb3NlQnV0dG9uKCk7XG4gICAgc2V0SW5uZXJIdG1sKGNsb3NlQnV0dG9uLCBwYXJhbXMuY2xvc2VCdXR0b25IdG1sKTsgLy8gQ3VzdG9tIGNsYXNzXG5cbiAgICBhcHBseUN1c3RvbUNsYXNzKGNsb3NlQnV0dG9uLCBwYXJhbXMsICdjbG9zZUJ1dHRvbicpO1xuICAgIHRvZ2dsZShjbG9zZUJ1dHRvbiwgcGFyYW1zLnNob3dDbG9zZUJ1dHRvbik7XG4gICAgY2xvc2VCdXR0b24uc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgcGFyYW1zLmNsb3NlQnV0dG9uQXJpYUxhYmVsKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0Mn0gaW5zdGFuY2VcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gICAqL1xuXG4gIGNvbnN0IHJlbmRlckljb24gPSAoaW5zdGFuY2UsIHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IGlubmVyUGFyYW1zID0gcHJpdmF0ZVByb3BzLmlubmVyUGFyYW1zLmdldChpbnN0YW5jZSk7XG4gICAgY29uc3QgaWNvbiA9IGdldEljb24oKTsgLy8gaWYgdGhlIGdpdmVuIGljb24gYWxyZWFkeSByZW5kZXJlZCwgYXBwbHkgdGhlIHN0eWxpbmcgd2l0aG91dCByZS1yZW5kZXJpbmcgdGhlIGljb25cblxuICAgIGlmIChpbm5lclBhcmFtcyAmJiBwYXJhbXMuaWNvbiA9PT0gaW5uZXJQYXJhbXMuaWNvbikge1xuICAgICAgLy8gQ3VzdG9tIG9yIGRlZmF1bHQgY29udGVudFxuICAgICAgc2V0Q29udGVudChpY29uLCBwYXJhbXMpO1xuICAgICAgYXBwbHlTdHlsZXMoaWNvbiwgcGFyYW1zKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXBhcmFtcy5pY29uICYmICFwYXJhbXMuaWNvbkh0bWwpIHtcbiAgICAgIGhpZGUoaWNvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy5pY29uICYmIE9iamVjdC5rZXlzKGljb25UeXBlcykuaW5kZXhPZihwYXJhbXMuaWNvbikgPT09IC0xKSB7XG4gICAgICBlcnJvcihcIlVua25vd24gaWNvbiEgRXhwZWN0ZWQgXFxcInN1Y2Nlc3NcXFwiLCBcXFwiZXJyb3JcXFwiLCBcXFwid2FybmluZ1xcXCIsIFxcXCJpbmZvXFxcIiBvciBcXFwicXVlc3Rpb25cXFwiLCBnb3QgXFxcIlwiLmNvbmNhdChwYXJhbXMuaWNvbiwgXCJcXFwiXCIpKTtcbiAgICAgIGhpZGUoaWNvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2hvdyhpY29uKTsgLy8gQ3VzdG9tIG9yIGRlZmF1bHQgY29udGVudFxuXG4gICAgc2V0Q29udGVudChpY29uLCBwYXJhbXMpO1xuICAgIGFwcGx5U3R5bGVzKGljb24sIHBhcmFtcyk7IC8vIEFuaW1hdGUgaWNvblxuXG4gICAgYWRkQ2xhc3MoaWNvbiwgcGFyYW1zLnNob3dDbGFzcy5pY29uKTtcbiAgfTtcbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGljb25cbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gICAqL1xuXG4gIGNvbnN0IGFwcGx5U3R5bGVzID0gKGljb24sIHBhcmFtcykgPT4ge1xuICAgIGZvciAoY29uc3QgaWNvblR5cGUgaW4gaWNvblR5cGVzKSB7XG4gICAgICBpZiAocGFyYW1zLmljb24gIT09IGljb25UeXBlKSB7XG4gICAgICAgIHJlbW92ZUNsYXNzKGljb24sIGljb25UeXBlc1tpY29uVHlwZV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGFkZENsYXNzKGljb24sIGljb25UeXBlc1twYXJhbXMuaWNvbl0pOyAvLyBJY29uIGNvbG9yXG5cbiAgICBzZXRDb2xvcihpY29uLCBwYXJhbXMpOyAvLyBTdWNjZXNzIGljb24gYmFja2dyb3VuZCBjb2xvclxuXG4gICAgYWRqdXN0U3VjY2Vzc0ljb25CYWNrZ3JvdW5kQ29sb3IoKTsgLy8gQ3VzdG9tIGNsYXNzXG5cbiAgICBhcHBseUN1c3RvbUNsYXNzKGljb24sIHBhcmFtcywgJ2ljb24nKTtcbiAgfTsgLy8gQWRqdXN0IHN1Y2Nlc3MgaWNvbiBiYWNrZ3JvdW5kIGNvbG9yIHRvIG1hdGNoIHRoZSBwb3B1cCBiYWNrZ3JvdW5kIGNvbG9yXG5cblxuICBjb25zdCBhZGp1c3RTdWNjZXNzSWNvbkJhY2tncm91bmRDb2xvciA9ICgpID0+IHtcbiAgICBjb25zdCBwb3B1cCA9IGdldFBvcHVwKCk7XG4gICAgY29uc3QgcG9wdXBCYWNrZ3JvdW5kQ29sb3IgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShwb3B1cCkuZ2V0UHJvcGVydHlWYWx1ZSgnYmFja2dyb3VuZC1jb2xvcicpO1xuICAgIC8qKiBAdHlwZSB7Tm9kZUxpc3RPZjxIVE1MRWxlbWVudD59ICovXG5cbiAgICBjb25zdCBzdWNjZXNzSWNvblBhcnRzID0gcG9wdXAucXVlcnlTZWxlY3RvckFsbCgnW2NsYXNzXj1zd2FsMi1zdWNjZXNzLWNpcmN1bGFyLWxpbmVdLCAuc3dhbDItc3VjY2Vzcy1maXgnKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3VjY2Vzc0ljb25QYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgc3VjY2Vzc0ljb25QYXJ0c1tpXS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBwb3B1cEJhY2tncm91bmRDb2xvcjtcbiAgICB9XG4gIH07XG5cbiAgY29uc3Qgc3VjY2Vzc0ljb25IdG1sID0gXCJcXG4gIDxkaXYgY2xhc3M9XFxcInN3YWwyLXN1Y2Nlc3MtY2lyY3VsYXItbGluZS1sZWZ0XFxcIj48L2Rpdj5cXG4gIDxzcGFuIGNsYXNzPVxcXCJzd2FsMi1zdWNjZXNzLWxpbmUtdGlwXFxcIj48L3NwYW4+IDxzcGFuIGNsYXNzPVxcXCJzd2FsMi1zdWNjZXNzLWxpbmUtbG9uZ1xcXCI+PC9zcGFuPlxcbiAgPGRpdiBjbGFzcz1cXFwic3dhbDItc3VjY2Vzcy1yaW5nXFxcIj48L2Rpdj4gPGRpdiBjbGFzcz1cXFwic3dhbDItc3VjY2Vzcy1maXhcXFwiPjwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cXFwic3dhbDItc3VjY2Vzcy1jaXJjdWxhci1saW5lLXJpZ2h0XFxcIj48L2Rpdj5cXG5cIjtcbiAgY29uc3QgZXJyb3JJY29uSHRtbCA9IFwiXFxuICA8c3BhbiBjbGFzcz1cXFwic3dhbDIteC1tYXJrXFxcIj5cXG4gICAgPHNwYW4gY2xhc3M9XFxcInN3YWwyLXgtbWFyay1saW5lLWxlZnRcXFwiPjwvc3Bhbj5cXG4gICAgPHNwYW4gY2xhc3M9XFxcInN3YWwyLXgtbWFyay1saW5lLXJpZ2h0XFxcIj48L3NwYW4+XFxuICA8L3NwYW4+XFxuXCI7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBpY29uXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICAgKi9cblxuICBjb25zdCBzZXRDb250ZW50ID0gKGljb24sIHBhcmFtcykgPT4ge1xuICAgIGxldCBvbGRDb250ZW50ID0gaWNvbi5pbm5lckhUTUw7XG4gICAgbGV0IG5ld0NvbnRlbnQ7XG5cbiAgICBpZiAocGFyYW1zLmljb25IdG1sKSB7XG4gICAgICBuZXdDb250ZW50ID0gaWNvbkNvbnRlbnQocGFyYW1zLmljb25IdG1sKTtcbiAgICB9IGVsc2UgaWYgKHBhcmFtcy5pY29uID09PSAnc3VjY2VzcycpIHtcbiAgICAgIG5ld0NvbnRlbnQgPSBzdWNjZXNzSWNvbkh0bWw7XG4gICAgICBvbGRDb250ZW50ID0gb2xkQ29udGVudC5yZXBsYWNlKC8gc3R5bGU9XCIuKj9cIi9nLCAnJyk7IC8vIHVuZG8gYWRqdXN0U3VjY2Vzc0ljb25CYWNrZ3JvdW5kQ29sb3IoKVxuICAgIH0gZWxzZSBpZiAocGFyYW1zLmljb24gPT09ICdlcnJvcicpIHtcbiAgICAgIG5ld0NvbnRlbnQgPSBlcnJvckljb25IdG1sO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBkZWZhdWx0SWNvbkh0bWwgPSB7XG4gICAgICAgIHF1ZXN0aW9uOiAnPycsXG4gICAgICAgIHdhcm5pbmc6ICchJyxcbiAgICAgICAgaW5mbzogJ2knXG4gICAgICB9O1xuICAgICAgbmV3Q29udGVudCA9IGljb25Db250ZW50KGRlZmF1bHRJY29uSHRtbFtwYXJhbXMuaWNvbl0pO1xuICAgIH1cblxuICAgIGlmIChvbGRDb250ZW50LnRyaW0oKSAhPT0gbmV3Q29udGVudC50cmltKCkpIHtcbiAgICAgIHNldElubmVySHRtbChpY29uLCBuZXdDb250ZW50KTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBpY29uXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICAgKi9cblxuXG4gIGNvbnN0IHNldENvbG9yID0gKGljb24sIHBhcmFtcykgPT4ge1xuICAgIGlmICghcGFyYW1zLmljb25Db2xvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGljb24uc3R5bGUuY29sb3IgPSBwYXJhbXMuaWNvbkNvbG9yO1xuICAgIGljb24uc3R5bGUuYm9yZGVyQ29sb3IgPSBwYXJhbXMuaWNvbkNvbG9yO1xuXG4gICAgZm9yIChjb25zdCBzZWwgb2YgWycuc3dhbDItc3VjY2Vzcy1saW5lLXRpcCcsICcuc3dhbDItc3VjY2Vzcy1saW5lLWxvbmcnLCAnLnN3YWwyLXgtbWFyay1saW5lLWxlZnQnLCAnLnN3YWwyLXgtbWFyay1saW5lLXJpZ2h0J10pIHtcbiAgICAgIHNldFN0eWxlKGljb24sIHNlbCwgJ2JhY2tncm91bmRDb2xvcicsIHBhcmFtcy5pY29uQ29sb3IpO1xuICAgIH1cblxuICAgIHNldFN0eWxlKGljb24sICcuc3dhbDItc3VjY2Vzcy1yaW5nJywgJ2JvcmRlckNvbG9yJywgcGFyYW1zLmljb25Db2xvcik7XG4gIH07XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGVudFxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cblxuXG4gIGNvbnN0IGljb25Db250ZW50ID0gY29udGVudCA9PiBcIjxkaXYgY2xhc3M9XFxcIlwiLmNvbmNhdChzd2FsQ2xhc3Nlc1snaWNvbi1jb250ZW50J10sIFwiXFxcIj5cIikuY29uY2F0KGNvbnRlbnQsIFwiPC9kaXY+XCIpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnQyfSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAgICovXG5cbiAgY29uc3QgcmVuZGVySW1hZ2UgPSAoaW5zdGFuY2UsIHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IGltYWdlID0gZ2V0SW1hZ2UoKTtcblxuICAgIGlmICghcGFyYW1zLmltYWdlVXJsKSB7XG4gICAgICByZXR1cm4gaGlkZShpbWFnZSk7XG4gICAgfVxuXG4gICAgc2hvdyhpbWFnZSwgJycpOyAvLyBTcmMsIGFsdFxuXG4gICAgaW1hZ2Uuc2V0QXR0cmlidXRlKCdzcmMnLCBwYXJhbXMuaW1hZ2VVcmwpO1xuICAgIGltYWdlLnNldEF0dHJpYnV0ZSgnYWx0JywgcGFyYW1zLmltYWdlQWx0KTsgLy8gV2lkdGgsIGhlaWdodFxuXG4gICAgYXBwbHlOdW1lcmljYWxTdHlsZShpbWFnZSwgJ3dpZHRoJywgcGFyYW1zLmltYWdlV2lkdGgpO1xuICAgIGFwcGx5TnVtZXJpY2FsU3R5bGUoaW1hZ2UsICdoZWlnaHQnLCBwYXJhbXMuaW1hZ2VIZWlnaHQpOyAvLyBDbGFzc1xuXG4gICAgaW1hZ2UuY2xhc3NOYW1lID0gc3dhbENsYXNzZXMuaW1hZ2U7XG4gICAgYXBwbHlDdXN0b21DbGFzcyhpbWFnZSwgcGFyYW1zLCAnaW1hZ2UnKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0Mn0gaW5zdGFuY2VcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gICAqL1xuXG4gIGNvbnN0IHJlbmRlclByb2dyZXNzU3RlcHMgPSAoaW5zdGFuY2UsIHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IHByb2dyZXNzU3RlcHNDb250YWluZXIgPSBnZXRQcm9ncmVzc1N0ZXBzKCk7XG5cbiAgICBpZiAoIXBhcmFtcy5wcm9ncmVzc1N0ZXBzIHx8IHBhcmFtcy5wcm9ncmVzc1N0ZXBzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGhpZGUocHJvZ3Jlc3NTdGVwc0NvbnRhaW5lcik7XG4gICAgfVxuXG4gICAgc2hvdyhwcm9ncmVzc1N0ZXBzQ29udGFpbmVyKTtcbiAgICBwcm9ncmVzc1N0ZXBzQ29udGFpbmVyLnRleHRDb250ZW50ID0gJyc7XG5cbiAgICBpZiAocGFyYW1zLmN1cnJlbnRQcm9ncmVzc1N0ZXAgPj0gcGFyYW1zLnByb2dyZXNzU3RlcHMubGVuZ3RoKSB7XG4gICAgICB3YXJuKCdJbnZhbGlkIGN1cnJlbnRQcm9ncmVzc1N0ZXAgcGFyYW1ldGVyLCBpdCBzaG91bGQgYmUgbGVzcyB0aGFuIHByb2dyZXNzU3RlcHMubGVuZ3RoICcgKyAnKGN1cnJlbnRQcm9ncmVzc1N0ZXAgbGlrZSBKUyBhcnJheXMgc3RhcnRzIGZyb20gMCknKTtcbiAgICB9XG5cbiAgICBwYXJhbXMucHJvZ3Jlc3NTdGVwcy5mb3JFYWNoKChzdGVwLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3Qgc3RlcEVsID0gY3JlYXRlU3RlcEVsZW1lbnQoc3RlcCk7XG4gICAgICBwcm9ncmVzc1N0ZXBzQ29udGFpbmVyLmFwcGVuZENoaWxkKHN0ZXBFbCk7XG5cbiAgICAgIGlmIChpbmRleCA9PT0gcGFyYW1zLmN1cnJlbnRQcm9ncmVzc1N0ZXApIHtcbiAgICAgICAgYWRkQ2xhc3Moc3RlcEVsLCBzd2FsQ2xhc3Nlc1snYWN0aXZlLXByb2dyZXNzLXN0ZXAnXSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCAhPT0gcGFyYW1zLnByb2dyZXNzU3RlcHMubGVuZ3RoIC0gMSkge1xuICAgICAgICBjb25zdCBsaW5lRWwgPSBjcmVhdGVMaW5lRWxlbWVudChwYXJhbXMpO1xuICAgICAgICBwcm9ncmVzc1N0ZXBzQ29udGFpbmVyLmFwcGVuZENoaWxkKGxpbmVFbCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RlcFxuICAgKiBAcmV0dXJucyB7SFRNTExJRWxlbWVudH1cbiAgICovXG5cbiAgY29uc3QgY3JlYXRlU3RlcEVsZW1lbnQgPSBzdGVwID0+IHtcbiAgICBjb25zdCBzdGVwRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuICAgIGFkZENsYXNzKHN0ZXBFbCwgc3dhbENsYXNzZXNbJ3Byb2dyZXNzLXN0ZXAnXSk7XG4gICAgc2V0SW5uZXJIdG1sKHN0ZXBFbCwgc3RlcCk7XG4gICAgcmV0dXJuIHN0ZXBFbDtcbiAgfTtcbiAgLyoqXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICAgKiBAcmV0dXJucyB7SFRNTExJRWxlbWVudH1cbiAgICovXG5cblxuICBjb25zdCBjcmVhdGVMaW5lRWxlbWVudCA9IHBhcmFtcyA9PiB7XG4gICAgY29uc3QgbGluZUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcbiAgICBhZGRDbGFzcyhsaW5lRWwsIHN3YWxDbGFzc2VzWydwcm9ncmVzcy1zdGVwLWxpbmUnXSk7XG5cbiAgICBpZiAocGFyYW1zLnByb2dyZXNzU3RlcHNEaXN0YW5jZSkge1xuICAgICAgYXBwbHlOdW1lcmljYWxTdHlsZShsaW5lRWwsICd3aWR0aCcsIHBhcmFtcy5wcm9ncmVzc1N0ZXBzRGlzdGFuY2UpO1xuICAgIH1cblxuICAgIHJldHVybiBsaW5lRWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydDJ9IGluc3RhbmNlXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICAgKi9cblxuICBjb25zdCByZW5kZXJUaXRsZSA9IChpbnN0YW5jZSwgcGFyYW1zKSA9PiB7XG4gICAgY29uc3QgdGl0bGUgPSBnZXRUaXRsZSgpO1xuICAgIHRvZ2dsZSh0aXRsZSwgcGFyYW1zLnRpdGxlIHx8IHBhcmFtcy50aXRsZVRleHQsICdibG9jaycpO1xuXG4gICAgaWYgKHBhcmFtcy50aXRsZSkge1xuICAgICAgcGFyc2VIdG1sVG9Db250YWluZXIocGFyYW1zLnRpdGxlLCB0aXRsZSk7XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy50aXRsZVRleHQpIHtcbiAgICAgIHRpdGxlLmlubmVyVGV4dCA9IHBhcmFtcy50aXRsZVRleHQ7XG4gICAgfSAvLyBDdXN0b20gY2xhc3NcblxuXG4gICAgYXBwbHlDdXN0b21DbGFzcyh0aXRsZSwgcGFyYW1zLCAndGl0bGUnKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0Mn0gaW5zdGFuY2VcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gICAqL1xuXG4gIGNvbnN0IHJlbmRlclBvcHVwID0gKGluc3RhbmNlLCBwYXJhbXMpID0+IHtcbiAgICBjb25zdCBjb250YWluZXIgPSBnZXRDb250YWluZXIoKTtcbiAgICBjb25zdCBwb3B1cCA9IGdldFBvcHVwKCk7IC8vIFdpZHRoXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3N3ZWV0YWxlcnQyL3N3ZWV0YWxlcnQyL2lzc3Vlcy8yMTcwXG5cbiAgICBpZiAocGFyYW1zLnRvYXN0KSB7XG4gICAgICBhcHBseU51bWVyaWNhbFN0eWxlKGNvbnRhaW5lciwgJ3dpZHRoJywgcGFyYW1zLndpZHRoKTtcbiAgICAgIHBvcHVwLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgcG9wdXAuaW5zZXJ0QmVmb3JlKGdldExvYWRlcigpLCBnZXRJY29uKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcHBseU51bWVyaWNhbFN0eWxlKHBvcHVwLCAnd2lkdGgnLCBwYXJhbXMud2lkdGgpO1xuICAgIH0gLy8gUGFkZGluZ1xuXG5cbiAgICBhcHBseU51bWVyaWNhbFN0eWxlKHBvcHVwLCAncGFkZGluZycsIHBhcmFtcy5wYWRkaW5nKTsgLy8gQ29sb3JcblxuICAgIGlmIChwYXJhbXMuY29sb3IpIHtcbiAgICAgIHBvcHVwLnN0eWxlLmNvbG9yID0gcGFyYW1zLmNvbG9yO1xuICAgIH0gLy8gQmFja2dyb3VuZFxuXG5cbiAgICBpZiAocGFyYW1zLmJhY2tncm91bmQpIHtcbiAgICAgIHBvcHVwLnN0eWxlLmJhY2tncm91bmQgPSBwYXJhbXMuYmFja2dyb3VuZDtcbiAgICB9XG5cbiAgICBoaWRlKGdldFZhbGlkYXRpb25NZXNzYWdlKCkpOyAvLyBDbGFzc2VzXG5cbiAgICBhZGRDbGFzc2VzKHBvcHVwLCBwYXJhbXMpO1xuICB9O1xuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcG9wdXBcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gICAqL1xuXG4gIGNvbnN0IGFkZENsYXNzZXMgPSAocG9wdXAsIHBhcmFtcykgPT4ge1xuICAgIC8vIERlZmF1bHQgQ2xhc3MgKyBzaG93Q2xhc3Mgd2hlbiB1cGRhdGluZyBTd2FsLnVwZGF0ZSh7fSlcbiAgICBwb3B1cC5jbGFzc05hbWUgPSBcIlwiLmNvbmNhdChzd2FsQ2xhc3Nlcy5wb3B1cCwgXCIgXCIpLmNvbmNhdChpc1Zpc2libGUocG9wdXApID8gcGFyYW1zLnNob3dDbGFzcy5wb3B1cCA6ICcnKTtcblxuICAgIGlmIChwYXJhbXMudG9hc3QpIHtcbiAgICAgIGFkZENsYXNzKFtkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIGRvY3VtZW50LmJvZHldLCBzd2FsQ2xhc3Nlc1sndG9hc3Qtc2hvd24nXSk7XG4gICAgICBhZGRDbGFzcyhwb3B1cCwgc3dhbENsYXNzZXMudG9hc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZGRDbGFzcyhwb3B1cCwgc3dhbENsYXNzZXMubW9kYWwpO1xuICAgIH0gLy8gQ3VzdG9tIGNsYXNzXG5cblxuICAgIGFwcGx5Q3VzdG9tQ2xhc3MocG9wdXAsIHBhcmFtcywgJ3BvcHVwJyk7XG5cbiAgICBpZiAodHlwZW9mIHBhcmFtcy5jdXN0b21DbGFzcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGFkZENsYXNzKHBvcHVwLCBwYXJhbXMuY3VzdG9tQ2xhc3MpO1xuICAgIH0gLy8gSWNvbiBjbGFzcyAoIzE4NDIpXG5cblxuICAgIGlmIChwYXJhbXMuaWNvbikge1xuICAgICAgYWRkQ2xhc3MocG9wdXAsIHN3YWxDbGFzc2VzW1wiaWNvbi1cIi5jb25jYXQocGFyYW1zLmljb24pXSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnQyfSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAgICovXG5cbiAgY29uc3QgcmVuZGVyID0gKGluc3RhbmNlLCBwYXJhbXMpID0+IHtcbiAgICByZW5kZXJQb3B1cChpbnN0YW5jZSwgcGFyYW1zKTtcbiAgICByZW5kZXJDb250YWluZXIoaW5zdGFuY2UsIHBhcmFtcyk7XG4gICAgcmVuZGVyUHJvZ3Jlc3NTdGVwcyhpbnN0YW5jZSwgcGFyYW1zKTtcbiAgICByZW5kZXJJY29uKGluc3RhbmNlLCBwYXJhbXMpO1xuICAgIHJlbmRlckltYWdlKGluc3RhbmNlLCBwYXJhbXMpO1xuICAgIHJlbmRlclRpdGxlKGluc3RhbmNlLCBwYXJhbXMpO1xuICAgIHJlbmRlckNsb3NlQnV0dG9uKGluc3RhbmNlLCBwYXJhbXMpO1xuICAgIHJlbmRlckNvbnRlbnQoaW5zdGFuY2UsIHBhcmFtcyk7XG4gICAgcmVuZGVyQWN0aW9ucyhpbnN0YW5jZSwgcGFyYW1zKTtcbiAgICByZW5kZXJGb290ZXIoaW5zdGFuY2UsIHBhcmFtcyk7XG5cbiAgICBpZiAodHlwZW9mIHBhcmFtcy5kaWRSZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBhcmFtcy5kaWRSZW5kZXIoZ2V0UG9wdXAoKSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IERpc21pc3NSZWFzb24gPSBPYmplY3QuZnJlZXplKHtcbiAgICBjYW5jZWw6ICdjYW5jZWwnLFxuICAgIGJhY2tkcm9wOiAnYmFja2Ryb3AnLFxuICAgIGNsb3NlOiAnY2xvc2UnLFxuICAgIGVzYzogJ2VzYycsXG4gICAgdGltZXI6ICd0aW1lcidcbiAgfSk7XG5cbiAgLy8gQWRkaW5nIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIHRvIGVsZW1lbnRzIG91dHNpZGUgb2YgdGhlIGFjdGl2ZSBtb2RhbCBkaWFsb2cgZW5zdXJlcyB0aGF0XG4gIC8vIGVsZW1lbnRzIG5vdCB3aXRoaW4gdGhlIGFjdGl2ZSBtb2RhbCBkaWFsb2cgd2lsbCBub3QgYmUgc3VyZmFjZWQgaWYgYSB1c2VyIG9wZW5zIGEgc2NyZWVuXG4gIC8vIHJlYWRlcuKAmXMgbGlzdCBvZiBlbGVtZW50cyAoaGVhZGluZ3MsIGZvcm0gY29udHJvbHMsIGxhbmRtYXJrcywgZXRjLikgaW4gdGhlIGRvY3VtZW50LlxuXG4gIGNvbnN0IHNldEFyaWFIaWRkZW4gPSAoKSA9PiB7XG4gICAgY29uc3QgYm9keUNoaWxkcmVuID0gdG9BcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAgICBib2R5Q2hpbGRyZW4uZm9yRWFjaChlbCA9PiB7XG4gICAgICBpZiAoZWwgPT09IGdldENvbnRhaW5lcigpIHx8IGVsLmNvbnRhaW5zKGdldENvbnRhaW5lcigpKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChlbC5oYXNBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJykpIHtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdkYXRhLXByZXZpb3VzLWFyaWEtaGlkZGVuJywgZWwuZ2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicpKTtcbiAgICAgIH1cblxuICAgICAgZWwuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IHVuc2V0QXJpYUhpZGRlbiA9ICgpID0+IHtcbiAgICBjb25zdCBib2R5Q2hpbGRyZW4gPSB0b0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICAgIGJvZHlDaGlsZHJlbi5mb3JFYWNoKGVsID0+IHtcbiAgICAgIGlmIChlbC5oYXNBdHRyaWJ1dGUoJ2RhdGEtcHJldmlvdXMtYXJpYS1oaWRkZW4nKSkge1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgZWwuZ2V0QXR0cmlidXRlKCdkYXRhLXByZXZpb3VzLWFyaWEtaGlkZGVuJykpO1xuICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtcHJldmlvdXMtYXJpYS1oaWRkZW4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBjb25zdCBzd2FsU3RyaW5nUGFyYW1zID0gWydzd2FsLXRpdGxlJywgJ3N3YWwtaHRtbCcsICdzd2FsLWZvb3RlciddO1xuICBjb25zdCBnZXRUZW1wbGF0ZVBhcmFtcyA9IHBhcmFtcyA9PiB7XG4gICAgY29uc3QgdGVtcGxhdGUgPSB0eXBlb2YgcGFyYW1zLnRlbXBsYXRlID09PSAnc3RyaW5nJyA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IocGFyYW1zLnRlbXBsYXRlKSA6IHBhcmFtcy50ZW1wbGF0ZTtcblxuICAgIGlmICghdGVtcGxhdGUpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgLyoqIEB0eXBlIHtEb2N1bWVudEZyYWdtZW50fSAqL1xuXG5cbiAgICBjb25zdCB0ZW1wbGF0ZUNvbnRlbnQgPSB0ZW1wbGF0ZS5jb250ZW50O1xuICAgIHNob3dXYXJuaW5nc0ZvckVsZW1lbnRzKHRlbXBsYXRlQ29udGVudCk7XG4gICAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbihnZXRTd2FsUGFyYW1zKHRlbXBsYXRlQ29udGVudCksIGdldFN3YWxCdXR0b25zKHRlbXBsYXRlQ29udGVudCksIGdldFN3YWxJbWFnZSh0ZW1wbGF0ZUNvbnRlbnQpLCBnZXRTd2FsSWNvbih0ZW1wbGF0ZUNvbnRlbnQpLCBnZXRTd2FsSW5wdXQodGVtcGxhdGVDb250ZW50KSwgZ2V0U3dhbFN0cmluZ1BhcmFtcyh0ZW1wbGF0ZUNvbnRlbnQsIHN3YWxTdHJpbmdQYXJhbXMpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICAvKipcbiAgICogQHBhcmFtIHtEb2N1bWVudEZyYWdtZW50fSB0ZW1wbGF0ZUNvbnRlbnRcbiAgICovXG5cbiAgY29uc3QgZ2V0U3dhbFBhcmFtcyA9IHRlbXBsYXRlQ29udGVudCA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgdG9BcnJheSh0ZW1wbGF0ZUNvbnRlbnQucXVlcnlTZWxlY3RvckFsbCgnc3dhbC1wYXJhbScpKS5mb3JFYWNoKHBhcmFtID0+IHtcbiAgICAgIHNob3dXYXJuaW5nc0ZvckF0dHJpYnV0ZXMocGFyYW0sIFsnbmFtZScsICd2YWx1ZSddKTtcbiAgICAgIGNvbnN0IHBhcmFtTmFtZSA9IHBhcmFtLmdldEF0dHJpYnV0ZSgnbmFtZScpO1xuICAgICAgY29uc3QgdmFsdWUgPSBwYXJhbS5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJyk7XG5cbiAgICAgIGlmICh0eXBlb2YgZGVmYXVsdFBhcmFtc1twYXJhbU5hbWVdID09PSAnYm9vbGVhbicgJiYgdmFsdWUgPT09ICdmYWxzZScpIHtcbiAgICAgICAgcmVzdWx0W3BhcmFtTmFtZV0gPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBkZWZhdWx0UGFyYW1zW3BhcmFtTmFtZV0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJlc3VsdFtwYXJhbU5hbWVdID0gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RG9jdW1lbnRGcmFnbWVudH0gdGVtcGxhdGVDb250ZW50XG4gICAqL1xuXG5cbiAgY29uc3QgZ2V0U3dhbEJ1dHRvbnMgPSB0ZW1wbGF0ZUNvbnRlbnQgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIHRvQXJyYXkodGVtcGxhdGVDb250ZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3N3YWwtYnV0dG9uJykpLmZvckVhY2goYnV0dG9uID0+IHtcbiAgICAgIHNob3dXYXJuaW5nc0ZvckF0dHJpYnV0ZXMoYnV0dG9uLCBbJ3R5cGUnLCAnY29sb3InLCAnYXJpYS1sYWJlbCddKTtcbiAgICAgIGNvbnN0IHR5cGUgPSBidXR0b24uZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG4gICAgICByZXN1bHRbXCJcIi5jb25jYXQodHlwZSwgXCJCdXR0b25UZXh0XCIpXSA9IGJ1dHRvbi5pbm5lckhUTUw7XG4gICAgICByZXN1bHRbXCJzaG93XCIuY29uY2F0KGNhcGl0YWxpemVGaXJzdExldHRlcih0eXBlKSwgXCJCdXR0b25cIildID0gdHJ1ZTtcblxuICAgICAgaWYgKGJ1dHRvbi5oYXNBdHRyaWJ1dGUoJ2NvbG9yJykpIHtcbiAgICAgICAgcmVzdWx0W1wiXCIuY29uY2F0KHR5cGUsIFwiQnV0dG9uQ29sb3JcIildID0gYnV0dG9uLmdldEF0dHJpYnV0ZSgnY29sb3InKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJ1dHRvbi5oYXNBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnKSkge1xuICAgICAgICByZXN1bHRbXCJcIi5jb25jYXQodHlwZSwgXCJCdXR0b25BcmlhTGFiZWxcIildID0gYnV0dG9uLmdldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIC8qKlxuICAgKiBAcGFyYW0ge0RvY3VtZW50RnJhZ21lbnR9IHRlbXBsYXRlQ29udGVudFxuICAgKi9cblxuXG4gIGNvbnN0IGdldFN3YWxJbWFnZSA9IHRlbXBsYXRlQ29udGVudCA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi9cblxuICAgIGNvbnN0IGltYWdlID0gdGVtcGxhdGVDb250ZW50LnF1ZXJ5U2VsZWN0b3IoJ3N3YWwtaW1hZ2UnKTtcblxuICAgIGlmIChpbWFnZSkge1xuICAgICAgc2hvd1dhcm5pbmdzRm9yQXR0cmlidXRlcyhpbWFnZSwgWydzcmMnLCAnd2lkdGgnLCAnaGVpZ2h0JywgJ2FsdCddKTtcblxuICAgICAgaWYgKGltYWdlLmhhc0F0dHJpYnV0ZSgnc3JjJykpIHtcbiAgICAgICAgcmVzdWx0LmltYWdlVXJsID0gaW1hZ2UuZ2V0QXR0cmlidXRlKCdzcmMnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGltYWdlLmhhc0F0dHJpYnV0ZSgnd2lkdGgnKSkge1xuICAgICAgICByZXN1bHQuaW1hZ2VXaWR0aCA9IGltYWdlLmdldEF0dHJpYnV0ZSgnd2lkdGgnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGltYWdlLmhhc0F0dHJpYnV0ZSgnaGVpZ2h0JykpIHtcbiAgICAgICAgcmVzdWx0LmltYWdlSGVpZ2h0ID0gaW1hZ2UuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGltYWdlLmhhc0F0dHJpYnV0ZSgnYWx0JykpIHtcbiAgICAgICAgcmVzdWx0LmltYWdlQWx0ID0gaW1hZ2UuZ2V0QXR0cmlidXRlKCdhbHQnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICAvKipcbiAgICogQHBhcmFtIHtEb2N1bWVudEZyYWdtZW50fSB0ZW1wbGF0ZUNvbnRlbnRcbiAgICovXG5cblxuICBjb25zdCBnZXRTd2FsSWNvbiA9IHRlbXBsYXRlQ29udGVudCA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi9cblxuICAgIGNvbnN0IGljb24gPSB0ZW1wbGF0ZUNvbnRlbnQucXVlcnlTZWxlY3Rvcignc3dhbC1pY29uJyk7XG5cbiAgICBpZiAoaWNvbikge1xuICAgICAgc2hvd1dhcm5pbmdzRm9yQXR0cmlidXRlcyhpY29uLCBbJ3R5cGUnLCAnY29sb3InXSk7XG5cbiAgICAgIGlmIChpY29uLmhhc0F0dHJpYnV0ZSgndHlwZScpKSB7XG4gICAgICAgIHJlc3VsdC5pY29uID0gaWNvbi5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGljb24uaGFzQXR0cmlidXRlKCdjb2xvcicpKSB7XG4gICAgICAgIHJlc3VsdC5pY29uQ29sb3IgPSBpY29uLmdldEF0dHJpYnV0ZSgnY29sb3InKTtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0Lmljb25IdG1sID0gaWNvbi5pbm5lckhUTUw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RG9jdW1lbnRGcmFnbWVudH0gdGVtcGxhdGVDb250ZW50XG4gICAqL1xuXG5cbiAgY29uc3QgZ2V0U3dhbElucHV0ID0gdGVtcGxhdGVDb250ZW50ID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqL1xuXG4gICAgY29uc3QgaW5wdXQgPSB0ZW1wbGF0ZUNvbnRlbnQucXVlcnlTZWxlY3Rvcignc3dhbC1pbnB1dCcpO1xuXG4gICAgaWYgKGlucHV0KSB7XG4gICAgICBzaG93V2FybmluZ3NGb3JBdHRyaWJ1dGVzKGlucHV0LCBbJ3R5cGUnLCAnbGFiZWwnLCAncGxhY2Vob2xkZXInLCAndmFsdWUnXSk7XG4gICAgICByZXN1bHQuaW5wdXQgPSBpbnB1dC5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSB8fCAndGV4dCc7XG5cbiAgICAgIGlmIChpbnB1dC5oYXNBdHRyaWJ1dGUoJ2xhYmVsJykpIHtcbiAgICAgICAgcmVzdWx0LmlucHV0TGFiZWwgPSBpbnB1dC5nZXRBdHRyaWJ1dGUoJ2xhYmVsJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbnB1dC5oYXNBdHRyaWJ1dGUoJ3BsYWNlaG9sZGVyJykpIHtcbiAgICAgICAgcmVzdWx0LmlucHV0UGxhY2Vob2xkZXIgPSBpbnB1dC5nZXRBdHRyaWJ1dGUoJ3BsYWNlaG9sZGVyJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbnB1dC5oYXNBdHRyaWJ1dGUoJ3ZhbHVlJykpIHtcbiAgICAgICAgcmVzdWx0LmlucHV0VmFsdWUgPSBpbnB1dC5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgaW5wdXRPcHRpb25zID0gdGVtcGxhdGVDb250ZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3N3YWwtaW5wdXQtb3B0aW9uJyk7XG5cbiAgICBpZiAoaW5wdXRPcHRpb25zLmxlbmd0aCkge1xuICAgICAgcmVzdWx0LmlucHV0T3B0aW9ucyA9IHt9O1xuICAgICAgdG9BcnJheShpbnB1dE9wdGlvbnMpLmZvckVhY2gob3B0aW9uID0+IHtcbiAgICAgICAgc2hvd1dhcm5pbmdzRm9yQXR0cmlidXRlcyhvcHRpb24sIFsndmFsdWUnXSk7XG4gICAgICAgIGNvbnN0IG9wdGlvblZhbHVlID0gb3B0aW9uLmdldEF0dHJpYnV0ZSgndmFsdWUnKTtcbiAgICAgICAgY29uc3Qgb3B0aW9uTmFtZSA9IG9wdGlvbi5pbm5lckhUTUw7XG4gICAgICAgIHJlc3VsdC5pbnB1dE9wdGlvbnNbb3B0aW9uVmFsdWVdID0gb3B0aW9uTmFtZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIC8qKlxuICAgKiBAcGFyYW0ge0RvY3VtZW50RnJhZ21lbnR9IHRlbXBsYXRlQ29udGVudFxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXJhbU5hbWVzXG4gICAqL1xuXG5cbiAgY29uc3QgZ2V0U3dhbFN0cmluZ1BhcmFtcyA9ICh0ZW1wbGF0ZUNvbnRlbnQsIHBhcmFtTmFtZXMpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcblxuICAgIGZvciAoY29uc3QgaSBpbiBwYXJhbU5hbWVzKSB7XG4gICAgICBjb25zdCBwYXJhbU5hbWUgPSBwYXJhbU5hbWVzW2ldO1xuICAgICAgLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi9cblxuICAgICAgY29uc3QgdGFnID0gdGVtcGxhdGVDb250ZW50LnF1ZXJ5U2VsZWN0b3IocGFyYW1OYW1lKTtcblxuICAgICAgaWYgKHRhZykge1xuICAgICAgICBzaG93V2FybmluZ3NGb3JBdHRyaWJ1dGVzKHRhZywgW10pO1xuICAgICAgICByZXN1bHRbcGFyYW1OYW1lLnJlcGxhY2UoL15zd2FsLS8sICcnKV0gPSB0YWcuaW5uZXJIVE1MLnRyaW0oKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICAvKipcbiAgICogQHBhcmFtIHtEb2N1bWVudEZyYWdtZW50fSB0ZW1wbGF0ZUNvbnRlbnRcbiAgICovXG5cblxuICBjb25zdCBzaG93V2FybmluZ3NGb3JFbGVtZW50cyA9IHRlbXBsYXRlQ29udGVudCA9PiB7XG4gICAgY29uc3QgYWxsb3dlZEVsZW1lbnRzID0gc3dhbFN0cmluZ1BhcmFtcy5jb25jYXQoWydzd2FsLXBhcmFtJywgJ3N3YWwtYnV0dG9uJywgJ3N3YWwtaW1hZ2UnLCAnc3dhbC1pY29uJywgJ3N3YWwtaW5wdXQnLCAnc3dhbC1pbnB1dC1vcHRpb24nXSk7XG4gICAgdG9BcnJheSh0ZW1wbGF0ZUNvbnRlbnQuY2hpbGRyZW4pLmZvckVhY2goZWwgPT4ge1xuICAgICAgY29uc3QgdGFnTmFtZSA9IGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgaWYgKGFsbG93ZWRFbGVtZW50cy5pbmRleE9mKHRhZ05hbWUpID09PSAtMSkge1xuICAgICAgICB3YXJuKFwiVW5yZWNvZ25pemVkIGVsZW1lbnQgPFwiLmNvbmNhdCh0YWdOYW1lLCBcIj5cIikpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gYWxsb3dlZEF0dHJpYnV0ZXNcbiAgICovXG5cblxuICBjb25zdCBzaG93V2FybmluZ3NGb3JBdHRyaWJ1dGVzID0gKGVsLCBhbGxvd2VkQXR0cmlidXRlcykgPT4ge1xuICAgIHRvQXJyYXkoZWwuYXR0cmlidXRlcykuZm9yRWFjaChhdHRyaWJ1dGUgPT4ge1xuICAgICAgaWYgKGFsbG93ZWRBdHRyaWJ1dGVzLmluZGV4T2YoYXR0cmlidXRlLm5hbWUpID09PSAtMSkge1xuICAgICAgICB3YXJuKFtcIlVucmVjb2duaXplZCBhdHRyaWJ1dGUgXFxcIlwiLmNvbmNhdChhdHRyaWJ1dGUubmFtZSwgXCJcXFwiIG9uIDxcIikuY29uY2F0KGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSwgXCI+LlwiKSwgXCJcIi5jb25jYXQoYWxsb3dlZEF0dHJpYnV0ZXMubGVuZ3RoID8gXCJBbGxvd2VkIGF0dHJpYnV0ZXMgYXJlOiBcIi5jb25jYXQoYWxsb3dlZEF0dHJpYnV0ZXMuam9pbignLCAnKSkgOiAnVG8gc2V0IHRoZSB2YWx1ZSwgdXNlIEhUTUwgd2l0aGluIHRoZSBlbGVtZW50LicpXSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGRlZmF1bHRJbnB1dFZhbGlkYXRvcnMgPSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWxpZGF0aW9uTWVzc2FnZVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQgfCBzdHJpbmc+fVxuICAgICAqL1xuICAgIGVtYWlsOiAoc3RyaW5nLCB2YWxpZGF0aW9uTWVzc2FnZSkgPT4ge1xuICAgICAgcmV0dXJuIC9eW2EtekEtWjAtOS4rXy1dK0BbYS16QS1aMC05Li1dK1xcLlthLXpBLVowLTktXXsyLDI0fSQvLnRlc3Qoc3RyaW5nKSA/IFByb21pc2UucmVzb2x2ZSgpIDogUHJvbWlzZS5yZXNvbHZlKHZhbGlkYXRpb25NZXNzYWdlIHx8ICdJbnZhbGlkIGVtYWlsIGFkZHJlc3MnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWxpZGF0aW9uTWVzc2FnZVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQgfCBzdHJpbmc+fVxuICAgICAqL1xuICAgIHVybDogKHN0cmluZywgdmFsaWRhdGlvbk1lc3NhZ2UpID0+IHtcbiAgICAgIC8vIHRha2VuIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM4MDk0MzUgd2l0aCBhIHNtYWxsIGNoYW5nZSBmcm9tICMxMzA2IGFuZCAjMjAxM1xuICAgICAgcmV0dXJuIC9eaHR0cHM/OlxcL1xcLyh3d3dcXC4pP1stYS16QS1aMC05QDolLl8rfiM9XXsxLDI1Nn1cXC5bYS16XXsyLDYzfVxcYihbLWEtekEtWjAtOUA6JV8rLn4jPyYvPV0qKSQvLnRlc3Qoc3RyaW5nKSA/IFByb21pc2UucmVzb2x2ZSgpIDogUHJvbWlzZS5yZXNvbHZlKHZhbGlkYXRpb25NZXNzYWdlIHx8ICdJbnZhbGlkIFVSTCcpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHNldERlZmF1bHRJbnB1dFZhbGlkYXRvcnMocGFyYW1zKSB7XG4gICAgLy8gVXNlIGRlZmF1bHQgYGlucHV0VmFsaWRhdG9yYCBmb3Igc3VwcG9ydGVkIGlucHV0IHR5cGVzIGlmIG5vdCBwcm92aWRlZFxuICAgIGlmICghcGFyYW1zLmlucHV0VmFsaWRhdG9yKSB7XG4gICAgICBPYmplY3Qua2V5cyhkZWZhdWx0SW5wdXRWYWxpZGF0b3JzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIGlmIChwYXJhbXMuaW5wdXQgPT09IGtleSkge1xuICAgICAgICAgIHBhcmFtcy5pbnB1dFZhbGlkYXRvciA9IGRlZmF1bHRJbnB1dFZhbGlkYXRvcnNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAgICovXG5cblxuICBmdW5jdGlvbiB2YWxpZGF0ZUN1c3RvbVRhcmdldEVsZW1lbnQocGFyYW1zKSB7XG4gICAgLy8gRGV0ZXJtaW5lIGlmIHRoZSBjdXN0b20gdGFyZ2V0IGVsZW1lbnQgaXMgdmFsaWRcbiAgICBpZiAoIXBhcmFtcy50YXJnZXQgfHwgdHlwZW9mIHBhcmFtcy50YXJnZXQgPT09ICdzdHJpbmcnICYmICFkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHBhcmFtcy50YXJnZXQpIHx8IHR5cGVvZiBwYXJhbXMudGFyZ2V0ICE9PSAnc3RyaW5nJyAmJiAhcGFyYW1zLnRhcmdldC5hcHBlbmRDaGlsZCkge1xuICAgICAgd2FybignVGFyZ2V0IHBhcmFtZXRlciBpcyBub3QgdmFsaWQsIGRlZmF1bHRpbmcgdG8gXCJib2R5XCInKTtcbiAgICAgIHBhcmFtcy50YXJnZXQgPSAnYm9keSc7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTZXQgdHlwZSwgdGV4dCBhbmQgYWN0aW9ucyBvbiBwb3B1cFxuICAgKlxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAgICovXG5cblxuICBmdW5jdGlvbiBzZXRQYXJhbWV0ZXJzKHBhcmFtcykge1xuICAgIHNldERlZmF1bHRJbnB1dFZhbGlkYXRvcnMocGFyYW1zKTsgLy8gc2hvd0xvYWRlck9uQ29uZmlybSAmJiBwcmVDb25maXJtXG5cbiAgICBpZiAocGFyYW1zLnNob3dMb2FkZXJPbkNvbmZpcm0gJiYgIXBhcmFtcy5wcmVDb25maXJtKSB7XG4gICAgICB3YXJuKCdzaG93TG9hZGVyT25Db25maXJtIGlzIHNldCB0byB0cnVlLCBidXQgcHJlQ29uZmlybSBpcyBub3QgZGVmaW5lZC5cXG4nICsgJ3Nob3dMb2FkZXJPbkNvbmZpcm0gc2hvdWxkIGJlIHVzZWQgdG9nZXRoZXIgd2l0aCBwcmVDb25maXJtLCBzZWUgdXNhZ2UgZXhhbXBsZTpcXG4nICsgJ2h0dHBzOi8vc3dlZXRhbGVydDIuZ2l0aHViLmlvLyNhamF4LXJlcXVlc3QnKTtcbiAgICB9XG5cbiAgICB2YWxpZGF0ZUN1c3RvbVRhcmdldEVsZW1lbnQocGFyYW1zKTsgLy8gUmVwbGFjZSBuZXdsaW5lcyB3aXRoIDxicj4gaW4gdGl0bGVcblxuICAgIGlmICh0eXBlb2YgcGFyYW1zLnRpdGxlID09PSAnc3RyaW5nJykge1xuICAgICAgcGFyYW1zLnRpdGxlID0gcGFyYW1zLnRpdGxlLnNwbGl0KCdcXG4nKS5qb2luKCc8YnIgLz4nKTtcbiAgICB9XG5cbiAgICBpbml0KHBhcmFtcyk7XG4gIH1cblxuICBjbGFzcyBUaW1lciB7XG4gICAgY29uc3RydWN0b3IoY2FsbGJhY2ssIGRlbGF5KSB7XG4gICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICB0aGlzLnJlbWFpbmluZyA9IGRlbGF5O1xuICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgfVxuXG4gICAgc3RhcnQoKSB7XG4gICAgICBpZiAoIXRoaXMucnVubmluZykge1xuICAgICAgICB0aGlzLnJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBuZXcgRGF0ZSgpO1xuICAgICAgICB0aGlzLmlkID0gc2V0VGltZW91dCh0aGlzLmNhbGxiYWNrLCB0aGlzLnJlbWFpbmluZyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJlbWFpbmluZztcbiAgICB9XG5cbiAgICBzdG9wKCkge1xuICAgICAgaWYgKHRoaXMucnVubmluZykge1xuICAgICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaWQpO1xuICAgICAgICB0aGlzLnJlbWFpbmluZyAtPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHRoaXMuc3RhcnRlZC5nZXRUaW1lKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJlbWFpbmluZztcbiAgICB9XG5cbiAgICBpbmNyZWFzZShuKSB7XG4gICAgICBjb25zdCBydW5uaW5nID0gdGhpcy5ydW5uaW5nO1xuXG4gICAgICBpZiAocnVubmluZykge1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5yZW1haW5pbmcgKz0gbjtcblxuICAgICAgaWYgKHJ1bm5pbmcpIHtcbiAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5yZW1haW5pbmc7XG4gICAgfVxuXG4gICAgZ2V0VGltZXJMZWZ0KCkge1xuICAgICAgaWYgKHRoaXMucnVubmluZykge1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5yZW1haW5pbmc7XG4gICAgfVxuXG4gICAgaXNSdW5uaW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXMucnVubmluZztcbiAgICB9XG5cbiAgfVxuXG4gIGNvbnN0IGZpeFNjcm9sbGJhciA9ICgpID0+IHtcbiAgICAvLyBmb3IgcXVldWVzLCBkbyBub3QgZG8gdGhpcyBtb3JlIHRoYW4gb25jZVxuICAgIGlmIChzdGF0ZXMucHJldmlvdXNCb2R5UGFkZGluZyAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gaWYgdGhlIGJvZHkgaGFzIG92ZXJmbG93XG5cblxuICAgIGlmIChkb2N1bWVudC5ib2R5LnNjcm9sbEhlaWdodCA+IHdpbmRvdy5pbm5lckhlaWdodCkge1xuICAgICAgLy8gYWRkIHBhZGRpbmcgc28gdGhlIGNvbnRlbnQgZG9lc24ndCBzaGlmdCBhZnRlciByZW1vdmFsIG9mIHNjcm9sbGJhclxuICAgICAgc3RhdGVzLnByZXZpb3VzQm9keVBhZGRpbmcgPSBwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5ib2R5KS5nZXRQcm9wZXJ0eVZhbHVlKCdwYWRkaW5nLXJpZ2h0JykpO1xuICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5wYWRkaW5nUmlnaHQgPSBcIlwiLmNvbmNhdChzdGF0ZXMucHJldmlvdXNCb2R5UGFkZGluZyArIG1lYXN1cmVTY3JvbGxiYXIoKSwgXCJweFwiKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHVuZG9TY3JvbGxiYXIgPSAoKSA9PiB7XG4gICAgaWYgKHN0YXRlcy5wcmV2aW91c0JvZHlQYWRkaW5nICE9PSBudWxsKSB7XG4gICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLnBhZGRpbmdSaWdodCA9IFwiXCIuY29uY2F0KHN0YXRlcy5wcmV2aW91c0JvZHlQYWRkaW5nLCBcInB4XCIpO1xuICAgICAgc3RhdGVzLnByZXZpb3VzQm9keVBhZGRpbmcgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZmlsZSAqL1xuXG4gIGNvbnN0IGlPU2ZpeCA9ICgpID0+IHtcbiAgICBjb25zdCBpT1MgPSAvLyBAdHMtaWdub3JlXG4gICAgL2lQYWR8aVBob25lfGlQb2QvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIXdpbmRvdy5NU1N0cmVhbSB8fCBuYXZpZ2F0b3IucGxhdGZvcm0gPT09ICdNYWNJbnRlbCcgJiYgbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMTtcblxuICAgIGlmIChpT1MgJiYgIWhhc0NsYXNzKGRvY3VtZW50LmJvZHksIHN3YWxDbGFzc2VzLmlvc2ZpeCkpIHtcbiAgICAgIGNvbnN0IG9mZnNldCA9IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wO1xuICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS50b3AgPSBcIlwiLmNvbmNhdChvZmZzZXQgKiAtMSwgXCJweFwiKTtcbiAgICAgIGFkZENsYXNzKGRvY3VtZW50LmJvZHksIHN3YWxDbGFzc2VzLmlvc2ZpeCk7XG4gICAgICBsb2NrQm9keVNjcm9sbCgpO1xuICAgICAgYWRkQm90dG9tUGFkZGluZ0ZvclRhbGxQb3B1cHMoKTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vc3dlZXRhbGVydDIvc3dlZXRhbGVydDIvaXNzdWVzLzE5NDhcbiAgICovXG5cbiAgY29uc3QgYWRkQm90dG9tUGFkZGluZ0ZvclRhbGxQb3B1cHMgPSAoKSA9PiB7XG4gICAgY29uc3QgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuICAgIGNvbnN0IGlPUyA9ICEhdWEubWF0Y2goL2lQYWQvaSkgfHwgISF1YS5tYXRjaCgvaVBob25lL2kpO1xuICAgIGNvbnN0IHdlYmtpdCA9ICEhdWEubWF0Y2goL1dlYktpdC9pKTtcbiAgICBjb25zdCBpT1NTYWZhcmkgPSBpT1MgJiYgd2Via2l0ICYmICF1YS5tYXRjaCgvQ3JpT1MvaSk7XG5cbiAgICBpZiAoaU9TU2FmYXJpKSB7XG4gICAgICBjb25zdCBib3R0b21QYW5lbEhlaWdodCA9IDQ0O1xuXG4gICAgICBpZiAoZ2V0UG9wdXAoKS5zY3JvbGxIZWlnaHQgPiB3aW5kb3cuaW5uZXJIZWlnaHQgLSBib3R0b21QYW5lbEhlaWdodCkge1xuICAgICAgICBnZXRDb250YWluZXIoKS5zdHlsZS5wYWRkaW5nQm90dG9tID0gXCJcIi5jb25jYXQoYm90dG9tUGFuZWxIZWlnaHQsIFwicHhcIik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL3N3ZWV0YWxlcnQyL3N3ZWV0YWxlcnQyL2lzc3Vlcy8xMjQ2XG4gICAqL1xuXG5cbiAgY29uc3QgbG9ja0JvZHlTY3JvbGwgPSAoKSA9PiB7XG4gICAgY29uc3QgY29udGFpbmVyID0gZ2V0Q29udGFpbmVyKCk7XG4gICAgbGV0IHByZXZlbnRUb3VjaE1vdmU7XG5cbiAgICBjb250YWluZXIub250b3VjaHN0YXJ0ID0gZSA9PiB7XG4gICAgICBwcmV2ZW50VG91Y2hNb3ZlID0gc2hvdWxkUHJldmVudFRvdWNoTW92ZShlKTtcbiAgICB9O1xuXG4gICAgY29udGFpbmVyLm9udG91Y2htb3ZlID0gZSA9PiB7XG4gICAgICBpZiAocHJldmVudFRvdWNoTW92ZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICBjb25zdCBzaG91bGRQcmV2ZW50VG91Y2hNb3ZlID0gZXZlbnQgPT4ge1xuICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICBjb25zdCBjb250YWluZXIgPSBnZXRDb250YWluZXIoKTtcblxuICAgIGlmIChpc1N0eWx1cyhldmVudCkgfHwgaXNab29tKGV2ZW50KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0YXJnZXQgPT09IGNvbnRhaW5lcikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKCFpc1Njcm9sbGFibGUoY29udGFpbmVyKSAmJiB0YXJnZXQudGFnTmFtZSAhPT0gJ0lOUFVUJyAmJiAvLyAjMTYwM1xuICAgIHRhcmdldC50YWdOYW1lICE9PSAnVEVYVEFSRUEnICYmIC8vICMyMjY2XG4gICAgIShpc1Njcm9sbGFibGUoZ2V0SHRtbENvbnRhaW5lcigpKSAmJiAvLyAjMTk0NFxuICAgIGdldEh0bWxDb250YWluZXIoKS5jb250YWlucyh0YXJnZXQpKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICAvKipcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL3N3ZWV0YWxlcnQyL3N3ZWV0YWxlcnQyL2lzc3Vlcy8xNzg2XG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gZXZlbnRcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuXG5cbiAgY29uc3QgaXNTdHlsdXMgPSBldmVudCA9PiB7XG4gICAgcmV0dXJuIGV2ZW50LnRvdWNoZXMgJiYgZXZlbnQudG91Y2hlcy5sZW5ndGggJiYgZXZlbnQudG91Y2hlc1swXS50b3VjaFR5cGUgPT09ICdzdHlsdXMnO1xuICB9O1xuICAvKipcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL3N3ZWV0YWxlcnQyL3N3ZWV0YWxlcnQyL2lzc3Vlcy8xODkxXG4gICAqXG4gICAqIEBwYXJhbSB7VG91Y2hFdmVudH0gZXZlbnRcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuXG5cbiAgY29uc3QgaXNab29tID0gZXZlbnQgPT4ge1xuICAgIHJldHVybiBldmVudC50b3VjaGVzICYmIGV2ZW50LnRvdWNoZXMubGVuZ3RoID4gMTtcbiAgfTtcblxuICBjb25zdCB1bmRvSU9TZml4ID0gKCkgPT4ge1xuICAgIGlmIChoYXNDbGFzcyhkb2N1bWVudC5ib2R5LCBzd2FsQ2xhc3Nlcy5pb3NmaXgpKSB7XG4gICAgICBjb25zdCBvZmZzZXQgPSBwYXJzZUludChkb2N1bWVudC5ib2R5LnN0eWxlLnRvcCwgMTApO1xuICAgICAgcmVtb3ZlQ2xhc3MoZG9jdW1lbnQuYm9keSwgc3dhbENsYXNzZXMuaW9zZml4KTtcbiAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUudG9wID0gJyc7XG4gICAgICBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCA9IG9mZnNldCAqIC0xO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBTSE9XX0NMQVNTX1RJTUVPVVQgPSAxMDtcbiAgLyoqXG4gICAqIE9wZW4gcG9wdXAsIGFkZCBuZWNlc3NhcnkgY2xhc3NlcyBhbmQgc3R5bGVzLCBmaXggc2Nyb2xsYmFyXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICovXG5cbiAgY29uc3Qgb3BlblBvcHVwID0gcGFyYW1zID0+IHtcbiAgICBjb25zdCBjb250YWluZXIgPSBnZXRDb250YWluZXIoKTtcbiAgICBjb25zdCBwb3B1cCA9IGdldFBvcHVwKCk7XG5cbiAgICBpZiAodHlwZW9mIHBhcmFtcy53aWxsT3BlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGFyYW1zLndpbGxPcGVuKHBvcHVwKTtcbiAgICB9XG5cbiAgICBjb25zdCBib2R5U3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuYm9keSk7XG4gICAgY29uc3QgaW5pdGlhbEJvZHlPdmVyZmxvdyA9IGJvZHlTdHlsZXMub3ZlcmZsb3dZO1xuICAgIGFkZENsYXNzZXMkMShjb250YWluZXIsIHBvcHVwLCBwYXJhbXMpOyAvLyBzY3JvbGxpbmcgaXMgJ2hpZGRlbicgdW50aWwgYW5pbWF0aW9uIGlzIGRvbmUsIGFmdGVyIHRoYXQgJ2F1dG8nXG5cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHNldFNjcm9sbGluZ1Zpc2liaWxpdHkoY29udGFpbmVyLCBwb3B1cCk7XG4gICAgfSwgU0hPV19DTEFTU19USU1FT1VUKTtcblxuICAgIGlmIChpc01vZGFsKCkpIHtcbiAgICAgIGZpeFNjcm9sbENvbnRhaW5lcihjb250YWluZXIsIHBhcmFtcy5zY3JvbGxiYXJQYWRkaW5nLCBpbml0aWFsQm9keU92ZXJmbG93KTtcbiAgICAgIHNldEFyaWFIaWRkZW4oKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzVG9hc3QoKSAmJiAhZ2xvYmFsU3RhdGUucHJldmlvdXNBY3RpdmVFbGVtZW50KSB7XG4gICAgICBnbG9iYWxTdGF0ZS5wcmV2aW91c0FjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcGFyYW1zLmRpZE9wZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gcGFyYW1zLmRpZE9wZW4ocG9wdXApKTtcbiAgICB9XG5cbiAgICByZW1vdmVDbGFzcyhjb250YWluZXIsIHN3YWxDbGFzc2VzWyduby10cmFuc2l0aW9uJ10pO1xuICB9O1xuXG4gIGNvbnN0IHN3YWxPcGVuQW5pbWF0aW9uRmluaXNoZWQgPSBldmVudCA9PiB7XG4gICAgY29uc3QgcG9wdXAgPSBnZXRQb3B1cCgpO1xuXG4gICAgaWYgKGV2ZW50LnRhcmdldCAhPT0gcG9wdXApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjb250YWluZXIgPSBnZXRDb250YWluZXIoKTtcbiAgICBwb3B1cC5yZW1vdmVFdmVudExpc3RlbmVyKGFuaW1hdGlvbkVuZEV2ZW50LCBzd2FsT3BlbkFuaW1hdGlvbkZpbmlzaGVkKTtcbiAgICBjb250YWluZXIuc3R5bGUub3ZlcmZsb3dZID0gJ2F1dG8nO1xuICB9O1xuXG4gIGNvbnN0IHNldFNjcm9sbGluZ1Zpc2liaWxpdHkgPSAoY29udGFpbmVyLCBwb3B1cCkgPT4ge1xuICAgIGlmIChhbmltYXRpb25FbmRFdmVudCAmJiBoYXNDc3NBbmltYXRpb24ocG9wdXApKSB7XG4gICAgICBjb250YWluZXIuc3R5bGUub3ZlcmZsb3dZID0gJ2hpZGRlbic7XG4gICAgICBwb3B1cC5hZGRFdmVudExpc3RlbmVyKGFuaW1hdGlvbkVuZEV2ZW50LCBzd2FsT3BlbkFuaW1hdGlvbkZpbmlzaGVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGFpbmVyLnN0eWxlLm92ZXJmbG93WSA9ICdhdXRvJztcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgZml4U2Nyb2xsQ29udGFpbmVyID0gKGNvbnRhaW5lciwgc2Nyb2xsYmFyUGFkZGluZywgaW5pdGlhbEJvZHlPdmVyZmxvdykgPT4ge1xuICAgIGlPU2ZpeCgpO1xuXG4gICAgaWYgKHNjcm9sbGJhclBhZGRpbmcgJiYgaW5pdGlhbEJvZHlPdmVyZmxvdyAhPT0gJ2hpZGRlbicpIHtcbiAgICAgIGZpeFNjcm9sbGJhcigpO1xuICAgIH0gLy8gc3dlZXRhbGVydDIvaXNzdWVzLzEyNDdcblxuXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBjb250YWluZXIuc2Nyb2xsVG9wID0gMDtcbiAgICB9KTtcbiAgfTtcblxuICBjb25zdCBhZGRDbGFzc2VzJDEgPSAoY29udGFpbmVyLCBwb3B1cCwgcGFyYW1zKSA9PiB7XG4gICAgYWRkQ2xhc3MoY29udGFpbmVyLCBwYXJhbXMuc2hvd0NsYXNzLmJhY2tkcm9wKTsgLy8gdGhpcyB3b3JrYXJvdW5kIHdpdGggb3BhY2l0eSBpcyBuZWVkZWQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9zd2VldGFsZXJ0Mi9zd2VldGFsZXJ0Mi9pc3N1ZXMvMjA1OVxuXG4gICAgcG9wdXAuc3R5bGUuc2V0UHJvcGVydHkoJ29wYWNpdHknLCAnMCcsICdpbXBvcnRhbnQnKTtcbiAgICBzaG93KHBvcHVwLCAnZ3JpZCcpO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgLy8gQW5pbWF0ZSBwb3B1cCByaWdodCBhZnRlciBzaG93aW5nIGl0XG4gICAgICBhZGRDbGFzcyhwb3B1cCwgcGFyYW1zLnNob3dDbGFzcy5wb3B1cCk7IC8vIGFuZCByZW1vdmUgdGhlIG9wYWNpdHkgd29ya2Fyb3VuZFxuXG4gICAgICBwb3B1cC5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgnb3BhY2l0eScpO1xuICAgIH0sIFNIT1dfQ0xBU1NfVElNRU9VVCk7IC8vIDEwbXMgaW4gb3JkZXIgdG8gZml4ICMyMDYyXG5cbiAgICBhZGRDbGFzcyhbZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBkb2N1bWVudC5ib2R5XSwgc3dhbENsYXNzZXMuc2hvd24pO1xuXG4gICAgaWYgKHBhcmFtcy5oZWlnaHRBdXRvICYmIHBhcmFtcy5iYWNrZHJvcCAmJiAhcGFyYW1zLnRvYXN0KSB7XG4gICAgICBhZGRDbGFzcyhbZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBkb2N1bWVudC5ib2R5XSwgc3dhbENsYXNzZXNbJ2hlaWdodC1hdXRvJ10pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2hvd3MgbG9hZGVyIChzcGlubmVyKSwgdGhpcyBpcyB1c2VmdWwgd2l0aCBBSkFYIHJlcXVlc3RzLlxuICAgKiBCeSBkZWZhdWx0IHRoZSBsb2FkZXIgYmUgc2hvd24gaW5zdGVhZCBvZiB0aGUgXCJDb25maXJtXCIgYnV0dG9uLlxuICAgKi9cblxuICBjb25zdCBzaG93TG9hZGluZyA9IGJ1dHRvblRvUmVwbGFjZSA9PiB7XG4gICAgbGV0IHBvcHVwID0gZ2V0UG9wdXAoKTtcblxuICAgIGlmICghcG9wdXApIHtcbiAgICAgIG5ldyBTd2FsKCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgfVxuXG4gICAgcG9wdXAgPSBnZXRQb3B1cCgpO1xuICAgIGNvbnN0IGxvYWRlciA9IGdldExvYWRlcigpO1xuXG4gICAgaWYgKGlzVG9hc3QoKSkge1xuICAgICAgaGlkZShnZXRJY29uKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXBsYWNlQnV0dG9uKHBvcHVwLCBidXR0b25Ub1JlcGxhY2UpO1xuICAgIH1cblxuICAgIHNob3cobG9hZGVyKTtcbiAgICBwb3B1cC5zZXRBdHRyaWJ1dGUoJ2RhdGEtbG9hZGluZycsICd0cnVlJyk7XG4gICAgcG9wdXAuc2V0QXR0cmlidXRlKCdhcmlhLWJ1c3knLCAndHJ1ZScpO1xuICAgIHBvcHVwLmZvY3VzKCk7XG4gIH07XG5cbiAgY29uc3QgcmVwbGFjZUJ1dHRvbiA9IChwb3B1cCwgYnV0dG9uVG9SZXBsYWNlKSA9PiB7XG4gICAgY29uc3QgYWN0aW9ucyA9IGdldEFjdGlvbnMoKTtcbiAgICBjb25zdCBsb2FkZXIgPSBnZXRMb2FkZXIoKTtcblxuICAgIGlmICghYnV0dG9uVG9SZXBsYWNlICYmIGlzVmlzaWJsZShnZXRDb25maXJtQnV0dG9uKCkpKSB7XG4gICAgICBidXR0b25Ub1JlcGxhY2UgPSBnZXRDb25maXJtQnV0dG9uKCk7XG4gICAgfVxuXG4gICAgc2hvdyhhY3Rpb25zKTtcblxuICAgIGlmIChidXR0b25Ub1JlcGxhY2UpIHtcbiAgICAgIGhpZGUoYnV0dG9uVG9SZXBsYWNlKTtcbiAgICAgIGxvYWRlci5zZXRBdHRyaWJ1dGUoJ2RhdGEtYnV0dG9uLXRvLXJlcGxhY2UnLCBidXR0b25Ub1JlcGxhY2UuY2xhc3NOYW1lKTtcbiAgICB9XG5cbiAgICBsb2FkZXIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobG9hZGVyLCBidXR0b25Ub1JlcGxhY2UpO1xuICAgIGFkZENsYXNzKFtwb3B1cCwgYWN0aW9uc10sIHN3YWxDbGFzc2VzLmxvYWRpbmcpO1xuICB9O1xuXG4gIGNvbnN0IGhhbmRsZUlucHV0T3B0aW9uc0FuZFZhbHVlID0gKGluc3RhbmNlLCBwYXJhbXMpID0+IHtcbiAgICBpZiAocGFyYW1zLmlucHV0ID09PSAnc2VsZWN0JyB8fCBwYXJhbXMuaW5wdXQgPT09ICdyYWRpbycpIHtcbiAgICAgIGhhbmRsZUlucHV0T3B0aW9ucyhpbnN0YW5jZSwgcGFyYW1zKTtcbiAgICB9IGVsc2UgaWYgKFsndGV4dCcsICdlbWFpbCcsICdudW1iZXInLCAndGVsJywgJ3RleHRhcmVhJ10uaW5jbHVkZXMocGFyYW1zLmlucHV0KSAmJiAoaGFzVG9Qcm9taXNlRm4ocGFyYW1zLmlucHV0VmFsdWUpIHx8IGlzUHJvbWlzZShwYXJhbXMuaW5wdXRWYWx1ZSkpKSB7XG4gICAgICBzaG93TG9hZGluZyhnZXRDb25maXJtQnV0dG9uKCkpO1xuICAgICAgaGFuZGxlSW5wdXRWYWx1ZShpbnN0YW5jZSwgcGFyYW1zKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGdldElucHV0VmFsdWUgPSAoaW5zdGFuY2UsIGlubmVyUGFyYW1zKSA9PiB7XG4gICAgY29uc3QgaW5wdXQgPSBpbnN0YW5jZS5nZXRJbnB1dCgpO1xuXG4gICAgaWYgKCFpbnB1dCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgc3dpdGNoIChpbm5lclBhcmFtcy5pbnB1dCkge1xuICAgICAgY2FzZSAnY2hlY2tib3gnOlxuICAgICAgICByZXR1cm4gZ2V0Q2hlY2tib3hWYWx1ZShpbnB1dCk7XG5cbiAgICAgIGNhc2UgJ3JhZGlvJzpcbiAgICAgICAgcmV0dXJuIGdldFJhZGlvVmFsdWUoaW5wdXQpO1xuXG4gICAgICBjYXNlICdmaWxlJzpcbiAgICAgICAgcmV0dXJuIGdldEZpbGVWYWx1ZShpbnB1dCk7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBpbm5lclBhcmFtcy5pbnB1dEF1dG9UcmltID8gaW5wdXQudmFsdWUudHJpbSgpIDogaW5wdXQudmFsdWU7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGdldENoZWNrYm94VmFsdWUgPSBpbnB1dCA9PiBpbnB1dC5jaGVja2VkID8gMSA6IDA7XG5cbiAgY29uc3QgZ2V0UmFkaW9WYWx1ZSA9IGlucHV0ID0+IGlucHV0LmNoZWNrZWQgPyBpbnB1dC52YWx1ZSA6IG51bGw7XG5cbiAgY29uc3QgZ2V0RmlsZVZhbHVlID0gaW5wdXQgPT4gaW5wdXQuZmlsZXMubGVuZ3RoID8gaW5wdXQuZ2V0QXR0cmlidXRlKCdtdWx0aXBsZScpICE9PSBudWxsID8gaW5wdXQuZmlsZXMgOiBpbnB1dC5maWxlc1swXSA6IG51bGw7XG5cbiAgY29uc3QgaGFuZGxlSW5wdXRPcHRpb25zID0gKGluc3RhbmNlLCBwYXJhbXMpID0+IHtcbiAgICBjb25zdCBwb3B1cCA9IGdldFBvcHVwKCk7XG5cbiAgICBjb25zdCBwcm9jZXNzSW5wdXRPcHRpb25zID0gaW5wdXRPcHRpb25zID0+IHBvcHVsYXRlSW5wdXRPcHRpb25zW3BhcmFtcy5pbnB1dF0ocG9wdXAsIGZvcm1hdElucHV0T3B0aW9ucyhpbnB1dE9wdGlvbnMpLCBwYXJhbXMpO1xuXG4gICAgaWYgKGhhc1RvUHJvbWlzZUZuKHBhcmFtcy5pbnB1dE9wdGlvbnMpIHx8IGlzUHJvbWlzZShwYXJhbXMuaW5wdXRPcHRpb25zKSkge1xuICAgICAgc2hvd0xvYWRpbmcoZ2V0Q29uZmlybUJ1dHRvbigpKTtcbiAgICAgIGFzUHJvbWlzZShwYXJhbXMuaW5wdXRPcHRpb25zKS50aGVuKGlucHV0T3B0aW9ucyA9PiB7XG4gICAgICAgIGluc3RhbmNlLmhpZGVMb2FkaW5nKCk7XG4gICAgICAgIHByb2Nlc3NJbnB1dE9wdGlvbnMoaW5wdXRPcHRpb25zKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHBhcmFtcy5pbnB1dE9wdGlvbnMgPT09ICdvYmplY3QnKSB7XG4gICAgICBwcm9jZXNzSW5wdXRPcHRpb25zKHBhcmFtcy5pbnB1dE9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvcihcIlVuZXhwZWN0ZWQgdHlwZSBvZiBpbnB1dE9wdGlvbnMhIEV4cGVjdGVkIG9iamVjdCwgTWFwIG9yIFByb21pc2UsIGdvdCBcIi5jb25jYXQodHlwZW9mIHBhcmFtcy5pbnB1dE9wdGlvbnMpKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlSW5wdXRWYWx1ZSA9IChpbnN0YW5jZSwgcGFyYW1zKSA9PiB7XG4gICAgY29uc3QgaW5wdXQgPSBpbnN0YW5jZS5nZXRJbnB1dCgpO1xuICAgIGhpZGUoaW5wdXQpO1xuICAgIGFzUHJvbWlzZShwYXJhbXMuaW5wdXRWYWx1ZSkudGhlbihpbnB1dFZhbHVlID0+IHtcbiAgICAgIGlucHV0LnZhbHVlID0gcGFyYW1zLmlucHV0ID09PSAnbnVtYmVyJyA/IHBhcnNlRmxvYXQoaW5wdXRWYWx1ZSkgfHwgMCA6IFwiXCIuY29uY2F0KGlucHV0VmFsdWUpO1xuICAgICAgc2hvdyhpbnB1dCk7XG4gICAgICBpbnB1dC5mb2N1cygpO1xuICAgICAgaW5zdGFuY2UuaGlkZUxvYWRpbmcoKTtcbiAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgZXJyb3IoXCJFcnJvciBpbiBpbnB1dFZhbHVlIHByb21pc2U6IFwiLmNvbmNhdChlcnIpKTtcbiAgICAgIGlucHV0LnZhbHVlID0gJyc7XG4gICAgICBzaG93KGlucHV0KTtcbiAgICAgIGlucHV0LmZvY3VzKCk7XG4gICAgICBpbnN0YW5jZS5oaWRlTG9hZGluZygpO1xuICAgIH0pO1xuICB9O1xuXG4gIGNvbnN0IHBvcHVsYXRlSW5wdXRPcHRpb25zID0ge1xuICAgIHNlbGVjdDogKHBvcHVwLCBpbnB1dE9wdGlvbnMsIHBhcmFtcykgPT4ge1xuICAgICAgY29uc3Qgc2VsZWN0ID0gZ2V0RGlyZWN0Q2hpbGRCeUNsYXNzKHBvcHVwLCBzd2FsQ2xhc3Nlcy5zZWxlY3QpO1xuXG4gICAgICBjb25zdCByZW5kZXJPcHRpb24gPSAocGFyZW50LCBvcHRpb25MYWJlbCwgb3B0aW9uVmFsdWUpID0+IHtcbiAgICAgICAgY29uc3Qgb3B0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0aW9uJyk7XG4gICAgICAgIG9wdGlvbi52YWx1ZSA9IG9wdGlvblZhbHVlO1xuICAgICAgICBzZXRJbm5lckh0bWwob3B0aW9uLCBvcHRpb25MYWJlbCk7XG4gICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IGlzU2VsZWN0ZWQob3B0aW9uVmFsdWUsIHBhcmFtcy5pbnB1dFZhbHVlKTtcbiAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKG9wdGlvbik7XG4gICAgICB9O1xuXG4gICAgICBpbnB1dE9wdGlvbnMuZm9yRWFjaChpbnB1dE9wdGlvbiA9PiB7XG4gICAgICAgIGNvbnN0IG9wdGlvblZhbHVlID0gaW5wdXRPcHRpb25bMF07XG4gICAgICAgIGNvbnN0IG9wdGlvbkxhYmVsID0gaW5wdXRPcHRpb25bMV07IC8vIDxvcHRncm91cD4gc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw0MDEvaW50ZXJhY3QvZm9ybXMuaHRtbCNoLTE3LjZcbiAgICAgICAgLy8gXCIuLi5hbGwgT1BUR1JPVVAgZWxlbWVudHMgbXVzdCBiZSBzcGVjaWZpZWQgZGlyZWN0bHkgd2l0aGluIGEgU0VMRUNUIGVsZW1lbnQgKGkuZS4sIGdyb3VwcyBtYXkgbm90IGJlIG5lc3RlZCkuLi5cIlxuICAgICAgICAvLyBjaGVjayB3aGV0aGVyIHRoaXMgaXMgYSA8b3B0Z3JvdXA+XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9uTGFiZWwpKSB7XG4gICAgICAgICAgLy8gaWYgaXQgaXMgYW4gYXJyYXksIHRoZW4gaXQgaXMgYW4gPG9wdGdyb3VwPlxuICAgICAgICAgIGNvbnN0IG9wdGdyb3VwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0Z3JvdXAnKTtcbiAgICAgICAgICBvcHRncm91cC5sYWJlbCA9IG9wdGlvblZhbHVlO1xuICAgICAgICAgIG9wdGdyb3VwLmRpc2FibGVkID0gZmFsc2U7IC8vIG5vdCBjb25maWd1cmFibGUgZm9yIG5vd1xuXG4gICAgICAgICAgc2VsZWN0LmFwcGVuZENoaWxkKG9wdGdyb3VwKTtcbiAgICAgICAgICBvcHRpb25MYWJlbC5mb3JFYWNoKG8gPT4gcmVuZGVyT3B0aW9uKG9wdGdyb3VwLCBvWzFdLCBvWzBdKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY2FzZSBvZiA8b3B0aW9uPlxuICAgICAgICAgIHJlbmRlck9wdGlvbihzZWxlY3QsIG9wdGlvbkxhYmVsLCBvcHRpb25WYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgc2VsZWN0LmZvY3VzKCk7XG4gICAgfSxcbiAgICByYWRpbzogKHBvcHVwLCBpbnB1dE9wdGlvbnMsIHBhcmFtcykgPT4ge1xuICAgICAgY29uc3QgcmFkaW8gPSBnZXREaXJlY3RDaGlsZEJ5Q2xhc3MocG9wdXAsIHN3YWxDbGFzc2VzLnJhZGlvKTtcbiAgICAgIGlucHV0T3B0aW9ucy5mb3JFYWNoKGlucHV0T3B0aW9uID0+IHtcbiAgICAgICAgY29uc3QgcmFkaW9WYWx1ZSA9IGlucHV0T3B0aW9uWzBdO1xuICAgICAgICBjb25zdCByYWRpb0xhYmVsID0gaW5wdXRPcHRpb25bMV07XG4gICAgICAgIGNvbnN0IHJhZGlvSW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICBjb25zdCByYWRpb0xhYmVsRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgICAgIHJhZGlvSW5wdXQudHlwZSA9ICdyYWRpbyc7XG4gICAgICAgIHJhZGlvSW5wdXQubmFtZSA9IHN3YWxDbGFzc2VzLnJhZGlvO1xuICAgICAgICByYWRpb0lucHV0LnZhbHVlID0gcmFkaW9WYWx1ZTtcblxuICAgICAgICBpZiAoaXNTZWxlY3RlZChyYWRpb1ZhbHVlLCBwYXJhbXMuaW5wdXRWYWx1ZSkpIHtcbiAgICAgICAgICByYWRpb0lucHV0LmNoZWNrZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgIHNldElubmVySHRtbChsYWJlbCwgcmFkaW9MYWJlbCk7XG4gICAgICAgIGxhYmVsLmNsYXNzTmFtZSA9IHN3YWxDbGFzc2VzLmxhYmVsO1xuICAgICAgICByYWRpb0xhYmVsRWxlbWVudC5hcHBlbmRDaGlsZChyYWRpb0lucHV0KTtcbiAgICAgICAgcmFkaW9MYWJlbEVsZW1lbnQuYXBwZW5kQ2hpbGQobGFiZWwpO1xuICAgICAgICByYWRpby5hcHBlbmRDaGlsZChyYWRpb0xhYmVsRWxlbWVudCk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHJhZGlvcyA9IHJhZGlvLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0Jyk7XG5cbiAgICAgIGlmIChyYWRpb3MubGVuZ3RoKSB7XG4gICAgICAgIHJhZGlvc1swXS5mb2N1cygpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIENvbnZlcnRzIGBpbnB1dE9wdGlvbnNgIGludG8gYW4gYXJyYXkgb2YgYFt2YWx1ZSwgbGFiZWxdYHNcbiAgICogQHBhcmFtIGlucHV0T3B0aW9uc1xuICAgKi9cblxuICBjb25zdCBmb3JtYXRJbnB1dE9wdGlvbnMgPSBpbnB1dE9wdGlvbnMgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuXG4gICAgaWYgKHR5cGVvZiBNYXAgIT09ICd1bmRlZmluZWQnICYmIGlucHV0T3B0aW9ucyBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgaW5wdXRPcHRpb25zLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgbGV0IHZhbHVlRm9ybWF0dGVkID0gdmFsdWU7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZUZvcm1hdHRlZCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAvLyBjYXNlIG9mIDxvcHRncm91cD5cbiAgICAgICAgICB2YWx1ZUZvcm1hdHRlZCA9IGZvcm1hdElucHV0T3B0aW9ucyh2YWx1ZUZvcm1hdHRlZCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQucHVzaChba2V5LCB2YWx1ZUZvcm1hdHRlZF0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIE9iamVjdC5rZXlzKGlucHV0T3B0aW9ucykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBsZXQgdmFsdWVGb3JtYXR0ZWQgPSBpbnB1dE9wdGlvbnNba2V5XTtcblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlRm9ybWF0dGVkID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIC8vIGNhc2Ugb2YgPG9wdGdyb3VwPlxuICAgICAgICAgIHZhbHVlRm9ybWF0dGVkID0gZm9ybWF0SW5wdXRPcHRpb25zKHZhbHVlRm9ybWF0dGVkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5wdXNoKFtrZXksIHZhbHVlRm9ybWF0dGVkXSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIGNvbnN0IGlzU2VsZWN0ZWQgPSAob3B0aW9uVmFsdWUsIGlucHV0VmFsdWUpID0+IHtcbiAgICByZXR1cm4gaW5wdXRWYWx1ZSAmJiBpbnB1dFZhbHVlLnRvU3RyaW5nKCkgPT09IG9wdGlvblZhbHVlLnRvU3RyaW5nKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhpZGVzIGxvYWRlciBhbmQgc2hvd3MgYmFjayB0aGUgYnV0dG9uIHdoaWNoIHdhcyBoaWRkZW4gYnkgLnNob3dMb2FkaW5nKClcbiAgICovXG5cbiAgZnVuY3Rpb24gaGlkZUxvYWRpbmcoKSB7XG4gICAgLy8gZG8gbm90aGluZyBpZiBwb3B1cCBpcyBjbG9zZWRcbiAgICBjb25zdCBpbm5lclBhcmFtcyA9IHByaXZhdGVQcm9wcy5pbm5lclBhcmFtcy5nZXQodGhpcyk7XG5cbiAgICBpZiAoIWlubmVyUGFyYW1zKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZG9tQ2FjaGUgPSBwcml2YXRlUHJvcHMuZG9tQ2FjaGUuZ2V0KHRoaXMpO1xuICAgIGhpZGUoZG9tQ2FjaGUubG9hZGVyKTtcblxuICAgIGlmIChpc1RvYXN0KCkpIHtcbiAgICAgIGlmIChpbm5lclBhcmFtcy5pY29uKSB7XG4gICAgICAgIHNob3coZ2V0SWNvbigpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2hvd1JlbGF0ZWRCdXR0b24oZG9tQ2FjaGUpO1xuICAgIH1cblxuICAgIHJlbW92ZUNsYXNzKFtkb21DYWNoZS5wb3B1cCwgZG9tQ2FjaGUuYWN0aW9uc10sIHN3YWxDbGFzc2VzLmxvYWRpbmcpO1xuICAgIGRvbUNhY2hlLnBvcHVwLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1idXN5Jyk7XG4gICAgZG9tQ2FjaGUucG9wdXAucmVtb3ZlQXR0cmlidXRlKCdkYXRhLWxvYWRpbmcnKTtcbiAgICBkb21DYWNoZS5jb25maXJtQnV0dG9uLmRpc2FibGVkID0gZmFsc2U7XG4gICAgZG9tQ2FjaGUuZGVueUJ1dHRvbi5kaXNhYmxlZCA9IGZhbHNlO1xuICAgIGRvbUNhY2hlLmNhbmNlbEJ1dHRvbi5kaXNhYmxlZCA9IGZhbHNlO1xuICB9XG5cbiAgY29uc3Qgc2hvd1JlbGF0ZWRCdXR0b24gPSBkb21DYWNoZSA9PiB7XG4gICAgY29uc3QgYnV0dG9uVG9SZXBsYWNlID0gZG9tQ2FjaGUucG9wdXAuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShkb21DYWNoZS5sb2FkZXIuZ2V0QXR0cmlidXRlKCdkYXRhLWJ1dHRvbi10by1yZXBsYWNlJykpO1xuXG4gICAgaWYgKGJ1dHRvblRvUmVwbGFjZS5sZW5ndGgpIHtcbiAgICAgIHNob3coYnV0dG9uVG9SZXBsYWNlWzBdLCAnaW5saW5lLWJsb2NrJyk7XG4gICAgfSBlbHNlIGlmIChhbGxCdXR0b25zQXJlSGlkZGVuKCkpIHtcbiAgICAgIGhpZGUoZG9tQ2FjaGUuYWN0aW9ucyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBpbnB1dCBET00gbm9kZSwgdGhpcyBtZXRob2Qgd29ya3Mgd2l0aCBpbnB1dCBwYXJhbWV0ZXIuXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudCB8IG51bGx9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGdldElucHV0JDEoaW5zdGFuY2UpIHtcbiAgICBjb25zdCBpbm5lclBhcmFtcyA9IHByaXZhdGVQcm9wcy5pbm5lclBhcmFtcy5nZXQoaW5zdGFuY2UgfHwgdGhpcyk7XG4gICAgY29uc3QgZG9tQ2FjaGUgPSBwcml2YXRlUHJvcHMuZG9tQ2FjaGUuZ2V0KGluc3RhbmNlIHx8IHRoaXMpO1xuXG4gICAgaWYgKCFkb21DYWNoZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdldElucHV0KGRvbUNhY2hlLnBvcHVwLCBpbm5lclBhcmFtcy5pbnB1dCk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtb2R1bGUgY29udGFpbnMgYFdlYWtNYXBgcyBmb3IgZWFjaCBlZmZlY3RpdmVseS1cInByaXZhdGUgIHByb3BlcnR5XCIgdGhhdCBhIGBTd2FsYCBoYXMuXG4gICAqIEZvciBleGFtcGxlLCB0byBzZXQgdGhlIHByaXZhdGUgcHJvcGVydHkgXCJmb29cIiBvZiBgdGhpc2AgdG8gXCJiYXJcIiwgeW91IGNhbiBgcHJpdmF0ZVByb3BzLmZvby5zZXQodGhpcywgJ2JhcicpYFxuICAgKiBUaGlzIGlzIHRoZSBhcHByb2FjaCB0aGF0IEJhYmVsIHdpbGwgcHJvYmFibHkgdGFrZSB0byBpbXBsZW1lbnQgcHJpdmF0ZSBtZXRob2RzL2ZpZWxkc1xuICAgKiAgIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXByaXZhdGUtbWV0aG9kc1xuICAgKiAgIGh0dHBzOi8vZ2l0aHViLmNvbS9iYWJlbC9iYWJlbC9wdWxsLzc1NTVcbiAgICogT25jZSB3ZSBoYXZlIHRoZSBjaGFuZ2VzIGZyb20gdGhhdCBQUiBpbiBCYWJlbCwgYW5kIG91ciBjb3JlIGNsYXNzIGZpdHMgcmVhc29uYWJsZSBpbiAqb25lIG1vZHVsZSpcbiAgICogICB0aGVuIHdlIGNhbiB1c2UgdGhhdCBsYW5ndWFnZSBmZWF0dXJlLlxuICAgKi9cbiAgdmFyIHByaXZhdGVNZXRob2RzID0ge1xuICAgIHN3YWxQcm9taXNlUmVzb2x2ZTogbmV3IFdlYWtNYXAoKSxcbiAgICBzd2FsUHJvbWlzZVJlamVjdDogbmV3IFdlYWtNYXAoKVxuICB9O1xuXG4gIC8qXG4gICAqIEdsb2JhbCBmdW5jdGlvbiB0byBkZXRlcm1pbmUgaWYgU3dlZXRBbGVydDIgcG9wdXAgaXMgc2hvd25cbiAgICovXG5cbiAgY29uc3QgaXNWaXNpYmxlJDEgPSAoKSA9PiB7XG4gICAgcmV0dXJuIGlzVmlzaWJsZShnZXRQb3B1cCgpKTtcbiAgfTtcbiAgLypcbiAgICogR2xvYmFsIGZ1bmN0aW9uIHRvIGNsaWNrICdDb25maXJtJyBidXR0b25cbiAgICovXG5cbiAgY29uc3QgY2xpY2tDb25maXJtID0gKCkgPT4gZ2V0Q29uZmlybUJ1dHRvbigpICYmIGdldENvbmZpcm1CdXR0b24oKS5jbGljaygpO1xuICAvKlxuICAgKiBHbG9iYWwgZnVuY3Rpb24gdG8gY2xpY2sgJ0RlbnknIGJ1dHRvblxuICAgKi9cblxuICBjb25zdCBjbGlja0RlbnkgPSAoKSA9PiBnZXREZW55QnV0dG9uKCkgJiYgZ2V0RGVueUJ1dHRvbigpLmNsaWNrKCk7XG4gIC8qXG4gICAqIEdsb2JhbCBmdW5jdGlvbiB0byBjbGljayAnQ2FuY2VsJyBidXR0b25cbiAgICovXG5cbiAgY29uc3QgY2xpY2tDYW5jZWwgPSAoKSA9PiBnZXRDYW5jZWxCdXR0b24oKSAmJiBnZXRDYW5jZWxCdXR0b24oKS5jbGljaygpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0dsb2JhbFN0YXRlfSBnbG9iYWxTdGF0ZVxuICAgKi9cblxuICBjb25zdCByZW1vdmVLZXlkb3duSGFuZGxlciA9IGdsb2JhbFN0YXRlID0+IHtcbiAgICBpZiAoZ2xvYmFsU3RhdGUua2V5ZG93blRhcmdldCAmJiBnbG9iYWxTdGF0ZS5rZXlkb3duSGFuZGxlckFkZGVkKSB7XG4gICAgICBnbG9iYWxTdGF0ZS5rZXlkb3duVGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBnbG9iYWxTdGF0ZS5rZXlkb3duSGFuZGxlciwge1xuICAgICAgICBjYXB0dXJlOiBnbG9iYWxTdGF0ZS5rZXlkb3duTGlzdGVuZXJDYXB0dXJlXG4gICAgICB9KTtcbiAgICAgIGdsb2JhbFN0YXRlLmtleWRvd25IYW5kbGVyQWRkZWQgPSBmYWxzZTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnQyfSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge0dsb2JhbFN0YXRlfSBnbG9iYWxTdGF0ZVxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBpbm5lclBhcmFtc1xuICAgKiBAcGFyYW0geyp9IGRpc21pc3NXaXRoXG4gICAqL1xuXG4gIGNvbnN0IGFkZEtleWRvd25IYW5kbGVyID0gKGluc3RhbmNlLCBnbG9iYWxTdGF0ZSwgaW5uZXJQYXJhbXMsIGRpc21pc3NXaXRoKSA9PiB7XG4gICAgcmVtb3ZlS2V5ZG93bkhhbmRsZXIoZ2xvYmFsU3RhdGUpO1xuXG4gICAgaWYgKCFpbm5lclBhcmFtcy50b2FzdCkge1xuICAgICAgZ2xvYmFsU3RhdGUua2V5ZG93bkhhbmRsZXIgPSBlID0+IGtleWRvd25IYW5kbGVyKGluc3RhbmNlLCBlLCBkaXNtaXNzV2l0aCk7XG5cbiAgICAgIGdsb2JhbFN0YXRlLmtleWRvd25UYXJnZXQgPSBpbm5lclBhcmFtcy5rZXlkb3duTGlzdGVuZXJDYXB0dXJlID8gd2luZG93IDogZ2V0UG9wdXAoKTtcbiAgICAgIGdsb2JhbFN0YXRlLmtleWRvd25MaXN0ZW5lckNhcHR1cmUgPSBpbm5lclBhcmFtcy5rZXlkb3duTGlzdGVuZXJDYXB0dXJlO1xuICAgICAgZ2xvYmFsU3RhdGUua2V5ZG93blRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZ2xvYmFsU3RhdGUua2V5ZG93bkhhbmRsZXIsIHtcbiAgICAgICAgY2FwdHVyZTogZ2xvYmFsU3RhdGUua2V5ZG93bkxpc3RlbmVyQ2FwdHVyZVxuICAgICAgfSk7XG4gICAgICBnbG9iYWxTdGF0ZS5rZXlkb3duSGFuZGxlckFkZGVkID0gdHJ1ZTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBpbm5lclBhcmFtc1xuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluY3JlbWVudFxuICAgKi9cblxuICBjb25zdCBzZXRGb2N1cyA9IChpbm5lclBhcmFtcywgaW5kZXgsIGluY3JlbWVudCkgPT4ge1xuICAgIGNvbnN0IGZvY3VzYWJsZUVsZW1lbnRzID0gZ2V0Rm9jdXNhYmxlRWxlbWVudHMoKTsgLy8gc2VhcmNoIGZvciB2aXNpYmxlIGVsZW1lbnRzIGFuZCBzZWxlY3QgdGhlIG5leHQgcG9zc2libGUgbWF0Y2hcblxuICAgIGlmIChmb2N1c2FibGVFbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgIGluZGV4ID0gaW5kZXggKyBpbmNyZW1lbnQ7IC8vIHJvbGxvdmVyIHRvIGZpcnN0IGl0ZW1cblxuICAgICAgaWYgKGluZGV4ID09PSBmb2N1c2FibGVFbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgaW5kZXggPSAwOyAvLyBnbyB0byBsYXN0IGl0ZW1cbiAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgIGluZGV4ID0gZm9jdXNhYmxlRWxlbWVudHMubGVuZ3RoIC0gMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZvY3VzYWJsZUVsZW1lbnRzW2luZGV4XS5mb2N1cygpO1xuICAgIH0gLy8gbm8gdmlzaWJsZSBmb2N1c2FibGUgZWxlbWVudHMsIGZvY3VzIHRoZSBwb3B1cFxuXG5cbiAgICBnZXRQb3B1cCgpLmZvY3VzKCk7XG4gIH07XG4gIGNvbnN0IGFycm93S2V5c05leHRCdXR0b24gPSBbJ0Fycm93UmlnaHQnLCAnQXJyb3dEb3duJ107XG4gIGNvbnN0IGFycm93S2V5c1ByZXZpb3VzQnV0dG9uID0gWydBcnJvd0xlZnQnLCAnQXJyb3dVcCddO1xuICAvKipcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0Mn0gaW5zdGFuY2VcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGRpc21pc3NXaXRoXG4gICAqL1xuXG4gIGNvbnN0IGtleWRvd25IYW5kbGVyID0gKGluc3RhbmNlLCBlLCBkaXNtaXNzV2l0aCkgPT4ge1xuICAgIGNvbnN0IGlubmVyUGFyYW1zID0gcHJpdmF0ZVByb3BzLmlubmVyUGFyYW1zLmdldChpbnN0YW5jZSk7XG5cbiAgICBpZiAoIWlubmVyUGFyYW1zKSB7XG4gICAgICByZXR1cm47IC8vIFRoaXMgaW5zdGFuY2UgaGFzIGFscmVhZHkgYmVlbiBkZXN0cm95ZWRcbiAgICB9IC8vIElnbm9yZSBrZXlkb3duIGR1cmluZyBJTUUgY29tcG9zaXRpb25cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRG9jdW1lbnQva2V5ZG93bl9ldmVudCNpZ25vcmluZ19rZXlkb3duX2R1cmluZ19pbWVfY29tcG9zaXRpb25cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vc3dlZXRhbGVydDIvc3dlZXRhbGVydDIvaXNzdWVzLzcyMFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zd2VldGFsZXJ0Mi9zd2VldGFsZXJ0Mi9pc3N1ZXMvMjQwNlxuXG5cbiAgICBpZiAoZS5pc0NvbXBvc2luZyB8fCBlLmtleUNvZGUgPT09IDIyOSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpbm5lclBhcmFtcy5zdG9wS2V5ZG93blByb3BhZ2F0aW9uKSB7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0gLy8gRU5URVJcblxuXG4gICAgaWYgKGUua2V5ID09PSAnRW50ZXInKSB7XG4gICAgICBoYW5kbGVFbnRlcihpbnN0YW5jZSwgZSwgaW5uZXJQYXJhbXMpO1xuICAgIH0gLy8gVEFCXG4gICAgZWxzZSBpZiAoZS5rZXkgPT09ICdUYWInKSB7XG4gICAgICBoYW5kbGVUYWIoZSwgaW5uZXJQYXJhbXMpO1xuICAgIH0gLy8gQVJST1dTIC0gc3dpdGNoIGZvY3VzIGJldHdlZW4gYnV0dG9uc1xuICAgIGVsc2UgaWYgKFsuLi5hcnJvd0tleXNOZXh0QnV0dG9uLCAuLi5hcnJvd0tleXNQcmV2aW91c0J1dHRvbl0uaW5jbHVkZXMoZS5rZXkpKSB7XG4gICAgICBoYW5kbGVBcnJvd3MoZS5rZXkpO1xuICAgIH0gLy8gRVNDXG4gICAgZWxzZSBpZiAoZS5rZXkgPT09ICdFc2NhcGUnKSB7XG4gICAgICBoYW5kbGVFc2MoZSwgaW5uZXJQYXJhbXMsIGRpc21pc3NXaXRoKTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnQyfSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGVcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gaW5uZXJQYXJhbXNcbiAgICovXG5cblxuICBjb25zdCBoYW5kbGVFbnRlciA9IChpbnN0YW5jZSwgZSwgaW5uZXJQYXJhbXMpID0+IHtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vc3dlZXRhbGVydDIvc3dlZXRhbGVydDIvaXNzdWVzLzIzODZcbiAgICBpZiAoIWNhbGxJZkZ1bmN0aW9uKGlubmVyUGFyYW1zLmFsbG93RW50ZXJLZXkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGUudGFyZ2V0ICYmIGluc3RhbmNlLmdldElucHV0KCkgJiYgZS50YXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiBlLnRhcmdldC5vdXRlckhUTUwgPT09IGluc3RhbmNlLmdldElucHV0KCkub3V0ZXJIVE1MKSB7XG4gICAgICBpZiAoWyd0ZXh0YXJlYScsICdmaWxlJ10uaW5jbHVkZXMoaW5uZXJQYXJhbXMuaW5wdXQpKSB7XG4gICAgICAgIHJldHVybjsgLy8gZG8gbm90IHN1Ym1pdFxuICAgICAgfVxuXG4gICAgICBjbGlja0NvbmZpcm0oKTtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGVcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gaW5uZXJQYXJhbXNcbiAgICovXG5cblxuICBjb25zdCBoYW5kbGVUYWIgPSAoZSwgaW5uZXJQYXJhbXMpID0+IHtcbiAgICBjb25zdCB0YXJnZXRFbGVtZW50ID0gZS50YXJnZXQ7XG4gICAgY29uc3QgZm9jdXNhYmxlRWxlbWVudHMgPSBnZXRGb2N1c2FibGVFbGVtZW50cygpO1xuICAgIGxldCBidG5JbmRleCA9IC0xO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmb2N1c2FibGVFbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRhcmdldEVsZW1lbnQgPT09IGZvY3VzYWJsZUVsZW1lbnRzW2ldKSB7XG4gICAgICAgIGJ0bkluZGV4ID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSAvLyBDeWNsZSB0byB0aGUgbmV4dCBidXR0b25cblxuXG4gICAgaWYgKCFlLnNoaWZ0S2V5KSB7XG4gICAgICBzZXRGb2N1cyhpbm5lclBhcmFtcywgYnRuSW5kZXgsIDEpO1xuICAgIH0gLy8gQ3ljbGUgdG8gdGhlIHByZXYgYnV0dG9uXG4gICAgZWxzZSB7XG4gICAgICBzZXRGb2N1cyhpbm5lclBhcmFtcywgYnRuSW5kZXgsIC0xKTtcbiAgICB9XG5cbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgfTtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICovXG5cblxuICBjb25zdCBoYW5kbGVBcnJvd3MgPSBrZXkgPT4ge1xuICAgIGNvbnN0IGNvbmZpcm1CdXR0b24gPSBnZXRDb25maXJtQnV0dG9uKCk7XG4gICAgY29uc3QgZGVueUJ1dHRvbiA9IGdldERlbnlCdXR0b24oKTtcbiAgICBjb25zdCBjYW5jZWxCdXR0b24gPSBnZXRDYW5jZWxCdXR0b24oKTtcblxuICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgIVtjb25maXJtQnV0dG9uLCBkZW55QnV0dG9uLCBjYW5jZWxCdXR0b25dLmluY2x1ZGVzKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc2libGluZyA9IGFycm93S2V5c05leHRCdXR0b24uaW5jbHVkZXMoa2V5KSA/ICduZXh0RWxlbWVudFNpYmxpbmcnIDogJ3ByZXZpb3VzRWxlbWVudFNpYmxpbmcnO1xuICAgIGxldCBidXR0b25Ub0ZvY3VzID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2V0QWN0aW9ucygpLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBidXR0b25Ub0ZvY3VzID0gYnV0dG9uVG9Gb2N1c1tzaWJsaW5nXTtcblxuICAgICAgaWYgKCFidXR0b25Ub0ZvY3VzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGJ1dHRvblRvRm9jdXMgaW5zdGFuY2VvZiBIVE1MQnV0dG9uRWxlbWVudCAmJiBpc1Zpc2libGUoYnV0dG9uVG9Gb2N1cykpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGJ1dHRvblRvRm9jdXMgaW5zdGFuY2VvZiBIVE1MQnV0dG9uRWxlbWVudCkge1xuICAgICAgYnV0dG9uVG9Gb2N1cy5mb2N1cygpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZVxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBpbm5lclBhcmFtc1xuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBkaXNtaXNzV2l0aFxuICAgKi9cblxuXG4gIGNvbnN0IGhhbmRsZUVzYyA9IChlLCBpbm5lclBhcmFtcywgZGlzbWlzc1dpdGgpID0+IHtcbiAgICBpZiAoY2FsbElmRnVuY3Rpb24oaW5uZXJQYXJhbXMuYWxsb3dFc2NhcGVLZXkpKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBkaXNtaXNzV2l0aChEaXNtaXNzUmVhc29uLmVzYyk7XG4gICAgfVxuICB9O1xuXG4gIC8qXG4gICAqIEluc3RhbmNlIG1ldGhvZCB0byBjbG9zZSBzd2VldEFsZXJ0XG4gICAqL1xuXG4gIGZ1bmN0aW9uIHJlbW92ZVBvcHVwQW5kUmVzZXRTdGF0ZShpbnN0YW5jZSwgY29udGFpbmVyLCByZXR1cm5Gb2N1cywgZGlkQ2xvc2UpIHtcbiAgICBpZiAoaXNUb2FzdCgpKSB7XG4gICAgICB0cmlnZ2VyRGlkQ2xvc2VBbmREaXNwb3NlKGluc3RhbmNlLCBkaWRDbG9zZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3RvcmVBY3RpdmVFbGVtZW50KHJldHVybkZvY3VzKS50aGVuKCgpID0+IHRyaWdnZXJEaWRDbG9zZUFuZERpc3Bvc2UoaW5zdGFuY2UsIGRpZENsb3NlKSk7XG4gICAgICByZW1vdmVLZXlkb3duSGFuZGxlcihnbG9iYWxTdGF0ZSk7XG4gICAgfVxuXG4gICAgY29uc3QgaXNTYWZhcmkgPSAvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpOyAvLyB3b3JrYXJvdW5kIGZvciAjMjA4OFxuICAgIC8vIGZvciBzb21lIHJlYXNvbiByZW1vdmluZyB0aGUgY29udGFpbmVyIGluIFNhZmFyaSB3aWxsIHNjcm9sbCB0aGUgZG9jdW1lbnQgdG8gYm90dG9tXG5cbiAgICBpZiAoaXNTYWZhcmkpIHtcbiAgICAgIGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2Rpc3BsYXk6bm9uZSAhaW1wb3J0YW50Jyk7XG4gICAgICBjb250YWluZXIucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICAgICAgY29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250YWluZXIucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgaWYgKGlzTW9kYWwoKSkge1xuICAgICAgdW5kb1Njcm9sbGJhcigpO1xuICAgICAgdW5kb0lPU2ZpeCgpO1xuICAgICAgdW5zZXRBcmlhSGlkZGVuKCk7XG4gICAgfVxuXG4gICAgcmVtb3ZlQm9keUNsYXNzZXMoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUJvZHlDbGFzc2VzKCkge1xuICAgIHJlbW92ZUNsYXNzKFtkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIGRvY3VtZW50LmJvZHldLCBbc3dhbENsYXNzZXMuc2hvd24sIHN3YWxDbGFzc2VzWydoZWlnaHQtYXV0byddLCBzd2FsQ2xhc3Nlc1snbm8tYmFja2Ryb3AnXSwgc3dhbENsYXNzZXNbJ3RvYXN0LXNob3duJ11dKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb3NlKHJlc29sdmVWYWx1ZSkge1xuICAgIHJlc29sdmVWYWx1ZSA9IHByZXBhcmVSZXNvbHZlVmFsdWUocmVzb2x2ZVZhbHVlKTtcbiAgICBjb25zdCBzd2FsUHJvbWlzZVJlc29sdmUgPSBwcml2YXRlTWV0aG9kcy5zd2FsUHJvbWlzZVJlc29sdmUuZ2V0KHRoaXMpO1xuICAgIGNvbnN0IGRpZENsb3NlID0gdHJpZ2dlckNsb3NlUG9wdXAodGhpcyk7XG5cbiAgICBpZiAodGhpcy5pc0F3YWl0aW5nUHJvbWlzZSgpKSB7XG4gICAgICAvLyBBIHN3YWwgYXdhaXRpbmcgZm9yIGEgcHJvbWlzZSAoYWZ0ZXIgYSBjbGljayBvbiBDb25maXJtIG9yIERlbnkpIGNhbm5vdCBiZSBkaXNtaXNzZWQgYW55bW9yZSAjMjMzNVxuICAgICAgaWYgKCFyZXNvbHZlVmFsdWUuaXNEaXNtaXNzZWQpIHtcbiAgICAgICAgaGFuZGxlQXdhaXRpbmdQcm9taXNlKHRoaXMpO1xuICAgICAgICBzd2FsUHJvbWlzZVJlc29sdmUocmVzb2x2ZVZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRpZENsb3NlKSB7XG4gICAgICAvLyBSZXNvbHZlIFN3YWwgcHJvbWlzZVxuICAgICAgc3dhbFByb21pc2VSZXNvbHZlKHJlc29sdmVWYWx1ZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGlzQXdhaXRpbmdQcm9taXNlKCkge1xuICAgIHJldHVybiAhIXByaXZhdGVQcm9wcy5hd2FpdGluZ1Byb21pc2UuZ2V0KHRoaXMpO1xuICB9XG5cbiAgY29uc3QgdHJpZ2dlckNsb3NlUG9wdXAgPSBpbnN0YW5jZSA9PiB7XG4gICAgY29uc3QgcG9wdXAgPSBnZXRQb3B1cCgpO1xuXG4gICAgaWYgKCFwb3B1cCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGlubmVyUGFyYW1zID0gcHJpdmF0ZVByb3BzLmlubmVyUGFyYW1zLmdldChpbnN0YW5jZSk7XG5cbiAgICBpZiAoIWlubmVyUGFyYW1zIHx8IGhhc0NsYXNzKHBvcHVwLCBpbm5lclBhcmFtcy5oaWRlQ2xhc3MucG9wdXApKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmVtb3ZlQ2xhc3MocG9wdXAsIGlubmVyUGFyYW1zLnNob3dDbGFzcy5wb3B1cCk7XG4gICAgYWRkQ2xhc3MocG9wdXAsIGlubmVyUGFyYW1zLmhpZGVDbGFzcy5wb3B1cCk7XG4gICAgY29uc3QgYmFja2Ryb3AgPSBnZXRDb250YWluZXIoKTtcbiAgICByZW1vdmVDbGFzcyhiYWNrZHJvcCwgaW5uZXJQYXJhbXMuc2hvd0NsYXNzLmJhY2tkcm9wKTtcbiAgICBhZGRDbGFzcyhiYWNrZHJvcCwgaW5uZXJQYXJhbXMuaGlkZUNsYXNzLmJhY2tkcm9wKTtcbiAgICBoYW5kbGVQb3B1cEFuaW1hdGlvbihpbnN0YW5jZSwgcG9wdXAsIGlubmVyUGFyYW1zKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBmdW5jdGlvbiByZWplY3RQcm9taXNlKGVycm9yKSB7XG4gICAgY29uc3QgcmVqZWN0UHJvbWlzZSA9IHByaXZhdGVNZXRob2RzLnN3YWxQcm9taXNlUmVqZWN0LmdldCh0aGlzKTtcbiAgICBoYW5kbGVBd2FpdGluZ1Byb21pc2UodGhpcyk7XG5cbiAgICBpZiAocmVqZWN0UHJvbWlzZSkge1xuICAgICAgLy8gUmVqZWN0IFN3YWwgcHJvbWlzZVxuICAgICAgcmVqZWN0UHJvbWlzZShlcnJvcik7XG4gICAgfVxuICB9XG4gIGNvbnN0IGhhbmRsZUF3YWl0aW5nUHJvbWlzZSA9IGluc3RhbmNlID0+IHtcbiAgICBpZiAoaW5zdGFuY2UuaXNBd2FpdGluZ1Byb21pc2UoKSkge1xuICAgICAgcHJpdmF0ZVByb3BzLmF3YWl0aW5nUHJvbWlzZS5kZWxldGUoaW5zdGFuY2UpOyAvLyBUaGUgaW5zdGFuY2UgbWlnaHQgaGF2ZSBiZWVuIHByZXZpb3VzbHkgcGFydGx5IGRlc3Ryb3llZCwgd2UgbXVzdCByZXN1bWUgdGhlIGRlc3Ryb3kgcHJvY2VzcyBpbiB0aGlzIGNhc2UgIzIzMzVcblxuICAgICAgaWYgKCFwcml2YXRlUHJvcHMuaW5uZXJQYXJhbXMuZ2V0KGluc3RhbmNlKSkge1xuICAgICAgICBpbnN0YW5jZS5fZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBjb25zdCBwcmVwYXJlUmVzb2x2ZVZhbHVlID0gcmVzb2x2ZVZhbHVlID0+IHtcbiAgICAvLyBXaGVuIHVzZXIgY2FsbHMgU3dhbC5jbG9zZSgpXG4gICAgaWYgKHR5cGVvZiByZXNvbHZlVmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc0NvbmZpcm1lZDogZmFsc2UsXG4gICAgICAgIGlzRGVuaWVkOiBmYWxzZSxcbiAgICAgICAgaXNEaXNtaXNzZWQ6IHRydWVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe1xuICAgICAgaXNDb25maXJtZWQ6IGZhbHNlLFxuICAgICAgaXNEZW5pZWQ6IGZhbHNlLFxuICAgICAgaXNEaXNtaXNzZWQ6IGZhbHNlXG4gICAgfSwgcmVzb2x2ZVZhbHVlKTtcbiAgfTtcblxuICBjb25zdCBoYW5kbGVQb3B1cEFuaW1hdGlvbiA9IChpbnN0YW5jZSwgcG9wdXAsIGlubmVyUGFyYW1zKSA9PiB7XG4gICAgY29uc3QgY29udGFpbmVyID0gZ2V0Q29udGFpbmVyKCk7IC8vIElmIGFuaW1hdGlvbiBpcyBzdXBwb3J0ZWQsIGFuaW1hdGVcblxuICAgIGNvbnN0IGFuaW1hdGlvbklzU3VwcG9ydGVkID0gYW5pbWF0aW9uRW5kRXZlbnQgJiYgaGFzQ3NzQW5pbWF0aW9uKHBvcHVwKTtcblxuICAgIGlmICh0eXBlb2YgaW5uZXJQYXJhbXMud2lsbENsb3NlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbm5lclBhcmFtcy53aWxsQ2xvc2UocG9wdXApO1xuICAgIH1cblxuICAgIGlmIChhbmltYXRpb25Jc1N1cHBvcnRlZCkge1xuICAgICAgYW5pbWF0ZVBvcHVwKGluc3RhbmNlLCBwb3B1cCwgY29udGFpbmVyLCBpbm5lclBhcmFtcy5yZXR1cm5Gb2N1cywgaW5uZXJQYXJhbXMuZGlkQ2xvc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPdGhlcndpc2UsIHJlbW92ZSBpbW1lZGlhdGVseVxuICAgICAgcmVtb3ZlUG9wdXBBbmRSZXNldFN0YXRlKGluc3RhbmNlLCBjb250YWluZXIsIGlubmVyUGFyYW1zLnJldHVybkZvY3VzLCBpbm5lclBhcmFtcy5kaWRDbG9zZSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGFuaW1hdGVQb3B1cCA9IChpbnN0YW5jZSwgcG9wdXAsIGNvbnRhaW5lciwgcmV0dXJuRm9jdXMsIGRpZENsb3NlKSA9PiB7XG4gICAgZ2xvYmFsU3RhdGUuc3dhbENsb3NlRXZlbnRGaW5pc2hlZENhbGxiYWNrID0gcmVtb3ZlUG9wdXBBbmRSZXNldFN0YXRlLmJpbmQobnVsbCwgaW5zdGFuY2UsIGNvbnRhaW5lciwgcmV0dXJuRm9jdXMsIGRpZENsb3NlKTtcbiAgICBwb3B1cC5hZGRFdmVudExpc3RlbmVyKGFuaW1hdGlvbkVuZEV2ZW50LCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKGUudGFyZ2V0ID09PSBwb3B1cCkge1xuICAgICAgICBnbG9iYWxTdGF0ZS5zd2FsQ2xvc2VFdmVudEZpbmlzaGVkQ2FsbGJhY2soKTtcbiAgICAgICAgZGVsZXRlIGdsb2JhbFN0YXRlLnN3YWxDbG9zZUV2ZW50RmluaXNoZWRDYWxsYmFjaztcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBjb25zdCB0cmlnZ2VyRGlkQ2xvc2VBbmREaXNwb3NlID0gKGluc3RhbmNlLCBkaWRDbG9zZSkgPT4ge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBkaWRDbG9zZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBkaWRDbG9zZS5iaW5kKGluc3RhbmNlLnBhcmFtcykoKTtcbiAgICAgIH1cblxuICAgICAgaW5zdGFuY2UuX2Rlc3Ryb3koKTtcbiAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBzZXRCdXR0b25zRGlzYWJsZWQoaW5zdGFuY2UsIGJ1dHRvbnMsIGRpc2FibGVkKSB7XG4gICAgY29uc3QgZG9tQ2FjaGUgPSBwcml2YXRlUHJvcHMuZG9tQ2FjaGUuZ2V0KGluc3RhbmNlKTtcbiAgICBidXR0b25zLmZvckVhY2goYnV0dG9uID0+IHtcbiAgICAgIGRvbUNhY2hlW2J1dHRvbl0uZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldElucHV0RGlzYWJsZWQoaW5wdXQsIGRpc2FibGVkKSB7XG4gICAgaWYgKCFpbnB1dCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChpbnB1dC50eXBlID09PSAncmFkaW8nKSB7XG4gICAgICBjb25zdCByYWRpb3NDb250YWluZXIgPSBpbnB1dC5wYXJlbnROb2RlLnBhcmVudE5vZGU7XG4gICAgICBjb25zdCByYWRpb3MgPSByYWRpb3NDb250YWluZXIucXVlcnlTZWxlY3RvckFsbCgnaW5wdXQnKTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYWRpb3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmFkaW9zW2ldLmRpc2FibGVkID0gZGlzYWJsZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlucHV0LmRpc2FibGVkID0gZGlzYWJsZWQ7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW5hYmxlQnV0dG9ucygpIHtcbiAgICBzZXRCdXR0b25zRGlzYWJsZWQodGhpcywgWydjb25maXJtQnV0dG9uJywgJ2RlbnlCdXR0b24nLCAnY2FuY2VsQnV0dG9uJ10sIGZhbHNlKTtcbiAgfVxuICBmdW5jdGlvbiBkaXNhYmxlQnV0dG9ucygpIHtcbiAgICBzZXRCdXR0b25zRGlzYWJsZWQodGhpcywgWydjb25maXJtQnV0dG9uJywgJ2RlbnlCdXR0b24nLCAnY2FuY2VsQnV0dG9uJ10sIHRydWUpO1xuICB9XG4gIGZ1bmN0aW9uIGVuYWJsZUlucHV0KCkge1xuICAgIHJldHVybiBzZXRJbnB1dERpc2FibGVkKHRoaXMuZ2V0SW5wdXQoKSwgZmFsc2UpO1xuICB9XG4gIGZ1bmN0aW9uIGRpc2FibGVJbnB1dCgpIHtcbiAgICByZXR1cm4gc2V0SW5wdXREaXNhYmxlZCh0aGlzLmdldElucHV0KCksIHRydWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2hvd1ZhbGlkYXRpb25NZXNzYWdlKGVycm9yKSB7XG4gICAgY29uc3QgZG9tQ2FjaGUgPSBwcml2YXRlUHJvcHMuZG9tQ2FjaGUuZ2V0KHRoaXMpO1xuICAgIGNvbnN0IHBhcmFtcyA9IHByaXZhdGVQcm9wcy5pbm5lclBhcmFtcy5nZXQodGhpcyk7XG4gICAgc2V0SW5uZXJIdG1sKGRvbUNhY2hlLnZhbGlkYXRpb25NZXNzYWdlLCBlcnJvcik7XG4gICAgZG9tQ2FjaGUudmFsaWRhdGlvbk1lc3NhZ2UuY2xhc3NOYW1lID0gc3dhbENsYXNzZXNbJ3ZhbGlkYXRpb24tbWVzc2FnZSddO1xuXG4gICAgaWYgKHBhcmFtcy5jdXN0b21DbGFzcyAmJiBwYXJhbXMuY3VzdG9tQ2xhc3MudmFsaWRhdGlvbk1lc3NhZ2UpIHtcbiAgICAgIGFkZENsYXNzKGRvbUNhY2hlLnZhbGlkYXRpb25NZXNzYWdlLCBwYXJhbXMuY3VzdG9tQ2xhc3MudmFsaWRhdGlvbk1lc3NhZ2UpO1xuICAgIH1cblxuICAgIHNob3coZG9tQ2FjaGUudmFsaWRhdGlvbk1lc3NhZ2UpO1xuICAgIGNvbnN0IGlucHV0ID0gdGhpcy5nZXRJbnB1dCgpO1xuXG4gICAgaWYgKGlucHV0KSB7XG4gICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaW52YWxpZCcsIHRydWUpO1xuICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKCdhcmlhLWRlc2NyaWJlZGJ5Jywgc3dhbENsYXNzZXNbJ3ZhbGlkYXRpb24tbWVzc2FnZSddKTtcbiAgICAgIGZvY3VzSW5wdXQoaW5wdXQpO1xuICAgICAgYWRkQ2xhc3MoaW5wdXQsIHN3YWxDbGFzc2VzLmlucHV0ZXJyb3IpO1xuICAgIH1cbiAgfSAvLyBIaWRlIGJsb2NrIHdpdGggdmFsaWRhdGlvbiBtZXNzYWdlXG5cbiAgZnVuY3Rpb24gcmVzZXRWYWxpZGF0aW9uTWVzc2FnZSQxKCkge1xuICAgIGNvbnN0IGRvbUNhY2hlID0gcHJpdmF0ZVByb3BzLmRvbUNhY2hlLmdldCh0aGlzKTtcblxuICAgIGlmIChkb21DYWNoZS52YWxpZGF0aW9uTWVzc2FnZSkge1xuICAgICAgaGlkZShkb21DYWNoZS52YWxpZGF0aW9uTWVzc2FnZSk7XG4gICAgfVxuXG4gICAgY29uc3QgaW5wdXQgPSB0aGlzLmdldElucHV0KCk7XG5cbiAgICBpZiAoaW5wdXQpIHtcbiAgICAgIGlucHV0LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1pbnZhbGlkJyk7XG4gICAgICBpbnB1dC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtZGVzY3JpYmVkYnknKTtcbiAgICAgIHJlbW92ZUNsYXNzKGlucHV0LCBzd2FsQ2xhc3Nlcy5pbnB1dGVycm9yKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRQcm9ncmVzc1N0ZXBzJDEoKSB7XG4gICAgY29uc3QgZG9tQ2FjaGUgPSBwcml2YXRlUHJvcHMuZG9tQ2FjaGUuZ2V0KHRoaXMpO1xuICAgIHJldHVybiBkb21DYWNoZS5wcm9ncmVzc1N0ZXBzO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgcG9wdXAgcGFyYW1ldGVycy5cbiAgICovXG5cbiAgZnVuY3Rpb24gdXBkYXRlKHBhcmFtcykge1xuICAgIGNvbnN0IHBvcHVwID0gZ2V0UG9wdXAoKTtcbiAgICBjb25zdCBpbm5lclBhcmFtcyA9IHByaXZhdGVQcm9wcy5pbm5lclBhcmFtcy5nZXQodGhpcyk7XG5cbiAgICBpZiAoIXBvcHVwIHx8IGhhc0NsYXNzKHBvcHVwLCBpbm5lclBhcmFtcy5oaWRlQ2xhc3MucG9wdXApKSB7XG4gICAgICByZXR1cm4gd2FybihcIllvdSdyZSB0cnlpbmcgdG8gdXBkYXRlIHRoZSBjbG9zZWQgb3IgY2xvc2luZyBwb3B1cCwgdGhhdCB3b24ndCB3b3JrLiBVc2UgdGhlIHVwZGF0ZSgpIG1ldGhvZCBpbiBwcmVDb25maXJtIHBhcmFtZXRlciBvciBzaG93IGEgbmV3IHBvcHVwLlwiKTtcbiAgICB9XG5cbiAgICBjb25zdCB2YWxpZFVwZGF0YWJsZVBhcmFtcyA9IGZpbHRlclZhbGlkUGFyYW1zKHBhcmFtcyk7XG4gICAgY29uc3QgdXBkYXRlZFBhcmFtcyA9IE9iamVjdC5hc3NpZ24oe30sIGlubmVyUGFyYW1zLCB2YWxpZFVwZGF0YWJsZVBhcmFtcyk7XG4gICAgcmVuZGVyKHRoaXMsIHVwZGF0ZWRQYXJhbXMpO1xuICAgIHByaXZhdGVQcm9wcy5pbm5lclBhcmFtcy5zZXQodGhpcywgdXBkYXRlZFBhcmFtcyk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIHZhbHVlOiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnBhcmFtcywgcGFyYW1zKSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBjb25zdCBmaWx0ZXJWYWxpZFBhcmFtcyA9IHBhcmFtcyA9PiB7XG4gICAgY29uc3QgdmFsaWRVcGRhdGFibGVQYXJhbXMgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhwYXJhbXMpLmZvckVhY2gocGFyYW0gPT4ge1xuICAgICAgaWYgKGlzVXBkYXRhYmxlUGFyYW1ldGVyKHBhcmFtKSkge1xuICAgICAgICB2YWxpZFVwZGF0YWJsZVBhcmFtc1twYXJhbV0gPSBwYXJhbXNbcGFyYW1dO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybihcIkludmFsaWQgcGFyYW1ldGVyIHRvIHVwZGF0ZTogXCIuY29uY2F0KHBhcmFtKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHZhbGlkVXBkYXRhYmxlUGFyYW1zO1xuICB9O1xuXG4gIGZ1bmN0aW9uIF9kZXN0cm95KCkge1xuICAgIGNvbnN0IGRvbUNhY2hlID0gcHJpdmF0ZVByb3BzLmRvbUNhY2hlLmdldCh0aGlzKTtcbiAgICBjb25zdCBpbm5lclBhcmFtcyA9IHByaXZhdGVQcm9wcy5pbm5lclBhcmFtcy5nZXQodGhpcyk7XG5cbiAgICBpZiAoIWlubmVyUGFyYW1zKSB7XG4gICAgICBkaXNwb3NlV2Vha01hcHModGhpcyk7IC8vIFRoZSBXZWFrTWFwcyBtaWdodCBoYXZlIGJlZW4gcGFydGx5IGRlc3Ryb3llZCwgd2UgbXVzdCByZWNhbGwgaXQgdG8gZGlzcG9zZSBhbnkgcmVtYWluaW5nIFdlYWtNYXBzICMyMzM1XG5cbiAgICAgIHJldHVybjsgLy8gVGhpcyBpbnN0YW5jZSBoYXMgYWxyZWFkeSBiZWVuIGRlc3Ryb3llZFxuICAgIH0gLy8gQ2hlY2sgaWYgdGhlcmUgaXMgYW5vdGhlciBTd2FsIGNsb3NpbmdcblxuXG4gICAgaWYgKGRvbUNhY2hlLnBvcHVwICYmIGdsb2JhbFN0YXRlLnN3YWxDbG9zZUV2ZW50RmluaXNoZWRDYWxsYmFjaykge1xuICAgICAgZ2xvYmFsU3RhdGUuc3dhbENsb3NlRXZlbnRGaW5pc2hlZENhbGxiYWNrKCk7XG4gICAgICBkZWxldGUgZ2xvYmFsU3RhdGUuc3dhbENsb3NlRXZlbnRGaW5pc2hlZENhbGxiYWNrO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5uZXJQYXJhbXMuZGlkRGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5uZXJQYXJhbXMuZGlkRGVzdHJveSgpO1xuICAgIH1cblxuICAgIGRpc3Bvc2VTd2FsKHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnQyfSBpbnN0YW5jZVxuICAgKi9cblxuICBjb25zdCBkaXNwb3NlU3dhbCA9IGluc3RhbmNlID0+IHtcbiAgICBkaXNwb3NlV2Vha01hcHMoaW5zdGFuY2UpOyAvLyBVbnNldCB0aGlzLnBhcmFtcyBzbyBHQyB3aWxsIGRpc3Bvc2UgaXQgKCMxNTY5KVxuICAgIC8vIEB0cy1pZ25vcmVcblxuICAgIGRlbGV0ZSBpbnN0YW5jZS5wYXJhbXM7IC8vIFVuc2V0IGdsb2JhbFN0YXRlIHByb3BzIHNvIEdDIHdpbGwgZGlzcG9zZSBnbG9iYWxTdGF0ZSAoIzE1NjkpXG5cbiAgICBkZWxldGUgZ2xvYmFsU3RhdGUua2V5ZG93bkhhbmRsZXI7XG4gICAgZGVsZXRlIGdsb2JhbFN0YXRlLmtleWRvd25UYXJnZXQ7IC8vIFVuc2V0IGN1cnJlbnRJbnN0YW5jZVxuXG4gICAgZGVsZXRlIGdsb2JhbFN0YXRlLmN1cnJlbnRJbnN0YW5jZTtcbiAgfTtcbiAgLyoqXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydDJ9IGluc3RhbmNlXG4gICAqL1xuXG5cbiAgY29uc3QgZGlzcG9zZVdlYWtNYXBzID0gaW5zdGFuY2UgPT4ge1xuICAgIC8vIElmIHRoZSBjdXJyZW50IGluc3RhbmNlIGlzIGF3YWl0aW5nIGEgcHJvbWlzZSByZXN1bHQsIHdlIGtlZXAgdGhlIHByaXZhdGVNZXRob2RzIHRvIGNhbGwgdGhlbSBvbmNlIHRoZSBwcm9taXNlIHJlc3VsdCBpcyByZXRyaWV2ZWQgIzIzMzVcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKGluc3RhbmNlLmlzQXdhaXRpbmdQcm9taXNlKCkpIHtcbiAgICAgIHVuc2V0V2Vha01hcHMocHJpdmF0ZVByb3BzLCBpbnN0YW5jZSk7XG4gICAgICBwcml2YXRlUHJvcHMuYXdhaXRpbmdQcm9taXNlLnNldChpbnN0YW5jZSwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVuc2V0V2Vha01hcHMocHJpdmF0ZU1ldGhvZHMsIGluc3RhbmNlKTtcbiAgICAgIHVuc2V0V2Vha01hcHMocHJpdmF0ZVByb3BzLCBpbnN0YW5jZSk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IG9ialxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnQyfSBpbnN0YW5jZVxuICAgKi9cblxuXG4gIGNvbnN0IHVuc2V0V2Vha01hcHMgPSAob2JqLCBpbnN0YW5jZSkgPT4ge1xuICAgIGZvciAoY29uc3QgaSBpbiBvYmopIHtcbiAgICAgIG9ialtpXS5kZWxldGUoaW5zdGFuY2UpO1xuICAgIH1cbiAgfTtcblxuXG5cbiAgdmFyIGluc3RhbmNlTWV0aG9kcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBoaWRlTG9hZGluZzogaGlkZUxvYWRpbmcsXG4gICAgZGlzYWJsZUxvYWRpbmc6IGhpZGVMb2FkaW5nLFxuICAgIGdldElucHV0OiBnZXRJbnB1dCQxLFxuICAgIGNsb3NlOiBjbG9zZSxcbiAgICBpc0F3YWl0aW5nUHJvbWlzZTogaXNBd2FpdGluZ1Byb21pc2UsXG4gICAgcmVqZWN0UHJvbWlzZTogcmVqZWN0UHJvbWlzZSxcbiAgICBoYW5kbGVBd2FpdGluZ1Byb21pc2U6IGhhbmRsZUF3YWl0aW5nUHJvbWlzZSxcbiAgICBjbG9zZVBvcHVwOiBjbG9zZSxcbiAgICBjbG9zZU1vZGFsOiBjbG9zZSxcbiAgICBjbG9zZVRvYXN0OiBjbG9zZSxcbiAgICBlbmFibGVCdXR0b25zOiBlbmFibGVCdXR0b25zLFxuICAgIGRpc2FibGVCdXR0b25zOiBkaXNhYmxlQnV0dG9ucyxcbiAgICBlbmFibGVJbnB1dDogZW5hYmxlSW5wdXQsXG4gICAgZGlzYWJsZUlucHV0OiBkaXNhYmxlSW5wdXQsXG4gICAgc2hvd1ZhbGlkYXRpb25NZXNzYWdlOiBzaG93VmFsaWRhdGlvbk1lc3NhZ2UsXG4gICAgcmVzZXRWYWxpZGF0aW9uTWVzc2FnZTogcmVzZXRWYWxpZGF0aW9uTWVzc2FnZSQxLFxuICAgIGdldFByb2dyZXNzU3RlcHM6IGdldFByb2dyZXNzU3RlcHMkMSxcbiAgICB1cGRhdGU6IHVwZGF0ZSxcbiAgICBfZGVzdHJveTogX2Rlc3Ryb3lcbiAgfSk7XG5cbiAgY29uc3QgaGFuZGxlQ29uZmlybUJ1dHRvbkNsaWNrID0gaW5zdGFuY2UgPT4ge1xuICAgIGNvbnN0IGlubmVyUGFyYW1zID0gcHJpdmF0ZVByb3BzLmlubmVyUGFyYW1zLmdldChpbnN0YW5jZSk7XG4gICAgaW5zdGFuY2UuZGlzYWJsZUJ1dHRvbnMoKTtcblxuICAgIGlmIChpbm5lclBhcmFtcy5pbnB1dCkge1xuICAgICAgaGFuZGxlQ29uZmlybU9yRGVueVdpdGhJbnB1dChpbnN0YW5jZSwgJ2NvbmZpcm0nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uZmlybShpbnN0YW5jZSwgdHJ1ZSk7XG4gICAgfVxuICB9O1xuICBjb25zdCBoYW5kbGVEZW55QnV0dG9uQ2xpY2sgPSBpbnN0YW5jZSA9PiB7XG4gICAgY29uc3QgaW5uZXJQYXJhbXMgPSBwcml2YXRlUHJvcHMuaW5uZXJQYXJhbXMuZ2V0KGluc3RhbmNlKTtcbiAgICBpbnN0YW5jZS5kaXNhYmxlQnV0dG9ucygpO1xuXG4gICAgaWYgKGlubmVyUGFyYW1zLnJldHVybklucHV0VmFsdWVPbkRlbnkpIHtcbiAgICAgIGhhbmRsZUNvbmZpcm1PckRlbnlXaXRoSW5wdXQoaW5zdGFuY2UsICdkZW55Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbnkoaW5zdGFuY2UsIGZhbHNlKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGhhbmRsZUNhbmNlbEJ1dHRvbkNsaWNrID0gKGluc3RhbmNlLCBkaXNtaXNzV2l0aCkgPT4ge1xuICAgIGluc3RhbmNlLmRpc2FibGVCdXR0b25zKCk7XG4gICAgZGlzbWlzc1dpdGgoRGlzbWlzc1JlYXNvbi5jYW5jZWwpO1xuICB9O1xuXG4gIGNvbnN0IGhhbmRsZUNvbmZpcm1PckRlbnlXaXRoSW5wdXQgPSAoaW5zdGFuY2UsIHR5cGVcbiAgLyogJ2NvbmZpcm0nIHwgJ2RlbnknICovXG4gICkgPT4ge1xuICAgIGNvbnN0IGlubmVyUGFyYW1zID0gcHJpdmF0ZVByb3BzLmlubmVyUGFyYW1zLmdldChpbnN0YW5jZSk7XG5cbiAgICBpZiAoIWlubmVyUGFyYW1zLmlucHV0KSB7XG4gICAgICByZXR1cm4gZXJyb3IoXCJUaGUgXFxcImlucHV0XFxcIiBwYXJhbWV0ZXIgaXMgbmVlZGVkIHRvIGJlIHNldCB3aGVuIHVzaW5nIHJldHVybklucHV0VmFsdWVPblwiLmNvbmNhdChjYXBpdGFsaXplRmlyc3RMZXR0ZXIodHlwZSkpKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbnB1dFZhbHVlID0gZ2V0SW5wdXRWYWx1ZShpbnN0YW5jZSwgaW5uZXJQYXJhbXMpO1xuXG4gICAgaWYgKGlubmVyUGFyYW1zLmlucHV0VmFsaWRhdG9yKSB7XG4gICAgICBoYW5kbGVJbnB1dFZhbGlkYXRvcihpbnN0YW5jZSwgaW5wdXRWYWx1ZSwgdHlwZSk7XG4gICAgfSBlbHNlIGlmICghaW5zdGFuY2UuZ2V0SW5wdXQoKS5jaGVja1ZhbGlkaXR5KCkpIHtcbiAgICAgIGluc3RhbmNlLmVuYWJsZUJ1dHRvbnMoKTtcbiAgICAgIGluc3RhbmNlLnNob3dWYWxpZGF0aW9uTWVzc2FnZShpbm5lclBhcmFtcy52YWxpZGF0aW9uTWVzc2FnZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnZGVueScpIHtcbiAgICAgIGRlbnkoaW5zdGFuY2UsIGlucHV0VmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25maXJtKGluc3RhbmNlLCBpbnB1dFZhbHVlKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlSW5wdXRWYWxpZGF0b3IgPSAoaW5zdGFuY2UsIGlucHV0VmFsdWUsIHR5cGVcbiAgLyogJ2NvbmZpcm0nIHwgJ2RlbnknICovXG4gICkgPT4ge1xuICAgIGNvbnN0IGlubmVyUGFyYW1zID0gcHJpdmF0ZVByb3BzLmlubmVyUGFyYW1zLmdldChpbnN0YW5jZSk7XG4gICAgaW5zdGFuY2UuZGlzYWJsZUlucHV0KCk7XG4gICAgY29uc3QgdmFsaWRhdGlvblByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IGFzUHJvbWlzZShpbm5lclBhcmFtcy5pbnB1dFZhbGlkYXRvcihpbnB1dFZhbHVlLCBpbm5lclBhcmFtcy52YWxpZGF0aW9uTWVzc2FnZSkpKTtcbiAgICB2YWxpZGF0aW9uUHJvbWlzZS50aGVuKHZhbGlkYXRpb25NZXNzYWdlID0+IHtcbiAgICAgIGluc3RhbmNlLmVuYWJsZUJ1dHRvbnMoKTtcbiAgICAgIGluc3RhbmNlLmVuYWJsZUlucHV0KCk7XG5cbiAgICAgIGlmICh2YWxpZGF0aW9uTWVzc2FnZSkge1xuICAgICAgICBpbnN0YW5jZS5zaG93VmFsaWRhdGlvbk1lc3NhZ2UodmFsaWRhdGlvbk1lc3NhZ2UpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnZGVueScpIHtcbiAgICAgICAgZGVueShpbnN0YW5jZSwgaW5wdXRWYWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25maXJtKGluc3RhbmNlLCBpbnB1dFZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBjb25zdCBkZW55ID0gKGluc3RhbmNlLCB2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IGlubmVyUGFyYW1zID0gcHJpdmF0ZVByb3BzLmlubmVyUGFyYW1zLmdldChpbnN0YW5jZSB8fCB1bmRlZmluZWQpO1xuXG4gICAgaWYgKGlubmVyUGFyYW1zLnNob3dMb2FkZXJPbkRlbnkpIHtcbiAgICAgIHNob3dMb2FkaW5nKGdldERlbnlCdXR0b24oKSk7XG4gICAgfVxuXG4gICAgaWYgKGlubmVyUGFyYW1zLnByZURlbnkpIHtcbiAgICAgIHByaXZhdGVQcm9wcy5hd2FpdGluZ1Byb21pc2Uuc2V0KGluc3RhbmNlIHx8IHVuZGVmaW5lZCwgdHJ1ZSk7IC8vIEZsYWdnaW5nIHRoZSBpbnN0YW5jZSBhcyBhd2FpdGluZyBhIHByb21pc2Ugc28gaXQncyBvd24gcHJvbWlzZSdzIHJlamVjdC9yZXNvbHZlIG1ldGhvZHMgZG9lc24ndCBnZXQgZGVzdHJveWVkIHVudGlsIHRoZSByZXN1bHQgZnJvbSB0aGlzIHByZURlbnkncyBwcm9taXNlIGlzIHJlY2VpdmVkXG5cbiAgICAgIGNvbnN0IHByZURlbnlQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiBhc1Byb21pc2UoaW5uZXJQYXJhbXMucHJlRGVueSh2YWx1ZSwgaW5uZXJQYXJhbXMudmFsaWRhdGlvbk1lc3NhZ2UpKSk7XG4gICAgICBwcmVEZW55UHJvbWlzZS50aGVuKHByZURlbnlWYWx1ZSA9PiB7XG4gICAgICAgIGlmIChwcmVEZW55VmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgaW5zdGFuY2UuaGlkZUxvYWRpbmcoKTtcbiAgICAgICAgICBoYW5kbGVBd2FpdGluZ1Byb21pc2UoaW5zdGFuY2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluc3RhbmNlLmNsb3NlUG9wdXAoe1xuICAgICAgICAgICAgaXNEZW5pZWQ6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHlwZW9mIHByZURlbnlWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyB2YWx1ZSA6IHByZURlbnlWYWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KS5jYXRjaChlcnJvciQkMSA9PiByZWplY3RXaXRoKGluc3RhbmNlIHx8IHVuZGVmaW5lZCwgZXJyb3IkJDEpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5zdGFuY2UuY2xvc2VQb3B1cCh7XG4gICAgICAgIGlzRGVuaWVkOiB0cnVlLFxuICAgICAgICB2YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHN1Y2NlZWRXaXRoID0gKGluc3RhbmNlLCB2YWx1ZSkgPT4ge1xuICAgIGluc3RhbmNlLmNsb3NlUG9wdXAoe1xuICAgICAgaXNDb25maXJtZWQ6IHRydWUsXG4gICAgICB2YWx1ZVxuICAgIH0pO1xuICB9O1xuXG4gIGNvbnN0IHJlamVjdFdpdGggPSAoaW5zdGFuY2UsIGVycm9yJCQxKSA9PiB7XG4gICAgaW5zdGFuY2UucmVqZWN0UHJvbWlzZShlcnJvciQkMSk7XG4gIH07XG5cbiAgY29uc3QgY29uZmlybSA9IChpbnN0YW5jZSwgdmFsdWUpID0+IHtcbiAgICBjb25zdCBpbm5lclBhcmFtcyA9IHByaXZhdGVQcm9wcy5pbm5lclBhcmFtcy5nZXQoaW5zdGFuY2UgfHwgdW5kZWZpbmVkKTtcblxuICAgIGlmIChpbm5lclBhcmFtcy5zaG93TG9hZGVyT25Db25maXJtKSB7XG4gICAgICBzaG93TG9hZGluZygpO1xuICAgIH1cblxuICAgIGlmIChpbm5lclBhcmFtcy5wcmVDb25maXJtKSB7XG4gICAgICBpbnN0YW5jZS5yZXNldFZhbGlkYXRpb25NZXNzYWdlKCk7XG4gICAgICBwcml2YXRlUHJvcHMuYXdhaXRpbmdQcm9taXNlLnNldChpbnN0YW5jZSB8fCB1bmRlZmluZWQsIHRydWUpOyAvLyBGbGFnZ2luZyB0aGUgaW5zdGFuY2UgYXMgYXdhaXRpbmcgYSBwcm9taXNlIHNvIGl0J3Mgb3duIHByb21pc2UncyByZWplY3QvcmVzb2x2ZSBtZXRob2RzIGRvZXNuJ3QgZ2V0IGRlc3Ryb3llZCB1bnRpbCB0aGUgcmVzdWx0IGZyb20gdGhpcyBwcmVDb25maXJtJ3MgcHJvbWlzZSBpcyByZWNlaXZlZFxuXG4gICAgICBjb25zdCBwcmVDb25maXJtUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gYXNQcm9taXNlKGlubmVyUGFyYW1zLnByZUNvbmZpcm0odmFsdWUsIGlubmVyUGFyYW1zLnZhbGlkYXRpb25NZXNzYWdlKSkpO1xuICAgICAgcHJlQ29uZmlybVByb21pc2UudGhlbihwcmVDb25maXJtVmFsdWUgPT4ge1xuICAgICAgICBpZiAoaXNWaXNpYmxlKGdldFZhbGlkYXRpb25NZXNzYWdlKCkpIHx8IHByZUNvbmZpcm1WYWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBpbnN0YW5jZS5oaWRlTG9hZGluZygpO1xuICAgICAgICAgIGhhbmRsZUF3YWl0aW5nUHJvbWlzZShpbnN0YW5jZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3VjY2VlZFdpdGgoaW5zdGFuY2UsIHR5cGVvZiBwcmVDb25maXJtVmFsdWUgPT09ICd1bmRlZmluZWQnID8gdmFsdWUgOiBwcmVDb25maXJtVmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KS5jYXRjaChlcnJvciQkMSA9PiByZWplY3RXaXRoKGluc3RhbmNlIHx8IHVuZGVmaW5lZCwgZXJyb3IkJDEpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3VjY2VlZFdpdGgoaW5zdGFuY2UsIHZhbHVlKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlUG9wdXBDbGljayA9IChpbnN0YW5jZSwgZG9tQ2FjaGUsIGRpc21pc3NXaXRoKSA9PiB7XG4gICAgY29uc3QgaW5uZXJQYXJhbXMgPSBwcml2YXRlUHJvcHMuaW5uZXJQYXJhbXMuZ2V0KGluc3RhbmNlKTtcblxuICAgIGlmIChpbm5lclBhcmFtcy50b2FzdCkge1xuICAgICAgaGFuZGxlVG9hc3RDbGljayhpbnN0YW5jZSwgZG9tQ2FjaGUsIGRpc21pc3NXaXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWdub3JlIGNsaWNrIGV2ZW50cyB0aGF0IGhhZCBtb3VzZWRvd24gb24gdGhlIHBvcHVwIGJ1dCBtb3VzZXVwIG9uIHRoZSBjb250YWluZXJcbiAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiB3aGVuIHRoZSB1c2VyIGRyYWdzIGEgc2xpZGVyXG4gICAgICBoYW5kbGVNb2RhbE1vdXNlZG93bihkb21DYWNoZSk7IC8vIElnbm9yZSBjbGljayBldmVudHMgdGhhdCBoYWQgbW91c2Vkb3duIG9uIHRoZSBjb250YWluZXIgYnV0IG1vdXNldXAgb24gdGhlIHBvcHVwXG5cbiAgICAgIGhhbmRsZUNvbnRhaW5lck1vdXNlZG93bihkb21DYWNoZSk7XG4gICAgICBoYW5kbGVNb2RhbENsaWNrKGluc3RhbmNlLCBkb21DYWNoZSwgZGlzbWlzc1dpdGgpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBoYW5kbGVUb2FzdENsaWNrID0gKGluc3RhbmNlLCBkb21DYWNoZSwgZGlzbWlzc1dpdGgpID0+IHtcbiAgICAvLyBDbG9zaW5nIHRvYXN0IGJ5IGludGVybmFsIGNsaWNrXG4gICAgZG9tQ2FjaGUucG9wdXAub25jbGljayA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGlubmVyUGFyYW1zID0gcHJpdmF0ZVByb3BzLmlubmVyUGFyYW1zLmdldChpbnN0YW5jZSk7XG5cbiAgICAgIGlmIChpbm5lclBhcmFtcyAmJiAoaXNBbnlCdXR0b25TaG93bihpbm5lclBhcmFtcykgfHwgaW5uZXJQYXJhbXMudGltZXIgfHwgaW5uZXJQYXJhbXMuaW5wdXQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZGlzbWlzc1dpdGgoRGlzbWlzc1JlYXNvbi5jbG9zZSk7XG4gICAgfTtcbiAgfTtcbiAgLyoqXG4gICAqIEBwYXJhbSB7Kn0gaW5uZXJQYXJhbXNcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuXG5cbiAgY29uc3QgaXNBbnlCdXR0b25TaG93biA9IGlubmVyUGFyYW1zID0+IHtcbiAgICByZXR1cm4gaW5uZXJQYXJhbXMuc2hvd0NvbmZpcm1CdXR0b24gfHwgaW5uZXJQYXJhbXMuc2hvd0RlbnlCdXR0b24gfHwgaW5uZXJQYXJhbXMuc2hvd0NhbmNlbEJ1dHRvbiB8fCBpbm5lclBhcmFtcy5zaG93Q2xvc2VCdXR0b247XG4gIH07XG5cbiAgbGV0IGlnbm9yZU91dHNpZGVDbGljayA9IGZhbHNlO1xuXG4gIGNvbnN0IGhhbmRsZU1vZGFsTW91c2Vkb3duID0gZG9tQ2FjaGUgPT4ge1xuICAgIGRvbUNhY2hlLnBvcHVwLm9ubW91c2Vkb3duID0gKCkgPT4ge1xuICAgICAgZG9tQ2FjaGUuY29udGFpbmVyLm9ubW91c2V1cCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGRvbUNhY2hlLmNvbnRhaW5lci5vbm1vdXNldXAgPSB1bmRlZmluZWQ7IC8vIFdlIG9ubHkgY2hlY2sgaWYgdGhlIG1vdXNldXAgdGFyZ2V0IGlzIHRoZSBjb250YWluZXIgYmVjYXVzZSB1c3VhbGx5IGl0IGRvZXNuJ3RcbiAgICAgICAgLy8gaGF2ZSBhbnkgb3RoZXIgZGlyZWN0IGNoaWxkcmVuIGFzaWRlIG9mIHRoZSBwb3B1cFxuXG4gICAgICAgIGlmIChlLnRhcmdldCA9PT0gZG9tQ2FjaGUuY29udGFpbmVyKSB7XG4gICAgICAgICAgaWdub3JlT3V0c2lkZUNsaWNrID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuICB9O1xuXG4gIGNvbnN0IGhhbmRsZUNvbnRhaW5lck1vdXNlZG93biA9IGRvbUNhY2hlID0+IHtcbiAgICBkb21DYWNoZS5jb250YWluZXIub25tb3VzZWRvd24gPSAoKSA9PiB7XG4gICAgICBkb21DYWNoZS5wb3B1cC5vbm1vdXNldXAgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBkb21DYWNoZS5wb3B1cC5vbm1vdXNldXAgPSB1bmRlZmluZWQ7IC8vIFdlIGFsc28gbmVlZCB0byBjaGVjayBpZiB0aGUgbW91c2V1cCB0YXJnZXQgaXMgYSBjaGlsZCBvZiB0aGUgcG9wdXBcblxuICAgICAgICBpZiAoZS50YXJnZXQgPT09IGRvbUNhY2hlLnBvcHVwIHx8IGRvbUNhY2hlLnBvcHVwLmNvbnRhaW5zKGUudGFyZ2V0KSkge1xuICAgICAgICAgIGlnbm9yZU91dHNpZGVDbGljayA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcbiAgfTtcblxuICBjb25zdCBoYW5kbGVNb2RhbENsaWNrID0gKGluc3RhbmNlLCBkb21DYWNoZSwgZGlzbWlzc1dpdGgpID0+IHtcbiAgICBkb21DYWNoZS5jb250YWluZXIub25jbGljayA9IGUgPT4ge1xuICAgICAgY29uc3QgaW5uZXJQYXJhbXMgPSBwcml2YXRlUHJvcHMuaW5uZXJQYXJhbXMuZ2V0KGluc3RhbmNlKTtcblxuICAgICAgaWYgKGlnbm9yZU91dHNpZGVDbGljaykge1xuICAgICAgICBpZ25vcmVPdXRzaWRlQ2xpY2sgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZS50YXJnZXQgPT09IGRvbUNhY2hlLmNvbnRhaW5lciAmJiBjYWxsSWZGdW5jdGlvbihpbm5lclBhcmFtcy5hbGxvd091dHNpZGVDbGljaykpIHtcbiAgICAgICAgZGlzbWlzc1dpdGgoRGlzbWlzc1JlYXNvbi5iYWNrZHJvcCk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICBjb25zdCBpc0pxdWVyeUVsZW1lbnQgPSBlbGVtID0+IHR5cGVvZiBlbGVtID09PSAnb2JqZWN0JyAmJiBlbGVtLmpxdWVyeTtcblxuICBjb25zdCBpc0VsZW1lbnQgPSBlbGVtID0+IGVsZW0gaW5zdGFuY2VvZiBFbGVtZW50IHx8IGlzSnF1ZXJ5RWxlbWVudChlbGVtKTtcblxuICBjb25zdCBhcmdzVG9QYXJhbXMgPSBhcmdzID0+IHtcbiAgICBjb25zdCBwYXJhbXMgPSB7fTtcblxuICAgIGlmICh0eXBlb2YgYXJnc1swXSA9PT0gJ29iamVjdCcgJiYgIWlzRWxlbWVudChhcmdzWzBdKSkge1xuICAgICAgT2JqZWN0LmFzc2lnbihwYXJhbXMsIGFyZ3NbMF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBbJ3RpdGxlJywgJ2h0bWwnLCAnaWNvbiddLmZvckVhY2goKG5hbWUsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IGFyZyA9IGFyZ3NbaW5kZXhdO1xuXG4gICAgICAgIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fCBpc0VsZW1lbnQoYXJnKSkge1xuICAgICAgICAgIHBhcmFtc1tuYW1lXSA9IGFyZztcbiAgICAgICAgfSBlbHNlIGlmIChhcmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGVycm9yKFwiVW5leHBlY3RlZCB0eXBlIG9mIFwiLmNvbmNhdChuYW1lLCBcIiEgRXhwZWN0ZWQgXFxcInN0cmluZ1xcXCIgb3IgXFxcIkVsZW1lbnRcXFwiLCBnb3QgXCIpLmNvbmNhdCh0eXBlb2YgYXJnKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJhbXM7XG4gIH07XG5cbiAgZnVuY3Rpb24gZmlyZSgpIHtcbiAgICBjb25zdCBTd2FsID0gdGhpczsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhc1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgU3dhbCguLi5hcmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGV4dGVuZGVkIHZlcnNpb24gb2YgYFN3YWxgIGNvbnRhaW5pbmcgYHBhcmFtc2AgYXMgZGVmYXVsdHMuXG4gICAqIFVzZWZ1bCBmb3IgcmV1c2luZyBTd2FsIGNvbmZpZ3VyYXRpb24uXG4gICAqXG4gICAqIEZvciBleGFtcGxlOlxuICAgKlxuICAgKiBCZWZvcmU6XG4gICAqIGNvbnN0IHRleHRQcm9tcHRPcHRpb25zID0geyBpbnB1dDogJ3RleHQnLCBzaG93Q2FuY2VsQnV0dG9uOiB0cnVlIH1cbiAgICogY29uc3Qge3ZhbHVlOiBmaXJzdE5hbWV9ID0gYXdhaXQgU3dhbC5maXJlKHsgLi4udGV4dFByb21wdE9wdGlvbnMsIHRpdGxlOiAnV2hhdCBpcyB5b3VyIGZpcnN0IG5hbWU/JyB9KVxuICAgKiBjb25zdCB7dmFsdWU6IGxhc3ROYW1lfSA9IGF3YWl0IFN3YWwuZmlyZSh7IC4uLnRleHRQcm9tcHRPcHRpb25zLCB0aXRsZTogJ1doYXQgaXMgeW91ciBsYXN0IG5hbWU/JyB9KVxuICAgKlxuICAgKiBBZnRlcjpcbiAgICogY29uc3QgVGV4dFByb21wdCA9IFN3YWwubWl4aW4oeyBpbnB1dDogJ3RleHQnLCBzaG93Q2FuY2VsQnV0dG9uOiB0cnVlIH0pXG4gICAqIGNvbnN0IHt2YWx1ZTogZmlyc3ROYW1lfSA9IGF3YWl0IFRleHRQcm9tcHQoJ1doYXQgaXMgeW91ciBmaXJzdCBuYW1lPycpXG4gICAqIGNvbnN0IHt2YWx1ZTogbGFzdE5hbWV9ID0gYXdhaXQgVGV4dFByb21wdCgnV2hhdCBpcyB5b3VyIGxhc3QgbmFtZT8nKVxuICAgKlxuICAgKiBAcGFyYW0gbWl4aW5QYXJhbXNcbiAgICovXG4gIGZ1bmN0aW9uIG1peGluKG1peGluUGFyYW1zKSB7XG4gICAgY2xhc3MgTWl4aW5Td2FsIGV4dGVuZHMgdGhpcyB7XG4gICAgICBfbWFpbihwYXJhbXMsIHByaW9yaXR5TWl4aW5QYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLl9tYWluKHBhcmFtcywgT2JqZWN0LmFzc2lnbih7fSwgbWl4aW5QYXJhbXMsIHByaW9yaXR5TWl4aW5QYXJhbXMpKTtcbiAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiBNaXhpblN3YWw7XG4gIH1cblxuICAvKipcbiAgICogSWYgYHRpbWVyYCBwYXJhbWV0ZXIgaXMgc2V0LCByZXR1cm5zIG51bWJlciBvZiBtaWxsaXNlY29uZHMgb2YgdGltZXIgcmVtYWluZWQuXG4gICAqIE90aGVyd2lzZSwgcmV0dXJucyB1bmRlZmluZWQuXG4gICAqL1xuXG4gIGNvbnN0IGdldFRpbWVyTGVmdCA9ICgpID0+IHtcbiAgICByZXR1cm4gZ2xvYmFsU3RhdGUudGltZW91dCAmJiBnbG9iYWxTdGF0ZS50aW1lb3V0LmdldFRpbWVyTGVmdCgpO1xuICB9O1xuICAvKipcbiAgICogU3RvcCB0aW1lci4gUmV0dXJucyBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIG9mIHRpbWVyIHJlbWFpbmVkLlxuICAgKiBJZiBgdGltZXJgIHBhcmFtZXRlciBpc24ndCBzZXQsIHJldHVybnMgdW5kZWZpbmVkLlxuICAgKi9cblxuICBjb25zdCBzdG9wVGltZXIgPSAoKSA9PiB7XG4gICAgaWYgKGdsb2JhbFN0YXRlLnRpbWVvdXQpIHtcbiAgICAgIHN0b3BUaW1lclByb2dyZXNzQmFyKCk7XG4gICAgICByZXR1cm4gZ2xvYmFsU3RhdGUudGltZW91dC5zdG9wKCk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogUmVzdW1lIHRpbWVyLiBSZXR1cm5zIG51bWJlciBvZiBtaWxsaXNlY29uZHMgb2YgdGltZXIgcmVtYWluZWQuXG4gICAqIElmIGB0aW1lcmAgcGFyYW1ldGVyIGlzbid0IHNldCwgcmV0dXJucyB1bmRlZmluZWQuXG4gICAqL1xuXG4gIGNvbnN0IHJlc3VtZVRpbWVyID0gKCkgPT4ge1xuICAgIGlmIChnbG9iYWxTdGF0ZS50aW1lb3V0KSB7XG4gICAgICBjb25zdCByZW1haW5pbmcgPSBnbG9iYWxTdGF0ZS50aW1lb3V0LnN0YXJ0KCk7XG4gICAgICBhbmltYXRlVGltZXJQcm9ncmVzc0JhcihyZW1haW5pbmcpO1xuICAgICAgcmV0dXJuIHJlbWFpbmluZztcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBSZXN1bWUgdGltZXIuIFJldHVybnMgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBvZiB0aW1lciByZW1haW5lZC5cbiAgICogSWYgYHRpbWVyYCBwYXJhbWV0ZXIgaXNuJ3Qgc2V0LCByZXR1cm5zIHVuZGVmaW5lZC5cbiAgICovXG5cbiAgY29uc3QgdG9nZ2xlVGltZXIgPSAoKSA9PiB7XG4gICAgY29uc3QgdGltZXIgPSBnbG9iYWxTdGF0ZS50aW1lb3V0O1xuICAgIHJldHVybiB0aW1lciAmJiAodGltZXIucnVubmluZyA/IHN0b3BUaW1lcigpIDogcmVzdW1lVGltZXIoKSk7XG4gIH07XG4gIC8qKlxuICAgKiBJbmNyZWFzZSB0aW1lci4gUmV0dXJucyBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIG9mIGFuIHVwZGF0ZWQgdGltZXIuXG4gICAqIElmIGB0aW1lcmAgcGFyYW1ldGVyIGlzbid0IHNldCwgcmV0dXJucyB1bmRlZmluZWQuXG4gICAqL1xuXG4gIGNvbnN0IGluY3JlYXNlVGltZXIgPSBuID0+IHtcbiAgICBpZiAoZ2xvYmFsU3RhdGUudGltZW91dCkge1xuICAgICAgY29uc3QgcmVtYWluaW5nID0gZ2xvYmFsU3RhdGUudGltZW91dC5pbmNyZWFzZShuKTtcbiAgICAgIGFuaW1hdGVUaW1lclByb2dyZXNzQmFyKHJlbWFpbmluZywgdHJ1ZSk7XG4gICAgICByZXR1cm4gcmVtYWluaW5nO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIENoZWNrIGlmIHRpbWVyIGlzIHJ1bm5pbmcuIFJldHVybnMgdHJ1ZSBpZiB0aW1lciBpcyBydW5uaW5nXG4gICAqIG9yIGZhbHNlIGlmIHRpbWVyIGlzIHBhdXNlZCBvciBzdG9wcGVkLlxuICAgKiBJZiBgdGltZXJgIHBhcmFtZXRlciBpc24ndCBzZXQsIHJldHVybnMgdW5kZWZpbmVkXG4gICAqL1xuXG4gIGNvbnN0IGlzVGltZXJSdW5uaW5nID0gKCkgPT4ge1xuICAgIHJldHVybiBnbG9iYWxTdGF0ZS50aW1lb3V0ICYmIGdsb2JhbFN0YXRlLnRpbWVvdXQuaXNSdW5uaW5nKCk7XG4gIH07XG5cbiAgbGV0IGJvZHlDbGlja0xpc3RlbmVyQWRkZWQgPSBmYWxzZTtcbiAgY29uc3QgY2xpY2tIYW5kbGVycyA9IHt9O1xuICBmdW5jdGlvbiBiaW5kQ2xpY2tIYW5kbGVyKCkge1xuICAgIGxldCBhdHRyID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnZGF0YS1zd2FsLXRlbXBsYXRlJztcbiAgICBjbGlja0hhbmRsZXJzW2F0dHJdID0gdGhpcztcblxuICAgIGlmICghYm9keUNsaWNrTGlzdGVuZXJBZGRlZCkge1xuICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGJvZHlDbGlja0xpc3RlbmVyKTtcbiAgICAgIGJvZHlDbGlja0xpc3RlbmVyQWRkZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGJvZHlDbGlja0xpc3RlbmVyID0gZXZlbnQgPT4ge1xuICAgIGZvciAobGV0IGVsID0gZXZlbnQudGFyZ2V0OyBlbCAmJiBlbCAhPT0gZG9jdW1lbnQ7IGVsID0gZWwucGFyZW50Tm9kZSkge1xuICAgICAgZm9yIChjb25zdCBhdHRyIGluIGNsaWNrSGFuZGxlcnMpIHtcbiAgICAgICAgY29uc3QgdGVtcGxhdGUgPSBlbC5nZXRBdHRyaWJ1dGUoYXR0cik7XG5cbiAgICAgICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICAgICAgY2xpY2tIYW5kbGVyc1thdHRyXS5maXJlKHtcbiAgICAgICAgICAgIHRlbXBsYXRlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG5cblxuICB2YXIgc3RhdGljTWV0aG9kcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBpc1ZhbGlkUGFyYW1ldGVyOiBpc1ZhbGlkUGFyYW1ldGVyLFxuICAgIGlzVXBkYXRhYmxlUGFyYW1ldGVyOiBpc1VwZGF0YWJsZVBhcmFtZXRlcixcbiAgICBpc0RlcHJlY2F0ZWRQYXJhbWV0ZXI6IGlzRGVwcmVjYXRlZFBhcmFtZXRlcixcbiAgICBhcmdzVG9QYXJhbXM6IGFyZ3NUb1BhcmFtcyxcbiAgICBpc1Zpc2libGU6IGlzVmlzaWJsZSQxLFxuICAgIGNsaWNrQ29uZmlybTogY2xpY2tDb25maXJtLFxuICAgIGNsaWNrRGVueTogY2xpY2tEZW55LFxuICAgIGNsaWNrQ2FuY2VsOiBjbGlja0NhbmNlbCxcbiAgICBnZXRDb250YWluZXI6IGdldENvbnRhaW5lcixcbiAgICBnZXRQb3B1cDogZ2V0UG9wdXAsXG4gICAgZ2V0VGl0bGU6IGdldFRpdGxlLFxuICAgIGdldEh0bWxDb250YWluZXI6IGdldEh0bWxDb250YWluZXIsXG4gICAgZ2V0SW1hZ2U6IGdldEltYWdlLFxuICAgIGdldEljb246IGdldEljb24sXG4gICAgZ2V0SW5wdXRMYWJlbDogZ2V0SW5wdXRMYWJlbCxcbiAgICBnZXRDbG9zZUJ1dHRvbjogZ2V0Q2xvc2VCdXR0b24sXG4gICAgZ2V0QWN0aW9uczogZ2V0QWN0aW9ucyxcbiAgICBnZXRDb25maXJtQnV0dG9uOiBnZXRDb25maXJtQnV0dG9uLFxuICAgIGdldERlbnlCdXR0b246IGdldERlbnlCdXR0b24sXG4gICAgZ2V0Q2FuY2VsQnV0dG9uOiBnZXRDYW5jZWxCdXR0b24sXG4gICAgZ2V0TG9hZGVyOiBnZXRMb2FkZXIsXG4gICAgZ2V0Rm9vdGVyOiBnZXRGb290ZXIsXG4gICAgZ2V0VGltZXJQcm9ncmVzc0JhcjogZ2V0VGltZXJQcm9ncmVzc0JhcixcbiAgICBnZXRGb2N1c2FibGVFbGVtZW50czogZ2V0Rm9jdXNhYmxlRWxlbWVudHMsXG4gICAgZ2V0VmFsaWRhdGlvbk1lc3NhZ2U6IGdldFZhbGlkYXRpb25NZXNzYWdlLFxuICAgIGlzTG9hZGluZzogaXNMb2FkaW5nLFxuICAgIGZpcmU6IGZpcmUsXG4gICAgbWl4aW46IG1peGluLFxuICAgIHNob3dMb2FkaW5nOiBzaG93TG9hZGluZyxcbiAgICBlbmFibGVMb2FkaW5nOiBzaG93TG9hZGluZyxcbiAgICBnZXRUaW1lckxlZnQ6IGdldFRpbWVyTGVmdCxcbiAgICBzdG9wVGltZXI6IHN0b3BUaW1lcixcbiAgICByZXN1bWVUaW1lcjogcmVzdW1lVGltZXIsXG4gICAgdG9nZ2xlVGltZXI6IHRvZ2dsZVRpbWVyLFxuICAgIGluY3JlYXNlVGltZXI6IGluY3JlYXNlVGltZXIsXG4gICAgaXNUaW1lclJ1bm5pbmc6IGlzVGltZXJSdW5uaW5nLFxuICAgIGJpbmRDbGlja0hhbmRsZXI6IGJpbmRDbGlja0hhbmRsZXJcbiAgfSk7XG5cbiAgbGV0IGN1cnJlbnRJbnN0YW5jZTtcblxuICBjbGFzcyBTd2VldEFsZXJ0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIC8vIFByZXZlbnQgcnVuIGluIE5vZGUgZW52XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjdXJyZW50SW5zdGFuY2UgPSB0aGlzOyAvLyBAdHMtaWdub3JlXG5cbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBvdXRlclBhcmFtcyA9IE9iamVjdC5mcmVlemUodGhpcy5jb25zdHJ1Y3Rvci5hcmdzVG9QYXJhbXMoYXJncykpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICB2YWx1ZTogb3V0ZXJQYXJhbXMsXG4gICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pOyAvLyBAdHMtaWdub3JlXG5cbiAgICAgIGNvbnN0IHByb21pc2UgPSBjdXJyZW50SW5zdGFuY2UuX21haW4oY3VycmVudEluc3RhbmNlLnBhcmFtcyk7XG5cbiAgICAgIHByaXZhdGVQcm9wcy5wcm9taXNlLnNldCh0aGlzLCBwcm9taXNlKTtcbiAgICB9XG5cbiAgICBfbWFpbih1c2VyUGFyYW1zKSB7XG4gICAgICBsZXQgbWl4aW5QYXJhbXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgc2hvd1dhcm5pbmdzRm9yUGFyYW1zKE9iamVjdC5hc3NpZ24oe30sIG1peGluUGFyYW1zLCB1c2VyUGFyYW1zKSk7XG5cbiAgICAgIGlmIChnbG9iYWxTdGF0ZS5jdXJyZW50SW5zdGFuY2UpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBnbG9iYWxTdGF0ZS5jdXJyZW50SW5zdGFuY2UuX2Rlc3Ryb3koKTtcblxuICAgICAgICBpZiAoaXNNb2RhbCgpKSB7XG4gICAgICAgICAgdW5zZXRBcmlhSGlkZGVuKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZ2xvYmFsU3RhdGUuY3VycmVudEluc3RhbmNlID0gY3VycmVudEluc3RhbmNlO1xuICAgICAgY29uc3QgaW5uZXJQYXJhbXMgPSBwcmVwYXJlUGFyYW1zKHVzZXJQYXJhbXMsIG1peGluUGFyYW1zKTtcbiAgICAgIHNldFBhcmFtZXRlcnMoaW5uZXJQYXJhbXMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShpbm5lclBhcmFtcyk7IC8vIGNsZWFyIHRoZSBwcmV2aW91cyB0aW1lclxuXG4gICAgICBpZiAoZ2xvYmFsU3RhdGUudGltZW91dCkge1xuICAgICAgICBnbG9iYWxTdGF0ZS50aW1lb3V0LnN0b3AoKTtcbiAgICAgICAgZGVsZXRlIGdsb2JhbFN0YXRlLnRpbWVvdXQ7XG4gICAgICB9IC8vIGNsZWFyIHRoZSByZXN0b3JlIGZvY3VzIHRpbWVvdXRcblxuXG4gICAgICBjbGVhclRpbWVvdXQoZ2xvYmFsU3RhdGUucmVzdG9yZUZvY3VzVGltZW91dCk7XG4gICAgICBjb25zdCBkb21DYWNoZSA9IHBvcHVsYXRlRG9tQ2FjaGUoY3VycmVudEluc3RhbmNlKTtcbiAgICAgIHJlbmRlcihjdXJyZW50SW5zdGFuY2UsIGlubmVyUGFyYW1zKTtcbiAgICAgIHByaXZhdGVQcm9wcy5pbm5lclBhcmFtcy5zZXQoY3VycmVudEluc3RhbmNlLCBpbm5lclBhcmFtcyk7XG4gICAgICByZXR1cm4gc3dhbFByb21pc2UoY3VycmVudEluc3RhbmNlLCBkb21DYWNoZSwgaW5uZXJQYXJhbXMpO1xuICAgIH0gLy8gYGNhdGNoYCBjYW5ub3QgYmUgdGhlIG5hbWUgb2YgYSBtb2R1bGUgZXhwb3J0LCBzbyB3ZSBkZWZpbmUgb3VyIHRoZW5hYmxlIG1ldGhvZHMgaGVyZSBpbnN0ZWFkXG5cblxuICAgIHRoZW4ob25GdWxmaWxsZWQpIHtcbiAgICAgIGNvbnN0IHByb21pc2UgPSBwcml2YXRlUHJvcHMucHJvbWlzZS5nZXQodGhpcyk7XG4gICAgICByZXR1cm4gcHJvbWlzZS50aGVuKG9uRnVsZmlsbGVkKTtcbiAgICB9XG5cbiAgICBmaW5hbGx5KG9uRmluYWxseSkge1xuICAgICAgY29uc3QgcHJvbWlzZSA9IHByaXZhdGVQcm9wcy5wcm9taXNlLmdldCh0aGlzKTtcbiAgICAgIHJldHVybiBwcm9taXNlLmZpbmFsbHkob25GaW5hbGx5KTtcbiAgICB9XG5cbiAgfVxuXG4gIGNvbnN0IHN3YWxQcm9taXNlID0gKGluc3RhbmNlLCBkb21DYWNoZSwgaW5uZXJQYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgLy8gZnVuY3Rpb25zIHRvIGhhbmRsZSBhbGwgY2xvc2luZ3MvZGlzbWlzc2Fsc1xuICAgICAgY29uc3QgZGlzbWlzc1dpdGggPSBkaXNtaXNzID0+IHtcbiAgICAgICAgaW5zdGFuY2UuY2xvc2VQb3B1cCh7XG4gICAgICAgICAgaXNEaXNtaXNzZWQ6IHRydWUsXG4gICAgICAgICAgZGlzbWlzc1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIHByaXZhdGVNZXRob2RzLnN3YWxQcm9taXNlUmVzb2x2ZS5zZXQoaW5zdGFuY2UsIHJlc29sdmUpO1xuICAgICAgcHJpdmF0ZU1ldGhvZHMuc3dhbFByb21pc2VSZWplY3Quc2V0KGluc3RhbmNlLCByZWplY3QpO1xuXG4gICAgICBkb21DYWNoZS5jb25maXJtQnV0dG9uLm9uY2xpY2sgPSAoKSA9PiBoYW5kbGVDb25maXJtQnV0dG9uQ2xpY2soaW5zdGFuY2UpO1xuXG4gICAgICBkb21DYWNoZS5kZW55QnV0dG9uLm9uY2xpY2sgPSAoKSA9PiBoYW5kbGVEZW55QnV0dG9uQ2xpY2soaW5zdGFuY2UpO1xuXG4gICAgICBkb21DYWNoZS5jYW5jZWxCdXR0b24ub25jbGljayA9ICgpID0+IGhhbmRsZUNhbmNlbEJ1dHRvbkNsaWNrKGluc3RhbmNlLCBkaXNtaXNzV2l0aCk7XG5cbiAgICAgIGRvbUNhY2hlLmNsb3NlQnV0dG9uLm9uY2xpY2sgPSAoKSA9PiBkaXNtaXNzV2l0aChEaXNtaXNzUmVhc29uLmNsb3NlKTtcblxuICAgICAgaGFuZGxlUG9wdXBDbGljayhpbnN0YW5jZSwgZG9tQ2FjaGUsIGRpc21pc3NXaXRoKTtcbiAgICAgIGFkZEtleWRvd25IYW5kbGVyKGluc3RhbmNlLCBnbG9iYWxTdGF0ZSwgaW5uZXJQYXJhbXMsIGRpc21pc3NXaXRoKTtcbiAgICAgIGhhbmRsZUlucHV0T3B0aW9uc0FuZFZhbHVlKGluc3RhbmNlLCBpbm5lclBhcmFtcyk7XG4gICAgICBvcGVuUG9wdXAoaW5uZXJQYXJhbXMpO1xuICAgICAgc2V0dXBUaW1lcihnbG9iYWxTdGF0ZSwgaW5uZXJQYXJhbXMsIGRpc21pc3NXaXRoKTtcbiAgICAgIGluaXRGb2N1cyhkb21DYWNoZSwgaW5uZXJQYXJhbXMpOyAvLyBTY3JvbGwgY29udGFpbmVyIHRvIHRvcCBvbiBvcGVuICgjMTI0NywgIzE5NDYpXG5cbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBkb21DYWNoZS5jb250YWluZXIuc2Nyb2xsVG9wID0gMDtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIGNvbnN0IHByZXBhcmVQYXJhbXMgPSAodXNlclBhcmFtcywgbWl4aW5QYXJhbXMpID0+IHtcbiAgICBjb25zdCB0ZW1wbGF0ZVBhcmFtcyA9IGdldFRlbXBsYXRlUGFyYW1zKHVzZXJQYXJhbXMpO1xuICAgIGNvbnN0IHBhcmFtcyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRQYXJhbXMsIG1peGluUGFyYW1zLCB0ZW1wbGF0ZVBhcmFtcywgdXNlclBhcmFtcyk7IC8vIHByZWNlZGVuY2UgaXMgZGVzY3JpYmVkIGluICMyMTMxXG5cbiAgICBwYXJhbXMuc2hvd0NsYXNzID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFBhcmFtcy5zaG93Q2xhc3MsIHBhcmFtcy5zaG93Q2xhc3MpO1xuICAgIHBhcmFtcy5oaWRlQ2xhc3MgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0UGFyYW1zLmhpZGVDbGFzcywgcGFyYW1zLmhpZGVDbGFzcyk7XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfTtcbiAgLyoqXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydDJ9IGluc3RhbmNlXG4gICAqIEByZXR1cm5zIHtEb21DYWNoZX1cbiAgICovXG5cblxuICBjb25zdCBwb3B1bGF0ZURvbUNhY2hlID0gaW5zdGFuY2UgPT4ge1xuICAgIGNvbnN0IGRvbUNhY2hlID0ge1xuICAgICAgcG9wdXA6IGdldFBvcHVwKCksXG4gICAgICBjb250YWluZXI6IGdldENvbnRhaW5lcigpLFxuICAgICAgYWN0aW9uczogZ2V0QWN0aW9ucygpLFxuICAgICAgY29uZmlybUJ1dHRvbjogZ2V0Q29uZmlybUJ1dHRvbigpLFxuICAgICAgZGVueUJ1dHRvbjogZ2V0RGVueUJ1dHRvbigpLFxuICAgICAgY2FuY2VsQnV0dG9uOiBnZXRDYW5jZWxCdXR0b24oKSxcbiAgICAgIGxvYWRlcjogZ2V0TG9hZGVyKCksXG4gICAgICBjbG9zZUJ1dHRvbjogZ2V0Q2xvc2VCdXR0b24oKSxcbiAgICAgIHZhbGlkYXRpb25NZXNzYWdlOiBnZXRWYWxpZGF0aW9uTWVzc2FnZSgpLFxuICAgICAgcHJvZ3Jlc3NTdGVwczogZ2V0UHJvZ3Jlc3NTdGVwcygpXG4gICAgfTtcbiAgICBwcml2YXRlUHJvcHMuZG9tQ2FjaGUuc2V0KGluc3RhbmNlLCBkb21DYWNoZSk7XG4gICAgcmV0dXJuIGRvbUNhY2hlO1xuICB9O1xuICAvKipcbiAgICogQHBhcmFtIHtHbG9iYWxTdGF0ZX0gZ2xvYmFsU3RhdGVcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gaW5uZXJQYXJhbXNcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZGlzbWlzc1dpdGhcbiAgICovXG5cblxuICBjb25zdCBzZXR1cFRpbWVyID0gKGdsb2JhbFN0YXRlJCQxLCBpbm5lclBhcmFtcywgZGlzbWlzc1dpdGgpID0+IHtcbiAgICBjb25zdCB0aW1lclByb2dyZXNzQmFyID0gZ2V0VGltZXJQcm9ncmVzc0JhcigpO1xuICAgIGhpZGUodGltZXJQcm9ncmVzc0Jhcik7XG5cbiAgICBpZiAoaW5uZXJQYXJhbXMudGltZXIpIHtcbiAgICAgIGdsb2JhbFN0YXRlJCQxLnRpbWVvdXQgPSBuZXcgVGltZXIoKCkgPT4ge1xuICAgICAgICBkaXNtaXNzV2l0aCgndGltZXInKTtcbiAgICAgICAgZGVsZXRlIGdsb2JhbFN0YXRlJCQxLnRpbWVvdXQ7XG4gICAgICB9LCBpbm5lclBhcmFtcy50aW1lcik7XG5cbiAgICAgIGlmIChpbm5lclBhcmFtcy50aW1lclByb2dyZXNzQmFyKSB7XG4gICAgICAgIHNob3codGltZXJQcm9ncmVzc0Jhcik7XG4gICAgICAgIGFwcGx5Q3VzdG9tQ2xhc3ModGltZXJQcm9ncmVzc0JhciwgaW5uZXJQYXJhbXMsICd0aW1lclByb2dyZXNzQmFyJyk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGlmIChnbG9iYWxTdGF0ZSQkMS50aW1lb3V0ICYmIGdsb2JhbFN0YXRlJCQxLnRpbWVvdXQucnVubmluZykge1xuICAgICAgICAgICAgLy8gdGltZXIgY2FuIGJlIGFscmVhZHkgc3RvcHBlZCBvciB1bnNldCBhdCB0aGlzIHBvaW50XG4gICAgICAgICAgICBhbmltYXRlVGltZXJQcm9ncmVzc0Jhcihpbm5lclBhcmFtcy50aW1lcik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBAcGFyYW0ge0RvbUNhY2hlfSBkb21DYWNoZVxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBpbm5lclBhcmFtc1xuICAgKi9cblxuXG4gIGNvbnN0IGluaXRGb2N1cyA9IChkb21DYWNoZSwgaW5uZXJQYXJhbXMpID0+IHtcbiAgICBpZiAoaW5uZXJQYXJhbXMudG9hc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWNhbGxJZkZ1bmN0aW9uKGlubmVyUGFyYW1zLmFsbG93RW50ZXJLZXkpKSB7XG4gICAgICByZXR1cm4gYmx1ckFjdGl2ZUVsZW1lbnQoKTtcbiAgICB9XG5cbiAgICBpZiAoIWZvY3VzQnV0dG9uKGRvbUNhY2hlLCBpbm5lclBhcmFtcykpIHtcbiAgICAgIHNldEZvY3VzKGlubmVyUGFyYW1zLCAtMSwgMSk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogQHBhcmFtIHtEb21DYWNoZX0gZG9tQ2FjaGVcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gaW5uZXJQYXJhbXNcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuXG5cbiAgY29uc3QgZm9jdXNCdXR0b24gPSAoZG9tQ2FjaGUsIGlubmVyUGFyYW1zKSA9PiB7XG4gICAgaWYgKGlubmVyUGFyYW1zLmZvY3VzRGVueSAmJiBpc1Zpc2libGUoZG9tQ2FjaGUuZGVueUJ1dHRvbikpIHtcbiAgICAgIGRvbUNhY2hlLmRlbnlCdXR0b24uZm9jdXMoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChpbm5lclBhcmFtcy5mb2N1c0NhbmNlbCAmJiBpc1Zpc2libGUoZG9tQ2FjaGUuY2FuY2VsQnV0dG9uKSkge1xuICAgICAgZG9tQ2FjaGUuY2FuY2VsQnV0dG9uLmZvY3VzKCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoaW5uZXJQYXJhbXMuZm9jdXNDb25maXJtICYmIGlzVmlzaWJsZShkb21DYWNoZS5jb25maXJtQnV0dG9uKSkge1xuICAgICAgZG9tQ2FjaGUuY29uZmlybUJ1dHRvbi5mb2N1cygpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIGNvbnN0IGJsdXJBY3RpdmVFbGVtZW50ID0gKCkgPT4ge1xuICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgdHlwZW9mIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1ciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ibHVyKCk7XG4gICAgfVxuICB9OyAvLyBBc3NpZ24gaW5zdGFuY2UgbWV0aG9kcyBmcm9tIHNyYy9pbnN0YW5jZU1ldGhvZHMvKi5qcyB0byBwcm90b3R5cGVcblxuXG4gIE9iamVjdC5hc3NpZ24oU3dlZXRBbGVydC5wcm90b3R5cGUsIGluc3RhbmNlTWV0aG9kcyk7IC8vIEFzc2lnbiBzdGF0aWMgbWV0aG9kcyBmcm9tIHNyYy9zdGF0aWNNZXRob2RzLyouanMgdG8gY29uc3RydWN0b3JcblxuICBPYmplY3QuYXNzaWduKFN3ZWV0QWxlcnQsIHN0YXRpY01ldGhvZHMpOyAvLyBQcm94eSB0byBpbnN0YW5jZSBtZXRob2RzIHRvIGNvbnN0cnVjdG9yLCBmb3Igbm93LCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblxuICBPYmplY3Qua2V5cyhpbnN0YW5jZU1ldGhvZHMpLmZvckVhY2goa2V5ID0+IHtcbiAgICBTd2VldEFsZXJ0W2tleV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoY3VycmVudEluc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50SW5zdGFuY2Vba2V5XSguLi5hcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xuICBTd2VldEFsZXJ0LkRpc21pc3NSZWFzb24gPSBEaXNtaXNzUmVhc29uO1xuICBTd2VldEFsZXJ0LnZlcnNpb24gPSAnMTEuNC4xNyc7XG5cbiAgY29uc3QgU3dhbCA9IFN3ZWV0QWxlcnQ7IC8vIEB0cy1pZ25vcmVcblxuICBTd2FsLmRlZmF1bHQgPSBTd2FsO1xuXG4gIHJldHVybiBTd2FsO1xuXG59KSk7XG5pZiAodHlwZW9mIHRoaXMgIT09ICd1bmRlZmluZWQnICYmIHRoaXMuU3dlZXRhbGVydDIpeyAgdGhpcy5zd2FsID0gdGhpcy5zd2VldEFsZXJ0ID0gdGhpcy5Td2FsID0gdGhpcy5Td2VldEFsZXJ0ID0gdGhpcy5Td2VldGFsZXJ0Mn1cblxuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGRvY3VtZW50JiZmdW5jdGlvbihlLHQpe3ZhciBuPWUuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO2lmKGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdLmFwcGVuZENoaWxkKG4pLG4uc3R5bGVTaGVldCluLnN0eWxlU2hlZXQuZGlzYWJsZWR8fChuLnN0eWxlU2hlZXQuY3NzVGV4dD10KTtlbHNlIHRyeXtuLmlubmVySFRNTD10fWNhdGNoKGUpe24uaW5uZXJUZXh0PXR9fShkb2N1bWVudCxcIi5zd2FsMi1wb3B1cC5zd2FsMi10b2FzdHtib3gtc2l6aW5nOmJvcmRlci1ib3g7Z3JpZC1jb2x1bW46MS80IWltcG9ydGFudDtncmlkLXJvdzoxLzQhaW1wb3J0YW50O2dyaWQtdGVtcGxhdGUtY29sdW1uczoxZnIgOTlmciAxZnI7cGFkZGluZzoxZW07b3ZlcmZsb3cteTpoaWRkZW47YmFja2dyb3VuZDojZmZmO2JveC1zaGFkb3c6MCAwIDFweCBoc2xhKDBkZWcsMCUsMCUsLjA3NSksMCAxcHggMnB4IGhzbGEoMGRlZywwJSwwJSwuMDc1KSwxcHggMnB4IDRweCBoc2xhKDBkZWcsMCUsMCUsLjA3NSksMXB4IDNweCA4cHggaHNsYSgwZGVnLDAlLDAlLC4wNzUpLDJweCA0cHggMTZweCBoc2xhKDBkZWcsMCUsMCUsLjA3NSk7cG9pbnRlci1ldmVudHM6YWxsfS5zd2FsMi1wb3B1cC5zd2FsMi10b2FzdD4qe2dyaWQtY29sdW1uOjJ9LnN3YWwyLXBvcHVwLnN3YWwyLXRvYXN0IC5zd2FsMi10aXRsZXttYXJnaW46LjVlbSAxZW07cGFkZGluZzowO2ZvbnQtc2l6ZToxZW07dGV4dC1hbGlnbjppbml0aWFsfS5zd2FsMi1wb3B1cC5zd2FsMi10b2FzdCAuc3dhbDItbG9hZGluZ3tqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyfS5zd2FsMi1wb3B1cC5zd2FsMi10b2FzdCAuc3dhbDItaW5wdXR7aGVpZ2h0OjJlbTttYXJnaW46LjVlbTtmb250LXNpemU6MWVtfS5zd2FsMi1wb3B1cC5zd2FsMi10b2FzdCAuc3dhbDItdmFsaWRhdGlvbi1tZXNzYWdle2ZvbnQtc2l6ZToxZW19LnN3YWwyLXBvcHVwLnN3YWwyLXRvYXN0IC5zd2FsMi1mb290ZXJ7bWFyZ2luOi41ZW0gMCAwO3BhZGRpbmc6LjVlbSAwIDA7Zm9udC1zaXplOi44ZW19LnN3YWwyLXBvcHVwLnN3YWwyLXRvYXN0IC5zd2FsMi1jbG9zZXtncmlkLWNvbHVtbjozLzM7Z3JpZC1yb3c6MS85OTthbGlnbi1zZWxmOmNlbnRlcjt3aWR0aDouOGVtO2hlaWdodDouOGVtO21hcmdpbjowO2ZvbnQtc2l6ZToyZW19LnN3YWwyLXBvcHVwLnN3YWwyLXRvYXN0IC5zd2FsMi1odG1sLWNvbnRhaW5lcnttYXJnaW46LjVlbSAxZW07cGFkZGluZzowO2ZvbnQtc2l6ZToxZW07dGV4dC1hbGlnbjppbml0aWFsfS5zd2FsMi1wb3B1cC5zd2FsMi10b2FzdCAuc3dhbDItaHRtbC1jb250YWluZXI6ZW1wdHl7cGFkZGluZzowfS5zd2FsMi1wb3B1cC5zd2FsMi10b2FzdCAuc3dhbDItbG9hZGVye2dyaWQtY29sdW1uOjE7Z3JpZC1yb3c6MS85OTthbGlnbi1zZWxmOmNlbnRlcjt3aWR0aDoyZW07aGVpZ2h0OjJlbTttYXJnaW46LjI1ZW19LnN3YWwyLXBvcHVwLnN3YWwyLXRvYXN0IC5zd2FsMi1pY29ue2dyaWQtY29sdW1uOjE7Z3JpZC1yb3c6MS85OTthbGlnbi1zZWxmOmNlbnRlcjt3aWR0aDoyZW07bWluLXdpZHRoOjJlbTtoZWlnaHQ6MmVtO21hcmdpbjowIC41ZW0gMCAwfS5zd2FsMi1wb3B1cC5zd2FsMi10b2FzdCAuc3dhbDItaWNvbiAuc3dhbDItaWNvbi1jb250ZW50e2Rpc3BsYXk6ZmxleDthbGlnbi1pdGVtczpjZW50ZXI7Zm9udC1zaXplOjEuOGVtO2ZvbnQtd2VpZ2h0OjcwMH0uc3dhbDItcG9wdXAuc3dhbDItdG9hc3QgLnN3YWwyLWljb24uc3dhbDItc3VjY2VzcyAuc3dhbDItc3VjY2Vzcy1yaW5ne3dpZHRoOjJlbTtoZWlnaHQ6MmVtfS5zd2FsMi1wb3B1cC5zd2FsMi10b2FzdCAuc3dhbDItaWNvbi5zd2FsMi1lcnJvciBbY2xhc3NePXN3YWwyLXgtbWFyay1saW5lXXt0b3A6Ljg3NWVtO3dpZHRoOjEuMzc1ZW19LnN3YWwyLXBvcHVwLnN3YWwyLXRvYXN0IC5zd2FsMi1pY29uLnN3YWwyLWVycm9yIFtjbGFzc149c3dhbDIteC1tYXJrLWxpbmVdW2NsYXNzJD1sZWZ0XXtsZWZ0Oi4zMTI1ZW19LnN3YWwyLXBvcHVwLnN3YWwyLXRvYXN0IC5zd2FsMi1pY29uLnN3YWwyLWVycm9yIFtjbGFzc149c3dhbDIteC1tYXJrLWxpbmVdW2NsYXNzJD1yaWdodF17cmlnaHQ6LjMxMjVlbX0uc3dhbDItcG9wdXAuc3dhbDItdG9hc3QgLnN3YWwyLWFjdGlvbnN7anVzdGlmeS1jb250ZW50OmZsZXgtc3RhcnQ7aGVpZ2h0OmF1dG87bWFyZ2luOjA7bWFyZ2luLXRvcDouNWVtO3BhZGRpbmc6MCAuNWVtfS5zd2FsMi1wb3B1cC5zd2FsMi10b2FzdCAuc3dhbDItc3R5bGVke21hcmdpbjouMjVlbSAuNWVtO3BhZGRpbmc6LjRlbSAuNmVtO2ZvbnQtc2l6ZToxZW19LnN3YWwyLXBvcHVwLnN3YWwyLXRvYXN0IC5zd2FsMi1zdWNjZXNze2JvcmRlci1jb2xvcjojYTVkYzg2fS5zd2FsMi1wb3B1cC5zd2FsMi10b2FzdCAuc3dhbDItc3VjY2VzcyBbY2xhc3NePXN3YWwyLXN1Y2Nlc3MtY2lyY3VsYXItbGluZV17cG9zaXRpb246YWJzb2x1dGU7d2lkdGg6MS42ZW07aGVpZ2h0OjNlbTt0cmFuc2Zvcm06cm90YXRlKDQ1ZGVnKTtib3JkZXItcmFkaXVzOjUwJX0uc3dhbDItcG9wdXAuc3dhbDItdG9hc3QgLnN3YWwyLXN1Y2Nlc3MgW2NsYXNzXj1zd2FsMi1zdWNjZXNzLWNpcmN1bGFyLWxpbmVdW2NsYXNzJD1sZWZ0XXt0b3A6LS44ZW07bGVmdDotLjVlbTt0cmFuc2Zvcm06cm90YXRlKC00NWRlZyk7dHJhbnNmb3JtLW9yaWdpbjoyZW0gMmVtO2JvcmRlci1yYWRpdXM6NGVtIDAgMCA0ZW19LnN3YWwyLXBvcHVwLnN3YWwyLXRvYXN0IC5zd2FsMi1zdWNjZXNzIFtjbGFzc149c3dhbDItc3VjY2Vzcy1jaXJjdWxhci1saW5lXVtjbGFzcyQ9cmlnaHRde3RvcDotLjI1ZW07bGVmdDouOTM3NWVtO3RyYW5zZm9ybS1vcmlnaW46MCAxLjVlbTtib3JkZXItcmFkaXVzOjAgNGVtIDRlbSAwfS5zd2FsMi1wb3B1cC5zd2FsMi10b2FzdCAuc3dhbDItc3VjY2VzcyAuc3dhbDItc3VjY2Vzcy1yaW5ne3dpZHRoOjJlbTtoZWlnaHQ6MmVtfS5zd2FsMi1wb3B1cC5zd2FsMi10b2FzdCAuc3dhbDItc3VjY2VzcyAuc3dhbDItc3VjY2Vzcy1maXh7dG9wOjA7bGVmdDouNDM3NWVtO3dpZHRoOi40Mzc1ZW07aGVpZ2h0OjIuNjg3NWVtfS5zd2FsMi1wb3B1cC5zd2FsMi10b2FzdCAuc3dhbDItc3VjY2VzcyBbY2xhc3NePXN3YWwyLXN1Y2Nlc3MtbGluZV17aGVpZ2h0Oi4zMTI1ZW19LnN3YWwyLXBvcHVwLnN3YWwyLXRvYXN0IC5zd2FsMi1zdWNjZXNzIFtjbGFzc149c3dhbDItc3VjY2Vzcy1saW5lXVtjbGFzcyQ9dGlwXXt0b3A6MS4xMjVlbTtsZWZ0Oi4xODc1ZW07d2lkdGg6Ljc1ZW19LnN3YWwyLXBvcHVwLnN3YWwyLXRvYXN0IC5zd2FsMi1zdWNjZXNzIFtjbGFzc149c3dhbDItc3VjY2Vzcy1saW5lXVtjbGFzcyQ9bG9uZ117dG9wOi45Mzc1ZW07cmlnaHQ6LjE4NzVlbTt3aWR0aDoxLjM3NWVtfS5zd2FsMi1wb3B1cC5zd2FsMi10b2FzdCAuc3dhbDItc3VjY2Vzcy5zd2FsMi1pY29uLXNob3cgLnN3YWwyLXN1Y2Nlc3MtbGluZS10aXB7LXdlYmtpdC1hbmltYXRpb246c3dhbDItdG9hc3QtYW5pbWF0ZS1zdWNjZXNzLWxpbmUtdGlwIC43NXM7YW5pbWF0aW9uOnN3YWwyLXRvYXN0LWFuaW1hdGUtc3VjY2Vzcy1saW5lLXRpcCAuNzVzfS5zd2FsMi1wb3B1cC5zd2FsMi10b2FzdCAuc3dhbDItc3VjY2Vzcy5zd2FsMi1pY29uLXNob3cgLnN3YWwyLXN1Y2Nlc3MtbGluZS1sb25ney13ZWJraXQtYW5pbWF0aW9uOnN3YWwyLXRvYXN0LWFuaW1hdGUtc3VjY2Vzcy1saW5lLWxvbmcgLjc1czthbmltYXRpb246c3dhbDItdG9hc3QtYW5pbWF0ZS1zdWNjZXNzLWxpbmUtbG9uZyAuNzVzfS5zd2FsMi1wb3B1cC5zd2FsMi10b2FzdC5zd2FsMi1zaG93ey13ZWJraXQtYW5pbWF0aW9uOnN3YWwyLXRvYXN0LXNob3cgLjVzO2FuaW1hdGlvbjpzd2FsMi10b2FzdC1zaG93IC41c30uc3dhbDItcG9wdXAuc3dhbDItdG9hc3Quc3dhbDItaGlkZXstd2Via2l0LWFuaW1hdGlvbjpzd2FsMi10b2FzdC1oaWRlIC4xcyBmb3J3YXJkczthbmltYXRpb246c3dhbDItdG9hc3QtaGlkZSAuMXMgZm9yd2FyZHN9LnN3YWwyLWNvbnRhaW5lcntkaXNwbGF5OmdyaWQ7cG9zaXRpb246Zml4ZWQ7ei1pbmRleDoxMDYwO3RvcDowO3JpZ2h0OjA7Ym90dG9tOjA7bGVmdDowO2JveC1zaXppbmc6Ym9yZGVyLWJveDtncmlkLXRlbXBsYXRlLWFyZWFzOlxcXCJ0b3Atc3RhcnQgICAgIHRvcCAgICAgICAgICAgIHRvcC1lbmRcXFwiIFxcXCJjZW50ZXItc3RhcnQgIGNlbnRlciAgICAgICAgIGNlbnRlci1lbmRcXFwiIFxcXCJib3R0b20tc3RhcnQgIGJvdHRvbS1jZW50ZXIgIGJvdHRvbS1lbmRcXFwiO2dyaWQtdGVtcGxhdGUtcm93czptaW5tYXgoLXdlYmtpdC1taW4tY29udGVudCxhdXRvKSBtaW5tYXgoLXdlYmtpdC1taW4tY29udGVudCxhdXRvKSBtaW5tYXgoLXdlYmtpdC1taW4tY29udGVudCxhdXRvKTtncmlkLXRlbXBsYXRlLXJvd3M6bWlubWF4KG1pbi1jb250ZW50LGF1dG8pIG1pbm1heChtaW4tY29udGVudCxhdXRvKSBtaW5tYXgobWluLWNvbnRlbnQsYXV0byk7aGVpZ2h0OjEwMCU7cGFkZGluZzouNjI1ZW07b3ZlcmZsb3cteDpoaWRkZW47dHJhbnNpdGlvbjpiYWNrZ3JvdW5kLWNvbG9yIC4xczstd2Via2l0LW92ZXJmbG93LXNjcm9sbGluZzp0b3VjaH0uc3dhbDItY29udGFpbmVyLnN3YWwyLWJhY2tkcm9wLXNob3csLnN3YWwyLWNvbnRhaW5lci5zd2FsMi1ub2FuaW1hdGlvbntiYWNrZ3JvdW5kOnJnYmEoMCwwLDAsLjQpfS5zd2FsMi1jb250YWluZXIuc3dhbDItYmFja2Ryb3AtaGlkZXtiYWNrZ3JvdW5kOjAgMCFpbXBvcnRhbnR9LnN3YWwyLWNvbnRhaW5lci5zd2FsMi1ib3R0b20tc3RhcnQsLnN3YWwyLWNvbnRhaW5lci5zd2FsMi1jZW50ZXItc3RhcnQsLnN3YWwyLWNvbnRhaW5lci5zd2FsMi10b3Atc3RhcnR7Z3JpZC10ZW1wbGF0ZS1jb2x1bW5zOm1pbm1heCgwLDFmcikgYXV0byBhdXRvfS5zd2FsMi1jb250YWluZXIuc3dhbDItYm90dG9tLC5zd2FsMi1jb250YWluZXIuc3dhbDItY2VudGVyLC5zd2FsMi1jb250YWluZXIuc3dhbDItdG9we2dyaWQtdGVtcGxhdGUtY29sdW1uczphdXRvIG1pbm1heCgwLDFmcikgYXV0b30uc3dhbDItY29udGFpbmVyLnN3YWwyLWJvdHRvbS1lbmQsLnN3YWwyLWNvbnRhaW5lci5zd2FsMi1jZW50ZXItZW5kLC5zd2FsMi1jb250YWluZXIuc3dhbDItdG9wLWVuZHtncmlkLXRlbXBsYXRlLWNvbHVtbnM6YXV0byBhdXRvIG1pbm1heCgwLDFmcil9LnN3YWwyLWNvbnRhaW5lci5zd2FsMi10b3Atc3RhcnQ+LnN3YWwyLXBvcHVwe2FsaWduLXNlbGY6c3RhcnR9LnN3YWwyLWNvbnRhaW5lci5zd2FsMi10b3A+LnN3YWwyLXBvcHVwe2dyaWQtY29sdW1uOjI7YWxpZ24tc2VsZjpzdGFydDtqdXN0aWZ5LXNlbGY6Y2VudGVyfS5zd2FsMi1jb250YWluZXIuc3dhbDItdG9wLWVuZD4uc3dhbDItcG9wdXAsLnN3YWwyLWNvbnRhaW5lci5zd2FsMi10b3AtcmlnaHQ+LnN3YWwyLXBvcHVwe2dyaWQtY29sdW1uOjM7YWxpZ24tc2VsZjpzdGFydDtqdXN0aWZ5LXNlbGY6ZW5kfS5zd2FsMi1jb250YWluZXIuc3dhbDItY2VudGVyLWxlZnQ+LnN3YWwyLXBvcHVwLC5zd2FsMi1jb250YWluZXIuc3dhbDItY2VudGVyLXN0YXJ0Pi5zd2FsMi1wb3B1cHtncmlkLXJvdzoyO2FsaWduLXNlbGY6Y2VudGVyfS5zd2FsMi1jb250YWluZXIuc3dhbDItY2VudGVyPi5zd2FsMi1wb3B1cHtncmlkLWNvbHVtbjoyO2dyaWQtcm93OjI7YWxpZ24tc2VsZjpjZW50ZXI7anVzdGlmeS1zZWxmOmNlbnRlcn0uc3dhbDItY29udGFpbmVyLnN3YWwyLWNlbnRlci1lbmQ+LnN3YWwyLXBvcHVwLC5zd2FsMi1jb250YWluZXIuc3dhbDItY2VudGVyLXJpZ2h0Pi5zd2FsMi1wb3B1cHtncmlkLWNvbHVtbjozO2dyaWQtcm93OjI7YWxpZ24tc2VsZjpjZW50ZXI7anVzdGlmeS1zZWxmOmVuZH0uc3dhbDItY29udGFpbmVyLnN3YWwyLWJvdHRvbS1sZWZ0Pi5zd2FsMi1wb3B1cCwuc3dhbDItY29udGFpbmVyLnN3YWwyLWJvdHRvbS1zdGFydD4uc3dhbDItcG9wdXB7Z3JpZC1jb2x1bW46MTtncmlkLXJvdzozO2FsaWduLXNlbGY6ZW5kfS5zd2FsMi1jb250YWluZXIuc3dhbDItYm90dG9tPi5zd2FsMi1wb3B1cHtncmlkLWNvbHVtbjoyO2dyaWQtcm93OjM7anVzdGlmeS1zZWxmOmNlbnRlcjthbGlnbi1zZWxmOmVuZH0uc3dhbDItY29udGFpbmVyLnN3YWwyLWJvdHRvbS1lbmQ+LnN3YWwyLXBvcHVwLC5zd2FsMi1jb250YWluZXIuc3dhbDItYm90dG9tLXJpZ2h0Pi5zd2FsMi1wb3B1cHtncmlkLWNvbHVtbjozO2dyaWQtcm93OjM7YWxpZ24tc2VsZjplbmQ7anVzdGlmeS1zZWxmOmVuZH0uc3dhbDItY29udGFpbmVyLnN3YWwyLWdyb3ctZnVsbHNjcmVlbj4uc3dhbDItcG9wdXAsLnN3YWwyLWNvbnRhaW5lci5zd2FsMi1ncm93LXJvdz4uc3dhbDItcG9wdXB7Z3JpZC1jb2x1bW46MS80O3dpZHRoOjEwMCV9LnN3YWwyLWNvbnRhaW5lci5zd2FsMi1ncm93LWNvbHVtbj4uc3dhbDItcG9wdXAsLnN3YWwyLWNvbnRhaW5lci5zd2FsMi1ncm93LWZ1bGxzY3JlZW4+LnN3YWwyLXBvcHVwe2dyaWQtcm93OjEvNDthbGlnbi1zZWxmOnN0cmV0Y2h9LnN3YWwyLWNvbnRhaW5lci5zd2FsMi1uby10cmFuc2l0aW9ue3RyYW5zaXRpb246bm9uZSFpbXBvcnRhbnR9LnN3YWwyLXBvcHVwe2Rpc3BsYXk6bm9uZTtwb3NpdGlvbjpyZWxhdGl2ZTtib3gtc2l6aW5nOmJvcmRlci1ib3g7Z3JpZC10ZW1wbGF0ZS1jb2x1bW5zOm1pbm1heCgwLDEwMCUpO3dpZHRoOjMyZW07bWF4LXdpZHRoOjEwMCU7cGFkZGluZzowIDAgMS4yNWVtO2JvcmRlcjpub25lO2JvcmRlci1yYWRpdXM6NXB4O2JhY2tncm91bmQ6I2ZmZjtjb2xvcjojNTQ1NDU0O2ZvbnQtZmFtaWx5OmluaGVyaXQ7Zm9udC1zaXplOjFyZW19LnN3YWwyLXBvcHVwOmZvY3Vze291dGxpbmU6MH0uc3dhbDItcG9wdXAuc3dhbDItbG9hZGluZ3tvdmVyZmxvdy15OmhpZGRlbn0uc3dhbDItdGl0bGV7cG9zaXRpb246cmVsYXRpdmU7bWF4LXdpZHRoOjEwMCU7bWFyZ2luOjA7cGFkZGluZzouOGVtIDFlbSAwO2NvbG9yOmluaGVyaXQ7Zm9udC1zaXplOjEuODc1ZW07Zm9udC13ZWlnaHQ6NjAwO3RleHQtYWxpZ246Y2VudGVyO3RleHQtdHJhbnNmb3JtOm5vbmU7d29yZC13cmFwOmJyZWFrLXdvcmR9LnN3YWwyLWFjdGlvbnN7ZGlzcGxheTpmbGV4O3otaW5kZXg6MTtib3gtc2l6aW5nOmJvcmRlci1ib3g7ZmxleC13cmFwOndyYXA7YWxpZ24taXRlbXM6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7d2lkdGg6YXV0bzttYXJnaW46MS4yNWVtIGF1dG8gMDtwYWRkaW5nOjB9LnN3YWwyLWFjdGlvbnM6bm90KC5zd2FsMi1sb2FkaW5nKSAuc3dhbDItc3R5bGVkW2Rpc2FibGVkXXtvcGFjaXR5Oi40fS5zd2FsMi1hY3Rpb25zOm5vdCguc3dhbDItbG9hZGluZykgLnN3YWwyLXN0eWxlZDpob3ZlcntiYWNrZ3JvdW5kLWltYWdlOmxpbmVhci1ncmFkaWVudChyZ2JhKDAsMCwwLC4xKSxyZ2JhKDAsMCwwLC4xKSl9LnN3YWwyLWFjdGlvbnM6bm90KC5zd2FsMi1sb2FkaW5nKSAuc3dhbDItc3R5bGVkOmFjdGl2ZXtiYWNrZ3JvdW5kLWltYWdlOmxpbmVhci1ncmFkaWVudChyZ2JhKDAsMCwwLC4yKSxyZ2JhKDAsMCwwLC4yKSl9LnN3YWwyLWxvYWRlcntkaXNwbGF5Om5vbmU7YWxpZ24taXRlbXM6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7d2lkdGg6Mi4yZW07aGVpZ2h0OjIuMmVtO21hcmdpbjowIDEuODc1ZW07LXdlYmtpdC1hbmltYXRpb246c3dhbDItcm90YXRlLWxvYWRpbmcgMS41cyBsaW5lYXIgMHMgaW5maW5pdGUgbm9ybWFsO2FuaW1hdGlvbjpzd2FsMi1yb3RhdGUtbG9hZGluZyAxLjVzIGxpbmVhciAwcyBpbmZpbml0ZSBub3JtYWw7Ym9yZGVyLXdpZHRoOi4yNWVtO2JvcmRlci1zdHlsZTpzb2xpZDtib3JkZXItcmFkaXVzOjEwMCU7Ym9yZGVyLWNvbG9yOiMyNzc4YzQgdHJhbnNwYXJlbnQgIzI3NzhjNCB0cmFuc3BhcmVudH0uc3dhbDItc3R5bGVke21hcmdpbjouMzEyNWVtO3BhZGRpbmc6LjYyNWVtIDEuMWVtO3RyYW5zaXRpb246Ym94LXNoYWRvdyAuMXM7Ym94LXNoYWRvdzowIDAgMCAzcHggdHJhbnNwYXJlbnQ7Zm9udC13ZWlnaHQ6NTAwfS5zd2FsMi1zdHlsZWQ6bm90KFtkaXNhYmxlZF0pe2N1cnNvcjpwb2ludGVyfS5zd2FsMi1zdHlsZWQuc3dhbDItY29uZmlybXtib3JkZXI6MDtib3JkZXItcmFkaXVzOi4yNWVtO2JhY2tncm91bmQ6aW5pdGlhbDtiYWNrZ3JvdW5kLWNvbG9yOiM3MDY2ZTA7Y29sb3I6I2ZmZjtmb250LXNpemU6MWVtfS5zd2FsMi1zdHlsZWQuc3dhbDItY29uZmlybTpmb2N1c3tib3gtc2hhZG93OjAgMCAwIDNweCByZ2JhKDExMiwxMDIsMjI0LC41KX0uc3dhbDItc3R5bGVkLnN3YWwyLWRlbnl7Ym9yZGVyOjA7Ym9yZGVyLXJhZGl1czouMjVlbTtiYWNrZ3JvdW5kOmluaXRpYWw7YmFja2dyb3VuZC1jb2xvcjojZGMzNzQxO2NvbG9yOiNmZmY7Zm9udC1zaXplOjFlbX0uc3dhbDItc3R5bGVkLnN3YWwyLWRlbnk6Zm9jdXN7Ym94LXNoYWRvdzowIDAgMCAzcHggcmdiYSgyMjAsNTUsNjUsLjUpfS5zd2FsMi1zdHlsZWQuc3dhbDItY2FuY2Vse2JvcmRlcjowO2JvcmRlci1yYWRpdXM6LjI1ZW07YmFja2dyb3VuZDppbml0aWFsO2JhY2tncm91bmQtY29sb3I6IzZlNzg4MTtjb2xvcjojZmZmO2ZvbnQtc2l6ZToxZW19LnN3YWwyLXN0eWxlZC5zd2FsMi1jYW5jZWw6Zm9jdXN7Ym94LXNoYWRvdzowIDAgMCAzcHggcmdiYSgxMTAsMTIwLDEyOSwuNSl9LnN3YWwyLXN0eWxlZC5zd2FsMi1kZWZhdWx0LW91dGxpbmU6Zm9jdXN7Ym94LXNoYWRvdzowIDAgMCAzcHggcmdiYSgxMDAsMTUwLDIwMCwuNSl9LnN3YWwyLXN0eWxlZDpmb2N1c3tvdXRsaW5lOjB9LnN3YWwyLXN0eWxlZDo6LW1vei1mb2N1cy1pbm5lcntib3JkZXI6MH0uc3dhbDItZm9vdGVye2p1c3RpZnktY29udGVudDpjZW50ZXI7bWFyZ2luOjFlbSAwIDA7cGFkZGluZzoxZW0gMWVtIDA7Ym9yZGVyLXRvcDoxcHggc29saWQgI2VlZTtjb2xvcjppbmhlcml0O2ZvbnQtc2l6ZToxZW19LnN3YWwyLXRpbWVyLXByb2dyZXNzLWJhci1jb250YWluZXJ7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6MDtib3R0b206MDtsZWZ0OjA7Z3JpZC1jb2x1bW46YXV0byFpbXBvcnRhbnQ7b3ZlcmZsb3c6aGlkZGVuO2JvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOjVweDtib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOjVweH0uc3dhbDItdGltZXItcHJvZ3Jlc3MtYmFye3dpZHRoOjEwMCU7aGVpZ2h0Oi4yNWVtO2JhY2tncm91bmQ6cmdiYSgwLDAsMCwuMil9LnN3YWwyLWltYWdle21heC13aWR0aDoxMDAlO21hcmdpbjoyZW0gYXV0byAxZW19LnN3YWwyLWNsb3Nle3otaW5kZXg6MjthbGlnbi1pdGVtczpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcjt3aWR0aDoxLjJlbTtoZWlnaHQ6MS4yZW07bWFyZ2luLXRvcDowO21hcmdpbi1yaWdodDowO21hcmdpbi1ib3R0b206LTEuMmVtO3BhZGRpbmc6MDtvdmVyZmxvdzpoaWRkZW47dHJhbnNpdGlvbjpjb2xvciAuMXMsYm94LXNoYWRvdyAuMXM7Ym9yZGVyOm5vbmU7Ym9yZGVyLXJhZGl1czo1cHg7YmFja2dyb3VuZDowIDA7Y29sb3I6I2NjYztmb250LWZhbWlseTpzZXJpZjtmb250LWZhbWlseTptb25vc3BhY2U7Zm9udC1zaXplOjIuNWVtO2N1cnNvcjpwb2ludGVyO2p1c3RpZnktc2VsZjplbmR9LnN3YWwyLWNsb3NlOmhvdmVye3RyYW5zZm9ybTpub25lO2JhY2tncm91bmQ6MCAwO2NvbG9yOiNmMjc0NzR9LnN3YWwyLWNsb3NlOmZvY3Vze291dGxpbmU6MDtib3gtc2hhZG93Omluc2V0IDAgMCAwIDNweCByZ2JhKDEwMCwxNTAsMjAwLC41KX0uc3dhbDItY2xvc2U6Oi1tb3otZm9jdXMtaW5uZXJ7Ym9yZGVyOjB9LnN3YWwyLWh0bWwtY29udGFpbmVye3otaW5kZXg6MTtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO21hcmdpbjoxZW0gMS42ZW0gLjNlbTtwYWRkaW5nOjA7b3ZlcmZsb3c6YXV0bztjb2xvcjppbmhlcml0O2ZvbnQtc2l6ZToxLjEyNWVtO2ZvbnQtd2VpZ2h0OjQwMDtsaW5lLWhlaWdodDpub3JtYWw7dGV4dC1hbGlnbjpjZW50ZXI7d29yZC13cmFwOmJyZWFrLXdvcmQ7d29yZC1icmVhazpicmVhay13b3JkfS5zd2FsMi1jaGVja2JveCwuc3dhbDItZmlsZSwuc3dhbDItaW5wdXQsLnN3YWwyLXJhZGlvLC5zd2FsMi1zZWxlY3QsLnN3YWwyLXRleHRhcmVhe21hcmdpbjoxZW0gMmVtIDNweH0uc3dhbDItZmlsZSwuc3dhbDItaW5wdXQsLnN3YWwyLXRleHRhcmVhe2JveC1zaXppbmc6Ym9yZGVyLWJveDt3aWR0aDphdXRvO3RyYW5zaXRpb246Ym9yZGVyLWNvbG9yIC4xcyxib3gtc2hhZG93IC4xcztib3JkZXI6MXB4IHNvbGlkICNkOWQ5ZDk7Ym9yZGVyLXJhZGl1czouMTg3NWVtO2JhY2tncm91bmQ6MCAwO2JveC1zaGFkb3c6aW5zZXQgMCAxcHggMXB4IHJnYmEoMCwwLDAsLjA2KSwwIDAgMCAzcHggdHJhbnNwYXJlbnQ7Y29sb3I6aW5oZXJpdDtmb250LXNpemU6MS4xMjVlbX0uc3dhbDItZmlsZS5zd2FsMi1pbnB1dGVycm9yLC5zd2FsMi1pbnB1dC5zd2FsMi1pbnB1dGVycm9yLC5zd2FsMi10ZXh0YXJlYS5zd2FsMi1pbnB1dGVycm9ye2JvcmRlci1jb2xvcjojZjI3NDc0IWltcG9ydGFudDtib3gtc2hhZG93OjAgMCAycHggI2YyNzQ3NCFpbXBvcnRhbnR9LnN3YWwyLWZpbGU6Zm9jdXMsLnN3YWwyLWlucHV0OmZvY3VzLC5zd2FsMi10ZXh0YXJlYTpmb2N1c3tib3JkZXI6MXB4IHNvbGlkICNiNGRiZWQ7b3V0bGluZTowO2JveC1zaGFkb3c6aW5zZXQgMCAxcHggMXB4IHJnYmEoMCwwLDAsLjA2KSwwIDAgMCAzcHggcmdiYSgxMDAsMTUwLDIwMCwuNSl9LnN3YWwyLWZpbGU6Oi1tb3otcGxhY2Vob2xkZXIsLnN3YWwyLWlucHV0OjotbW96LXBsYWNlaG9sZGVyLC5zd2FsMi10ZXh0YXJlYTo6LW1vei1wbGFjZWhvbGRlcntjb2xvcjojY2NjfS5zd2FsMi1maWxlOi1tcy1pbnB1dC1wbGFjZWhvbGRlciwuc3dhbDItaW5wdXQ6LW1zLWlucHV0LXBsYWNlaG9sZGVyLC5zd2FsMi10ZXh0YXJlYTotbXMtaW5wdXQtcGxhY2Vob2xkZXJ7Y29sb3I6I2NjY30uc3dhbDItZmlsZTo6cGxhY2Vob2xkZXIsLnN3YWwyLWlucHV0OjpwbGFjZWhvbGRlciwuc3dhbDItdGV4dGFyZWE6OnBsYWNlaG9sZGVye2NvbG9yOiNjY2N9LnN3YWwyLXJhbmdle21hcmdpbjoxZW0gMmVtIDNweDtiYWNrZ3JvdW5kOiNmZmZ9LnN3YWwyLXJhbmdlIGlucHV0e3dpZHRoOjgwJX0uc3dhbDItcmFuZ2Ugb3V0cHV0e3dpZHRoOjIwJTtjb2xvcjppbmhlcml0O2ZvbnQtd2VpZ2h0OjYwMDt0ZXh0LWFsaWduOmNlbnRlcn0uc3dhbDItcmFuZ2UgaW5wdXQsLnN3YWwyLXJhbmdlIG91dHB1dHtoZWlnaHQ6Mi42MjVlbTtwYWRkaW5nOjA7Zm9udC1zaXplOjEuMTI1ZW07bGluZS1oZWlnaHQ6Mi42MjVlbX0uc3dhbDItaW5wdXR7aGVpZ2h0OjIuNjI1ZW07cGFkZGluZzowIC43NWVtfS5zd2FsMi1maWxle3dpZHRoOjc1JTttYXJnaW4tcmlnaHQ6YXV0bzttYXJnaW4tbGVmdDphdXRvO2JhY2tncm91bmQ6MCAwO2ZvbnQtc2l6ZToxLjEyNWVtfS5zd2FsMi10ZXh0YXJlYXtoZWlnaHQ6Ni43NWVtO3BhZGRpbmc6Ljc1ZW19LnN3YWwyLXNlbGVjdHttaW4td2lkdGg6NTAlO21heC13aWR0aDoxMDAlO3BhZGRpbmc6LjM3NWVtIC42MjVlbTtiYWNrZ3JvdW5kOjAgMDtjb2xvcjppbmhlcml0O2ZvbnQtc2l6ZToxLjEyNWVtfS5zd2FsMi1jaGVja2JveCwuc3dhbDItcmFkaW97YWxpZ24taXRlbXM6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7YmFja2dyb3VuZDojZmZmO2NvbG9yOmluaGVyaXR9LnN3YWwyLWNoZWNrYm94IGxhYmVsLC5zd2FsMi1yYWRpbyBsYWJlbHttYXJnaW46MCAuNmVtO2ZvbnQtc2l6ZToxLjEyNWVtfS5zd2FsMi1jaGVja2JveCBpbnB1dCwuc3dhbDItcmFkaW8gaW5wdXR7ZmxleC1zaHJpbms6MDttYXJnaW46MCAuNGVtfS5zd2FsMi1pbnB1dC1sYWJlbHtkaXNwbGF5OmZsZXg7anVzdGlmeS1jb250ZW50OmNlbnRlcjttYXJnaW46MWVtIGF1dG8gMH0uc3dhbDItdmFsaWRhdGlvbi1tZXNzYWdle2FsaWduLWl0ZW1zOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO21hcmdpbjoxZW0gMCAwO3BhZGRpbmc6LjYyNWVtO292ZXJmbG93OmhpZGRlbjtiYWNrZ3JvdW5kOiNmMGYwZjA7Y29sb3I6IzY2Njtmb250LXNpemU6MWVtO2ZvbnQtd2VpZ2h0OjMwMH0uc3dhbDItdmFsaWRhdGlvbi1tZXNzYWdlOjpiZWZvcmV7Y29udGVudDpcXFwiIVxcXCI7ZGlzcGxheTppbmxpbmUtYmxvY2s7d2lkdGg6MS41ZW07bWluLXdpZHRoOjEuNWVtO2hlaWdodDoxLjVlbTttYXJnaW46MCAuNjI1ZW07Ym9yZGVyLXJhZGl1czo1MCU7YmFja2dyb3VuZC1jb2xvcjojZjI3NDc0O2NvbG9yOiNmZmY7Zm9udC13ZWlnaHQ6NjAwO2xpbmUtaGVpZ2h0OjEuNWVtO3RleHQtYWxpZ246Y2VudGVyfS5zd2FsMi1pY29ue3Bvc2l0aW9uOnJlbGF0aXZlO2JveC1zaXppbmc6Y29udGVudC1ib3g7anVzdGlmeS1jb250ZW50OmNlbnRlcjt3aWR0aDo1ZW07aGVpZ2h0OjVlbTttYXJnaW46Mi41ZW0gYXV0byAuNmVtO2JvcmRlcjouMjVlbSBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItcmFkaXVzOjUwJTtib3JkZXItY29sb3I6IzAwMDtmb250LWZhbWlseTppbmhlcml0O2xpbmUtaGVpZ2h0OjVlbTtjdXJzb3I6ZGVmYXVsdDstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDpub25lOy1tcy11c2VyLXNlbGVjdDpub25lO3VzZXItc2VsZWN0Om5vbmV9LnN3YWwyLWljb24gLnN3YWwyLWljb24tY29udGVudHtkaXNwbGF5OmZsZXg7YWxpZ24taXRlbXM6Y2VudGVyO2ZvbnQtc2l6ZTozLjc1ZW19LnN3YWwyLWljb24uc3dhbDItZXJyb3J7Ym9yZGVyLWNvbG9yOiNmMjc0NzQ7Y29sb3I6I2YyNzQ3NH0uc3dhbDItaWNvbi5zd2FsMi1lcnJvciAuc3dhbDIteC1tYXJre3Bvc2l0aW9uOnJlbGF0aXZlO2ZsZXgtZ3JvdzoxfS5zd2FsMi1pY29uLnN3YWwyLWVycm9yIFtjbGFzc149c3dhbDIteC1tYXJrLWxpbmVde2Rpc3BsYXk6YmxvY2s7cG9zaXRpb246YWJzb2x1dGU7dG9wOjIuMzEyNWVtO3dpZHRoOjIuOTM3NWVtO2hlaWdodDouMzEyNWVtO2JvcmRlci1yYWRpdXM6LjEyNWVtO2JhY2tncm91bmQtY29sb3I6I2YyNzQ3NH0uc3dhbDItaWNvbi5zd2FsMi1lcnJvciBbY2xhc3NePXN3YWwyLXgtbWFyay1saW5lXVtjbGFzcyQ9bGVmdF17bGVmdDoxLjA2MjVlbTt0cmFuc2Zvcm06cm90YXRlKDQ1ZGVnKX0uc3dhbDItaWNvbi5zd2FsMi1lcnJvciBbY2xhc3NePXN3YWwyLXgtbWFyay1saW5lXVtjbGFzcyQ9cmlnaHRde3JpZ2h0OjFlbTt0cmFuc2Zvcm06cm90YXRlKC00NWRlZyl9LnN3YWwyLWljb24uc3dhbDItZXJyb3Iuc3dhbDItaWNvbi1zaG93ey13ZWJraXQtYW5pbWF0aW9uOnN3YWwyLWFuaW1hdGUtZXJyb3ItaWNvbiAuNXM7YW5pbWF0aW9uOnN3YWwyLWFuaW1hdGUtZXJyb3ItaWNvbiAuNXN9LnN3YWwyLWljb24uc3dhbDItZXJyb3Iuc3dhbDItaWNvbi1zaG93IC5zd2FsMi14LW1hcmt7LXdlYmtpdC1hbmltYXRpb246c3dhbDItYW5pbWF0ZS1lcnJvci14LW1hcmsgLjVzO2FuaW1hdGlvbjpzd2FsMi1hbmltYXRlLWVycm9yLXgtbWFyayAuNXN9LnN3YWwyLWljb24uc3dhbDItd2FybmluZ3tib3JkZXItY29sb3I6I2ZhY2VhODtjb2xvcjojZjhiYjg2fS5zd2FsMi1pY29uLnN3YWwyLXdhcm5pbmcuc3dhbDItaWNvbi1zaG93ey13ZWJraXQtYW5pbWF0aW9uOnN3YWwyLWFuaW1hdGUtZXJyb3ItaWNvbiAuNXM7YW5pbWF0aW9uOnN3YWwyLWFuaW1hdGUtZXJyb3ItaWNvbiAuNXN9LnN3YWwyLWljb24uc3dhbDItd2FybmluZy5zd2FsMi1pY29uLXNob3cgLnN3YWwyLWljb24tY29udGVudHstd2Via2l0LWFuaW1hdGlvbjpzd2FsMi1hbmltYXRlLWktbWFyayAuNXM7YW5pbWF0aW9uOnN3YWwyLWFuaW1hdGUtaS1tYXJrIC41c30uc3dhbDItaWNvbi5zd2FsMi1pbmZve2JvcmRlci1jb2xvcjojOWRlMGY2O2NvbG9yOiMzZmMzZWV9LnN3YWwyLWljb24uc3dhbDItaW5mby5zd2FsMi1pY29uLXNob3d7LXdlYmtpdC1hbmltYXRpb246c3dhbDItYW5pbWF0ZS1lcnJvci1pY29uIC41czthbmltYXRpb246c3dhbDItYW5pbWF0ZS1lcnJvci1pY29uIC41c30uc3dhbDItaWNvbi5zd2FsMi1pbmZvLnN3YWwyLWljb24tc2hvdyAuc3dhbDItaWNvbi1jb250ZW50ey13ZWJraXQtYW5pbWF0aW9uOnN3YWwyLWFuaW1hdGUtaS1tYXJrIC44czthbmltYXRpb246c3dhbDItYW5pbWF0ZS1pLW1hcmsgLjhzfS5zd2FsMi1pY29uLnN3YWwyLXF1ZXN0aW9ue2JvcmRlci1jb2xvcjojYzlkYWUxO2NvbG9yOiM4N2FkYmR9LnN3YWwyLWljb24uc3dhbDItcXVlc3Rpb24uc3dhbDItaWNvbi1zaG93ey13ZWJraXQtYW5pbWF0aW9uOnN3YWwyLWFuaW1hdGUtZXJyb3ItaWNvbiAuNXM7YW5pbWF0aW9uOnN3YWwyLWFuaW1hdGUtZXJyb3ItaWNvbiAuNXN9LnN3YWwyLWljb24uc3dhbDItcXVlc3Rpb24uc3dhbDItaWNvbi1zaG93IC5zd2FsMi1pY29uLWNvbnRlbnR7LXdlYmtpdC1hbmltYXRpb246c3dhbDItYW5pbWF0ZS1xdWVzdGlvbi1tYXJrIC44czthbmltYXRpb246c3dhbDItYW5pbWF0ZS1xdWVzdGlvbi1tYXJrIC44c30uc3dhbDItaWNvbi5zd2FsMi1zdWNjZXNze2JvcmRlci1jb2xvcjojYTVkYzg2O2NvbG9yOiNhNWRjODZ9LnN3YWwyLWljb24uc3dhbDItc3VjY2VzcyBbY2xhc3NePXN3YWwyLXN1Y2Nlc3MtY2lyY3VsYXItbGluZV17cG9zaXRpb246YWJzb2x1dGU7d2lkdGg6My43NWVtO2hlaWdodDo3LjVlbTt0cmFuc2Zvcm06cm90YXRlKDQ1ZGVnKTtib3JkZXItcmFkaXVzOjUwJX0uc3dhbDItaWNvbi5zd2FsMi1zdWNjZXNzIFtjbGFzc149c3dhbDItc3VjY2Vzcy1jaXJjdWxhci1saW5lXVtjbGFzcyQ9bGVmdF17dG9wOi0uNDM3NWVtO2xlZnQ6LTIuMDYzNWVtO3RyYW5zZm9ybTpyb3RhdGUoLTQ1ZGVnKTt0cmFuc2Zvcm0tb3JpZ2luOjMuNzVlbSAzLjc1ZW07Ym9yZGVyLXJhZGl1czo3LjVlbSAwIDAgNy41ZW19LnN3YWwyLWljb24uc3dhbDItc3VjY2VzcyBbY2xhc3NePXN3YWwyLXN1Y2Nlc3MtY2lyY3VsYXItbGluZV1bY2xhc3MkPXJpZ2h0XXt0b3A6LS42ODc1ZW07bGVmdDoxLjg3NWVtO3RyYW5zZm9ybTpyb3RhdGUoLTQ1ZGVnKTt0cmFuc2Zvcm0tb3JpZ2luOjAgMy43NWVtO2JvcmRlci1yYWRpdXM6MCA3LjVlbSA3LjVlbSAwfS5zd2FsMi1pY29uLnN3YWwyLXN1Y2Nlc3MgLnN3YWwyLXN1Y2Nlc3MtcmluZ3twb3NpdGlvbjphYnNvbHV0ZTt6LWluZGV4OjI7dG9wOi0uMjVlbTtsZWZ0Oi0uMjVlbTtib3gtc2l6aW5nOmNvbnRlbnQtYm94O3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7Ym9yZGVyOi4yNWVtIHNvbGlkIHJnYmEoMTY1LDIyMCwxMzQsLjMpO2JvcmRlci1yYWRpdXM6NTAlfS5zd2FsMi1pY29uLnN3YWwyLXN1Y2Nlc3MgLnN3YWwyLXN1Y2Nlc3MtZml4e3Bvc2l0aW9uOmFic29sdXRlO3otaW5kZXg6MTt0b3A6LjVlbTtsZWZ0OjEuNjI1ZW07d2lkdGg6LjQzNzVlbTtoZWlnaHQ6NS42MjVlbTt0cmFuc2Zvcm06cm90YXRlKC00NWRlZyl9LnN3YWwyLWljb24uc3dhbDItc3VjY2VzcyBbY2xhc3NePXN3YWwyLXN1Y2Nlc3MtbGluZV17ZGlzcGxheTpibG9jaztwb3NpdGlvbjphYnNvbHV0ZTt6LWluZGV4OjI7aGVpZ2h0Oi4zMTI1ZW07Ym9yZGVyLXJhZGl1czouMTI1ZW07YmFja2dyb3VuZC1jb2xvcjojYTVkYzg2fS5zd2FsMi1pY29uLnN3YWwyLXN1Y2Nlc3MgW2NsYXNzXj1zd2FsMi1zdWNjZXNzLWxpbmVdW2NsYXNzJD10aXBde3RvcDoyLjg3NWVtO2xlZnQ6LjgxMjVlbTt3aWR0aDoxLjU2MjVlbTt0cmFuc2Zvcm06cm90YXRlKDQ1ZGVnKX0uc3dhbDItaWNvbi5zd2FsMi1zdWNjZXNzIFtjbGFzc149c3dhbDItc3VjY2Vzcy1saW5lXVtjbGFzcyQ9bG9uZ117dG9wOjIuMzc1ZW07cmlnaHQ6LjVlbTt3aWR0aDoyLjkzNzVlbTt0cmFuc2Zvcm06cm90YXRlKC00NWRlZyl9LnN3YWwyLWljb24uc3dhbDItc3VjY2Vzcy5zd2FsMi1pY29uLXNob3cgLnN3YWwyLXN1Y2Nlc3MtbGluZS10aXB7LXdlYmtpdC1hbmltYXRpb246c3dhbDItYW5pbWF0ZS1zdWNjZXNzLWxpbmUtdGlwIC43NXM7YW5pbWF0aW9uOnN3YWwyLWFuaW1hdGUtc3VjY2Vzcy1saW5lLXRpcCAuNzVzfS5zd2FsMi1pY29uLnN3YWwyLXN1Y2Nlc3Muc3dhbDItaWNvbi1zaG93IC5zd2FsMi1zdWNjZXNzLWxpbmUtbG9uZ3std2Via2l0LWFuaW1hdGlvbjpzd2FsMi1hbmltYXRlLXN1Y2Nlc3MtbGluZS1sb25nIC43NXM7YW5pbWF0aW9uOnN3YWwyLWFuaW1hdGUtc3VjY2Vzcy1saW5lLWxvbmcgLjc1c30uc3dhbDItaWNvbi5zd2FsMi1zdWNjZXNzLnN3YWwyLWljb24tc2hvdyAuc3dhbDItc3VjY2Vzcy1jaXJjdWxhci1saW5lLXJpZ2h0ey13ZWJraXQtYW5pbWF0aW9uOnN3YWwyLXJvdGF0ZS1zdWNjZXNzLWNpcmN1bGFyLWxpbmUgNC4yNXMgZWFzZS1pbjthbmltYXRpb246c3dhbDItcm90YXRlLXN1Y2Nlc3MtY2lyY3VsYXItbGluZSA0LjI1cyBlYXNlLWlufS5zd2FsMi1wcm9ncmVzcy1zdGVwc3tmbGV4LXdyYXA6d3JhcDthbGlnbi1pdGVtczpjZW50ZXI7bWF4LXdpZHRoOjEwMCU7bWFyZ2luOjEuMjVlbSBhdXRvO3BhZGRpbmc6MDtiYWNrZ3JvdW5kOjAgMDtmb250LXdlaWdodDo2MDB9LnN3YWwyLXByb2dyZXNzLXN0ZXBzIGxpe2Rpc3BsYXk6aW5saW5lLWJsb2NrO3Bvc2l0aW9uOnJlbGF0aXZlfS5zd2FsMi1wcm9ncmVzcy1zdGVwcyAuc3dhbDItcHJvZ3Jlc3Mtc3RlcHt6LWluZGV4OjIwO2ZsZXgtc2hyaW5rOjA7d2lkdGg6MmVtO2hlaWdodDoyZW07Ym9yZGVyLXJhZGl1czoyZW07YmFja2dyb3VuZDojMjc3OGM0O2NvbG9yOiNmZmY7bGluZS1oZWlnaHQ6MmVtO3RleHQtYWxpZ246Y2VudGVyfS5zd2FsMi1wcm9ncmVzcy1zdGVwcyAuc3dhbDItcHJvZ3Jlc3Mtc3RlcC5zd2FsMi1hY3RpdmUtcHJvZ3Jlc3Mtc3RlcHtiYWNrZ3JvdW5kOiMyNzc4YzR9LnN3YWwyLXByb2dyZXNzLXN0ZXBzIC5zd2FsMi1wcm9ncmVzcy1zdGVwLnN3YWwyLWFjdGl2ZS1wcm9ncmVzcy1zdGVwfi5zd2FsMi1wcm9ncmVzcy1zdGVwe2JhY2tncm91bmQ6I2FkZDhlNjtjb2xvcjojZmZmfS5zd2FsMi1wcm9ncmVzcy1zdGVwcyAuc3dhbDItcHJvZ3Jlc3Mtc3RlcC5zd2FsMi1hY3RpdmUtcHJvZ3Jlc3Mtc3RlcH4uc3dhbDItcHJvZ3Jlc3Mtc3RlcC1saW5le2JhY2tncm91bmQ6I2FkZDhlNn0uc3dhbDItcHJvZ3Jlc3Mtc3RlcHMgLnN3YWwyLXByb2dyZXNzLXN0ZXAtbGluZXt6LWluZGV4OjEwO2ZsZXgtc2hyaW5rOjA7d2lkdGg6Mi41ZW07aGVpZ2h0Oi40ZW07bWFyZ2luOjAgLTFweDtiYWNrZ3JvdW5kOiMyNzc4YzR9W2NsYXNzXj1zd2FsMl17LXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOnRyYW5zcGFyZW50fS5zd2FsMi1zaG93ey13ZWJraXQtYW5pbWF0aW9uOnN3YWwyLXNob3cgLjNzO2FuaW1hdGlvbjpzd2FsMi1zaG93IC4zc30uc3dhbDItaGlkZXstd2Via2l0LWFuaW1hdGlvbjpzd2FsMi1oaWRlIC4xNXMgZm9yd2FyZHM7YW5pbWF0aW9uOnN3YWwyLWhpZGUgLjE1cyBmb3J3YXJkc30uc3dhbDItbm9hbmltYXRpb257dHJhbnNpdGlvbjpub25lfS5zd2FsMi1zY3JvbGxiYXItbWVhc3VyZXtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6LTk5OTlweDt3aWR0aDo1MHB4O2hlaWdodDo1MHB4O292ZXJmbG93OnNjcm9sbH0uc3dhbDItcnRsIC5zd2FsMi1jbG9zZXttYXJnaW4tcmlnaHQ6aW5pdGlhbDttYXJnaW4tbGVmdDowfS5zd2FsMi1ydGwgLnN3YWwyLXRpbWVyLXByb2dyZXNzLWJhcntyaWdodDowO2xlZnQ6YXV0b30uc3dhbDItbm8td2Fye2Rpc3BsYXk6ZmxleDtwb3NpdGlvbjpmaXhlZDt6LWluZGV4OjEwNjE7dG9wOjA7bGVmdDowO2FsaWduLWl0ZW1zOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO3dpZHRoOjEwMCU7aGVpZ2h0OjMuMzc1ZW07YmFja2dyb3VuZDojMjAyMzJhO2NvbG9yOiNmZmY7dGV4dC1hbGlnbjpjZW50ZXJ9LnN3YWwyLW5vLXdhciBhe2NvbG9yOiM2MWRhZmI7dGV4dC1kZWNvcmF0aW9uOm5vbmV9LnN3YWwyLW5vLXdhciBhOmhvdmVye3RleHQtZGVjb3JhdGlvbjp1bmRlcmxpbmV9QC13ZWJraXQta2V5ZnJhbWVzIHN3YWwyLXRvYXN0LXNob3d7MCV7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoLS42MjVlbSkgcm90YXRlWigyZGVnKX0zMyV7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoMCkgcm90YXRlWigtMmRlZyl9NjYle3RyYW5zZm9ybTp0cmFuc2xhdGVZKC4zMTI1ZW0pIHJvdGF0ZVooMmRlZyl9MTAwJXt0cmFuc2Zvcm06dHJhbnNsYXRlWSgwKSByb3RhdGVaKDApfX1Aa2V5ZnJhbWVzIHN3YWwyLXRvYXN0LXNob3d7MCV7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoLS42MjVlbSkgcm90YXRlWigyZGVnKX0zMyV7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoMCkgcm90YXRlWigtMmRlZyl9NjYle3RyYW5zZm9ybTp0cmFuc2xhdGVZKC4zMTI1ZW0pIHJvdGF0ZVooMmRlZyl9MTAwJXt0cmFuc2Zvcm06dHJhbnNsYXRlWSgwKSByb3RhdGVaKDApfX1ALXdlYmtpdC1rZXlmcmFtZXMgc3dhbDItdG9hc3QtaGlkZXsxMDAle3RyYW5zZm9ybTpyb3RhdGVaKDFkZWcpO29wYWNpdHk6MH19QGtleWZyYW1lcyBzd2FsMi10b2FzdC1oaWRlezEwMCV7dHJhbnNmb3JtOnJvdGF0ZVooMWRlZyk7b3BhY2l0eTowfX1ALXdlYmtpdC1rZXlmcmFtZXMgc3dhbDItdG9hc3QtYW5pbWF0ZS1zdWNjZXNzLWxpbmUtdGlwezAle3RvcDouNTYyNWVtO2xlZnQ6LjA2MjVlbTt3aWR0aDowfTU0JXt0b3A6LjEyNWVtO2xlZnQ6LjEyNWVtO3dpZHRoOjB9NzAle3RvcDouNjI1ZW07bGVmdDotLjI1ZW07d2lkdGg6MS42MjVlbX04NCV7dG9wOjEuMDYyNWVtO2xlZnQ6Ljc1ZW07d2lkdGg6LjVlbX0xMDAle3RvcDoxLjEyNWVtO2xlZnQ6LjE4NzVlbTt3aWR0aDouNzVlbX19QGtleWZyYW1lcyBzd2FsMi10b2FzdC1hbmltYXRlLXN1Y2Nlc3MtbGluZS10aXB7MCV7dG9wOi41NjI1ZW07bGVmdDouMDYyNWVtO3dpZHRoOjB9NTQle3RvcDouMTI1ZW07bGVmdDouMTI1ZW07d2lkdGg6MH03MCV7dG9wOi42MjVlbTtsZWZ0Oi0uMjVlbTt3aWR0aDoxLjYyNWVtfTg0JXt0b3A6MS4wNjI1ZW07bGVmdDouNzVlbTt3aWR0aDouNWVtfTEwMCV7dG9wOjEuMTI1ZW07bGVmdDouMTg3NWVtO3dpZHRoOi43NWVtfX1ALXdlYmtpdC1rZXlmcmFtZXMgc3dhbDItdG9hc3QtYW5pbWF0ZS1zdWNjZXNzLWxpbmUtbG9uZ3swJXt0b3A6MS42MjVlbTtyaWdodDoxLjM3NWVtO3dpZHRoOjB9NjUle3RvcDoxLjI1ZW07cmlnaHQ6LjkzNzVlbTt3aWR0aDowfTg0JXt0b3A6LjkzNzVlbTtyaWdodDowO3dpZHRoOjEuMTI1ZW19MTAwJXt0b3A6LjkzNzVlbTtyaWdodDouMTg3NWVtO3dpZHRoOjEuMzc1ZW19fUBrZXlmcmFtZXMgc3dhbDItdG9hc3QtYW5pbWF0ZS1zdWNjZXNzLWxpbmUtbG9uZ3swJXt0b3A6MS42MjVlbTtyaWdodDoxLjM3NWVtO3dpZHRoOjB9NjUle3RvcDoxLjI1ZW07cmlnaHQ6LjkzNzVlbTt3aWR0aDowfTg0JXt0b3A6LjkzNzVlbTtyaWdodDowO3dpZHRoOjEuMTI1ZW19MTAwJXt0b3A6LjkzNzVlbTtyaWdodDouMTg3NWVtO3dpZHRoOjEuMzc1ZW19fUAtd2Via2l0LWtleWZyYW1lcyBzd2FsMi1zaG93ezAle3RyYW5zZm9ybTpzY2FsZSguNyl9NDUle3RyYW5zZm9ybTpzY2FsZSgxLjA1KX04MCV7dHJhbnNmb3JtOnNjYWxlKC45NSl9MTAwJXt0cmFuc2Zvcm06c2NhbGUoMSl9fUBrZXlmcmFtZXMgc3dhbDItc2hvd3swJXt0cmFuc2Zvcm06c2NhbGUoLjcpfTQ1JXt0cmFuc2Zvcm06c2NhbGUoMS4wNSl9ODAle3RyYW5zZm9ybTpzY2FsZSguOTUpfTEwMCV7dHJhbnNmb3JtOnNjYWxlKDEpfX1ALXdlYmtpdC1rZXlmcmFtZXMgc3dhbDItaGlkZXswJXt0cmFuc2Zvcm06c2NhbGUoMSk7b3BhY2l0eToxfTEwMCV7dHJhbnNmb3JtOnNjYWxlKC41KTtvcGFjaXR5OjB9fUBrZXlmcmFtZXMgc3dhbDItaGlkZXswJXt0cmFuc2Zvcm06c2NhbGUoMSk7b3BhY2l0eToxfTEwMCV7dHJhbnNmb3JtOnNjYWxlKC41KTtvcGFjaXR5OjB9fUAtd2Via2l0LWtleWZyYW1lcyBzd2FsMi1hbmltYXRlLXN1Y2Nlc3MtbGluZS10aXB7MCV7dG9wOjEuMTg3NWVtO2xlZnQ6LjA2MjVlbTt3aWR0aDowfTU0JXt0b3A6MS4wNjI1ZW07bGVmdDouMTI1ZW07d2lkdGg6MH03MCV7dG9wOjIuMTg3NWVtO2xlZnQ6LS4zNzVlbTt3aWR0aDozLjEyNWVtfTg0JXt0b3A6M2VtO2xlZnQ6MS4zMTI1ZW07d2lkdGg6MS4wNjI1ZW19MTAwJXt0b3A6Mi44MTI1ZW07bGVmdDouODEyNWVtO3dpZHRoOjEuNTYyNWVtfX1Aa2V5ZnJhbWVzIHN3YWwyLWFuaW1hdGUtc3VjY2Vzcy1saW5lLXRpcHswJXt0b3A6MS4xODc1ZW07bGVmdDouMDYyNWVtO3dpZHRoOjB9NTQle3RvcDoxLjA2MjVlbTtsZWZ0Oi4xMjVlbTt3aWR0aDowfTcwJXt0b3A6Mi4xODc1ZW07bGVmdDotLjM3NWVtO3dpZHRoOjMuMTI1ZW19ODQle3RvcDozZW07bGVmdDoxLjMxMjVlbTt3aWR0aDoxLjA2MjVlbX0xMDAle3RvcDoyLjgxMjVlbTtsZWZ0Oi44MTI1ZW07d2lkdGg6MS41NjI1ZW19fUAtd2Via2l0LWtleWZyYW1lcyBzd2FsMi1hbmltYXRlLXN1Y2Nlc3MtbGluZS1sb25nezAle3RvcDozLjM3NWVtO3JpZ2h0OjIuODc1ZW07d2lkdGg6MH02NSV7dG9wOjMuMzc1ZW07cmlnaHQ6Mi44NzVlbTt3aWR0aDowfTg0JXt0b3A6Mi4xODc1ZW07cmlnaHQ6MDt3aWR0aDozLjQzNzVlbX0xMDAle3RvcDoyLjM3NWVtO3JpZ2h0Oi41ZW07d2lkdGg6Mi45Mzc1ZW19fUBrZXlmcmFtZXMgc3dhbDItYW5pbWF0ZS1zdWNjZXNzLWxpbmUtbG9uZ3swJXt0b3A6My4zNzVlbTtyaWdodDoyLjg3NWVtO3dpZHRoOjB9NjUle3RvcDozLjM3NWVtO3JpZ2h0OjIuODc1ZW07d2lkdGg6MH04NCV7dG9wOjIuMTg3NWVtO3JpZ2h0OjA7d2lkdGg6My40Mzc1ZW19MTAwJXt0b3A6Mi4zNzVlbTtyaWdodDouNWVtO3dpZHRoOjIuOTM3NWVtfX1ALXdlYmtpdC1rZXlmcmFtZXMgc3dhbDItcm90YXRlLXN1Y2Nlc3MtY2lyY3VsYXItbGluZXswJXt0cmFuc2Zvcm06cm90YXRlKC00NWRlZyl9NSV7dHJhbnNmb3JtOnJvdGF0ZSgtNDVkZWcpfTEyJXt0cmFuc2Zvcm06cm90YXRlKC00MDVkZWcpfTEwMCV7dHJhbnNmb3JtOnJvdGF0ZSgtNDA1ZGVnKX19QGtleWZyYW1lcyBzd2FsMi1yb3RhdGUtc3VjY2Vzcy1jaXJjdWxhci1saW5lezAle3RyYW5zZm9ybTpyb3RhdGUoLTQ1ZGVnKX01JXt0cmFuc2Zvcm06cm90YXRlKC00NWRlZyl9MTIle3RyYW5zZm9ybTpyb3RhdGUoLTQwNWRlZyl9MTAwJXt0cmFuc2Zvcm06cm90YXRlKC00MDVkZWcpfX1ALXdlYmtpdC1rZXlmcmFtZXMgc3dhbDItYW5pbWF0ZS1lcnJvci14LW1hcmt7MCV7bWFyZ2luLXRvcDoxLjYyNWVtO3RyYW5zZm9ybTpzY2FsZSguNCk7b3BhY2l0eTowfTUwJXttYXJnaW4tdG9wOjEuNjI1ZW07dHJhbnNmb3JtOnNjYWxlKC40KTtvcGFjaXR5OjB9ODAle21hcmdpbi10b3A6LS4zNzVlbTt0cmFuc2Zvcm06c2NhbGUoMS4xNSl9MTAwJXttYXJnaW4tdG9wOjA7dHJhbnNmb3JtOnNjYWxlKDEpO29wYWNpdHk6MX19QGtleWZyYW1lcyBzd2FsMi1hbmltYXRlLWVycm9yLXgtbWFya3swJXttYXJnaW4tdG9wOjEuNjI1ZW07dHJhbnNmb3JtOnNjYWxlKC40KTtvcGFjaXR5OjB9NTAle21hcmdpbi10b3A6MS42MjVlbTt0cmFuc2Zvcm06c2NhbGUoLjQpO29wYWNpdHk6MH04MCV7bWFyZ2luLXRvcDotLjM3NWVtO3RyYW5zZm9ybTpzY2FsZSgxLjE1KX0xMDAle21hcmdpbi10b3A6MDt0cmFuc2Zvcm06c2NhbGUoMSk7b3BhY2l0eToxfX1ALXdlYmtpdC1rZXlmcmFtZXMgc3dhbDItYW5pbWF0ZS1lcnJvci1pY29uezAle3RyYW5zZm9ybTpyb3RhdGVYKDEwMGRlZyk7b3BhY2l0eTowfTEwMCV7dHJhbnNmb3JtOnJvdGF0ZVgoMCk7b3BhY2l0eToxfX1Aa2V5ZnJhbWVzIHN3YWwyLWFuaW1hdGUtZXJyb3ItaWNvbnswJXt0cmFuc2Zvcm06cm90YXRlWCgxMDBkZWcpO29wYWNpdHk6MH0xMDAle3RyYW5zZm9ybTpyb3RhdGVYKDApO29wYWNpdHk6MX19QC13ZWJraXQta2V5ZnJhbWVzIHN3YWwyLXJvdGF0ZS1sb2FkaW5nezAle3RyYW5zZm9ybTpyb3RhdGUoMCl9MTAwJXt0cmFuc2Zvcm06cm90YXRlKDM2MGRlZyl9fUBrZXlmcmFtZXMgc3dhbDItcm90YXRlLWxvYWRpbmd7MCV7dHJhbnNmb3JtOnJvdGF0ZSgwKX0xMDAle3RyYW5zZm9ybTpyb3RhdGUoMzYwZGVnKX19QC13ZWJraXQta2V5ZnJhbWVzIHN3YWwyLWFuaW1hdGUtcXVlc3Rpb24tbWFya3swJXt0cmFuc2Zvcm06cm90YXRlWSgtMzYwZGVnKX0xMDAle3RyYW5zZm9ybTpyb3RhdGVZKDApfX1Aa2V5ZnJhbWVzIHN3YWwyLWFuaW1hdGUtcXVlc3Rpb24tbWFya3swJXt0cmFuc2Zvcm06cm90YXRlWSgtMzYwZGVnKX0xMDAle3RyYW5zZm9ybTpyb3RhdGVZKDApfX1ALXdlYmtpdC1rZXlmcmFtZXMgc3dhbDItYW5pbWF0ZS1pLW1hcmt7MCV7dHJhbnNmb3JtOnJvdGF0ZVooNDVkZWcpO29wYWNpdHk6MH0yNSV7dHJhbnNmb3JtOnJvdGF0ZVooLTI1ZGVnKTtvcGFjaXR5Oi40fTUwJXt0cmFuc2Zvcm06cm90YXRlWigxNWRlZyk7b3BhY2l0eTouOH03NSV7dHJhbnNmb3JtOnJvdGF0ZVooLTVkZWcpO29wYWNpdHk6MX0xMDAle3RyYW5zZm9ybTpyb3RhdGVYKDApO29wYWNpdHk6MX19QGtleWZyYW1lcyBzd2FsMi1hbmltYXRlLWktbWFya3swJXt0cmFuc2Zvcm06cm90YXRlWig0NWRlZyk7b3BhY2l0eTowfTI1JXt0cmFuc2Zvcm06cm90YXRlWigtMjVkZWcpO29wYWNpdHk6LjR9NTAle3RyYW5zZm9ybTpyb3RhdGVaKDE1ZGVnKTtvcGFjaXR5Oi44fTc1JXt0cmFuc2Zvcm06cm90YXRlWigtNWRlZyk7b3BhY2l0eToxfTEwMCV7dHJhbnNmb3JtOnJvdGF0ZVgoMCk7b3BhY2l0eToxfX1ib2R5LnN3YWwyLXNob3duOm5vdCguc3dhbDItbm8tYmFja2Ryb3ApOm5vdCguc3dhbDItdG9hc3Qtc2hvd24pe292ZXJmbG93OmhpZGRlbn1ib2R5LnN3YWwyLWhlaWdodC1hdXRve2hlaWdodDphdXRvIWltcG9ydGFudH1ib2R5LnN3YWwyLW5vLWJhY2tkcm9wIC5zd2FsMi1jb250YWluZXJ7YmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudCFpbXBvcnRhbnQ7cG9pbnRlci1ldmVudHM6bm9uZX1ib2R5LnN3YWwyLW5vLWJhY2tkcm9wIC5zd2FsMi1jb250YWluZXIgLnN3YWwyLXBvcHVwe3BvaW50ZXItZXZlbnRzOmFsbH1ib2R5LnN3YWwyLW5vLWJhY2tkcm9wIC5zd2FsMi1jb250YWluZXIgLnN3YWwyLW1vZGFse2JveC1zaGFkb3c6MCAwIDEwcHggcmdiYSgwLDAsMCwuNCl9QG1lZGlhIHByaW50e2JvZHkuc3dhbDItc2hvd246bm90KC5zd2FsMi1uby1iYWNrZHJvcCk6bm90KC5zd2FsMi10b2FzdC1zaG93bil7b3ZlcmZsb3cteTpzY3JvbGwhaW1wb3J0YW50fWJvZHkuc3dhbDItc2hvd246bm90KC5zd2FsMi1uby1iYWNrZHJvcCk6bm90KC5zd2FsMi10b2FzdC1zaG93bik+W2FyaWEtaGlkZGVuPXRydWVde2Rpc3BsYXk6bm9uZX1ib2R5LnN3YWwyLXNob3duOm5vdCguc3dhbDItbm8tYmFja2Ryb3ApOm5vdCguc3dhbDItdG9hc3Qtc2hvd24pIC5zd2FsMi1jb250YWluZXJ7cG9zaXRpb246c3RhdGljIWltcG9ydGFudH19Ym9keS5zd2FsMi10b2FzdC1zaG93biAuc3dhbDItY29udGFpbmVye2JveC1zaXppbmc6Ym9yZGVyLWJveDt3aWR0aDozNjBweDttYXgtd2lkdGg6MTAwJTtiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50O3BvaW50ZXItZXZlbnRzOm5vbmV9Ym9keS5zd2FsMi10b2FzdC1zaG93biAuc3dhbDItY29udGFpbmVyLnN3YWwyLXRvcHt0b3A6MDtyaWdodDphdXRvO2JvdHRvbTphdXRvO2xlZnQ6NTAlO3RyYW5zZm9ybTp0cmFuc2xhdGVYKC01MCUpfWJvZHkuc3dhbDItdG9hc3Qtc2hvd24gLnN3YWwyLWNvbnRhaW5lci5zd2FsMi10b3AtZW5kLGJvZHkuc3dhbDItdG9hc3Qtc2hvd24gLnN3YWwyLWNvbnRhaW5lci5zd2FsMi10b3AtcmlnaHR7dG9wOjA7cmlnaHQ6MDtib3R0b206YXV0bztsZWZ0OmF1dG99Ym9keS5zd2FsMi10b2FzdC1zaG93biAuc3dhbDItY29udGFpbmVyLnN3YWwyLXRvcC1sZWZ0LGJvZHkuc3dhbDItdG9hc3Qtc2hvd24gLnN3YWwyLWNvbnRhaW5lci5zd2FsMi10b3Atc3RhcnR7dG9wOjA7cmlnaHQ6YXV0bztib3R0b206YXV0bztsZWZ0OjB9Ym9keS5zd2FsMi10b2FzdC1zaG93biAuc3dhbDItY29udGFpbmVyLnN3YWwyLWNlbnRlci1sZWZ0LGJvZHkuc3dhbDItdG9hc3Qtc2hvd24gLnN3YWwyLWNvbnRhaW5lci5zd2FsMi1jZW50ZXItc3RhcnR7dG9wOjUwJTtyaWdodDphdXRvO2JvdHRvbTphdXRvO2xlZnQ6MDt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtNTAlKX1ib2R5LnN3YWwyLXRvYXN0LXNob3duIC5zd2FsMi1jb250YWluZXIuc3dhbDItY2VudGVye3RvcDo1MCU7cmlnaHQ6YXV0bztib3R0b206YXV0bztsZWZ0OjUwJTt0cmFuc2Zvcm06dHJhbnNsYXRlKC01MCUsLTUwJSl9Ym9keS5zd2FsMi10b2FzdC1zaG93biAuc3dhbDItY29udGFpbmVyLnN3YWwyLWNlbnRlci1lbmQsYm9keS5zd2FsMi10b2FzdC1zaG93biAuc3dhbDItY29udGFpbmVyLnN3YWwyLWNlbnRlci1yaWdodHt0b3A6NTAlO3JpZ2h0OjA7Ym90dG9tOmF1dG87bGVmdDphdXRvO3RyYW5zZm9ybTp0cmFuc2xhdGVZKC01MCUpfWJvZHkuc3dhbDItdG9hc3Qtc2hvd24gLnN3YWwyLWNvbnRhaW5lci5zd2FsMi1ib3R0b20tbGVmdCxib2R5LnN3YWwyLXRvYXN0LXNob3duIC5zd2FsMi1jb250YWluZXIuc3dhbDItYm90dG9tLXN0YXJ0e3RvcDphdXRvO3JpZ2h0OmF1dG87Ym90dG9tOjA7bGVmdDowfWJvZHkuc3dhbDItdG9hc3Qtc2hvd24gLnN3YWwyLWNvbnRhaW5lci5zd2FsMi1ib3R0b217dG9wOmF1dG87cmlnaHQ6YXV0bztib3R0b206MDtsZWZ0OjUwJTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgtNTAlKX1ib2R5LnN3YWwyLXRvYXN0LXNob3duIC5zd2FsMi1jb250YWluZXIuc3dhbDItYm90dG9tLWVuZCxib2R5LnN3YWwyLXRvYXN0LXNob3duIC5zd2FsMi1jb250YWluZXIuc3dhbDItYm90dG9tLXJpZ2h0e3RvcDphdXRvO3JpZ2h0OjA7Ym90dG9tOjA7bGVmdDphdXRvfVwiKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/sweetalert2/dist/sweetalert2.all.js\n");

/***/ }),

/***/ "./node_modules/tinymce/tinymce.js":
/*!*****************************************!*\
  !*** ./node_modules/tinymce/tinymce.js ***!
  \*****************************************/
/***/ ((module) => {

eval("/**\n * TinyMCE version 6.0.3 (2022-05-25)\n */\n\n(function () {\n    'use strict';\n\n    var typeOf$1 = function (x) {\n      if (x === null) {\n        return 'null';\n      }\n      if (x === undefined) {\n        return 'undefined';\n      }\n      var t = typeof x;\n      if (t === 'object' && (Array.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'Array')) {\n        return 'array';\n      }\n      if (t === 'object' && (String.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'String')) {\n        return 'string';\n      }\n      return t;\n    };\n    var isEquatableType = function (x) {\n      return [\n        'undefined',\n        'boolean',\n        'number',\n        'string',\n        'function',\n        'xml',\n        'null'\n      ].indexOf(x) !== -1;\n    };\n\n    var sort$1 = function (xs, compareFn) {\n      var clone = Array.prototype.slice.call(xs);\n      return clone.sort(compareFn);\n    };\n\n    var contramap = function (eqa, f) {\n      return eq$2(function (x, y) {\n        return eqa.eq(f(x), f(y));\n      });\n    };\n    var eq$2 = function (f) {\n      return { eq: f };\n    };\n    var tripleEq = eq$2(function (x, y) {\n      return x === y;\n    });\n    var eqString = tripleEq;\n    var eqArray = function (eqa) {\n      return eq$2(function (x, y) {\n        if (x.length !== y.length) {\n          return false;\n        }\n        var len = x.length;\n        for (var i = 0; i < len; i++) {\n          if (!eqa.eq(x[i], y[i])) {\n            return false;\n          }\n        }\n        return true;\n      });\n    };\n    var eqSortedArray = function (eqa, compareFn) {\n      return contramap(eqArray(eqa), function (xs) {\n        return sort$1(xs, compareFn);\n      });\n    };\n    var eqRecord = function (eqa) {\n      return eq$2(function (x, y) {\n        var kx = Object.keys(x);\n        var ky = Object.keys(y);\n        if (!eqSortedArray(eqString).eq(kx, ky)) {\n          return false;\n        }\n        var len = kx.length;\n        for (var i = 0; i < len; i++) {\n          var q = kx[i];\n          if (!eqa.eq(x[q], y[q])) {\n            return false;\n          }\n        }\n        return true;\n      });\n    };\n    var eqAny = eq$2(function (x, y) {\n      if (x === y) {\n        return true;\n      }\n      var tx = typeOf$1(x);\n      var ty = typeOf$1(y);\n      if (tx !== ty) {\n        return false;\n      }\n      if (isEquatableType(tx)) {\n        return x === y;\n      } else if (tx === 'array') {\n        return eqArray(eqAny).eq(x, y);\n      } else if (tx === 'object') {\n        return eqRecord(eqAny).eq(x, y);\n      }\n      return false;\n    });\n\n    const getPrototypeOf$1 = Object.getPrototypeOf;\n    const hasProto = (v, constructor, predicate) => {\n      var _a;\n      if (predicate(v, constructor.prototype)) {\n        return true;\n      } else {\n        return ((_a = v.constructor) === null || _a === void 0 ? void 0 : _a.name) === constructor.name;\n      }\n    };\n    const typeOf = x => {\n      const t = typeof x;\n      if (x === null) {\n        return 'null';\n      } else if (t === 'object' && Array.isArray(x)) {\n        return 'array';\n      } else if (t === 'object' && hasProto(x, String, (o, proto) => proto.isPrototypeOf(o))) {\n        return 'string';\n      } else {\n        return t;\n      }\n    };\n    const isType$1 = type => value => typeOf(value) === type;\n    const isSimpleType = type => value => typeof value === type;\n    const eq$1 = t => a => t === a;\n    const is$4 = (value, constructor) => isObject(value) && hasProto(value, constructor, (o, proto) => getPrototypeOf$1(o) === proto);\n    const isString = isType$1('string');\n    const isObject = isType$1('object');\n    const isPlainObject = value => is$4(value, Object);\n    const isArray$1 = isType$1('array');\n    const isNull = eq$1(null);\n    const isBoolean = isSimpleType('boolean');\n    const isUndefined = eq$1(undefined);\n    const isNullable = a => a === null || a === undefined;\n    const isNonNullable = a => !isNullable(a);\n    const isFunction = isSimpleType('function');\n    const isNumber = isSimpleType('number');\n    const isArrayOf = (value, pred) => {\n      if (isArray$1(value)) {\n        for (let i = 0, len = value.length; i < len; ++i) {\n          if (!pred(value[i])) {\n            return false;\n          }\n        }\n        return true;\n      }\n      return false;\n    };\n\n    const noop = () => {\n    };\n    const compose = (fa, fb) => {\n      return (...args) => {\n        return fa(fb.apply(null, args));\n      };\n    };\n    const compose1 = (fbc, fab) => a => fbc(fab(a));\n    const constant = value => {\n      return () => {\n        return value;\n      };\n    };\n    const identity = x => {\n      return x;\n    };\n    const tripleEquals = (a, b) => {\n      return a === b;\n    };\n    function curry(fn, ...initialArgs) {\n      return (...restArgs) => {\n        const all = initialArgs.concat(restArgs);\n        return fn.apply(null, all);\n      };\n    }\n    const not = f => t => !f(t);\n    const die = msg => {\n      return () => {\n        throw new Error(msg);\n      };\n    };\n    const apply$1 = f => {\n      return f();\n    };\n    const call = f => {\n      f();\n    };\n    const never = constant(false);\n    const always = constant(true);\n\n    class Optional {\n      constructor(tag, value) {\n        this.tag = tag;\n        this.value = value;\n      }\n      static some(value) {\n        return new Optional(true, value);\n      }\n      static none() {\n        return Optional.singletonNone;\n      }\n      fold(onNone, onSome) {\n        if (this.tag) {\n          return onSome(this.value);\n        } else {\n          return onNone();\n        }\n      }\n      isSome() {\n        return this.tag;\n      }\n      isNone() {\n        return !this.tag;\n      }\n      map(mapper) {\n        if (this.tag) {\n          return Optional.some(mapper(this.value));\n        } else {\n          return Optional.none();\n        }\n      }\n      bind(binder) {\n        if (this.tag) {\n          return binder(this.value);\n        } else {\n          return Optional.none();\n        }\n      }\n      exists(predicate) {\n        return this.tag && predicate(this.value);\n      }\n      forall(predicate) {\n        return !this.tag || predicate(this.value);\n      }\n      filter(predicate) {\n        if (!this.tag || predicate(this.value)) {\n          return this;\n        } else {\n          return Optional.none();\n        }\n      }\n      getOr(replacement) {\n        return this.tag ? this.value : replacement;\n      }\n      or(replacement) {\n        return this.tag ? this : replacement;\n      }\n      getOrThunk(thunk) {\n        return this.tag ? this.value : thunk();\n      }\n      orThunk(thunk) {\n        return this.tag ? this : thunk();\n      }\n      getOrDie(message) {\n        if (!this.tag) {\n          throw new Error(message !== null && message !== void 0 ? message : 'Called getOrDie on None');\n        } else {\n          return this.value;\n        }\n      }\n      static from(value) {\n        return isNonNullable(value) ? Optional.some(value) : Optional.none();\n      }\n      getOrNull() {\n        return this.tag ? this.value : null;\n      }\n      getOrUndefined() {\n        return this.value;\n      }\n      each(worker) {\n        if (this.tag) {\n          worker(this.value);\n        }\n      }\n      toArray() {\n        return this.tag ? [this.value] : [];\n      }\n      toString() {\n        return this.tag ? `some(${ this.value })` : 'none()';\n      }\n    }\n    Optional.singletonNone = new Optional(false);\n\n    const nativeSlice = Array.prototype.slice;\n    const nativeIndexOf = Array.prototype.indexOf;\n    const nativePush = Array.prototype.push;\n    const rawIndexOf = (ts, t) => nativeIndexOf.call(ts, t);\n    const indexOf$1 = (xs, x) => {\n      const r = rawIndexOf(xs, x);\n      return r === -1 ? Optional.none() : Optional.some(r);\n    };\n    const contains$2 = (xs, x) => rawIndexOf(xs, x) > -1;\n    const exists = (xs, pred) => {\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (pred(x, i)) {\n          return true;\n        }\n      }\n      return false;\n    };\n    const map$3 = (xs, f) => {\n      const len = xs.length;\n      const r = new Array(len);\n      for (let i = 0; i < len; i++) {\n        const x = xs[i];\n        r[i] = f(x, i);\n      }\n      return r;\n    };\n    const each$g = (xs, f) => {\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        f(x, i);\n      }\n    };\n    const eachr = (xs, f) => {\n      for (let i = xs.length - 1; i >= 0; i--) {\n        const x = xs[i];\n        f(x, i);\n      }\n    };\n    const partition$2 = (xs, pred) => {\n      const pass = [];\n      const fail = [];\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        const arr = pred(x, i) ? pass : fail;\n        arr.push(x);\n      }\n      return {\n        pass,\n        fail\n      };\n    };\n    const filter$6 = (xs, pred) => {\n      const r = [];\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (pred(x, i)) {\n          r.push(x);\n        }\n      }\n      return r;\n    };\n    const foldr = (xs, f, acc) => {\n      eachr(xs, (x, i) => {\n        acc = f(acc, x, i);\n      });\n      return acc;\n    };\n    const foldl = (xs, f, acc) => {\n      each$g(xs, (x, i) => {\n        acc = f(acc, x, i);\n      });\n      return acc;\n    };\n    const findUntil$1 = (xs, pred, until) => {\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (pred(x, i)) {\n          return Optional.some(x);\n        } else if (until(x, i)) {\n          break;\n        }\n      }\n      return Optional.none();\n    };\n    const find$2 = (xs, pred) => {\n      return findUntil$1(xs, pred, never);\n    };\n    const findIndex$2 = (xs, pred) => {\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (pred(x, i)) {\n          return Optional.some(i);\n        }\n      }\n      return Optional.none();\n    };\n    const flatten = xs => {\n      const r = [];\n      for (let i = 0, len = xs.length; i < len; ++i) {\n        if (!isArray$1(xs[i])) {\n          throw new Error('Arr.flatten item ' + i + ' was not an array, input: ' + xs);\n        }\n        nativePush.apply(r, xs[i]);\n      }\n      return r;\n    };\n    const bind$3 = (xs, f) => flatten(map$3(xs, f));\n    const forall = (xs, pred) => {\n      for (let i = 0, len = xs.length; i < len; ++i) {\n        const x = xs[i];\n        if (pred(x, i) !== true) {\n          return false;\n        }\n      }\n      return true;\n    };\n    const reverse = xs => {\n      const r = nativeSlice.call(xs, 0);\n      r.reverse();\n      return r;\n    };\n    const difference = (a1, a2) => filter$6(a1, x => !contains$2(a2, x));\n    const mapToObject = (xs, f) => {\n      const r = {};\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        r[String(x)] = f(x, i);\n      }\n      return r;\n    };\n    const sort = (xs, comparator) => {\n      const copy = nativeSlice.call(xs, 0);\n      copy.sort(comparator);\n      return copy;\n    };\n    const get$b = (xs, i) => i >= 0 && i < xs.length ? Optional.some(xs[i]) : Optional.none();\n    const head = xs => get$b(xs, 0);\n    const last$3 = xs => get$b(xs, xs.length - 1);\n    const from = isFunction(Array.from) ? Array.from : x => nativeSlice.call(x);\n    const findMap = (arr, f) => {\n      for (let i = 0; i < arr.length; i++) {\n        const r = f(arr[i], i);\n        if (r.isSome()) {\n          return r;\n        }\n      }\n      return Optional.none();\n    };\n    const unique$1 = (xs, comparator) => {\n      const r = [];\n      const isDuplicated = isFunction(comparator) ? x => exists(r, i => comparator(i, x)) : x => contains$2(r, x);\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (!isDuplicated(x)) {\n          r.push(x);\n        }\n      }\n      return r;\n    };\n\n    const keys = Object.keys;\n    const hasOwnProperty$2 = Object.hasOwnProperty;\n    const each$f = (obj, f) => {\n      const props = keys(obj);\n      for (let k = 0, len = props.length; k < len; k++) {\n        const i = props[k];\n        const x = obj[i];\n        f(x, i);\n      }\n    };\n    const map$2 = (obj, f) => {\n      return tupleMap(obj, (x, i) => ({\n        k: i,\n        v: f(x, i)\n      }));\n    };\n    const tupleMap = (obj, f) => {\n      const r = {};\n      each$f(obj, (x, i) => {\n        const tuple = f(x, i);\n        r[tuple.k] = tuple.v;\n      });\n      return r;\n    };\n    const objAcc = r => (x, i) => {\n      r[i] = x;\n    };\n    const internalFilter = (obj, pred, onTrue, onFalse) => {\n      const r = {};\n      each$f(obj, (x, i) => {\n        (pred(x, i) ? onTrue : onFalse)(x, i);\n      });\n      return r;\n    };\n    const bifilter = (obj, pred) => {\n      const t = {};\n      const f = {};\n      internalFilter(obj, pred, objAcc(t), objAcc(f));\n      return {\n        t,\n        f\n      };\n    };\n    const filter$5 = (obj, pred) => {\n      const t = {};\n      internalFilter(obj, pred, objAcc(t), noop);\n      return t;\n    };\n    const mapToArray = (obj, f) => {\n      const r = [];\n      each$f(obj, (value, name) => {\n        r.push(f(value, name));\n      });\n      return r;\n    };\n    const values = obj => {\n      return mapToArray(obj, identity);\n    };\n    const get$a = (obj, key) => {\n      return has$2(obj, key) ? Optional.from(obj[key]) : Optional.none();\n    };\n    const has$2 = (obj, key) => hasOwnProperty$2.call(obj, key);\n    const hasNonNullableKey = (obj, key) => has$2(obj, key) && obj[key] !== undefined && obj[key] !== null;\n    const equal$1 = (a1, a2, eq = eqAny) => eqRecord(eq).eq(a1, a2);\n\n    const stringArray = a => {\n      const all = {};\n      each$g(a, key => {\n        all[key] = {};\n      });\n      return keys(all);\n    };\n\n    const isArray = Array.isArray;\n    const toArray$1 = obj => {\n      if (!isArray(obj)) {\n        const array = [];\n        for (let i = 0, l = obj.length; i < l; i++) {\n          array[i] = obj[i];\n        }\n        return array;\n      } else {\n        return obj;\n      }\n    };\n    const each$e = (o, cb, s) => {\n      let n, l;\n      if (!o) {\n        return false;\n      }\n      s = s || o;\n      if (o.length !== undefined) {\n        for (n = 0, l = o.length; n < l; n++) {\n          if (cb.call(s, o[n], n, o) === false) {\n            return false;\n          }\n        }\n      } else {\n        for (n in o) {\n          if (has$2(o, n)) {\n            if (cb.call(s, o[n], n, o) === false) {\n              return false;\n            }\n          }\n        }\n      }\n      return true;\n    };\n    const map$1 = (array, callback) => {\n      const out = [];\n      each$e(array, (item, index) => {\n        out.push(callback(item, index, array));\n      });\n      return out;\n    };\n    const filter$4 = (a, f) => {\n      const o = [];\n      each$e(a, (v, index) => {\n        if (!f || f(v, index, a)) {\n          o.push(v);\n        }\n      });\n      return o;\n    };\n    const indexOf = (a, v) => {\n      if (a) {\n        for (let i = 0, l = a.length; i < l; i++) {\n          if (a[i] === v) {\n            return i;\n          }\n        }\n      }\n      return -1;\n    };\n    const reduce = (collection, iteratee, accumulator, thisArg) => {\n      let acc = isUndefined(accumulator) ? collection[0] : accumulator;\n      for (let i = 0; i < collection.length; i++) {\n        acc = iteratee.call(thisArg, acc, collection[i], i);\n      }\n      return acc;\n    };\n    const findIndex$1 = (array, predicate, thisArg) => {\n      let i, l;\n      for (i = 0, l = array.length; i < l; i++) {\n        if (predicate.call(thisArg, array[i], i, array)) {\n          return i;\n        }\n      }\n      return -1;\n    };\n    const last$2 = collection => collection[collection.length - 1];\n\n    const cached = f => {\n      let called = false;\n      let r;\n      return (...args) => {\n        if (!called) {\n          called = true;\n          r = f.apply(null, args);\n        }\n        return r;\n      };\n    };\n\n    const DeviceType = (os, browser, userAgent, mediaMatch) => {\n      const isiPad = os.isiOS() && /ipad/i.test(userAgent) === true;\n      const isiPhone = os.isiOS() && !isiPad;\n      const isMobile = os.isiOS() || os.isAndroid();\n      const isTouch = isMobile || mediaMatch('(pointer:coarse)');\n      const isTablet = isiPad || !isiPhone && isMobile && mediaMatch('(min-device-width:768px)');\n      const isPhone = isiPhone || isMobile && !isTablet;\n      const iOSwebview = browser.isSafari() && os.isiOS() && /safari/i.test(userAgent) === false;\n      const isDesktop = !isPhone && !isTablet && !iOSwebview;\n      return {\n        isiPad: constant(isiPad),\n        isiPhone: constant(isiPhone),\n        isTablet: constant(isTablet),\n        isPhone: constant(isPhone),\n        isTouch: constant(isTouch),\n        isAndroid: os.isAndroid,\n        isiOS: os.isiOS,\n        isWebView: constant(iOSwebview),\n        isDesktop: constant(isDesktop)\n      };\n    };\n\n    const firstMatch = (regexes, s) => {\n      for (let i = 0; i < regexes.length; i++) {\n        const x = regexes[i];\n        if (x.test(s)) {\n          return x;\n        }\n      }\n      return undefined;\n    };\n    const find$1 = (regexes, agent) => {\n      const r = firstMatch(regexes, agent);\n      if (!r) {\n        return {\n          major: 0,\n          minor: 0\n        };\n      }\n      const group = i => {\n        return Number(agent.replace(r, '$' + i));\n      };\n      return nu$3(group(1), group(2));\n    };\n    const detect$5 = (versionRegexes, agent) => {\n      const cleanedAgent = String(agent).toLowerCase();\n      if (versionRegexes.length === 0) {\n        return unknown$2();\n      }\n      return find$1(versionRegexes, cleanedAgent);\n    };\n    const unknown$2 = () => {\n      return nu$3(0, 0);\n    };\n    const nu$3 = (major, minor) => {\n      return {\n        major,\n        minor\n      };\n    };\n    const Version = {\n      nu: nu$3,\n      detect: detect$5,\n      unknown: unknown$2\n    };\n\n    const detectBrowser$1 = (browsers, userAgentData) => {\n      return findMap(userAgentData.brands, uaBrand => {\n        const lcBrand = uaBrand.brand.toLowerCase();\n        return find$2(browsers, browser => {\n          var _a;\n          return lcBrand === ((_a = browser.brand) === null || _a === void 0 ? void 0 : _a.toLowerCase());\n        }).map(info => ({\n          current: info.name,\n          version: Version.nu(parseInt(uaBrand.version, 10), 0)\n        }));\n      });\n    };\n\n    const detect$4 = (candidates, userAgent) => {\n      const agent = String(userAgent).toLowerCase();\n      return find$2(candidates, candidate => {\n        return candidate.search(agent);\n      });\n    };\n    const detectBrowser = (browsers, userAgent) => {\n      return detect$4(browsers, userAgent).map(browser => {\n        const version = Version.detect(browser.versionRegexes, userAgent);\n        return {\n          current: browser.name,\n          version\n        };\n      });\n    };\n    const detectOs = (oses, userAgent) => {\n      return detect$4(oses, userAgent).map(os => {\n        const version = Version.detect(os.versionRegexes, userAgent);\n        return {\n          current: os.name,\n          version\n        };\n      });\n    };\n\n    const removeFromStart = (str, numChars) => {\n      return str.substring(numChars);\n    };\n\n    const checkRange = (str, substr, start) => substr === '' || str.length >= substr.length && str.substr(start, start + substr.length) === substr;\n    const removeLeading = (str, prefix) => {\n      return startsWith(str, prefix) ? removeFromStart(str, prefix.length) : str;\n    };\n    const contains$1 = (str, substr) => {\n      return str.indexOf(substr) !== -1;\n    };\n    const startsWith = (str, prefix) => {\n      return checkRange(str, prefix, 0);\n    };\n    const endsWith = (str, suffix) => {\n      return checkRange(str, suffix, str.length - suffix.length);\n    };\n    const blank = r => s => s.replace(r, '');\n    const trim$3 = blank(/^\\s+|\\s+$/g);\n    const lTrim = blank(/^\\s+/g);\n    const rTrim = blank(/\\s+$/g);\n    const isNotEmpty = s => s.length > 0;\n    const isEmpty$3 = s => !isNotEmpty(s);\n    const repeat = (s, count) => count <= 0 ? '' : new Array(count + 1).join(s);\n    const toInt = (value, radix = 10) => {\n      const num = parseInt(value, radix);\n      return isNaN(num) ? Optional.none() : Optional.some(num);\n    };\n\n    const normalVersionRegex = /.*?version\\/\\ ?([0-9]+)\\.([0-9]+).*/;\n    const checkContains = target => {\n      return uastring => {\n        return contains$1(uastring, target);\n      };\n    };\n    const browsers = [\n      {\n        name: 'Edge',\n        versionRegexes: [/.*?edge\\/ ?([0-9]+)\\.([0-9]+)$/],\n        search: uastring => {\n          return contains$1(uastring, 'edge/') && contains$1(uastring, 'chrome') && contains$1(uastring, 'safari') && contains$1(uastring, 'applewebkit');\n        }\n      },\n      {\n        name: 'Chromium',\n        brand: 'Chromium',\n        versionRegexes: [\n          /.*?chrome\\/([0-9]+)\\.([0-9]+).*/,\n          normalVersionRegex\n        ],\n        search: uastring => {\n          return contains$1(uastring, 'chrome') && !contains$1(uastring, 'chromeframe');\n        }\n      },\n      {\n        name: 'IE',\n        versionRegexes: [\n          /.*?msie\\ ?([0-9]+)\\.([0-9]+).*/,\n          /.*?rv:([0-9]+)\\.([0-9]+).*/\n        ],\n        search: uastring => {\n          return contains$1(uastring, 'msie') || contains$1(uastring, 'trident');\n        }\n      },\n      {\n        name: 'Opera',\n        versionRegexes: [\n          normalVersionRegex,\n          /.*?opera\\/([0-9]+)\\.([0-9]+).*/\n        ],\n        search: checkContains('opera')\n      },\n      {\n        name: 'Firefox',\n        versionRegexes: [/.*?firefox\\/\\ ?([0-9]+)\\.([0-9]+).*/],\n        search: checkContains('firefox')\n      },\n      {\n        name: 'Safari',\n        versionRegexes: [\n          normalVersionRegex,\n          /.*?cpu os ([0-9]+)_([0-9]+).*/\n        ],\n        search: uastring => {\n          return (contains$1(uastring, 'safari') || contains$1(uastring, 'mobile/')) && contains$1(uastring, 'applewebkit');\n        }\n      }\n    ];\n    const oses = [\n      {\n        name: 'Windows',\n        search: checkContains('win'),\n        versionRegexes: [/.*?windows\\ nt\\ ?([0-9]+)\\.([0-9]+).*/]\n      },\n      {\n        name: 'iOS',\n        search: uastring => {\n          return contains$1(uastring, 'iphone') || contains$1(uastring, 'ipad');\n        },\n        versionRegexes: [\n          /.*?version\\/\\ ?([0-9]+)\\.([0-9]+).*/,\n          /.*cpu os ([0-9]+)_([0-9]+).*/,\n          /.*cpu iphone os ([0-9]+)_([0-9]+).*/\n        ]\n      },\n      {\n        name: 'Android',\n        search: checkContains('android'),\n        versionRegexes: [/.*?android\\ ?([0-9]+)\\.([0-9]+).*/]\n      },\n      {\n        name: 'macOS',\n        search: checkContains('mac os x'),\n        versionRegexes: [/.*?mac\\ os\\ x\\ ?([0-9]+)_([0-9]+).*/]\n      },\n      {\n        name: 'Linux',\n        search: checkContains('linux'),\n        versionRegexes: []\n      },\n      {\n        name: 'Solaris',\n        search: checkContains('sunos'),\n        versionRegexes: []\n      },\n      {\n        name: 'FreeBSD',\n        search: checkContains('freebsd'),\n        versionRegexes: []\n      },\n      {\n        name: 'ChromeOS',\n        search: checkContains('cros'),\n        versionRegexes: [/.*?chrome\\/([0-9]+)\\.([0-9]+).*/]\n      }\n    ];\n    const PlatformInfo = {\n      browsers: constant(browsers),\n      oses: constant(oses)\n    };\n\n    const edge = 'Edge';\n    const chromium = 'Chromium';\n    const ie = 'IE';\n    const opera = 'Opera';\n    const firefox = 'Firefox';\n    const safari = 'Safari';\n    const unknown$1 = () => {\n      return nu$2({\n        current: undefined,\n        version: Version.unknown()\n      });\n    };\n    const nu$2 = info => {\n      const current = info.current;\n      const version = info.version;\n      const isBrowser = name => () => current === name;\n      return {\n        current,\n        version,\n        isEdge: isBrowser(edge),\n        isChromium: isBrowser(chromium),\n        isIE: isBrowser(ie),\n        isOpera: isBrowser(opera),\n        isFirefox: isBrowser(firefox),\n        isSafari: isBrowser(safari)\n      };\n    };\n    const Browser = {\n      unknown: unknown$1,\n      nu: nu$2,\n      edge: constant(edge),\n      chromium: constant(chromium),\n      ie: constant(ie),\n      opera: constant(opera),\n      firefox: constant(firefox),\n      safari: constant(safari)\n    };\n\n    const windows = 'Windows';\n    const ios = 'iOS';\n    const android = 'Android';\n    const linux = 'Linux';\n    const macos = 'macOS';\n    const solaris = 'Solaris';\n    const freebsd = 'FreeBSD';\n    const chromeos = 'ChromeOS';\n    const unknown = () => {\n      return nu$1({\n        current: undefined,\n        version: Version.unknown()\n      });\n    };\n    const nu$1 = info => {\n      const current = info.current;\n      const version = info.version;\n      const isOS = name => () => current === name;\n      return {\n        current,\n        version,\n        isWindows: isOS(windows),\n        isiOS: isOS(ios),\n        isAndroid: isOS(android),\n        isMacOS: isOS(macos),\n        isLinux: isOS(linux),\n        isSolaris: isOS(solaris),\n        isFreeBSD: isOS(freebsd),\n        isChromeOS: isOS(chromeos)\n      };\n    };\n    const OperatingSystem = {\n      unknown,\n      nu: nu$1,\n      windows: constant(windows),\n      ios: constant(ios),\n      android: constant(android),\n      linux: constant(linux),\n      macos: constant(macos),\n      solaris: constant(solaris),\n      freebsd: constant(freebsd),\n      chromeos: constant(chromeos)\n    };\n\n    const detect$3 = (userAgent, userAgentDataOpt, mediaMatch) => {\n      const browsers = PlatformInfo.browsers();\n      const oses = PlatformInfo.oses();\n      const browser = userAgentDataOpt.bind(userAgentData => detectBrowser$1(browsers, userAgentData)).orThunk(() => detectBrowser(browsers, userAgent)).fold(Browser.unknown, Browser.nu);\n      const os = detectOs(oses, userAgent).fold(OperatingSystem.unknown, OperatingSystem.nu);\n      const deviceType = DeviceType(os, browser, userAgent, mediaMatch);\n      return {\n        browser,\n        os,\n        deviceType\n      };\n    };\n    const PlatformDetection = { detect: detect$3 };\n\n    const mediaMatch = query => window.matchMedia(query).matches;\n    let platform$2 = cached(() => PlatformDetection.detect(navigator.userAgent, Optional.from(navigator.userAgentData), mediaMatch));\n    const detect$2 = () => platform$2();\n\n    const userAgent = navigator.userAgent;\n    const platform$1 = detect$2();\n    const browser$1 = platform$1.browser;\n    const os = platform$1.os;\n    const deviceType = platform$1.deviceType;\n    const windowsPhone = userAgent.indexOf('Windows Phone') !== -1;\n    const Env = {\n      transparentSrc: 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7',\n      documentMode: browser$1.isIE() ? document.documentMode || 7 : 10,\n      cacheSuffix: null,\n      container: null,\n      canHaveCSP: !browser$1.isIE(),\n      windowsPhone,\n      browser: {\n        current: browser$1.current,\n        version: browser$1.version,\n        isChromium: browser$1.isChromium,\n        isEdge: browser$1.isEdge,\n        isFirefox: browser$1.isFirefox,\n        isIE: browser$1.isIE,\n        isOpera: browser$1.isOpera,\n        isSafari: browser$1.isSafari\n      },\n      os: {\n        current: os.current,\n        version: os.version,\n        isAndroid: os.isAndroid,\n        isChromeOS: os.isChromeOS,\n        isFreeBSD: os.isFreeBSD,\n        isiOS: os.isiOS,\n        isLinux: os.isLinux,\n        isMacOS: os.isMacOS,\n        isSolaris: os.isSolaris,\n        isWindows: os.isWindows\n      },\n      deviceType: {\n        isDesktop: deviceType.isDesktop,\n        isiPad: deviceType.isiPad,\n        isiPhone: deviceType.isiPhone,\n        isPhone: deviceType.isPhone,\n        isTablet: deviceType.isTablet,\n        isTouch: deviceType.isTouch,\n        isWebView: deviceType.isWebView\n      }\n    };\n\n    const whiteSpaceRegExp$1 = /^\\s*|\\s*$/g;\n    const trim$2 = str => {\n      return str === null || str === undefined ? '' : ('' + str).replace(whiteSpaceRegExp$1, '');\n    };\n    const is$3 = (obj, type) => {\n      if (!type) {\n        return obj !== undefined;\n      }\n      if (type === 'array' && isArray(obj)) {\n        return true;\n      }\n      return typeof obj === type;\n    };\n    const makeMap$4 = (items, delim, map) => {\n      let i;\n      items = items || [];\n      delim = delim || ',';\n      if (typeof items === 'string') {\n        items = items.split(delim);\n      }\n      map = map || {};\n      i = items.length;\n      while (i--) {\n        map[items[i]] = {};\n      }\n      return map;\n    };\n    const hasOwnProperty$1 = has$2;\n    const extend$3 = (obj, ...exts) => {\n      for (let i = 0; i < exts.length; i++) {\n        const ext = exts[i];\n        for (const name in ext) {\n          if (has$2(ext, name)) {\n            const value = ext[name];\n            if (value !== undefined) {\n              obj[name] = value;\n            }\n          }\n        }\n      }\n      return obj;\n    };\n    const walk$4 = function (o, f, n, s) {\n      s = s || this;\n      if (o) {\n        if (n) {\n          o = o[n];\n        }\n        each$e(o, (o, i) => {\n          if (f.call(s, o, i, n) === false) {\n            return false;\n          }\n          walk$4(o, f, n, s);\n        });\n      }\n    };\n    const resolve$2 = (n, o) => {\n      let i, l;\n      o = o || window;\n      n = n.split('.');\n      for (i = 0, l = n.length; i < l; i++) {\n        o = o[n[i]];\n        if (!o) {\n          break;\n        }\n      }\n      return o;\n    };\n    const explode$3 = (s, d) => {\n      if (!s || is$3(s, 'array')) {\n        return s;\n      }\n      return map$1(s.split(d || ','), trim$2);\n    };\n    const _addCacheSuffix = url => {\n      const cacheSuffix = Env.cacheSuffix;\n      if (cacheSuffix) {\n        url += (url.indexOf('?') === -1 ? '?' : '&') + cacheSuffix;\n      }\n      return url;\n    };\n    const Tools = {\n      trim: trim$2,\n      isArray: isArray,\n      is: is$3,\n      toArray: toArray$1,\n      makeMap: makeMap$4,\n      each: each$e,\n      map: map$1,\n      grep: filter$4,\n      inArray: indexOf,\n      hasOwn: hasOwnProperty$1,\n      extend: extend$3,\n      walk: walk$4,\n      resolve: resolve$2,\n      explode: explode$3,\n      _addCacheSuffix\n    };\n\n    const is$2 = (lhs, rhs, comparator = tripleEquals) => lhs.exists(left => comparator(left, rhs));\n    const cat = arr => {\n      const r = [];\n      const push = x => {\n        r.push(x);\n      };\n      for (let i = 0; i < arr.length; i++) {\n        arr[i].each(push);\n      }\n      return r;\n    };\n    const lift2 = (oa, ob, f) => oa.isSome() && ob.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie())) : Optional.none();\n    const lift3 = (oa, ob, oc, f) => oa.isSome() && ob.isSome() && oc.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie(), oc.getOrDie())) : Optional.none();\n    const someIf = (b, a) => b ? Optional.some(a) : Optional.none();\n\n    typeof window !== 'undefined' ? window : Function('return this;')();\n\n    const COMMENT = 8;\n    const DOCUMENT = 9;\n    const DOCUMENT_FRAGMENT = 11;\n    const ELEMENT = 1;\n    const TEXT = 3;\n\n    const name = element => {\n      const r = element.dom.nodeName;\n      return r.toLowerCase();\n    };\n    const type$1 = element => element.dom.nodeType;\n    const isType = t => element => type$1(element) === t;\n    const isComment$1 = element => type$1(element) === COMMENT || name(element) === '#comment';\n    const isElement$7 = isType(ELEMENT);\n    const isText$9 = isType(TEXT);\n    const isDocument$2 = isType(DOCUMENT);\n    const isDocumentFragment$1 = isType(DOCUMENT_FRAGMENT);\n    const isTag = tag => e => isElement$7(e) && name(e) === tag;\n\n    const rawSet = (dom, key, value) => {\n      if (isString(value) || isBoolean(value) || isNumber(value)) {\n        dom.setAttribute(key, value + '');\n      } else {\n        console.error('Invalid call to Attribute.set. Key ', key, ':: Value ', value, ':: Element ', dom);\n        throw new Error('Attribute value was not simple');\n      }\n    };\n    const set$2 = (element, key, value) => {\n      rawSet(element.dom, key, value);\n    };\n    const setAll$1 = (element, attrs) => {\n      const dom = element.dom;\n      each$f(attrs, (v, k) => {\n        rawSet(dom, k, v);\n      });\n    };\n    const get$9 = (element, key) => {\n      const v = element.dom.getAttribute(key);\n      return v === null ? undefined : v;\n    };\n    const getOpt = (element, key) => Optional.from(get$9(element, key));\n    const has$1 = (element, key) => {\n      const dom = element.dom;\n      return dom && dom.hasAttribute ? dom.hasAttribute(key) : false;\n    };\n    const remove$a = (element, key) => {\n      element.dom.removeAttribute(key);\n    };\n    const hasNone = element => {\n      const attrs = element.dom.attributes;\n      return attrs === undefined || attrs === null || attrs.length === 0;\n    };\n    const clone$4 = element => foldl(element.dom.attributes, (acc, attr) => {\n      acc[attr.name] = attr.value;\n      return acc;\n    }, {});\n\n    const read$4 = (element, attr) => {\n      const value = get$9(element, attr);\n      return value === undefined || value === '' ? [] : value.split(' ');\n    };\n    const add$4 = (element, attr, id) => {\n      const old = read$4(element, attr);\n      const nu = old.concat([id]);\n      set$2(element, attr, nu.join(' '));\n      return true;\n    };\n    const remove$9 = (element, attr, id) => {\n      const nu = filter$6(read$4(element, attr), v => v !== id);\n      if (nu.length > 0) {\n        set$2(element, attr, nu.join(' '));\n      } else {\n        remove$a(element, attr);\n      }\n      return false;\n    };\n\n    const supports = element => element.dom.classList !== undefined;\n    const get$8 = element => read$4(element, 'class');\n    const add$3 = (element, clazz) => add$4(element, 'class', clazz);\n    const remove$8 = (element, clazz) => remove$9(element, 'class', clazz);\n    const toggle$2 = (element, clazz) => {\n      if (contains$2(get$8(element), clazz)) {\n        return remove$8(element, clazz);\n      } else {\n        return add$3(element, clazz);\n      }\n    };\n\n    const add$2 = (element, clazz) => {\n      if (supports(element)) {\n        element.dom.classList.add(clazz);\n      } else {\n        add$3(element, clazz);\n      }\n    };\n    const cleanClass = element => {\n      const classList = supports(element) ? element.dom.classList : get$8(element);\n      if (classList.length === 0) {\n        remove$a(element, 'class');\n      }\n    };\n    const remove$7 = (element, clazz) => {\n      if (supports(element)) {\n        const classList = element.dom.classList;\n        classList.remove(clazz);\n      } else {\n        remove$8(element, clazz);\n      }\n      cleanClass(element);\n    };\n    const toggle$1 = (element, clazz) => {\n      const result = supports(element) ? element.dom.classList.toggle(clazz) : toggle$2(element, clazz);\n      cleanClass(element);\n      return result;\n    };\n    const has = (element, clazz) => supports(element) && element.dom.classList.contains(clazz);\n\n    const isSupported$1 = dom => dom.style !== undefined && isFunction(dom.style.getPropertyValue);\n\n    const fromHtml$1 = (html, scope) => {\n      const doc = scope || document;\n      const div = doc.createElement('div');\n      div.innerHTML = html;\n      if (!div.hasChildNodes() || div.childNodes.length > 1) {\n        const message = 'HTML does not have a single root node';\n        console.error(message, html);\n        throw new Error(message);\n      }\n      return fromDom$2(div.childNodes[0]);\n    };\n    const fromTag = (tag, scope) => {\n      const doc = scope || document;\n      const node = doc.createElement(tag);\n      return fromDom$2(node);\n    };\n    const fromText = (text, scope) => {\n      const doc = scope || document;\n      const node = doc.createTextNode(text);\n      return fromDom$2(node);\n    };\n    const fromDom$2 = node => {\n      if (node === null || node === undefined) {\n        throw new Error('Node cannot be null or undefined');\n      }\n      return { dom: node };\n    };\n    const fromPoint$2 = (docElm, x, y) => Optional.from(docElm.dom.elementFromPoint(x, y)).map(fromDom$2);\n    const SugarElement = {\n      fromHtml: fromHtml$1,\n      fromTag,\n      fromText,\n      fromDom: fromDom$2,\n      fromPoint: fromPoint$2\n    };\n\n    const toArray = (target, f) => {\n      const r = [];\n      const recurse = e => {\n        r.push(e);\n        return f(e);\n      };\n      let cur = f(target);\n      do {\n        cur = cur.bind(recurse);\n      } while (cur.isSome());\n      return r;\n    };\n\n    const is$1 = (element, selector) => {\n      const dom = element.dom;\n      if (dom.nodeType !== ELEMENT) {\n        return false;\n      } else {\n        const elem = dom;\n        if (elem.matches !== undefined) {\n          return elem.matches(selector);\n        } else if (elem.msMatchesSelector !== undefined) {\n          return elem.msMatchesSelector(selector);\n        } else if (elem.webkitMatchesSelector !== undefined) {\n          return elem.webkitMatchesSelector(selector);\n        } else if (elem.mozMatchesSelector !== undefined) {\n          return elem.mozMatchesSelector(selector);\n        } else {\n          throw new Error('Browser lacks native selectors');\n        }\n      }\n    };\n    const bypassSelector = dom => dom.nodeType !== ELEMENT && dom.nodeType !== DOCUMENT && dom.nodeType !== DOCUMENT_FRAGMENT || dom.childElementCount === 0;\n    const all = (selector, scope) => {\n      const base = scope === undefined ? document : scope.dom;\n      return bypassSelector(base) ? [] : map$3(base.querySelectorAll(selector), SugarElement.fromDom);\n    };\n    const one = (selector, scope) => {\n      const base = scope === undefined ? document : scope.dom;\n      return bypassSelector(base) ? Optional.none() : Optional.from(base.querySelector(selector)).map(SugarElement.fromDom);\n    };\n\n    const eq = (e1, e2) => e1.dom === e2.dom;\n    const contains = (e1, e2) => {\n      const d1 = e1.dom;\n      const d2 = e2.dom;\n      return d1 === d2 ? false : d1.contains(d2);\n    };\n\n    const owner$1 = element => SugarElement.fromDom(element.dom.ownerDocument);\n    const documentOrOwner = dos => isDocument$2(dos) ? dos : owner$1(dos);\n    const documentElement = element => SugarElement.fromDom(documentOrOwner(element).dom.documentElement);\n    const defaultView = element => SugarElement.fromDom(documentOrOwner(element).dom.defaultView);\n    const parent = element => Optional.from(element.dom.parentNode).map(SugarElement.fromDom);\n    const parentElement = element => Optional.from(element.dom.parentElement).map(SugarElement.fromDom);\n    const parents$1 = (element, isRoot) => {\n      const stop = isFunction(isRoot) ? isRoot : never;\n      let dom = element.dom;\n      const ret = [];\n      while (dom.parentNode !== null && dom.parentNode !== undefined) {\n        const rawParent = dom.parentNode;\n        const p = SugarElement.fromDom(rawParent);\n        ret.push(p);\n        if (stop(p) === true) {\n          break;\n        } else {\n          dom = rawParent;\n        }\n      }\n      return ret;\n    };\n    const siblings = element => {\n      const filterSelf = elements => filter$6(elements, x => !eq(element, x));\n      return parent(element).map(children).map(filterSelf).getOr([]);\n    };\n    const prevSibling = element => Optional.from(element.dom.previousSibling).map(SugarElement.fromDom);\n    const nextSibling = element => Optional.from(element.dom.nextSibling).map(SugarElement.fromDom);\n    const prevSiblings = element => reverse(toArray(element, prevSibling));\n    const nextSiblings = element => toArray(element, nextSibling);\n    const children = element => map$3(element.dom.childNodes, SugarElement.fromDom);\n    const child$1 = (element, index) => {\n      const cs = element.dom.childNodes;\n      return Optional.from(cs[index]).map(SugarElement.fromDom);\n    };\n    const firstChild = element => child$1(element, 0);\n    const lastChild = element => child$1(element, element.dom.childNodes.length - 1);\n    const childNodesCount = element => element.dom.childNodes.length;\n\n    const getHead = doc => {\n      const b = doc.dom.head;\n      if (b === null || b === undefined) {\n        throw new Error('Head is not available yet');\n      }\n      return SugarElement.fromDom(b);\n    };\n\n    const isShadowRoot = dos => isDocumentFragment$1(dos) && isNonNullable(dos.dom.host);\n    const supported = isFunction(Element.prototype.attachShadow) && isFunction(Node.prototype.getRootNode);\n    const isSupported = constant(supported);\n    const getRootNode = supported ? e => SugarElement.fromDom(e.dom.getRootNode()) : documentOrOwner;\n    const getStyleContainer = dos => isShadowRoot(dos) ? dos : getHead(documentOrOwner(dos));\n    const getShadowRoot = e => {\n      const r = getRootNode(e);\n      return isShadowRoot(r) ? Optional.some(r) : Optional.none();\n    };\n    const getShadowHost = e => SugarElement.fromDom(e.dom.host);\n    const getOriginalEventTarget = event => {\n      if (isSupported() && isNonNullable(event.target)) {\n        const el = SugarElement.fromDom(event.target);\n        if (isElement$7(el) && isOpenShadowHost(el)) {\n          if (event.composed && event.composedPath) {\n            const composedPath = event.composedPath();\n            if (composedPath) {\n              return head(composedPath);\n            }\n          }\n        }\n      }\n      return Optional.from(event.target);\n    };\n    const isOpenShadowHost = element => isNonNullable(element.dom.shadowRoot);\n\n    const inBody = element => {\n      const dom = isText$9(element) ? element.dom.parentNode : element.dom;\n      if (dom === undefined || dom === null || dom.ownerDocument === null) {\n        return false;\n      }\n      const doc = dom.ownerDocument;\n      return getShadowRoot(SugarElement.fromDom(dom)).fold(() => doc.body.contains(dom), compose1(inBody, getShadowHost));\n    };\n\n    const internalSet = (dom, property, value) => {\n      if (!isString(value)) {\n        console.error('Invalid call to CSS.set. Property ', property, ':: Value ', value, ':: Element ', dom);\n        throw new Error('CSS value must be a string: ' + value);\n      }\n      if (isSupported$1(dom)) {\n        dom.style.setProperty(property, value);\n      }\n    };\n    const internalRemove = (dom, property) => {\n      if (isSupported$1(dom)) {\n        dom.style.removeProperty(property);\n      }\n    };\n    const set$1 = (element, property, value) => {\n      const dom = element.dom;\n      internalSet(dom, property, value);\n    };\n    const setAll = (element, css) => {\n      const dom = element.dom;\n      each$f(css, (v, k) => {\n        internalSet(dom, k, v);\n      });\n    };\n    const get$7 = (element, property) => {\n      const dom = element.dom;\n      const styles = window.getComputedStyle(dom);\n      const r = styles.getPropertyValue(property);\n      return r === '' && !inBody(element) ? getUnsafeProperty(dom, property) : r;\n    };\n    const getUnsafeProperty = (dom, property) => isSupported$1(dom) ? dom.style.getPropertyValue(property) : '';\n    const getRaw$1 = (element, property) => {\n      const dom = element.dom;\n      const raw = getUnsafeProperty(dom, property);\n      return Optional.from(raw).filter(r => r.length > 0);\n    };\n    const getAllRaw = element => {\n      const css = {};\n      const dom = element.dom;\n      if (isSupported$1(dom)) {\n        for (let i = 0; i < dom.style.length; i++) {\n          const ruleName = dom.style.item(i);\n          css[ruleName] = dom.style[ruleName];\n        }\n      }\n      return css;\n    };\n    const remove$6 = (element, property) => {\n      const dom = element.dom;\n      internalRemove(dom, property);\n      if (is$2(getOpt(element, 'style').map(trim$3), '')) {\n        remove$a(element, 'style');\n      }\n    };\n    const reflow = e => e.dom.offsetWidth;\n\n    const before$3 = (marker, element) => {\n      const parent$1 = parent(marker);\n      parent$1.each(v => {\n        v.dom.insertBefore(element.dom, marker.dom);\n      });\n    };\n    const after$4 = (marker, element) => {\n      const sibling = nextSibling(marker);\n      sibling.fold(() => {\n        const parent$1 = parent(marker);\n        parent$1.each(v => {\n          append$1(v, element);\n        });\n      }, v => {\n        before$3(v, element);\n      });\n    };\n    const prepend = (parent, element) => {\n      const firstChild$1 = firstChild(parent);\n      firstChild$1.fold(() => {\n        append$1(parent, element);\n      }, v => {\n        parent.dom.insertBefore(element.dom, v.dom);\n      });\n    };\n    const append$1 = (parent, element) => {\n      parent.dom.appendChild(element.dom);\n    };\n    const wrap$2 = (element, wrapper) => {\n      before$3(element, wrapper);\n      append$1(wrapper, element);\n    };\n\n    const after$3 = (marker, elements) => {\n      each$g(elements, (x, i) => {\n        const e = i === 0 ? marker : elements[i - 1];\n        after$4(e, x);\n      });\n    };\n    const append = (parent, elements) => {\n      each$g(elements, x => {\n        append$1(parent, x);\n      });\n    };\n\n    const empty = element => {\n      element.dom.textContent = '';\n      each$g(children(element), rogue => {\n        remove$5(rogue);\n      });\n    };\n    const remove$5 = element => {\n      const dom = element.dom;\n      if (dom.parentNode !== null) {\n        dom.parentNode.removeChild(dom);\n      }\n    };\n    const unwrap = wrapper => {\n      const children$1 = children(wrapper);\n      if (children$1.length > 0) {\n        after$3(wrapper, children$1);\n      }\n      remove$5(wrapper);\n    };\n\n    const fromHtml = (html, scope) => {\n      const doc = scope || document;\n      const div = doc.createElement('div');\n      div.innerHTML = html;\n      return children(SugarElement.fromDom(div));\n    };\n    const fromDom$1 = nodes => map$3(nodes, SugarElement.fromDom);\n\n    const get$6 = element => element.dom.innerHTML;\n    const set = (element, content) => {\n      const owner = owner$1(element);\n      const docDom = owner.dom;\n      const fragment = SugarElement.fromDom(docDom.createDocumentFragment());\n      const contentElements = fromHtml(content, docDom);\n      append(fragment, contentElements);\n      empty(element);\n      append$1(element, fragment);\n    };\n    const getOuter = element => {\n      const container = SugarElement.fromTag('div');\n      const clone = SugarElement.fromDom(element.dom.cloneNode(true));\n      append$1(container, clone);\n      return get$6(container);\n    };\n\n    const mkEvent = (target, x, y, stop, prevent, kill, raw) => ({\n      target,\n      x,\n      y,\n      stop,\n      prevent,\n      kill,\n      raw\n    });\n    const fromRawEvent = rawEvent => {\n      const target = SugarElement.fromDom(getOriginalEventTarget(rawEvent).getOr(rawEvent.target));\n      const stop = () => rawEvent.stopPropagation();\n      const prevent = () => rawEvent.preventDefault();\n      const kill = compose(prevent, stop);\n      return mkEvent(target, rawEvent.clientX, rawEvent.clientY, stop, prevent, kill, rawEvent);\n    };\n    const handle$1 = (filter, handler) => rawEvent => {\n      if (filter(rawEvent)) {\n        handler(fromRawEvent(rawEvent));\n      }\n    };\n    const binder = (element, event, filter, handler, useCapture) => {\n      const wrapped = handle$1(filter, handler);\n      element.dom.addEventListener(event, wrapped, useCapture);\n      return { unbind: curry(unbind, element, event, wrapped, useCapture) };\n    };\n    const bind$2 = (element, event, filter, handler) => binder(element, event, filter, handler, false);\n    const unbind = (element, event, handler, useCapture) => {\n      element.dom.removeEventListener(event, handler, useCapture);\n    };\n\n    const r = (left, top) => {\n      const translate = (x, y) => r(left + x, top + y);\n      return {\n        left,\n        top,\n        translate\n      };\n    };\n    const SugarPosition = r;\n\n    const boxPosition = dom => {\n      const box = dom.getBoundingClientRect();\n      return SugarPosition(box.left, box.top);\n    };\n    const firstDefinedOrZero = (a, b) => {\n      if (a !== undefined) {\n        return a;\n      } else {\n        return b !== undefined ? b : 0;\n      }\n    };\n    const absolute = element => {\n      const doc = element.dom.ownerDocument;\n      const body = doc.body;\n      const win = doc.defaultView;\n      const html = doc.documentElement;\n      if (body === element.dom) {\n        return SugarPosition(body.offsetLeft, body.offsetTop);\n      }\n      const scrollTop = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageYOffset, html.scrollTop);\n      const scrollLeft = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageXOffset, html.scrollLeft);\n      const clientTop = firstDefinedOrZero(html.clientTop, body.clientTop);\n      const clientLeft = firstDefinedOrZero(html.clientLeft, body.clientLeft);\n      return viewport(element).translate(scrollLeft - clientLeft, scrollTop - clientTop);\n    };\n    const viewport = element => {\n      const dom = element.dom;\n      const doc = dom.ownerDocument;\n      const body = doc.body;\n      if (body === dom) {\n        return SugarPosition(body.offsetLeft, body.offsetTop);\n      }\n      if (!inBody(element)) {\n        return SugarPosition(0, 0);\n      }\n      return boxPosition(dom);\n    };\n\n    const get$5 = _DOC => {\n      const doc = _DOC !== undefined ? _DOC.dom : document;\n      const x = doc.body.scrollLeft || doc.documentElement.scrollLeft;\n      const y = doc.body.scrollTop || doc.documentElement.scrollTop;\n      return SugarPosition(x, y);\n    };\n    const to = (x, y, _DOC) => {\n      const doc = _DOC !== undefined ? _DOC.dom : document;\n      const win = doc.defaultView;\n      if (win) {\n        win.scrollTo(x, y);\n      }\n    };\n    const intoView = (element, alignToTop) => {\n      const isSafari = detect$2().browser.isSafari();\n      if (isSafari && isFunction(element.dom.scrollIntoViewIfNeeded)) {\n        element.dom.scrollIntoViewIfNeeded(false);\n      } else {\n        element.dom.scrollIntoView(alignToTop);\n      }\n    };\n\n    const get$4 = _win => {\n      const win = _win === undefined ? window : _win;\n      if (detect$2().browser.isFirefox()) {\n        return Optional.none();\n      } else {\n        return Optional.from(win.visualViewport);\n      }\n    };\n    const bounds = (x, y, width, height) => ({\n      x,\n      y,\n      width,\n      height,\n      right: x + width,\n      bottom: y + height\n    });\n    const getBounds = _win => {\n      const win = _win === undefined ? window : _win;\n      const doc = win.document;\n      const scroll = get$5(SugarElement.fromDom(doc));\n      return get$4(win).fold(() => {\n        const html = win.document.documentElement;\n        const width = html.clientWidth;\n        const height = html.clientHeight;\n        return bounds(scroll.left, scroll.top, width, height);\n      }, visualViewport => bounds(Math.max(visualViewport.pageLeft, scroll.left), Math.max(visualViewport.pageTop, scroll.top), visualViewport.width, visualViewport.height));\n    };\n\n    const isNodeType = type => {\n      return node => {\n        return !!node && node.nodeType === type;\n      };\n    };\n    const isRestrictedNode = node => !!node && !Object.getPrototypeOf(node);\n    const isElement$6 = isNodeType(1);\n    const matchNodeNames = names => {\n      const lowercasedNames = names.map(s => s.toLowerCase());\n      return node => {\n        if (node && node.nodeName) {\n          const nodeName = node.nodeName.toLowerCase();\n          return contains$2(lowercasedNames, nodeName);\n        }\n        return false;\n      };\n    };\n    const matchStyleValues = (name, values) => {\n      const items = values.toLowerCase().split(' ');\n      return node => {\n        if (isElement$6(node)) {\n          for (let i = 0; i < items.length; i++) {\n            const computed = node.ownerDocument.defaultView.getComputedStyle(node, null);\n            const cssValue = computed ? computed.getPropertyValue(name) : null;\n            if (cssValue === items[i]) {\n              return true;\n            }\n          }\n        }\n        return false;\n      };\n    };\n    const hasAttribute = attrName => {\n      return node => {\n        return isElement$6(node) && node.hasAttribute(attrName);\n      };\n    };\n    const hasAttributeValue = (attrName, attrValue) => {\n      return node => {\n        return isElement$6(node) && node.getAttribute(attrName) === attrValue;\n      };\n    };\n    const isBogus$2 = node => isElement$6(node) && node.hasAttribute('data-mce-bogus');\n    const isBogusAll$1 = node => isElement$6(node) && node.getAttribute('data-mce-bogus') === 'all';\n    const isTable$3 = node => isElement$6(node) && node.tagName === 'TABLE';\n    const hasContentEditableState = value => {\n      return node => {\n        if (isElement$6(node)) {\n          if (node.contentEditable === value) {\n            return true;\n          }\n          if (node.getAttribute('data-mce-contenteditable') === value) {\n            return true;\n          }\n        }\n        return false;\n      };\n    };\n    const isTextareaOrInput = matchNodeNames([\n      'textarea',\n      'input'\n    ]);\n    const isText$8 = isNodeType(3);\n    const isCData = isNodeType(4);\n    const isPi = isNodeType(7);\n    const isComment = isNodeType(8);\n    const isDocument$1 = isNodeType(9);\n    const isDocumentFragment = isNodeType(11);\n    const isBr$5 = matchNodeNames(['br']);\n    const isImg = matchNodeNames(['img']);\n    const isContentEditableTrue$4 = hasContentEditableState('true');\n    const isContentEditableFalse$a = hasContentEditableState('false');\n    const isTableCell$5 = matchNodeNames([\n      'td',\n      'th'\n    ]);\n    const isMedia$2 = matchNodeNames([\n      'video',\n      'audio',\n      'object',\n      'embed'\n    ]);\n\n    const browser = detect$2().browser;\n    const firstElement = nodes => find$2(nodes, isElement$7);\n    const getTableCaptionDeltaY = elm => {\n      if (browser.isFirefox() && name(elm) === 'table') {\n        return firstElement(children(elm)).filter(elm => {\n          return name(elm) === 'caption';\n        }).bind(caption => {\n          return firstElement(nextSiblings(caption)).map(body => {\n            const bodyTop = body.dom.offsetTop;\n            const captionTop = caption.dom.offsetTop;\n            const captionHeight = caption.dom.offsetHeight;\n            return bodyTop <= captionTop ? -captionHeight : 0;\n          });\n        }).getOr(0);\n      } else {\n        return 0;\n      }\n    };\n    const hasChild = (elm, child) => elm.children && contains$2(elm.children, child);\n    const getPos = (body, elm, rootElm) => {\n      let x = 0, y = 0;\n      const doc = body.ownerDocument;\n      rootElm = rootElm ? rootElm : body;\n      if (elm) {\n        if (rootElm === body && elm.getBoundingClientRect && get$7(SugarElement.fromDom(body), 'position') === 'static') {\n          const pos = elm.getBoundingClientRect();\n          x = pos.left + (doc.documentElement.scrollLeft || body.scrollLeft) - doc.documentElement.clientLeft;\n          y = pos.top + (doc.documentElement.scrollTop || body.scrollTop) - doc.documentElement.clientTop;\n          return {\n            x,\n            y\n          };\n        }\n        let offsetParent = elm;\n        while (offsetParent && offsetParent !== rootElm && offsetParent.nodeType && !hasChild(offsetParent, rootElm)) {\n          const castOffsetParent = offsetParent;\n          x += castOffsetParent.offsetLeft || 0;\n          y += castOffsetParent.offsetTop || 0;\n          offsetParent = castOffsetParent.offsetParent;\n        }\n        offsetParent = elm.parentNode;\n        while (offsetParent && offsetParent !== rootElm && offsetParent.nodeType && !hasChild(offsetParent, rootElm)) {\n          x -= offsetParent.scrollLeft || 0;\n          y -= offsetParent.scrollTop || 0;\n          offsetParent = offsetParent.parentNode;\n        }\n        y += getTableCaptionDeltaY(SugarElement.fromDom(elm));\n      }\n      return {\n        x,\n        y\n      };\n    };\n\n    var ClosestOrAncestor = (is, ancestor, scope, a, isRoot) => {\n      if (is(scope, a)) {\n        return Optional.some(scope);\n      } else if (isFunction(isRoot) && isRoot(scope)) {\n        return Optional.none();\n      } else {\n        return ancestor(scope, a, isRoot);\n      }\n    };\n\n    const ancestor$3 = (scope, predicate, isRoot) => {\n      let element = scope.dom;\n      const stop = isFunction(isRoot) ? isRoot : never;\n      while (element.parentNode) {\n        element = element.parentNode;\n        const el = SugarElement.fromDom(element);\n        if (predicate(el)) {\n          return Optional.some(el);\n        } else if (stop(el)) {\n          break;\n        }\n      }\n      return Optional.none();\n    };\n    const closest$4 = (scope, predicate, isRoot) => {\n      const is = (s, test) => test(s);\n      return ClosestOrAncestor(is, ancestor$3, scope, predicate, isRoot);\n    };\n    const sibling$1 = (scope, predicate) => {\n      const element = scope.dom;\n      if (!element.parentNode) {\n        return Optional.none();\n      }\n      return child(SugarElement.fromDom(element.parentNode), x => !eq(scope, x) && predicate(x));\n    };\n    const child = (scope, predicate) => {\n      const pred = node => predicate(SugarElement.fromDom(node));\n      const result = find$2(scope.dom.childNodes, pred);\n      return result.map(SugarElement.fromDom);\n    };\n    const descendant$1 = (scope, predicate) => {\n      const descend = node => {\n        for (let i = 0; i < node.childNodes.length; i++) {\n          const child = SugarElement.fromDom(node.childNodes[i]);\n          if (predicate(child)) {\n            return Optional.some(child);\n          }\n          const res = descend(node.childNodes[i]);\n          if (res.isSome()) {\n            return res;\n          }\n        }\n        return Optional.none();\n      };\n      return descend(scope.dom);\n    };\n\n    const ancestor$2 = (scope, selector, isRoot) => ancestor$3(scope, e => is$1(e, selector), isRoot);\n    const descendant = (scope, selector) => one(selector, scope);\n    const closest$3 = (scope, selector, isRoot) => {\n      const is = (element, selector) => is$1(element, selector);\n      return ClosestOrAncestor(is, ancestor$2, scope, selector, isRoot);\n    };\n\n    const StyleSheetLoader = (documentOrShadowRoot, settings = {}) => {\n      let idCount = 0;\n      const loadedStates = {};\n      const edos = SugarElement.fromDom(documentOrShadowRoot);\n      const doc = documentOrOwner(edos);\n      const maxLoadTime = settings.maxLoadTime || 5000;\n      const _setReferrerPolicy = referrerPolicy => {\n        settings.referrerPolicy = referrerPolicy;\n      };\n      const addStyle = element => {\n        append$1(getStyleContainer(edos), element);\n      };\n      const removeStyle = id => {\n        const styleContainer = getStyleContainer(edos);\n        descendant(styleContainer, '#' + id).each(remove$5);\n      };\n      const getOrCreateState = url => get$a(loadedStates, url).getOrThunk(() => ({\n        id: 'mce-u' + idCount++,\n        passed: [],\n        failed: [],\n        count: 0\n      }));\n      const load = url => new Promise((success, failure) => {\n        let link;\n        const urlWithSuffix = Tools._addCacheSuffix(url);\n        const state = getOrCreateState(urlWithSuffix);\n        loadedStates[urlWithSuffix] = state;\n        state.count++;\n        const resolve = (callbacks, status) => {\n          each$g(callbacks, call);\n          state.status = status;\n          state.passed = [];\n          state.failed = [];\n          if (link) {\n            link.onload = null;\n            link.onerror = null;\n            link = null;\n          }\n        };\n        const passed = () => resolve(state.passed, 2);\n        const failed = () => resolve(state.failed, 3);\n        const wait = (testCallback, waitCallback) => {\n          if (!testCallback()) {\n            if (Date.now() - startTime < maxLoadTime) {\n              setTimeout(waitCallback);\n            } else {\n              failed();\n            }\n          }\n        };\n        const waitForWebKitLinkLoaded = () => {\n          wait(() => {\n            const styleSheets = documentOrShadowRoot.styleSheets;\n            let i = styleSheets.length;\n            while (i--) {\n              const styleSheet = styleSheets[i];\n              const owner = styleSheet.ownerNode;\n              if (owner && owner.id === link.id) {\n                passed();\n                return true;\n              }\n            }\n            return false;\n          }, waitForWebKitLinkLoaded);\n        };\n        if (success) {\n          state.passed.push(success);\n        }\n        if (failure) {\n          state.failed.push(failure);\n        }\n        if (state.status === 1) {\n          return;\n        }\n        if (state.status === 2) {\n          passed();\n          return;\n        }\n        if (state.status === 3) {\n          failed();\n          return;\n        }\n        state.status = 1;\n        const linkElem = SugarElement.fromTag('link', doc.dom);\n        setAll$1(linkElem, {\n          rel: 'stylesheet',\n          type: 'text/css',\n          id: state.id\n        });\n        const startTime = Date.now();\n        if (settings.contentCssCors) {\n          set$2(linkElem, 'crossOrigin', 'anonymous');\n        }\n        if (settings.referrerPolicy) {\n          set$2(linkElem, 'referrerpolicy', settings.referrerPolicy);\n        }\n        link = linkElem.dom;\n        link.onload = waitForWebKitLinkLoaded;\n        link.onerror = failed;\n        addStyle(linkElem);\n        set$2(linkElem, 'href', urlWithSuffix);\n      });\n      const loadAll = urls => {\n        const loadedUrls = Promise.allSettled(map$3(urls, url => load(url).then(constant(url))));\n        return loadedUrls.then(results => {\n          const parts = partition$2(results, r => r.status === 'fulfilled');\n          if (parts.fail.length > 0) {\n            return Promise.reject(map$3(parts.fail, result => result.reason));\n          } else {\n            return map$3(parts.pass, result => result.value);\n          }\n        });\n      };\n      const unload = url => {\n        const urlWithSuffix = Tools._addCacheSuffix(url);\n        get$a(loadedStates, urlWithSuffix).each(state => {\n          const count = --state.count;\n          if (count === 0) {\n            delete loadedStates[urlWithSuffix];\n            removeStyle(state.id);\n          }\n        });\n      };\n      const unloadAll = urls => {\n        each$g(urls, url => {\n          unload(url);\n        });\n      };\n      return {\n        load,\n        loadAll,\n        unload,\n        unloadAll,\n        _setReferrerPolicy\n      };\n    };\n\n    const create$c = () => {\n      const map = new WeakMap();\n      const forElement = (referenceElement, settings) => {\n        const root = getRootNode(referenceElement);\n        const rootDom = root.dom;\n        return Optional.from(map.get(rootDom)).getOrThunk(() => {\n          const sl = StyleSheetLoader(rootDom, settings);\n          map.set(rootDom, sl);\n          return sl;\n        });\n      };\n      return { forElement };\n    };\n    const instance = create$c();\n\n    class DomTreeWalker {\n      constructor(startNode, rootNode) {\n        this.node = startNode;\n        this.rootNode = rootNode;\n        this.current = this.current.bind(this);\n        this.next = this.next.bind(this);\n        this.prev = this.prev.bind(this);\n        this.prev2 = this.prev2.bind(this);\n      }\n      current() {\n        return this.node;\n      }\n      next(shallow) {\n        this.node = this.findSibling(this.node, 'firstChild', 'nextSibling', shallow);\n        return this.node;\n      }\n      prev(shallow) {\n        this.node = this.findSibling(this.node, 'lastChild', 'previousSibling', shallow);\n        return this.node;\n      }\n      prev2(shallow) {\n        this.node = this.findPreviousNode(this.node, 'lastChild', 'previousSibling', shallow);\n        return this.node;\n      }\n      findSibling(node, startName, siblingName, shallow) {\n        let sibling, parent;\n        if (node) {\n          if (!shallow && node[startName]) {\n            return node[startName];\n          }\n          if (node !== this.rootNode) {\n            sibling = node[siblingName];\n            if (sibling) {\n              return sibling;\n            }\n            for (parent = node.parentNode; parent && parent !== this.rootNode; parent = parent.parentNode) {\n              sibling = parent[siblingName];\n              if (sibling) {\n                return sibling;\n              }\n            }\n          }\n        }\n      }\n      findPreviousNode(node, startName, siblingName, shallow) {\n        let sibling, parent, child;\n        if (node) {\n          sibling = node[siblingName];\n          if (this.rootNode && sibling === this.rootNode) {\n            return;\n          }\n          if (sibling) {\n            if (!shallow) {\n              for (child = sibling[startName]; child; child = child[startName]) {\n                if (!child[startName]) {\n                  return child;\n                }\n              }\n            }\n            return sibling;\n          }\n          parent = node.parentNode;\n          if (parent && parent !== this.rootNode) {\n            return parent;\n          }\n        }\n      }\n    }\n\n    const blocks = [\n      'article',\n      'aside',\n      'details',\n      'div',\n      'dt',\n      'figcaption',\n      'footer',\n      'form',\n      'fieldset',\n      'header',\n      'hgroup',\n      'html',\n      'main',\n      'nav',\n      'section',\n      'summary',\n      'body',\n      'p',\n      'dl',\n      'multicol',\n      'dd',\n      'figure',\n      'address',\n      'center',\n      'blockquote',\n      'h1',\n      'h2',\n      'h3',\n      'h4',\n      'h5',\n      'h6',\n      'listing',\n      'xmp',\n      'pre',\n      'plaintext',\n      'menu',\n      'dir',\n      'ul',\n      'ol',\n      'li',\n      'hr',\n      'table',\n      'tbody',\n      'thead',\n      'tfoot',\n      'th',\n      'tr',\n      'td',\n      'caption'\n    ];\n    const tableCells = [\n      'td',\n      'th'\n    ];\n    const tableSections = [\n      'thead',\n      'tbody',\n      'tfoot'\n    ];\n    const textBlocks = [\n      'h1',\n      'h2',\n      'h3',\n      'h4',\n      'h5',\n      'h6',\n      'p',\n      'div',\n      'address',\n      'pre',\n      'form',\n      'blockquote',\n      'center',\n      'dir',\n      'fieldset',\n      'header',\n      'footer',\n      'article',\n      'section',\n      'hgroup',\n      'aside',\n      'nav',\n      'figure'\n    ];\n    const headings = [\n      'h1',\n      'h2',\n      'h3',\n      'h4',\n      'h5',\n      'h6'\n    ];\n    const listItems$1 = [\n      'li',\n      'dd',\n      'dt'\n    ];\n    const lists = [\n      'ul',\n      'ol',\n      'dl'\n    ];\n    const wsElements = [\n      'pre',\n      'script',\n      'textarea',\n      'style'\n    ];\n    const lazyLookup = items => {\n      let lookup;\n      return node => {\n        lookup = lookup ? lookup : mapToObject(items, always);\n        return has$2(lookup, name(node));\n      };\n    };\n    const isHeading = lazyLookup(headings);\n    const isBlock$2 = lazyLookup(blocks);\n    const isTable$2 = node => name(node) === 'table';\n    const isInline$1 = node => isElement$7(node) && !isBlock$2(node);\n    const isBr$4 = node => isElement$7(node) && name(node) === 'br';\n    const isTextBlock$2 = lazyLookup(textBlocks);\n    const isList = lazyLookup(lists);\n    const isListItem = lazyLookup(listItems$1);\n    const isTableSection = lazyLookup(tableSections);\n    const isTableCell$4 = lazyLookup(tableCells);\n    const isWsPreserveElement = lazyLookup(wsElements);\n\n    const ancestor$1 = (scope, selector, isRoot) => ancestor$2(scope, selector, isRoot).isSome();\n\n    const zeroWidth = '\\uFEFF';\n    const nbsp = '\\xA0';\n    const isZwsp$1 = char => char === zeroWidth;\n    const removeZwsp = s => s.replace(/\\uFEFF/g, '');\n\n    const ZWSP$1 = zeroWidth;\n    const isZwsp = isZwsp$1;\n    const trim$1 = removeZwsp;\n\n    const isElement$5 = isElement$6;\n    const isText$7 = isText$8;\n    const isCaretContainerBlock$1 = node => {\n      if (isText$7(node)) {\n        node = node.parentNode;\n      }\n      return isElement$5(node) && node.hasAttribute('data-mce-caret');\n    };\n    const isCaretContainerInline = node => isText$7(node) && isZwsp(node.data);\n    const isCaretContainer$2 = node => isCaretContainerBlock$1(node) || isCaretContainerInline(node);\n    const hasContent = node => node.firstChild !== node.lastChild || !isBr$5(node.firstChild);\n    const insertInline$1 = (node, before) => {\n      const doc = node.ownerDocument;\n      const textNode = doc.createTextNode(ZWSP$1);\n      const parentNode = node.parentNode;\n      if (!before) {\n        const sibling = node.nextSibling;\n        if (isText$7(sibling)) {\n          if (isCaretContainer$2(sibling)) {\n            return sibling;\n          }\n          if (startsWithCaretContainer$1(sibling)) {\n            sibling.splitText(1);\n            return sibling;\n          }\n        }\n        if (node.nextSibling) {\n          parentNode.insertBefore(textNode, node.nextSibling);\n        } else {\n          parentNode.appendChild(textNode);\n        }\n      } else {\n        const sibling = node.previousSibling;\n        if (isText$7(sibling)) {\n          if (isCaretContainer$2(sibling)) {\n            return sibling;\n          }\n          if (endsWithCaretContainer$1(sibling)) {\n            return sibling.splitText(sibling.data.length - 1);\n          }\n        }\n        parentNode.insertBefore(textNode, node);\n      }\n      return textNode;\n    };\n    const isBeforeInline = pos => {\n      const container = pos.container();\n      if (!isText$8(container)) {\n        return false;\n      }\n      return container.data.charAt(pos.offset()) === ZWSP$1 || pos.isAtStart() && isCaretContainerInline(container.previousSibling);\n    };\n    const isAfterInline = pos => {\n      const container = pos.container();\n      if (!isText$8(container)) {\n        return false;\n      }\n      return container.data.charAt(pos.offset() - 1) === ZWSP$1 || pos.isAtEnd() && isCaretContainerInline(container.nextSibling);\n    };\n    const createBogusBr = () => {\n      const br = document.createElement('br');\n      br.setAttribute('data-mce-bogus', '1');\n      return br;\n    };\n    const insertBlock = (blockName, node, before) => {\n      const doc = node.ownerDocument;\n      const blockNode = doc.createElement(blockName);\n      blockNode.setAttribute('data-mce-caret', before ? 'before' : 'after');\n      blockNode.setAttribute('data-mce-bogus', 'all');\n      blockNode.appendChild(createBogusBr());\n      const parentNode = node.parentNode;\n      if (!before) {\n        if (node.nextSibling) {\n          parentNode.insertBefore(blockNode, node.nextSibling);\n        } else {\n          parentNode.appendChild(blockNode);\n        }\n      } else {\n        parentNode.insertBefore(blockNode, node);\n      }\n      return blockNode;\n    };\n    const startsWithCaretContainer$1 = node => isText$7(node) && node.data[0] === ZWSP$1;\n    const endsWithCaretContainer$1 = node => isText$7(node) && node.data[node.data.length - 1] === ZWSP$1;\n    const trimBogusBr = elm => {\n      const brs = elm.getElementsByTagName('br');\n      const lastBr = brs[brs.length - 1];\n      if (isBogus$2(lastBr)) {\n        lastBr.parentNode.removeChild(lastBr);\n      }\n    };\n    const showCaretContainerBlock = caretContainer => {\n      if (caretContainer && caretContainer.hasAttribute('data-mce-caret')) {\n        trimBogusBr(caretContainer);\n        caretContainer.removeAttribute('data-mce-caret');\n        caretContainer.removeAttribute('data-mce-bogus');\n        caretContainer.removeAttribute('style');\n        caretContainer.removeAttribute('data-mce-style');\n        caretContainer.removeAttribute('_moz_abspos');\n        return caretContainer;\n      }\n      return null;\n    };\n    const isRangeInCaretContainerBlock = range => isCaretContainerBlock$1(range.startContainer);\n\n    const isContentEditableTrue$3 = isContentEditableTrue$4;\n    const isContentEditableFalse$9 = isContentEditableFalse$a;\n    const isBr$3 = isBr$5;\n    const isText$6 = isText$8;\n    const isInvalidTextElement = matchNodeNames([\n      'script',\n      'style',\n      'textarea'\n    ]);\n    const isAtomicInline = matchNodeNames([\n      'img',\n      'input',\n      'textarea',\n      'hr',\n      'iframe',\n      'video',\n      'audio',\n      'object',\n      'embed'\n    ]);\n    const isTable$1 = matchNodeNames(['table']);\n    const isCaretContainer$1 = isCaretContainer$2;\n    const isCaretCandidate$3 = node => {\n      if (isCaretContainer$1(node)) {\n        return false;\n      }\n      if (isText$6(node)) {\n        return !isInvalidTextElement(node.parentNode);\n      }\n      return isAtomicInline(node) || isBr$3(node) || isTable$1(node) || isNonUiContentEditableFalse(node);\n    };\n    const isUnselectable = node => isElement$6(node) && node.getAttribute('unselectable') === 'true';\n    const isNonUiContentEditableFalse = node => isUnselectable(node) === false && isContentEditableFalse$9(node);\n    const isInEditable = (node, root) => {\n      for (node = node.parentNode; node && node !== root; node = node.parentNode) {\n        if (isNonUiContentEditableFalse(node)) {\n          return false;\n        }\n        if (isContentEditableTrue$3(node)) {\n          return true;\n        }\n      }\n      return true;\n    };\n    const isAtomicContentEditableFalse = node => {\n      if (!isNonUiContentEditableFalse(node)) {\n        return false;\n      }\n      return foldl(from(node.getElementsByTagName('*')), (result, elm) => {\n        return result || isContentEditableTrue$3(elm);\n      }, false) !== true;\n    };\n    const isAtomic$1 = node => isAtomicInline(node) || isAtomicContentEditableFalse(node);\n    const isEditableCaretCandidate$1 = (node, root) => isCaretCandidate$3(node) && isInEditable(node, root);\n\n    const whiteSpaceRegExp = /^[ \\t\\r\\n]*$/;\n    const isWhitespaceText = text => whiteSpaceRegExp.test(text);\n    const isCollapsibleWhitespace$1 = c => ' \\f\\t\\x0B'.indexOf(c) !== -1;\n    const isNewLineChar = c => c === '\\n' || c === '\\r';\n    const isNewline = (text, idx) => idx < text.length && idx >= 0 ? isNewLineChar(text[idx]) : false;\n    const normalize$4 = (text, tabSpaces = 4, isStartOfContent = true, isEndOfContent = true) => {\n      const tabSpace = repeat(' ', tabSpaces);\n      const normalizedText = text.replace(/\\t/g, tabSpace);\n      const result = foldl(normalizedText, (acc, c) => {\n        if (isCollapsibleWhitespace$1(c) || c === nbsp) {\n          if (acc.pcIsSpace || acc.str === '' && isStartOfContent || acc.str.length === normalizedText.length - 1 && isEndOfContent || isNewline(normalizedText, acc.str.length + 1)) {\n            return {\n              pcIsSpace: false,\n              str: acc.str + nbsp\n            };\n          } else {\n            return {\n              pcIsSpace: true,\n              str: acc.str + ' '\n            };\n          }\n        } else {\n          return {\n            pcIsSpace: isNewLineChar(c),\n            str: acc.str + c\n          };\n        }\n      }, {\n        pcIsSpace: false,\n        str: ''\n      });\n      return result.str;\n    };\n\n    const hasWhitespacePreserveParent = (node, rootNode) => {\n      const rootElement = SugarElement.fromDom(rootNode);\n      const startNode = SugarElement.fromDom(node);\n      return ancestor$1(startNode, 'pre,code', curry(eq, rootElement));\n    };\n    const isWhitespace$1 = (node, rootNode) => {\n      return isText$8(node) && isWhitespaceText(node.data) && hasWhitespacePreserveParent(node, rootNode) === false;\n    };\n    const isNamedAnchor = node => {\n      return isElement$6(node) && node.nodeName === 'A' && !node.hasAttribute('href') && (node.hasAttribute('name') || node.hasAttribute('id'));\n    };\n    const isContent$1 = (node, rootNode) => {\n      return isCaretCandidate$3(node) && isWhitespace$1(node, rootNode) === false || isNamedAnchor(node) || isBookmark(node);\n    };\n    const isBookmark = hasAttribute('data-mce-bookmark');\n    const isBogus$1 = hasAttribute('data-mce-bogus');\n    const isBogusAll = hasAttributeValue('data-mce-bogus', 'all');\n    const isEmptyNode = (targetNode, skipBogus) => {\n      let brCount = 0;\n      if (isContent$1(targetNode, targetNode)) {\n        return false;\n      } else {\n        let node = targetNode.firstChild;\n        if (!node) {\n          return true;\n        }\n        const walker = new DomTreeWalker(node, targetNode);\n        do {\n          if (skipBogus) {\n            if (isBogusAll(node)) {\n              node = walker.next(true);\n              continue;\n            }\n            if (isBogus$1(node)) {\n              node = walker.next();\n              continue;\n            }\n          }\n          if (isBr$5(node)) {\n            brCount++;\n            node = walker.next();\n            continue;\n          }\n          if (isContent$1(node, targetNode)) {\n            return false;\n          }\n          node = walker.next();\n        } while (node);\n        return brCount <= 1;\n      }\n    };\n    const isEmpty$2 = (elm, skipBogus = true) => isEmptyNode(elm.dom, skipBogus);\n\n    const isSpan = node => node.nodeName.toLowerCase() === 'span';\n    const isInlineContent = (node, root) => isNonNullable(node) && (isContent$1(node, root) || isInline$1(SugarElement.fromDom(node)));\n    const surroundedByInlineContent = (node, root) => {\n      const prev = new DomTreeWalker(node, root).prev(false);\n      const next = new DomTreeWalker(node, root).next(false);\n      const prevIsInline = isUndefined(prev) || isInlineContent(prev, root);\n      const nextIsInline = isUndefined(next) || isInlineContent(next, root);\n      return prevIsInline && nextIsInline;\n    };\n    const isBookmarkNode$2 = node => isSpan(node) && node.getAttribute('data-mce-type') === 'bookmark';\n    const isKeepTextNode = (node, root) => isText$8(node) && node.data.length > 0 && surroundedByInlineContent(node, root);\n    const isKeepElement = node => isElement$6(node) ? node.childNodes.length > 0 : false;\n    const isDocument = node => isDocumentFragment(node) || isDocument$1(node);\n    const trimNode = (dom, node, root) => {\n      const rootNode = root || node;\n      if (isElement$6(node) && isBookmarkNode$2(node)) {\n        return node;\n      }\n      const children = node.childNodes;\n      for (let i = children.length - 1; i >= 0; i--) {\n        trimNode(dom, children[i], rootNode);\n      }\n      if (isElement$6(node)) {\n        const currentChildren = node.childNodes;\n        if (currentChildren.length === 1 && isBookmarkNode$2(currentChildren[0])) {\n          node.parentNode.insertBefore(currentChildren[0], node);\n        }\n      }\n      if (!isDocument(node) && !isContent$1(node, rootNode) && !isKeepElement(node) && !isKeepTextNode(node, rootNode)) {\n        dom.remove(node);\n      }\n      return node;\n    };\n\n    const makeMap$3 = Tools.makeMap;\n    const attrsCharsRegExp = /[&<>\\\"\\u0060\\u007E-\\uD7FF\\uE000-\\uFFEF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n    const textCharsRegExp = /[<>&\\u007E-\\uD7FF\\uE000-\\uFFEF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n    const rawCharsRegExp = /[<>&\\\"\\']/g;\n    const entityRegExp = /&#([a-z0-9]+);?|&([a-z0-9]+);/gi;\n    const asciiMap = {\n      128: '\\u20AC',\n      130: '\\u201A',\n      131: '\\u0192',\n      132: '\\u201E',\n      133: '\\u2026',\n      134: '\\u2020',\n      135: '\\u2021',\n      136: '\\u02c6',\n      137: '\\u2030',\n      138: '\\u0160',\n      139: '\\u2039',\n      140: '\\u0152',\n      142: '\\u017d',\n      145: '\\u2018',\n      146: '\\u2019',\n      147: '\\u201C',\n      148: '\\u201D',\n      149: '\\u2022',\n      150: '\\u2013',\n      151: '\\u2014',\n      152: '\\u02DC',\n      153: '\\u2122',\n      154: '\\u0161',\n      155: '\\u203A',\n      156: '\\u0153',\n      158: '\\u017e',\n      159: '\\u0178'\n    };\n    const baseEntities = {\n      '\"': '&quot;',\n      '\\'': '&#39;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '&': '&amp;',\n      '`': '&#96;'\n    };\n    const reverseEntities = {\n      '&lt;': '<',\n      '&gt;': '>',\n      '&amp;': '&',\n      '&quot;': '\"',\n      '&apos;': `'`\n    };\n    const nativeDecode = text => {\n      const elm = SugarElement.fromTag('div').dom;\n      elm.innerHTML = text;\n      return elm.textContent || elm.innerText || text;\n    };\n    const buildEntitiesLookup = (items, radix) => {\n      let i, chr, entity;\n      const lookup = {};\n      if (items) {\n        items = items.split(',');\n        radix = radix || 10;\n        for (i = 0; i < items.length; i += 2) {\n          chr = String.fromCharCode(parseInt(items[i], radix));\n          if (!baseEntities[chr]) {\n            entity = '&' + items[i + 1] + ';';\n            lookup[chr] = entity;\n            lookup[entity] = chr;\n          }\n        }\n        return lookup;\n      }\n    };\n    const namedEntities = buildEntitiesLookup('50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,' + '5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,' + '5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,' + '5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,' + '68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,' + '6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,' + '6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,' + '75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,' + '7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,' + '7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,' + 'sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,' + 'st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,' + 't9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,' + 'tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,' + 'u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,' + '81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,' + '8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,' + '8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,' + '8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,' + '8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,' + 'nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,' + 'rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,' + 'Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,' + '80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,' + '811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro', 32);\n    const encodeRaw = (text, attr) => text.replace(attr ? attrsCharsRegExp : textCharsRegExp, chr => {\n      return baseEntities[chr] || chr;\n    });\n    const encodeAllRaw = text => ('' + text).replace(rawCharsRegExp, chr => {\n      return baseEntities[chr] || chr;\n    });\n    const encodeNumeric = (text, attr) => text.replace(attr ? attrsCharsRegExp : textCharsRegExp, chr => {\n      if (chr.length > 1) {\n        return '&#' + ((chr.charCodeAt(0) - 55296) * 1024 + (chr.charCodeAt(1) - 56320) + 65536) + ';';\n      }\n      return baseEntities[chr] || '&#' + chr.charCodeAt(0) + ';';\n    });\n    const encodeNamed = (text, attr, entities) => {\n      entities = entities || namedEntities;\n      return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, chr => {\n        return baseEntities[chr] || entities[chr] || chr;\n      });\n    };\n    const getEncodeFunc = (name, entities) => {\n      const entitiesMap = buildEntitiesLookup(entities) || namedEntities;\n      const encodeNamedAndNumeric = (text, attr) => text.replace(attr ? attrsCharsRegExp : textCharsRegExp, chr => {\n        if (baseEntities[chr] !== undefined) {\n          return baseEntities[chr];\n        }\n        if (entitiesMap[chr] !== undefined) {\n          return entitiesMap[chr];\n        }\n        if (chr.length > 1) {\n          return '&#' + ((chr.charCodeAt(0) - 55296) * 1024 + (chr.charCodeAt(1) - 56320) + 65536) + ';';\n        }\n        return '&#' + chr.charCodeAt(0) + ';';\n      });\n      const encodeCustomNamed = (text, attr) => {\n        return encodeNamed(text, attr, entitiesMap);\n      };\n      const nameMap = makeMap$3(name.replace(/\\+/g, ','));\n      if (nameMap.named && nameMap.numeric) {\n        return encodeNamedAndNumeric;\n      }\n      if (nameMap.named) {\n        if (entities) {\n          return encodeCustomNamed;\n        }\n        return encodeNamed;\n      }\n      if (nameMap.numeric) {\n        return encodeNumeric;\n      }\n      return encodeRaw;\n    };\n    const decode = text => text.replace(entityRegExp, (all, numeric) => {\n      if (numeric) {\n        if (numeric.charAt(0).toLowerCase() === 'x') {\n          numeric = parseInt(numeric.substr(1), 16);\n        } else {\n          numeric = parseInt(numeric, 10);\n        }\n        if (numeric > 65535) {\n          numeric -= 65536;\n          return String.fromCharCode(55296 + (numeric >> 10), 56320 + (numeric & 1023));\n        }\n        return asciiMap[numeric] || String.fromCharCode(numeric);\n      }\n      return reverseEntities[all] || namedEntities[all] || nativeDecode(all);\n    });\n    const Entities = {\n      encodeRaw,\n      encodeAllRaw,\n      encodeNumeric,\n      encodeNamed,\n      getEncodeFunc,\n      decode\n    };\n\n    const mapCache = {}, dummyObj = {};\n    const makeMap$2 = Tools.makeMap, each$d = Tools.each, extend$2 = Tools.extend, explode$2 = Tools.explode, inArray = Tools.inArray;\n    const split$1 = (items, delim) => {\n      items = Tools.trim(items);\n      return items ? items.split(delim || ' ') : [];\n    };\n    const createMap = (defaultValue, extendWith) => {\n      const value = makeMap$2(defaultValue, ' ', makeMap$2(defaultValue.toUpperCase(), ' '));\n      return extend$2(value, extendWith);\n    };\n    const getTextRootBlockElements = schema => createMap('td th li dt dd figcaption caption details summary', schema.getTextBlockElements());\n    const compileSchema = type => {\n      const schema = {};\n      let globalAttributes, blockContent;\n      let phrasingContent, flowContent, html4BlockContent, html4PhrasingContent;\n      const add = (name, attributes = '', children = '') => {\n        const childNames = split$1(children);\n        const names = split$1(name);\n        let ni = names.length;\n        while (ni--) {\n          const attributesOrder = split$1([\n            globalAttributes,\n            attributes\n          ].join(' '));\n          schema[names[ni]] = {\n            attributes: mapToObject(attributesOrder, () => ({})),\n            attributesOrder,\n            children: mapToObject(childNames, constant(dummyObj))\n          };\n        }\n      };\n      const addAttrs = (name, attributes) => {\n        const names = split$1(name);\n        const attrs = split$1(attributes);\n        let ni = names.length;\n        while (ni--) {\n          const schemaItem = schema[names[ni]];\n          for (let i = 0, l = attrs.length; i < l; i++) {\n            schemaItem.attributes[attrs[i]] = {};\n            schemaItem.attributesOrder.push(attrs[i]);\n          }\n        }\n      };\n      if (mapCache[type]) {\n        return mapCache[type];\n      }\n      globalAttributes = 'id accesskey class dir lang style tabindex title role';\n      blockContent = 'address blockquote div dl fieldset form h1 h2 h3 h4 h5 h6 hr menu ol p pre table ul';\n      phrasingContent = 'a abbr b bdo br button cite code del dfn em embed i iframe img input ins kbd ' + 'label map noscript object q s samp script select small span strong sub sup ' + 'textarea u var #text #comment';\n      if (type !== 'html4') {\n        globalAttributes += ' contenteditable contextmenu draggable dropzone ' + 'hidden spellcheck translate';\n        blockContent += ' article aside details dialog figure main header footer hgroup section nav';\n        phrasingContent += ' audio canvas command datalist mark meter output picture ' + 'progress time wbr video ruby bdi keygen';\n      }\n      if (type !== 'html5-strict') {\n        globalAttributes += ' xml:lang';\n        html4PhrasingContent = 'acronym applet basefont big font strike tt';\n        phrasingContent = [\n          phrasingContent,\n          html4PhrasingContent\n        ].join(' ');\n        each$d(split$1(html4PhrasingContent), name => {\n          add(name, '', phrasingContent);\n        });\n        html4BlockContent = 'center dir isindex noframes';\n        blockContent = [\n          blockContent,\n          html4BlockContent\n        ].join(' ');\n        flowContent = [\n          blockContent,\n          phrasingContent\n        ].join(' ');\n        each$d(split$1(html4BlockContent), name => {\n          add(name, '', flowContent);\n        });\n      }\n      flowContent = flowContent || [\n        blockContent,\n        phrasingContent\n      ].join(' ');\n      add('html', 'manifest', 'head body');\n      add('head', '', 'base command link meta noscript script style title');\n      add('title hr noscript br');\n      add('base', 'href target');\n      add('link', 'href rel media hreflang type sizes hreflang');\n      add('meta', 'name http-equiv content charset');\n      add('style', 'media type scoped');\n      add('script', 'src async defer type charset');\n      add('body', 'onafterprint onbeforeprint onbeforeunload onblur onerror onfocus ' + 'onhashchange onload onmessage onoffline ononline onpagehide onpageshow ' + 'onpopstate onresize onscroll onstorage onunload', flowContent);\n      add('address dt dd div caption', '', flowContent);\n      add('h1 h2 h3 h4 h5 h6 pre p abbr code var samp kbd sub sup i b u bdo span legend em strong small s cite dfn', '', phrasingContent);\n      add('blockquote', 'cite', flowContent);\n      add('ol', 'reversed start type', 'li');\n      add('ul', '', 'li');\n      add('li', 'value', flowContent);\n      add('dl', '', 'dt dd');\n      add('a', 'href target rel media hreflang type', phrasingContent);\n      add('q', 'cite', phrasingContent);\n      add('ins del', 'cite datetime', flowContent);\n      add('img', 'src sizes srcset alt usemap ismap width height');\n      add('iframe', 'src name width height', flowContent);\n      add('embed', 'src type width height');\n      add('object', 'data type typemustmatch name usemap form width height', [\n        flowContent,\n        'param'\n      ].join(' '));\n      add('param', 'name value');\n      add('map', 'name', [\n        flowContent,\n        'area'\n      ].join(' '));\n      add('area', 'alt coords shape href target rel media hreflang type');\n      add('table', 'border', 'caption colgroup thead tfoot tbody tr' + (type === 'html4' ? ' col' : ''));\n      add('colgroup', 'span', 'col');\n      add('col', 'span');\n      add('tbody thead tfoot', '', 'tr');\n      add('tr', '', 'td th');\n      add('td', 'colspan rowspan headers', flowContent);\n      add('th', 'colspan rowspan headers scope abbr', flowContent);\n      add('form', 'accept-charset action autocomplete enctype method name novalidate target', flowContent);\n      add('fieldset', 'disabled form name', [\n        flowContent,\n        'legend'\n      ].join(' '));\n      add('label', 'form for', phrasingContent);\n      add('input', 'accept alt autocomplete checked dirname disabled form formaction formenctype formmethod formnovalidate ' + 'formtarget height list max maxlength min multiple name pattern readonly required size src step type value width');\n      add('button', 'disabled form formaction formenctype formmethod formnovalidate formtarget name type value', type === 'html4' ? flowContent : phrasingContent);\n      add('select', 'disabled form multiple name required size', 'option optgroup');\n      add('optgroup', 'disabled label', 'option');\n      add('option', 'disabled label selected value');\n      add('textarea', 'cols dirname disabled form maxlength name readonly required rows wrap');\n      add('menu', 'type label', [\n        flowContent,\n        'li'\n      ].join(' '));\n      add('noscript', '', flowContent);\n      if (type !== 'html4') {\n        add('wbr');\n        add('ruby', '', [\n          phrasingContent,\n          'rt rp'\n        ].join(' '));\n        add('figcaption', '', flowContent);\n        add('mark rt rp summary bdi', '', phrasingContent);\n        add('canvas', 'width height', flowContent);\n        add('video', 'src crossorigin poster preload autoplay mediagroup loop ' + 'muted controls width height buffered', [\n          flowContent,\n          'track source'\n        ].join(' '));\n        add('audio', 'src crossorigin preload autoplay mediagroup loop muted controls ' + 'buffered volume', [\n          flowContent,\n          'track source'\n        ].join(' '));\n        add('picture', '', 'img source');\n        add('source', 'src srcset type media sizes');\n        add('track', 'kind src srclang label default');\n        add('datalist', '', [\n          phrasingContent,\n          'option'\n        ].join(' '));\n        add('article section nav aside main header footer', '', flowContent);\n        add('hgroup', '', 'h1 h2 h3 h4 h5 h6');\n        add('figure', '', [\n          flowContent,\n          'figcaption'\n        ].join(' '));\n        add('time', 'datetime', phrasingContent);\n        add('dialog', 'open', flowContent);\n        add('command', 'type label icon disabled checked radiogroup command');\n        add('output', 'for form name', phrasingContent);\n        add('progress', 'value max', phrasingContent);\n        add('meter', 'value min max low high optimum', phrasingContent);\n        add('details', 'open', [\n          flowContent,\n          'summary'\n        ].join(' '));\n        add('keygen', 'autofocus challenge disabled form keytype name');\n      }\n      if (type !== 'html5-strict') {\n        addAttrs('script', 'language xml:space');\n        addAttrs('style', 'xml:space');\n        addAttrs('object', 'declare classid code codebase codetype archive standby align border hspace vspace');\n        addAttrs('embed', 'align name hspace vspace');\n        addAttrs('param', 'valuetype type');\n        addAttrs('a', 'charset name rev shape coords');\n        addAttrs('br', 'clear');\n        addAttrs('applet', 'codebase archive code object alt name width height align hspace vspace');\n        addAttrs('img', 'name longdesc align border hspace vspace');\n        addAttrs('iframe', 'longdesc frameborder marginwidth marginheight scrolling align');\n        addAttrs('font basefont', 'size color face');\n        addAttrs('input', 'usemap align');\n        addAttrs('select');\n        addAttrs('textarea');\n        addAttrs('h1 h2 h3 h4 h5 h6 div p legend caption', 'align');\n        addAttrs('ul', 'type compact');\n        addAttrs('li', 'type');\n        addAttrs('ol dl menu dir', 'compact');\n        addAttrs('pre', 'width xml:space');\n        addAttrs('hr', 'align noshade size width');\n        addAttrs('isindex', 'prompt');\n        addAttrs('table', 'summary width frame rules cellspacing cellpadding align bgcolor');\n        addAttrs('col', 'width align char charoff valign');\n        addAttrs('colgroup', 'width align char charoff valign');\n        addAttrs('thead', 'align char charoff valign');\n        addAttrs('tr', 'align char charoff valign bgcolor');\n        addAttrs('th', 'axis align char charoff valign nowrap bgcolor width height');\n        addAttrs('form', 'accept');\n        addAttrs('td', 'abbr axis scope align char charoff valign nowrap bgcolor width height');\n        addAttrs('tfoot', 'align char charoff valign');\n        addAttrs('tbody', 'align char charoff valign');\n        addAttrs('area', 'nohref');\n        addAttrs('body', 'background bgcolor text link vlink alink');\n      }\n      if (type !== 'html4') {\n        addAttrs('input button select textarea', 'autofocus');\n        addAttrs('input textarea', 'placeholder');\n        addAttrs('a', 'download');\n        addAttrs('link script img', 'crossorigin');\n        addAttrs('img', 'loading');\n        addAttrs('iframe', 'sandbox seamless allowfullscreen loading');\n      }\n      if (type !== 'html4') {\n        each$g([\n          schema.video,\n          schema.audio\n        ], item => {\n          delete item.children.audio;\n          delete item.children.video;\n        });\n      }\n      each$d(split$1('a form meter progress dfn'), name => {\n        if (schema[name]) {\n          delete schema[name].children[name];\n        }\n      });\n      delete schema.caption.children.table;\n      delete schema.script;\n      mapCache[type] = schema;\n      return schema;\n    };\n    const compileElementMap = (value, mode) => {\n      let styles;\n      if (value) {\n        styles = {};\n        if (typeof value === 'string') {\n          value = { '*': value };\n        }\n        each$d(value, (value, key) => {\n          styles[key] = styles[key.toUpperCase()] = mode === 'map' ? makeMap$2(value, /[, ]/) : explode$2(value, /[, ]/);\n        });\n      }\n      return styles;\n    };\n    const Schema = settings => {\n      var _a;\n      const elements = {};\n      const children = {};\n      let patternElements = [];\n      const customElementsMap = {}, specialElements = {};\n      const createLookupTable = (option, defaultValue, extendWith) => {\n        let value = settings[option];\n        if (!value) {\n          value = mapCache[option];\n          if (!value) {\n            value = createMap(defaultValue, extendWith);\n            mapCache[option] = value;\n          }\n        } else {\n          value = makeMap$2(value, /[, ]/, makeMap$2(value.toUpperCase(), /[, ]/));\n        }\n        return value;\n      };\n      settings = settings || {};\n      const schemaType = (_a = settings.schema) !== null && _a !== void 0 ? _a : 'html5';\n      const schemaItems = compileSchema(schemaType);\n      if (settings.verify_html === false) {\n        settings.valid_elements = '*[*]';\n      }\n      const validStyles = compileElementMap(settings.valid_styles);\n      const invalidStyles = compileElementMap(settings.invalid_styles, 'map');\n      const validClasses = compileElementMap(settings.valid_classes, 'map');\n      const whitespaceElementsMap = createLookupTable('whitespace_elements', 'pre script noscript style textarea video audio iframe object code');\n      const selfClosingElementsMap = createLookupTable('self_closing_elements', 'colgroup dd dt li option p td tfoot th thead tr');\n      const voidElementsMap = createLookupTable('void_elements', 'area base basefont br col frame hr img input isindex link ' + 'meta param embed source wbr track');\n      const boolAttrMap = createLookupTable('boolean_attributes', 'checked compact declare defer disabled ismap multiple nohref noresize ' + 'noshade nowrap readonly selected autoplay loop controls allowfullscreen');\n      const nonEmptyOrMoveCaretBeforeOnEnter = 'td th iframe video audio object script code';\n      const nonEmptyElementsMap = createLookupTable('non_empty_elements', nonEmptyOrMoveCaretBeforeOnEnter + ' pre', voidElementsMap);\n      const moveCaretBeforeOnEnterElementsMap = createLookupTable('move_caret_before_on_enter_elements', nonEmptyOrMoveCaretBeforeOnEnter + ' table', voidElementsMap);\n      const textBlockElementsMap = createLookupTable('text_block_elements', 'h1 h2 h3 h4 h5 h6 p div address pre form ' + 'blockquote center dir fieldset header footer article section hgroup aside main nav figure');\n      const blockElementsMap = createLookupTable('block_elements', 'hr table tbody thead tfoot ' + 'th tr td li ol ul caption dl dt dd noscript menu isindex option ' + 'datalist select optgroup figcaption details summary', textBlockElementsMap);\n      const textInlineElementsMap = createLookupTable('text_inline_elements', 'span strong b em i font s strike u var cite ' + 'dfn code mark q sup sub samp');\n      each$d('script noscript iframe noframes noembed title style textarea xmp plaintext'.split(' '), name => {\n        specialElements[name] = new RegExp('</' + name + '[^>]*>', 'gi');\n      });\n      const patternToRegExp = str => new RegExp('^' + str.replace(/([?+*])/g, '.$1') + '$');\n      const addValidElements = validElements => {\n        let ei, el, ai, al, matches, element, attr, attrData, elementName, attrName, attrType, attributes, attributesOrder, prefix, outputName, globalAttributes, globalAttributesOrder, value;\n        const elementRuleRegExp = /^([#+\\-])?([^\\[!\\/]+)(?:\\/([^\\[!]+))?(?:(!?)\\[([^\\]]+)])?$/, attrRuleRegExp = /^([!\\-])?(\\w+[\\\\:]:\\w+|[^=~<]+)?(?:([=~<])(.*))?$/, hasPatternsRegExp = /[*?+]/;\n        if (validElements) {\n          const validElementsArr = split$1(validElements, ',');\n          if (elements['@']) {\n            globalAttributes = elements['@'].attributes;\n            globalAttributesOrder = elements['@'].attributesOrder;\n          }\n          for (ei = 0, el = validElementsArr.length; ei < el; ei++) {\n            matches = elementRuleRegExp.exec(validElementsArr[ei]);\n            if (matches) {\n              prefix = matches[1];\n              elementName = matches[2];\n              outputName = matches[3];\n              attrData = matches[5];\n              attributes = {};\n              attributesOrder = [];\n              element = {\n                attributes,\n                attributesOrder\n              };\n              if (prefix === '#') {\n                element.paddEmpty = true;\n              }\n              if (prefix === '-') {\n                element.removeEmpty = true;\n              }\n              if (matches[4] === '!') {\n                element.removeEmptyAttrs = true;\n              }\n              if (globalAttributes) {\n                each$f(globalAttributes, (value, key) => {\n                  attributes[key] = value;\n                });\n                attributesOrder.push.apply(attributesOrder, globalAttributesOrder);\n              }\n              if (attrData) {\n                attrData = split$1(attrData, '|');\n                for (ai = 0, al = attrData.length; ai < al; ai++) {\n                  matches = attrRuleRegExp.exec(attrData[ai]);\n                  if (matches) {\n                    attr = {};\n                    attrType = matches[1];\n                    attrName = matches[2].replace(/[\\\\:]:/g, ':');\n                    prefix = matches[3];\n                    value = matches[4];\n                    if (attrType === '!') {\n                      element.attributesRequired = element.attributesRequired || [];\n                      element.attributesRequired.push(attrName);\n                      attr.required = true;\n                    }\n                    if (attrType === '-') {\n                      delete attributes[attrName];\n                      attributesOrder.splice(inArray(attributesOrder, attrName), 1);\n                      continue;\n                    }\n                    if (prefix) {\n                      if (prefix === '=') {\n                        element.attributesDefault = element.attributesDefault || [];\n                        element.attributesDefault.push({\n                          name: attrName,\n                          value\n                        });\n                        attr.defaultValue = value;\n                      }\n                      if (prefix === '~') {\n                        element.attributesForced = element.attributesForced || [];\n                        element.attributesForced.push({\n                          name: attrName,\n                          value\n                        });\n                        attr.forcedValue = value;\n                      }\n                      if (prefix === '<') {\n                        attr.validValues = makeMap$2(value, '?');\n                      }\n                    }\n                    if (hasPatternsRegExp.test(attrName)) {\n                      element.attributePatterns = element.attributePatterns || [];\n                      attr.pattern = patternToRegExp(attrName);\n                      element.attributePatterns.push(attr);\n                    } else {\n                      if (!attributes[attrName]) {\n                        attributesOrder.push(attrName);\n                      }\n                      attributes[attrName] = attr;\n                    }\n                  }\n                }\n              }\n              if (!globalAttributes && elementName === '@') {\n                globalAttributes = attributes;\n                globalAttributesOrder = attributesOrder;\n              }\n              if (outputName) {\n                element.outputName = elementName;\n                elements[outputName] = element;\n              }\n              if (hasPatternsRegExp.test(elementName)) {\n                element.pattern = patternToRegExp(elementName);\n                patternElements.push(element);\n              } else {\n                elements[elementName] = element;\n              }\n            }\n          }\n        }\n      };\n      const setValidElements = validElements => {\n        patternElements = [];\n        each$g(keys(elements), name => {\n          delete elements[name];\n        });\n        addValidElements(validElements);\n        each$d(schemaItems, (element, name) => {\n          children[name] = element.children;\n        });\n      };\n      const addCustomElements = customElements => {\n        const customElementRegExp = /^(~)?(.+)$/;\n        if (customElements) {\n          mapCache.text_block_elements = mapCache.block_elements = null;\n          each$d(split$1(customElements, ','), rule => {\n            const matches = customElementRegExp.exec(rule), inline = matches[1] === '~', cloneName = inline ? 'span' : 'div', name = matches[2];\n            children[name] = children[cloneName];\n            customElementsMap[name] = cloneName;\n            if (!inline) {\n              blockElementsMap[name.toUpperCase()] = {};\n              blockElementsMap[name] = {};\n            }\n            if (!elements[name]) {\n              let customRule = elements[cloneName];\n              customRule = extend$2({}, customRule);\n              delete customRule.removeEmptyAttrs;\n              delete customRule.removeEmpty;\n              elements[name] = customRule;\n            }\n            each$d(children, (element, elmName) => {\n              if (element[cloneName]) {\n                children[elmName] = element = extend$2({}, children[elmName]);\n                element[name] = element[cloneName];\n              }\n            });\n          });\n        }\n      };\n      const addValidChildren = validChildren => {\n        const childRuleRegExp = /^([+\\-]?)([A-Za-z0-9_\\-.\\u00b7\\u00c0-\\u00d6\\u00d8-\\u00f6\\u00f8-\\u037d\\u037f-\\u1fff\\u200c-\\u200d\\u203f-\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]+)\\[([^\\]]+)]$/;\n        mapCache[schemaType] = null;\n        if (validChildren) {\n          each$d(split$1(validChildren, ','), rule => {\n            const matches = childRuleRegExp.exec(rule);\n            let parent, prefix;\n            if (matches) {\n              prefix = matches[1];\n              if (prefix) {\n                parent = children[matches[2]];\n              } else {\n                parent = children[matches[2]] = { '#comment': {} };\n              }\n              parent = children[matches[2]];\n              each$d(split$1(matches[3], '|'), child => {\n                if (prefix === '-') {\n                  delete parent[child];\n                } else {\n                  parent[child] = {};\n                }\n              });\n            }\n          });\n        }\n      };\n      const getElementRule = name => {\n        let element = elements[name], i;\n        if (element) {\n          return element;\n        }\n        i = patternElements.length;\n        while (i--) {\n          element = patternElements[i];\n          if (element.pattern.test(name)) {\n            return element;\n          }\n        }\n      };\n      if (!settings.valid_elements) {\n        each$d(schemaItems, (element, name) => {\n          elements[name] = {\n            attributes: element.attributes,\n            attributesOrder: element.attributesOrder\n          };\n          children[name] = element.children;\n        });\n        each$d(split$1('strong/b em/i'), item => {\n          const items = split$1(item, '/');\n          elements[items[1]].outputName = items[0];\n        });\n        each$d(textInlineElementsMap, (_val, name) => {\n          if (elements[name]) {\n            if (settings.padd_empty_block_inline_children) {\n              elements[name].paddInEmptyBlock = true;\n            }\n            elements[name].removeEmpty = true;\n          }\n        });\n        each$d(split$1('ol ul blockquote a table tbody'), name => {\n          if (elements[name]) {\n            elements[name].removeEmpty = true;\n          }\n        });\n        each$d(split$1('p h1 h2 h3 h4 h5 h6 th td pre div address caption li'), name => {\n          elements[name].paddEmpty = true;\n        });\n        each$d(split$1('span'), name => {\n          elements[name].removeEmptyAttrs = true;\n        });\n      } else {\n        setValidElements(settings.valid_elements);\n      }\n      addCustomElements(settings.custom_elements);\n      addValidChildren(settings.valid_children);\n      addValidElements(settings.extended_valid_elements);\n      addValidChildren('+ol[ul|ol],+ul[ul|ol]');\n      each$d({\n        dd: 'dl',\n        dt: 'dl',\n        li: 'ul ol',\n        td: 'tr',\n        th: 'tr',\n        tr: 'tbody thead tfoot',\n        tbody: 'table',\n        thead: 'table',\n        tfoot: 'table',\n        legend: 'fieldset',\n        area: 'map',\n        param: 'video audio object'\n      }, (parents, item) => {\n        if (elements[item]) {\n          elements[item].parentsRequired = split$1(parents);\n        }\n      });\n      if (settings.invalid_elements) {\n        each$d(explode$2(settings.invalid_elements), item => {\n          if (elements[item]) {\n            delete elements[item];\n          }\n        });\n      }\n      if (!getElementRule('span')) {\n        addValidElements('span[!data-mce-type|*]');\n      }\n      const getValidStyles = constant(validStyles);\n      const getInvalidStyles = constant(invalidStyles);\n      const getValidClasses = constant(validClasses);\n      const getBoolAttrs = constant(boolAttrMap);\n      const getBlockElements = constant(blockElementsMap);\n      const getTextBlockElements = constant(textBlockElementsMap);\n      const getTextInlineElements = constant(textInlineElementsMap);\n      const getVoidElements = constant(Object.seal(voidElementsMap));\n      const getSelfClosingElements = constant(selfClosingElementsMap);\n      const getNonEmptyElements = constant(nonEmptyElementsMap);\n      const getMoveCaretBeforeOnEnterElements = constant(moveCaretBeforeOnEnterElementsMap);\n      const getWhitespaceElements = constant(whitespaceElementsMap);\n      const getSpecialElements = constant(Object.seal(specialElements));\n      const isValidChild = (name, child) => {\n        const parent = children[name.toLowerCase()];\n        return !!(parent && parent[child.toLowerCase()]);\n      };\n      const isValid = (name, attr) => {\n        let attrPatterns, i;\n        const rule = getElementRule(name);\n        if (rule) {\n          if (attr) {\n            if (rule.attributes[attr]) {\n              return true;\n            }\n            attrPatterns = rule.attributePatterns;\n            if (attrPatterns) {\n              i = attrPatterns.length;\n              while (i--) {\n                if (attrPatterns[i].pattern.test(attr)) {\n                  return true;\n                }\n              }\n            }\n          } else {\n            return true;\n          }\n        }\n        return false;\n      };\n      const getCustomElements = constant(customElementsMap);\n      return {\n        type: schemaType,\n        children,\n        elements,\n        getValidStyles,\n        getValidClasses,\n        getBlockElements,\n        getInvalidStyles,\n        getVoidElements,\n        getTextBlockElements,\n        getTextInlineElements,\n        getBoolAttrs,\n        getElementRule,\n        getSelfClosingElements,\n        getNonEmptyElements,\n        getMoveCaretBeforeOnEnterElements,\n        getWhitespaceElements,\n        getSpecialElements,\n        isValidChild,\n        isValid,\n        getCustomElements,\n        addValidElements,\n        setValidElements,\n        addCustomElements,\n        addValidChildren\n      };\n    };\n\n    const Styles = (settings, schema) => {\n      const urlOrStrRegExp = /(?:url(?:(?:\\(\\s*\\\"([^\\\"]+)\\\"\\s*\\))|(?:\\(\\s*\\'([^\\']+)\\'\\s*\\))|(?:\\(\\s*([^)\\s]+)\\s*\\))))|(?:\\'([^\\']+)\\')|(?:\\\"([^\\\"]+)\\\")/gi;\n      const styleRegExp = /\\s*([^:]+):\\s*([^;]+);?/g;\n      const trimRightRegExp = /\\s+$/;\n      let i;\n      const encodingLookup = {};\n      let validStyles;\n      let invalidStyles;\n      const invisibleChar = zeroWidth;\n      settings = settings || {};\n      if (schema) {\n        validStyles = schema.getValidStyles();\n        invalidStyles = schema.getInvalidStyles();\n      }\n      const encodingItems = (`\\\\\" \\\\' \\\\; \\\\: ; : ` + invisibleChar).split(' ');\n      for (i = 0; i < encodingItems.length; i++) {\n        encodingLookup[encodingItems[i]] = invisibleChar + i;\n        encodingLookup[invisibleChar + i] = encodingItems[i];\n      }\n      const self = {\n        parse: css => {\n          const styles = {};\n          let matches, name, value, isEncoded;\n          const urlConverter = settings.url_converter;\n          const urlConverterScope = settings.url_converter_scope || self;\n          const compress = (prefix, suffix, noJoin) => {\n            const top = styles[prefix + '-top' + suffix];\n            if (!top) {\n              return;\n            }\n            const right = styles[prefix + '-right' + suffix];\n            if (!right) {\n              return;\n            }\n            const bottom = styles[prefix + '-bottom' + suffix];\n            if (!bottom) {\n              return;\n            }\n            const left = styles[prefix + '-left' + suffix];\n            if (!left) {\n              return;\n            }\n            const box = [\n              top,\n              right,\n              bottom,\n              left\n            ];\n            i = box.length - 1;\n            while (i--) {\n              if (box[i] !== box[i + 1]) {\n                break;\n              }\n            }\n            if (i > -1 && noJoin) {\n              return;\n            }\n            styles[prefix + suffix] = i === -1 ? box[0] : box.join(' ');\n            delete styles[prefix + '-top' + suffix];\n            delete styles[prefix + '-right' + suffix];\n            delete styles[prefix + '-bottom' + suffix];\n            delete styles[prefix + '-left' + suffix];\n          };\n          const canCompress = key => {\n            let value = styles[key], i;\n            if (!value) {\n              return;\n            }\n            value = value.split(' ');\n            i = value.length;\n            while (i--) {\n              if (value[i] !== value[0]) {\n                return false;\n              }\n            }\n            styles[key] = value[0];\n            return true;\n          };\n          const compress2 = (target, a, b, c) => {\n            if (!canCompress(a)) {\n              return;\n            }\n            if (!canCompress(b)) {\n              return;\n            }\n            if (!canCompress(c)) {\n              return;\n            }\n            styles[target] = styles[a] + ' ' + styles[b] + ' ' + styles[c];\n            delete styles[a];\n            delete styles[b];\n            delete styles[c];\n          };\n          const encode = str => {\n            isEncoded = true;\n            return encodingLookup[str];\n          };\n          const decode = (str, keepSlashes) => {\n            if (isEncoded) {\n              str = str.replace(/\\uFEFF[0-9]/g, str => {\n                return encodingLookup[str];\n              });\n            }\n            if (!keepSlashes) {\n              str = str.replace(/\\\\([\\'\\\";:])/g, '$1');\n            }\n            return str;\n          };\n          const decodeSingleHexSequence = escSeq => {\n            return String.fromCharCode(parseInt(escSeq.slice(1), 16));\n          };\n          const decodeHexSequences = value => {\n            return value.replace(/\\\\[0-9a-f]+/gi, decodeSingleHexSequence);\n          };\n          const processUrl = (match, url, url2, url3, str, str2) => {\n            str = str || str2;\n            if (str) {\n              str = decode(str);\n              return `'` + str.replace(/\\'/g, `\\\\'`) + `'`;\n            }\n            url = decode(url || url2 || url3);\n            if (!settings.allow_script_urls) {\n              const scriptUrl = url.replace(/[\\s\\r\\n]+/g, '');\n              if (/(java|vb)script:/i.test(scriptUrl)) {\n                return '';\n              }\n              if (!settings.allow_svg_data_urls && /^data:image\\/svg/i.test(scriptUrl)) {\n                return '';\n              }\n            }\n            if (urlConverter) {\n              url = urlConverter.call(urlConverterScope, url, 'style');\n            }\n            return `url('` + url.replace(/\\'/g, `\\\\'`) + `')`;\n          };\n          if (css) {\n            css = css.replace(/[\\u0000-\\u001F]/g, '');\n            css = css.replace(/\\\\[\\\"\\';:\\uFEFF]/g, encode).replace(/\\\"[^\\\"]+\\\"|\\'[^\\']+\\'/g, str => {\n              return str.replace(/[;:]/g, encode);\n            });\n            while (matches = styleRegExp.exec(css)) {\n              styleRegExp.lastIndex = matches.index + matches[0].length;\n              name = matches[1].replace(trimRightRegExp, '').toLowerCase();\n              value = matches[2].replace(trimRightRegExp, '');\n              if (name && value) {\n                name = decodeHexSequences(name);\n                value = decodeHexSequences(value);\n                if (name.indexOf(invisibleChar) !== -1 || name.indexOf('\"') !== -1) {\n                  continue;\n                }\n                if (!settings.allow_script_urls && (name === 'behavior' || /expression\\s*\\(|\\/\\*|\\*\\//.test(value))) {\n                  continue;\n                }\n                if (name === 'font-weight' && value === '700') {\n                  value = 'bold';\n                } else if (name === 'color' || name === 'background-color') {\n                  value = value.toLowerCase();\n                }\n                value = value.replace(urlOrStrRegExp, processUrl);\n                styles[name] = isEncoded ? decode(value, true) : value;\n              }\n            }\n            compress('border', '', true);\n            compress('border', '-width');\n            compress('border', '-color');\n            compress('border', '-style');\n            compress('padding', '');\n            compress('margin', '');\n            compress2('border', 'border-width', 'border-style', 'border-color');\n            if (styles.border === 'medium none') {\n              delete styles.border;\n            }\n            if (styles['border-image'] === 'none') {\n              delete styles['border-image'];\n            }\n          }\n          return styles;\n        },\n        serialize: (styles, elementName) => {\n          let css = '';\n          const serializeStyles = name => {\n            let value;\n            const styleList = validStyles[name];\n            if (styleList) {\n              for (let i = 0, l = styleList.length; i < l; i++) {\n                name = styleList[i];\n                value = styles[name];\n                if (value) {\n                  css += (css.length > 0 ? ' ' : '') + name + ': ' + value + ';';\n                }\n              }\n            }\n          };\n          const isValid = (name, elementName) => {\n            let styleMap = invalidStyles['*'];\n            if (styleMap && styleMap[name]) {\n              return false;\n            }\n            styleMap = invalidStyles[elementName];\n            return !(styleMap && styleMap[name]);\n          };\n          if (elementName && validStyles) {\n            serializeStyles('*');\n            serializeStyles(elementName);\n          } else {\n            each$f(styles, (value, name) => {\n              if (value && (!invalidStyles || isValid(name, elementName))) {\n                css += (css.length > 0 ? ' ' : '') + name + ': ' + value + ';';\n              }\n            });\n          }\n          return css;\n        }\n      };\n      return self;\n    };\n\n    const deprecated = {\n      keyLocation: true,\n      layerX: true,\n      layerY: true,\n      returnValue: true,\n      webkitMovementX: true,\n      webkitMovementY: true,\n      keyIdentifier: true,\n      mozPressure: true\n    };\n    const isNativeEvent = event => event instanceof Event || isFunction(event.initEvent);\n    const hasIsDefaultPrevented = event => event.isDefaultPrevented === always || event.isDefaultPrevented === never;\n    const needsNormalizing = event => isNullable(event.preventDefault) || isNativeEvent(event);\n    const clone$3 = (originalEvent, data) => {\n      const event = data !== null && data !== void 0 ? data : {};\n      for (const name in originalEvent) {\n        if (!has$2(deprecated, name)) {\n          event[name] = originalEvent[name];\n        }\n      }\n      if (isNonNullable(event.composedPath)) {\n        event.composedPath = () => originalEvent.composedPath();\n      }\n      return event;\n    };\n    const normalize$3 = (type, originalEvent, fallbackTarget, data) => {\n      var _a;\n      const event = clone$3(originalEvent, data);\n      event.type = type;\n      if (isNullable(event.target)) {\n        event.target = (_a = event.srcElement) !== null && _a !== void 0 ? _a : fallbackTarget;\n      }\n      if (needsNormalizing(originalEvent)) {\n        event.preventDefault = () => {\n          event.defaultPrevented = true;\n          event.isDefaultPrevented = always;\n          if (isFunction(originalEvent.preventDefault)) {\n            originalEvent.preventDefault();\n          }\n        };\n        event.stopPropagation = () => {\n          event.cancelBubble = true;\n          event.isPropagationStopped = always;\n          if (isFunction(originalEvent.stopPropagation)) {\n            originalEvent.stopPropagation();\n          }\n        };\n        event.stopImmediatePropagation = () => {\n          event.isImmediatePropagationStopped = always;\n          event.stopPropagation();\n        };\n        if (!hasIsDefaultPrevented(event)) {\n          event.isDefaultPrevented = event.defaultPrevented === true ? always : never;\n          event.isPropagationStopped = event.cancelBubble === true ? always : never;\n          event.isImmediatePropagationStopped = never;\n        }\n      }\n      return event;\n    };\n\n    const eventExpandoPrefix = 'mce-data-';\n    const mouseEventRe = /^(?:mouse|contextmenu)|click/;\n    const addEvent = (target, name, callback, capture) => {\n      if (target.addEventListener) {\n        target.addEventListener(name, callback, capture || false);\n      } else if (target.attachEvent) {\n        target.attachEvent('on' + name, callback);\n      }\n    };\n    const removeEvent = (target, name, callback, capture) => {\n      if (target.removeEventListener) {\n        target.removeEventListener(name, callback, capture || false);\n      } else if (target.detachEvent) {\n        target.detachEvent('on' + name, callback);\n      }\n    };\n    const isMouseEvent = event => isNonNullable(event) && mouseEventRe.test(event.type);\n    const fix = (originalEvent, data) => {\n      const event = normalize$3(originalEvent.type, originalEvent, document, data);\n      if (isMouseEvent(originalEvent) && isUndefined(originalEvent.pageX) && !isUndefined(originalEvent.clientX)) {\n        const eventDoc = event.target.ownerDocument || document;\n        const doc = eventDoc.documentElement;\n        const body = eventDoc.body;\n        const mouseEvent = event;\n        mouseEvent.pageX = originalEvent.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);\n        mouseEvent.pageY = originalEvent.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);\n      }\n      return event;\n    };\n    const bindOnReady = (win, callback, eventUtils) => {\n      const doc = win.document, event = { type: 'ready' };\n      if (eventUtils.domLoaded) {\n        callback(event);\n        return;\n      }\n      const isDocReady = () => {\n        return doc.readyState === 'complete' || doc.readyState === 'interactive' && doc.body;\n      };\n      const readyHandler = () => {\n        removeEvent(win, 'DOMContentLoaded', readyHandler);\n        removeEvent(win, 'load', readyHandler);\n        if (!eventUtils.domLoaded) {\n          eventUtils.domLoaded = true;\n          callback(event);\n        }\n        win = null;\n      };\n      if (isDocReady()) {\n        readyHandler();\n      } else {\n        addEvent(win, 'DOMContentLoaded', readyHandler);\n      }\n      if (!eventUtils.domLoaded) {\n        addEvent(win, 'load', readyHandler);\n      }\n    };\n    class EventUtils {\n      constructor() {\n        this.domLoaded = false;\n        this.events = {};\n        this.count = 1;\n        this.expando = eventExpandoPrefix + (+new Date()).toString(32);\n        this.hasMouseEnterLeave = 'onmouseenter' in document.documentElement;\n        this.hasFocusIn = 'onfocusin' in document.documentElement;\n        this.count = 1;\n      }\n      bind(target, names, callback, scope) {\n        const self = this;\n        let id, callbackList, i, name, fakeName, nativeHandler, capture;\n        const win = window;\n        const defaultNativeHandler = evt => {\n          self.executeHandlers(fix(evt || win.event), id);\n        };\n        if (!target || target.nodeType === 3 || target.nodeType === 8) {\n          return;\n        }\n        if (!target[self.expando]) {\n          id = self.count++;\n          target[self.expando] = id;\n          self.events[id] = {};\n        } else {\n          id = target[self.expando];\n        }\n        scope = scope || target;\n        const namesList = names.split(' ');\n        i = namesList.length;\n        while (i--) {\n          name = namesList[i];\n          nativeHandler = defaultNativeHandler;\n          fakeName = capture = false;\n          if (name === 'DOMContentLoaded') {\n            name = 'ready';\n          }\n          if (self.domLoaded && name === 'ready' && target.readyState === 'complete') {\n            callback.call(scope, fix({ type: name }));\n            continue;\n          }\n          if (!self.hasMouseEnterLeave) {\n            fakeName = self.mouseEnterLeave[name];\n            if (fakeName) {\n              nativeHandler = evt => {\n                const current = evt.currentTarget;\n                let related = evt.relatedTarget;\n                if (related && current.contains) {\n                  related = current.contains(related);\n                } else {\n                  while (related && related !== current) {\n                    related = related.parentNode;\n                  }\n                }\n                if (!related) {\n                  evt = fix(evt || win.event);\n                  evt.type = evt.type === 'mouseout' ? 'mouseleave' : 'mouseenter';\n                  evt.target = current;\n                  self.executeHandlers(evt, id);\n                }\n              };\n            }\n          }\n          if (!self.hasFocusIn && (name === 'focusin' || name === 'focusout')) {\n            capture = true;\n            fakeName = name === 'focusin' ? 'focus' : 'blur';\n            nativeHandler = evt => {\n              evt = fix(evt || win.event);\n              evt.type = evt.type === 'focus' ? 'focusin' : 'focusout';\n              self.executeHandlers(evt, id);\n            };\n          }\n          callbackList = self.events[id][name];\n          if (!callbackList) {\n            self.events[id][name] = callbackList = [{\n                func: callback,\n                scope\n              }];\n            callbackList.fakeName = fakeName;\n            callbackList.capture = capture;\n            callbackList.nativeHandler = nativeHandler;\n            if (name === 'ready') {\n              bindOnReady(target, nativeHandler, self);\n            } else {\n              addEvent(target, fakeName || name, nativeHandler, capture);\n            }\n          } else {\n            if (name === 'ready' && self.domLoaded) {\n              callback(fix({ type: name }));\n            } else {\n              callbackList.push({\n                func: callback,\n                scope\n              });\n            }\n          }\n        }\n        target = callbackList = null;\n        return callback;\n      }\n      unbind(target, names, callback) {\n        let callbackList, i, ci, name, eventMap;\n        if (!target || target.nodeType === 3 || target.nodeType === 8) {\n          return this;\n        }\n        const id = target[this.expando];\n        if (id) {\n          eventMap = this.events[id];\n          if (names) {\n            const namesList = names.split(' ');\n            i = namesList.length;\n            while (i--) {\n              name = namesList[i];\n              callbackList = eventMap[name];\n              if (callbackList) {\n                if (callback) {\n                  ci = callbackList.length;\n                  while (ci--) {\n                    if (callbackList[ci].func === callback) {\n                      const nativeHandler = callbackList.nativeHandler;\n                      const fakeName = callbackList.fakeName, capture = callbackList.capture;\n                      callbackList = callbackList.slice(0, ci).concat(callbackList.slice(ci + 1));\n                      callbackList.nativeHandler = nativeHandler;\n                      callbackList.fakeName = fakeName;\n                      callbackList.capture = capture;\n                      eventMap[name] = callbackList;\n                    }\n                  }\n                }\n                if (!callback || callbackList.length === 0) {\n                  delete eventMap[name];\n                  removeEvent(target, callbackList.fakeName || name, callbackList.nativeHandler, callbackList.capture);\n                }\n              }\n            }\n          } else {\n            each$f(eventMap, (callbackList, name) => {\n              removeEvent(target, callbackList.fakeName || name, callbackList.nativeHandler, callbackList.capture);\n            });\n            eventMap = {};\n          }\n          for (name in eventMap) {\n            if (has$2(eventMap, name)) {\n              return this;\n            }\n          }\n          delete this.events[id];\n          try {\n            delete target[this.expando];\n          } catch (ex) {\n            target[this.expando] = null;\n          }\n        }\n        return this;\n      }\n      fire(target, name, args) {\n        return this.dispatch(target, name, args);\n      }\n      dispatch(target, name, args) {\n        let id;\n        if (!target || target.nodeType === 3 || target.nodeType === 8) {\n          return this;\n        }\n        const event = fix({\n          type: name,\n          target\n        }, args);\n        do {\n          id = target[this.expando];\n          if (id) {\n            this.executeHandlers(event, id);\n          }\n          target = target.parentNode || target.ownerDocument || target.defaultView || target.parentWindow;\n        } while (target && !event.isPropagationStopped());\n        return this;\n      }\n      clean(target) {\n        let i, children;\n        if (!target || target.nodeType === 3 || target.nodeType === 8) {\n          return this;\n        }\n        if (target[this.expando]) {\n          this.unbind(target);\n        }\n        if (!target.getElementsByTagName) {\n          target = target.document;\n        }\n        if (target && target.getElementsByTagName) {\n          this.unbind(target);\n          children = target.getElementsByTagName('*');\n          i = children.length;\n          while (i--) {\n            target = children[i];\n            if (target[this.expando]) {\n              this.unbind(target);\n            }\n          }\n        }\n        return this;\n      }\n      destroy() {\n        this.events = {};\n      }\n      cancel(e) {\n        if (e) {\n          e.preventDefault();\n          e.stopImmediatePropagation();\n        }\n        return false;\n      }\n      executeHandlers(evt, id) {\n        const container = this.events[id];\n        const callbackList = container && container[evt.type];\n        if (callbackList) {\n          for (let i = 0, l = callbackList.length; i < l; i++) {\n            const callback = callbackList[i];\n            if (callback && callback.func.call(callback.scope, evt) === false) {\n              evt.preventDefault();\n            }\n            if (evt.isImmediatePropagationStopped()) {\n              return;\n            }\n          }\n        }\n      }\n    }\n    EventUtils.Event = new EventUtils();\n\n    const each$c = Tools.each;\n    const grep = Tools.grep;\n    const internalStyleName = 'data-mce-style';\n    const legacySetAttribute = (elm, name, value) => {\n      if (isNullable(value) || value === '') {\n        remove$a(elm, name);\n      } else {\n        set$2(elm, name, value);\n      }\n    };\n    const setupAttrHooks = (styles, settings, getContext) => {\n      const keepValues = settings.keep_values;\n      const keepUrlHook = {\n        set: (elm, value, name) => {\n          const sugarElm = SugarElement.fromDom(elm);\n          if (isFunction(settings.url_converter) && isNonNullable(value)) {\n            value = settings.url_converter.call(settings.url_converter_scope || getContext(), value, name, elm[0]);\n          }\n          const internalName = 'data-mce-' + name;\n          legacySetAttribute(sugarElm, internalName, value);\n          legacySetAttribute(sugarElm, name, value);\n        },\n        get: (elm, name) => {\n          const sugarElm = SugarElement.fromDom(elm);\n          return get$9(sugarElm, 'data-mce-' + name) || get$9(sugarElm, name);\n        }\n      };\n      const attrHooks = {\n        style: {\n          set: (elm, value) => {\n            const sugarElm = SugarElement.fromDom(elm);\n            if (isObject(value)) {\n              setAll(sugarElm, value);\n              return;\n            }\n            if (keepValues) {\n              legacySetAttribute(sugarElm, internalStyleName, value);\n            }\n            remove$a(sugarElm, 'style');\n            if (isString(value)) {\n              setAll(sugarElm, styles.parse(value));\n            }\n          },\n          get: elm => {\n            const sugarElm = SugarElement.fromDom(elm);\n            const value = get$9(sugarElm, internalStyleName) || get$9(sugarElm, 'style');\n            return styles.serialize(styles.parse(value), name(sugarElm));\n          }\n        }\n      };\n      if (keepValues) {\n        attrHooks.href = attrHooks.src = keepUrlHook;\n      }\n      return attrHooks;\n    };\n    const updateInternalStyleAttr = (styles, elm) => {\n      const rawValue = get$9(elm, 'style');\n      const value = styles.serialize(styles.parse(rawValue), name(elm));\n      legacySetAttribute(elm, internalStyleName, value);\n    };\n    const findNodeIndex = (node, normalized) => {\n      let idx = 0, lastNodeType, nodeType;\n      if (node) {\n        for (lastNodeType = node.nodeType, node = node.previousSibling; node; node = node.previousSibling) {\n          nodeType = node.nodeType;\n          if (normalized && nodeType === 3) {\n            if (nodeType === lastNodeType || !node.nodeValue.length) {\n              continue;\n            }\n          }\n          idx++;\n          lastNodeType = nodeType;\n        }\n      }\n      return idx;\n    };\n    const numericalCssMap = Tools.makeMap('fill-opacity font-weight line-height opacity orphans widows z-index zoom', ' ');\n    const camelCaseToHyphens = name => name.replace(/[A-Z]/g, v => '-' + v.toLowerCase());\n    const DOMUtils = (doc, settings = {}) => {\n      const addedStyles = {};\n      const win = window;\n      const files = {};\n      let counter = 0;\n      const stdMode = true;\n      const boxModel = true;\n      const styleSheetLoader = instance.forElement(SugarElement.fromDom(doc), {\n        contentCssCors: settings.contentCssCors,\n        referrerPolicy: settings.referrerPolicy\n      });\n      const boundEvents = [];\n      const schema = settings.schema ? settings.schema : Schema({});\n      const styles = Styles({\n        url_converter: settings.url_converter,\n        url_converter_scope: settings.url_converter_scope\n      }, settings.schema);\n      const events = settings.ownEvents ? new EventUtils() : EventUtils.Event;\n      const blockElementsMap = schema.getBlockElements();\n      const isBlock = node => {\n        if (isString(node)) {\n          return has$2(blockElementsMap, node);\n        } else {\n          return isElement$6(node) && has$2(blockElementsMap, node.nodeName);\n        }\n      };\n      const get = elm => elm && doc && isString(elm) ? doc.getElementById(elm) : elm;\n      const _get = elm => {\n        const value = get(elm);\n        return isNonNullable(value) ? SugarElement.fromDom(value) : null;\n      };\n      const getAttrib = (elm, name, defaultVal) => {\n        let value;\n        const $elm = _get(elm);\n        if (isNonNullable($elm) && isElement$7($elm)) {\n          const hook = attrHooks[name];\n          if (hook && hook.get) {\n            value = hook.get($elm.dom, name);\n          } else {\n            value = get$9($elm, name);\n          }\n        }\n        return isNonNullable(value) ? value : defaultVal !== null && defaultVal !== void 0 ? defaultVal : '';\n      };\n      const getAttribs = elm => {\n        const node = get(elm);\n        return isNullable(node) ? [] : node.attributes;\n      };\n      const setAttrib = (elm, name, value) => {\n        run(elm, e => {\n          if (isElement$6(e)) {\n            const $elm = SugarElement.fromDom(e);\n            if (value === '') {\n              value = null;\n            }\n            const originalValue = get$9($elm, name);\n            const hook = attrHooks[name];\n            if (hook && hook.set) {\n              hook.set($elm.dom, value, name);\n            } else {\n              legacySetAttribute($elm, name, value);\n            }\n            if (originalValue !== value && settings.onSetAttrib) {\n              settings.onSetAttrib({\n                attrElm: $elm,\n                attrName: name,\n                attrValue: value\n              });\n            }\n          }\n        });\n      };\n      const clone = (node, deep) => {\n        return node.cloneNode(deep);\n      };\n      const getRoot = () => settings.root_element || doc.body;\n      const getViewPort = argWin => {\n        const vp = getBounds(argWin);\n        return {\n          x: vp.x,\n          y: vp.y,\n          w: vp.width,\n          h: vp.height\n        };\n      };\n      const getPos$1 = (elm, rootElm) => getPos(doc.body, get(elm), rootElm);\n      const setStyle = (elm, name, value) => {\n        const convertStyleToString = (cssValue, cssName) => {\n          if (isString(cssValue)) {\n            return cssValue;\n          } else if (isNumber(cssValue)) {\n            return has$2(numericalCssMap, cssName) ? cssValue + '' : cssValue + 'px';\n          } else {\n            return map$2(cssValue, convertStyleToString);\n          }\n        };\n        const applyStyle = ($elm, cssName, cssValue) => {\n          const normalizedName = camelCaseToHyphens(cssName);\n          if (isNullable(cssValue) || cssValue === '') {\n            remove$6($elm, normalizedName);\n          } else {\n            set$1($elm, normalizedName, convertStyleToString(cssValue, normalizedName));\n          }\n        };\n        run(elm, e => {\n          const $elm = SugarElement.fromDom(e);\n          if (isString(name)) {\n            applyStyle($elm, name, value);\n          } else {\n            each$f(name, (v, n) => {\n              applyStyle($elm, n, v);\n            });\n          }\n          if (settings.update_styles) {\n            updateInternalStyleAttr(styles, $elm);\n          }\n        });\n      };\n      const setStyles = (elm, stylesArg) => {\n        setStyle(elm, stylesArg);\n      };\n      const getStyle = (elm, name, computed) => {\n        const $elm = get(elm);\n        if (isNullable($elm) || !isElement$6($elm)) {\n          return undefined;\n        }\n        if (computed) {\n          return get$7(SugarElement.fromDom($elm), camelCaseToHyphens(name));\n        } else {\n          name = name.replace(/-(\\D)/g, (a, b) => b.toUpperCase());\n          if (name === 'float') {\n            name = 'cssFloat';\n          }\n          return $elm.style ? $elm.style[name] : undefined;\n        }\n      };\n      const getSize = elm => {\n        let w, h;\n        const $elm = get(elm);\n        w = getStyle($elm, 'width');\n        h = getStyle($elm, 'height');\n        if (w.indexOf('px') === -1) {\n          w = 0;\n        }\n        if (h.indexOf('px') === -1) {\n          h = 0;\n        }\n        return {\n          w: parseInt(w, 10) || $elm.offsetWidth || $elm.clientWidth,\n          h: parseInt(h, 10) || $elm.offsetHeight || $elm.clientHeight\n        };\n      };\n      const getRect = elm => {\n        const $elm = get(elm);\n        const pos = getPos$1($elm);\n        const size = getSize($elm);\n        return {\n          x: pos.x,\n          y: pos.y,\n          w: size.w,\n          h: size.h\n        };\n      };\n      const is = (elm, selector) => {\n        if (!elm) {\n          return false;\n        }\n        const elms = isArray$1(elm) ? elm : [elm];\n        return exists(elms, e => {\n          return is$1(SugarElement.fromDom(e), selector);\n        });\n      };\n      const getParents = (elm, selector, root, collect) => {\n        const result = [];\n        let selectorVal;\n        let node = get(elm);\n        collect = collect === undefined;\n        root = root || (getRoot().nodeName !== 'BODY' ? getRoot().parentNode : null);\n        if (isString(selector)) {\n          selectorVal = selector;\n          if (selector === '*') {\n            selector = isElement$6;\n          } else {\n            selector = node => is(node, selectorVal);\n          }\n        }\n        while (node) {\n          if (node === root || isNullable(node.nodeType) || isDocument$1(node) || isDocumentFragment(node)) {\n            break;\n          }\n          if (!selector || selector(node)) {\n            if (collect) {\n              result.push(node);\n            } else {\n              return [node];\n            }\n          }\n          node = node.parentNode;\n        }\n        return collect ? result : null;\n      };\n      const getParent = (node, selector, root) => {\n        const parents = getParents(node, selector, root, false);\n        return parents && parents.length > 0 ? parents[0] : null;\n      };\n      const _findSib = (node, selector, name) => {\n        let func = selector;\n        if (node) {\n          if (isString(selector)) {\n            func = node => {\n              return is(node, selector);\n            };\n          }\n          for (node = node[name]; node; node = node[name]) {\n            if (isFunction(func) && func(node)) {\n              return node;\n            }\n          }\n        }\n        return null;\n      };\n      const getNext = (node, selector) => _findSib(node, selector, 'nextSibling');\n      const getPrev = (node, selector) => _findSib(node, selector, 'previousSibling');\n      const select = (selector, scope) => {\n        var _a, _b;\n        const elm = (_b = (_a = get(scope)) !== null && _a !== void 0 ? _a : settings.root_element) !== null && _b !== void 0 ? _b : doc;\n        return from(elm.querySelectorAll(selector));\n      };\n      const run = function (elm, func, scope) {\n        const context = scope !== null && scope !== void 0 ? scope : this;\n        const node = isString(elm) ? get(elm) : elm;\n        if (!node) {\n          return false;\n        }\n        if (isArray$1(node) && (node.length || node.length === 0)) {\n          const result = [];\n          each$c(node, (elm, i) => {\n            if (elm) {\n              result.push(func.call(context, isString(elm) ? get(elm) : elm, i));\n            }\n          });\n          return result;\n        } else {\n          return func.call(context, node);\n        }\n      };\n      const setAttribs = (elm, attrs) => {\n        run(elm, $elm => {\n          each$f(attrs, (value, name) => {\n            setAttrib($elm, name, value);\n          });\n        });\n      };\n      const setHTML = (elm, html) => {\n        run(elm, e => {\n          const $elm = SugarElement.fromDom(e);\n          set($elm, html);\n        });\n      };\n      const add = (parentElm, name, attrs, html, create) => run(parentElm, parentElm => {\n        const newElm = isString(name) ? doc.createElement(name) : name;\n        if (isNonNullable(attrs)) {\n          setAttribs(newElm, attrs);\n        }\n        if (html) {\n          if (!isString(html) && html.nodeType) {\n            newElm.appendChild(html);\n          } else if (isString(html)) {\n            setHTML(newElm, html);\n          }\n        }\n        return !create ? parentElm.appendChild(newElm) : newElm;\n      });\n      const create = (name, attrs, html) => add(doc.createElement(name), name, attrs, html, true);\n      const decode = Entities.decode;\n      const encode = Entities.encodeAllRaw;\n      const createHTML = (name, attrs, html = '') => {\n        let outHtml = '', key;\n        outHtml += '<' + name;\n        for (key in attrs) {\n          if (hasNonNullableKey(attrs, key)) {\n            outHtml += ' ' + key + '=\"' + encode(attrs[key]) + '\"';\n          }\n        }\n        if (isEmpty$3(html) && has$2(schema.getVoidElements(), name)) {\n          return outHtml + ' />';\n        } else {\n          return outHtml + '>' + html + '</' + name + '>';\n        }\n      };\n      const createFragment = html => {\n        let node;\n        const container = doc.createElement('div');\n        const frag = doc.createDocumentFragment();\n        frag.appendChild(container);\n        if (html) {\n          container.innerHTML = html;\n        }\n        while (node = container.firstChild) {\n          frag.appendChild(node);\n        }\n        frag.removeChild(container);\n        return frag;\n      };\n      const remove = (node, keepChildren) => {\n        return run(node, n => {\n          const $node = SugarElement.fromDom(n);\n          if (keepChildren) {\n            each$g(children($node), child => {\n              if (isText$9(child) && child.dom.length === 0) {\n                remove$5(child);\n              } else {\n                before$3($node, child);\n              }\n            });\n          }\n          remove$5($node);\n          return $node.dom;\n        });\n      };\n      const removeAllAttribs = e => run(e, e => {\n        const attrs = e.attributes;\n        for (let i = attrs.length - 1; i >= 0; i--) {\n          e.removeAttributeNode(attrs.item(i));\n        }\n      });\n      const parseStyle = cssText => styles.parse(cssText);\n      const serializeStyle = (stylesArg, name) => styles.serialize(stylesArg, name);\n      const addStyle = cssText => {\n        let head, styleElm;\n        if (self !== DOMUtils.DOM && doc === document) {\n          if (addedStyles[cssText]) {\n            return;\n          }\n          addedStyles[cssText] = true;\n        }\n        styleElm = doc.getElementById('mceDefaultStyles');\n        if (!styleElm) {\n          styleElm = doc.createElement('style');\n          styleElm.id = 'mceDefaultStyles';\n          styleElm.type = 'text/css';\n          head = doc.getElementsByTagName('head')[0];\n          if (head.firstChild) {\n            head.insertBefore(styleElm, head.firstChild);\n          } else {\n            head.appendChild(styleElm);\n          }\n        }\n        if (styleElm.styleSheet) {\n          styleElm.styleSheet.cssText += cssText;\n        } else {\n          styleElm.appendChild(doc.createTextNode(cssText));\n        }\n      };\n      const loadCSS = urls => {\n        if (!urls) {\n          urls = '';\n        }\n        each$g(urls.split(','), url => {\n          files[url] = true;\n          styleSheetLoader.load(url).catch(noop);\n        });\n      };\n      const toggleClass = (elm, cls, state) => {\n        run(elm, e => {\n          if (isElement$6(e)) {\n            const $elm = SugarElement.fromDom(e);\n            const classes = cls.split(' ');\n            each$g(classes, c => {\n              if (isNonNullable(state)) {\n                const fn = state ? add$2 : remove$7;\n                fn($elm, c);\n              } else {\n                toggle$1($elm, c);\n              }\n            });\n          }\n        });\n      };\n      const addClass = (elm, cls) => {\n        toggleClass(elm, cls, true);\n      };\n      const removeClass = (elm, cls) => {\n        toggleClass(elm, cls, false);\n      };\n      const hasClass = (elm, cls) => {\n        const $elm = _get(elm);\n        const classes = cls.split(' ');\n        return forall(classes, c => has($elm, c));\n      };\n      const show = elm => {\n        run(elm, e => remove$6(SugarElement.fromDom(e), 'display'));\n      };\n      const hide = elm => {\n        run(elm, e => set$1(SugarElement.fromDom(e), 'display', 'none'));\n      };\n      const isHidden = elm => {\n        const $elm = _get(elm);\n        return is$2(getRaw$1($elm, 'display'), 'none');\n      };\n      const uniqueId = prefix => (!prefix ? 'mce_' : prefix) + counter++;\n      const getOuterHTML = elm => {\n        const $elm = _get(elm);\n        return isElement$6($elm.dom) ? $elm.dom.outerHTML : getOuter($elm);\n      };\n      const setOuterHTML = (elm, html) => {\n        run(elm, $elm => {\n          if (isElement$6($elm)) {\n            $elm.outerHTML = html;\n          }\n        });\n      };\n      const insertAfter = (node, reference) => {\n        const referenceNode = get(reference);\n        return run(node, node => {\n          const parent = referenceNode.parentNode;\n          const nextSibling = referenceNode.nextSibling;\n          if (nextSibling) {\n            parent.insertBefore(node, nextSibling);\n          } else {\n            parent.appendChild(node);\n          }\n          return node;\n        });\n      };\n      const replace = (newElm, oldElm, keepChildren) => run(oldElm, oldElm => {\n        if (isArray$1(oldElm)) {\n          newElm = newElm.cloneNode(true);\n        }\n        if (keepChildren) {\n          each$c(grep(oldElm.childNodes), node => {\n            newElm.appendChild(node);\n          });\n        }\n        return oldElm.parentNode.replaceChild(newElm, oldElm);\n      });\n      const rename = (elm, name) => {\n        let newElm;\n        if (elm.nodeName !== name.toUpperCase()) {\n          newElm = create(name);\n          each$c(getAttribs(elm), attrNode => {\n            setAttrib(newElm, attrNode.nodeName, getAttrib(elm, attrNode.nodeName));\n          });\n          replace(newElm, elm, true);\n        }\n        return newElm || elm;\n      };\n      const findCommonAncestor = (a, b) => {\n        let ps = a, pe;\n        while (ps) {\n          pe = b;\n          while (pe && ps !== pe) {\n            pe = pe.parentNode;\n          }\n          if (ps === pe) {\n            break;\n          }\n          ps = ps.parentNode;\n        }\n        if (!ps && a.ownerDocument) {\n          return a.ownerDocument.documentElement;\n        }\n        return ps;\n      };\n      const isNonEmptyElement = node => {\n        if (isElement$6(node)) {\n          const isNamedAnchor = node.nodeName.toLowerCase() === 'a' && !getAttrib(node, 'href') && getAttrib(node, 'id');\n          if (getAttrib(node, 'name') || getAttrib(node, 'data-mce-bookmark') || isNamedAnchor) {\n            return true;\n          }\n        }\n        return false;\n      };\n      const isEmpty = (node, elements) => {\n        let type, name, brCount = 0;\n        if (isNonEmptyElement(node)) {\n          return false;\n        }\n        node = node.firstChild;\n        if (node) {\n          const walker = new DomTreeWalker(node, node.parentNode);\n          const whitespace = schema ? schema.getWhitespaceElements() : {};\n          elements = elements || (schema ? schema.getNonEmptyElements() : null);\n          do {\n            type = node.nodeType;\n            if (isElement$6(node)) {\n              const bogusVal = node.getAttribute('data-mce-bogus');\n              if (bogusVal) {\n                node = walker.next(bogusVal === 'all');\n                continue;\n              }\n              name = node.nodeName.toLowerCase();\n              if (elements && elements[name]) {\n                if (name === 'br') {\n                  brCount++;\n                  node = walker.next();\n                  continue;\n                }\n                return false;\n              }\n              if (isNonEmptyElement(node)) {\n                return false;\n              }\n            }\n            if (type === 8) {\n              return false;\n            }\n            if (type === 3 && !isWhitespaceText(node.nodeValue)) {\n              return false;\n            }\n            if (type === 3 && node.parentNode && whitespace[node.parentNode.nodeName] && isWhitespaceText(node.nodeValue)) {\n              return false;\n            }\n            node = walker.next();\n          } while (node);\n        }\n        return brCount <= 1;\n      };\n      const createRng = () => doc.createRange();\n      const split = (parentElm, splitElm, replacementElm) => {\n        let range = createRng();\n        let beforeFragment;\n        let afterFragment;\n        let parentNode;\n        if (parentElm && splitElm) {\n          range.setStart(parentElm.parentNode, findNodeIndex(parentElm));\n          range.setEnd(splitElm.parentNode, findNodeIndex(splitElm));\n          beforeFragment = range.extractContents();\n          range = createRng();\n          range.setStart(splitElm.parentNode, findNodeIndex(splitElm) + 1);\n          range.setEnd(parentElm.parentNode, findNodeIndex(parentElm) + 1);\n          afterFragment = range.extractContents();\n          parentNode = parentElm.parentNode;\n          parentNode.insertBefore(trimNode(self, beforeFragment), parentElm);\n          if (replacementElm) {\n            parentNode.insertBefore(replacementElm, parentElm);\n          } else {\n            parentNode.insertBefore(splitElm, parentElm);\n          }\n          parentNode.insertBefore(trimNode(self, afterFragment), parentElm);\n          remove(parentElm);\n          return replacementElm || splitElm;\n        }\n      };\n      const bind = (target, name, func, scope) => {\n        if (isArray$1(target)) {\n          let i = target.length;\n          const rv = [];\n          while (i--) {\n            rv[i] = bind(target[i], name, func, scope);\n          }\n          return rv;\n        } else {\n          if (settings.collect && (target === doc || target === win)) {\n            boundEvents.push([\n              target,\n              name,\n              func,\n              scope\n            ]);\n          }\n          return events.bind(target, name, func, scope || self);\n        }\n      };\n      const unbind = (target, name, func) => {\n        if (isArray$1(target)) {\n          let i = target.length;\n          const rv = [];\n          while (i--) {\n            rv[i] = unbind(target[i], name, func);\n          }\n          return rv;\n        } else {\n          if (boundEvents.length > 0 && (target === doc || target === win)) {\n            let i = boundEvents.length;\n            while (i--) {\n              const item = boundEvents[i];\n              if (target === item[0] && (!name || name === item[1]) && (!func || func === item[2])) {\n                events.unbind(item[0], item[1], item[2]);\n              }\n            }\n          }\n          return events.unbind(target, name, func);\n        }\n      };\n      const dispatch = (target, name, evt) => events.dispatch(target, name, evt);\n      const fire = (target, name, evt) => events.dispatch(target, name, evt);\n      const getContentEditable = node => {\n        if (node && isElement$6(node)) {\n          const contentEditable = node.getAttribute('data-mce-contenteditable');\n          if (contentEditable && contentEditable !== 'inherit') {\n            return contentEditable;\n          }\n          return node.contentEditable !== 'inherit' ? node.contentEditable : null;\n        } else {\n          return null;\n        }\n      };\n      const getContentEditableParent = node => {\n        const root = getRoot();\n        let state = null;\n        for (; node && node !== root; node = node.parentNode) {\n          state = getContentEditable(node);\n          if (state !== null) {\n            break;\n          }\n        }\n        return state;\n      };\n      const destroy = () => {\n        if (boundEvents.length > 0) {\n          let i = boundEvents.length;\n          while (i--) {\n            const item = boundEvents[i];\n            events.unbind(item[0], item[1], item[2]);\n          }\n        }\n        each$f(files, (_, url) => {\n          styleSheetLoader.unload(url);\n          delete files[url];\n        });\n      };\n      const isChildOf = (node, parent) => {\n        return node === parent || parent.contains(node);\n      };\n      const dumpRng = r => 'startContainer: ' + r.startContainer.nodeName + ', startOffset: ' + r.startOffset + ', endContainer: ' + r.endContainer.nodeName + ', endOffset: ' + r.endOffset;\n      const self = {\n        doc,\n        settings,\n        win,\n        files,\n        stdMode,\n        boxModel,\n        styleSheetLoader,\n        boundEvents,\n        styles,\n        schema,\n        events,\n        isBlock,\n        root: null,\n        clone,\n        getRoot,\n        getViewPort,\n        getRect,\n        getSize,\n        getParent,\n        getParents,\n        get,\n        getNext,\n        getPrev,\n        select,\n        is,\n        add,\n        create,\n        createHTML,\n        createFragment,\n        remove,\n        setStyle,\n        getStyle,\n        setStyles,\n        removeAllAttribs,\n        setAttrib,\n        setAttribs,\n        getAttrib,\n        getPos: getPos$1,\n        parseStyle,\n        serializeStyle,\n        addStyle,\n        loadCSS,\n        addClass,\n        removeClass,\n        hasClass,\n        toggleClass,\n        show,\n        hide,\n        isHidden,\n        uniqueId,\n        setHTML,\n        getOuterHTML,\n        setOuterHTML,\n        decode,\n        encode,\n        insertAfter,\n        replace,\n        rename,\n        findCommonAncestor,\n        run,\n        getAttribs,\n        isEmpty,\n        createRng,\n        nodeIndex: findNodeIndex,\n        split,\n        bind: bind,\n        unbind: unbind,\n        fire,\n        dispatch,\n        getContentEditable,\n        getContentEditableParent,\n        destroy,\n        isChildOf,\n        dumpRng\n      };\n      const attrHooks = setupAttrHooks(styles, settings, constant(self));\n      return self;\n    };\n    DOMUtils.DOM = DOMUtils(document);\n    DOMUtils.nodeIndex = findNodeIndex;\n\n    const DOM$b = DOMUtils.DOM;\n    const QUEUED = 0;\n    const LOADING = 1;\n    const LOADED = 2;\n    const FAILED = 3;\n    class ScriptLoader {\n      constructor(settings = {}) {\n        this.states = {};\n        this.queue = [];\n        this.scriptLoadedCallbacks = {};\n        this.queueLoadedCallbacks = [];\n        this.loading = false;\n        this.settings = settings;\n      }\n      _setReferrerPolicy(referrerPolicy) {\n        this.settings.referrerPolicy = referrerPolicy;\n      }\n      loadScript(url) {\n        return new Promise((resolve, reject) => {\n          const dom = DOM$b;\n          let elm;\n          const cleanup = () => {\n            dom.remove(id);\n            if (elm) {\n              elm.onerror = elm.onload = elm = null;\n            }\n          };\n          const done = () => {\n            cleanup();\n            resolve();\n          };\n          const error = () => {\n            cleanup();\n            reject('Failed to load script: ' + url);\n          };\n          const id = dom.uniqueId();\n          elm = document.createElement('script');\n          elm.id = id;\n          elm.type = 'text/javascript';\n          elm.src = Tools._addCacheSuffix(url);\n          if (this.settings.referrerPolicy) {\n            dom.setAttrib(elm, 'referrerpolicy', this.settings.referrerPolicy);\n          }\n          elm.onload = done;\n          elm.onerror = error;\n          (document.getElementsByTagName('head')[0] || document.body).appendChild(elm);\n        });\n      }\n      isDone(url) {\n        return this.states[url] === LOADED;\n      }\n      markDone(url) {\n        this.states[url] = LOADED;\n      }\n      add(url) {\n        const self = this;\n        self.queue.push(url);\n        const state = self.states[url];\n        if (state === undefined) {\n          self.states[url] = QUEUED;\n        }\n        return new Promise((resolve, reject) => {\n          if (!self.scriptLoadedCallbacks[url]) {\n            self.scriptLoadedCallbacks[url] = [];\n          }\n          self.scriptLoadedCallbacks[url].push({\n            resolve,\n            reject\n          });\n        });\n      }\n      load(url) {\n        return this.add(url);\n      }\n      remove(url) {\n        delete this.states[url];\n        delete this.scriptLoadedCallbacks[url];\n      }\n      loadQueue() {\n        const queue = this.queue;\n        this.queue = [];\n        return this.loadScripts(queue);\n      }\n      loadScripts(scripts) {\n        const self = this;\n        const execCallbacks = (name, url) => {\n          get$a(self.scriptLoadedCallbacks, url).each(callbacks => {\n            each$g(callbacks, callback => callback[name](url));\n          });\n          delete self.scriptLoadedCallbacks[url];\n        };\n        const processResults = results => {\n          const failures = filter$6(results, result => result.status === 'rejected');\n          if (failures.length > 0) {\n            return Promise.reject(bind$3(failures, ({reason}) => isArray$1(reason) ? reason : [reason]));\n          } else {\n            return Promise.resolve();\n          }\n        };\n        const load = urls => Promise.allSettled(map$3(urls, url => {\n          if (self.states[url] === LOADED) {\n            execCallbacks('resolve', url);\n            return Promise.resolve();\n          } else if (self.states[url] === FAILED) {\n            execCallbacks('reject', url);\n            return Promise.reject(url);\n          } else {\n            self.states[url] = LOADING;\n            return self.loadScript(url).then(() => {\n              self.states[url] = LOADED;\n              execCallbacks('resolve', url);\n              const queue = self.queue;\n              if (queue.length > 0) {\n                self.queue = [];\n                return load(queue).then(processResults);\n              }\n            }, () => {\n              self.states[url] = FAILED;\n              execCallbacks('reject', url);\n              return Promise.reject(url);\n            });\n          }\n        }));\n        const processQueue = urls => {\n          self.loading = true;\n          return load(urls).then(results => {\n            self.loading = false;\n            const nextQueuedItem = self.queueLoadedCallbacks.shift();\n            Optional.from(nextQueuedItem).each(call);\n            return processResults(results);\n          });\n        };\n        const uniqueScripts = stringArray(scripts);\n        if (self.loading) {\n          return new Promise((resolve, reject) => {\n            self.queueLoadedCallbacks.push(() => processQueue(uniqueScripts).then(resolve, reject));\n          });\n        } else {\n          return processQueue(uniqueScripts);\n        }\n      }\n    }\n    ScriptLoader.ScriptLoader = new ScriptLoader();\n\n    const Cell = initial => {\n      let value = initial;\n      const get = () => {\n        return value;\n      };\n      const set = v => {\n        value = v;\n      };\n      return {\n        get,\n        set\n      };\n    };\n\n    const isRaw = str => isObject(str) && has$2(str, 'raw');\n    const isTokenised = str => isArray$1(str) && str.length > 1;\n    const data = {};\n    const currentCode = Cell('en');\n    const getLanguageData = () => get$a(data, currentCode.get());\n    const getData$1 = () => map$2(data, value => ({ ...value }));\n    const setCode = newCode => {\n      if (newCode) {\n        currentCode.set(newCode);\n      }\n    };\n    const getCode = () => currentCode.get();\n    const add$1 = (code, items) => {\n      let langData = data[code];\n      if (!langData) {\n        data[code] = langData = {};\n      }\n      each$f(items, (translation, name) => {\n        langData[name.toLowerCase()] = translation;\n      });\n    };\n    const translate = text => {\n      const langData = getLanguageData().getOr({});\n      const toString = obj => {\n        if (isFunction(obj)) {\n          return Object.prototype.toString.call(obj);\n        }\n        return !isEmpty(obj) ? '' + obj : '';\n      };\n      const isEmpty = text => text === '' || text === null || text === undefined;\n      const getLangData = text => {\n        const textstr = toString(text);\n        return get$a(langData, textstr.toLowerCase()).map(toString).getOr(textstr);\n      };\n      const removeContext = str => str.replace(/{context:\\w+}$/, '');\n      if (isEmpty(text)) {\n        return '';\n      }\n      if (isRaw(text)) {\n        return toString(text.raw);\n      }\n      if (isTokenised(text)) {\n        const values = text.slice(1);\n        const substitued = getLangData(text[0]).replace(/\\{([0-9]+)\\}/g, ($1, $2) => has$2(values, $2) ? toString(values[$2]) : $1);\n        return removeContext(substitued);\n      }\n      return removeContext(getLangData(text));\n    };\n    const isRtl$1 = () => getLanguageData().bind(items => get$a(items, '_dir')).exists(dir => dir === 'rtl');\n    const hasCode = code => has$2(data, code);\n    const I18n = {\n      getData: getData$1,\n      setCode,\n      getCode,\n      add: add$1,\n      translate,\n      isRtl: isRtl$1,\n      hasCode\n    };\n\n    const AddOnManager = () => {\n      const items = [];\n      const urls = {};\n      const lookup = {};\n      const _listeners = [];\n      const runListeners = (name, state) => {\n        const matchedListeners = filter$6(_listeners, listener => listener.name === name && listener.state === state);\n        each$g(matchedListeners, listener => listener.resolve());\n      };\n      const isLoaded = name => has$2(urls, name);\n      const isAdded = name => has$2(lookup, name);\n      const get = name => {\n        if (lookup[name]) {\n          return lookup[name].instance;\n        }\n        return undefined;\n      };\n      const loadLanguagePack = (name, languages) => {\n        const language = I18n.getCode();\n        const wrappedLanguages = ',' + (languages || '') + ',';\n        if (!language || languages && wrappedLanguages.indexOf(',' + language + ',') === -1) {\n          return;\n        }\n        ScriptLoader.ScriptLoader.add(urls[name] + '/langs/' + language + '.js');\n      };\n      const requireLangPack = (name, languages) => {\n        if (AddOnManager.languageLoad !== false) {\n          if (isLoaded(name)) {\n            loadLanguagePack(name, languages);\n          } else {\n            waitFor(name, 'loaded').then(() => loadLanguagePack(name, languages));\n          }\n        }\n      };\n      const add = (id, addOn) => {\n        items.push(addOn);\n        lookup[id] = { instance: addOn };\n        runListeners(id, 'added');\n        return addOn;\n      };\n      const remove = name => {\n        delete urls[name];\n        delete lookup[name];\n      };\n      const createUrl = (baseUrl, dep) => {\n        if (isString(dep)) {\n          return isString(baseUrl) ? {\n            prefix: '',\n            resource: dep,\n            suffix: ''\n          } : {\n            prefix: baseUrl.prefix,\n            resource: dep,\n            suffix: baseUrl.suffix\n          };\n        } else {\n          return dep;\n        }\n      };\n      const load = (name, addOnUrl) => {\n        if (urls[name]) {\n          return Promise.resolve();\n        }\n        let urlString = isString(addOnUrl) ? addOnUrl : addOnUrl.prefix + addOnUrl.resource + addOnUrl.suffix;\n        if (urlString.indexOf('/') !== 0 && urlString.indexOf('://') === -1) {\n          urlString = AddOnManager.baseURL + '/' + urlString;\n        }\n        urls[name] = urlString.substring(0, urlString.lastIndexOf('/'));\n        const done = () => {\n          runListeners(name, 'loaded');\n          return Promise.resolve();\n        };\n        if (lookup[name]) {\n          return done();\n        } else {\n          return ScriptLoader.ScriptLoader.add(urlString).then(done);\n        }\n      };\n      const waitFor = (name, state = 'added') => {\n        if (state === 'added' && isAdded(name)) {\n          return Promise.resolve();\n        } else if (state === 'loaded' && isLoaded(name)) {\n          return Promise.resolve();\n        } else {\n          return new Promise(resolve => {\n            _listeners.push({\n              name,\n              state,\n              resolve\n            });\n          });\n        }\n      };\n      return {\n        items,\n        urls,\n        lookup,\n        get,\n        requireLangPack,\n        add,\n        remove,\n        createUrl,\n        load,\n        waitFor\n      };\n    };\n    AddOnManager.languageLoad = true;\n    AddOnManager.baseURL = '';\n    AddOnManager.PluginManager = AddOnManager();\n    AddOnManager.ThemeManager = AddOnManager();\n    AddOnManager.ModelManager = AddOnManager();\n\n    const singleton = doRevoke => {\n      const subject = Cell(Optional.none());\n      const revoke = () => subject.get().each(doRevoke);\n      const clear = () => {\n        revoke();\n        subject.set(Optional.none());\n      };\n      const isSet = () => subject.get().isSome();\n      const get = () => subject.get();\n      const set = s => {\n        revoke();\n        subject.set(Optional.some(s));\n      };\n      return {\n        clear,\n        isSet,\n        get,\n        set\n      };\n    };\n    const value$2 = () => {\n      const subject = singleton(noop);\n      const on = f => subject.get().each(f);\n      return {\n        ...subject,\n        on\n      };\n    };\n\n    const first$1 = (fn, rate) => {\n      let timer = null;\n      const cancel = () => {\n        if (!isNull(timer)) {\n          clearTimeout(timer);\n          timer = null;\n        }\n      };\n      const throttle = (...args) => {\n        if (isNull(timer)) {\n          timer = setTimeout(() => {\n            timer = null;\n            fn.apply(null, args);\n          }, rate);\n        }\n      };\n      return {\n        cancel,\n        throttle\n      };\n    };\n    const last$1 = (fn, rate) => {\n      let timer = null;\n      const cancel = () => {\n        if (!isNull(timer)) {\n          clearTimeout(timer);\n          timer = null;\n        }\n      };\n      const throttle = (...args) => {\n        cancel();\n        timer = setTimeout(() => {\n          timer = null;\n          fn.apply(null, args);\n        }, rate);\n      };\n      return {\n        cancel,\n        throttle\n      };\n    };\n\n    const descendants$1 = (scope, predicate) => {\n      let result = [];\n      each$g(children(scope), x => {\n        if (predicate(x)) {\n          result = result.concat([x]);\n        }\n        result = result.concat(descendants$1(x, predicate));\n      });\n      return result;\n    };\n\n    const descendants = (scope, selector) => all(selector, scope);\n\n    const annotation = constant('mce-annotation');\n    const dataAnnotation = constant('data-mce-annotation');\n    const dataAnnotationId = constant('data-mce-annotation-uid');\n    const dataAnnotationActive = constant('data-mce-annotation-active');\n\n    const identify = (editor, annotationName) => {\n      const rng = editor.selection.getRng();\n      const start = SugarElement.fromDom(rng.startContainer);\n      const root = SugarElement.fromDom(editor.getBody());\n      const selector = annotationName.fold(() => '.' + annotation(), an => `[${ dataAnnotation() }=\"${ an }\"]`);\n      const newStart = child$1(start, rng.startOffset).getOr(start);\n      const closest = closest$3(newStart, selector, n => eq(n, root));\n      const getAttr = (c, property) => {\n        if (has$1(c, property)) {\n          return Optional.some(get$9(c, property));\n        } else {\n          return Optional.none();\n        }\n      };\n      return closest.bind(c => getAttr(c, `${ dataAnnotationId() }`).bind(uid => getAttr(c, `${ dataAnnotation() }`).map(name => {\n        const elements = findMarkers(editor, uid);\n        return {\n          uid,\n          name,\n          elements\n        };\n      })));\n    };\n    const isAnnotation = elem => isElement$7(elem) && has(elem, annotation());\n    const findMarkers = (editor, uid) => {\n      const body = SugarElement.fromDom(editor.getBody());\n      return descendants(body, `[${ dataAnnotationId() }=\"${ uid }\"]`);\n    };\n    const findAll = (editor, name) => {\n      const body = SugarElement.fromDom(editor.getBody());\n      const markers = descendants(body, `[${ dataAnnotation() }=\"${ name }\"]`);\n      const directory = {};\n      each$g(markers, m => {\n        const uid = get$9(m, dataAnnotationId());\n        const nodesAlready = get$a(directory, uid).getOr([]);\n        directory[uid] = nodesAlready.concat([m]);\n      });\n      return directory;\n    };\n\n    const setup$x = (editor, registry) => {\n      const changeCallbacks = Cell({});\n      const initData = () => ({\n        listeners: [],\n        previous: value$2()\n      });\n      const withCallbacks = (name, f) => {\n        updateCallbacks(name, data => {\n          f(data);\n          return data;\n        });\n      };\n      const updateCallbacks = (name, f) => {\n        const callbackMap = changeCallbacks.get();\n        const data = get$a(callbackMap, name).getOrThunk(initData);\n        const outputData = f(data);\n        callbackMap[name] = outputData;\n        changeCallbacks.set(callbackMap);\n      };\n      const fireCallbacks = (name, uid, elements) => {\n        withCallbacks(name, data => {\n          each$g(data.listeners, f => f(true, name, {\n            uid,\n            nodes: map$3(elements, elem => elem.dom)\n          }));\n        });\n      };\n      const fireNoAnnotation = name => {\n        withCallbacks(name, data => {\n          each$g(data.listeners, f => f(false, name));\n        });\n      };\n      const toggleActiveAttr = (uid, state) => {\n        each$g(findMarkers(editor, uid), span => {\n          if (state) {\n            set$2(span, dataAnnotationActive(), 'true');\n          } else {\n            remove$a(span, dataAnnotationActive());\n          }\n        });\n      };\n      const onNodeChange = last$1(() => {\n        const annotations = sort(registry.getNames());\n        each$g(annotations, name => {\n          updateCallbacks(name, data => {\n            const prev = data.previous.get();\n            identify(editor, Optional.some(name)).fold(() => {\n              prev.each(uid => {\n                fireNoAnnotation(name);\n                data.previous.clear();\n                toggleActiveAttr(uid, false);\n              });\n            }, ({uid, name, elements}) => {\n              if (!is$2(prev, uid)) {\n                prev.each(uid => toggleActiveAttr(uid, false));\n                fireCallbacks(name, uid, elements);\n                data.previous.set(uid);\n                toggleActiveAttr(uid, true);\n              }\n            });\n            return {\n              previous: data.previous,\n              listeners: data.listeners\n            };\n          });\n        });\n      }, 30);\n      editor.on('remove', () => {\n        onNodeChange.cancel();\n      });\n      editor.on('NodeChange', () => {\n        onNodeChange.throttle();\n      });\n      const addListener = (name, f) => {\n        updateCallbacks(name, data => ({\n          previous: data.previous,\n          listeners: data.listeners.concat([f])\n        }));\n      };\n      return { addListener };\n    };\n\n    const setup$w = (editor, registry) => {\n      const identifyParserNode = span => Optional.from(span.attr(dataAnnotation())).bind(registry.lookup);\n      editor.serializer.addTempAttr(dataAnnotationActive());\n      editor.serializer.addNodeFilter('span', spans => {\n        each$g(spans, span => {\n          identifyParserNode(span).each(settings => {\n            if (settings.persistent === false) {\n              span.unwrap();\n            }\n          });\n        });\n      });\n    };\n\n    const create$b = () => {\n      const annotations = {};\n      const register = (name, settings) => {\n        annotations[name] = {\n          name,\n          settings\n        };\n      };\n      const lookup = name => get$a(annotations, name).map(a => a.settings);\n      const getNames = () => keys(annotations);\n      return {\n        register,\n        lookup,\n        getNames\n      };\n    };\n\n    let unique = 0;\n    const generate$1 = prefix => {\n      const date = new Date();\n      const time = date.getTime();\n      const random = Math.floor(Math.random() * 1000000000);\n      unique++;\n      return prefix + '_' + random + unique + String(time);\n    };\n\n    const add = (element, classes) => {\n      each$g(classes, x => {\n        add$2(element, x);\n      });\n    };\n\n    const clone$2 = (original, isDeep) => SugarElement.fromDom(original.dom.cloneNode(isDeep));\n    const shallow$1 = original => clone$2(original, false);\n    const deep$1 = original => clone$2(original, true);\n    const shallowAs = (original, tag) => {\n      const nu = SugarElement.fromTag(tag);\n      const attributes = clone$4(original);\n      setAll$1(nu, attributes);\n      return nu;\n    };\n    const mutate = (original, tag) => {\n      const nu = shallowAs(original, tag);\n      after$4(original, nu);\n      const children$1 = children(original);\n      append(nu, children$1);\n      remove$5(original);\n      return nu;\n    };\n\n    const TextWalker = (startNode, rootNode, isBoundary = never) => {\n      const walker = new DomTreeWalker(startNode, rootNode);\n      const walk = direction => {\n        let next;\n        do {\n          next = walker[direction]();\n        } while (next && !isText$8(next) && !isBoundary(next));\n        return Optional.from(next).filter(isText$8);\n      };\n      return {\n        current: () => Optional.from(walker.current()).filter(isText$8),\n        next: () => walk('next'),\n        prev: () => walk('prev'),\n        prev2: () => walk('prev2')\n      };\n    };\n\n    const TextSeeker = (dom, isBoundary) => {\n      const isBlockBoundary = isBoundary ? isBoundary : node => dom.isBlock(node) || isBr$5(node) || isContentEditableFalse$a(node);\n      const walk = (node, offset, walker, process) => {\n        if (isText$8(node)) {\n          const newOffset = process(node, offset, node.data);\n          if (newOffset !== -1) {\n            return Optional.some({\n              container: node,\n              offset: newOffset\n            });\n          }\n        }\n        return walker().bind(next => walk(next.container, next.offset, walker, process));\n      };\n      const backwards = (node, offset, process, root) => {\n        const walker = TextWalker(node, root, isBlockBoundary);\n        return walk(node, offset, () => walker.prev().map(prev => ({\n          container: prev,\n          offset: prev.length\n        })), process).getOrNull();\n      };\n      const forwards = (node, offset, process, root) => {\n        const walker = TextWalker(node, root, isBlockBoundary);\n        return walk(node, offset, () => walker.next().map(next => ({\n          container: next,\n          offset: 0\n        })), process).getOrNull();\n      };\n      return {\n        backwards,\n        forwards\n      };\n    };\n\n    const round$1 = Math.round;\n    const clone$1 = rect => {\n      if (!rect) {\n        return {\n          left: 0,\n          top: 0,\n          bottom: 0,\n          right: 0,\n          width: 0,\n          height: 0\n        };\n      }\n      return {\n        left: round$1(rect.left),\n        top: round$1(rect.top),\n        bottom: round$1(rect.bottom),\n        right: round$1(rect.right),\n        width: round$1(rect.width),\n        height: round$1(rect.height)\n      };\n    };\n    const collapse = (rect, toStart) => {\n      rect = clone$1(rect);\n      if (toStart) {\n        rect.right = rect.left;\n      } else {\n        rect.left = rect.left + rect.width;\n        rect.right = rect.left;\n      }\n      rect.width = 0;\n      return rect;\n    };\n    const isEqual = (rect1, rect2) => rect1.left === rect2.left && rect1.top === rect2.top && rect1.bottom === rect2.bottom && rect1.right === rect2.right;\n    const isValidOverflow = (overflowY, rect1, rect2) => overflowY >= 0 && overflowY <= Math.min(rect1.height, rect2.height) / 2;\n    const isAbove$1 = (rect1, rect2) => {\n      const halfHeight = Math.min(rect2.height / 2, rect1.height / 2);\n      if (rect1.bottom - halfHeight < rect2.top) {\n        return true;\n      }\n      if (rect1.top > rect2.bottom) {\n        return false;\n      }\n      return isValidOverflow(rect2.top - rect1.bottom, rect1, rect2);\n    };\n    const isBelow$1 = (rect1, rect2) => {\n      if (rect1.top > rect2.bottom) {\n        return true;\n      }\n      if (rect1.bottom < rect2.top) {\n        return false;\n      }\n      return isValidOverflow(rect2.bottom - rect1.top, rect1, rect2);\n    };\n    const containsXY = (rect, clientX, clientY) => clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom;\n    const boundingClientRectFromRects = rects => {\n      return foldl(rects, (acc, rect) => {\n        return acc.fold(() => Optional.some(rect), prevRect => {\n          const left = Math.min(rect.left, prevRect.left);\n          const top = Math.min(rect.top, prevRect.top);\n          const right = Math.max(rect.right, prevRect.right);\n          const bottom = Math.max(rect.bottom, prevRect.bottom);\n          return Optional.some({\n            top,\n            right,\n            bottom,\n            left,\n            width: right - left,\n            height: bottom - top\n          });\n        });\n      }, Optional.none());\n    };\n    const distanceToRectEdgeFromXY = (rect, x, y) => {\n      const cx = Math.max(Math.min(x, rect.left + rect.width), rect.left);\n      const cy = Math.max(Math.min(y, rect.top + rect.height), rect.top);\n      return Math.sqrt((x - cx) * (x - cx) + (y - cy) * (y - cy));\n    };\n    const overlapY = (r1, r2) => Math.max(0, Math.min(r1.bottom, r2.bottom) - Math.max(r1.top, r2.top));\n\n    const clamp$2 = (value, min, max) => Math.min(Math.max(value, min), max);\n\n    const getSelectedNode = range => {\n      const startContainer = range.startContainer, startOffset = range.startOffset;\n      if (startContainer.hasChildNodes() && range.endOffset === startOffset + 1) {\n        return startContainer.childNodes[startOffset];\n      }\n      return null;\n    };\n    const getNode$1 = (container, offset) => {\n      if (isElement$6(container) && container.hasChildNodes()) {\n        const childNodes = container.childNodes;\n        const safeOffset = clamp$2(offset, 0, childNodes.length - 1);\n        return childNodes[safeOffset];\n      } else {\n        return container;\n      }\n    };\n    const getNodeUnsafe = (container, offset) => {\n      if (offset < 0 && isElement$6(container) && container.hasChildNodes()) {\n        return undefined;\n      } else {\n        return getNode$1(container, offset);\n      }\n    };\n\n    const extendingChars = new RegExp('[\\u0300-\\u036f\\u0483-\\u0487\\u0488-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1-\\u05c2\\u05c4-\\u05c5\\u05c7\\u0610-\\u061a' + '\\u064b-\\u065f\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7-\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0' + '\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08e3-\\u0902\\u093a\\u093c' + '\\u0941-\\u0948\\u094d\\u0951-\\u0957\\u0962-\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2-\\u09e3' + '\\u0a01-\\u0a02\\u0a3c\\u0a41-\\u0a42\\u0a47-\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70-\\u0a71\\u0a75\\u0a81-\\u0a82\\u0abc' + '\\u0ac1-\\u0ac5\\u0ac7-\\u0ac8\\u0acd\\u0ae2-\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57' + '\\u0b62-\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c00\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55-\\u0c56' + '\\u0c62-\\u0c63\\u0c81\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc-\\u0ccd\\u0cd5-\\u0cd6\\u0ce2-\\u0ce3\\u0d01\\u0d3e\\u0d41-\\u0d44' + '\\u0d4d\\u0d57\\u0d62-\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9' + '\\u0ebb-\\u0ebc\\u0ec8-\\u0ecd\\u0f18-\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86-\\u0f87\\u0f8d-\\u0f97' + '\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039-\\u103a\\u103d-\\u103e\\u1058-\\u1059\\u105e-\\u1060\\u1071-\\u1074' + '\\u1082\\u1085-\\u1086\\u108d\\u109d\\u135d-\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752-\\u1753\\u1772-\\u1773\\u17b4-\\u17b5' + '\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927-\\u1928\\u1932\\u1939-\\u193b\\u1a17-\\u1a18' + '\\u1a1b\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1ab0-\\u1abd\\u1ABE\\u1b00-\\u1b03\\u1b34' + '\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80-\\u1b81\\u1ba2-\\u1ba5\\u1ba8-\\u1ba9\\u1bab-\\u1bad\\u1be6\\u1be8-\\u1be9' + '\\u1bed\\u1bef-\\u1bf1\\u1c2c-\\u1c33\\u1c36-\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1cf4\\u1cf8-\\u1cf9' + '\\u1dc0-\\u1df5\\u1dfc-\\u1dff\\u200c-\\u200d\\u20d0-\\u20dc\\u20DD-\\u20E0\\u20e1\\u20E2-\\u20E4\\u20e5-\\u20f0\\u2cef-\\u2cf1' + '\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302d\\u302e-\\u302f\\u3099-\\u309a\\ua66f\\uA670-\\uA672\\ua674-\\ua67d\\ua69e-\\ua69f\\ua6f0-\\ua6f1' + '\\ua802\\ua806\\ua80b\\ua825-\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc' + '\\ua9e5\\uaa29-\\uaa2e\\uaa31-\\uaa32\\uaa35-\\uaa36\\uaa43\\uaa4c\\uaa7c\\uaab0\\uaab2-\\uaab4\\uaab7-\\uaab8\\uaabe-\\uaabf\\uaac1' + '\\uaaec-\\uaaed\\uaaf6\\uabe5\\uabe8\\uabed\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\uff9e-\\uff9f]');\n    const isExtendingChar = ch => typeof ch === 'string' && ch.charCodeAt(0) >= 768 && extendingChars.test(ch);\n\n    const or = (...args) => {\n      return x => {\n        for (let i = 0; i < args.length; i++) {\n          if (args[i](x)) {\n            return true;\n          }\n        }\n        return false;\n      };\n    };\n    const and = (...args) => {\n      return x => {\n        for (let i = 0; i < args.length; i++) {\n          if (!args[i](x)) {\n            return false;\n          }\n        }\n        return true;\n      };\n    };\n\n    const isElement$4 = isElement$6;\n    const isCaretCandidate$2 = isCaretCandidate$3;\n    const isBlock$1 = matchStyleValues('display', 'block table');\n    const isFloated = matchStyleValues('float', 'left right');\n    const isValidElementCaretCandidate = and(isElement$4, isCaretCandidate$2, not(isFloated));\n    const isNotPre = not(matchStyleValues('white-space', 'pre pre-line pre-wrap'));\n    const isText$5 = isText$8;\n    const isBr$2 = isBr$5;\n    const nodeIndex$1 = DOMUtils.nodeIndex;\n    const resolveIndex$1 = getNodeUnsafe;\n    const createRange$1 = doc => 'createRange' in doc ? doc.createRange() : DOMUtils.DOM.createRng();\n    const isWhiteSpace$1 = chr => chr && /[\\r\\n\\t ]/.test(chr);\n    const isRange = rng => !!rng.setStart && !!rng.setEnd;\n    const isHiddenWhiteSpaceRange = range => {\n      const container = range.startContainer;\n      const offset = range.startOffset;\n      if (isWhiteSpace$1(range.toString()) && isNotPre(container.parentNode) && isText$8(container)) {\n        const text = container.data;\n        if (isWhiteSpace$1(text[offset - 1]) || isWhiteSpace$1(text[offset + 1])) {\n          return true;\n        }\n      }\n      return false;\n    };\n    const getBrClientRect = brNode => {\n      const doc = brNode.ownerDocument;\n      const rng = createRange$1(doc);\n      const nbsp$1 = doc.createTextNode(nbsp);\n      const parentNode = brNode.parentNode;\n      parentNode.insertBefore(nbsp$1, brNode);\n      rng.setStart(nbsp$1, 0);\n      rng.setEnd(nbsp$1, 1);\n      const clientRect = clone$1(rng.getBoundingClientRect());\n      parentNode.removeChild(nbsp$1);\n      return clientRect;\n    };\n    const getBoundingClientRectWebKitText = rng => {\n      const sc = rng.startContainer;\n      const ec = rng.endContainer;\n      const so = rng.startOffset;\n      const eo = rng.endOffset;\n      if (sc === ec && isText$8(ec) && so === 0 && eo === 1) {\n        const newRng = rng.cloneRange();\n        newRng.setEndAfter(ec);\n        return getBoundingClientRect$1(newRng);\n      } else {\n        return null;\n      }\n    };\n    const isZeroRect = r => r.left === 0 && r.right === 0 && r.top === 0 && r.bottom === 0;\n    const getBoundingClientRect$1 = item => {\n      let clientRect;\n      const clientRects = item.getClientRects();\n      if (clientRects.length > 0) {\n        clientRect = clone$1(clientRects[0]);\n      } else {\n        clientRect = clone$1(item.getBoundingClientRect());\n      }\n      if (!isRange(item) && isBr$2(item) && isZeroRect(clientRect)) {\n        return getBrClientRect(item);\n      }\n      if (isZeroRect(clientRect) && isRange(item)) {\n        return getBoundingClientRectWebKitText(item);\n      }\n      return clientRect;\n    };\n    const collapseAndInflateWidth = (clientRect, toStart) => {\n      const newClientRect = collapse(clientRect, toStart);\n      newClientRect.width = 1;\n      newClientRect.right = newClientRect.left + 1;\n      return newClientRect;\n    };\n    const getCaretPositionClientRects = caretPosition => {\n      const clientRects = [];\n      const addUniqueAndValidRect = clientRect => {\n        if (clientRect.height === 0) {\n          return;\n        }\n        if (clientRects.length > 0) {\n          if (isEqual(clientRect, clientRects[clientRects.length - 1])) {\n            return;\n          }\n        }\n        clientRects.push(clientRect);\n      };\n      const addCharacterOffset = (container, offset) => {\n        const range = createRange$1(container.ownerDocument);\n        if (offset < container.data.length) {\n          if (isExtendingChar(container.data[offset])) {\n            return clientRects;\n          }\n          if (isExtendingChar(container.data[offset - 1])) {\n            range.setStart(container, offset);\n            range.setEnd(container, offset + 1);\n            if (!isHiddenWhiteSpaceRange(range)) {\n              addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range), false));\n              return clientRects;\n            }\n          }\n        }\n        if (offset > 0) {\n          range.setStart(container, offset - 1);\n          range.setEnd(container, offset);\n          if (!isHiddenWhiteSpaceRange(range)) {\n            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range), false));\n          }\n        }\n        if (offset < container.data.length) {\n          range.setStart(container, offset);\n          range.setEnd(container, offset + 1);\n          if (!isHiddenWhiteSpaceRange(range)) {\n            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range), true));\n          }\n        }\n      };\n      const container = caretPosition.container();\n      const offset = caretPosition.offset();\n      if (isText$5(container)) {\n        addCharacterOffset(container, offset);\n        return clientRects;\n      }\n      if (isElement$4(container)) {\n        if (caretPosition.isAtEnd()) {\n          const node = resolveIndex$1(container, offset);\n          if (isText$5(node)) {\n            addCharacterOffset(node, node.data.length);\n          }\n          if (isValidElementCaretCandidate(node) && !isBr$2(node)) {\n            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), false));\n          }\n        } else {\n          const node = resolveIndex$1(container, offset);\n          if (isText$5(node)) {\n            addCharacterOffset(node, 0);\n          }\n          if (isValidElementCaretCandidate(node) && caretPosition.isAtEnd()) {\n            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), false));\n            return clientRects;\n          }\n          const beforeNode = resolveIndex$1(caretPosition.container(), caretPosition.offset() - 1);\n          if (isValidElementCaretCandidate(beforeNode) && !isBr$2(beforeNode)) {\n            if (isBlock$1(beforeNode) || isBlock$1(node) || !isValidElementCaretCandidate(node)) {\n              addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(beforeNode), false));\n            }\n          }\n          if (isValidElementCaretCandidate(node)) {\n            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), true));\n          }\n        }\n      }\n      return clientRects;\n    };\n    const CaretPosition = (container, offset, clientRects) => {\n      const isAtStart = () => {\n        if (isText$5(container)) {\n          return offset === 0;\n        }\n        return offset === 0;\n      };\n      const isAtEnd = () => {\n        if (isText$5(container)) {\n          return offset >= container.data.length;\n        }\n        return offset >= container.childNodes.length;\n      };\n      const toRange = () => {\n        const range = createRange$1(container.ownerDocument);\n        range.setStart(container, offset);\n        range.setEnd(container, offset);\n        return range;\n      };\n      const getClientRects = () => {\n        if (!clientRects) {\n          clientRects = getCaretPositionClientRects(CaretPosition(container, offset));\n        }\n        return clientRects;\n      };\n      const isVisible = () => getClientRects().length > 0;\n      const isEqual = caretPosition => caretPosition && container === caretPosition.container() && offset === caretPosition.offset();\n      const getNode = before => resolveIndex$1(container, before ? offset - 1 : offset);\n      return {\n        container: constant(container),\n        offset: constant(offset),\n        toRange,\n        getClientRects,\n        isVisible,\n        isAtStart,\n        isAtEnd,\n        isEqual,\n        getNode\n      };\n    };\n    CaretPosition.fromRangeStart = range => CaretPosition(range.startContainer, range.startOffset);\n    CaretPosition.fromRangeEnd = range => CaretPosition(range.endContainer, range.endOffset);\n    CaretPosition.after = node => CaretPosition(node.parentNode, nodeIndex$1(node) + 1);\n    CaretPosition.before = node => CaretPosition(node.parentNode, nodeIndex$1(node));\n    CaretPosition.isAbove = (pos1, pos2) => lift2(head(pos2.getClientRects()), last$3(pos1.getClientRects()), isAbove$1).getOr(false);\n    CaretPosition.isBelow = (pos1, pos2) => lift2(last$3(pos2.getClientRects()), head(pos1.getClientRects()), isBelow$1).getOr(false);\n    CaretPosition.isAtStart = pos => pos ? pos.isAtStart() : false;\n    CaretPosition.isAtEnd = pos => pos ? pos.isAtEnd() : false;\n    CaretPosition.isTextPosition = pos => pos ? isText$8(pos.container()) : false;\n    CaretPosition.isElementPosition = pos => CaretPosition.isTextPosition(pos) === false;\n\n    const trimEmptyTextNode$1 = (dom, node) => {\n      if (isText$8(node) && node.data.length === 0) {\n        dom.remove(node);\n      }\n    };\n    const insertNode = (dom, rng, node) => {\n      rng.insertNode(node);\n      trimEmptyTextNode$1(dom, node.previousSibling);\n      trimEmptyTextNode$1(dom, node.nextSibling);\n    };\n    const insertFragment = (dom, rng, frag) => {\n      const firstChild = Optional.from(frag.firstChild);\n      const lastChild = Optional.from(frag.lastChild);\n      rng.insertNode(frag);\n      firstChild.each(child => trimEmptyTextNode$1(dom, child.previousSibling));\n      lastChild.each(child => trimEmptyTextNode$1(dom, child.nextSibling));\n    };\n    const rangeInsertNode = (dom, rng, node) => {\n      if (isDocumentFragment(node)) {\n        insertFragment(dom, rng, node);\n      } else {\n        insertNode(dom, rng, node);\n      }\n    };\n\n    const isText$4 = isText$8;\n    const isBogus = isBogus$2;\n    const nodeIndex = DOMUtils.nodeIndex;\n    const normalizedParent = node => {\n      const parentNode = node.parentNode;\n      if (isBogus(parentNode)) {\n        return normalizedParent(parentNode);\n      }\n      return parentNode;\n    };\n    const getChildNodes = node => {\n      if (!node) {\n        return [];\n      }\n      return reduce(node.childNodes, (result, node) => {\n        if (isBogus(node) && node.nodeName !== 'BR') {\n          result = result.concat(getChildNodes(node));\n        } else {\n          result.push(node);\n        }\n        return result;\n      }, []);\n    };\n    const normalizedTextOffset = (node, offset) => {\n      while (node = node.previousSibling) {\n        if (!isText$4(node)) {\n          break;\n        }\n        offset += node.data.length;\n      }\n      return offset;\n    };\n    const equal = a => b => a === b;\n    const normalizedNodeIndex = node => {\n      let nodes, index;\n      nodes = getChildNodes(normalizedParent(node));\n      index = findIndex$1(nodes, equal(node), node);\n      nodes = nodes.slice(0, index + 1);\n      const numTextFragments = reduce(nodes, (result, node, i) => {\n        if (isText$4(node) && isText$4(nodes[i - 1])) {\n          result++;\n        }\n        return result;\n      }, 0);\n      nodes = filter$4(nodes, matchNodeNames([node.nodeName]));\n      index = findIndex$1(nodes, equal(node), node);\n      return index - numTextFragments;\n    };\n    const createPathItem = node => {\n      let name;\n      if (isText$4(node)) {\n        name = 'text()';\n      } else {\n        name = node.nodeName.toLowerCase();\n      }\n      return name + '[' + normalizedNodeIndex(node) + ']';\n    };\n    const parentsUntil$1 = (root, node, predicate) => {\n      const parents = [];\n      for (node = node.parentNode; node !== root; node = node.parentNode) {\n        if (predicate && predicate(node)) {\n          break;\n        }\n        parents.push(node);\n      }\n      return parents;\n    };\n    const create$a = (root, caretPosition) => {\n      let container, offset, path = [], outputOffset, childNodes, parents;\n      container = caretPosition.container();\n      offset = caretPosition.offset();\n      if (isText$4(container)) {\n        outputOffset = normalizedTextOffset(container, offset);\n      } else {\n        childNodes = container.childNodes;\n        if (offset >= childNodes.length) {\n          outputOffset = 'after';\n          offset = childNodes.length - 1;\n        } else {\n          outputOffset = 'before';\n        }\n        container = childNodes[offset];\n      }\n      path.push(createPathItem(container));\n      parents = parentsUntil$1(root, container);\n      parents = filter$4(parents, not(isBogus$2));\n      path = path.concat(map$1(parents, node => {\n        return createPathItem(node);\n      }));\n      return path.reverse().join('/') + ',' + outputOffset;\n    };\n    const resolvePathItem = (node, name, index) => {\n      let nodes = getChildNodes(node);\n      nodes = filter$4(nodes, (node, index) => {\n        return !isText$4(node) || !isText$4(nodes[index - 1]);\n      });\n      nodes = filter$4(nodes, matchNodeNames([name]));\n      return nodes[index];\n    };\n    const findTextPosition = (container, offset) => {\n      let node = container, targetOffset = 0, dataLen;\n      while (isText$4(node)) {\n        dataLen = node.data.length;\n        if (offset >= targetOffset && offset <= targetOffset + dataLen) {\n          container = node;\n          offset = offset - targetOffset;\n          break;\n        }\n        if (!isText$4(node.nextSibling)) {\n          container = node;\n          offset = dataLen;\n          break;\n        }\n        targetOffset += dataLen;\n        node = node.nextSibling;\n      }\n      if (isText$4(container) && offset > container.data.length) {\n        offset = container.data.length;\n      }\n      return CaretPosition(container, offset);\n    };\n    const resolve$1 = (root, path) => {\n      let offset;\n      if (!path) {\n        return null;\n      }\n      const parts = path.split(',');\n      const paths = parts[0].split('/');\n      offset = parts.length > 1 ? parts[1] : 'before';\n      const container = reduce(paths, (result, value) => {\n        const match = /([\\w\\-\\(\\)]+)\\[([0-9]+)\\]/.exec(value);\n        if (!match) {\n          return null;\n        }\n        if (match[1] === 'text()') {\n          match[1] = '#text';\n        }\n        return resolvePathItem(result, match[1], parseInt(match[2], 10));\n      }, root);\n      if (!container) {\n        return null;\n      }\n      if (!isText$4(container)) {\n        if (offset === 'after') {\n          offset = nodeIndex(container) + 1;\n        } else {\n          offset = nodeIndex(container);\n        }\n        return CaretPosition(container.parentNode, offset);\n      }\n      return findTextPosition(container, parseInt(offset, 10));\n    };\n\n    const isContentEditableFalse$8 = isContentEditableFalse$a;\n    const getNormalizedTextOffset = (trim, container, offset) => {\n      let node, trimmedOffset;\n      trimmedOffset = trim(container.data.slice(0, offset)).length;\n      for (node = container.previousSibling; node && isText$8(node); node = node.previousSibling) {\n        trimmedOffset += trim(node.data).length;\n      }\n      return trimmedOffset;\n    };\n    const getPoint = (dom, trim, normalized, rng, start) => {\n      let container = rng[start ? 'startContainer' : 'endContainer'];\n      let offset = rng[start ? 'startOffset' : 'endOffset'];\n      const point = [];\n      let childNodes, after = 0;\n      const root = dom.getRoot();\n      if (isText$8(container)) {\n        point.push(normalized ? getNormalizedTextOffset(trim, container, offset) : offset);\n      } else {\n        childNodes = container.childNodes;\n        if (offset >= childNodes.length && childNodes.length) {\n          after = 1;\n          offset = Math.max(0, childNodes.length - 1);\n        }\n        point.push(dom.nodeIndex(childNodes[offset], normalized) + after);\n      }\n      for (; container && container !== root; container = container.parentNode) {\n        point.push(dom.nodeIndex(container, normalized));\n      }\n      return point;\n    };\n    const getLocation = (trim, selection, normalized, rng) => {\n      const dom = selection.dom, bookmark = {};\n      bookmark.start = getPoint(dom, trim, normalized, rng, true);\n      if (!selection.isCollapsed()) {\n        bookmark.end = getPoint(dom, trim, normalized, rng, false);\n      }\n      if (isRangeInCaretContainerBlock(rng)) {\n        bookmark.isFakeCaret = true;\n      }\n      return bookmark;\n    };\n    const findIndex = (dom, name, element) => {\n      let count = 0;\n      Tools.each(dom.select(name), node => {\n        if (node.getAttribute('data-mce-bogus') === 'all') {\n          return;\n        }\n        if (node === element) {\n          return false;\n        }\n        count++;\n      });\n      return count;\n    };\n    const moveEndPoint$1 = (rng, start) => {\n      let container, offset, childNodes;\n      const prefix = start ? 'start' : 'end';\n      container = rng[prefix + 'Container'];\n      offset = rng[prefix + 'Offset'];\n      if (isElement$6(container) && container.nodeName === 'TR') {\n        childNodes = container.childNodes;\n        container = childNodes[Math.min(start ? offset : offset - 1, childNodes.length - 1)];\n        if (container) {\n          offset = start ? 0 : container.childNodes.length;\n          rng['set' + (start ? 'Start' : 'End')](container, offset);\n        }\n      }\n    };\n    const normalizeTableCellSelection = rng => {\n      moveEndPoint$1(rng, true);\n      moveEndPoint$1(rng, false);\n      return rng;\n    };\n    const findSibling = (node, offset) => {\n      let sibling;\n      if (isElement$6(node)) {\n        node = getNode$1(node, offset);\n        if (isContentEditableFalse$8(node)) {\n          return node;\n        }\n      }\n      if (isCaretContainer$2(node)) {\n        if (isText$8(node) && isCaretContainerBlock$1(node)) {\n          node = node.parentNode;\n        }\n        sibling = node.previousSibling;\n        if (isContentEditableFalse$8(sibling)) {\n          return sibling;\n        }\n        sibling = node.nextSibling;\n        if (isContentEditableFalse$8(sibling)) {\n          return sibling;\n        }\n      }\n    };\n    const findAdjacentContentEditableFalseElm = rng => {\n      return findSibling(rng.startContainer, rng.startOffset) || findSibling(rng.endContainer, rng.endOffset);\n    };\n    const getOffsetBookmark = (trim, normalized, selection) => {\n      const element = selection.getNode();\n      let name = element ? element.nodeName : null;\n      const rng = selection.getRng();\n      if (isContentEditableFalse$8(element) || name === 'IMG') {\n        return {\n          name,\n          index: findIndex(selection.dom, name, element)\n        };\n      }\n      const sibling = findAdjacentContentEditableFalseElm(rng);\n      if (sibling) {\n        name = sibling.tagName;\n        return {\n          name,\n          index: findIndex(selection.dom, name, sibling)\n        };\n      }\n      return getLocation(trim, selection, normalized, rng);\n    };\n    const getCaretBookmark = selection => {\n      const rng = selection.getRng();\n      return {\n        start: create$a(selection.dom.getRoot(), CaretPosition.fromRangeStart(rng)),\n        end: create$a(selection.dom.getRoot(), CaretPosition.fromRangeEnd(rng))\n      };\n    };\n    const getRangeBookmark = selection => {\n      return { rng: selection.getRng() };\n    };\n    const createBookmarkSpan = (dom, id, filled) => {\n      const args = {\n        'data-mce-type': 'bookmark',\n        id,\n        'style': 'overflow:hidden;line-height:0px'\n      };\n      return filled ? dom.create('span', args, '&#xFEFF;') : dom.create('span', args);\n    };\n    const getPersistentBookmark = (selection, filled) => {\n      const dom = selection.dom;\n      let rng = selection.getRng();\n      const id = dom.uniqueId();\n      const collapsed = selection.isCollapsed();\n      const element = selection.getNode();\n      const name = element.nodeName;\n      if (name === 'IMG') {\n        return {\n          name,\n          index: findIndex(dom, name, element)\n        };\n      }\n      const rng2 = normalizeTableCellSelection(rng.cloneRange());\n      if (!collapsed) {\n        rng2.collapse(false);\n        const endBookmarkNode = createBookmarkSpan(dom, id + '_end', filled);\n        rangeInsertNode(dom, rng2, endBookmarkNode);\n      }\n      rng = normalizeTableCellSelection(rng);\n      rng.collapse(true);\n      const startBookmarkNode = createBookmarkSpan(dom, id + '_start', filled);\n      rangeInsertNode(dom, rng, startBookmarkNode);\n      selection.moveToBookmark({\n        id,\n        keep: true\n      });\n      return { id };\n    };\n    const getBookmark$2 = (selection, type, normalized) => {\n      if (type === 2) {\n        return getOffsetBookmark(trim$1, normalized, selection);\n      } else if (type === 3) {\n        return getCaretBookmark(selection);\n      } else if (type) {\n        return getRangeBookmark(selection);\n      } else {\n        return getPersistentBookmark(selection, false);\n      }\n    };\n    const getUndoBookmark = curry(getOffsetBookmark, identity, true);\n\n    const value$1 = value => {\n      const applyHelper = fn => fn(value);\n      const constHelper = constant(value);\n      const outputHelper = () => output;\n      const output = {\n        tag: true,\n        inner: value,\n        fold: (_onError, onValue) => onValue(value),\n        isValue: always,\n        isError: never,\n        map: mapper => Result.value(mapper(value)),\n        mapError: outputHelper,\n        bind: applyHelper,\n        exists: applyHelper,\n        forall: applyHelper,\n        getOr: constHelper,\n        or: outputHelper,\n        getOrThunk: constHelper,\n        orThunk: outputHelper,\n        getOrDie: constHelper,\n        each: fn => {\n          fn(value);\n        },\n        toOptional: () => Optional.some(value)\n      };\n      return output;\n    };\n    const error = error => {\n      const outputHelper = () => output;\n      const output = {\n        tag: false,\n        inner: error,\n        fold: (onError, _onValue) => onError(error),\n        isValue: never,\n        isError: always,\n        map: outputHelper,\n        mapError: mapper => Result.error(mapper(error)),\n        bind: outputHelper,\n        exists: never,\n        forall: always,\n        getOr: identity,\n        or: identity,\n        getOrThunk: apply$1,\n        orThunk: apply$1,\n        getOrDie: die(String(error)),\n        each: noop,\n        toOptional: Optional.none\n      };\n      return output;\n    };\n    const fromOption = (optional, err) => optional.fold(() => error(err), value$1);\n    const Result = {\n      value: value$1,\n      error,\n      fromOption\n    };\n\n    const generate = cases => {\n      if (!isArray$1(cases)) {\n        throw new Error('cases must be an array');\n      }\n      if (cases.length === 0) {\n        throw new Error('there must be at least one case');\n      }\n      const constructors = [];\n      const adt = {};\n      each$g(cases, (acase, count) => {\n        const keys$1 = keys(acase);\n        if (keys$1.length !== 1) {\n          throw new Error('one and only one name per case');\n        }\n        const key = keys$1[0];\n        const value = acase[key];\n        if (adt[key] !== undefined) {\n          throw new Error('duplicate key detected:' + key);\n        } else if (key === 'cata') {\n          throw new Error('cannot have a case named cata (sorry)');\n        } else if (!isArray$1(value)) {\n          throw new Error('case arguments must be an array');\n        }\n        constructors.push(key);\n        adt[key] = (...args) => {\n          const argLength = args.length;\n          if (argLength !== value.length) {\n            throw new Error('Wrong number of arguments to case ' + key + '. Expected ' + value.length + ' (' + value + '), got ' + argLength);\n          }\n          const match = branches => {\n            const branchKeys = keys(branches);\n            if (constructors.length !== branchKeys.length) {\n              throw new Error('Wrong number of arguments to match. Expected: ' + constructors.join(',') + '\\nActual: ' + branchKeys.join(','));\n            }\n            const allReqd = forall(constructors, reqKey => {\n              return contains$2(branchKeys, reqKey);\n            });\n            if (!allReqd) {\n              throw new Error('Not all branches were specified when using match. Specified: ' + branchKeys.join(', ') + '\\nRequired: ' + constructors.join(', '));\n            }\n            return branches[key].apply(null, args);\n          };\n          return {\n            fold: (...foldArgs) => {\n              if (foldArgs.length !== cases.length) {\n                throw new Error('Wrong number of arguments to fold. Expected ' + cases.length + ', got ' + foldArgs.length);\n              }\n              const target = foldArgs[count];\n              return target.apply(null, args);\n            },\n            match,\n            log: label => {\n              console.log(label, {\n                constructors,\n                constructor: key,\n                params: args\n              });\n            }\n          };\n        };\n      });\n      return adt;\n    };\n    const Adt = { generate };\n\n    Adt.generate([\n      {\n        bothErrors: [\n          'error1',\n          'error2'\n        ]\n      },\n      {\n        firstError: [\n          'error1',\n          'value2'\n        ]\n      },\n      {\n        secondError: [\n          'value1',\n          'error2'\n        ]\n      },\n      {\n        bothValues: [\n          'value1',\n          'value2'\n        ]\n      }\n    ]);\n    const partition$1 = results => {\n      const errors = [];\n      const values = [];\n      each$g(results, result => {\n        result.fold(err => {\n          errors.push(err);\n        }, value => {\n          values.push(value);\n        });\n      });\n      return {\n        errors,\n        values\n      };\n    };\n\n    const isInlinePattern = pattern => pattern.type === 'inline-command' || pattern.type === 'inline-format';\n    const isBlockPattern = pattern => pattern.type === 'block-command' || pattern.type === 'block-format';\n    const sortPatterns = patterns => sort(patterns, (a, b) => {\n      if (a.start.length === b.start.length) {\n        return 0;\n      }\n      return a.start.length > b.start.length ? -1 : 1;\n    });\n    const normalizePattern = pattern => {\n      const err = message => Result.error({\n        message,\n        pattern\n      });\n      const formatOrCmd = (name, onFormat, onCommand) => {\n        if (pattern.format !== undefined) {\n          let formats;\n          if (isArray$1(pattern.format)) {\n            if (!forall(pattern.format, isString)) {\n              return err(name + ' pattern has non-string items in the `format` array');\n            }\n            formats = pattern.format;\n          } else if (isString(pattern.format)) {\n            formats = [pattern.format];\n          } else {\n            return err(name + ' pattern has non-string `format` parameter');\n          }\n          return Result.value(onFormat(formats));\n        } else if (pattern.cmd !== undefined) {\n          if (!isString(pattern.cmd)) {\n            return err(name + ' pattern has non-string `cmd` parameter');\n          }\n          return Result.value(onCommand(pattern.cmd, pattern.value));\n        } else {\n          return err(name + ' pattern is missing both `format` and `cmd` parameters');\n        }\n      };\n      if (!isObject(pattern)) {\n        return err('Raw pattern is not an object');\n      }\n      if (!isString(pattern.start)) {\n        return err('Raw pattern is missing `start` parameter');\n      }\n      if (pattern.end !== undefined) {\n        if (!isString(pattern.end)) {\n          return err('Inline pattern has non-string `end` parameter');\n        }\n        if (pattern.start.length === 0 && pattern.end.length === 0) {\n          return err('Inline pattern has empty `start` and `end` parameters');\n        }\n        let start = pattern.start;\n        let end = pattern.end;\n        if (end.length === 0) {\n          end = start;\n          start = '';\n        }\n        return formatOrCmd('Inline', format => ({\n          type: 'inline-format',\n          start,\n          end,\n          format\n        }), (cmd, value) => ({\n          type: 'inline-command',\n          start,\n          end,\n          cmd,\n          value\n        }));\n      } else if (pattern.replacement !== undefined) {\n        if (!isString(pattern.replacement)) {\n          return err('Replacement pattern has non-string `replacement` parameter');\n        }\n        if (pattern.start.length === 0) {\n          return err('Replacement pattern has empty `start` parameter');\n        }\n        return Result.value({\n          type: 'inline-command',\n          start: '',\n          end: pattern.start,\n          cmd: 'mceInsertContent',\n          value: pattern.replacement\n        });\n      } else {\n        if (pattern.start.length === 0) {\n          return err('Block pattern has empty `start` parameter');\n        }\n        return formatOrCmd('Block', formats => ({\n          type: 'block-format',\n          start: pattern.start,\n          format: formats[0]\n        }), (command, commandValue) => ({\n          type: 'block-command',\n          start: pattern.start,\n          cmd: command,\n          value: commandValue\n        }));\n      }\n    };\n    const getBlockPatterns = patterns => sortPatterns(filter$6(patterns, isBlockPattern));\n    const getInlinePatterns = patterns => filter$6(patterns, isInlinePattern);\n    const createPatternSet = patterns => ({\n      inlinePatterns: getInlinePatterns(patterns),\n      blockPatterns: getBlockPatterns(patterns)\n    });\n    const fromRawPatterns = patterns => {\n      const normalized = partition$1(map$3(patterns, normalizePattern));\n      each$g(normalized.errors, err => console.error(err.message, err.pattern));\n      return normalized.values;\n    };\n\n    const deviceDetection$1 = detect$2().deviceType;\n    const isTouch = deviceDetection$1.isTouch();\n    const DOM$a = DOMUtils.DOM;\n    const getHash = value => {\n      const items = value.indexOf('=') > 0 ? value.split(/[;,](?![^=;,]*(?:[;,]|$))/) : value.split(',');\n      return foldl(items, (output, item) => {\n        const arr = item.split('=');\n        const key = arr[0];\n        const val = arr.length > 1 ? arr[1] : key;\n        output[trim$3(key)] = trim$3(val);\n        return output;\n      }, {});\n    };\n    const isRegExp = x => is$4(x, RegExp);\n    const option = name => editor => editor.options.get(name);\n    const stringOrObjectProcessor = value => isString(value) || isObject(value);\n    const bodyOptionProcessor = (editor, defaultValue = '') => value => {\n      const valid = isString(value);\n      if (valid) {\n        if (value.indexOf('=') !== -1) {\n          const bodyObj = getHash(value);\n          return {\n            value: get$a(bodyObj, editor.id).getOr(defaultValue),\n            valid\n          };\n        } else {\n          return {\n            value,\n            valid\n          };\n        }\n      } else {\n        return {\n          valid: false,\n          message: 'Must be a string.'\n        };\n      }\n    };\n    const register$7 = editor => {\n      const registerOption = editor.options.register;\n      registerOption('id', {\n        processor: 'string',\n        default: editor.id\n      });\n      registerOption('selector', { processor: 'string' });\n      registerOption('target', { processor: 'object' });\n      registerOption('suffix', { processor: 'string' });\n      registerOption('cache_suffix', { processor: 'string' });\n      registerOption('base_url', { processor: 'string' });\n      registerOption('referrer_policy', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('language_load', { processor: 'boolean' });\n      registerOption('inline', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('iframe_attrs', {\n        processor: 'object',\n        default: {}\n      });\n      registerOption('doctype', {\n        processor: 'string',\n        default: '<!DOCTYPE html>'\n      });\n      registerOption('document_base_url', {\n        processor: 'string',\n        default: editor.documentBaseUrl\n      });\n      registerOption('body_id', {\n        processor: bodyOptionProcessor(editor, 'tinymce'),\n        default: 'tinymce'\n      });\n      registerOption('body_class', {\n        processor: bodyOptionProcessor(editor),\n        default: ''\n      });\n      registerOption('content_security_policy', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('br_in_pre', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('forced_root_block', {\n        processor: value => {\n          const valid = isString(value) && isNotEmpty(value);\n          if (valid) {\n            return {\n              value,\n              valid\n            };\n          } else {\n            return {\n              valid: false,\n              message: 'Must be a non-empty string.'\n            };\n          }\n        },\n        default: 'p'\n      });\n      registerOption('forced_root_block_attrs', {\n        processor: 'object',\n        default: {}\n      });\n      registerOption('br_newline_selector', {\n        processor: 'string',\n        default: '.mce-toc h2,figcaption,caption'\n      });\n      registerOption('no_newline_selector', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('keep_styles', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('end_container_on_empty_block', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('font_size_style_values', {\n        processor: 'string',\n        default: 'xx-small,x-small,small,medium,large,x-large,xx-large'\n      });\n      registerOption('font_size_legacy_values', {\n        processor: 'string',\n        default: 'xx-small,small,medium,large,x-large,xx-large,300%'\n      });\n      registerOption('font_size_classes', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('automatic_uploads', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('images_reuse_filename', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('images_replace_blob_uris', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('icons', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('icons_url', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('images_upload_url', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('images_upload_base_path', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('images_upload_base_path', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('images_upload_credentials', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('images_upload_handler', { processor: 'function' });\n      registerOption('language', {\n        processor: 'string',\n        default: 'en'\n      });\n      registerOption('language_url', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('entity_encoding', {\n        processor: 'string',\n        default: 'named'\n      });\n      registerOption('indent', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('indent_before', {\n        processor: 'string',\n        default: 'p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,' + 'tfoot,tbody,tr,section,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist'\n      });\n      registerOption('indent_after', {\n        processor: 'string',\n        default: 'p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,' + 'tfoot,tbody,tr,section,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist'\n      });\n      registerOption('indent_use_margin', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('indentation', {\n        processor: 'string',\n        default: '40px'\n      });\n      registerOption('content_css', {\n        processor: value => {\n          const valid = value === false || isString(value) || isArrayOf(value, isString);\n          if (valid) {\n            if (isString(value)) {\n              return {\n                value: map$3(value.split(','), trim$3),\n                valid\n              };\n            } else if (isArray$1(value)) {\n              return {\n                value,\n                valid\n              };\n            } else if (value === false) {\n              return {\n                value: [],\n                valid\n              };\n            } else {\n              return {\n                value,\n                valid\n              };\n            }\n          } else {\n            return {\n              valid: false,\n              message: 'Must be false, a string or an array of strings.'\n            };\n          }\n        },\n        default: isInline(editor) ? [] : ['default']\n      });\n      registerOption('content_style', { processor: 'string' });\n      registerOption('content_css_cors', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('font_css', {\n        processor: value => {\n          const valid = isString(value) || isArrayOf(value, isString);\n          if (valid) {\n            const newValue = isArray$1(value) ? value : map$3(value.split(','), trim$3);\n            return {\n              value: newValue,\n              valid\n            };\n          } else {\n            return {\n              valid: false,\n              message: 'Must be a string or an array of strings.'\n            };\n          }\n        },\n        default: []\n      });\n      registerOption('inline_boundaries', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('inline_boundaries_selector', {\n        processor: 'string',\n        default: 'a[href],code,.mce-annotation'\n      });\n      registerOption('object_resizing', {\n        processor: value => {\n          const valid = isBoolean(value) || isString(value);\n          if (valid) {\n            if (value === false || deviceDetection$1.isiPhone() || deviceDetection$1.isiPad()) {\n              return {\n                value: '',\n                valid\n              };\n            } else {\n              return {\n                value: value === true ? 'table,img,figure.image,div,video,iframe' : value,\n                valid\n              };\n            }\n          } else {\n            return {\n              valid: false,\n              message: 'Must be boolean or a string'\n            };\n          }\n        },\n        default: !isTouch\n      });\n      registerOption('resize_img_proportional', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('event_root', { processor: 'object' });\n      registerOption('service_message', { processor: 'string' });\n      registerOption('theme', {\n        processor: value => value === false || isString(value) || isFunction(value),\n        default: 'silver'\n      });\n      registerOption('theme_url', { processor: 'string' });\n      registerOption('formats', { processor: 'object' });\n      registerOption('format_empty_lines', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('preview_styles', {\n        processor: value => {\n          const valid = value === false || isString(value);\n          if (valid) {\n            return {\n              value: value === false ? '' : value,\n              valid\n            };\n          } else {\n            return {\n              valid: false,\n              message: 'Must be false or a string'\n            };\n          }\n        },\n        default: 'font-family font-size font-weight font-style text-decoration text-transform color background-color border border-radius outline text-shadow'\n      });\n      registerOption('custom_ui_selector', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('hidden_input', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('submit_patch', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('encoding', { processor: 'string' });\n      registerOption('add_form_submit_trigger', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('add_unload_trigger', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('custom_undo_redo_levels', {\n        processor: 'number',\n        default: 0\n      });\n      registerOption('disable_nodechange', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('readonly', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('plugins', {\n        processor: 'string[]',\n        default: []\n      });\n      registerOption('external_plugins', { processor: 'object' });\n      registerOption('forced_plugins', { processor: 'string[]' });\n      registerOption('model', {\n        processor: 'string',\n        default: editor.hasPlugin('rtc') ? 'plugin' : 'dom'\n      });\n      registerOption('model_url', { processor: 'string' });\n      registerOption('block_unsupported_drop', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('visual', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('visual_table_class', {\n        processor: 'string',\n        default: 'mce-item-table'\n      });\n      registerOption('visual_anchor_class', {\n        processor: 'string',\n        default: 'mce-item-anchor'\n      });\n      registerOption('iframe_aria_text', {\n        processor: 'string',\n        default: 'Rich Text Area. Press ALT-0 for help.'\n      });\n      registerOption('setup', { processor: 'function' });\n      registerOption('init_instance_callback', { processor: 'function' });\n      registerOption('url_converter', {\n        processor: 'function',\n        default: editor.convertURL\n      });\n      registerOption('url_converter_scope', {\n        processor: 'object',\n        default: editor\n      });\n      registerOption('urlconverter_callback', { processor: 'function' });\n      registerOption('allow_conditional_comments', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('allow_html_data_urls', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('allow_svg_data_urls', { processor: 'boolean' });\n      registerOption('allow_html_in_named_anchor', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('allow_script_urls', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('allow_unsafe_link_target', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('convert_fonts_to_spans', {\n        processor: 'boolean',\n        default: true,\n        deprecated: true\n      });\n      registerOption('fix_list_elements', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('preserve_cdata', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('remove_trailing_brs', { processor: 'boolean' });\n      registerOption('inline_styles', {\n        processor: 'boolean',\n        default: true,\n        deprecated: true\n      });\n      registerOption('element_format', {\n        processor: 'string',\n        default: 'html'\n      });\n      registerOption('entities', { processor: 'string' });\n      registerOption('schema', {\n        processor: 'string',\n        default: 'html5'\n      });\n      registerOption('convert_urls', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('relative_urls', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('remove_script_host', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('custom_elements', { processor: 'string' });\n      registerOption('extended_valid_elements', { processor: 'string' });\n      registerOption('invalid_elements', { processor: 'string' });\n      registerOption('invalid_styles', { processor: stringOrObjectProcessor });\n      registerOption('valid_children', { processor: 'string' });\n      registerOption('valid_classes', { processor: stringOrObjectProcessor });\n      registerOption('valid_elements', { processor: 'string' });\n      registerOption('valid_styles', { processor: stringOrObjectProcessor });\n      registerOption('verify_html', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('auto_focus', { processor: value => isString(value) || value === true });\n      registerOption('browser_spellcheck', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('protect', { processor: 'array' });\n      registerOption('images_file_types', {\n        processor: 'string',\n        default: 'jpeg,jpg,jpe,jfi,jif,jfif,png,gif,bmp,webp'\n      });\n      registerOption('deprecation_warnings', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('a11y_advanced_options', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('api_key', { processor: 'string' });\n      registerOption('paste_block_drop', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('paste_data_images', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('paste_preprocess', { processor: 'function' });\n      registerOption('paste_postprocess', { processor: 'function' });\n      registerOption('paste_webkit_styles', {\n        processor: 'string',\n        default: 'none'\n      });\n      registerOption('paste_remove_styles_if_webkit', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('paste_merge_formats', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('smart_paste', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('paste_as_text', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('paste_tab_spaces', {\n        processor: 'number',\n        default: 4\n      });\n      registerOption('text_patterns', {\n        processor: value => {\n          if (isArrayOf(value, isObject) || value === false) {\n            const patterns = value === false ? [] : value;\n            return {\n              value: fromRawPatterns(patterns),\n              valid: true\n            };\n          } else {\n            return {\n              valid: false,\n              message: 'Must be an array of objects or false.'\n            };\n          }\n        },\n        default: [\n          {\n            start: '*',\n            end: '*',\n            format: 'italic'\n          },\n          {\n            start: '**',\n            end: '**',\n            format: 'bold'\n          },\n          {\n            start: '#',\n            format: 'h1'\n          },\n          {\n            start: '##',\n            format: 'h2'\n          },\n          {\n            start: '###',\n            format: 'h3'\n          },\n          {\n            start: '####',\n            format: 'h4'\n          },\n          {\n            start: '#####',\n            format: 'h5'\n          },\n          {\n            start: '######',\n            format: 'h6'\n          },\n          {\n            start: '1. ',\n            cmd: 'InsertOrderedList'\n          },\n          {\n            start: '* ',\n            cmd: 'InsertUnorderedList'\n          },\n          {\n            start: '- ',\n            cmd: 'InsertUnorderedList'\n          }\n        ]\n      });\n      registerOption('noneditable_class', {\n        processor: 'string',\n        default: 'mceNonEditable'\n      });\n      registerOption('editable_class', {\n        processor: 'string',\n        default: 'mceEditable'\n      });\n      registerOption('noneditable_regexp', {\n        processor: value => {\n          if (isArrayOf(value, isRegExp)) {\n            return {\n              value,\n              valid: true\n            };\n          } else if (isRegExp(value)) {\n            return {\n              value: [value],\n              valid: true\n            };\n          } else {\n            return {\n              valid: false,\n              message: 'Must be a RegExp or an array of RegExp.'\n            };\n          }\n        },\n        default: []\n      });\n      registerOption('table_tab_navigation', {\n        processor: 'boolean',\n        default: true\n      });\n      editor.on('ScriptsLoaded', () => {\n        registerOption('directionality', {\n          processor: 'string',\n          default: I18n.isRtl() ? 'rtl' : undefined\n        });\n        registerOption('placeholder', {\n          processor: 'string',\n          default: DOM$a.getAttrib(editor.getElement(), 'placeholder')\n        });\n      });\n    };\n    const getIframeAttrs = option('iframe_attrs');\n    const getDocType = option('doctype');\n    const getDocumentBaseUrl = option('document_base_url');\n    const getBodyId = option('body_id');\n    const getBodyClass = option('body_class');\n    const getContentSecurityPolicy = option('content_security_policy');\n    const shouldPutBrInPre$1 = option('br_in_pre');\n    const getForcedRootBlock = option('forced_root_block');\n    const getForcedRootBlockAttrs = option('forced_root_block_attrs');\n    const getBrNewLineSelector = option('br_newline_selector');\n    const getNoNewLineSelector = option('no_newline_selector');\n    const shouldKeepStyles = option('keep_styles');\n    const shouldEndContainerOnEmptyBlock = option('end_container_on_empty_block');\n    const isAutomaticUploadsEnabled = option('automatic_uploads');\n    const shouldReuseFileName = option('images_reuse_filename');\n    const shouldReplaceBlobUris = option('images_replace_blob_uris');\n    const getIconPackName = option('icons');\n    const getIconsUrl = option('icons_url');\n    const getImageUploadUrl = option('images_upload_url');\n    const getImageUploadBasePath = option('images_upload_base_path');\n    const getImagesUploadCredentials = option('images_upload_credentials');\n    const getImagesUploadHandler = option('images_upload_handler');\n    const shouldUseContentCssCors = option('content_css_cors');\n    const getReferrerPolicy = option('referrer_policy');\n    const getLanguageCode = option('language');\n    const getLanguageUrl = option('language_url');\n    const shouldIndentUseMargin = option('indent_use_margin');\n    const getIndentation = option('indentation');\n    const getContentCss = option('content_css');\n    const getContentStyle = option('content_style');\n    const getFontCss = option('font_css');\n    const getDirectionality = option('directionality');\n    const getInlineBoundarySelector = option('inline_boundaries_selector');\n    const getObjectResizing = option('object_resizing');\n    const getResizeImgProportional = option('resize_img_proportional');\n    const getPlaceholder = option('placeholder');\n    const getEventRoot = option('event_root');\n    const getServiceMessage = option('service_message');\n    const getTheme = option('theme');\n    const getThemeUrl = option('theme_url');\n    const getModel = option('model');\n    const getModelUrl = option('model_url');\n    const isInlineBoundariesEnabled = option('inline_boundaries');\n    const getFormats = option('formats');\n    const getPreviewStyles = option('preview_styles');\n    const canFormatEmptyLines = option('format_empty_lines');\n    const getCustomUiSelector = option('custom_ui_selector');\n    const isInline = option('inline');\n    const hasHiddenInput = option('hidden_input');\n    const shouldPatchSubmit = option('submit_patch');\n    const shouldAddFormSubmitTrigger = option('add_form_submit_trigger');\n    const shouldAddUnloadTrigger = option('add_unload_trigger');\n    const getCustomUndoRedoLevels = option('custom_undo_redo_levels');\n    const shouldDisableNodeChange = option('disable_nodechange');\n    const isReadOnly$1 = option('readonly');\n    const hasContentCssCors = option('content_css_cors');\n    const getPlugins = option('plugins');\n    const getExternalPlugins$1 = option('external_plugins');\n    const shouldBlockUnsupportedDrop = option('block_unsupported_drop');\n    const isVisualAidsEnabled = option('visual');\n    const getVisualAidsTableClass = option('visual_table_class');\n    const getVisualAidsAnchorClass = option('visual_anchor_class');\n    const getIframeAriaText = option('iframe_aria_text');\n    const getSetupCallback = option('setup');\n    const getInitInstanceCallback = option('init_instance_callback');\n    const getUrlConverterCallback = option('urlconverter_callback');\n    const getAutoFocus = option('auto_focus');\n    const shouldBrowserSpellcheck = option('browser_spellcheck');\n    const getProtect = option('protect');\n    const shouldPasteBlockDrop = option('paste_block_drop');\n    const shouldPasteDataImages = option('paste_data_images');\n    const getPastePreProcess = option('paste_preprocess');\n    const getPastePostProcess = option('paste_postprocess');\n    const getPasteWebkitStyles = option('paste_webkit_styles');\n    const shouldPasteRemoveWebKitStyles = option('paste_remove_styles_if_webkit');\n    const shouldPasteMergeFormats = option('paste_merge_formats');\n    const isSmartPasteEnabled = option('smart_paste');\n    const isPasteAsTextEnabled = option('paste_as_text');\n    const getPasteTabSpaces = option('paste_tab_spaces');\n    const shouldAllowHtmlDataUrls = option('allow_html_data_urls');\n    const getTextPatterns = option('text_patterns');\n    const getNonEditableClass = option('noneditable_class');\n    const getEditableClass = option('editable_class');\n    const getNonEditableRegExps = option('noneditable_regexp');\n    const getFontStyleValues = editor => Tools.explode(editor.options.get('font_size_style_values'));\n    const getFontSizeClasses = editor => Tools.explode(editor.options.get('font_size_classes'));\n    const isEncodingXml = editor => editor.options.get('encoding') === 'xml';\n    const getAllowedImageFileTypes = editor => Tools.explode(editor.options.get('images_file_types'));\n    const hasTableTabNavigation = option('table_tab_navigation');\n\n    const isElement$3 = isElement$6;\n    const isText$3 = isText$8;\n    const removeNode$1 = node => {\n      const parentNode = node.parentNode;\n      if (parentNode) {\n        parentNode.removeChild(node);\n      }\n    };\n    const trimCount = text => {\n      const trimmedText = trim$1(text);\n      return {\n        count: text.length - trimmedText.length,\n        text: trimmedText\n      };\n    };\n    const deleteZwspChars = caretContainer => {\n      let idx;\n      while ((idx = caretContainer.data.lastIndexOf(ZWSP$1)) !== -1) {\n        caretContainer.deleteData(idx, 1);\n      }\n    };\n    const removeUnchanged = (caretContainer, pos) => {\n      remove$4(caretContainer);\n      return pos;\n    };\n    const removeTextAndReposition = (caretContainer, pos) => {\n      const before = trimCount(caretContainer.data.substr(0, pos.offset()));\n      const after = trimCount(caretContainer.data.substr(pos.offset()));\n      const text = before.text + after.text;\n      if (text.length > 0) {\n        deleteZwspChars(caretContainer);\n        return CaretPosition(caretContainer, pos.offset() - before.count);\n      } else {\n        return pos;\n      }\n    };\n    const removeElementAndReposition = (caretContainer, pos) => {\n      const parentNode = pos.container();\n      const newPosition = indexOf$1(from(parentNode.childNodes), caretContainer).map(index => {\n        return index < pos.offset() ? CaretPosition(parentNode, pos.offset() - 1) : pos;\n      }).getOr(pos);\n      remove$4(caretContainer);\n      return newPosition;\n    };\n    const removeTextCaretContainer = (caretContainer, pos) => isText$3(caretContainer) && pos.container() === caretContainer ? removeTextAndReposition(caretContainer, pos) : removeUnchanged(caretContainer, pos);\n    const removeElementCaretContainer = (caretContainer, pos) => pos.container() === caretContainer.parentNode ? removeElementAndReposition(caretContainer, pos) : removeUnchanged(caretContainer, pos);\n    const removeAndReposition = (container, pos) => CaretPosition.isTextPosition(pos) ? removeTextCaretContainer(container, pos) : removeElementCaretContainer(container, pos);\n    const remove$4 = caretContainerNode => {\n      if (isElement$3(caretContainerNode) && isCaretContainer$2(caretContainerNode)) {\n        if (hasContent(caretContainerNode)) {\n          caretContainerNode.removeAttribute('data-mce-caret');\n        } else {\n          removeNode$1(caretContainerNode);\n        }\n      }\n      if (isText$3(caretContainerNode)) {\n        deleteZwspChars(caretContainerNode);\n        if (caretContainerNode.data.length === 0) {\n          removeNode$1(caretContainerNode);\n        }\n      }\n    };\n\n    const isContentEditableFalse$7 = isContentEditableFalse$a;\n    const isMedia$1 = isMedia$2;\n    const isTableCell$3 = isTableCell$5;\n    const inlineFakeCaretSelector = '*[contentEditable=false],video,audio,embed,object';\n    const getAbsoluteClientRect = (root, element, before) => {\n      const clientRect = collapse(element.getBoundingClientRect(), before);\n      let scrollX;\n      let scrollY;\n      if (root.tagName === 'BODY') {\n        const docElm = root.ownerDocument.documentElement;\n        scrollX = root.scrollLeft || docElm.scrollLeft;\n        scrollY = root.scrollTop || docElm.scrollTop;\n      } else {\n        const rootRect = root.getBoundingClientRect();\n        scrollX = root.scrollLeft - rootRect.left;\n        scrollY = root.scrollTop - rootRect.top;\n      }\n      clientRect.left += scrollX;\n      clientRect.right += scrollX;\n      clientRect.top += scrollY;\n      clientRect.bottom += scrollY;\n      clientRect.width = 1;\n      let margin = element.offsetWidth - element.clientWidth;\n      if (margin > 0) {\n        if (before) {\n          margin *= -1;\n        }\n        clientRect.left += margin;\n        clientRect.right += margin;\n      }\n      return clientRect;\n    };\n    const trimInlineCaretContainers = root => {\n      const fakeCaretTargetNodes = descendants(SugarElement.fromDom(root), inlineFakeCaretSelector);\n      for (let i = 0; i < fakeCaretTargetNodes.length; i++) {\n        const node = fakeCaretTargetNodes[i].dom;\n        let sibling = node.previousSibling;\n        if (endsWithCaretContainer$1(sibling)) {\n          const data = sibling.data;\n          if (data.length === 1) {\n            sibling.parentNode.removeChild(sibling);\n          } else {\n            sibling.deleteData(data.length - 1, 1);\n          }\n        }\n        sibling = node.nextSibling;\n        if (startsWithCaretContainer$1(sibling)) {\n          const data = sibling.data;\n          if (data.length === 1) {\n            sibling.parentNode.removeChild(sibling);\n          } else {\n            sibling.deleteData(0, 1);\n          }\n        }\n      }\n    };\n    const FakeCaret = (editor, root, isBlock, hasFocus) => {\n      const lastVisualCaret = value$2();\n      let cursorInterval;\n      let caretContainerNode;\n      const caretBlock = getForcedRootBlock(editor);\n      const dom = editor.dom;\n      const show = (before, element) => {\n        let rng;\n        hide();\n        if (isTableCell$3(element)) {\n          return null;\n        }\n        if (isBlock(element)) {\n          caretContainerNode = insertBlock(caretBlock, element, before);\n          const clientRect = getAbsoluteClientRect(root, element, before);\n          dom.setStyle(caretContainerNode, 'top', clientRect.top);\n          const caret = dom.create('div', {\n            'class': 'mce-visual-caret',\n            'data-mce-bogus': 'all'\n          });\n          dom.setStyles(caret, { ...clientRect });\n          dom.add(root, caret);\n          lastVisualCaret.set({\n            caret,\n            element,\n            before\n          });\n          if (before) {\n            dom.addClass(caret, 'mce-visual-caret-before');\n          }\n          startBlink();\n          rng = element.ownerDocument.createRange();\n          rng.setStart(caretContainerNode, 0);\n          rng.setEnd(caretContainerNode, 0);\n        } else {\n          caretContainerNode = insertInline$1(element, before);\n          rng = element.ownerDocument.createRange();\n          if (isInlineFakeCaretTarget(caretContainerNode.nextSibling)) {\n            rng.setStart(caretContainerNode, 0);\n            rng.setEnd(caretContainerNode, 0);\n          } else {\n            rng.setStart(caretContainerNode, 1);\n            rng.setEnd(caretContainerNode, 1);\n          }\n          return rng;\n        }\n        return rng;\n      };\n      const hide = () => {\n        trimInlineCaretContainers(root);\n        if (caretContainerNode) {\n          remove$4(caretContainerNode);\n          caretContainerNode = null;\n        }\n        lastVisualCaret.on(caretState => {\n          dom.remove(caretState.caret);\n          lastVisualCaret.clear();\n        });\n        if (cursorInterval) {\n          clearInterval(cursorInterval);\n          cursorInterval = undefined;\n        }\n      };\n      const startBlink = () => {\n        cursorInterval = setInterval(() => {\n          lastVisualCaret.on(caretState => {\n            if (hasFocus()) {\n              dom.toggleClass(caretState.caret, 'mce-visual-caret-hidden');\n            } else {\n              dom.addClass(caretState.caret, 'mce-visual-caret-hidden');\n            }\n          });\n        }, 500);\n      };\n      const reposition = () => {\n        lastVisualCaret.on(caretState => {\n          const clientRect = getAbsoluteClientRect(root, caretState.element, caretState.before);\n          dom.setStyles(caretState.caret, { ...clientRect });\n        });\n      };\n      const destroy = () => clearInterval(cursorInterval);\n      const getCss = () => '.mce-visual-caret {' + 'position: absolute;' + 'background-color: black;' + 'background-color: currentcolor;' + '}' + '.mce-visual-caret-hidden {' + 'display: none;' + '}' + '*[data-mce-caret] {' + 'position: absolute;' + 'left: -1000px;' + 'right: auto;' + 'top: 0;' + 'margin: 0;' + 'padding: 0;' + '}';\n      return {\n        show,\n        hide,\n        getCss,\n        reposition,\n        destroy\n      };\n    };\n    const isFakeCaretTableBrowser = () => Env.browser.isFirefox();\n    const isInlineFakeCaretTarget = node => isContentEditableFalse$7(node) || isMedia$1(node);\n    const isFakeCaretTarget = node => isInlineFakeCaretTarget(node) || isTable$3(node) && isFakeCaretTableBrowser();\n\n    const isContentEditableTrue$2 = isContentEditableTrue$4;\n    const isContentEditableFalse$6 = isContentEditableFalse$a;\n    const isMedia = isMedia$2;\n    const isBlockLike = matchStyleValues('display', 'block table table-cell table-caption list-item');\n    const isCaretContainer = isCaretContainer$2;\n    const isCaretContainerBlock = isCaretContainerBlock$1;\n    const isElement$2 = isElement$6;\n    const isCaretCandidate$1 = isCaretCandidate$3;\n    const isForwards = direction => direction > 0;\n    const isBackwards = direction => direction < 0;\n    const skipCaretContainers = (walk, shallow) => {\n      let node;\n      while (node = walk(shallow)) {\n        if (!isCaretContainerBlock(node)) {\n          return node;\n        }\n      }\n      return null;\n    };\n    const findNode = (node, direction, predicateFn, rootNode, shallow) => {\n      const walker = new DomTreeWalker(node, rootNode);\n      const isCefOrCaretContainer = isContentEditableFalse$6(node) || isCaretContainerBlock(node);\n      if (isBackwards(direction)) {\n        if (isCefOrCaretContainer) {\n          node = skipCaretContainers(walker.prev.bind(walker), true);\n          if (predicateFn(node)) {\n            return node;\n          }\n        }\n        while (node = skipCaretContainers(walker.prev.bind(walker), shallow)) {\n          if (predicateFn(node)) {\n            return node;\n          }\n        }\n      }\n      if (isForwards(direction)) {\n        if (isCefOrCaretContainer) {\n          node = skipCaretContainers(walker.next.bind(walker), true);\n          if (predicateFn(node)) {\n            return node;\n          }\n        }\n        while (node = skipCaretContainers(walker.next.bind(walker), shallow)) {\n          if (predicateFn(node)) {\n            return node;\n          }\n        }\n      }\n      return null;\n    };\n    const getEditingHost = (node, rootNode) => {\n      const isCETrue = node => isContentEditableTrue$2(node.dom);\n      const isRoot = node => node.dom === rootNode;\n      return ancestor$3(SugarElement.fromDom(node), isCETrue, isRoot).map(elm => elm.dom).getOr(rootNode);\n    };\n    const getParentBlock$3 = (node, rootNode) => {\n      while (node && node !== rootNode) {\n        if (isBlockLike(node)) {\n          return node;\n        }\n        node = node.parentNode;\n      }\n      return null;\n    };\n    const isInSameBlock = (caretPosition1, caretPosition2, rootNode) => getParentBlock$3(caretPosition1.container(), rootNode) === getParentBlock$3(caretPosition2.container(), rootNode);\n    const getChildNodeAtRelativeOffset = (relativeOffset, caretPosition) => {\n      if (!caretPosition) {\n        return null;\n      }\n      const container = caretPosition.container();\n      const offset = caretPosition.offset();\n      if (!isElement$2(container)) {\n        return null;\n      }\n      return container.childNodes[offset + relativeOffset];\n    };\n    const beforeAfter = (before, node) => {\n      const range = node.ownerDocument.createRange();\n      if (before) {\n        range.setStartBefore(node);\n        range.setEndBefore(node);\n      } else {\n        range.setStartAfter(node);\n        range.setEndAfter(node);\n      }\n      return range;\n    };\n    const isNodesInSameBlock = (root, node1, node2) => getParentBlock$3(node1, root) === getParentBlock$3(node2, root);\n    const lean = (left, root, node) => {\n      const siblingName = left ? 'previousSibling' : 'nextSibling';\n      while (node && node !== root) {\n        let sibling = node[siblingName];\n        if (isCaretContainer(sibling)) {\n          sibling = sibling[siblingName];\n        }\n        if (isContentEditableFalse$6(sibling) || isMedia(sibling)) {\n          if (isNodesInSameBlock(root, sibling, node)) {\n            return sibling;\n          }\n          break;\n        }\n        if (isCaretCandidate$1(sibling)) {\n          break;\n        }\n        node = node.parentNode;\n      }\n      return null;\n    };\n    const before$2 = curry(beforeAfter, true);\n    const after$2 = curry(beforeAfter, false);\n    const normalizeRange = (direction, root, range) => {\n      let node;\n      const leanLeft = curry(lean, true, root);\n      const leanRight = curry(lean, false, root);\n      let container = range.startContainer;\n      const offset = range.startOffset;\n      if (isCaretContainerBlock$1(container)) {\n        if (!isElement$2(container)) {\n          container = container.parentNode;\n        }\n        const location = container.getAttribute('data-mce-caret');\n        if (location === 'before') {\n          node = container.nextSibling;\n          if (isFakeCaretTarget(node)) {\n            return before$2(node);\n          }\n        }\n        if (location === 'after') {\n          node = container.previousSibling;\n          if (isFakeCaretTarget(node)) {\n            return after$2(node);\n          }\n        }\n      }\n      if (!range.collapsed) {\n        return range;\n      }\n      if (isText$8(container)) {\n        if (isCaretContainer(container)) {\n          if (direction === 1) {\n            node = leanRight(container);\n            if (node) {\n              return before$2(node);\n            }\n            node = leanLeft(container);\n            if (node) {\n              return after$2(node);\n            }\n          }\n          if (direction === -1) {\n            node = leanLeft(container);\n            if (node) {\n              return after$2(node);\n            }\n            node = leanRight(container);\n            if (node) {\n              return before$2(node);\n            }\n          }\n          return range;\n        }\n        if (endsWithCaretContainer$1(container) && offset >= container.data.length - 1) {\n          if (direction === 1) {\n            node = leanRight(container);\n            if (node) {\n              return before$2(node);\n            }\n          }\n          return range;\n        }\n        if (startsWithCaretContainer$1(container) && offset <= 1) {\n          if (direction === -1) {\n            node = leanLeft(container);\n            if (node) {\n              return after$2(node);\n            }\n          }\n          return range;\n        }\n        if (offset === container.data.length) {\n          node = leanRight(container);\n          if (node) {\n            return before$2(node);\n          }\n          return range;\n        }\n        if (offset === 0) {\n          node = leanLeft(container);\n          if (node) {\n            return after$2(node);\n          }\n          return range;\n        }\n      }\n      return range;\n    };\n    const getRelativeCefElm = (forward, caretPosition) => Optional.from(getChildNodeAtRelativeOffset(forward ? 0 : -1, caretPosition)).filter(isContentEditableFalse$6);\n    const getNormalizedRangeEndPoint = (direction, root, range) => {\n      const normalizedRange = normalizeRange(direction, root, range);\n      if (direction === -1) {\n        return CaretPosition.fromRangeStart(normalizedRange);\n      }\n      return CaretPosition.fromRangeEnd(normalizedRange);\n    };\n    const getElementFromPosition = pos => Optional.from(pos.getNode()).map(SugarElement.fromDom);\n    const getElementFromPrevPosition = pos => Optional.from(pos.getNode(true)).map(SugarElement.fromDom);\n    const getVisualCaretPosition = (walkFn, caretPosition) => {\n      while (caretPosition = walkFn(caretPosition)) {\n        if (caretPosition.isVisible()) {\n          return caretPosition;\n        }\n      }\n      return caretPosition;\n    };\n    const isMoveInsideSameBlock = (from, to) => {\n      const inSameBlock = isInSameBlock(from, to);\n      if (!inSameBlock && isBr$5(from.getNode())) {\n        return true;\n      }\n      return inSameBlock;\n    };\n\n    var HDirection;\n    (function (HDirection) {\n      HDirection[HDirection['Backwards'] = -1] = 'Backwards';\n      HDirection[HDirection['Forwards'] = 1] = 'Forwards';\n    }(HDirection || (HDirection = {})));\n    const isContentEditableFalse$5 = isContentEditableFalse$a;\n    const isText$2 = isText$8;\n    const isElement$1 = isElement$6;\n    const isBr$1 = isBr$5;\n    const isCaretCandidate = isCaretCandidate$3;\n    const isAtomic = isAtomic$1;\n    const isEditableCaretCandidate = isEditableCaretCandidate$1;\n    const getParents$3 = (node, root) => {\n      const parents = [];\n      while (node && node !== root) {\n        parents.push(node);\n        node = node.parentNode;\n      }\n      return parents;\n    };\n    const nodeAtIndex = (container, offset) => {\n      if (container.hasChildNodes() && offset < container.childNodes.length) {\n        return container.childNodes[offset];\n      }\n      return null;\n    };\n    const getCaretCandidatePosition = (direction, node) => {\n      if (isForwards(direction)) {\n        if (isCaretCandidate(node.previousSibling) && !isText$2(node.previousSibling)) {\n          return CaretPosition.before(node);\n        }\n        if (isText$2(node)) {\n          return CaretPosition(node, 0);\n        }\n      }\n      if (isBackwards(direction)) {\n        if (isCaretCandidate(node.nextSibling) && !isText$2(node.nextSibling)) {\n          return CaretPosition.after(node);\n        }\n        if (isText$2(node)) {\n          return CaretPosition(node, node.data.length);\n        }\n      }\n      if (isBackwards(direction)) {\n        if (isBr$1(node)) {\n          return CaretPosition.before(node);\n        }\n        return CaretPosition.after(node);\n      }\n      return CaretPosition.before(node);\n    };\n    const moveForwardFromBr = (root, nextNode) => {\n      const nextSibling = nextNode.nextSibling;\n      if (nextSibling && isCaretCandidate(nextSibling)) {\n        if (isText$2(nextSibling)) {\n          return CaretPosition(nextSibling, 0);\n        } else {\n          return CaretPosition.before(nextSibling);\n        }\n      } else {\n        return findCaretPosition$1(HDirection.Forwards, CaretPosition.after(nextNode), root);\n      }\n    };\n    const findCaretPosition$1 = (direction, startPos, root) => {\n      let node;\n      let nextNode;\n      let innerNode;\n      let caretPosition;\n      if (!isElement$1(root) || !startPos) {\n        return null;\n      }\n      if (startPos.isEqual(CaretPosition.after(root)) && root.lastChild) {\n        caretPosition = CaretPosition.after(root.lastChild);\n        if (isBackwards(direction) && isCaretCandidate(root.lastChild) && isElement$1(root.lastChild)) {\n          return isBr$1(root.lastChild) ? CaretPosition.before(root.lastChild) : caretPosition;\n        }\n      } else {\n        caretPosition = startPos;\n      }\n      const container = caretPosition.container();\n      let offset = caretPosition.offset();\n      if (isText$2(container)) {\n        if (isBackwards(direction) && offset > 0) {\n          return CaretPosition(container, --offset);\n        }\n        if (isForwards(direction) && offset < container.length) {\n          return CaretPosition(container, ++offset);\n        }\n        node = container;\n      } else {\n        if (isBackwards(direction) && offset > 0) {\n          nextNode = nodeAtIndex(container, offset - 1);\n          if (isCaretCandidate(nextNode)) {\n            if (!isAtomic(nextNode)) {\n              innerNode = findNode(nextNode, direction, isEditableCaretCandidate, nextNode);\n              if (innerNode) {\n                if (isText$2(innerNode)) {\n                  return CaretPosition(innerNode, innerNode.data.length);\n                }\n                return CaretPosition.after(innerNode);\n              }\n            }\n            if (isText$2(nextNode)) {\n              return CaretPosition(nextNode, nextNode.data.length);\n            }\n            return CaretPosition.before(nextNode);\n          }\n        }\n        if (isForwards(direction) && offset < container.childNodes.length) {\n          nextNode = nodeAtIndex(container, offset);\n          if (isCaretCandidate(nextNode)) {\n            if (isBr$1(nextNode)) {\n              return moveForwardFromBr(root, nextNode);\n            }\n            if (!isAtomic(nextNode)) {\n              innerNode = findNode(nextNode, direction, isEditableCaretCandidate, nextNode);\n              if (innerNode) {\n                if (isText$2(innerNode)) {\n                  return CaretPosition(innerNode, 0);\n                }\n                return CaretPosition.before(innerNode);\n              }\n            }\n            if (isText$2(nextNode)) {\n              return CaretPosition(nextNode, 0);\n            }\n            return CaretPosition.after(nextNode);\n          }\n        }\n        node = nextNode ? nextNode : caretPosition.getNode();\n      }\n      if (isForwards(direction) && caretPosition.isAtEnd() || isBackwards(direction) && caretPosition.isAtStart()) {\n        node = findNode(node, direction, always, root, true);\n        if (isEditableCaretCandidate(node, root)) {\n          return getCaretCandidatePosition(direction, node);\n        }\n      }\n      nextNode = findNode(node, direction, isEditableCaretCandidate, root);\n      const rootContentEditableFalseElm = last$2(filter$6(getParents$3(container, root), isContentEditableFalse$5));\n      if (rootContentEditableFalseElm && (!nextNode || !rootContentEditableFalseElm.contains(nextNode))) {\n        if (isForwards(direction)) {\n          caretPosition = CaretPosition.after(rootContentEditableFalseElm);\n        } else {\n          caretPosition = CaretPosition.before(rootContentEditableFalseElm);\n        }\n        return caretPosition;\n      }\n      if (nextNode) {\n        return getCaretCandidatePosition(direction, nextNode);\n      }\n      return null;\n    };\n    const CaretWalker = root => ({\n      next: caretPosition => {\n        return findCaretPosition$1(HDirection.Forwards, caretPosition, root);\n      },\n      prev: caretPosition => {\n        return findCaretPosition$1(HDirection.Backwards, caretPosition, root);\n      }\n    });\n\n    const walkToPositionIn = (forward, root, start) => {\n      const position = forward ? CaretPosition.before(start) : CaretPosition.after(start);\n      return fromPosition(forward, root, position);\n    };\n    const afterElement = node => isBr$5(node) ? CaretPosition.before(node) : CaretPosition.after(node);\n    const isBeforeOrStart = position => {\n      if (CaretPosition.isTextPosition(position)) {\n        return position.offset() === 0;\n      } else {\n        return isCaretCandidate$3(position.getNode());\n      }\n    };\n    const isAfterOrEnd = position => {\n      if (CaretPosition.isTextPosition(position)) {\n        const container = position.container();\n        return position.offset() === container.data.length;\n      } else {\n        return isCaretCandidate$3(position.getNode(true));\n      }\n    };\n    const isBeforeAfterSameElement = (from, to) => !CaretPosition.isTextPosition(from) && !CaretPosition.isTextPosition(to) && from.getNode() === to.getNode(true);\n    const isAtBr = position => !CaretPosition.isTextPosition(position) && isBr$5(position.getNode());\n    const shouldSkipPosition = (forward, from, to) => {\n      if (forward) {\n        return !isBeforeAfterSameElement(from, to) && !isAtBr(from) && isAfterOrEnd(from) && isBeforeOrStart(to);\n      } else {\n        return !isBeforeAfterSameElement(to, from) && isBeforeOrStart(from) && isAfterOrEnd(to);\n      }\n    };\n    const fromPosition = (forward, root, pos) => {\n      const walker = CaretWalker(root);\n      return Optional.from(forward ? walker.next(pos) : walker.prev(pos));\n    };\n    const navigate = (forward, root, from) => fromPosition(forward, root, from).bind(to => {\n      if (isInSameBlock(from, to, root) && shouldSkipPosition(forward, from, to)) {\n        return fromPosition(forward, root, to);\n      } else {\n        return Optional.some(to);\n      }\n    });\n    const navigateIgnore = (forward, root, from, ignoreFilter) => navigate(forward, root, from).bind(pos => ignoreFilter(pos) ? navigateIgnore(forward, root, pos, ignoreFilter) : Optional.some(pos));\n    const positionIn = (forward, element) => {\n      const startNode = forward ? element.firstChild : element.lastChild;\n      if (isText$8(startNode)) {\n        return Optional.some(CaretPosition(startNode, forward ? 0 : startNode.data.length));\n      } else if (startNode) {\n        if (isCaretCandidate$3(startNode)) {\n          return Optional.some(forward ? CaretPosition.before(startNode) : afterElement(startNode));\n        } else {\n          return walkToPositionIn(forward, element, startNode);\n        }\n      } else {\n        return Optional.none();\n      }\n    };\n    const nextPosition = curry(fromPosition, true);\n    const prevPosition = curry(fromPosition, false);\n    const firstPositionIn = curry(positionIn, true);\n    const lastPositionIn = curry(positionIn, false);\n\n    const CARET_ID$1 = '_mce_caret';\n    const isCaretNode = node => isElement$6(node) && node.id === CARET_ID$1;\n    const getParentCaretContainer = (body, node) => {\n      while (node && node !== body) {\n        if (node.id === CARET_ID$1) {\n          return node;\n        }\n        node = node.parentNode;\n      }\n      return null;\n    };\n\n    const isStringPathBookmark = bookmark => isString(bookmark.start);\n    const isRangeBookmark = bookmark => has$2(bookmark, 'rng');\n    const isIdBookmark = bookmark => has$2(bookmark, 'id');\n    const isIndexBookmark = bookmark => has$2(bookmark, 'name');\n    const isPathBookmark = bookmark => Tools.isArray(bookmark.start);\n\n    const addBogus = (dom, node) => {\n      if (isElement$6(node) && dom.isBlock(node) && !node.innerHTML) {\n        node.innerHTML = '<br data-mce-bogus=\"1\" />';\n      }\n      return node;\n    };\n    const resolveCaretPositionBookmark = (dom, bookmark) => {\n      let pos;\n      const rng = dom.createRng();\n      pos = resolve$1(dom.getRoot(), bookmark.start);\n      rng.setStart(pos.container(), pos.offset());\n      pos = resolve$1(dom.getRoot(), bookmark.end);\n      rng.setEnd(pos.container(), pos.offset());\n      return rng;\n    };\n    const insertZwsp = (node, rng) => {\n      const textNode = node.ownerDocument.createTextNode(ZWSP$1);\n      node.appendChild(textNode);\n      rng.setStart(textNode, 0);\n      rng.setEnd(textNode, 0);\n    };\n    const isEmpty$1 = node => node.hasChildNodes() === false;\n    const tryFindRangePosition = (node, rng) => lastPositionIn(node).fold(never, pos => {\n      rng.setStart(pos.container(), pos.offset());\n      rng.setEnd(pos.container(), pos.offset());\n      return true;\n    });\n    const padEmptyCaretContainer = (root, node, rng) => {\n      if (isEmpty$1(node) && getParentCaretContainer(root, node)) {\n        insertZwsp(node, rng);\n        return true;\n      } else {\n        return false;\n      }\n    };\n    const setEndPoint = (dom, start, bookmark, rng) => {\n      const point = bookmark[start ? 'start' : 'end'];\n      let i, node, offset, children;\n      const root = dom.getRoot();\n      if (point) {\n        offset = point[0];\n        for (node = root, i = point.length - 1; i >= 1; i--) {\n          children = node.childNodes;\n          if (padEmptyCaretContainer(root, node, rng)) {\n            return true;\n          }\n          if (point[i] > children.length - 1) {\n            if (padEmptyCaretContainer(root, node, rng)) {\n              return true;\n            }\n            return tryFindRangePosition(node, rng);\n          }\n          node = children[point[i]];\n        }\n        if (node.nodeType === 3) {\n          offset = Math.min(point[0], node.nodeValue.length);\n        }\n        if (node.nodeType === 1) {\n          offset = Math.min(point[0], node.childNodes.length);\n        }\n        if (start) {\n          rng.setStart(node, offset);\n        } else {\n          rng.setEnd(node, offset);\n        }\n      }\n      return true;\n    };\n    const isValidTextNode = node => isText$8(node) && node.data.length > 0;\n    const restoreEndPoint = (dom, suffix, bookmark) => {\n      let marker = dom.get(bookmark.id + '_' + suffix), node, idx, next, prev;\n      const keep = bookmark.keep;\n      let container, offset;\n      if (marker) {\n        node = marker.parentNode;\n        if (suffix === 'start') {\n          if (!keep) {\n            idx = dom.nodeIndex(marker);\n          } else {\n            if (marker.hasChildNodes()) {\n              node = marker.firstChild;\n              idx = 1;\n            } else if (isValidTextNode(marker.nextSibling)) {\n              node = marker.nextSibling;\n              idx = 0;\n            } else if (isValidTextNode(marker.previousSibling)) {\n              node = marker.previousSibling;\n              idx = marker.previousSibling.data.length;\n            } else {\n              node = marker.parentNode;\n              idx = dom.nodeIndex(marker) + 1;\n            }\n          }\n          container = node;\n          offset = idx;\n        } else {\n          if (!keep) {\n            idx = dom.nodeIndex(marker);\n          } else {\n            if (marker.hasChildNodes()) {\n              node = marker.firstChild;\n              idx = 1;\n            } else if (isValidTextNode(marker.previousSibling)) {\n              node = marker.previousSibling;\n              idx = marker.previousSibling.data.length;\n            } else {\n              node = marker.parentNode;\n              idx = dom.nodeIndex(marker);\n            }\n          }\n          container = node;\n          offset = idx;\n        }\n        if (!keep) {\n          prev = marker.previousSibling;\n          next = marker.nextSibling;\n          Tools.each(Tools.grep(marker.childNodes), node => {\n            if (isText$8(node)) {\n              node.nodeValue = node.nodeValue.replace(/\\uFEFF/g, '');\n            }\n          });\n          while (marker = dom.get(bookmark.id + '_' + suffix)) {\n            dom.remove(marker, true);\n          }\n          if (prev && next && prev.nodeType === next.nodeType && isText$8(prev) && !Env.browser.isOpera()) {\n            idx = prev.nodeValue.length;\n            prev.appendData(next.nodeValue);\n            dom.remove(next);\n            container = prev;\n            offset = idx;\n          }\n        }\n        return Optional.some(CaretPosition(container, offset));\n      } else {\n        return Optional.none();\n      }\n    };\n    const resolvePaths = (dom, bookmark) => {\n      const rng = dom.createRng();\n      if (setEndPoint(dom, true, bookmark, rng) && setEndPoint(dom, false, bookmark, rng)) {\n        return Optional.some(rng);\n      } else {\n        return Optional.none();\n      }\n    };\n    const resolveId = (dom, bookmark) => {\n      const startPos = restoreEndPoint(dom, 'start', bookmark);\n      const endPos = restoreEndPoint(dom, 'end', bookmark);\n      return lift2(startPos, endPos.or(startPos), (spos, epos) => {\n        const rng = dom.createRng();\n        rng.setStart(addBogus(dom, spos.container()), spos.offset());\n        rng.setEnd(addBogus(dom, epos.container()), epos.offset());\n        return rng;\n      });\n    };\n    const resolveIndex = (dom, bookmark) => Optional.from(dom.select(bookmark.name)[bookmark.index]).map(elm => {\n      const rng = dom.createRng();\n      rng.selectNode(elm);\n      return rng;\n    });\n    const resolve = (selection, bookmark) => {\n      const dom = selection.dom;\n      if (bookmark) {\n        if (isPathBookmark(bookmark)) {\n          return resolvePaths(dom, bookmark);\n        } else if (isStringPathBookmark(bookmark)) {\n          return Optional.some(resolveCaretPositionBookmark(dom, bookmark));\n        } else if (isIdBookmark(bookmark)) {\n          return resolveId(dom, bookmark);\n        } else if (isIndexBookmark(bookmark)) {\n          return resolveIndex(dom, bookmark);\n        } else if (isRangeBookmark(bookmark)) {\n          return Optional.some(bookmark.rng);\n        }\n      }\n      return Optional.none();\n    };\n\n    const getBookmark$1 = (selection, type, normalized) => {\n      return getBookmark$2(selection, type, normalized);\n    };\n    const moveToBookmark = (selection, bookmark) => {\n      resolve(selection, bookmark).each(rng => {\n        selection.setRng(rng);\n      });\n    };\n    const isBookmarkNode$1 = node => {\n      return isElement$6(node) && node.tagName === 'SPAN' && node.getAttribute('data-mce-type') === 'bookmark';\n    };\n\n    const is = expected => actual => expected === actual;\n    const isNbsp = is(nbsp);\n    const isWhiteSpace = chr => chr !== '' && ' \\f\\n\\r\\t\\x0B'.indexOf(chr) !== -1;\n    const isContent = chr => !isWhiteSpace(chr) && !isNbsp(chr) && !isZwsp$1(chr);\n\n    const hexColour = value => ({ value });\n    const toHex = component => {\n      const hex = component.toString(16);\n      return (hex.length === 1 ? '0' + hex : hex).toUpperCase();\n    };\n    const fromRgba = rgbaColour => {\n      const value = toHex(rgbaColour.red) + toHex(rgbaColour.green) + toHex(rgbaColour.blue);\n      return hexColour(value);\n    };\n\n    const rgbRegex = /^\\s*rgb\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)\\s*$/i;\n    const rgbaRegex = /^\\s*rgba\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d?(?:\\.\\d+)?)\\s*\\)\\s*$/i;\n    const rgbaColour = (red, green, blue, alpha) => ({\n      red,\n      green,\n      blue,\n      alpha\n    });\n    const fromStringValues = (red, green, blue, alpha) => {\n      const r = parseInt(red, 10);\n      const g = parseInt(green, 10);\n      const b = parseInt(blue, 10);\n      const a = parseFloat(alpha);\n      return rgbaColour(r, g, b, a);\n    };\n    const fromString = rgbaString => {\n      if (rgbaString === 'transparent') {\n        return Optional.some(rgbaColour(0, 0, 0, 0));\n      }\n      const rgbMatch = rgbRegex.exec(rgbaString);\n      if (rgbMatch !== null) {\n        return Optional.some(fromStringValues(rgbMatch[1], rgbMatch[2], rgbMatch[3], '1'));\n      }\n      const rgbaMatch = rgbaRegex.exec(rgbaString);\n      if (rgbaMatch !== null) {\n        return Optional.some(fromStringValues(rgbaMatch[1], rgbaMatch[2], rgbaMatch[3], rgbaMatch[4]));\n      }\n      return Optional.none();\n    };\n\n    const rgbaToHexString = color => fromString(color).map(fromRgba).map(h => '#' + h.value).getOr(color);\n\n    const isNode = node => !!node.nodeType;\n    const isInlineBlock = node => {\n      return node && /^(IMG)$/.test(node.nodeName);\n    };\n    const moveStart = (dom, selection, rng) => {\n      const offset = rng.startOffset;\n      let container = rng.startContainer;\n      if (container === rng.endContainer) {\n        if (isInlineBlock(container.childNodes[offset])) {\n          return;\n        }\n      }\n      if (isElement$6(container)) {\n        const nodes = container.childNodes;\n        let walker;\n        if (offset < nodes.length) {\n          container = nodes[offset];\n          walker = new DomTreeWalker(container, dom.getParent(container, dom.isBlock));\n        } else {\n          container = nodes[nodes.length - 1];\n          walker = new DomTreeWalker(container, dom.getParent(container, dom.isBlock));\n          walker.next(true);\n        }\n        for (let node = walker.current(); node; node = walker.next()) {\n          if (isText$8(node) && !isWhiteSpaceNode$1(node)) {\n            rng.setStart(node, 0);\n            selection.setRng(rng);\n            return;\n          }\n        }\n      }\n    };\n    const getNonWhiteSpaceSibling = (node, next, inc) => {\n      if (node) {\n        const nextName = next ? 'nextSibling' : 'previousSibling';\n        for (node = inc ? node : node[nextName]; node; node = node[nextName]) {\n          if (isElement$6(node) || !isWhiteSpaceNode$1(node)) {\n            return node;\n          }\n        }\n      }\n    };\n    const isTextBlock$1 = (editor, name) => {\n      if (isNode(name)) {\n        name = name.nodeName;\n      }\n      return !!editor.schema.getTextBlockElements()[name.toLowerCase()];\n    };\n    const isValid = (ed, parent, child) => {\n      return ed.schema.isValidChild(parent, child);\n    };\n    const isWhiteSpaceNode$1 = (node, allowSpaces = false) => {\n      if (isNonNullable(node) && isText$8(node)) {\n        const data = allowSpaces ? node.data.replace(/ /g, '\\xA0') : node.data;\n        return isWhitespaceText(data);\n      } else {\n        return false;\n      }\n    };\n    const isEmptyTextNode$1 = node => {\n      return isNonNullable(node) && isText$8(node) && node.length === 0;\n    };\n    const replaceVars = (value, vars) => {\n      if (isFunction(value)) {\n        value = value(vars);\n      } else if (isNonNullable(vars)) {\n        value = value.replace(/%(\\w+)/g, (str, name) => {\n          return vars[name] || str;\n        });\n      }\n      return value;\n    };\n    const isEq$5 = (str1, str2) => {\n      str1 = str1 || '';\n      str2 = str2 || '';\n      str1 = '' + (str1.nodeName || str1);\n      str2 = '' + (str2.nodeName || str2);\n      return str1.toLowerCase() === str2.toLowerCase();\n    };\n    const normalizeStyleValue = (value, name) => {\n      if (name === 'color' || name === 'backgroundColor') {\n        value = rgbaToHexString(value);\n      }\n      if (name === 'fontWeight' && value === 700) {\n        value = 'bold';\n      }\n      if (name === 'fontFamily') {\n        value = value.replace(/[\\'\\\"]/g, '').replace(/,\\s+/g, ',');\n      }\n      return '' + value;\n    };\n    const getStyle = (dom, node, name) => {\n      return normalizeStyleValue(dom.getStyle(node, name), name);\n    };\n    const getTextDecoration = (dom, node) => {\n      let decoration;\n      dom.getParent(node, n => {\n        decoration = dom.getStyle(n, 'text-decoration');\n        return decoration && decoration !== 'none';\n      });\n      return decoration;\n    };\n    const getParents$2 = (dom, node, selector) => {\n      return dom.getParents(node, selector, dom.getRoot());\n    };\n    const isVariableFormatName = (editor, formatName) => {\n      const hasVariableValues = format => {\n        const isVariableValue = val => val.length > 1 && val.charAt(0) === '%';\n        return exists([\n          'styles',\n          'attributes'\n        ], key => get$a(format, key).exists(field => {\n          const fieldValues = isArray$1(field) ? field : values(field);\n          return exists(fieldValues, isVariableValue);\n        }));\n      };\n      return exists(editor.formatter.get(formatName), hasVariableValues);\n    };\n    const areSimilarFormats = (editor, formatName, otherFormatName) => {\n      const validKeys = [\n        'inline',\n        'block',\n        'selector',\n        'attributes',\n        'styles',\n        'classes'\n      ];\n      const filterObj = format => filter$5(format, (_, key) => exists(validKeys, validKey => validKey === key));\n      return exists(editor.formatter.get(formatName), fmt1 => {\n        const filteredFmt1 = filterObj(fmt1);\n        return exists(editor.formatter.get(otherFormatName), fmt2 => {\n          const filteredFmt2 = filterObj(fmt2);\n          return equal$1(filteredFmt1, filteredFmt2);\n        });\n      });\n    };\n    const isBlockFormat = format => hasNonNullableKey(format, 'block');\n    const isSelectorFormat = format => hasNonNullableKey(format, 'selector');\n    const isInlineFormat = format => hasNonNullableKey(format, 'inline');\n    const isMixedFormat = format => isSelectorFormat(format) && isInlineFormat(format) && is$2(get$a(format, 'mixed'), true);\n    const shouldExpandToSelector = format => isSelectorFormat(format) && format.expand !== false && !isInlineFormat(format);\n\n    const isBookmarkNode = isBookmarkNode$1;\n    const getParents$1 = getParents$2;\n    const isWhiteSpaceNode = isWhiteSpaceNode$1;\n    const isTextBlock = isTextBlock$1;\n    const isBogusBr = node => {\n      return isBr$5(node) && node.getAttribute('data-mce-bogus') && !node.nextSibling;\n    };\n    const findParentContentEditable = (dom, node) => {\n      let parent = node;\n      while (parent) {\n        if (isElement$6(parent) && dom.getContentEditable(parent)) {\n          return dom.getContentEditable(parent) === 'false' ? parent : node;\n        }\n        parent = parent.parentNode;\n      }\n      return node;\n    };\n    const walkText = (start, node, offset, predicate) => {\n      const str = node.data;\n      for (let i = offset; start ? i >= 0 : i < str.length; start ? i-- : i++) {\n        if (predicate(str.charAt(i))) {\n          return start ? i + 1 : i;\n        }\n      }\n      return -1;\n    };\n    const findSpace = (start, node, offset) => walkText(start, node, offset, c => isNbsp(c) || isWhiteSpace(c));\n    const findContent = (start, node, offset) => walkText(start, node, offset, isContent);\n    const findWordEndPoint = (dom, body, container, offset, start, includeTrailingSpaces) => {\n      let lastTextNode;\n      const rootNode = dom.getParent(container, dom.isBlock) || body;\n      const walk = (container, offset, pred) => {\n        const textSeeker = TextSeeker(dom);\n        const walker = start ? textSeeker.backwards : textSeeker.forwards;\n        return Optional.from(walker(container, offset, (text, textOffset) => {\n          if (isBookmarkNode(text.parentNode)) {\n            return -1;\n          } else {\n            lastTextNode = text;\n            return pred(start, text, textOffset);\n          }\n        }, rootNode));\n      };\n      const spaceResult = walk(container, offset, findSpace);\n      return spaceResult.bind(result => includeTrailingSpaces ? walk(result.container, result.offset + (start ? -1 : 0), findContent) : Optional.some(result)).orThunk(() => lastTextNode ? Optional.some({\n        container: lastTextNode,\n        offset: start ? 0 : lastTextNode.length\n      }) : Optional.none());\n    };\n    const findSelectorEndPoint = (dom, formatList, rng, container, siblingName) => {\n      if (isText$8(container) && isEmpty$3(container.data) && container[siblingName]) {\n        container = container[siblingName];\n      }\n      const parents = getParents$1(dom, container);\n      for (let i = 0; i < parents.length; i++) {\n        for (let y = 0; y < formatList.length; y++) {\n          const curFormat = formatList[y];\n          if (isNonNullable(curFormat.collapsed) && curFormat.collapsed !== rng.collapsed) {\n            continue;\n          }\n          if (isSelectorFormat(curFormat) && dom.is(parents[i], curFormat.selector)) {\n            return parents[i];\n          }\n        }\n      }\n      return container;\n    };\n    const findBlockEndPoint = (editor, formatList, container, siblingName) => {\n      let node = container;\n      const dom = editor.dom;\n      const root = dom.getRoot();\n      const format = formatList[0];\n      if (isBlockFormat(format)) {\n        node = format.wrapper ? null : dom.getParent(container, format.block, root);\n      }\n      if (!node) {\n        const scopeRoot = dom.getParent(container, 'LI,TD,TH');\n        node = dom.getParent(isText$8(container) ? container.parentNode : container, node => node !== root && isTextBlock(editor, node), scopeRoot);\n      }\n      if (node && isBlockFormat(format) && format.wrapper) {\n        node = getParents$1(dom, node, 'ul,ol').reverse()[0] || node;\n      }\n      if (!node) {\n        node = container;\n        while (node[siblingName] && !dom.isBlock(node[siblingName])) {\n          node = node[siblingName];\n          if (isEq$5(node, 'br')) {\n            break;\n          }\n        }\n      }\n      return node || container;\n    };\n    const isAtBlockBoundary$1 = (dom, root, container, siblingName) => {\n      const parent = container.parentNode;\n      if (isNonNullable(container[siblingName])) {\n        return false;\n      } else if (parent === root || isNullable(parent) || dom.isBlock(parent)) {\n        return true;\n      } else {\n        return isAtBlockBoundary$1(dom, root, parent, siblingName);\n      }\n    };\n    const findParentContainer = (dom, formatList, container, offset, start) => {\n      let parent = container;\n      const siblingName = start ? 'previousSibling' : 'nextSibling';\n      const root = dom.getRoot();\n      if (isText$8(container) && !isWhiteSpaceNode(container)) {\n        if (start ? offset > 0 : offset < container.data.length) {\n          return container;\n        }\n      }\n      while (true) {\n        if (!formatList[0].block_expand && dom.isBlock(parent)) {\n          return parent;\n        }\n        for (let sibling = parent[siblingName]; sibling; sibling = sibling[siblingName]) {\n          const allowSpaces = isText$8(sibling) && !isAtBlockBoundary$1(dom, root, sibling, siblingName);\n          if (!isBookmarkNode(sibling) && !isBogusBr(sibling) && !isWhiteSpaceNode(sibling, allowSpaces)) {\n            return parent;\n          }\n        }\n        if (parent === root || parent.parentNode === root) {\n          container = parent;\n          break;\n        }\n        parent = parent.parentNode;\n      }\n      return container;\n    };\n    const isSelfOrParentBookmark = container => isBookmarkNode(container.parentNode) || isBookmarkNode(container);\n    const expandRng = (editor, rng, formatList, includeTrailingSpace = false) => {\n      let {startContainer, startOffset, endContainer, endOffset} = rng;\n      const dom = editor.dom;\n      const format = formatList[0];\n      if (isElement$6(startContainer) && startContainer.hasChildNodes()) {\n        startContainer = getNode$1(startContainer, startOffset);\n        if (isText$8(startContainer)) {\n          startOffset = 0;\n        }\n      }\n      if (isElement$6(endContainer) && endContainer.hasChildNodes()) {\n        endContainer = getNode$1(endContainer, rng.collapsed ? endOffset : endOffset - 1);\n        if (isText$8(endContainer)) {\n          endOffset = endContainer.nodeValue.length;\n        }\n      }\n      startContainer = findParentContentEditable(dom, startContainer);\n      endContainer = findParentContentEditable(dom, endContainer);\n      if (isSelfOrParentBookmark(startContainer)) {\n        startContainer = isBookmarkNode(startContainer) ? startContainer : startContainer.parentNode;\n        if (rng.collapsed) {\n          startContainer = startContainer.previousSibling || startContainer;\n        } else {\n          startContainer = startContainer.nextSibling || startContainer;\n        }\n        if (isText$8(startContainer)) {\n          startOffset = rng.collapsed ? startContainer.length : 0;\n        }\n      }\n      if (isSelfOrParentBookmark(endContainer)) {\n        endContainer = isBookmarkNode(endContainer) ? endContainer : endContainer.parentNode;\n        if (rng.collapsed) {\n          endContainer = endContainer.nextSibling || endContainer;\n        } else {\n          endContainer = endContainer.previousSibling || endContainer;\n        }\n        if (isText$8(endContainer)) {\n          endOffset = rng.collapsed ? 0 : endContainer.length;\n        }\n      }\n      if (rng.collapsed) {\n        const startPoint = findWordEndPoint(dom, editor.getBody(), startContainer, startOffset, true, includeTrailingSpace);\n        startPoint.each(({container, offset}) => {\n          startContainer = container;\n          startOffset = offset;\n        });\n        const endPoint = findWordEndPoint(dom, editor.getBody(), endContainer, endOffset, false, includeTrailingSpace);\n        endPoint.each(({container, offset}) => {\n          endContainer = container;\n          endOffset = offset;\n        });\n      }\n      if (isInlineFormat(format) || format.block_expand) {\n        if (!isInlineFormat(format) || (!isText$8(startContainer) || startOffset === 0)) {\n          startContainer = findParentContainer(dom, formatList, startContainer, startOffset, true);\n        }\n        if (!isInlineFormat(format) || (!isText$8(endContainer) || endOffset === endContainer.nodeValue.length)) {\n          endContainer = findParentContainer(dom, formatList, endContainer, endOffset, false);\n        }\n      }\n      if (shouldExpandToSelector(format)) {\n        startContainer = findSelectorEndPoint(dom, formatList, rng, startContainer, 'previousSibling');\n        endContainer = findSelectorEndPoint(dom, formatList, rng, endContainer, 'nextSibling');\n      }\n      if (isBlockFormat(format) || isSelectorFormat(format)) {\n        startContainer = findBlockEndPoint(editor, formatList, startContainer, 'previousSibling');\n        endContainer = findBlockEndPoint(editor, formatList, endContainer, 'nextSibling');\n        if (isBlockFormat(format)) {\n          if (!dom.isBlock(startContainer)) {\n            startContainer = findParentContainer(dom, formatList, startContainer, startOffset, true);\n          }\n          if (!dom.isBlock(endContainer)) {\n            endContainer = findParentContainer(dom, formatList, endContainer, endOffset, false);\n          }\n        }\n      }\n      if (isElement$6(startContainer)) {\n        startOffset = dom.nodeIndex(startContainer);\n        startContainer = startContainer.parentNode;\n      }\n      if (isElement$6(endContainer)) {\n        endOffset = dom.nodeIndex(endContainer) + 1;\n        endContainer = endContainer.parentNode;\n      }\n      return {\n        startContainer,\n        startOffset,\n        endContainer,\n        endOffset\n      };\n    };\n\n    const walk$3 = (dom, rng, callback) => {\n      const startOffset = rng.startOffset;\n      const startContainer = getNode$1(rng.startContainer, startOffset);\n      const endOffset = rng.endOffset;\n      const endContainer = getNode$1(rng.endContainer, endOffset - 1);\n      const exclude = nodes => {\n        const firstNode = nodes[0];\n        if (isText$8(firstNode) && firstNode === startContainer && startOffset >= firstNode.data.length) {\n          nodes.splice(0, 1);\n        }\n        const lastNode = nodes[nodes.length - 1];\n        if (endOffset === 0 && nodes.length > 0 && lastNode === endContainer && isText$8(lastNode)) {\n          nodes.splice(nodes.length - 1, 1);\n        }\n        return nodes;\n      };\n      const collectSiblings = (node, name, endNode) => {\n        const siblings = [];\n        for (; node && node !== endNode; node = node[name]) {\n          siblings.push(node);\n        }\n        return siblings;\n      };\n      const findEndPoint = (node, root) => dom.getParent(node, node => node.parentNode === root, root);\n      const walkBoundary = (startNode, endNode, next) => {\n        const siblingName = next ? 'nextSibling' : 'previousSibling';\n        for (let node = startNode, parent = node.parentNode; node && node !== endNode; node = parent) {\n          parent = node.parentNode;\n          const siblings = collectSiblings(node === startNode ? node : node[siblingName], siblingName);\n          if (siblings.length) {\n            if (!next) {\n              siblings.reverse();\n            }\n            callback(exclude(siblings));\n          }\n        }\n      };\n      if (startContainer === endContainer) {\n        return callback(exclude([startContainer]));\n      }\n      const ancestor = dom.findCommonAncestor(startContainer, endContainer);\n      if (dom.isChildOf(startContainer, endContainer)) {\n        return walkBoundary(startContainer, ancestor, true);\n      }\n      if (dom.isChildOf(endContainer, startContainer)) {\n        return walkBoundary(endContainer, ancestor);\n      }\n      const startPoint = findEndPoint(startContainer, ancestor) || startContainer;\n      const endPoint = findEndPoint(endContainer, ancestor) || endContainer;\n      walkBoundary(startContainer, startPoint, true);\n      const siblings = collectSiblings(startPoint === startContainer ? startPoint : startPoint.nextSibling, 'nextSibling', endPoint === endContainer ? endPoint.nextSibling : endPoint);\n      if (siblings.length) {\n        callback(exclude(siblings));\n      }\n      walkBoundary(endContainer, endPoint);\n    };\n\n    const getRanges$1 = selection => {\n      const ranges = [];\n      if (selection) {\n        for (let i = 0; i < selection.rangeCount; i++) {\n          ranges.push(selection.getRangeAt(i));\n        }\n      }\n      return ranges;\n    };\n    const getSelectedNodes = ranges => {\n      return bind$3(ranges, range => {\n        const node = getSelectedNode(range);\n        return node ? [SugarElement.fromDom(node)] : [];\n      });\n    };\n    const hasMultipleRanges = selection => {\n      return getRanges$1(selection).length > 1;\n    };\n\n    const getCellsFromRanges = ranges => filter$6(getSelectedNodes(ranges), isTableCell$4);\n    const getCellsFromElement = elm => descendants(elm, 'td[data-mce-selected],th[data-mce-selected]');\n    const getCellsFromElementOrRanges = (ranges, element) => {\n      const selectedCells = getCellsFromElement(element);\n      return selectedCells.length > 0 ? selectedCells : getCellsFromRanges(ranges);\n    };\n    const getCellsFromEditor = editor => getCellsFromElementOrRanges(getRanges$1(editor.selection.getSel()), SugarElement.fromDom(editor.getBody()));\n    const getClosestTable = (cell, isRoot) => ancestor$2(cell, 'table', isRoot);\n\n    const getStartNode = rng => {\n      const sc = rng.startContainer, so = rng.startOffset;\n      if (isText$8(sc)) {\n        return so === 0 ? Optional.some(SugarElement.fromDom(sc)) : Optional.none();\n      } else {\n        return Optional.from(sc.childNodes[so]).map(SugarElement.fromDom);\n      }\n    };\n    const getEndNode = rng => {\n      const ec = rng.endContainer, eo = rng.endOffset;\n      if (isText$8(ec)) {\n        return eo === ec.data.length ? Optional.some(SugarElement.fromDom(ec)) : Optional.none();\n      } else {\n        return Optional.from(ec.childNodes[eo - 1]).map(SugarElement.fromDom);\n      }\n    };\n    const getFirstChildren = node => {\n      return firstChild(node).fold(constant([node]), child => {\n        return [node].concat(getFirstChildren(child));\n      });\n    };\n    const getLastChildren$1 = node => {\n      return lastChild(node).fold(constant([node]), child => {\n        if (name(child) === 'br') {\n          return prevSibling(child).map(sibling => {\n            return [node].concat(getLastChildren$1(sibling));\n          }).getOr([]);\n        } else {\n          return [node].concat(getLastChildren$1(child));\n        }\n      });\n    };\n    const hasAllContentsSelected = (elm, rng) => {\n      return lift2(getStartNode(rng), getEndNode(rng), (startNode, endNode) => {\n        const start = find$2(getFirstChildren(elm), curry(eq, startNode));\n        const end = find$2(getLastChildren$1(elm), curry(eq, endNode));\n        return start.isSome() && end.isSome();\n      }).getOr(false);\n    };\n    const moveEndPoint = (dom, rng, node, start) => {\n      const root = node, walker = new DomTreeWalker(node, root);\n      const moveCaretBeforeOnEnterElementsMap = filter$5(dom.schema.getMoveCaretBeforeOnEnterElements(), (_, name) => !contains$2([\n        'td',\n        'th',\n        'table'\n      ], name.toLowerCase()));\n      do {\n        if (isText$8(node) && Tools.trim(node.nodeValue).length !== 0) {\n          if (start) {\n            rng.setStart(node, 0);\n          } else {\n            rng.setEnd(node, node.nodeValue.length);\n          }\n          return;\n        }\n        if (moveCaretBeforeOnEnterElementsMap[node.nodeName]) {\n          if (start) {\n            rng.setStartBefore(node);\n          } else {\n            if (node.nodeName === 'BR') {\n              rng.setEndBefore(node);\n            } else {\n              rng.setEndAfter(node);\n            }\n          }\n          return;\n        }\n      } while (node = start ? walker.next() : walker.prev());\n      if (root.nodeName === 'BODY') {\n        if (start) {\n          rng.setStart(root, 0);\n        } else {\n          rng.setEnd(root, root.childNodes.length);\n        }\n      }\n    };\n    const hasAnyRanges = editor => {\n      const sel = editor.selection.getSel();\n      return sel && sel.rangeCount > 0;\n    };\n    const runOnRanges = (editor, executor) => {\n      const fakeSelectionNodes = getCellsFromEditor(editor);\n      if (fakeSelectionNodes.length > 0) {\n        each$g(fakeSelectionNodes, elem => {\n          const node = elem.dom;\n          const fakeNodeRng = editor.dom.createRng();\n          fakeNodeRng.setStartBefore(node);\n          fakeNodeRng.setEndAfter(node);\n          executor(fakeNodeRng, true);\n        });\n      } else {\n        executor(editor.selection.getRng(), false);\n      }\n    };\n    const preserve = (selection, fillBookmark, executor) => {\n      const bookmark = getPersistentBookmark(selection, fillBookmark);\n      executor(bookmark);\n      selection.moveToBookmark(bookmark);\n    };\n\n    const NodeValue = (is, name) => {\n      const get = element => {\n        if (!is(element)) {\n          throw new Error('Can only get ' + name + ' value of a ' + name + ' node');\n        }\n        return getOption(element).getOr('');\n      };\n      const getOption = element => is(element) ? Optional.from(element.dom.nodeValue) : Optional.none();\n      const set = (element, value) => {\n        if (!is(element)) {\n          throw new Error('Can only set raw ' + name + ' value of a ' + name + ' node');\n        }\n        element.dom.nodeValue = value;\n      };\n      return {\n        get,\n        getOption,\n        set\n      };\n    };\n\n    const api$1 = NodeValue(isText$9, 'text');\n    const get$3 = element => api$1.get(element);\n    const getOption = element => api$1.getOption(element);\n\n    const isZeroWidth = elem => isText$9(elem) && get$3(elem) === ZWSP$1;\n    const context = (editor, elem, wrapName, nodeName) => parent(elem).fold(() => 'skipping', parent => {\n      if (nodeName === 'br' || isZeroWidth(elem)) {\n        return 'valid';\n      } else if (isAnnotation(elem)) {\n        return 'existing';\n      } else if (isCaretNode(elem.dom)) {\n        return 'caret';\n      } else if (!isValid(editor, wrapName, nodeName) || !isValid(editor, name(parent), wrapName)) {\n        return 'invalid-child';\n      } else {\n        return 'valid';\n      }\n    });\n\n    const applyWordGrab = (editor, rng) => {\n      const r = expandRng(editor, rng, [{ inline: 'span' }]);\n      rng.setStart(r.startContainer, r.startOffset);\n      rng.setEnd(r.endContainer, r.endOffset);\n      editor.selection.setRng(rng);\n    };\n    const makeAnnotation = (eDoc, {uid = generate$1('mce-annotation'), ...data}, annotationName, decorate) => {\n      const master = SugarElement.fromTag('span', eDoc);\n      add$2(master, annotation());\n      set$2(master, `${ dataAnnotationId() }`, uid);\n      set$2(master, `${ dataAnnotation() }`, annotationName);\n      const {attributes = {}, classes = []} = decorate(uid, data);\n      setAll$1(master, attributes);\n      add(master, classes);\n      return master;\n    };\n    const annotate = (editor, rng, annotationName, decorate, data) => {\n      const newWrappers = [];\n      const master = makeAnnotation(editor.getDoc(), data, annotationName, decorate);\n      const wrapper = value$2();\n      const finishWrapper = () => {\n        wrapper.clear();\n      };\n      const getOrOpenWrapper = () => wrapper.get().getOrThunk(() => {\n        const nu = shallow$1(master);\n        newWrappers.push(nu);\n        wrapper.set(nu);\n        return nu;\n      });\n      const processElements = elems => {\n        each$g(elems, processElement);\n      };\n      const processElement = elem => {\n        const ctx = context(editor, elem, 'span', name(elem));\n        switch (ctx) {\n        case 'invalid-child': {\n            finishWrapper();\n            const children$1 = children(elem);\n            processElements(children$1);\n            finishWrapper();\n            break;\n          }\n        case 'valid': {\n            const w = getOrOpenWrapper();\n            wrap$2(elem, w);\n            break;\n          }\n        }\n      };\n      const processNodes = nodes => {\n        const elems = map$3(nodes, SugarElement.fromDom);\n        processElements(elems);\n      };\n      walk$3(editor.dom, rng, nodes => {\n        finishWrapper();\n        processNodes(nodes);\n      });\n      return newWrappers;\n    };\n    const annotateWithBookmark = (editor, name, settings, data) => {\n      editor.undoManager.transact(() => {\n        const selection = editor.selection;\n        const initialRng = selection.getRng();\n        const hasFakeSelection = getCellsFromEditor(editor).length > 0;\n        if (initialRng.collapsed && !hasFakeSelection) {\n          applyWordGrab(editor, initialRng);\n        }\n        if (selection.getRng().collapsed && !hasFakeSelection) {\n          const wrapper = makeAnnotation(editor.getDoc(), data, name, settings.decorate);\n          set(wrapper, nbsp);\n          selection.getRng().insertNode(wrapper.dom);\n          selection.select(wrapper.dom);\n        } else {\n          preserve(selection, false, () => {\n            runOnRanges(editor, selectionRng => {\n              annotate(editor, selectionRng, name, settings.decorate, data);\n            });\n          });\n        }\n      });\n    };\n\n    const Annotator = editor => {\n      const registry = create$b();\n      setup$w(editor, registry);\n      const changes = setup$x(editor, registry);\n      return {\n        register: (name, settings) => {\n          registry.register(name, settings);\n        },\n        annotate: (name, data) => {\n          registry.lookup(name).each(settings => {\n            annotateWithBookmark(editor, name, settings, data);\n          });\n        },\n        annotationChanged: (name, callback) => {\n          changes.addListener(name, callback);\n        },\n        remove: name => {\n          const bookmark = editor.selection.getBookmark();\n          identify(editor, Optional.some(name)).each(({elements}) => {\n            each$g(elements, unwrap);\n          });\n          editor.selection.moveToBookmark(bookmark);\n        },\n        removeAll: name => {\n          const bookmark = editor.selection.getBookmark();\n          each$f(findAll(editor, name), (spans, _) => each$g(spans, unwrap));\n          editor.selection.moveToBookmark(bookmark);\n        },\n        getAll: name => {\n          const directory = findAll(editor, name);\n          return map$2(directory, elems => map$3(elems, elem => elem.dom));\n        }\n      };\n    };\n\n    const BookmarkManager = selection => {\n      return {\n        getBookmark: curry(getBookmark$1, selection),\n        moveToBookmark: curry(moveToBookmark, selection)\n      };\n    };\n    BookmarkManager.isBookmarkNode = isBookmarkNode$1;\n\n    const isXYWithinRange = (clientX, clientY, range) => {\n      if (range.collapsed) {\n        return false;\n      } else {\n        return exists(range.getClientRects(), rect => containsXY(rect, clientX, clientY));\n      }\n    };\n\n    const firePreProcess = (editor, args) => editor.dispatch('PreProcess', args);\n    const firePostProcess = (editor, args) => editor.dispatch('PostProcess', args);\n    const fireRemove = editor => editor.dispatch('remove');\n    const fireDetach = editor => editor.dispatch('detach');\n    const fireSwitchMode = (editor, mode) => editor.dispatch('SwitchMode', { mode });\n    const fireObjectResizeStart = (editor, target, width, height, origin) => {\n      editor.dispatch('ObjectResizeStart', {\n        target,\n        width,\n        height,\n        origin\n      });\n    };\n    const fireObjectResized = (editor, target, width, height, origin) => {\n      editor.dispatch('ObjectResized', {\n        target,\n        width,\n        height,\n        origin\n      });\n    };\n    const firePreInit = editor => editor.dispatch('PreInit');\n    const firePostRender = editor => editor.dispatch('PostRender');\n    const fireInit = editor => editor.dispatch('Init');\n    const firePlaceholderToggle = (editor, state) => editor.dispatch('PlaceholderToggle', { state });\n    const fireError = (editor, errorType, error) => editor.dispatch(errorType, error);\n    const fireFormatApply = (editor, format, node, vars) => editor.dispatch('FormatApply', {\n      format,\n      node,\n      vars\n    });\n    const fireFormatRemove = (editor, format, node, vars) => editor.dispatch('FormatRemove', {\n      format,\n      node,\n      vars\n    });\n    const fireBeforeSetContent = (editor, args) => editor.dispatch('BeforeSetContent', args);\n    const fireSetContent = (editor, args) => editor.dispatch('SetContent', args);\n    const fireBeforeGetContent = (editor, args) => editor.dispatch('BeforeGetContent', args);\n    const fireGetContent = (editor, args) => editor.dispatch('GetContent', args);\n    const fireAutocompleterStart = (editor, args) => editor.dispatch('AutocompleterStart', args);\n    const fireAutocompleterUpdate = (editor, args) => editor.dispatch('AutocompleterUpdate', args);\n    const fireAutocompleterEnd = editor => editor.dispatch('AutocompleterEnd');\n    const firePastePreProcess = (editor, html, internal) => editor.dispatch('PastePreProcess', {\n      content: html,\n      internal\n    });\n    const firePastePostProcess = (editor, node, internal) => editor.dispatch('PastePostProcess', {\n      node,\n      internal\n    });\n    const firePastePlainTextToggle = (editor, state) => editor.dispatch('PastePlainTextToggle', { state });\n\n    const VK = {\n      BACKSPACE: 8,\n      DELETE: 46,\n      DOWN: 40,\n      ENTER: 13,\n      ESC: 27,\n      LEFT: 37,\n      RIGHT: 39,\n      SPACEBAR: 32,\n      TAB: 9,\n      UP: 38,\n      PAGE_UP: 33,\n      PAGE_DOWN: 34,\n      END: 35,\n      HOME: 36,\n      modifierPressed: e => {\n        return e.shiftKey || e.ctrlKey || e.altKey || VK.metaKeyPressed(e);\n      },\n      metaKeyPressed: e => {\n        return Env.os.isMacOS() || Env.os.isiOS() ? e.metaKey : e.ctrlKey && !e.altKey;\n      }\n    };\n\n    const ControlSelection = (selection, editor) => {\n      const elementSelectionAttr = 'data-mce-selected';\n      const dom = editor.dom, each = Tools.each;\n      let selectedElm, selectedElmGhost, resizeHelper, selectedHandle, resizeBackdrop;\n      let startX, startY, selectedElmX, selectedElmY, startW, startH, ratio, resizeStarted;\n      let width, height;\n      const editableDoc = editor.getDoc(), rootDocument = document;\n      const abs = Math.abs, round = Math.round, rootElement = editor.getBody();\n      let startScrollWidth, startScrollHeight;\n      const resizeHandles = {\n        nw: [\n          0,\n          0,\n          -1,\n          -1\n        ],\n        ne: [\n          1,\n          0,\n          1,\n          -1\n        ],\n        se: [\n          1,\n          1,\n          1,\n          1\n        ],\n        sw: [\n          0,\n          1,\n          -1,\n          1\n        ]\n      };\n      const isImage = elm => isNonNullable(elm) && (isImg(elm) || editor.dom.is(elm, 'figure.image'));\n      const isMedia = elm => isMedia$2(elm) || dom.hasClass(elm, 'mce-preview-object');\n      const isEventOnImageOutsideRange = (evt, range) => {\n        if (evt.type === 'longpress' || evt.type.indexOf('touch') === 0) {\n          const touch = evt.touches[0];\n          return isImage(evt.target) && !isXYWithinRange(touch.clientX, touch.clientY, range);\n        } else {\n          return isImage(evt.target) && !isXYWithinRange(evt.clientX, evt.clientY, range);\n        }\n      };\n      const contextMenuSelectImage = evt => {\n        const target = evt.target;\n        if (isEventOnImageOutsideRange(evt, editor.selection.getRng()) && !evt.isDefaultPrevented()) {\n          editor.selection.select(target);\n        }\n      };\n      const getResizeTargets = elm => {\n        if (dom.is(elm, 'figure.image')) {\n          return [elm.querySelector('img')];\n        } else if (dom.hasClass(elm, 'mce-preview-object') && isNonNullable(elm.firstElementChild)) {\n          return [\n            elm,\n            elm.firstElementChild\n          ];\n        } else {\n          return [elm];\n        }\n      };\n      const isResizable = elm => {\n        const selector = getObjectResizing(editor);\n        if (!selector) {\n          return false;\n        }\n        if (elm.getAttribute('data-mce-resize') === 'false') {\n          return false;\n        }\n        if (elm === editor.getBody()) {\n          return false;\n        }\n        if (dom.hasClass(elm, 'mce-preview-object')) {\n          return is$1(SugarElement.fromDom(elm.firstElementChild), selector);\n        } else {\n          return is$1(SugarElement.fromDom(elm), selector);\n        }\n      };\n      const createGhostElement = elm => {\n        if (isMedia(elm)) {\n          return dom.create('img', { src: Env.transparentSrc });\n        } else {\n          return elm.cloneNode(true);\n        }\n      };\n      const setSizeProp = (element, name, value) => {\n        if (isNonNullable(value)) {\n          const targets = getResizeTargets(element);\n          each$g(targets, target => {\n            if (target.style[name] || !editor.schema.isValid(target.nodeName.toLowerCase(), name)) {\n              dom.setStyle(target, name, value);\n            } else {\n              dom.setAttrib(target, name, '' + value);\n            }\n          });\n        }\n      };\n      const setGhostElmSize = (ghostElm, width, height) => {\n        setSizeProp(ghostElm, 'width', width);\n        setSizeProp(ghostElm, 'height', height);\n      };\n      const resizeGhostElement = e => {\n        let deltaX, deltaY, proportional;\n        let resizeHelperX, resizeHelperY;\n        deltaX = e.screenX - startX;\n        deltaY = e.screenY - startY;\n        width = deltaX * selectedHandle[2] + startW;\n        height = deltaY * selectedHandle[3] + startH;\n        width = width < 5 ? 5 : width;\n        height = height < 5 ? 5 : height;\n        if ((isImage(selectedElm) || isMedia(selectedElm)) && getResizeImgProportional(editor) !== false) {\n          proportional = !VK.modifierPressed(e);\n        } else {\n          proportional = VK.modifierPressed(e);\n        }\n        if (proportional) {\n          if (abs(deltaX) > abs(deltaY)) {\n            height = round(width * ratio);\n            width = round(height / ratio);\n          } else {\n            width = round(height / ratio);\n            height = round(width * ratio);\n          }\n        }\n        setGhostElmSize(selectedElmGhost, width, height);\n        resizeHelperX = selectedHandle.startPos.x + deltaX;\n        resizeHelperY = selectedHandle.startPos.y + deltaY;\n        resizeHelperX = resizeHelperX > 0 ? resizeHelperX : 0;\n        resizeHelperY = resizeHelperY > 0 ? resizeHelperY : 0;\n        dom.setStyles(resizeHelper, {\n          left: resizeHelperX,\n          top: resizeHelperY,\n          display: 'block'\n        });\n        resizeHelper.innerHTML = width + ' &times; ' + height;\n        if (selectedHandle[2] < 0 && selectedElmGhost.clientWidth <= width) {\n          dom.setStyle(selectedElmGhost, 'left', selectedElmX + (startW - width));\n        }\n        if (selectedHandle[3] < 0 && selectedElmGhost.clientHeight <= height) {\n          dom.setStyle(selectedElmGhost, 'top', selectedElmY + (startH - height));\n        }\n        deltaX = rootElement.scrollWidth - startScrollWidth;\n        deltaY = rootElement.scrollHeight - startScrollHeight;\n        if (deltaX + deltaY !== 0) {\n          dom.setStyles(resizeHelper, {\n            left: resizeHelperX - deltaX,\n            top: resizeHelperY - deltaY\n          });\n        }\n        if (!resizeStarted) {\n          fireObjectResizeStart(editor, selectedElm, startW, startH, 'corner-' + selectedHandle.name);\n          resizeStarted = true;\n        }\n      };\n      const endGhostResize = () => {\n        const wasResizeStarted = resizeStarted;\n        resizeStarted = false;\n        if (wasResizeStarted) {\n          setSizeProp(selectedElm, 'width', width);\n          setSizeProp(selectedElm, 'height', height);\n        }\n        dom.unbind(editableDoc, 'mousemove', resizeGhostElement);\n        dom.unbind(editableDoc, 'mouseup', endGhostResize);\n        if (rootDocument !== editableDoc) {\n          dom.unbind(rootDocument, 'mousemove', resizeGhostElement);\n          dom.unbind(rootDocument, 'mouseup', endGhostResize);\n        }\n        dom.remove(selectedElmGhost);\n        dom.remove(resizeHelper);\n        dom.remove(resizeBackdrop);\n        showResizeRect(selectedElm);\n        if (wasResizeStarted) {\n          fireObjectResized(editor, selectedElm, width, height, 'corner-' + selectedHandle.name);\n          dom.setAttrib(selectedElm, 'style', dom.getAttrib(selectedElm, 'style'));\n        }\n        editor.nodeChanged();\n      };\n      const showResizeRect = targetElm => {\n        unbindResizeHandleEvents();\n        const position = dom.getPos(targetElm, rootElement);\n        const selectedElmX = position.x;\n        const selectedElmY = position.y;\n        const rect = targetElm.getBoundingClientRect();\n        const targetWidth = rect.width || rect.right - rect.left;\n        const targetHeight = rect.height || rect.bottom - rect.top;\n        if (selectedElm !== targetElm) {\n          hideResizeRect();\n          selectedElm = targetElm;\n          width = height = 0;\n        }\n        const e = editor.dispatch('ObjectSelected', { target: targetElm });\n        const selectedValue = dom.getAttrib(selectedElm, elementSelectionAttr, '1');\n        if (isResizable(targetElm) && !e.isDefaultPrevented()) {\n          each(resizeHandles, (handle, name) => {\n            let handleElm;\n            const startDrag = e => {\n              const target = getResizeTargets(selectedElm)[0];\n              startX = e.screenX;\n              startY = e.screenY;\n              startW = target.clientWidth;\n              startH = target.clientHeight;\n              ratio = startH / startW;\n              selectedHandle = handle;\n              selectedHandle.name = name;\n              selectedHandle.startPos = {\n                x: targetWidth * handle[0] + selectedElmX,\n                y: targetHeight * handle[1] + selectedElmY\n              };\n              startScrollWidth = rootElement.scrollWidth;\n              startScrollHeight = rootElement.scrollHeight;\n              resizeBackdrop = dom.add(rootElement, 'div', {\n                'class': 'mce-resize-backdrop',\n                'data-mce-bogus': 'all'\n              });\n              dom.setStyles(resizeBackdrop, {\n                position: 'fixed',\n                left: '0',\n                top: '0',\n                width: '100%',\n                height: '100%'\n              });\n              selectedElmGhost = createGhostElement(selectedElm);\n              dom.addClass(selectedElmGhost, 'mce-clonedresizable');\n              dom.setAttrib(selectedElmGhost, 'data-mce-bogus', 'all');\n              selectedElmGhost.contentEditable = 'false';\n              dom.setStyles(selectedElmGhost, {\n                left: selectedElmX,\n                top: selectedElmY,\n                margin: 0\n              });\n              setGhostElmSize(selectedElmGhost, targetWidth, targetHeight);\n              selectedElmGhost.removeAttribute(elementSelectionAttr);\n              rootElement.appendChild(selectedElmGhost);\n              dom.bind(editableDoc, 'mousemove', resizeGhostElement);\n              dom.bind(editableDoc, 'mouseup', endGhostResize);\n              if (rootDocument !== editableDoc) {\n                dom.bind(rootDocument, 'mousemove', resizeGhostElement);\n                dom.bind(rootDocument, 'mouseup', endGhostResize);\n              }\n              resizeHelper = dom.add(rootElement, 'div', {\n                'class': 'mce-resize-helper',\n                'data-mce-bogus': 'all'\n              }, startW + ' &times; ' + startH);\n            };\n            handleElm = dom.get('mceResizeHandle' + name);\n            if (handleElm) {\n              dom.remove(handleElm);\n            }\n            handleElm = dom.add(rootElement, 'div', {\n              'id': 'mceResizeHandle' + name,\n              'data-mce-bogus': 'all',\n              'class': 'mce-resizehandle',\n              'unselectable': true,\n              'style': 'cursor:' + name + '-resize; margin:0; padding:0'\n            });\n            dom.bind(handleElm, 'mousedown', e => {\n              e.stopImmediatePropagation();\n              e.preventDefault();\n              startDrag(e);\n            });\n            handle.elm = handleElm;\n            dom.setStyles(handleElm, {\n              left: targetWidth * handle[0] + selectedElmX - handleElm.offsetWidth / 2,\n              top: targetHeight * handle[1] + selectedElmY - handleElm.offsetHeight / 2\n            });\n          });\n        } else {\n          hideResizeRect();\n        }\n        if (!dom.getAttrib(selectedElm, elementSelectionAttr)) {\n          selectedElm.setAttribute(elementSelectionAttr, selectedValue);\n        }\n      };\n      const hideResizeRect = () => {\n        unbindResizeHandleEvents();\n        if (selectedElm) {\n          selectedElm.removeAttribute(elementSelectionAttr);\n        }\n        each$f(resizeHandles, (value, name) => {\n          const handleElm = dom.get('mceResizeHandle' + name);\n          if (handleElm) {\n            dom.unbind(handleElm);\n            dom.remove(handleElm);\n          }\n        });\n      };\n      const updateResizeRect = e => {\n        var _a;\n        let startElm, controlElm;\n        const isChildOrEqual = (node, parent) => {\n          if (node) {\n            do {\n              if (node === parent) {\n                return true;\n              }\n            } while (node = node.parentNode);\n          }\n        };\n        if (resizeStarted || editor.removed) {\n          return;\n        }\n        each(dom.select('img[data-mce-selected],hr[data-mce-selected]'), img => {\n          img.removeAttribute(elementSelectionAttr);\n        });\n        controlElm = e.type === 'mousedown' ? e.target : selection.getNode();\n        controlElm = (_a = closest$3(SugarElement.fromDom(controlElm), 'table,img,figure.image,hr,video,span.mce-preview-object').getOrUndefined()) === null || _a === void 0 ? void 0 : _a.dom;\n        if (isChildOrEqual(controlElm, rootElement)) {\n          disableGeckoResize();\n          startElm = selection.getStart(true);\n          if (isChildOrEqual(startElm, controlElm) && isChildOrEqual(selection.getEnd(true), controlElm)) {\n            showResizeRect(controlElm);\n            return;\n          }\n        }\n        hideResizeRect();\n      };\n      const unbindResizeHandleEvents = () => {\n        each$f(resizeHandles, handle => {\n          if (handle.elm) {\n            dom.unbind(handle.elm);\n            delete handle.elm;\n          }\n        });\n      };\n      const disableGeckoResize = () => {\n        try {\n          editor.getDoc().execCommand('enableObjectResizing', false, 'false');\n        } catch (ex) {\n        }\n      };\n      editor.on('init', () => {\n        disableGeckoResize();\n        const throttledUpdateResizeRect = first$1(e => {\n          if (!editor.composing) {\n            updateResizeRect(e);\n          }\n        }, 0);\n        editor.on('nodechange ResizeEditor ResizeWindow ResizeContent drop FullscreenStateChanged', throttledUpdateResizeRect.throttle);\n        editor.on('keyup compositionend', e => {\n          if (selectedElm && selectedElm.nodeName === 'TABLE') {\n            throttledUpdateResizeRect.throttle(e);\n          }\n        });\n        editor.on('hide blur', hideResizeRect);\n        editor.on('contextmenu longpress', contextMenuSelectImage, true);\n      });\n      editor.on('remove', unbindResizeHandleEvents);\n      const destroy = () => {\n        selectedElm = selectedElmGhost = resizeBackdrop = null;\n      };\n      return {\n        isResizable,\n        showResizeRect,\n        hideResizeRect,\n        updateResizeRect,\n        destroy\n      };\n    };\n\n    const setStart = (rng, situ) => {\n      situ.fold(e => {\n        rng.setStartBefore(e.dom);\n      }, (e, o) => {\n        rng.setStart(e.dom, o);\n      }, e => {\n        rng.setStartAfter(e.dom);\n      });\n    };\n    const setFinish = (rng, situ) => {\n      situ.fold(e => {\n        rng.setEndBefore(e.dom);\n      }, (e, o) => {\n        rng.setEnd(e.dom, o);\n      }, e => {\n        rng.setEndAfter(e.dom);\n      });\n    };\n    const relativeToNative = (win, startSitu, finishSitu) => {\n      const range = win.document.createRange();\n      setStart(range, startSitu);\n      setFinish(range, finishSitu);\n      return range;\n    };\n    const exactToNative = (win, start, soffset, finish, foffset) => {\n      const rng = win.document.createRange();\n      rng.setStart(start.dom, soffset);\n      rng.setEnd(finish.dom, foffset);\n      return rng;\n    };\n\n    const adt$3 = Adt.generate([\n      {\n        ltr: [\n          'start',\n          'soffset',\n          'finish',\n          'foffset'\n        ]\n      },\n      {\n        rtl: [\n          'start',\n          'soffset',\n          'finish',\n          'foffset'\n        ]\n      }\n    ]);\n    const fromRange = (win, type, range) => type(SugarElement.fromDom(range.startContainer), range.startOffset, SugarElement.fromDom(range.endContainer), range.endOffset);\n    const getRanges = (win, selection) => selection.match({\n      domRange: rng => {\n        return {\n          ltr: constant(rng),\n          rtl: Optional.none\n        };\n      },\n      relative: (startSitu, finishSitu) => {\n        return {\n          ltr: cached(() => relativeToNative(win, startSitu, finishSitu)),\n          rtl: cached(() => Optional.some(relativeToNative(win, finishSitu, startSitu)))\n        };\n      },\n      exact: (start, soffset, finish, foffset) => {\n        return {\n          ltr: cached(() => exactToNative(win, start, soffset, finish, foffset)),\n          rtl: cached(() => Optional.some(exactToNative(win, finish, foffset, start, soffset)))\n        };\n      }\n    });\n    const doDiagnose = (win, ranges) => {\n      const rng = ranges.ltr();\n      if (rng.collapsed) {\n        const reversed = ranges.rtl().filter(rev => rev.collapsed === false);\n        return reversed.map(rev => adt$3.rtl(SugarElement.fromDom(rev.endContainer), rev.endOffset, SugarElement.fromDom(rev.startContainer), rev.startOffset)).getOrThunk(() => fromRange(win, adt$3.ltr, rng));\n      } else {\n        return fromRange(win, adt$3.ltr, rng);\n      }\n    };\n    const diagnose = (win, selection) => {\n      const ranges = getRanges(win, selection);\n      return doDiagnose(win, ranges);\n    };\n    adt$3.ltr;\n    adt$3.rtl;\n\n    const create$9 = (start, soffset, finish, foffset) => ({\n      start,\n      soffset,\n      finish,\n      foffset\n    });\n    const SimRange = { create: create$9 };\n\n    const caretPositionFromPoint = (doc, x, y) => {\n      var _a, _b;\n      return Optional.from((_b = (_a = doc.dom).caretPositionFromPoint) === null || _b === void 0 ? void 0 : _b.call(_a, x, y)).bind(pos => {\n        if (pos.offsetNode === null) {\n          return Optional.none();\n        }\n        const r = doc.dom.createRange();\n        r.setStart(pos.offsetNode, pos.offset);\n        r.collapse();\n        return Optional.some(r);\n      });\n    };\n    const caretRangeFromPoint = (doc, x, y) => {\n      var _a, _b;\n      return Optional.from((_b = (_a = doc.dom).caretRangeFromPoint) === null || _b === void 0 ? void 0 : _b.call(_a, x, y));\n    };\n    const availableSearch = (() => {\n      if (document.caretPositionFromPoint) {\n        return caretPositionFromPoint;\n      } else if (document.caretRangeFromPoint) {\n        return caretRangeFromPoint;\n      } else {\n        return Optional.none;\n      }\n    })();\n    const fromPoint$1 = (win, x, y) => {\n      const doc = SugarElement.fromDom(win.document);\n      return availableSearch(doc, x, y).map(rng => SimRange.create(SugarElement.fromDom(rng.startContainer), rng.startOffset, SugarElement.fromDom(rng.endContainer), rng.endOffset));\n    };\n\n    const adt$2 = Adt.generate([\n      { before: ['element'] },\n      {\n        on: [\n          'element',\n          'offset'\n        ]\n      },\n      { after: ['element'] }\n    ]);\n    const cata = (subject, onBefore, onOn, onAfter) => subject.fold(onBefore, onOn, onAfter);\n    const getStart$2 = situ => situ.fold(identity, identity, identity);\n    const before$1 = adt$2.before;\n    const on = adt$2.on;\n    const after$1 = adt$2.after;\n    const Situ = {\n      before: before$1,\n      on,\n      after: after$1,\n      cata,\n      getStart: getStart$2\n    };\n\n    const adt$1 = Adt.generate([\n      { domRange: ['rng'] },\n      {\n        relative: [\n          'startSitu',\n          'finishSitu'\n        ]\n      },\n      {\n        exact: [\n          'start',\n          'soffset',\n          'finish',\n          'foffset'\n        ]\n      }\n    ]);\n    const exactFromRange = simRange => adt$1.exact(simRange.start, simRange.soffset, simRange.finish, simRange.foffset);\n    const getStart$1 = selection => selection.match({\n      domRange: rng => SugarElement.fromDom(rng.startContainer),\n      relative: (startSitu, _finishSitu) => Situ.getStart(startSitu),\n      exact: (start, _soffset, _finish, _foffset) => start\n    });\n    const domRange = adt$1.domRange;\n    const relative = adt$1.relative;\n    const exact = adt$1.exact;\n    const getWin = selection => {\n      const start = getStart$1(selection);\n      return defaultView(start);\n    };\n    const range = SimRange.create;\n    const SimSelection = {\n      domRange,\n      relative,\n      exact,\n      exactFromRange,\n      getWin,\n      range\n    };\n\n    const beforeSpecial = (element, offset) => {\n      const name$1 = name(element);\n      if ('input' === name$1) {\n        return Situ.after(element);\n      } else if (!contains$2([\n          'br',\n          'img'\n        ], name$1)) {\n        return Situ.on(element, offset);\n      } else {\n        return offset === 0 ? Situ.before(element) : Situ.after(element);\n      }\n    };\n    const preprocessRelative = (startSitu, finishSitu) => {\n      const start = startSitu.fold(Situ.before, beforeSpecial, Situ.after);\n      const finish = finishSitu.fold(Situ.before, beforeSpecial, Situ.after);\n      return SimSelection.relative(start, finish);\n    };\n    const preprocessExact = (start, soffset, finish, foffset) => {\n      const startSitu = beforeSpecial(start, soffset);\n      const finishSitu = beforeSpecial(finish, foffset);\n      return SimSelection.relative(startSitu, finishSitu);\n    };\n    const preprocess = selection => selection.match({\n      domRange: rng => {\n        const start = SugarElement.fromDom(rng.startContainer);\n        const finish = SugarElement.fromDom(rng.endContainer);\n        return preprocessExact(start, rng.startOffset, finish, rng.endOffset);\n      },\n      relative: preprocessRelative,\n      exact: preprocessExact\n    });\n\n    const fromElements = (elements, scope) => {\n      const doc = scope || document;\n      const fragment = doc.createDocumentFragment();\n      each$g(elements, element => {\n        fragment.appendChild(element.dom);\n      });\n      return SugarElement.fromDom(fragment);\n    };\n\n    const toNative = selection => {\n      const win = SimSelection.getWin(selection).dom;\n      const getDomRange = (start, soffset, finish, foffset) => exactToNative(win, start, soffset, finish, foffset);\n      const filtered = preprocess(selection);\n      return diagnose(win, filtered).match({\n        ltr: getDomRange,\n        rtl: getDomRange\n      });\n    };\n    const getAtPoint = (win, x, y) => fromPoint$1(win, x, y);\n\n    const fromPoint = (clientX, clientY, doc) => getAtPoint(doc.defaultView, clientX, clientY).map(simRange => {\n      const rng = doc.createRange();\n      rng.setStart(simRange.start.dom, simRange.soffset);\n      rng.setEnd(simRange.finish.dom, simRange.foffset);\n      return rng;\n    }).getOrUndefined();\n\n    const isEq$4 = (rng1, rng2) => {\n      return rng1 && rng2 && (rng1.startContainer === rng2.startContainer && rng1.startOffset === rng2.startOffset) && (rng1.endContainer === rng2.endContainer && rng1.endOffset === rng2.endOffset);\n    };\n\n    const findParent = (node, rootNode, predicate) => {\n      while (node && node !== rootNode) {\n        if (predicate(node)) {\n          return node;\n        }\n        node = node.parentNode;\n      }\n      return null;\n    };\n    const hasParent$1 = (node, rootNode, predicate) => findParent(node, rootNode, predicate) !== null;\n    const hasParentWithName = (node, rootNode, name) => hasParent$1(node, rootNode, node => {\n      return node.nodeName === name;\n    });\n    const isTable = node => node && node.nodeName === 'TABLE';\n    const isTableCell$2 = node => node && /^(TD|TH|CAPTION)$/.test(node.nodeName);\n    const isCeFalseCaretContainer = (node, rootNode) => isCaretContainer$2(node) && hasParent$1(node, rootNode, isCaretNode) === false;\n    const hasBrBeforeAfter = (dom, node, left) => {\n      const walker = new DomTreeWalker(node, dom.getParent(node.parentNode, dom.isBlock) || dom.getRoot());\n      while (node = walker[left ? 'prev' : 'next']()) {\n        if (isBr$5(node)) {\n          return true;\n        }\n      }\n    };\n    const isPrevNode = (node, name) => node.previousSibling && node.previousSibling.nodeName === name;\n    const hasContentEditableFalseParent = (body, node) => {\n      while (node && node !== body) {\n        if (isContentEditableFalse$a(node)) {\n          return true;\n        }\n        node = node.parentNode;\n      }\n      return false;\n    };\n    const findTextNodeRelative = (dom, isAfterNode, collapsed, left, startNode) => {\n      let lastInlineElement;\n      const body = dom.getRoot();\n      let node;\n      const nonEmptyElementsMap = dom.schema.getNonEmptyElements();\n      const parentBlockContainer = dom.getParent(startNode.parentNode, dom.isBlock) || body;\n      if (left && isBr$5(startNode) && isAfterNode && dom.isEmpty(parentBlockContainer)) {\n        return Optional.some(CaretPosition(startNode.parentNode, dom.nodeIndex(startNode)));\n      }\n      const walker = new DomTreeWalker(startNode, parentBlockContainer);\n      while (node = walker[left ? 'prev' : 'next']()) {\n        if (dom.getContentEditableParent(node) === 'false' || isCeFalseCaretContainer(node, body)) {\n          return Optional.none();\n        }\n        if (isText$8(node) && node.nodeValue.length > 0) {\n          if (hasParentWithName(node, body, 'A') === false) {\n            return Optional.some(CaretPosition(node, left ? node.nodeValue.length : 0));\n          }\n          return Optional.none();\n        }\n        if (dom.isBlock(node) || nonEmptyElementsMap[node.nodeName.toLowerCase()]) {\n          return Optional.none();\n        }\n        lastInlineElement = node;\n      }\n      if (collapsed && lastInlineElement) {\n        return Optional.some(CaretPosition(lastInlineElement, 0));\n      }\n      return Optional.none();\n    };\n    const normalizeEndPoint = (dom, collapsed, start, rng) => {\n      let container, offset;\n      const body = dom.getRoot();\n      let node;\n      let directionLeft, normalized = false;\n      container = rng[(start ? 'start' : 'end') + 'Container'];\n      offset = rng[(start ? 'start' : 'end') + 'Offset'];\n      const isAfterNode = isElement$6(container) && offset === container.childNodes.length;\n      const nonEmptyElementsMap = dom.schema.getNonEmptyElements();\n      directionLeft = start;\n      if (isCaretContainer$2(container)) {\n        return Optional.none();\n      }\n      if (isElement$6(container) && offset > container.childNodes.length - 1) {\n        directionLeft = false;\n      }\n      if (isDocument$1(container)) {\n        container = body;\n        offset = 0;\n      }\n      if (container === body) {\n        if (directionLeft) {\n          node = container.childNodes[offset > 0 ? offset - 1 : 0];\n          if (node) {\n            if (isCaretContainer$2(node)) {\n              return Optional.none();\n            }\n            if (nonEmptyElementsMap[node.nodeName] || isTable(node)) {\n              return Optional.none();\n            }\n          }\n        }\n        if (container.hasChildNodes()) {\n          offset = Math.min(!directionLeft && offset > 0 ? offset - 1 : offset, container.childNodes.length - 1);\n          container = container.childNodes[offset];\n          offset = isText$8(container) && isAfterNode ? container.data.length : 0;\n          if (!collapsed && container === body.lastChild && isTable(container)) {\n            return Optional.none();\n          }\n          if (hasContentEditableFalseParent(body, container) || isCaretContainer$2(container)) {\n            return Optional.none();\n          }\n          if (container.hasChildNodes() && isTable(container) === false) {\n            node = container;\n            const walker = new DomTreeWalker(container, body);\n            do {\n              if (isContentEditableFalse$a(node) || isCaretContainer$2(node)) {\n                normalized = false;\n                break;\n              }\n              if (isText$8(node) && node.nodeValue.length > 0) {\n                offset = directionLeft ? 0 : node.nodeValue.length;\n                container = node;\n                normalized = true;\n                break;\n              }\n              if (nonEmptyElementsMap[node.nodeName.toLowerCase()] && !isTableCell$2(node)) {\n                offset = dom.nodeIndex(node);\n                container = node.parentNode;\n                if (!directionLeft) {\n                  offset++;\n                }\n                normalized = true;\n                break;\n              }\n            } while (node = directionLeft ? walker.next() : walker.prev());\n          }\n        }\n      }\n      if (collapsed) {\n        if (isText$8(container) && offset === 0) {\n          findTextNodeRelative(dom, isAfterNode, collapsed, true, container).each(pos => {\n            container = pos.container();\n            offset = pos.offset();\n            normalized = true;\n          });\n        }\n        if (isElement$6(container)) {\n          node = container.childNodes[offset];\n          if (!node) {\n            node = container.childNodes[offset - 1];\n          }\n          if (node && isBr$5(node) && !isPrevNode(node, 'A') && !hasBrBeforeAfter(dom, node, false) && !hasBrBeforeAfter(dom, node, true)) {\n            findTextNodeRelative(dom, isAfterNode, collapsed, true, node).each(pos => {\n              container = pos.container();\n              offset = pos.offset();\n              normalized = true;\n            });\n          }\n        }\n      }\n      if (directionLeft && !collapsed && isText$8(container) && offset === container.nodeValue.length) {\n        findTextNodeRelative(dom, isAfterNode, collapsed, false, container).each(pos => {\n          container = pos.container();\n          offset = pos.offset();\n          normalized = true;\n        });\n      }\n      return normalized ? Optional.some(CaretPosition(container, offset)) : Optional.none();\n    };\n    const normalize$2 = (dom, rng) => {\n      const collapsed = rng.collapsed, normRng = rng.cloneRange();\n      const startPos = CaretPosition.fromRangeStart(rng);\n      normalizeEndPoint(dom, collapsed, true, normRng).each(pos => {\n        if (!collapsed || !CaretPosition.isAbove(startPos, pos)) {\n          normRng.setStart(pos.container(), pos.offset());\n        }\n      });\n      if (!collapsed) {\n        normalizeEndPoint(dom, collapsed, false, normRng).each(pos => {\n          normRng.setEnd(pos.container(), pos.offset());\n        });\n      }\n      if (collapsed) {\n        normRng.collapse(true);\n      }\n      return isEq$4(rng, normRng) ? Optional.none() : Optional.some(normRng);\n    };\n\n    const splitText = (node, offset) => {\n      return node.splitText(offset);\n    };\n    const split = rng => {\n      let startContainer = rng.startContainer, startOffset = rng.startOffset, endContainer = rng.endContainer, endOffset = rng.endOffset;\n      if (startContainer === endContainer && isText$8(startContainer)) {\n        if (startOffset > 0 && startOffset < startContainer.nodeValue.length) {\n          endContainer = splitText(startContainer, startOffset);\n          startContainer = endContainer.previousSibling;\n          if (endOffset > startOffset) {\n            endOffset = endOffset - startOffset;\n            startContainer = endContainer = splitText(endContainer, endOffset).previousSibling;\n            endOffset = endContainer.nodeValue.length;\n            startOffset = 0;\n          } else {\n            endOffset = 0;\n          }\n        }\n      } else {\n        if (isText$8(startContainer) && startOffset > 0 && startOffset < startContainer.nodeValue.length) {\n          startContainer = splitText(startContainer, startOffset);\n          startOffset = 0;\n        }\n        if (isText$8(endContainer) && endOffset > 0 && endOffset < endContainer.nodeValue.length) {\n          endContainer = splitText(endContainer, endOffset).previousSibling;\n          endOffset = endContainer.nodeValue.length;\n        }\n      }\n      return {\n        startContainer,\n        startOffset,\n        endContainer,\n        endOffset\n      };\n    };\n\n    const RangeUtils = dom => {\n      const walk = (rng, callback) => {\n        return walk$3(dom, rng, callback);\n      };\n      const split$1 = split;\n      const normalize = rng => {\n        return normalize$2(dom, rng).fold(never, normalizedRng => {\n          rng.setStart(normalizedRng.startContainer, normalizedRng.startOffset);\n          rng.setEnd(normalizedRng.endContainer, normalizedRng.endOffset);\n          return true;\n        });\n      };\n      return {\n        walk,\n        split: split$1,\n        normalize\n      };\n    };\n    RangeUtils.compareRanges = isEq$4;\n    RangeUtils.getCaretRangeFromPoint = fromPoint;\n    RangeUtils.getSelectedNode = getSelectedNode;\n    RangeUtils.getNode = getNode$1;\n\n    const Dimension = (name, getOffset) => {\n      const set = (element, h) => {\n        if (!isNumber(h) && !h.match(/^[0-9]+$/)) {\n          throw new Error(name + '.set accepts only positive integer values. Value was ' + h);\n        }\n        const dom = element.dom;\n        if (isSupported$1(dom)) {\n          dom.style[name] = h + 'px';\n        }\n      };\n      const get = element => {\n        const r = getOffset(element);\n        if (r <= 0 || r === null) {\n          const css = get$7(element, name);\n          return parseFloat(css) || 0;\n        }\n        return r;\n      };\n      const getOuter = get;\n      const aggregate = (element, properties) => foldl(properties, (acc, property) => {\n        const val = get$7(element, property);\n        const value = val === undefined ? 0 : parseInt(val, 10);\n        return isNaN(value) ? acc : acc + value;\n      }, 0);\n      const max = (element, value, properties) => {\n        const cumulativeInclusions = aggregate(element, properties);\n        const absoluteMax = value > cumulativeInclusions ? value - cumulativeInclusions : 0;\n        return absoluteMax;\n      };\n      return {\n        set,\n        get,\n        getOuter,\n        aggregate,\n        max\n      };\n    };\n\n    const api = Dimension('height', element => {\n      const dom = element.dom;\n      return inBody(element) ? dom.getBoundingClientRect().height : dom.offsetHeight;\n    });\n    const get$2 = element => api.get(element);\n\n    const getDocument = () => SugarElement.fromDom(document);\n\n    const walkUp = (navigation, doc) => {\n      const frame = navigation.view(doc);\n      return frame.fold(constant([]), f => {\n        const parent = navigation.owner(f);\n        const rest = walkUp(navigation, parent);\n        return [f].concat(rest);\n      });\n    };\n    const pathTo = (element, navigation) => {\n      const d = navigation.owner(element);\n      return walkUp(navigation, d);\n    };\n\n    const view = doc => {\n      var _a;\n      const element = doc.dom === document ? Optional.none() : Optional.from((_a = doc.dom.defaultView) === null || _a === void 0 ? void 0 : _a.frameElement);\n      return element.map(SugarElement.fromDom);\n    };\n    const owner = element => documentOrOwner(element);\n\n    var Navigation = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        view: view,\n        owner: owner\n    });\n\n    const find = element => {\n      const doc = getDocument();\n      const scroll = get$5(doc);\n      const frames = pathTo(element, Navigation);\n      const offset = viewport(element);\n      const r = foldr(frames, (b, a) => {\n        const loc = viewport(a);\n        return {\n          left: b.left + loc.left,\n          top: b.top + loc.top\n        };\n      }, {\n        left: 0,\n        top: 0\n      });\n      return SugarPosition(r.left + offset.left + scroll.left, r.top + offset.top + scroll.top);\n    };\n\n    const excludeFromDescend = element => name(element) === 'textarea';\n    const fireScrollIntoViewEvent = (editor, data) => {\n      const scrollEvent = editor.dispatch('ScrollIntoView', data);\n      return scrollEvent.isDefaultPrevented();\n    };\n    const fireAfterScrollIntoViewEvent = (editor, data) => {\n      editor.dispatch('AfterScrollIntoView', data);\n    };\n    const descend = (element, offset) => {\n      const children$1 = children(element);\n      if (children$1.length === 0 || excludeFromDescend(element)) {\n        return {\n          element,\n          offset\n        };\n      } else if (offset < children$1.length && !excludeFromDescend(children$1[offset])) {\n        return {\n          element: children$1[offset],\n          offset: 0\n        };\n      } else {\n        const last = children$1[children$1.length - 1];\n        if (excludeFromDescend(last)) {\n          return {\n            element,\n            offset\n          };\n        } else {\n          if (name(last) === 'img') {\n            return {\n              element: last,\n              offset: 1\n            };\n          } else if (isText$9(last)) {\n            return {\n              element: last,\n              offset: get$3(last).length\n            };\n          } else {\n            return {\n              element: last,\n              offset: children(last).length\n            };\n          }\n        }\n      }\n    };\n    const markerInfo = (element, cleanupFun) => {\n      const pos = absolute(element);\n      const height = get$2(element);\n      return {\n        element,\n        bottom: pos.top + height,\n        height,\n        pos,\n        cleanup: cleanupFun\n      };\n    };\n    const createMarker$1 = (element, offset) => {\n      const startPoint = descend(element, offset);\n      const span = SugarElement.fromHtml('<span data-mce-bogus=\"all\" style=\"display: inline-block;\">' + ZWSP$1 + '</span>');\n      before$3(startPoint.element, span);\n      return markerInfo(span, () => remove$5(span));\n    };\n    const elementMarker = element => markerInfo(SugarElement.fromDom(element), noop);\n    const withMarker = (editor, f, rng, alignToTop) => {\n      preserveWith(editor, (_s, _e) => applyWithMarker(editor, f, rng, alignToTop), rng);\n    };\n    const withScrollEvents = (editor, doc, f, marker, alignToTop) => {\n      const data = {\n        elm: marker.element.dom,\n        alignToTop\n      };\n      if (fireScrollIntoViewEvent(editor, data)) {\n        return;\n      }\n      const scrollTop = get$5(doc).top;\n      f(doc, scrollTop, marker, alignToTop);\n      fireAfterScrollIntoViewEvent(editor, data);\n    };\n    const applyWithMarker = (editor, f, rng, alignToTop) => {\n      const body = SugarElement.fromDom(editor.getBody());\n      const doc = SugarElement.fromDom(editor.getDoc());\n      reflow(body);\n      const marker = createMarker$1(SugarElement.fromDom(rng.startContainer), rng.startOffset);\n      withScrollEvents(editor, doc, f, marker, alignToTop);\n      marker.cleanup();\n    };\n    const withElement = (editor, element, f, alignToTop) => {\n      const doc = SugarElement.fromDom(editor.getDoc());\n      withScrollEvents(editor, doc, f, elementMarker(element), alignToTop);\n    };\n    const preserveWith = (editor, f, rng) => {\n      const startElement = rng.startContainer;\n      const startOffset = rng.startOffset;\n      const endElement = rng.endContainer;\n      const endOffset = rng.endOffset;\n      f(SugarElement.fromDom(startElement), SugarElement.fromDom(endElement));\n      const newRng = editor.dom.createRng();\n      newRng.setStart(startElement, startOffset);\n      newRng.setEnd(endElement, endOffset);\n      editor.selection.setRng(rng);\n    };\n    const scrollToMarker = (marker, viewHeight, alignToTop, doc) => {\n      const pos = marker.pos;\n      if (alignToTop) {\n        to(pos.left, pos.top, doc);\n      } else {\n        const y = pos.top - viewHeight + marker.height;\n        to(pos.left, y, doc);\n      }\n    };\n    const intoWindowIfNeeded = (doc, scrollTop, viewHeight, marker, alignToTop) => {\n      const viewportBottom = viewHeight + scrollTop;\n      const markerTop = marker.pos.top;\n      const markerBottom = marker.bottom;\n      const largerThanViewport = markerBottom - markerTop >= viewHeight;\n      if (markerTop < scrollTop) {\n        scrollToMarker(marker, viewHeight, alignToTop !== false, doc);\n      } else if (markerTop > viewportBottom) {\n        const align = largerThanViewport ? alignToTop !== false : alignToTop === true;\n        scrollToMarker(marker, viewHeight, align, doc);\n      } else if (markerBottom > viewportBottom && !largerThanViewport) {\n        scrollToMarker(marker, viewHeight, alignToTop === true, doc);\n      }\n    };\n    const intoWindow = (doc, scrollTop, marker, alignToTop) => {\n      const viewHeight = doc.dom.defaultView.innerHeight;\n      intoWindowIfNeeded(doc, scrollTop, viewHeight, marker, alignToTop);\n    };\n    const intoFrame = (doc, scrollTop, marker, alignToTop) => {\n      const frameViewHeight = doc.dom.defaultView.innerHeight;\n      intoWindowIfNeeded(doc, scrollTop, frameViewHeight, marker, alignToTop);\n      const op = find(marker.element);\n      const viewportBounds = getBounds(window);\n      if (op.top < viewportBounds.y) {\n        intoView(marker.element, alignToTop !== false);\n      } else if (op.top > viewportBounds.bottom) {\n        intoView(marker.element, alignToTop === true);\n      }\n    };\n    const rangeIntoWindow = (editor, rng, alignToTop) => withMarker(editor, intoWindow, rng, alignToTop);\n    const elementIntoWindow = (editor, element, alignToTop) => withElement(editor, element, intoWindow, alignToTop);\n    const rangeIntoFrame = (editor, rng, alignToTop) => withMarker(editor, intoFrame, rng, alignToTop);\n    const elementIntoFrame = (editor, element, alignToTop) => withElement(editor, element, intoFrame, alignToTop);\n    const scrollElementIntoView = (editor, element, alignToTop) => {\n      const scroller = editor.inline ? elementIntoWindow : elementIntoFrame;\n      scroller(editor, element, alignToTop);\n    };\n    const scrollRangeIntoView = (editor, rng, alignToTop) => {\n      const scroller = editor.inline ? rangeIntoWindow : rangeIntoFrame;\n      scroller(editor, rng, alignToTop);\n    };\n\n    const focus$1 = element => element.dom.focus();\n    const hasFocus$1 = element => {\n      const root = getRootNode(element).dom;\n      return element.dom === root.activeElement;\n    };\n    const active$1 = (root = getDocument()) => Optional.from(root.dom.activeElement).map(SugarElement.fromDom);\n    const search = element => active$1(getRootNode(element)).filter(e => element.dom.contains(e.dom));\n\n    const clamp$1 = (offset, element) => {\n      const max = isText$9(element) ? get$3(element).length : children(element).length + 1;\n      if (offset > max) {\n        return max;\n      } else if (offset < 0) {\n        return 0;\n      }\n      return offset;\n    };\n    const normalizeRng = rng => SimSelection.range(rng.start, clamp$1(rng.soffset, rng.start), rng.finish, clamp$1(rng.foffset, rng.finish));\n    const isOrContains = (root, elm) => !isRestrictedNode(elm.dom) && (contains(root, elm) || eq(root, elm));\n    const isRngInRoot = root => rng => isOrContains(root, rng.start) && isOrContains(root, rng.finish);\n    const shouldStore = editor => editor.inline;\n    const nativeRangeToSelectionRange = r => SimSelection.range(SugarElement.fromDom(r.startContainer), r.startOffset, SugarElement.fromDom(r.endContainer), r.endOffset);\n    const readRange = win => {\n      const selection = win.getSelection();\n      const rng = !selection || selection.rangeCount === 0 ? Optional.none() : Optional.from(selection.getRangeAt(0));\n      return rng.map(nativeRangeToSelectionRange);\n    };\n    const getBookmark = root => {\n      const win = defaultView(root);\n      return readRange(win.dom).filter(isRngInRoot(root));\n    };\n    const validate = (root, bookmark) => Optional.from(bookmark).filter(isRngInRoot(root)).map(normalizeRng);\n    const bookmarkToNativeRng = bookmark => {\n      const rng = document.createRange();\n      try {\n        rng.setStart(bookmark.start.dom, bookmark.soffset);\n        rng.setEnd(bookmark.finish.dom, bookmark.foffset);\n        return Optional.some(rng);\n      } catch (_) {\n        return Optional.none();\n      }\n    };\n    const store = editor => {\n      const newBookmark = shouldStore(editor) ? getBookmark(SugarElement.fromDom(editor.getBody())) : Optional.none();\n      editor.bookmark = newBookmark.isSome() ? newBookmark : editor.bookmark;\n    };\n    const getRng = editor => {\n      const bookmark = editor.bookmark ? editor.bookmark : Optional.none();\n      return bookmark.bind(x => validate(SugarElement.fromDom(editor.getBody()), x)).bind(bookmarkToNativeRng);\n    };\n    const restore = editor => {\n      getRng(editor).each(rng => editor.selection.setRng(rng));\n    };\n\n    const isEditorUIElement$1 = elm => {\n      const className = elm.className.toString();\n      return className.indexOf('tox-') !== -1 || className.indexOf('mce-') !== -1;\n    };\n    const FocusManager = { isEditorUIElement: isEditorUIElement$1 };\n\n    const wrappedSetTimeout = (callback, time) => {\n      if (!isNumber(time)) {\n        time = 0;\n      }\n      return setTimeout(callback, time);\n    };\n    const wrappedSetInterval = (callback, time) => {\n      if (!isNumber(time)) {\n        time = 0;\n      }\n      return setInterval(callback, time);\n    };\n    const Delay = {\n      setEditorTimeout: (editor, callback, time) => {\n        return wrappedSetTimeout(() => {\n          if (!editor.removed) {\n            callback();\n          }\n        }, time);\n      },\n      setEditorInterval: (editor, callback, time) => {\n        const timer = wrappedSetInterval(() => {\n          if (!editor.removed) {\n            callback();\n          } else {\n            clearInterval(timer);\n          }\n        }, time);\n        return timer;\n      }\n    };\n\n    const isManualNodeChange = e => {\n      return e.type === 'nodechange' && e.selectionChange;\n    };\n    const registerPageMouseUp = (editor, throttledStore) => {\n      const mouseUpPage = () => {\n        throttledStore.throttle();\n      };\n      DOMUtils.DOM.bind(document, 'mouseup', mouseUpPage);\n      editor.on('remove', () => {\n        DOMUtils.DOM.unbind(document, 'mouseup', mouseUpPage);\n      });\n    };\n    const registerMouseUp = (editor, throttledStore) => {\n      editor.on('mouseup touchend', _e => {\n        throttledStore.throttle();\n      });\n    };\n    const registerEditorEvents = (editor, throttledStore) => {\n      registerMouseUp(editor, throttledStore);\n      editor.on('keyup NodeChange AfterSetSelectionRange', e => {\n        if (!isManualNodeChange(e)) {\n          store(editor);\n        }\n      });\n    };\n    const register$6 = editor => {\n      const throttledStore = first$1(() => {\n        store(editor);\n      }, 0);\n      editor.on('init', () => {\n        if (editor.inline) {\n          registerPageMouseUp(editor, throttledStore);\n        }\n        registerEditorEvents(editor, throttledStore);\n      });\n      editor.on('remove', () => {\n        throttledStore.cancel();\n      });\n    };\n\n    let documentFocusInHandler;\n    const DOM$9 = DOMUtils.DOM;\n    const isEditorUIElement = elm => {\n      return FocusManager.isEditorUIElement(elm);\n    };\n    const isEditorContentAreaElement = elm => {\n      const classList = elm.classList;\n      if (classList !== undefined) {\n        return classList.contains('tox-edit-area') || classList.contains('tox-edit-area__iframe') || classList.contains('mce-content-body');\n      } else {\n        return false;\n      }\n    };\n    const isUIElement = (editor, elm) => {\n      const customSelector = getCustomUiSelector(editor);\n      const parent = DOM$9.getParent(elm, elm => {\n        return isEditorUIElement(elm) || (customSelector ? editor.dom.is(elm, customSelector) : false);\n      });\n      return parent !== null;\n    };\n    const getActiveElement = editor => {\n      try {\n        const root = getRootNode(SugarElement.fromDom(editor.getElement()));\n        return active$1(root).fold(() => document.body, x => x.dom);\n      } catch (ex) {\n        return document.body;\n      }\n    };\n    const registerEvents$1 = (editorManager, e) => {\n      const editor = e.editor;\n      register$6(editor);\n      editor.on('focusin', () => {\n        const focusedEditor = editorManager.focusedEditor;\n        if (focusedEditor !== editor) {\n          if (focusedEditor) {\n            focusedEditor.dispatch('blur', { focusedEditor: editor });\n          }\n          editorManager.setActive(editor);\n          editorManager.focusedEditor = editor;\n          editor.dispatch('focus', { blurredEditor: focusedEditor });\n          editor.focus(true);\n        }\n      });\n      editor.on('focusout', () => {\n        Delay.setEditorTimeout(editor, () => {\n          const focusedEditor = editorManager.focusedEditor;\n          if (!isUIElement(editor, getActiveElement(editor)) && focusedEditor === editor) {\n            editor.dispatch('blur', { focusedEditor: null });\n            editorManager.focusedEditor = null;\n          }\n        });\n      });\n      if (!documentFocusInHandler) {\n        documentFocusInHandler = e => {\n          const activeEditor = editorManager.activeEditor;\n          if (activeEditor) {\n            getOriginalEventTarget(e).each(target => {\n              if (target.ownerDocument === document) {\n                if (target !== document.body && !isUIElement(activeEditor, target) && editorManager.focusedEditor === activeEditor) {\n                  activeEditor.dispatch('blur', { focusedEditor: null });\n                  editorManager.focusedEditor = null;\n                }\n              }\n            });\n          }\n        };\n        DOM$9.bind(document, 'focusin', documentFocusInHandler);\n      }\n    };\n    const unregisterDocumentEvents = (editorManager, e) => {\n      if (editorManager.focusedEditor === e.editor) {\n        editorManager.focusedEditor = null;\n      }\n      if (!editorManager.activeEditor) {\n        DOM$9.unbind(document, 'focusin', documentFocusInHandler);\n        documentFocusInHandler = null;\n      }\n    };\n    const setup$v = editorManager => {\n      editorManager.on('AddEditor', curry(registerEvents$1, editorManager));\n      editorManager.on('RemoveEditor', curry(unregisterDocumentEvents, editorManager));\n    };\n\n    const getContentEditableHost = (editor, node) => editor.dom.getParent(node, node => editor.dom.getContentEditable(node) === 'true');\n    const getCollapsedNode = rng => rng.collapsed ? Optional.from(getNode$1(rng.startContainer, rng.startOffset)).map(SugarElement.fromDom) : Optional.none();\n    const getFocusInElement = (root, rng) => getCollapsedNode(rng).bind(node => {\n      if (isTableSection(node)) {\n        return Optional.some(node);\n      } else if (contains(root, node) === false) {\n        return Optional.some(root);\n      } else {\n        return Optional.none();\n      }\n    });\n    const normalizeSelection$1 = (editor, rng) => {\n      getFocusInElement(SugarElement.fromDom(editor.getBody()), rng).bind(elm => {\n        return firstPositionIn(elm.dom);\n      }).fold(() => {\n        editor.selection.normalize();\n        return;\n      }, caretPos => editor.selection.setRng(caretPos.toRange()));\n    };\n    const focusBody = body => {\n      if (body.setActive) {\n        try {\n          body.setActive();\n        } catch (ex) {\n          body.focus();\n        }\n      } else {\n        body.focus();\n      }\n    };\n    const hasElementFocus = elm => hasFocus$1(elm) || search(elm).isSome();\n    const hasIframeFocus = editor => editor.iframeElement && hasFocus$1(SugarElement.fromDom(editor.iframeElement));\n    const hasInlineFocus = editor => {\n      const rawBody = editor.getBody();\n      return rawBody && hasElementFocus(SugarElement.fromDom(rawBody));\n    };\n    const hasUiFocus = editor => {\n      const dos = getRootNode(SugarElement.fromDom(editor.getElement()));\n      return active$1(dos).filter(elem => !isEditorContentAreaElement(elem.dom) && isUIElement(editor, elem.dom)).isSome();\n    };\n    const hasFocus = editor => editor.inline ? hasInlineFocus(editor) : hasIframeFocus(editor);\n    const hasEditorOrUiFocus = editor => hasFocus(editor) || hasUiFocus(editor);\n    const focusEditor = editor => {\n      const selection = editor.selection;\n      const body = editor.getBody();\n      let rng = selection.getRng();\n      editor.quirks.refreshContentEditable();\n      if (editor.bookmark !== undefined && hasFocus(editor) === false) {\n        getRng(editor).each(bookmarkRng => {\n          editor.selection.setRng(bookmarkRng);\n          rng = bookmarkRng;\n        });\n      }\n      const contentEditableHost = getContentEditableHost(editor, selection.getNode());\n      if (editor.dom.isChildOf(contentEditableHost, body)) {\n        focusBody(contentEditableHost);\n        normalizeSelection$1(editor, rng);\n        activateEditor(editor);\n        return;\n      }\n      if (!editor.inline) {\n        if (!Env.browser.isOpera()) {\n          focusBody(body);\n        }\n        editor.getWin().focus();\n      }\n      if (Env.browser.isFirefox() || editor.inline) {\n        focusBody(body);\n        normalizeSelection$1(editor, rng);\n      }\n      activateEditor(editor);\n    };\n    const activateEditor = editor => editor.editorManager.setActive(editor);\n    const focus = (editor, skipFocus) => {\n      if (editor.removed) {\n        return;\n      }\n      if (skipFocus) {\n        activateEditor(editor);\n      } else {\n        focusEditor(editor);\n      }\n    };\n\n    const getEndpointElement = (root, rng, start, real, resolve) => {\n      const container = start ? rng.startContainer : rng.endContainer;\n      const offset = start ? rng.startOffset : rng.endOffset;\n      return Optional.from(container).map(SugarElement.fromDom).map(elm => !real || !rng.collapsed ? child$1(elm, resolve(elm, offset)).getOr(elm) : elm).bind(elm => isElement$7(elm) ? Optional.some(elm) : parent(elm).filter(isElement$7)).map(elm => elm.dom).getOr(root);\n    };\n    const getStart = (root, rng, real) => getEndpointElement(root, rng, true, real, (elm, offset) => Math.min(childNodesCount(elm), offset));\n    const getEnd$1 = (root, rng, real) => getEndpointElement(root, rng, false, real, (elm, offset) => offset > 0 ? offset - 1 : offset);\n    const skipEmptyTextNodes = (node, forwards) => {\n      const orig = node;\n      while (node && isText$8(node) && node.length === 0) {\n        node = forwards ? node.nextSibling : node.previousSibling;\n      }\n      return node || orig;\n    };\n    const getNode = (root, rng) => {\n      let elm, startContainer, endContainer;\n      if (!rng) {\n        return root;\n      }\n      startContainer = rng.startContainer;\n      endContainer = rng.endContainer;\n      const startOffset = rng.startOffset;\n      const endOffset = rng.endOffset;\n      elm = rng.commonAncestorContainer;\n      if (!rng.collapsed) {\n        if (startContainer === endContainer) {\n          if (endOffset - startOffset < 2) {\n            if (startContainer.hasChildNodes()) {\n              elm = startContainer.childNodes[startOffset];\n            }\n          }\n        }\n        if (startContainer.nodeType === 3 && endContainer.nodeType === 3) {\n          if (startContainer.length === startOffset) {\n            startContainer = skipEmptyTextNodes(startContainer.nextSibling, true);\n          } else {\n            startContainer = startContainer.parentNode;\n          }\n          if (endOffset === 0) {\n            endContainer = skipEmptyTextNodes(endContainer.previousSibling, false);\n          } else {\n            endContainer = endContainer.parentNode;\n          }\n          if (startContainer && startContainer === endContainer) {\n            return startContainer;\n          }\n        }\n      }\n      if (elm && elm.nodeType === 3) {\n        return elm.parentNode;\n      }\n      return elm;\n    };\n    const getSelectedBlocks = (dom, rng, startElm, endElm) => {\n      let node;\n      const selectedBlocks = [];\n      const root = dom.getRoot();\n      startElm = dom.getParent(startElm || getStart(root, rng, rng.collapsed), dom.isBlock);\n      endElm = dom.getParent(endElm || getEnd$1(root, rng, rng.collapsed), dom.isBlock);\n      if (startElm && startElm !== root) {\n        selectedBlocks.push(startElm);\n      }\n      if (startElm && endElm && startElm !== endElm) {\n        node = startElm;\n        const walker = new DomTreeWalker(startElm, root);\n        while ((node = walker.next()) && node !== endElm) {\n          if (dom.isBlock(node)) {\n            selectedBlocks.push(node);\n          }\n        }\n      }\n      if (endElm && startElm !== endElm && endElm !== root) {\n        selectedBlocks.push(endElm);\n      }\n      return selectedBlocks;\n    };\n    const select = (dom, node, content) => Optional.from(node).map(node => {\n      const idx = dom.nodeIndex(node);\n      const rng = dom.createRng();\n      rng.setStart(node.parentNode, idx);\n      rng.setEnd(node.parentNode, idx + 1);\n      if (content) {\n        moveEndPoint(dom, rng, node, true);\n        moveEndPoint(dom, rng, node, false);\n      }\n      return rng;\n    });\n\n    const processRanges = (editor, ranges) => map$3(ranges, range => {\n      const evt = editor.dispatch('GetSelectionRange', { range });\n      return evt.range !== range ? evt.range : range;\n    });\n\n    const getEnd = element => name(element) === 'img' ? 1 : getOption(element).fold(() => children(element).length, v => v.length);\n    const isTextNodeWithCursorPosition = el => getOption(el).filter(text => text.trim().length !== 0 || text.indexOf(nbsp) > -1).isSome();\n    const elementsWithCursorPosition = [\n      'img',\n      'br'\n    ];\n    const isCursorPosition = elem => {\n      const hasCursorPosition = isTextNodeWithCursorPosition(elem);\n      return hasCursorPosition || contains$2(elementsWithCursorPosition, name(elem));\n    };\n\n    const first = element => descendant$1(element, isCursorPosition);\n    const last = element => descendantRtl(element, isCursorPosition);\n    const descendantRtl = (scope, predicate) => {\n      const descend = element => {\n        const children$1 = children(element);\n        for (let i = children$1.length - 1; i >= 0; i--) {\n          const child = children$1[i];\n          if (predicate(child)) {\n            return Optional.some(child);\n          }\n          const res = descend(child);\n          if (res.isSome()) {\n            return res;\n          }\n        }\n        return Optional.none();\n      };\n      return descend(scope);\n    };\n\n    const autocompleteSelector = '[data-mce-autocompleter]';\n    const create$8 = (editor, range) => {\n      if (findIn(SugarElement.fromDom(editor.getBody())).isNone()) {\n        const wrapper = SugarElement.fromHtml('<span data-mce-autocompleter=\"1\" data-mce-bogus=\"1\"></span>', editor.getDoc());\n        append$1(wrapper, SugarElement.fromDom(range.extractContents()));\n        range.insertNode(wrapper.dom);\n        parent(wrapper).each(elm => elm.dom.normalize());\n        last(wrapper).map(last => {\n          editor.selection.setCursorLocation(last.dom, getEnd(last));\n        });\n      }\n    };\n    const detect$1 = elm => closest$3(elm, autocompleteSelector);\n    const findIn = elm => descendant(elm, autocompleteSelector);\n    const remove$3 = (editor, elm) => findIn(elm).each(wrapper => {\n      const bookmark = editor.selection.getBookmark();\n      unwrap(wrapper);\n      editor.selection.moveToBookmark(bookmark);\n    });\n\n    const typeLookup = {\n      '#text': 3,\n      '#comment': 8,\n      '#cdata': 4,\n      '#pi': 7,\n      '#doctype': 10,\n      '#document-fragment': 11\n    };\n    const walk$2 = (node, root, prev) => {\n      const startName = prev ? 'lastChild' : 'firstChild';\n      const siblingName = prev ? 'prev' : 'next';\n      if (node[startName]) {\n        return node[startName];\n      }\n      if (node !== root) {\n        let sibling = node[siblingName];\n        if (sibling) {\n          return sibling;\n        }\n        for (let parent = node.parent; parent && parent !== root; parent = parent.parent) {\n          sibling = parent[siblingName];\n          if (sibling) {\n            return sibling;\n          }\n        }\n      }\n    };\n    const isEmptyTextNode = node => {\n      if (!isWhitespaceText(node.value)) {\n        return false;\n      }\n      const parentNode = node.parent;\n      if (parentNode && (parentNode.name !== 'span' || parentNode.attr('style')) && /^[ ]+$/.test(node.value)) {\n        return false;\n      }\n      return true;\n    };\n    const isNonEmptyElement = node => {\n      const isNamedAnchor = node.name === 'a' && !node.attr('href') && node.attr('id');\n      return node.attr('name') || node.attr('id') && !node.firstChild || node.attr('data-mce-bookmark') || isNamedAnchor;\n    };\n    class AstNode {\n      constructor(name, type) {\n        this.name = name;\n        this.type = type;\n        if (type === 1) {\n          this.attributes = [];\n          this.attributes.map = {};\n        }\n      }\n      static create(name, attrs) {\n        const node = new AstNode(name, typeLookup[name] || 1);\n        if (attrs) {\n          each$f(attrs, (value, attrName) => {\n            node.attr(attrName, value);\n          });\n        }\n        return node;\n      }\n      replace(node) {\n        const self = this;\n        if (node.parent) {\n          node.remove();\n        }\n        self.insert(node, self);\n        self.remove();\n        return self;\n      }\n      attr(name, value) {\n        const self = this;\n        let attrs;\n        if (typeof name !== 'string') {\n          if (name !== undefined && name !== null) {\n            each$f(name, (value, key) => {\n              self.attr(key, value);\n            });\n          }\n          return self;\n        }\n        if (attrs = self.attributes) {\n          if (value !== undefined) {\n            if (value === null) {\n              if (name in attrs.map) {\n                delete attrs.map[name];\n                let i = attrs.length;\n                while (i--) {\n                  if (attrs[i].name === name) {\n                    attrs.splice(i, 1);\n                    return self;\n                  }\n                }\n              }\n              return self;\n            }\n            if (name in attrs.map) {\n              let i = attrs.length;\n              while (i--) {\n                if (attrs[i].name === name) {\n                  attrs[i].value = value;\n                  break;\n                }\n              }\n            } else {\n              attrs.push({\n                name,\n                value\n              });\n            }\n            attrs.map[name] = value;\n            return self;\n          }\n          return attrs.map[name];\n        }\n      }\n      clone() {\n        const self = this;\n        const clone = new AstNode(self.name, self.type);\n        let selfAttrs;\n        if (selfAttrs = self.attributes) {\n          const cloneAttrs = [];\n          cloneAttrs.map = {};\n          for (let i = 0, l = selfAttrs.length; i < l; i++) {\n            const selfAttr = selfAttrs[i];\n            if (selfAttr.name !== 'id') {\n              cloneAttrs[cloneAttrs.length] = {\n                name: selfAttr.name,\n                value: selfAttr.value\n              };\n              cloneAttrs.map[selfAttr.name] = selfAttr.value;\n            }\n          }\n          clone.attributes = cloneAttrs;\n        }\n        clone.value = self.value;\n        return clone;\n      }\n      wrap(wrapper) {\n        const self = this;\n        self.parent.insert(wrapper, self);\n        wrapper.append(self);\n        return self;\n      }\n      unwrap() {\n        const self = this;\n        for (let node = self.firstChild; node;) {\n          const next = node.next;\n          self.insert(node, self, true);\n          node = next;\n        }\n        self.remove();\n      }\n      remove() {\n        const self = this, parent = self.parent, next = self.next, prev = self.prev;\n        if (parent) {\n          if (parent.firstChild === self) {\n            parent.firstChild = next;\n            if (next) {\n              next.prev = null;\n            }\n          } else {\n            prev.next = next;\n          }\n          if (parent.lastChild === self) {\n            parent.lastChild = prev;\n            if (prev) {\n              prev.next = null;\n            }\n          } else {\n            next.prev = prev;\n          }\n          self.parent = self.next = self.prev = null;\n        }\n        return self;\n      }\n      append(node) {\n        const self = this;\n        if (node.parent) {\n          node.remove();\n        }\n        const last = self.lastChild;\n        if (last) {\n          last.next = node;\n          node.prev = last;\n          self.lastChild = node;\n        } else {\n          self.lastChild = self.firstChild = node;\n        }\n        node.parent = self;\n        return node;\n      }\n      insert(node, refNode, before) {\n        if (node.parent) {\n          node.remove();\n        }\n        const parent = refNode.parent || this;\n        if (before) {\n          if (refNode === parent.firstChild) {\n            parent.firstChild = node;\n          } else {\n            refNode.prev.next = node;\n          }\n          node.prev = refNode.prev;\n          node.next = refNode;\n          refNode.prev = node;\n        } else {\n          if (refNode === parent.lastChild) {\n            parent.lastChild = node;\n          } else {\n            refNode.next.prev = node;\n          }\n          node.next = refNode.next;\n          node.prev = refNode;\n          refNode.next = node;\n        }\n        node.parent = parent;\n        return node;\n      }\n      getAll(name) {\n        const self = this;\n        const collection = [];\n        for (let node = self.firstChild; node; node = walk$2(node, self)) {\n          if (node.name === name) {\n            collection.push(node);\n          }\n        }\n        return collection;\n      }\n      children() {\n        const self = this;\n        const collection = [];\n        for (let node = self.firstChild; node; node = node.next) {\n          collection.push(node);\n        }\n        return collection;\n      }\n      empty() {\n        const self = this;\n        if (self.firstChild) {\n          const nodes = [];\n          for (let node = self.firstChild; node; node = walk$2(node, self)) {\n            nodes.push(node);\n          }\n          let i = nodes.length;\n          while (i--) {\n            const node = nodes[i];\n            node.parent = node.firstChild = node.lastChild = node.next = node.prev = null;\n          }\n        }\n        self.firstChild = self.lastChild = null;\n        return self;\n      }\n      isEmpty(elements, whitespace = {}, predicate) {\n        const self = this;\n        let node = self.firstChild;\n        if (isNonEmptyElement(self)) {\n          return false;\n        }\n        if (node) {\n          do {\n            if (node.type === 1) {\n              if (node.attr('data-mce-bogus')) {\n                continue;\n              }\n              if (elements[node.name]) {\n                return false;\n              }\n              if (isNonEmptyElement(node)) {\n                return false;\n              }\n            }\n            if (node.type === 8) {\n              return false;\n            }\n            if (node.type === 3 && !isEmptyTextNode(node)) {\n              return false;\n            }\n            if (node.type === 3 && node.parent && whitespace[node.parent.name] && isWhitespaceText(node.value)) {\n              return false;\n            }\n            if (predicate && predicate(node)) {\n              return false;\n            }\n          } while (node = walk$2(node, self));\n        }\n        return true;\n      }\n      walk(prev) {\n        return walk$2(this, null, prev);\n      }\n    }\n\n    const isConditionalComment = (html, startIndex) => /^\\s*\\[if [\\w\\W]+\\]>.*<!\\[endif\\](--!?)?>/.test(html.substr(startIndex));\n    const findCommentEndIndex = (html, isBogus, startIndex = 0) => {\n      const lcHtml = html.toLowerCase();\n      if (lcHtml.indexOf('[if ', startIndex) !== -1 && isConditionalComment(lcHtml, startIndex)) {\n        const endIfIndex = lcHtml.indexOf('[endif]', startIndex);\n        return lcHtml.indexOf('>', endIfIndex);\n      } else {\n        if (isBogus) {\n          const endIndex = lcHtml.indexOf('>', startIndex);\n          return endIndex !== -1 ? endIndex : lcHtml.length;\n        } else {\n          const endCommentRegexp = /--!?>/g;\n          endCommentRegexp.lastIndex = startIndex;\n          const match = endCommentRegexp.exec(html);\n          return match ? match.index + match[0].length : lcHtml.length;\n        }\n      }\n    };\n    const findMatchingEndTagIndex = (schema, html, startIndex) => {\n      const startTagRegExp = /<([!?\\/])?([A-Za-z0-9\\-_:.]+)/g;\n      const endTagRegExp = /(?:\\s(?:[^'\">]+(?:\"[^\"]*\"|'[^']*'))*[^\"'>]*(?:\"[^\">]*|'[^'>]*)?|\\s*|\\/)>/g;\n      const voidElements = schema.getVoidElements();\n      let count = 1, index = startIndex;\n      while (count !== 0) {\n        startTagRegExp.lastIndex = index;\n        while (true) {\n          const startMatch = startTagRegExp.exec(html);\n          if (startMatch === null) {\n            return index;\n          } else if (startMatch[1] === '!') {\n            if (startsWith(startMatch[2], '--')) {\n              index = findCommentEndIndex(html, false, startMatch.index + '!--'.length);\n            } else {\n              index = findCommentEndIndex(html, true, startMatch.index + 1);\n            }\n            break;\n          } else {\n            endTagRegExp.lastIndex = startTagRegExp.lastIndex;\n            const endMatch = endTagRegExp.exec(html);\n            if (isNull(endMatch) || endMatch.index !== startTagRegExp.lastIndex) {\n              continue;\n            }\n            if (startMatch[1] === '/') {\n              count -= 1;\n            } else if (!has$2(voidElements, startMatch[2])) {\n              count += 1;\n            }\n            index = startTagRegExp.lastIndex + endMatch[0].length;\n            break;\n          }\n        }\n      }\n      return index;\n    };\n    const trimHtml$1 = (tempAttrs, html) => {\n      const trimContentRegExp = new RegExp(['\\\\s?(' + tempAttrs.join('|') + ')=\"[^\"]+\"'].join('|'), 'gi');\n      return html.replace(trimContentRegExp, '');\n    };\n    const trimInternal = (serializer, html) => {\n      const bogusAllRegExp = /<(\\w+) [^>]*data-mce-bogus=\"all\"[^>]*>/g;\n      const schema = serializer.schema;\n      let content = trimHtml$1(serializer.getTempAttrs(), html);\n      const voidElements = schema.getVoidElements();\n      let matches;\n      while (matches = bogusAllRegExp.exec(content)) {\n        const index = bogusAllRegExp.lastIndex;\n        const matchLength = matches[0].length;\n        let endTagIndex;\n        if (voidElements[matches[1]]) {\n          endTagIndex = index;\n        } else {\n          endTagIndex = findMatchingEndTagIndex(schema, content, index);\n        }\n        content = content.substring(0, index - matchLength) + content.substring(endTagIndex);\n        bogusAllRegExp.lastIndex = index - matchLength;\n      }\n      return trim$1(content);\n    };\n    const trimExternal = trimInternal;\n\n    const trimEmptyContents = (editor, html) => {\n      const blockName = getForcedRootBlock(editor);\n      const emptyRegExp = new RegExp(`^(<${ blockName }[^>]*>(&nbsp;|&#160;|\\\\s|\\u00a0|<br \\\\/>|)<\\\\/${ blockName }>[\\r\\n]*|<br \\\\/>[\\r\\n]*)$`);\n      return html.replace(emptyRegExp, '');\n    };\n    const getContentFromBody = (editor, args, body) => {\n      let content;\n      if (args.format === 'raw') {\n        content = Tools.trim(trimExternal(editor.serializer, body.innerHTML));\n      } else if (args.format === 'text') {\n        content = editor.dom.isEmpty(body) ? '' : trim$1(body.innerText || body.textContent);\n      } else if (args.format === 'tree') {\n        content = editor.serializer.serialize(body, args);\n      } else {\n        content = trimEmptyContents(editor, editor.serializer.serialize(body, args));\n      }\n      const shouldTrim = args.format !== 'text' && !isWsPreserveElement(SugarElement.fromDom(body));\n      return shouldTrim && isString(content) ? Tools.trim(content) : content;\n    };\n    const getContentInternal = (editor, args) => Optional.from(editor.getBody()).fold(constant(args.format === 'tree' ? new AstNode('body', 11) : ''), body => getContentFromBody(editor, args, body));\n\n    const each$b = Tools.each;\n    const ElementUtils = dom => {\n      const compare = (node1, node2) => {\n        if (node1.nodeName !== node2.nodeName) {\n          return false;\n        }\n        const getAttribs = node => {\n          const attribs = {};\n          each$b(dom.getAttribs(node), attr => {\n            const name = attr.nodeName.toLowerCase();\n            if (name.indexOf('_') !== 0 && name !== 'style' && name.indexOf('data-') !== 0) {\n              attribs[name] = dom.getAttrib(node, name);\n            }\n          });\n          return attribs;\n        };\n        const compareObjects = (obj1, obj2) => {\n          let value, name;\n          for (name in obj1) {\n            if (has$2(obj1, name)) {\n              value = obj2[name];\n              if (typeof value === 'undefined') {\n                return false;\n              }\n              if (obj1[name] !== value) {\n                return false;\n              }\n              delete obj2[name];\n            }\n          }\n          for (name in obj2) {\n            if (has$2(obj2, name)) {\n              return false;\n            }\n          }\n          return true;\n        };\n        if (!compareObjects(getAttribs(node1), getAttribs(node2))) {\n          return false;\n        }\n        if (!compareObjects(dom.parseStyle(dom.getAttrib(node1, 'style')), dom.parseStyle(dom.getAttrib(node2, 'style')))) {\n          return false;\n        }\n        return !isBookmarkNode$1(node1) && !isBookmarkNode$1(node2);\n      };\n      return { compare };\n    };\n\n    const makeMap$1 = Tools.makeMap;\n    const Writer = settings => {\n      const html = [];\n      settings = settings || {};\n      const indent = settings.indent;\n      const indentBefore = makeMap$1(settings.indent_before || '');\n      const indentAfter = makeMap$1(settings.indent_after || '');\n      const encode = Entities.getEncodeFunc(settings.entity_encoding || 'raw', settings.entities);\n      const htmlOutput = settings.element_format !== 'xhtml';\n      return {\n        start: (name, attrs, empty) => {\n          let i, l, attr, value;\n          if (indent && indentBefore[name] && html.length > 0) {\n            value = html[html.length - 1];\n            if (value.length > 0 && value !== '\\n') {\n              html.push('\\n');\n            }\n          }\n          html.push('<', name);\n          if (attrs) {\n            for (i = 0, l = attrs.length; i < l; i++) {\n              attr = attrs[i];\n              html.push(' ', attr.name, '=\"', encode(attr.value, true), '\"');\n            }\n          }\n          if (!empty || htmlOutput) {\n            html[html.length] = '>';\n          } else {\n            html[html.length] = ' />';\n          }\n          if (empty && indent && indentAfter[name] && html.length > 0) {\n            value = html[html.length - 1];\n            if (value.length > 0 && value !== '\\n') {\n              html.push('\\n');\n            }\n          }\n        },\n        end: name => {\n          let value;\n          html.push('</', name, '>');\n          if (indent && indentAfter[name] && html.length > 0) {\n            value = html[html.length - 1];\n            if (value.length > 0 && value !== '\\n') {\n              html.push('\\n');\n            }\n          }\n        },\n        text: (text, raw) => {\n          if (text.length > 0) {\n            html[html.length] = raw ? text : encode(text);\n          }\n        },\n        cdata: text => {\n          html.push('<![CDATA[', text, ']]>');\n        },\n        comment: text => {\n          html.push('<!--', text, '-->');\n        },\n        pi: (name, text) => {\n          if (text) {\n            html.push('<?', name, ' ', encode(text), '?>');\n          } else {\n            html.push('<?', name, '?>');\n          }\n          if (indent) {\n            html.push('\\n');\n          }\n        },\n        doctype: text => {\n          html.push('<!DOCTYPE', text, '>', indent ? '\\n' : '');\n        },\n        reset: () => {\n          html.length = 0;\n        },\n        getContent: () => {\n          return html.join('').replace(/\\n$/, '');\n        }\n      };\n    };\n\n    const HtmlSerializer = (settings, schema = Schema()) => {\n      const writer = Writer(settings);\n      settings = settings || {};\n      settings.validate = 'validate' in settings ? settings.validate : true;\n      const serialize = node => {\n        const validate = settings.validate;\n        const handlers = {\n          3: node => {\n            writer.text(node.value, node.raw);\n          },\n          8: node => {\n            writer.comment(node.value);\n          },\n          7: node => {\n            writer.pi(node.name, node.value);\n          },\n          10: node => {\n            writer.doctype(node.value);\n          },\n          4: node => {\n            writer.cdata(node.value);\n          },\n          11: node => {\n            if (node = node.firstChild) {\n              do {\n                walk(node);\n              } while (node = node.next);\n            }\n          }\n        };\n        writer.reset();\n        const walk = node => {\n          const handler = handlers[node.type];\n          if (!handler) {\n            const name = node.name;\n            const isEmpty = name in schema.getVoidElements();\n            let attrs = node.attributes;\n            if (validate && attrs && attrs.length > 1) {\n              const sortedAttrs = [];\n              sortedAttrs.map = {};\n              const elementRule = schema.getElementRule(node.name);\n              if (elementRule) {\n                for (let i = 0, l = elementRule.attributesOrder.length; i < l; i++) {\n                  const attrName = elementRule.attributesOrder[i];\n                  if (attrName in attrs.map) {\n                    const attrValue = attrs.map[attrName];\n                    sortedAttrs.map[attrName] = attrValue;\n                    sortedAttrs.push({\n                      name: attrName,\n                      value: attrValue\n                    });\n                  }\n                }\n                for (let i = 0, l = attrs.length; i < l; i++) {\n                  const attrName = attrs[i].name;\n                  if (!(attrName in sortedAttrs.map)) {\n                    const attrValue = attrs.map[attrName];\n                    sortedAttrs.map[attrName] = attrValue;\n                    sortedAttrs.push({\n                      name: attrName,\n                      value: attrValue\n                    });\n                  }\n                }\n                attrs = sortedAttrs;\n              }\n            }\n            writer.start(name, attrs, isEmpty);\n            if (!isEmpty) {\n              let child = node.firstChild;\n              if (child) {\n                if ((name === 'pre' || name === 'textarea') && child.type === 3 && child.value[0] === '\\n') {\n                  writer.text('\\n', true);\n                }\n                do {\n                  walk(child);\n                } while (child = child.next);\n              }\n              writer.end(name);\n            }\n          } else {\n            handler(node);\n          }\n        };\n        if (node.type === 1 && !settings.inner) {\n          walk(node);\n        } else if (node.type === 3) {\n          handlers[3](node);\n        } else {\n          handlers[11](node);\n        }\n        return writer.getContent();\n      };\n      return { serialize };\n    };\n\n    const nonInheritableStyles = new Set();\n    (() => {\n      const nonInheritableStylesArr = [\n        'margin',\n        'margin-left',\n        'margin-right',\n        'margin-top',\n        'margin-bottom',\n        'padding',\n        'padding-left',\n        'padding-right',\n        'padding-top',\n        'padding-bottom',\n        'border',\n        'border-width',\n        'border-style',\n        'border-color',\n        'background',\n        'background-attachment',\n        'background-clip',\n        'background-color',\n        'background-image',\n        'background-origin',\n        'background-position',\n        'background-repeat',\n        'background-size',\n        'float',\n        'position',\n        'left',\n        'right',\n        'top',\n        'bottom',\n        'z-index',\n        'display',\n        'transform',\n        'width',\n        'max-width',\n        'min-width',\n        'height',\n        'max-height',\n        'min-height',\n        'overflow',\n        'overflow-x',\n        'overflow-y',\n        'text-overflow',\n        'vertical-align',\n        'transition',\n        'transition-delay',\n        'transition-duration',\n        'transition-property',\n        'transition-timing-function'\n      ];\n      each$g(nonInheritableStylesArr, style => {\n        nonInheritableStyles.add(style);\n      });\n    })();\n    const shorthandStyleProps = [\n      'font',\n      'text-decoration',\n      'text-emphasis'\n    ];\n    const getStyleProps = (dom, node) => keys(dom.parseStyle(dom.getAttrib(node, 'style')));\n    const isNonInheritableStyle = style => nonInheritableStyles.has(style);\n    const hasInheritableStyles = (dom, node) => forall(getStyleProps(dom, node), style => !isNonInheritableStyle(style));\n    const getLonghandStyleProps = styles => filter$6(styles, style => exists(shorthandStyleProps, prop => startsWith(style, prop)));\n    const hasStyleConflict = (dom, node, parentNode) => {\n      const nodeStyleProps = getStyleProps(dom, node);\n      const parentNodeStyleProps = getStyleProps(dom, parentNode);\n      const valueMismatch = prop => {\n        var _a, _b;\n        const nodeValue = (_a = dom.getStyle(node, prop)) !== null && _a !== void 0 ? _a : '';\n        const parentValue = (_b = dom.getStyle(parentNode, prop)) !== null && _b !== void 0 ? _b : '';\n        return isNotEmpty(nodeValue) && isNotEmpty(parentValue) && nodeValue !== parentValue;\n      };\n      return exists(nodeStyleProps, nodeStyleProp => {\n        const propExists = props => exists(props, prop => prop === nodeStyleProp);\n        if (!propExists(parentNodeStyleProps) && propExists(shorthandStyleProps)) {\n          const longhandProps = getLonghandStyleProps(parentNodeStyleProps);\n          return exists(longhandProps, valueMismatch);\n        } else {\n          return valueMismatch(nodeStyleProp);\n        }\n      });\n    };\n\n    const isChar = (forward, predicate, pos) => Optional.from(pos.container()).filter(isText$8).exists(text => {\n      const delta = forward ? 0 : -1;\n      return predicate(text.data.charAt(pos.offset() + delta));\n    });\n    const isBeforeSpace = curry(isChar, true, isWhiteSpace);\n    const isAfterSpace = curry(isChar, false, isWhiteSpace);\n    const isEmptyText = pos => {\n      const container = pos.container();\n      return isText$8(container) && (container.data.length === 0 || isZwsp(container.data) && BookmarkManager.isBookmarkNode(container.parentNode));\n    };\n    const matchesElementPosition = (before, predicate) => pos => Optional.from(getChildNodeAtRelativeOffset(before ? 0 : -1, pos)).filter(predicate).isSome();\n    const isImageBlock = node => isImg(node) && get$7(SugarElement.fromDom(node), 'display') === 'block';\n    const isCefNode = node => isContentEditableFalse$a(node) && !isBogusAll$1(node);\n    const isBeforeImageBlock = matchesElementPosition(true, isImageBlock);\n    const isAfterImageBlock = matchesElementPosition(false, isImageBlock);\n    const isBeforeMedia = matchesElementPosition(true, isMedia$2);\n    const isAfterMedia = matchesElementPosition(false, isMedia$2);\n    const isBeforeTable = matchesElementPosition(true, isTable$3);\n    const isAfterTable = matchesElementPosition(false, isTable$3);\n    const isBeforeContentEditableFalse = matchesElementPosition(true, isCefNode);\n    const isAfterContentEditableFalse = matchesElementPosition(false, isCefNode);\n\n    const getLastChildren = elm => {\n      const children = [];\n      let rawNode = elm.dom;\n      while (rawNode) {\n        children.push(SugarElement.fromDom(rawNode));\n        rawNode = rawNode.lastChild;\n      }\n      return children;\n    };\n    const removeTrailingBr = elm => {\n      const allBrs = descendants(elm, 'br');\n      const brs = filter$6(getLastChildren(elm).slice(-1), isBr$4);\n      if (allBrs.length === brs.length) {\n        each$g(brs, remove$5);\n      }\n    };\n    const fillWithPaddingBr = elm => {\n      empty(elm);\n      append$1(elm, SugarElement.fromHtml('<br data-mce-bogus=\"1\">'));\n    };\n    const trimBlockTrailingBr = elm => {\n      lastChild(elm).each(lastChild => {\n        prevSibling(lastChild).each(lastChildPrevSibling => {\n          if (isBlock$2(elm) && isBr$4(lastChild) && isBlock$2(lastChildPrevSibling)) {\n            remove$5(lastChild);\n          }\n        });\n      });\n    };\n\n    const dropLast = xs => xs.slice(0, -1);\n    const parentsUntil = (start, root, predicate) => {\n      if (contains(root, start)) {\n        return dropLast(parents$1(start, elm => {\n          return predicate(elm) || eq(elm, root);\n        }));\n      } else {\n        return [];\n      }\n    };\n    const parents = (start, root) => parentsUntil(start, root, never);\n    const parentsAndSelf = (start, root) => [start].concat(parents(start, root));\n\n    const navigateIgnoreEmptyTextNodes = (forward, root, from) => navigateIgnore(forward, root, from, isEmptyText);\n    const getClosestBlock$1 = (root, pos) => find$2(parentsAndSelf(SugarElement.fromDom(pos.container()), root), isBlock$2);\n    const isAtBeforeAfterBlockBoundary = (forward, root, pos) => navigateIgnoreEmptyTextNodes(forward, root.dom, pos).forall(newPos => getClosestBlock$1(root, pos).fold(() => isInSameBlock(newPos, pos, root.dom) === false, fromBlock => isInSameBlock(newPos, pos, root.dom) === false && contains(fromBlock, SugarElement.fromDom(newPos.container()))));\n    const isAtBlockBoundary = (forward, root, pos) => getClosestBlock$1(root, pos).fold(() => navigateIgnoreEmptyTextNodes(forward, root.dom, pos).forall(newPos => isInSameBlock(newPos, pos, root.dom) === false), parent => navigateIgnoreEmptyTextNodes(forward, parent.dom, pos).isNone());\n    const isAtStartOfBlock = curry(isAtBlockBoundary, false);\n    const isAtEndOfBlock = curry(isAtBlockBoundary, true);\n    const isBeforeBlock = curry(isAtBeforeAfterBlockBoundary, false);\n    const isAfterBlock = curry(isAtBeforeAfterBlockBoundary, true);\n\n    const isBr = pos => getElementFromPosition(pos).exists(isBr$4);\n    const findBr = (forward, root, pos) => {\n      const parentBlocks = filter$6(parentsAndSelf(SugarElement.fromDom(pos.container()), root), isBlock$2);\n      const scope = head(parentBlocks).getOr(root);\n      return fromPosition(forward, scope.dom, pos).filter(isBr);\n    };\n    const isBeforeBr$1 = (root, pos) => getElementFromPosition(pos).exists(isBr$4) || findBr(true, root, pos).isSome();\n    const isAfterBr = (root, pos) => getElementFromPrevPosition(pos).exists(isBr$4) || findBr(false, root, pos).isSome();\n    const findPreviousBr = curry(findBr, false);\n    const findNextBr = curry(findBr, true);\n\n    const isInMiddleOfText = pos => CaretPosition.isTextPosition(pos) && !pos.isAtStart() && !pos.isAtEnd();\n    const getClosestBlock = (root, pos) => {\n      const parentBlocks = filter$6(parentsAndSelf(SugarElement.fromDom(pos.container()), root), isBlock$2);\n      return head(parentBlocks).getOr(root);\n    };\n    const hasSpaceBefore = (root, pos) => {\n      if (isInMiddleOfText(pos)) {\n        return isAfterSpace(pos);\n      } else {\n        return isAfterSpace(pos) || prevPosition(getClosestBlock(root, pos).dom, pos).exists(isAfterSpace);\n      }\n    };\n    const hasSpaceAfter = (root, pos) => {\n      if (isInMiddleOfText(pos)) {\n        return isBeforeSpace(pos);\n      } else {\n        return isBeforeSpace(pos) || nextPosition(getClosestBlock(root, pos).dom, pos).exists(isBeforeSpace);\n      }\n    };\n    const isPreValue = value => contains$2([\n      'pre',\n      'pre-wrap'\n    ], value);\n    const isInPre = pos => getElementFromPosition(pos).bind(elm => closest$4(elm, isElement$7)).exists(elm => isPreValue(get$7(elm, 'white-space')));\n    const isAtBeginningOfBody = (root, pos) => prevPosition(root.dom, pos).isNone();\n    const isAtEndOfBody = (root, pos) => nextPosition(root.dom, pos).isNone();\n    const isAtLineBoundary = (root, pos) => isAtBeginningOfBody(root, pos) || isAtEndOfBody(root, pos) || isAtStartOfBlock(root, pos) || isAtEndOfBlock(root, pos) || isAfterBr(root, pos) || isBeforeBr$1(root, pos);\n    const needsToHaveNbsp = (root, pos) => {\n      if (isInPre(pos)) {\n        return false;\n      } else {\n        return isAtLineBoundary(root, pos) || hasSpaceBefore(root, pos) || hasSpaceAfter(root, pos);\n      }\n    };\n    const needsToBeNbspLeft = (root, pos) => {\n      if (isInPre(pos)) {\n        return false;\n      } else {\n        return isAtStartOfBlock(root, pos) || isBeforeBlock(root, pos) || isAfterBr(root, pos) || hasSpaceBefore(root, pos);\n      }\n    };\n    const leanRight = pos => {\n      const container = pos.container();\n      const offset = pos.offset();\n      if (isText$8(container) && offset < container.data.length) {\n        return CaretPosition(container, offset + 1);\n      } else {\n        return pos;\n      }\n    };\n    const needsToBeNbspRight = (root, pos) => {\n      if (isInPre(pos)) {\n        return false;\n      } else {\n        return isAtEndOfBlock(root, pos) || isAfterBlock(root, pos) || isBeforeBr$1(root, pos) || hasSpaceAfter(root, pos);\n      }\n    };\n    const needsToBeNbsp = (root, pos) => needsToBeNbspLeft(root, pos) || needsToBeNbspRight(root, leanRight(pos));\n    const isNbspAt = (text, offset) => isNbsp(text.charAt(offset));\n    const hasNbsp = pos => {\n      const container = pos.container();\n      return isText$8(container) && contains$1(container.data, nbsp);\n    };\n    const normalizeNbspMiddle = text => {\n      const chars = text.split('');\n      return map$3(chars, (chr, i) => {\n        if (isNbsp(chr) && i > 0 && i < chars.length - 1 && isContent(chars[i - 1]) && isContent(chars[i + 1])) {\n          return ' ';\n        } else {\n          return chr;\n        }\n      }).join('');\n    };\n    const normalizeNbspAtStart = (root, node) => {\n      const text = node.data;\n      const firstPos = CaretPosition(node, 0);\n      if (isNbspAt(text, 0) && !needsToBeNbsp(root, firstPos)) {\n        node.data = ' ' + text.slice(1);\n        return true;\n      } else {\n        return false;\n      }\n    };\n    const normalizeNbspInMiddleOfTextNode = node => {\n      const text = node.data;\n      const newText = normalizeNbspMiddle(text);\n      if (newText !== text) {\n        node.data = newText;\n        return true;\n      } else {\n        return false;\n      }\n    };\n    const normalizeNbspAtEnd = (root, node) => {\n      const text = node.data;\n      const lastPos = CaretPosition(node, text.length - 1);\n      if (isNbspAt(text, text.length - 1) && !needsToBeNbsp(root, lastPos)) {\n        node.data = text.slice(0, -1) + ' ';\n        return true;\n      } else {\n        return false;\n      }\n    };\n    const normalizeNbsps = (root, pos) => Optional.some(pos).filter(hasNbsp).bind(pos => {\n      const container = pos.container();\n      const normalized = normalizeNbspAtStart(root, container) || normalizeNbspInMiddleOfTextNode(container) || normalizeNbspAtEnd(root, container);\n      return normalized ? Optional.some(pos) : Optional.none();\n    });\n    const normalizeNbspsInEditor = editor => {\n      const root = SugarElement.fromDom(editor.getBody());\n      if (editor.selection.isCollapsed()) {\n        normalizeNbsps(root, CaretPosition.fromRangeStart(editor.selection.getRng())).each(pos => {\n          editor.selection.setRng(pos.toRange());\n        });\n      }\n    };\n\n    const normalize$1 = (node, offset, count) => {\n      if (count === 0) {\n        return;\n      }\n      const elm = SugarElement.fromDom(node);\n      const root = ancestor$3(elm, isBlock$2).getOr(elm);\n      const whitespace = node.data.slice(offset, offset + count);\n      const isEndOfContent = offset + count >= node.data.length && needsToBeNbspRight(root, CaretPosition(node, node.data.length));\n      const isStartOfContent = offset === 0 && needsToBeNbspLeft(root, CaretPosition(node, 0));\n      node.replaceData(offset, count, normalize$4(whitespace, 4, isStartOfContent, isEndOfContent));\n    };\n    const normalizeWhitespaceAfter = (node, offset) => {\n      const content = node.data.slice(offset);\n      const whitespaceCount = content.length - lTrim(content).length;\n      normalize$1(node, offset, whitespaceCount);\n    };\n    const normalizeWhitespaceBefore = (node, offset) => {\n      const content = node.data.slice(0, offset);\n      const whitespaceCount = content.length - rTrim(content).length;\n      normalize$1(node, offset - whitespaceCount, whitespaceCount);\n    };\n    const mergeTextNodes = (prevNode, nextNode, normalizeWhitespace, mergeToPrev = true) => {\n      const whitespaceOffset = rTrim(prevNode.data).length;\n      const newNode = mergeToPrev ? prevNode : nextNode;\n      const removeNode = mergeToPrev ? nextNode : prevNode;\n      if (mergeToPrev) {\n        newNode.appendData(removeNode.data);\n      } else {\n        newNode.insertData(0, removeNode.data);\n      }\n      remove$5(SugarElement.fromDom(removeNode));\n      if (normalizeWhitespace) {\n        normalizeWhitespaceAfter(newNode, whitespaceOffset);\n      }\n      return newNode;\n    };\n\n    const needsReposition = (pos, elm) => {\n      const container = pos.container();\n      const offset = pos.offset();\n      return CaretPosition.isTextPosition(pos) === false && container === elm.parentNode && offset > CaretPosition.before(elm).offset();\n    };\n    const reposition = (elm, pos) => needsReposition(pos, elm) ? CaretPosition(pos.container(), pos.offset() - 1) : pos;\n    const beforeOrStartOf = node => isText$8(node) ? CaretPosition(node, 0) : CaretPosition.before(node);\n    const afterOrEndOf = node => isText$8(node) ? CaretPosition(node, node.data.length) : CaretPosition.after(node);\n    const getPreviousSiblingCaretPosition = elm => {\n      if (isCaretCandidate$3(elm.previousSibling)) {\n        return Optional.some(afterOrEndOf(elm.previousSibling));\n      } else {\n        return elm.previousSibling ? lastPositionIn(elm.previousSibling) : Optional.none();\n      }\n    };\n    const getNextSiblingCaretPosition = elm => {\n      if (isCaretCandidate$3(elm.nextSibling)) {\n        return Optional.some(beforeOrStartOf(elm.nextSibling));\n      } else {\n        return elm.nextSibling ? firstPositionIn(elm.nextSibling) : Optional.none();\n      }\n    };\n    const findCaretPositionBackwardsFromElm = (rootElement, elm) => {\n      const startPosition = CaretPosition.before(elm.previousSibling ? elm.previousSibling : elm.parentNode);\n      return prevPosition(rootElement, startPosition).fold(() => nextPosition(rootElement, CaretPosition.after(elm)), Optional.some);\n    };\n    const findCaretPositionForwardsFromElm = (rootElement, elm) => nextPosition(rootElement, CaretPosition.after(elm)).fold(() => prevPosition(rootElement, CaretPosition.before(elm)), Optional.some);\n    const findCaretPositionBackwards = (rootElement, elm) => getPreviousSiblingCaretPosition(elm).orThunk(() => getNextSiblingCaretPosition(elm)).orThunk(() => findCaretPositionBackwardsFromElm(rootElement, elm));\n    const findCaretPositionForward = (rootElement, elm) => getNextSiblingCaretPosition(elm).orThunk(() => getPreviousSiblingCaretPosition(elm)).orThunk(() => findCaretPositionForwardsFromElm(rootElement, elm));\n    const findCaretPosition = (forward, rootElement, elm) => forward ? findCaretPositionForward(rootElement, elm) : findCaretPositionBackwards(rootElement, elm);\n    const findCaretPosOutsideElmAfterDelete = (forward, rootElement, elm) => findCaretPosition(forward, rootElement, elm).map(curry(reposition, elm));\n    const setSelection$1 = (editor, forward, pos) => {\n      pos.fold(() => {\n        editor.focus();\n      }, pos => {\n        editor.selection.setRng(pos.toRange(), forward);\n      });\n    };\n    const eqRawNode = rawNode => elm => elm.dom === rawNode;\n    const isBlock = (editor, elm) => elm && has$2(editor.schema.getBlockElements(), name(elm));\n    const paddEmptyBlock = elm => {\n      if (isEmpty$2(elm)) {\n        const br = SugarElement.fromHtml('<br data-mce-bogus=\"1\">');\n        empty(elm);\n        append$1(elm, br);\n        return Optional.some(CaretPosition.before(br.dom));\n      } else {\n        return Optional.none();\n      }\n    };\n    const deleteNormalized = (elm, afterDeletePosOpt, normalizeWhitespace) => {\n      const prevTextOpt = prevSibling(elm).filter(isText$9);\n      const nextTextOpt = nextSibling(elm).filter(isText$9);\n      remove$5(elm);\n      return lift3(prevTextOpt, nextTextOpt, afterDeletePosOpt, (prev, next, pos) => {\n        const prevNode = prev.dom, nextNode = next.dom;\n        const offset = prevNode.data.length;\n        mergeTextNodes(prevNode, nextNode, normalizeWhitespace);\n        return pos.container() === nextNode ? CaretPosition(prevNode, offset) : pos;\n      }).orThunk(() => {\n        if (normalizeWhitespace) {\n          prevTextOpt.each(elm => normalizeWhitespaceBefore(elm.dom, elm.dom.length));\n          nextTextOpt.each(elm => normalizeWhitespaceAfter(elm.dom, 0));\n        }\n        return afterDeletePosOpt;\n      });\n    };\n    const isInlineElement = (editor, element) => has$2(editor.schema.getTextInlineElements(), name(element));\n    const deleteElement$2 = (editor, forward, elm, moveCaret = true) => {\n      const afterDeletePos = findCaretPosOutsideElmAfterDelete(forward, editor.getBody(), elm.dom);\n      const parentBlock = ancestor$3(elm, curry(isBlock, editor), eqRawNode(editor.getBody()));\n      const normalizedAfterDeletePos = deleteNormalized(elm, afterDeletePos, isInlineElement(editor, elm));\n      if (editor.dom.isEmpty(editor.getBody())) {\n        editor.setContent('');\n        editor.selection.setCursorLocation();\n      } else {\n        parentBlock.bind(paddEmptyBlock).fold(() => {\n          if (moveCaret) {\n            setSelection$1(editor, forward, normalizedAfterDeletePos);\n          }\n        }, paddPos => {\n          if (moveCaret) {\n            setSelection$1(editor, forward, Optional.some(paddPos));\n          }\n        });\n      }\n    };\n\n    const isRootFromElement = root => cur => eq(root, cur);\n    const getTableCells = table => descendants(table, 'td,th');\n    const getTableDetailsFromRange = (rng, isRoot) => {\n      const getTable = node => getClosestTable(SugarElement.fromDom(node), isRoot);\n      const startTable = getTable(rng.startContainer);\n      const endTable = getTable(rng.endContainer);\n      const isStartInTable = startTable.isSome();\n      const isEndInTable = endTable.isSome();\n      const isSameTable = lift2(startTable, endTable, eq).getOr(false);\n      const isMultiTable = !isSameTable && isStartInTable && isEndInTable;\n      return {\n        startTable,\n        endTable,\n        isStartInTable,\n        isEndInTable,\n        isSameTable,\n        isMultiTable\n      };\n    };\n\n    const tableCellRng = (start, end) => ({\n      start,\n      end\n    });\n    const tableSelection = (rng, table, cells) => ({\n      rng,\n      table,\n      cells\n    });\n    const deleteAction = Adt.generate([\n      {\n        singleCellTable: [\n          'rng',\n          'cell'\n        ]\n      },\n      { fullTable: ['table'] },\n      {\n        partialTable: [\n          'cells',\n          'outsideDetails'\n        ]\n      },\n      {\n        multiTable: [\n          'startTableCells',\n          'endTableCells',\n          'betweenRng'\n        ]\n      }\n    ]);\n    const getClosestCell$1 = (container, isRoot) => closest$3(SugarElement.fromDom(container), 'td,th', isRoot);\n    const isExpandedCellRng = cellRng => !eq(cellRng.start, cellRng.end);\n    const getTableFromCellRng = (cellRng, isRoot) => getClosestTable(cellRng.start, isRoot).bind(startParentTable => getClosestTable(cellRng.end, isRoot).bind(endParentTable => someIf(eq(startParentTable, endParentTable), startParentTable)));\n    const isSingleCellTable = (cellRng, isRoot) => !isExpandedCellRng(cellRng) && getTableFromCellRng(cellRng, isRoot).exists(table => {\n      const rows = table.dom.rows;\n      return rows.length === 1 && rows[0].cells.length === 1;\n    });\n    const getCellRng = (rng, isRoot) => {\n      const startCell = getClosestCell$1(rng.startContainer, isRoot);\n      const endCell = getClosestCell$1(rng.endContainer, isRoot);\n      return lift2(startCell, endCell, tableCellRng);\n    };\n    const getCellRangeFromStartTable = isRoot => startCell => getClosestTable(startCell, isRoot).bind(table => last$3(getTableCells(table)).map(endCell => tableCellRng(startCell, endCell)));\n    const getCellRangeFromEndTable = isRoot => endCell => getClosestTable(endCell, isRoot).bind(table => head(getTableCells(table)).map(startCell => tableCellRng(startCell, endCell)));\n    const getTableSelectionFromCellRng = isRoot => cellRng => getTableFromCellRng(cellRng, isRoot).map(table => tableSelection(cellRng, table, getTableCells(table)));\n    const getTableSelections = (cellRng, selectionDetails, rng, isRoot) => {\n      if (rng.collapsed || !cellRng.forall(isExpandedCellRng)) {\n        return Optional.none();\n      } else if (selectionDetails.isSameTable) {\n        const sameTableSelection = cellRng.bind(getTableSelectionFromCellRng(isRoot));\n        return Optional.some({\n          start: sameTableSelection,\n          end: sameTableSelection\n        });\n      } else {\n        const startCell = getClosestCell$1(rng.startContainer, isRoot);\n        const endCell = getClosestCell$1(rng.endContainer, isRoot);\n        const startTableSelection = startCell.bind(getCellRangeFromStartTable(isRoot)).bind(getTableSelectionFromCellRng(isRoot));\n        const endTableSelection = endCell.bind(getCellRangeFromEndTable(isRoot)).bind(getTableSelectionFromCellRng(isRoot));\n        return Optional.some({\n          start: startTableSelection,\n          end: endTableSelection\n        });\n      }\n    };\n    const getCellIndex = (cells, cell) => findIndex$2(cells, x => eq(x, cell));\n    const getSelectedCells = tableSelection => lift2(getCellIndex(tableSelection.cells, tableSelection.rng.start), getCellIndex(tableSelection.cells, tableSelection.rng.end), (startIndex, endIndex) => tableSelection.cells.slice(startIndex, endIndex + 1));\n    const isSingleCellTableContentSelected = (optCellRng, rng, isRoot) => optCellRng.exists(cellRng => isSingleCellTable(cellRng, isRoot) && hasAllContentsSelected(cellRng.start, rng));\n    const unselectCells = (rng, selectionDetails) => {\n      const {startTable, endTable} = selectionDetails;\n      const otherContentRng = rng.cloneRange();\n      startTable.each(table => otherContentRng.setStartAfter(table.dom));\n      endTable.each(table => otherContentRng.setEndBefore(table.dom));\n      return otherContentRng;\n    };\n    const handleSingleTable = (cellRng, selectionDetails, rng, isRoot) => getTableSelections(cellRng, selectionDetails, rng, isRoot).bind(({start, end}) => start.or(end)).bind(tableSelection => {\n      const {isSameTable} = selectionDetails;\n      const selectedCells = getSelectedCells(tableSelection).getOr([]);\n      if (isSameTable && tableSelection.cells.length === selectedCells.length) {\n        return Optional.some(deleteAction.fullTable(tableSelection.table));\n      } else if (selectedCells.length > 0) {\n        if (isSameTable) {\n          return Optional.some(deleteAction.partialTable(selectedCells, Optional.none()));\n        } else {\n          const otherContentRng = unselectCells(rng, selectionDetails);\n          return Optional.some(deleteAction.partialTable(selectedCells, Optional.some({\n            ...selectionDetails,\n            rng: otherContentRng\n          })));\n        }\n      } else {\n        return Optional.none();\n      }\n    });\n    const handleMultiTable = (cellRng, selectionDetails, rng, isRoot) => getTableSelections(cellRng, selectionDetails, rng, isRoot).bind(({start, end}) => {\n      const startTableSelectedCells = start.bind(getSelectedCells).getOr([]);\n      const endTableSelectedCells = end.bind(getSelectedCells).getOr([]);\n      if (startTableSelectedCells.length > 0 && endTableSelectedCells.length > 0) {\n        const otherContentRng = unselectCells(rng, selectionDetails);\n        return Optional.some(deleteAction.multiTable(startTableSelectedCells, endTableSelectedCells, otherContentRng));\n      } else {\n        return Optional.none();\n      }\n    });\n    const getActionFromRange = (root, rng) => {\n      const isRoot = isRootFromElement(root);\n      const optCellRng = getCellRng(rng, isRoot);\n      const selectionDetails = getTableDetailsFromRange(rng, isRoot);\n      if (isSingleCellTableContentSelected(optCellRng, rng, isRoot)) {\n        return optCellRng.map(cellRng => deleteAction.singleCellTable(rng, cellRng.start));\n      } else if (selectionDetails.isMultiTable) {\n        return handleMultiTable(optCellRng, selectionDetails, rng, isRoot);\n      } else {\n        return handleSingleTable(optCellRng, selectionDetails, rng, isRoot);\n      }\n    };\n\n    const freefallRtl = root => {\n      const child = isComment$1(root) ? prevSibling(root) : lastChild(root);\n      return child.bind(freefallRtl).orThunk(() => Optional.some(root));\n    };\n    const cleanCells = cells => each$g(cells, cell => {\n      remove$a(cell, 'contenteditable');\n      fillWithPaddingBr(cell);\n    });\n    const getOutsideBlock = (editor, container) => Optional.from(editor.dom.getParent(container, editor.dom.isBlock)).map(SugarElement.fromDom);\n    const handleEmptyBlock = (editor, startInTable, emptyBlock) => {\n      emptyBlock.each(block => {\n        if (startInTable) {\n          remove$5(block);\n        } else {\n          fillWithPaddingBr(block);\n          editor.selection.setCursorLocation(block.dom, 0);\n        }\n      });\n    };\n    const deleteContentInsideCell = (editor, cell, rng, isFirstCellInSelection) => {\n      const insideTableRng = rng.cloneRange();\n      if (isFirstCellInSelection) {\n        insideTableRng.setStart(rng.startContainer, rng.startOffset);\n        insideTableRng.setEndAfter(cell.dom.lastChild);\n      } else {\n        insideTableRng.setStartBefore(cell.dom.firstChild);\n        insideTableRng.setEnd(rng.endContainer, rng.endOffset);\n      }\n      deleteCellContents(editor, insideTableRng, cell, false).each(action => action());\n    };\n    const collapseAndRestoreCellSelection = editor => {\n      const selectedCells = getCellsFromEditor(editor);\n      const selectedNode = SugarElement.fromDom(editor.selection.getNode());\n      if (isTableCell$5(selectedNode.dom) && isEmpty$2(selectedNode)) {\n        editor.selection.setCursorLocation(selectedNode.dom, 0);\n      } else {\n        editor.selection.collapse(true);\n      }\n      if (selectedCells.length > 1 && exists(selectedCells, cell => eq(cell, selectedNode))) {\n        set$2(selectedNode, 'data-mce-selected', '1');\n      }\n    };\n    const emptySingleTableCells = (editor, cells, outsideDetails) => Optional.some(() => {\n      const editorRng = editor.selection.getRng();\n      const cellsToClean = outsideDetails.bind(({rng, isStartInTable}) => {\n        const outsideBlock = getOutsideBlock(editor, isStartInTable ? rng.endContainer : rng.startContainer);\n        rng.deleteContents();\n        handleEmptyBlock(editor, isStartInTable, outsideBlock.filter(isEmpty$2));\n        const endPointCell = isStartInTable ? cells[0] : cells[cells.length - 1];\n        deleteContentInsideCell(editor, endPointCell, editorRng, isStartInTable);\n        if (!isEmpty$2(endPointCell)) {\n          return Optional.some(isStartInTable ? cells.slice(1) : cells.slice(0, -1));\n        } else {\n          return Optional.none();\n        }\n      }).getOr(cells);\n      cleanCells(cellsToClean);\n      collapseAndRestoreCellSelection(editor);\n    });\n    const emptyMultiTableCells = (editor, startTableCells, endTableCells, betweenRng) => Optional.some(() => {\n      const rng = editor.selection.getRng();\n      const startCell = startTableCells[0];\n      const endCell = endTableCells[endTableCells.length - 1];\n      deleteContentInsideCell(editor, startCell, rng, true);\n      deleteContentInsideCell(editor, endCell, rng, false);\n      const startTableCellsToClean = isEmpty$2(startCell) ? startTableCells : startTableCells.slice(1);\n      const endTableCellsToClean = isEmpty$2(endCell) ? endTableCells : endTableCells.slice(0, -1);\n      cleanCells(startTableCellsToClean.concat(endTableCellsToClean));\n      betweenRng.deleteContents();\n      collapseAndRestoreCellSelection(editor);\n    });\n    const deleteCellContents = (editor, rng, cell, moveSelection = true) => Optional.some(() => {\n      rng.deleteContents();\n      const lastNode = freefallRtl(cell).getOr(cell);\n      const lastBlock = SugarElement.fromDom(editor.dom.getParent(lastNode.dom, editor.dom.isBlock));\n      if (isEmpty$2(lastBlock)) {\n        fillWithPaddingBr(lastBlock);\n        if (moveSelection) {\n          editor.selection.setCursorLocation(lastBlock.dom, 0);\n        }\n      }\n      if (!eq(cell, lastBlock)) {\n        const additionalCleanupNodes = is$2(parent(lastBlock), cell) ? [] : siblings(lastBlock);\n        each$g(additionalCleanupNodes.concat(children(cell)), node => {\n          if (!eq(node, lastBlock) && !contains(node, lastBlock) && isEmpty$2(node)) {\n            remove$5(node);\n          }\n        });\n      }\n    });\n    const deleteTableElement = (editor, table) => Optional.some(() => deleteElement$2(editor, false, table));\n    const deleteCellRange = (editor, rootElm, rng) => getActionFromRange(rootElm, rng).bind(action => action.fold(curry(deleteCellContents, editor), curry(deleteTableElement, editor), curry(emptySingleTableCells, editor), curry(emptyMultiTableCells, editor)));\n    const deleteCaptionRange = (editor, caption) => emptyElement(editor, caption);\n    const deleteTableRange = (editor, rootElm, rng, startElm) => getParentCaption(rootElm, startElm).fold(() => deleteCellRange(editor, rootElm, rng), caption => deleteCaptionRange(editor, caption));\n    const deleteRange$2 = (editor, startElm, selectedCells) => {\n      const rootNode = SugarElement.fromDom(editor.getBody());\n      const rng = editor.selection.getRng();\n      return selectedCells.length !== 0 ? emptySingleTableCells(editor, selectedCells, Optional.none()) : deleteTableRange(editor, rootNode, rng, startElm);\n    };\n    const getParentCell = (rootElm, elm) => find$2(parentsAndSelf(elm, rootElm), isTableCell$4);\n    const getParentCaption = (rootElm, elm) => find$2(parentsAndSelf(elm, rootElm), isTag('caption'));\n    const deleteBetweenCells = (editor, rootElm, forward, fromCell, from) => navigate(forward, editor.getBody(), from).bind(to => getParentCell(rootElm, SugarElement.fromDom(to.getNode())).bind(toCell => eq(toCell, fromCell) ? Optional.none() : Optional.some(noop)));\n    const emptyElement = (editor, elm) => Optional.some(() => {\n      fillWithPaddingBr(elm);\n      editor.selection.setCursorLocation(elm.dom, 0);\n    });\n    const isDeleteOfLastCharPos = (fromCaption, forward, from, to) => firstPositionIn(fromCaption.dom).bind(first => lastPositionIn(fromCaption.dom).map(last => forward ? from.isEqual(first) && to.isEqual(last) : from.isEqual(last) && to.isEqual(first))).getOr(true);\n    const emptyCaretCaption = (editor, elm) => emptyElement(editor, elm);\n    const validateCaretCaption = (rootElm, fromCaption, to) => getParentCaption(rootElm, SugarElement.fromDom(to.getNode())).fold(() => Optional.some(noop), toCaption => someIf(!eq(toCaption, fromCaption), noop));\n    const deleteCaretInsideCaption = (editor, rootElm, forward, fromCaption, from) => navigate(forward, editor.getBody(), from).fold(() => Optional.some(noop), to => isDeleteOfLastCharPos(fromCaption, forward, from, to) ? emptyCaretCaption(editor, fromCaption) : validateCaretCaption(rootElm, fromCaption, to));\n    const deleteCaretCells = (editor, forward, rootElm, startElm) => {\n      const from = CaretPosition.fromRangeStart(editor.selection.getRng());\n      return getParentCell(rootElm, startElm).bind(fromCell => isEmpty$2(fromCell) ? emptyElement(editor, fromCell) : deleteBetweenCells(editor, rootElm, forward, fromCell, from));\n    };\n    const deleteCaretCaption = (editor, forward, rootElm, fromCaption) => {\n      const from = CaretPosition.fromRangeStart(editor.selection.getRng());\n      return isEmpty$2(fromCaption) ? emptyElement(editor, fromCaption) : deleteCaretInsideCaption(editor, rootElm, forward, fromCaption, from);\n    };\n    const isNearTable = (forward, pos) => forward ? isBeforeTable(pos) : isAfterTable(pos);\n    const isBeforeOrAfterTable = (editor, forward) => {\n      const fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());\n      return isNearTable(forward, fromPos) || fromPosition(forward, editor.getBody(), fromPos).exists(pos => isNearTable(forward, pos));\n    };\n    const deleteCaret$3 = (editor, forward, startElm) => {\n      const rootElm = SugarElement.fromDom(editor.getBody());\n      return getParentCaption(rootElm, startElm).fold(() => deleteCaretCells(editor, forward, rootElm, startElm).orThunk(() => someIf(isBeforeOrAfterTable(editor, forward), noop)), fromCaption => deleteCaretCaption(editor, forward, rootElm, fromCaption));\n    };\n    const backspaceDelete$9 = (editor, forward) => {\n      const startElm = SugarElement.fromDom(editor.selection.getStart(true));\n      const cells = getCellsFromEditor(editor);\n      return editor.selection.isCollapsed() && cells.length === 0 ? deleteCaret$3(editor, forward, startElm) : deleteRange$2(editor, startElm, cells);\n    };\n\n    const getContentEditableRoot$1 = (root, node) => {\n      while (node && node !== root) {\n        if (isContentEditableTrue$4(node) || isContentEditableFalse$a(node)) {\n          return node;\n        }\n        node = node.parentNode;\n      }\n      return null;\n    };\n\n    const traverse = (node, fn) => {\n      fn(node);\n      if (node.firstChild) {\n        traverse(node.firstChild, fn);\n      }\n      if (node.next) {\n        traverse(node.next, fn);\n      }\n    };\n    const matchNode$1 = (nodeFilters, attributeFilters, node, matches) => {\n      const name = node.name;\n      for (let ni = 0, nl = nodeFilters.length; ni < nl; ni++) {\n        const filter = nodeFilters[ni];\n        if (filter.name === name) {\n          const match = matches.nodes[name];\n          if (match) {\n            match.nodes.push(node);\n          } else {\n            matches.nodes[name] = {\n              filter,\n              nodes: [node]\n            };\n          }\n        }\n      }\n      if (node.attributes) {\n        for (let ai = 0, al = attributeFilters.length; ai < al; ai++) {\n          const filter = attributeFilters[ai];\n          const attrName = filter.name;\n          if (attrName in node.attributes.map) {\n            const match = matches.attributes[attrName];\n            if (match) {\n              match.nodes.push(node);\n            } else {\n              matches.attributes[attrName] = {\n                filter,\n                nodes: [node]\n              };\n            }\n          }\n        }\n      }\n    };\n    const findMatchingNodes = (nodeFilters, attributeFilters, node) => {\n      const matches = {\n        nodes: {},\n        attributes: {}\n      };\n      if (node.firstChild) {\n        traverse(node.firstChild, node => {\n          matchNode$1(nodeFilters, attributeFilters, node, matches);\n        });\n      }\n      return matches;\n    };\n    const runFilters = (matches, args) => {\n      const run = matchRecord => {\n        each$f(matchRecord, match => {\n          const nodes = filter$6(match.nodes, node => isNonNullable(node.parent));\n          each$g(match.filter.callbacks, callback => {\n            callback(nodes, match.filter.name, args);\n          });\n        });\n      };\n      run(matches.nodes);\n      run(matches.attributes);\n    };\n    const filter$3 = (nodeFilters, attributeFilters, node, args = {}) => {\n      const matches = findMatchingNodes(nodeFilters, attributeFilters, node);\n      runFilters(matches, args);\n    };\n\n    const paddEmptyNode = (settings, args, blockElements, node) => {\n      if (args.insert && blockElements[node.name]) {\n        node.empty().append(new AstNode('br', 1));\n      } else {\n        node.empty().append(new AstNode('#text', 3)).value = nbsp;\n      }\n    };\n    const isPaddedWithNbsp = node => hasOnlyChild(node, '#text') && node.firstChild.value === nbsp;\n    const hasOnlyChild = (node, name) => node && node.firstChild && node.firstChild === node.lastChild && node.firstChild.name === name;\n    const isPadded = (schema, node) => {\n      const rule = schema.getElementRule(node.name);\n      return rule && rule.paddEmpty;\n    };\n    const isEmpty = (schema, nonEmptyElements, whitespaceElements, node) => node.isEmpty(nonEmptyElements, whitespaceElements, node => isPadded(schema, node));\n    const isLineBreakNode = (node, blockElements) => node && (node.name in blockElements || node.name === 'br');\n\n    const removeOrUnwrapInvalidNode = (node, schema, originalNodeParent = node.parent) => {\n      if (schema.getSpecialElements()[node.name]) {\n        node.empty().remove();\n      } else {\n        const children = node.children();\n        for (const childNode of children) {\n          if (!schema.isValidChild(originalNodeParent.name, childNode.name)) {\n            removeOrUnwrapInvalidNode(childNode, schema, originalNodeParent);\n          }\n        }\n        node.unwrap();\n      }\n    };\n    const cleanInvalidNodes = (nodes, schema, onCreate = noop) => {\n      const textBlockElements = schema.getTextBlockElements();\n      const nonEmptyElements = schema.getNonEmptyElements();\n      const whitespaceElements = schema.getWhitespaceElements();\n      const nonSplittableElements = Tools.makeMap('tr,td,th,tbody,thead,tfoot,table');\n      const fixed = new Set();\n      for (let ni = 0; ni < nodes.length; ni++) {\n        const node = nodes[ni];\n        let parent;\n        let newParent;\n        let tempNode;\n        if (!node.parent || fixed.has(node)) {\n          continue;\n        }\n        if (textBlockElements[node.name] && node.parent.name === 'li') {\n          let sibling = node.next;\n          while (sibling) {\n            if (textBlockElements[sibling.name]) {\n              sibling.name = 'li';\n              fixed.add(sibling);\n              node.parent.insert(sibling, node.parent);\n            } else {\n              break;\n            }\n            sibling = sibling.next;\n          }\n          node.unwrap();\n          continue;\n        }\n        const parents = [node];\n        for (parent = node.parent; parent && !schema.isValidChild(parent.name, node.name) && !nonSplittableElements[parent.name]; parent = parent.parent) {\n          parents.push(parent);\n        }\n        if (parent && parents.length > 1) {\n          if (schema.isValidChild(parent.name, node.name)) {\n            parents.reverse();\n            newParent = parents[0].clone();\n            onCreate(newParent);\n            let currentNode = newParent;\n            for (let i = 0; i < parents.length - 1; i++) {\n              if (schema.isValidChild(currentNode.name, parents[i].name)) {\n                tempNode = parents[i].clone();\n                onCreate(tempNode);\n                currentNode.append(tempNode);\n              } else {\n                tempNode = currentNode;\n              }\n              for (let childNode = parents[i].firstChild; childNode && childNode !== parents[i + 1];) {\n                const nextNode = childNode.next;\n                tempNode.append(childNode);\n                childNode = nextNode;\n              }\n              currentNode = tempNode;\n            }\n            if (!isEmpty(schema, nonEmptyElements, whitespaceElements, newParent)) {\n              parent.insert(newParent, parents[0], true);\n              parent.insert(node, newParent);\n            } else {\n              parent.insert(node, parents[0], true);\n            }\n            parent = parents[0];\n            if (isEmpty(schema, nonEmptyElements, whitespaceElements, parent) || hasOnlyChild(parent, 'br')) {\n              parent.empty().remove();\n            }\n          } else {\n            removeOrUnwrapInvalidNode(node, schema);\n          }\n        } else if (node.parent) {\n          if (node.name === 'li') {\n            let sibling = node.prev;\n            if (sibling && (sibling.name === 'ul' || sibling.name === 'ol')) {\n              sibling.append(node);\n              continue;\n            }\n            sibling = node.next;\n            if (sibling && (sibling.name === 'ul' || sibling.name === 'ol')) {\n              sibling.insert(node, sibling.firstChild, true);\n              continue;\n            }\n            const wrapper = new AstNode('ul', 1);\n            onCreate(wrapper);\n            node.wrap(wrapper);\n            continue;\n          }\n          if (schema.isValidChild(node.parent.name, 'div') && schema.isValidChild('div', node.name)) {\n            const wrapper = new AstNode('div', 1);\n            onCreate(wrapper);\n            node.wrap(wrapper);\n          } else {\n            removeOrUnwrapInvalidNode(node, schema);\n          }\n        }\n      }\n    };\n\n    const createRange = (sc, so, ec, eo) => {\n      const rng = document.createRange();\n      rng.setStart(sc, so);\n      rng.setEnd(ec, eo);\n      return rng;\n    };\n    const normalizeBlockSelectionRange = rng => {\n      const startPos = CaretPosition.fromRangeStart(rng);\n      const endPos = CaretPosition.fromRangeEnd(rng);\n      const rootNode = rng.commonAncestorContainer;\n      return fromPosition(false, rootNode, endPos).map(newEndPos => {\n        if (!isInSameBlock(startPos, endPos, rootNode) && isInSameBlock(startPos, newEndPos, rootNode)) {\n          return createRange(startPos.container(), startPos.offset(), newEndPos.container(), newEndPos.offset());\n        } else {\n          return rng;\n        }\n      }).getOr(rng);\n    };\n    const normalize = rng => rng.collapsed ? rng : normalizeBlockSelectionRange(rng);\n\n    const hasOnlyOneChild$1 = node => {\n      return node.firstChild && node.firstChild === node.lastChild;\n    };\n    const isPaddingNode = node => {\n      return node.name === 'br' || node.value === nbsp;\n    };\n    const isPaddedEmptyBlock = (schema, node) => {\n      const blockElements = schema.getBlockElements();\n      return blockElements[node.name] && hasOnlyOneChild$1(node) && isPaddingNode(node.firstChild);\n    };\n    const isEmptyFragmentElement = (schema, node) => {\n      const nonEmptyElements = schema.getNonEmptyElements();\n      return node && (node.isEmpty(nonEmptyElements) || isPaddedEmptyBlock(schema, node));\n    };\n    const isListFragment = (schema, fragment) => {\n      let firstChild = fragment.firstChild;\n      let lastChild = fragment.lastChild;\n      if (firstChild && firstChild.name === 'meta') {\n        firstChild = firstChild.next;\n      }\n      if (lastChild && lastChild.attr('id') === 'mce_marker') {\n        lastChild = lastChild.prev;\n      }\n      if (isEmptyFragmentElement(schema, lastChild)) {\n        lastChild = lastChild.prev;\n      }\n      if (!firstChild || firstChild !== lastChild) {\n        return false;\n      }\n      return firstChild.name === 'ul' || firstChild.name === 'ol';\n    };\n    const cleanupDomFragment = domFragment => {\n      const firstChild = domFragment.firstChild;\n      const lastChild = domFragment.lastChild;\n      if (firstChild && firstChild.nodeName === 'META') {\n        firstChild.parentNode.removeChild(firstChild);\n      }\n      if (lastChild && lastChild.id === 'mce_marker') {\n        lastChild.parentNode.removeChild(lastChild);\n      }\n      return domFragment;\n    };\n    const toDomFragment = (dom, serializer, fragment) => {\n      const html = serializer.serialize(fragment);\n      const domFragment = dom.createFragment(html);\n      return cleanupDomFragment(domFragment);\n    };\n    const listItems = elm => {\n      return filter$6(elm.childNodes, child => {\n        return child.nodeName === 'LI';\n      });\n    };\n    const isPadding = node => {\n      return node.data === nbsp || isBr$5(node);\n    };\n    const isListItemPadded = node => {\n      return node && node.firstChild && node.firstChild === node.lastChild && isPadding(node.firstChild);\n    };\n    const isEmptyOrPadded = elm => {\n      return !elm.firstChild || isListItemPadded(elm);\n    };\n    const trimListItems = elms => {\n      return elms.length > 0 && isEmptyOrPadded(elms[elms.length - 1]) ? elms.slice(0, -1) : elms;\n    };\n    const getParentLi = (dom, node) => {\n      const parentBlock = dom.getParent(node, dom.isBlock);\n      return parentBlock && parentBlock.nodeName === 'LI' ? parentBlock : null;\n    };\n    const isParentBlockLi = (dom, node) => {\n      return !!getParentLi(dom, node);\n    };\n    const getSplit = (parentNode, rng) => {\n      const beforeRng = rng.cloneRange();\n      const afterRng = rng.cloneRange();\n      beforeRng.setStartBefore(parentNode);\n      afterRng.setEndAfter(parentNode);\n      return [\n        beforeRng.cloneContents(),\n        afterRng.cloneContents()\n      ];\n    };\n    const findFirstIn = (node, rootNode) => {\n      const caretPos = CaretPosition.before(node);\n      const caretWalker = CaretWalker(rootNode);\n      const newCaretPos = caretWalker.next(caretPos);\n      return newCaretPos ? newCaretPos.toRange() : null;\n    };\n    const findLastOf = (node, rootNode) => {\n      const caretPos = CaretPosition.after(node);\n      const caretWalker = CaretWalker(rootNode);\n      const newCaretPos = caretWalker.prev(caretPos);\n      return newCaretPos ? newCaretPos.toRange() : null;\n    };\n    const insertMiddle = (target, elms, rootNode, rng) => {\n      const parts = getSplit(target, rng);\n      const parentElm = target.parentNode;\n      parentElm.insertBefore(parts[0], target);\n      Tools.each(elms, li => {\n        parentElm.insertBefore(li, target);\n      });\n      parentElm.insertBefore(parts[1], target);\n      parentElm.removeChild(target);\n      return findLastOf(elms[elms.length - 1], rootNode);\n    };\n    const insertBefore$1 = (target, elms, rootNode) => {\n      const parentElm = target.parentNode;\n      Tools.each(elms, elm => {\n        parentElm.insertBefore(elm, target);\n      });\n      return findFirstIn(target, rootNode);\n    };\n    const insertAfter$1 = (target, elms, rootNode, dom) => {\n      dom.insertAfter(elms.reverse(), target);\n      return findLastOf(elms[0], rootNode);\n    };\n    const insertAtCaret$1 = (serializer, dom, rng, fragment) => {\n      const domFragment = toDomFragment(dom, serializer, fragment);\n      const liTarget = getParentLi(dom, rng.startContainer);\n      const liElms = trimListItems(listItems(domFragment.firstChild));\n      const BEGINNING = 1, END = 2;\n      const rootNode = dom.getRoot();\n      const isAt = location => {\n        const caretPos = CaretPosition.fromRangeStart(rng);\n        const caretWalker = CaretWalker(dom.getRoot());\n        const newPos = location === BEGINNING ? caretWalker.prev(caretPos) : caretWalker.next(caretPos);\n        return newPos ? getParentLi(dom, newPos.getNode()) !== liTarget : true;\n      };\n      if (isAt(BEGINNING)) {\n        return insertBefore$1(liTarget, liElms, rootNode);\n      } else if (isAt(END)) {\n        return insertAfter$1(liTarget, liElms, rootNode, dom);\n      }\n      return insertMiddle(liTarget, liElms, rootNode, rng);\n    };\n\n    const isTableCell$1 = isTableCell$5;\n    const isTableCellContentSelected = (dom, rng, cell) => {\n      if (cell !== null) {\n        const endCell = dom.getParent(rng.endContainer, isTableCell$1);\n        return cell === endCell && hasAllContentsSelected(SugarElement.fromDom(cell), rng);\n      } else {\n        return false;\n      }\n    };\n    const validInsertion = (editor, value, parentNode) => {\n      if (parentNode.getAttribute('data-mce-bogus') === 'all') {\n        parentNode.parentNode.insertBefore(editor.dom.createFragment(value), parentNode);\n      } else {\n        const node = parentNode.firstChild;\n        const node2 = parentNode.lastChild;\n        if (!node || node === node2 && node.nodeName === 'BR') {\n          editor.dom.setHTML(parentNode, value);\n        } else {\n          editor.selection.setContent(value, { no_events: true });\n        }\n      }\n    };\n    const trimBrsFromTableCell = (dom, elm) => {\n      Optional.from(dom.getParent(elm, 'td,th')).map(SugarElement.fromDom).each(trimBlockTrailingBr);\n    };\n    const reduceInlineTextElements = (editor, merge) => {\n      const textInlineElements = editor.schema.getTextInlineElements();\n      const dom = editor.dom;\n      if (merge) {\n        const root = editor.getBody();\n        const elementUtils = ElementUtils(dom);\n        Tools.each(dom.select('*[data-mce-fragment]'), node => {\n          const isInline = isNonNullable(textInlineElements[node.nodeName.toLowerCase()]);\n          if (isInline && hasInheritableStyles(dom, node)) {\n            for (let parentNode = node.parentNode; isNonNullable(parentNode) && parentNode !== root; parentNode = parentNode.parentNode) {\n              const styleConflict = hasStyleConflict(dom, node, parentNode);\n              if (styleConflict) {\n                break;\n              }\n              if (elementUtils.compare(parentNode, node)) {\n                dom.remove(node, true);\n                break;\n              }\n            }\n          }\n        });\n      }\n    };\n    const markFragmentElements = fragment => {\n      let node = fragment;\n      while (node = node.walk()) {\n        if (node.type === 1) {\n          node.attr('data-mce-fragment', '1');\n        }\n      }\n    };\n    const unmarkFragmentElements = elm => {\n      Tools.each(elm.getElementsByTagName('*'), elm => {\n        elm.removeAttribute('data-mce-fragment');\n      });\n    };\n    const isPartOfFragment = node => {\n      return !!node.getAttribute('data-mce-fragment');\n    };\n    const canHaveChildren = (editor, node) => {\n      return node && !editor.schema.getVoidElements()[node.nodeName];\n    };\n    const moveSelectionToMarker = (editor, marker) => {\n      let nextRng;\n      const dom = editor.dom;\n      const selection = editor.selection;\n      if (!marker) {\n        return;\n      }\n      selection.scrollIntoView(marker);\n      const parentEditableElm = getContentEditableRoot$1(editor.getBody(), marker);\n      if (dom.getContentEditable(parentEditableElm) === 'false') {\n        dom.remove(marker);\n        selection.select(parentEditableElm);\n        return;\n      }\n      let rng = dom.createRng();\n      const node = marker.previousSibling;\n      if (isText$8(node)) {\n        rng.setStart(node, node.nodeValue.length);\n        const node2 = marker.nextSibling;\n        if (isText$8(node2)) {\n          node.appendData(node2.data);\n          node2.parentNode.removeChild(node2);\n        }\n      } else {\n        rng.setStartBefore(marker);\n        rng.setEndBefore(marker);\n      }\n      const findNextCaretRng = rng => {\n        let caretPos = CaretPosition.fromRangeStart(rng);\n        const caretWalker = CaretWalker(editor.getBody());\n        caretPos = caretWalker.next(caretPos);\n        if (caretPos) {\n          return caretPos.toRange();\n        }\n      };\n      const parentBlock = dom.getParent(marker, dom.isBlock);\n      dom.remove(marker);\n      if (parentBlock && dom.isEmpty(parentBlock)) {\n        empty(SugarElement.fromDom(parentBlock));\n        rng.setStart(parentBlock, 0);\n        rng.setEnd(parentBlock, 0);\n        if (!isTableCell$1(parentBlock) && !isPartOfFragment(parentBlock) && (nextRng = findNextCaretRng(rng))) {\n          rng = nextRng;\n          dom.remove(parentBlock);\n        } else {\n          dom.add(parentBlock, dom.create('br', { 'data-mce-bogus': '1' }));\n        }\n      }\n      selection.setRng(rng);\n    };\n    const deleteSelectedContent = editor => {\n      const dom = editor.dom;\n      const rng = normalize(editor.selection.getRng());\n      editor.selection.setRng(rng);\n      const startCell = dom.getParent(rng.startContainer, isTableCell$1);\n      if (isTableCellContentSelected(dom, rng, startCell)) {\n        deleteCellContents(editor, rng, SugarElement.fromDom(startCell));\n      } else {\n        editor.getDoc().execCommand('Delete', false, null);\n      }\n    };\n    const insertHtmlAtCaret = (editor, value, details) => {\n      let parentNode;\n      let rng, node;\n      const selection = editor.selection;\n      const dom = editor.dom;\n      const parser = editor.parser;\n      const merge = details.merge;\n      const serializer = HtmlSerializer({ validate: true }, editor.schema);\n      const bookmarkHtml = '<span id=\"mce_marker\" data-mce-type=\"bookmark\">&#xFEFF;</span>';\n      if (value.indexOf('{$caret}') === -1) {\n        value += '{$caret}';\n      }\n      value = value.replace(/\\{\\$caret\\}/, bookmarkHtml);\n      rng = selection.getRng();\n      const caretElement = rng.startContainer || (rng.parentElement ? rng.parentElement() : null);\n      const body = editor.getBody();\n      if (caretElement === body && selection.isCollapsed()) {\n        if (dom.isBlock(body.firstChild) && canHaveChildren(editor, body.firstChild) && dom.isEmpty(body.firstChild)) {\n          rng = dom.createRng();\n          rng.setStart(body.firstChild, 0);\n          rng.setEnd(body.firstChild, 0);\n          selection.setRng(rng);\n        }\n      }\n      if (!selection.isCollapsed()) {\n        deleteSelectedContent(editor);\n      }\n      parentNode = selection.getNode();\n      const parserArgs = {\n        context: parentNode.nodeName.toLowerCase(),\n        data: details.data,\n        insert: true\n      };\n      const fragment = parser.parse(value, parserArgs);\n      if (details.paste === true && isListFragment(editor.schema, fragment) && isParentBlockLi(dom, parentNode)) {\n        rng = insertAtCaret$1(serializer, dom, selection.getRng(), fragment);\n        selection.setRng(rng);\n        return value;\n      }\n      markFragmentElements(fragment);\n      node = fragment.lastChild;\n      if (node.attr('id') === 'mce_marker') {\n        const marker = node;\n        for (node = node.prev; node; node = node.walk(true)) {\n          if (node.type === 3 || !dom.isBlock(node.name)) {\n            if (editor.schema.isValidChild(node.parent.name, 'span')) {\n              node.parent.insert(marker, node, node.name === 'br');\n            }\n            break;\n          }\n        }\n      }\n      editor._selectionOverrides.showBlockCaretContainer(parentNode);\n      if (!parserArgs.invalid) {\n        value = serializer.serialize(fragment);\n        validInsertion(editor, value, parentNode);\n      } else {\n        editor.selection.setContent(bookmarkHtml);\n        parentNode = selection.getNode();\n        const rootNode = editor.getBody();\n        if (parentNode.nodeType === 9) {\n          parentNode = node = rootNode;\n        } else {\n          node = parentNode;\n        }\n        while (node !== rootNode) {\n          parentNode = node;\n          node = node.parentNode;\n        }\n        value = parentNode === rootNode ? rootNode.innerHTML : dom.getOuterHTML(parentNode);\n        const root = parser.parse(value);\n        for (let markerNode = root; markerNode; markerNode = markerNode.walk()) {\n          if (markerNode.attr('id') === 'mce_marker') {\n            markerNode.replace(fragment);\n            break;\n          }\n        }\n        const toExtract = fragment.children();\n        const parent = fragment.parent.name;\n        fragment.unwrap();\n        const invalidChildren = filter$6(toExtract, node => !editor.schema.isValidChild(parent, node.name));\n        cleanInvalidNodes(invalidChildren, editor.schema);\n        filter$3(parser.getNodeFilters(), parser.getAttributeFilters(), root);\n        value = serializer.serialize(root);\n        if (parentNode === rootNode) {\n          dom.setHTML(rootNode, value);\n        } else {\n          dom.setOuterHTML(parentNode, value);\n        }\n      }\n      reduceInlineTextElements(editor, merge);\n      moveSelectionToMarker(editor, dom.get('mce_marker'));\n      unmarkFragmentElements(editor.getBody());\n      trimBrsFromTableCell(dom, selection.getStart());\n      return value;\n    };\n\n    const isTreeNode = content => content instanceof AstNode;\n\n    const moveSelection = editor => {\n      if (hasFocus(editor)) {\n        firstPositionIn(editor.getBody()).each(pos => {\n          const node = pos.getNode();\n          const caretPos = isTable$3(node) ? firstPositionIn(node).getOr(pos) : pos;\n          editor.selection.setRng(caretPos.toRange());\n        });\n      }\n    };\n    const setEditorHtml = (editor, html, noSelection) => {\n      editor.dom.setHTML(editor.getBody(), html);\n      if (noSelection !== true) {\n        moveSelection(editor);\n      }\n    };\n    const setContentString = (editor, body, content, args) => {\n      if (content.length === 0 || /^\\s+$/.test(content)) {\n        const padd = '<br data-mce-bogus=\"1\">';\n        if (body.nodeName === 'TABLE') {\n          content = '<tr><td>' + padd + '</td></tr>';\n        } else if (/^(UL|OL)$/.test(body.nodeName)) {\n          content = '<li>' + padd + '</li>';\n        }\n        const forcedRootBlockName = getForcedRootBlock(editor);\n        if (editor.schema.isValidChild(body.nodeName.toLowerCase(), forcedRootBlockName.toLowerCase())) {\n          content = padd;\n          content = editor.dom.createHTML(forcedRootBlockName, getForcedRootBlockAttrs(editor), content);\n        } else if (!content) {\n          content = padd;\n        }\n        setEditorHtml(editor, content, args.no_selection);\n        return {\n          content,\n          html: content\n        };\n      } else {\n        if (args.format !== 'raw') {\n          content = HtmlSerializer({ validate: false }, editor.schema).serialize(editor.parser.parse(content, {\n            isRootContent: true,\n            insert: true\n          }));\n        }\n        const trimmedHtml = isWsPreserveElement(SugarElement.fromDom(body)) ? content : Tools.trim(content);\n        setEditorHtml(editor, trimmedHtml, args.no_selection);\n        return {\n          content: trimmedHtml,\n          html: trimmedHtml\n        };\n      }\n    };\n    const setContentTree = (editor, body, content, args) => {\n      filter$3(editor.parser.getNodeFilters(), editor.parser.getAttributeFilters(), content);\n      const html = HtmlSerializer({ validate: false }, editor.schema).serialize(content);\n      const trimmedHtml = isWsPreserveElement(SugarElement.fromDom(body)) ? html : Tools.trim(html);\n      setEditorHtml(editor, trimmedHtml, args.no_selection);\n      return {\n        content,\n        html: trimmedHtml\n      };\n    };\n    const setContentInternal = (editor, content, args) => {\n      return Optional.from(editor.getBody()).map(body => {\n        if (isTreeNode(content)) {\n          return setContentTree(editor, body, content, args);\n        } else {\n          return setContentString(editor, body, content, args);\n        }\n      }).getOr({\n        content,\n        html: isTreeNode(args.content) ? '' : args.content\n      });\n    };\n\n    const sibling = (scope, predicate) => sibling$1(scope, predicate).isSome();\n\n    const ensureIsRoot = isRoot => isFunction(isRoot) ? isRoot : never;\n    const ancestor = (scope, transform, isRoot) => {\n      let element = scope.dom;\n      const stop = ensureIsRoot(isRoot);\n      while (element.parentNode) {\n        element = element.parentNode;\n        const el = SugarElement.fromDom(element);\n        const transformed = transform(el);\n        if (transformed.isSome()) {\n          return transformed;\n        } else if (stop(el)) {\n          break;\n        }\n      }\n      return Optional.none();\n    };\n    const closest$2 = (scope, transform, isRoot) => {\n      const current = transform(scope);\n      const stop = ensureIsRoot(isRoot);\n      return current.orThunk(() => stop(scope) ? Optional.none() : ancestor(scope, transform, stop));\n    };\n\n    const isEq$3 = isEq$5;\n    const matchesUnInheritedFormatSelector = (ed, node, name) => {\n      const formatList = ed.formatter.get(name);\n      if (formatList) {\n        for (let i = 0; i < formatList.length; i++) {\n          const format = formatList[i];\n          if (isSelectorFormat(format) && format.inherit === false && ed.dom.is(node, format.selector)) {\n            return true;\n          }\n        }\n      }\n      return false;\n    };\n    const matchParents = (editor, node, name, vars, similar) => {\n      const root = editor.dom.getRoot();\n      if (node === root) {\n        return false;\n      }\n      node = editor.dom.getParent(node, node => {\n        if (matchesUnInheritedFormatSelector(editor, node, name)) {\n          return true;\n        }\n        return node.parentNode === root || !!matchNode(editor, node, name, vars, true);\n      });\n      return !!matchNode(editor, node, name, vars, similar);\n    };\n    const matchName = (dom, node, format) => {\n      if (isInlineFormat(format) && isEq$3(node, format.inline)) {\n        return true;\n      }\n      if (isBlockFormat(format) && isEq$3(node, format.block)) {\n        return true;\n      }\n      if (isSelectorFormat(format)) {\n        return isElement$6(node) && dom.is(node, format.selector);\n      }\n      return false;\n    };\n    const matchItems = (dom, node, format, itemName, similar, vars) => {\n      const items = format[itemName];\n      if (isFunction(format.onmatch)) {\n        return format.onmatch(node, format, itemName);\n      }\n      if (items) {\n        if (isUndefined(items.length)) {\n          for (const key in items) {\n            if (has$2(items, key)) {\n              const value = itemName === 'attributes' ? dom.getAttrib(node, key) : getStyle(dom, node, key);\n              const expectedValue = replaceVars(items[key], vars);\n              const isEmptyValue = isNullable(value) || isEmpty$3(value);\n              if (isEmptyValue && isNullable(expectedValue)) {\n                continue;\n              }\n              if (similar && isEmptyValue && !format.exact) {\n                return false;\n              }\n              if ((!similar || format.exact) && !isEq$3(value, normalizeStyleValue(expectedValue, key))) {\n                return false;\n              }\n            }\n          }\n        } else {\n          for (let i = 0; i < items.length; i++) {\n            if (itemName === 'attributes' ? dom.getAttrib(node, items[i]) : getStyle(dom, node, items[i])) {\n              return true;\n            }\n          }\n        }\n      }\n      return true;\n    };\n    const matchNode = (ed, node, name, vars, similar) => {\n      const formatList = ed.formatter.get(name);\n      const dom = ed.dom;\n      if (formatList && node) {\n        for (let i = 0; i < formatList.length; i++) {\n          const format = formatList[i];\n          if (matchName(ed.dom, node, format) && matchItems(dom, node, format, 'attributes', similar, vars) && matchItems(dom, node, format, 'styles', similar, vars)) {\n            const classes = format.classes;\n            if (classes) {\n              for (let x = 0; x < classes.length; x++) {\n                if (!ed.dom.hasClass(node, replaceVars(classes[x], vars))) {\n                  return;\n                }\n              }\n            }\n            return format;\n          }\n        }\n      }\n    };\n    const match$2 = (editor, name, vars, node, similar) => {\n      if (node) {\n        return matchParents(editor, node, name, vars, similar);\n      }\n      node = editor.selection.getNode();\n      if (matchParents(editor, node, name, vars, similar)) {\n        return true;\n      }\n      const startNode = editor.selection.getStart();\n      if (startNode !== node) {\n        if (matchParents(editor, startNode, name, vars, similar)) {\n          return true;\n        }\n      }\n      return false;\n    };\n    const matchAll = (editor, names, vars) => {\n      const matchedFormatNames = [];\n      const checkedMap = {};\n      const startElement = editor.selection.getStart();\n      editor.dom.getParent(startElement, node => {\n        for (let i = 0; i < names.length; i++) {\n          const name = names[i];\n          if (!checkedMap[name] && matchNode(editor, node, name, vars)) {\n            checkedMap[name] = true;\n            matchedFormatNames.push(name);\n          }\n        }\n      }, editor.dom.getRoot());\n      return matchedFormatNames;\n    };\n    const closest$1 = (editor, names) => {\n      const isRoot = elm => eq(elm, SugarElement.fromDom(editor.getBody()));\n      const match = (elm, name) => matchNode(editor, elm.dom, name) ? Optional.some(name) : Optional.none();\n      return Optional.from(editor.selection.getStart(true)).bind(rawElm => closest$2(SugarElement.fromDom(rawElm), elm => findMap(names, name => match(elm, name)), isRoot)).getOrNull();\n    };\n    const canApply = (editor, name) => {\n      const formatList = editor.formatter.get(name);\n      const dom = editor.dom;\n      if (formatList) {\n        const startNode = editor.selection.getStart();\n        const parents = getParents$2(dom, startNode);\n        for (let x = formatList.length - 1; x >= 0; x--) {\n          const format = formatList[x];\n          if (!isSelectorFormat(format)) {\n            return true;\n          }\n          for (let i = parents.length - 1; i >= 0; i--) {\n            if (dom.is(parents[i], format.selector)) {\n              return true;\n            }\n          }\n        }\n      }\n      return false;\n    };\n    const matchAllOnNode = (editor, node, formatNames) => foldl(formatNames, (acc, name) => {\n      const matchSimilar = isVariableFormatName(editor, name);\n      if (editor.formatter.matchNode(node, name, {}, matchSimilar)) {\n        return acc.concat([name]);\n      } else {\n        return acc;\n      }\n    }, []);\n\n    const ZWSP = ZWSP$1, CARET_ID = '_mce_caret';\n    const importNode = (ownerDocument, node) => {\n      return ownerDocument.importNode(node, true);\n    };\n    const getEmptyCaretContainers = node => {\n      const nodes = [];\n      while (node) {\n        if (node.nodeType === 3 && node.nodeValue !== ZWSP || node.childNodes.length > 1) {\n          return [];\n        }\n        if (node.nodeType === 1) {\n          nodes.push(node);\n        }\n        node = node.firstChild;\n      }\n      return nodes;\n    };\n    const isCaretContainerEmpty = node => {\n      return getEmptyCaretContainers(node).length > 0;\n    };\n    const findFirstTextNode = node => {\n      if (node) {\n        const walker = new DomTreeWalker(node, node);\n        for (node = walker.current(); node; node = walker.next()) {\n          if (isText$8(node)) {\n            return node;\n          }\n        }\n      }\n      return null;\n    };\n    const createCaretContainer = fill => {\n      const caretContainer = SugarElement.fromTag('span');\n      setAll$1(caretContainer, {\n        'id': CARET_ID,\n        'data-mce-bogus': '1',\n        'data-mce-type': 'format-caret'\n      });\n      if (fill) {\n        append$1(caretContainer, SugarElement.fromText(ZWSP));\n      }\n      return caretContainer;\n    };\n    const trimZwspFromCaretContainer = caretContainerNode => {\n      const textNode = findFirstTextNode(caretContainerNode);\n      if (textNode && textNode.nodeValue.charAt(0) === ZWSP) {\n        textNode.deleteData(0, 1);\n      }\n      return textNode;\n    };\n    const removeCaretContainerNode = (editor, node, moveCaret = true) => {\n      const dom = editor.dom, selection = editor.selection;\n      if (isCaretContainerEmpty(node)) {\n        deleteElement$2(editor, false, SugarElement.fromDom(node), moveCaret);\n      } else {\n        const rng = selection.getRng();\n        const block = dom.getParent(node, dom.isBlock);\n        const startContainer = rng.startContainer;\n        const startOffset = rng.startOffset;\n        const endContainer = rng.endContainer;\n        const endOffset = rng.endOffset;\n        const textNode = trimZwspFromCaretContainer(node);\n        dom.remove(node, true);\n        if (startContainer === textNode && startOffset > 0) {\n          rng.setStart(textNode, startOffset - 1);\n        }\n        if (endContainer === textNode && endOffset > 0) {\n          rng.setEnd(textNode, endOffset - 1);\n        }\n        if (block && dom.isEmpty(block)) {\n          fillWithPaddingBr(SugarElement.fromDom(block));\n        }\n        selection.setRng(rng);\n      }\n    };\n    const removeCaretContainer = (editor, node, moveCaret = true) => {\n      const dom = editor.dom, selection = editor.selection;\n      if (!node) {\n        node = getParentCaretContainer(editor.getBody(), selection.getStart());\n        if (!node) {\n          while (node = dom.get(CARET_ID)) {\n            removeCaretContainerNode(editor, node, false);\n          }\n        }\n      } else {\n        removeCaretContainerNode(editor, node, moveCaret);\n      }\n    };\n    const insertCaretContainerNode = (editor, caretContainer, formatNode) => {\n      const dom = editor.dom, block = dom.getParent(formatNode, curry(isTextBlock$1, editor));\n      if (block && dom.isEmpty(block)) {\n        formatNode.parentNode.replaceChild(caretContainer, formatNode);\n      } else {\n        removeTrailingBr(SugarElement.fromDom(formatNode));\n        if (dom.isEmpty(formatNode)) {\n          formatNode.parentNode.replaceChild(caretContainer, formatNode);\n        } else {\n          dom.insertAfter(caretContainer, formatNode);\n        }\n      }\n    };\n    const appendNode = (parentNode, node) => {\n      parentNode.appendChild(node);\n      return node;\n    };\n    const insertFormatNodesIntoCaretContainer = (formatNodes, caretContainer) => {\n      const innerMostFormatNode = foldr(formatNodes, (parentNode, formatNode) => {\n        return appendNode(parentNode, formatNode.cloneNode(false));\n      }, caretContainer);\n      return appendNode(innerMostFormatNode, innerMostFormatNode.ownerDocument.createTextNode(ZWSP));\n    };\n    const cleanFormatNode = (editor, caretContainer, formatNode, name, vars, similar) => {\n      const formatter = editor.formatter;\n      const dom = editor.dom;\n      const validFormats = filter$6(keys(formatter.get()), formatName => formatName !== name && !contains$1(formatName, 'removeformat'));\n      const matchedFormats = matchAllOnNode(editor, formatNode, validFormats);\n      const uniqueFormats = filter$6(matchedFormats, fmtName => !areSimilarFormats(editor, fmtName, name));\n      if (uniqueFormats.length > 0) {\n        const clonedFormatNode = formatNode.cloneNode(false);\n        dom.add(caretContainer, clonedFormatNode);\n        formatter.remove(name, vars, clonedFormatNode, similar);\n        dom.remove(clonedFormatNode);\n        return Optional.some(clonedFormatNode);\n      } else {\n        return Optional.none();\n      }\n    };\n    const applyCaretFormat = (editor, name, vars) => {\n      let caretContainer, textNode;\n      const selection = editor.selection;\n      const selectionRng = selection.getRng();\n      let offset = selectionRng.startOffset;\n      const container = selectionRng.startContainer;\n      const text = container.nodeValue;\n      caretContainer = getParentCaretContainer(editor.getBody(), selection.getStart());\n      if (caretContainer) {\n        textNode = findFirstTextNode(caretContainer);\n      }\n      const wordcharRegex = /[^\\s\\u00a0\\u00ad\\u200b\\ufeff]/;\n      if (text && offset > 0 && offset < text.length && wordcharRegex.test(text.charAt(offset)) && wordcharRegex.test(text.charAt(offset - 1))) {\n        const bookmark = selection.getBookmark();\n        selectionRng.collapse(true);\n        let rng = expandRng(editor, selectionRng, editor.formatter.get(name));\n        rng = split(rng);\n        editor.formatter.apply(name, vars, rng);\n        selection.moveToBookmark(bookmark);\n      } else {\n        if (!caretContainer || textNode.nodeValue !== ZWSP) {\n          caretContainer = importNode(editor.getDoc(), createCaretContainer(true).dom);\n          textNode = caretContainer.firstChild;\n          selectionRng.insertNode(caretContainer);\n          offset = 1;\n          editor.formatter.apply(name, vars, caretContainer);\n        } else {\n          editor.formatter.apply(name, vars, caretContainer);\n        }\n        selection.setCursorLocation(textNode, offset);\n      }\n    };\n    const removeCaretFormat = (editor, name, vars, similar) => {\n      const dom = editor.dom;\n      const selection = editor.selection;\n      let hasContentAfter, node, formatNode;\n      const parents = [];\n      const rng = selection.getRng();\n      const container = rng.startContainer;\n      const offset = rng.startOffset;\n      node = container;\n      if (container.nodeType === 3) {\n        if (offset !== container.nodeValue.length) {\n          hasContentAfter = true;\n        }\n        node = node.parentNode;\n      }\n      while (node) {\n        if (matchNode(editor, node, name, vars, similar)) {\n          formatNode = node;\n          break;\n        }\n        if (node.nextSibling) {\n          hasContentAfter = true;\n        }\n        parents.push(node);\n        node = node.parentNode;\n      }\n      if (!formatNode) {\n        return;\n      }\n      if (hasContentAfter) {\n        const bookmark = selection.getBookmark();\n        rng.collapse(true);\n        let expandedRng = expandRng(editor, rng, editor.formatter.get(name), true);\n        expandedRng = split(expandedRng);\n        editor.formatter.remove(name, vars, expandedRng, similar);\n        selection.moveToBookmark(bookmark);\n      } else {\n        const caretContainer = getParentCaretContainer(editor.getBody(), formatNode);\n        const newCaretContainer = createCaretContainer(false).dom;\n        insertCaretContainerNode(editor, newCaretContainer, caretContainer !== null ? caretContainer : formatNode);\n        const cleanedFormatNode = cleanFormatNode(editor, newCaretContainer, formatNode, name, vars, similar);\n        const caretTextNode = insertFormatNodesIntoCaretContainer(parents.concat(cleanedFormatNode.toArray()), newCaretContainer);\n        removeCaretContainerNode(editor, caretContainer, false);\n        selection.setCursorLocation(caretTextNode, 1);\n        if (dom.isEmpty(formatNode)) {\n          dom.remove(formatNode);\n        }\n      }\n    };\n    const disableCaretContainer = (editor, keyCode) => {\n      const selection = editor.selection, body = editor.getBody();\n      removeCaretContainer(editor, null, false);\n      if ((keyCode === 8 || keyCode === 46) && selection.isCollapsed() && selection.getStart().innerHTML === ZWSP) {\n        removeCaretContainer(editor, getParentCaretContainer(body, selection.getStart()));\n      }\n      if (keyCode === 37 || keyCode === 39) {\n        removeCaretContainer(editor, getParentCaretContainer(body, selection.getStart()));\n      }\n    };\n    const setup$u = editor => {\n      editor.on('mouseup keydown', e => {\n        disableCaretContainer(editor, e.keyCode);\n      });\n    };\n    const replaceWithCaretFormat = (targetNode, formatNodes) => {\n      const caretContainer = createCaretContainer(false);\n      const innerMost = insertFormatNodesIntoCaretContainer(formatNodes, caretContainer.dom);\n      before$3(SugarElement.fromDom(targetNode), caretContainer);\n      remove$5(SugarElement.fromDom(targetNode));\n      return CaretPosition(innerMost, 0);\n    };\n    const isFormatElement = (editor, element) => {\n      const inlineElements = editor.schema.getTextInlineElements();\n      return has$2(inlineElements, name(element)) && !isCaretNode(element.dom) && !isBogus$2(element.dom);\n    };\n    const isEmptyCaretFormatElement = element => {\n      return isCaretNode(element.dom) && isCaretContainerEmpty(element.dom);\n    };\n\n    const postProcessHooks = {};\n    const filter$2 = filter$4;\n    const each$a = each$e;\n    const addPostProcessHook = (name, hook) => {\n      const hooks = postProcessHooks[name];\n      if (!hooks) {\n        postProcessHooks[name] = [];\n      }\n      postProcessHooks[name].push(hook);\n    };\n    const postProcess$1 = (name, editor) => {\n      each$a(postProcessHooks[name], hook => {\n        hook(editor);\n      });\n    };\n    addPostProcessHook('pre', editor => {\n      const rng = editor.selection.getRng();\n      let blocks;\n      const hasPreSibling = pre => {\n        return isPre(pre.previousSibling) && indexOf(blocks, pre.previousSibling) !== -1;\n      };\n      const joinPre = (pre1, pre2) => {\n        const sPre2 = SugarElement.fromDom(pre2);\n        const doc = documentOrOwner(sPre2).dom;\n        remove$5(sPre2);\n        append(SugarElement.fromDom(pre1), [\n          SugarElement.fromTag('br', doc),\n          SugarElement.fromTag('br', doc),\n          ...children(sPre2)\n        ]);\n      };\n      const isPre = matchNodeNames(['pre']);\n      if (!rng.collapsed) {\n        blocks = editor.selection.getSelectedBlocks();\n        each$a(filter$2(filter$2(blocks, isPre), hasPreSibling), pre => {\n          joinPre(pre.previousSibling, pre);\n        });\n      }\n    });\n\n    const each$9 = Tools.each;\n    const isElementNode$1 = node => isElement$6(node) && !isBookmarkNode$1(node) && !isCaretNode(node) && !isBogus$2(node);\n    const findElementSibling = (node, siblingName) => {\n      for (let sibling = node; sibling; sibling = sibling[siblingName]) {\n        if (isText$8(sibling) && isNotEmpty(sibling.data)) {\n          return node;\n        }\n        if (isElement$6(sibling) && !isBookmarkNode$1(sibling)) {\n          return sibling;\n        }\n      }\n      return node;\n    };\n    const mergeSiblingsNodes = (dom, prev, next) => {\n      const elementUtils = ElementUtils(dom);\n      if (prev && next) {\n        prev = findElementSibling(prev, 'previousSibling');\n        next = findElementSibling(next, 'nextSibling');\n        if (elementUtils.compare(prev, next)) {\n          for (let sibling = prev.nextSibling; sibling && sibling !== next;) {\n            const tmpSibling = sibling;\n            sibling = sibling.nextSibling;\n            prev.appendChild(tmpSibling);\n          }\n          dom.remove(next);\n          Tools.each(Tools.grep(next.childNodes), node => {\n            prev.appendChild(node);\n          });\n          return prev;\n        }\n      }\n      return next;\n    };\n    const mergeSiblings = (dom, format, vars, node) => {\n      if (node && format.merge_siblings !== false) {\n        const newNode = mergeSiblingsNodes(dom, getNonWhiteSpaceSibling(node), node);\n        mergeSiblingsNodes(dom, newNode, getNonWhiteSpaceSibling(newNode, true));\n      }\n    };\n    const clearChildStyles = (dom, format, node) => {\n      if (format.clear_child_styles) {\n        const selector = format.links ? '*:not(a)' : '*';\n        each$9(dom.select(selector, node), node => {\n          if (isElementNode$1(node)) {\n            each$9(format.styles, (value, name) => {\n              dom.setStyle(node, name, '');\n            });\n          }\n        });\n      }\n    };\n    const processChildElements = (node, filter, process) => {\n      each$9(node.childNodes, node => {\n        if (isElementNode$1(node)) {\n          if (filter(node)) {\n            process(node);\n          }\n          if (node.hasChildNodes()) {\n            processChildElements(node, filter, process);\n          }\n        }\n      });\n    };\n    const unwrapEmptySpan = (dom, node) => {\n      if (node.nodeName === 'SPAN' && dom.getAttribs(node).length === 0) {\n        dom.remove(node, true);\n      }\n    };\n    const hasStyle = (dom, name) => node => !!(node && getStyle(dom, node, name));\n    const applyStyle = (dom, name, value) => node => {\n      dom.setStyle(node, name, value);\n      if (node.getAttribute('style') === '') {\n        node.removeAttribute('style');\n      }\n      unwrapEmptySpan(dom, node);\n    };\n\n    const removeResult = Adt.generate([\n      { keep: [] },\n      { rename: ['name'] },\n      { removed: [] }\n    ]);\n    const MCE_ATTR_RE = /^(src|href|style)$/;\n    const each$8 = Tools.each;\n    const isEq$2 = isEq$5;\n    const isTableCellOrRow = node => /^(TR|TH|TD)$/.test(node.nodeName);\n    const isChildOfInlineParent = (dom, node, parent) => dom.isChildOf(node, parent) && node !== parent && !dom.isBlock(parent);\n    const getContainer = (ed, rng, start) => {\n      let container = rng[start ? 'startContainer' : 'endContainer'];\n      let offset = rng[start ? 'startOffset' : 'endOffset'];\n      if (isElement$6(container)) {\n        const lastIdx = container.childNodes.length - 1;\n        if (!start && offset) {\n          offset--;\n        }\n        container = container.childNodes[offset > lastIdx ? lastIdx : offset];\n      }\n      if (isText$8(container) && start && offset >= container.nodeValue.length) {\n        container = new DomTreeWalker(container, ed.getBody()).next() || container;\n      }\n      if (isText$8(container) && !start && offset === 0) {\n        container = new DomTreeWalker(container, ed.getBody()).prev() || container;\n      }\n      return container;\n    };\n    const normalizeTableSelection = (node, start) => {\n      const prop = start ? 'firstChild' : 'lastChild';\n      if (isTableCellOrRow(node) && node[prop]) {\n        const childNode = node[prop];\n        if (node.nodeName === 'TR') {\n          return childNode[prop] || childNode;\n        } else {\n          return childNode;\n        }\n      }\n      return node;\n    };\n    const wrap$1 = (dom, node, name, attrs) => {\n      const wrapper = dom.create(name, attrs);\n      node.parentNode.insertBefore(wrapper, node);\n      wrapper.appendChild(node);\n      return wrapper;\n    };\n    const wrapWithSiblings = (dom, node, next, name, attrs) => {\n      const start = SugarElement.fromDom(node);\n      const wrapper = SugarElement.fromDom(dom.create(name, attrs));\n      const siblings = next ? nextSiblings(start) : prevSiblings(start);\n      append(wrapper, siblings);\n      if (next) {\n        before$3(start, wrapper);\n        prepend(wrapper, start);\n      } else {\n        after$4(start, wrapper);\n        append$1(wrapper, start);\n      }\n      return wrapper.dom;\n    };\n    const isColorFormatAndAnchor = (node, format) => format.links && node.nodeName === 'A';\n    const removeNode = (ed, node, format) => {\n      const parentNode = node.parentNode;\n      let rootBlockElm;\n      const dom = ed.dom;\n      const forcedRootBlock = getForcedRootBlock(ed);\n      if (isBlockFormat(format)) {\n        if (parentNode === dom.getRoot()) {\n          if (!format.list_block || !isEq$2(node, format.list_block)) {\n            each$g(from(node.childNodes), node => {\n              if (isValid(ed, forcedRootBlock, node.nodeName.toLowerCase())) {\n                if (!rootBlockElm) {\n                  rootBlockElm = wrap$1(dom, node, forcedRootBlock);\n                  dom.setAttribs(rootBlockElm, getForcedRootBlockAttrs(ed));\n                } else {\n                  rootBlockElm.appendChild(node);\n                }\n              } else {\n                rootBlockElm = null;\n              }\n            });\n          }\n        }\n      }\n      if (isMixedFormat(format) && !isEq$2(format.inline, node)) {\n        return;\n      }\n      dom.remove(node, true);\n    };\n    const removeFormatInternal = (ed, format, vars, node, compareNode) => {\n      let stylesModified;\n      const dom = ed.dom;\n      if (!matchName(dom, node, format) && !isColorFormatAndAnchor(node, format)) {\n        return removeResult.keep();\n      }\n      const elm = node;\n      if (isInlineFormat(format) && format.remove === 'all' && isArray$1(format.preserve_attributes)) {\n        const attrsToPreserve = filter$6(dom.getAttribs(elm), attr => contains$2(format.preserve_attributes, attr.name.toLowerCase()));\n        dom.removeAllAttribs(elm);\n        each$g(attrsToPreserve, attr => dom.setAttrib(elm, attr.name, attr.value));\n        if (attrsToPreserve.length > 0) {\n          return removeResult.rename('span');\n        }\n      }\n      if (format.remove !== 'all') {\n        each$8(format.styles, (value, name) => {\n          value = normalizeStyleValue(replaceVars(value, vars), name + '');\n          if (isNumber(name)) {\n            name = value;\n            compareNode = null;\n          }\n          if (format.remove_similar || (!compareNode || isEq$2(getStyle(dom, compareNode, name), value))) {\n            dom.setStyle(elm, name, '');\n          }\n          stylesModified = true;\n        });\n        if (stylesModified && dom.getAttrib(elm, 'style') === '') {\n          elm.removeAttribute('style');\n          elm.removeAttribute('data-mce-style');\n        }\n        each$8(format.attributes, (value, name) => {\n          let valueOut;\n          value = replaceVars(value, vars);\n          if (isNumber(name)) {\n            name = value;\n            compareNode = null;\n          }\n          if (format.remove_similar || (!compareNode || isEq$2(dom.getAttrib(compareNode, name), value))) {\n            if (name === 'class') {\n              value = dom.getAttrib(elm, name);\n              if (value) {\n                valueOut = '';\n                each$g(value.split(/\\s+/), cls => {\n                  if (/mce\\-\\w+/.test(cls)) {\n                    valueOut += (valueOut ? ' ' : '') + cls;\n                  }\n                });\n                if (valueOut) {\n                  dom.setAttrib(elm, name, valueOut);\n                  return;\n                }\n              }\n            }\n            if (MCE_ATTR_RE.test(name)) {\n              elm.removeAttribute('data-mce-' + name);\n            }\n            if (name === 'style' && matchNodeNames(['li'])(elm) && dom.getStyle(elm, 'list-style-type') === 'none') {\n              elm.removeAttribute(name);\n              dom.setStyle(elm, 'list-style-type', 'none');\n              return;\n            }\n            if (name === 'class') {\n              elm.removeAttribute('className');\n            }\n            elm.removeAttribute(name);\n          }\n        });\n        each$8(format.classes, value => {\n          value = replaceVars(value, vars);\n          if (!compareNode || dom.hasClass(compareNode, value)) {\n            dom.removeClass(elm, value);\n          }\n        });\n        const attrs = dom.getAttribs(elm);\n        for (let i = 0; i < attrs.length; i++) {\n          const attrName = attrs[i].nodeName;\n          if (attrName.indexOf('_') !== 0 && attrName.indexOf('data-') !== 0) {\n            return removeResult.keep();\n          }\n        }\n      }\n      if (format.remove !== 'none') {\n        removeNode(ed, elm, format);\n        return removeResult.removed();\n      }\n      return removeResult.keep();\n    };\n    const removeFormat$1 = (ed, format, vars, node, compareNode) => removeFormatInternal(ed, format, vars, node, compareNode).fold(never, newName => {\n      ed.dom.rename(node, newName);\n      return true;\n    }, always);\n    const findFormatRoot = (editor, container, name, vars, similar) => {\n      let formatRoot;\n      each$g(getParents$2(editor.dom, container.parentNode).reverse(), parent => {\n        if (!formatRoot && parent.id !== '_start' && parent.id !== '_end') {\n          const format = matchNode(editor, parent, name, vars, similar);\n          if (format && format.split !== false) {\n            formatRoot = parent;\n          }\n        }\n      });\n      return formatRoot;\n    };\n    const removeFormatFromClone = (editor, format, vars, clone) => removeFormatInternal(editor, format, vars, clone, clone).fold(constant(clone), newName => {\n      const fragment = editor.dom.createFragment();\n      fragment.appendChild(clone);\n      return editor.dom.rename(clone, newName);\n    }, constant(null));\n    const wrapAndSplit = (editor, formatList, formatRoot, container, target, split, format, vars) => {\n      let clone, lastClone, firstClone;\n      const dom = editor.dom;\n      if (formatRoot) {\n        const formatRootParent = formatRoot.parentNode;\n        for (let parent = container.parentNode; parent && parent !== formatRootParent; parent = parent.parentNode) {\n          clone = dom.clone(parent, false);\n          for (let i = 0; i < formatList.length; i++) {\n            clone = removeFormatFromClone(editor, formatList[i], vars, clone);\n            if (clone === null) {\n              break;\n            }\n          }\n          if (clone) {\n            if (lastClone) {\n              clone.appendChild(lastClone);\n            }\n            if (!firstClone) {\n              firstClone = clone;\n            }\n            lastClone = clone;\n          }\n        }\n        if (split && (!format.mixed || !dom.isBlock(formatRoot))) {\n          container = dom.split(formatRoot, container);\n        }\n        if (lastClone) {\n          target.parentNode.insertBefore(lastClone, target);\n          firstClone.appendChild(target);\n          if (isInlineFormat(format)) {\n            mergeSiblings(dom, format, vars, lastClone);\n          }\n        }\n      }\n      return container;\n    };\n    const remove$2 = (ed, name, vars, node, similar) => {\n      const formatList = ed.formatter.get(name);\n      const format = formatList[0];\n      let contentEditable = true;\n      const dom = ed.dom;\n      const selection = ed.selection;\n      const splitToFormatRoot = container => {\n        const formatRoot = findFormatRoot(ed, container, name, vars, similar);\n        return wrapAndSplit(ed, formatList, formatRoot, container, container, true, format, vars);\n      };\n      const isRemoveBookmarkNode = node => isBookmarkNode$1(node) && isElement$6(node) && (node.id === '_start' || node.id === '_end');\n      const removeNodeFormat = node => exists(formatList, fmt => removeFormat$1(ed, fmt, vars, node, node));\n      const process = node => {\n        let lastContentEditable = true;\n        let hasContentEditableState = false;\n        if (isElement$6(node) && dom.getContentEditable(node)) {\n          lastContentEditable = contentEditable;\n          contentEditable = dom.getContentEditable(node) === 'true';\n          hasContentEditableState = true;\n        }\n        const children = from(node.childNodes);\n        if (contentEditable && !hasContentEditableState) {\n          const removed = removeNodeFormat(node);\n          const currentNodeMatches = removed || exists(formatList, f => matchName(dom, node, f));\n          const parentNode = node.parentNode;\n          if (!currentNodeMatches && isNonNullable(parentNode) && shouldExpandToSelector(format)) {\n            removeNodeFormat(parentNode);\n          }\n        }\n        if (format.deep) {\n          if (children.length) {\n            for (let i = 0; i < children.length; i++) {\n              process(children[i]);\n            }\n            if (hasContentEditableState) {\n              contentEditable = lastContentEditable;\n            }\n          }\n        }\n        const textDecorations = [\n          'underline',\n          'line-through',\n          'overline'\n        ];\n        each$g(textDecorations, decoration => {\n          if (isElement$6(node) && ed.dom.getStyle(node, 'text-decoration') === decoration && node.parentNode && getTextDecoration(dom, node.parentNode) === decoration) {\n            removeFormat$1(ed, {\n              deep: false,\n              exact: true,\n              inline: 'span',\n              styles: { textDecoration: decoration }\n            }, null, node);\n          }\n        });\n      };\n      const unwrap = start => {\n        const node = dom.get(start ? '_start' : '_end');\n        let out = node[start ? 'firstChild' : 'lastChild'];\n        if (isRemoveBookmarkNode(out)) {\n          out = out[start ? 'firstChild' : 'lastChild'];\n        }\n        if (isText$8(out) && out.data.length === 0) {\n          out = start ? node.previousSibling || node.nextSibling : node.nextSibling || node.previousSibling;\n        }\n        dom.remove(node, true);\n        return out;\n      };\n      const removeRngStyle = rng => {\n        let startContainer, endContainer;\n        let expandedRng = expandRng(ed, rng, formatList, rng.collapsed);\n        if (format.split) {\n          expandedRng = split(expandedRng);\n          startContainer = getContainer(ed, expandedRng, true);\n          endContainer = getContainer(ed, expandedRng);\n          if (startContainer !== endContainer) {\n            startContainer = normalizeTableSelection(startContainer, true);\n            endContainer = normalizeTableSelection(endContainer, false);\n            if (isChildOfInlineParent(dom, startContainer, endContainer)) {\n              const marker = Optional.from(startContainer.firstChild).getOr(startContainer);\n              splitToFormatRoot(wrapWithSiblings(dom, marker, true, 'span', {\n                'id': '_start',\n                'data-mce-type': 'bookmark'\n              }));\n              unwrap(true);\n              return;\n            }\n            if (isChildOfInlineParent(dom, endContainer, startContainer)) {\n              const marker = Optional.from(endContainer.lastChild).getOr(endContainer);\n              splitToFormatRoot(wrapWithSiblings(dom, marker, false, 'span', {\n                'id': '_end',\n                'data-mce-type': 'bookmark'\n              }));\n              unwrap(false);\n              return;\n            }\n            startContainer = wrap$1(dom, startContainer, 'span', {\n              'id': '_start',\n              'data-mce-type': 'bookmark'\n            });\n            endContainer = wrap$1(dom, endContainer, 'span', {\n              'id': '_end',\n              'data-mce-type': 'bookmark'\n            });\n            const newRng = dom.createRng();\n            newRng.setStartAfter(startContainer);\n            newRng.setEndBefore(endContainer);\n            walk$3(dom, newRng, nodes => {\n              each$g(nodes, n => {\n                if (!isBookmarkNode$1(n) && !isBookmarkNode$1(n.parentNode)) {\n                  splitToFormatRoot(n);\n                }\n              });\n            });\n            splitToFormatRoot(startContainer);\n            splitToFormatRoot(endContainer);\n            startContainer = unwrap(true);\n            endContainer = unwrap();\n          } else {\n            startContainer = endContainer = splitToFormatRoot(startContainer);\n          }\n          expandedRng.startContainer = startContainer.parentNode ? startContainer.parentNode : startContainer;\n          expandedRng.startOffset = dom.nodeIndex(startContainer);\n          expandedRng.endContainer = endContainer.parentNode ? endContainer.parentNode : endContainer;\n          expandedRng.endOffset = dom.nodeIndex(endContainer) + 1;\n        }\n        walk$3(dom, expandedRng, nodes => {\n          each$g(nodes, process);\n        });\n      };\n      if (node) {\n        if (isNode(node)) {\n          const rng = dom.createRng();\n          rng.setStartBefore(node);\n          rng.setEndAfter(node);\n          removeRngStyle(rng);\n        } else {\n          removeRngStyle(node);\n        }\n        fireFormatRemove(ed, name, node, vars);\n        return;\n      }\n      if (dom.getContentEditable(selection.getNode()) === 'false') {\n        node = selection.getNode();\n        for (let i = 0; i < formatList.length; i++) {\n          if (formatList[i].ceFalseOverride) {\n            if (removeFormat$1(ed, formatList[i], vars, node, node)) {\n              break;\n            }\n          }\n        }\n        fireFormatRemove(ed, name, node, vars);\n        return;\n      }\n      if (!selection.isCollapsed() || !isInlineFormat(format) || getCellsFromEditor(ed).length) {\n        preserve(selection, true, () => {\n          runOnRanges(ed, removeRngStyle);\n        });\n        if (isInlineFormat(format) && match$2(ed, name, vars, selection.getStart())) {\n          moveStart(dom, selection, selection.getRng());\n        }\n        ed.nodeChanged();\n      } else {\n        removeCaretFormat(ed, name, vars, similar);\n      }\n      fireFormatRemove(ed, name, node, vars);\n    };\n\n    const each$7 = Tools.each;\n    const mergeTextDecorationsAndColor = (dom, format, vars, node) => {\n      const processTextDecorationsAndColor = n => {\n        if (n.nodeType === 1 && n.parentNode && n.parentNode.nodeType === 1) {\n          const textDecoration = getTextDecoration(dom, n.parentNode);\n          if (dom.getStyle(n, 'color') && textDecoration) {\n            dom.setStyle(n, 'text-decoration', textDecoration);\n          } else if (dom.getStyle(n, 'text-decoration') === textDecoration) {\n            dom.setStyle(n, 'text-decoration', null);\n          }\n        }\n      };\n      if (format.styles && (format.styles.color || format.styles.textDecoration)) {\n        Tools.walk(node, processTextDecorationsAndColor, 'childNodes');\n        processTextDecorationsAndColor(node);\n      }\n    };\n    const mergeBackgroundColorAndFontSize = (dom, format, vars, node) => {\n      if (format.styles && format.styles.backgroundColor) {\n        processChildElements(node, hasStyle(dom, 'fontSize'), applyStyle(dom, 'backgroundColor', replaceVars(format.styles.backgroundColor, vars)));\n      }\n    };\n    const mergeSubSup = (dom, format, vars, node) => {\n      if (isInlineFormat(format) && (format.inline === 'sub' || format.inline === 'sup')) {\n        processChildElements(node, hasStyle(dom, 'fontSize'), applyStyle(dom, 'fontSize', ''));\n        dom.remove(dom.select(format.inline === 'sup' ? 'sub' : 'sup', node), true);\n      }\n    };\n    const mergeWithChildren = (editor, formatList, vars, node) => {\n      each$7(formatList, format => {\n        if (isInlineFormat(format)) {\n          each$7(editor.dom.select(format.inline, node), child => {\n            if (!isElementNode$1(child)) {\n              return;\n            }\n            removeFormat$1(editor, format, vars, child, format.exact ? child : null);\n          });\n        }\n        clearChildStyles(editor.dom, format, node);\n      });\n    };\n    const mergeWithParents = (editor, format, name, vars, node) => {\n      if (matchNode(editor, node.parentNode, name, vars)) {\n        if (removeFormat$1(editor, format, vars, node)) {\n          return;\n        }\n      }\n      if (format.merge_with_parents) {\n        editor.dom.getParent(node.parentNode, parent => {\n          if (matchNode(editor, parent, name, vars)) {\n            removeFormat$1(editor, format, vars, node);\n            return true;\n          }\n        });\n      }\n    };\n\n    const each$6 = Tools.each;\n    const isElementNode = node => {\n      return isElement$6(node) && !isBookmarkNode$1(node) && !isCaretNode(node) && !isBogus$2(node);\n    };\n    const canFormatBR = (editor, format, node, parentName) => {\n      if (canFormatEmptyLines(editor) && isInlineFormat(format)) {\n        const validBRParentElements = getTextRootBlockElements(editor.schema);\n        const hasCaretNodeSibling = sibling(SugarElement.fromDom(node), sibling => isCaretNode(sibling.dom));\n        return hasNonNullableKey(validBRParentElements, parentName) && isEmpty$2(SugarElement.fromDom(node.parentNode), false) && !hasCaretNodeSibling;\n      } else {\n        return false;\n      }\n    };\n    const applyFormat$1 = (ed, name, vars, node) => {\n      const formatList = ed.formatter.get(name);\n      const format = formatList[0];\n      const isCollapsed = !node && ed.selection.isCollapsed();\n      const dom = ed.dom;\n      const selection = ed.selection;\n      const setElementFormat = (elm, fmt = format) => {\n        if (isFunction(fmt.onformat)) {\n          fmt.onformat(elm, fmt, vars, node);\n        }\n        each$6(fmt.styles, (value, name) => {\n          dom.setStyle(elm, name, replaceVars(value, vars));\n        });\n        if (fmt.styles) {\n          const styleVal = dom.getAttrib(elm, 'style');\n          if (styleVal) {\n            dom.setAttrib(elm, 'data-mce-style', styleVal);\n          }\n        }\n        each$6(fmt.attributes, (value, name) => {\n          dom.setAttrib(elm, name, replaceVars(value, vars));\n        });\n        each$6(fmt.classes, value => {\n          value = replaceVars(value, vars);\n          if (!dom.hasClass(elm, value)) {\n            dom.addClass(elm, value);\n          }\n        });\n      };\n      const applyNodeStyle = (formatList, node) => {\n        let found = false;\n        each$6(formatList, format => {\n          if (!isSelectorFormat(format)) {\n            return false;\n          }\n          if (isNonNullable(format.collapsed) && format.collapsed !== isCollapsed) {\n            return;\n          }\n          if (dom.is(node, format.selector) && !isCaretNode(node)) {\n            setElementFormat(node, format);\n            found = true;\n            return false;\n          }\n        });\n        return found;\n      };\n      const createWrapElement = wrapName => {\n        if (isString(wrapName)) {\n          const wrapElm = dom.create(wrapName);\n          setElementFormat(wrapElm);\n          return wrapElm;\n        } else {\n          return null;\n        }\n      };\n      const applyRngStyle = (dom, rng, nodeSpecific) => {\n        const newWrappers = [];\n        let contentEditable = true;\n        const wrapName = format.inline || format.block;\n        const wrapElm = createWrapElement(wrapName);\n        walk$3(dom, rng, nodes => {\n          let currentWrapElm;\n          const process = node => {\n            let hasContentEditableState = false;\n            let lastContentEditable = contentEditable;\n            const nodeName = node.nodeName.toLowerCase();\n            const parentNode = node.parentNode;\n            const parentName = parentNode.nodeName.toLowerCase();\n            if (isElement$6(node) && dom.getContentEditable(node)) {\n              lastContentEditable = contentEditable;\n              contentEditable = dom.getContentEditable(node) === 'true';\n              hasContentEditableState = true;\n            }\n            if (isBr$5(node) && !canFormatBR(ed, format, node, parentName)) {\n              currentWrapElm = null;\n              if (isBlockFormat(format)) {\n                dom.remove(node);\n              }\n              return;\n            }\n            if (isBlockFormat(format) && format.wrapper && matchNode(ed, node, name, vars)) {\n              currentWrapElm = null;\n              return;\n            }\n            if (contentEditable && !hasContentEditableState && isBlockFormat(format) && !format.wrapper && isTextBlock$1(ed, nodeName) && isValid(ed, parentName, wrapName)) {\n              const elm = dom.rename(node, wrapName);\n              setElementFormat(elm);\n              newWrappers.push(elm);\n              currentWrapElm = null;\n              return;\n            }\n            if (isSelectorFormat(format)) {\n              let found = applyNodeStyle(formatList, node);\n              if (!found && isNonNullable(parentNode) && shouldExpandToSelector(format)) {\n                found = applyNodeStyle(formatList, parentNode);\n              }\n              if (!isInlineFormat(format) || found) {\n                currentWrapElm = null;\n                return;\n              }\n            }\n            if (contentEditable && !hasContentEditableState && isValid(ed, wrapName, nodeName) && isValid(ed, parentName, wrapName) && !(!nodeSpecific && isText$8(node) && isZwsp(node.data)) && !isCaretNode(node) && (!isInlineFormat(format) || !dom.isBlock(node))) {\n              if (!currentWrapElm) {\n                currentWrapElm = dom.clone(wrapElm, false);\n                node.parentNode.insertBefore(currentWrapElm, node);\n                newWrappers.push(currentWrapElm);\n              }\n              currentWrapElm.appendChild(node);\n            } else {\n              currentWrapElm = null;\n              each$g(from(node.childNodes), process);\n              if (hasContentEditableState) {\n                contentEditable = lastContentEditable;\n              }\n              currentWrapElm = null;\n            }\n          };\n          each$g(nodes, process);\n        });\n        if (format.links === true) {\n          each$g(newWrappers, node => {\n            const process = node => {\n              if (node.nodeName === 'A') {\n                setElementFormat(node, format);\n              }\n              each$g(from(node.childNodes), process);\n            };\n            process(node);\n          });\n        }\n        each$g(newWrappers, node => {\n          const getChildCount = node => {\n            let count = 0;\n            each$g(node.childNodes, node => {\n              if (!isEmptyTextNode$1(node) && !isBookmarkNode$1(node)) {\n                count++;\n              }\n            });\n            return count;\n          };\n          const mergeStyles = node => {\n            const childElement = find$2(node.childNodes, isElementNode).filter(child => matchName(dom, child, format));\n            return childElement.map(child => {\n              const clone = dom.clone(child, false);\n              setElementFormat(clone);\n              dom.replace(clone, node, true);\n              dom.remove(child, true);\n              return clone;\n            }).getOr(node);\n          };\n          const childCount = getChildCount(node);\n          if ((newWrappers.length > 1 || !dom.isBlock(node)) && childCount === 0) {\n            dom.remove(node, true);\n            return;\n          }\n          if (isInlineFormat(format) || isBlockFormat(format) && format.wrapper) {\n            if (!format.exact && childCount === 1) {\n              node = mergeStyles(node);\n            }\n            mergeWithChildren(ed, formatList, vars, node);\n            mergeWithParents(ed, format, name, vars, node);\n            mergeBackgroundColorAndFontSize(dom, format, vars, node);\n            mergeTextDecorationsAndColor(dom, format, vars, node);\n            mergeSubSup(dom, format, vars, node);\n            mergeSiblings(dom, format, vars, node);\n          }\n        });\n      };\n      if (dom.getContentEditable(selection.getNode()) === 'false') {\n        node = selection.getNode();\n        for (let i = 0, l = formatList.length; i < l; i++) {\n          const formatItem = formatList[i];\n          if (formatItem.ceFalseOverride && isSelectorFormat(formatItem) && dom.is(node, formatItem.selector)) {\n            setElementFormat(node, formatItem);\n            break;\n          }\n        }\n        fireFormatApply(ed, name, node, vars);\n        return;\n      }\n      if (format) {\n        if (node) {\n          if (isNode(node)) {\n            if (!applyNodeStyle(formatList, node)) {\n              const rng = dom.createRng();\n              rng.setStartBefore(node);\n              rng.setEndAfter(node);\n              applyRngStyle(dom, expandRng(ed, rng, formatList), true);\n            }\n          } else {\n            applyRngStyle(dom, node, true);\n          }\n        } else {\n          if (!isCollapsed || !isInlineFormat(format) || getCellsFromEditor(ed).length) {\n            selection.setRng(normalize(selection.getRng()));\n            preserve(selection, true, () => {\n              runOnRanges(ed, (selectionRng, fake) => {\n                const expandedRng = fake ? selectionRng : expandRng(ed, selectionRng, formatList);\n                applyRngStyle(dom, expandedRng, false);\n              });\n            });\n            moveStart(dom, selection, selection.getRng());\n            ed.nodeChanged();\n          } else {\n            applyCaretFormat(ed, name, vars);\n          }\n        }\n        postProcess$1(name, ed);\n      }\n      fireFormatApply(ed, name, node, vars);\n    };\n\n    const hasVars = value => has$2(value, 'vars');\n    const setup$t = (registeredFormatListeners, editor) => {\n      registeredFormatListeners.set({});\n      editor.on('NodeChange', e => {\n        updateAndFireChangeCallbacks(editor, e.element, registeredFormatListeners.get());\n      });\n      editor.on('FormatApply FormatRemove', e => {\n        const element = Optional.from(e.node).map(nodeOrRange => isNode(nodeOrRange) ? nodeOrRange : nodeOrRange.startContainer).bind(node => isElement$6(node) ? Optional.some(node) : Optional.from(node.parentElement)).getOrThunk(() => fallbackElement(editor));\n        updateAndFireChangeCallbacks(editor, element, registeredFormatListeners.get());\n      });\n    };\n    const fallbackElement = editor => editor.selection.getStart();\n    const matchingNode = (editor, parents, format, similar, vars) => {\n      const isMatchingNode = node => {\n        const matchingFormat = editor.formatter.matchNode(node, format, vars !== null && vars !== void 0 ? vars : {}, similar);\n        return !isUndefined(matchingFormat);\n      };\n      const isUnableToMatch = node => {\n        if (matchesUnInheritedFormatSelector(editor, node, format)) {\n          return true;\n        } else {\n          if (!similar) {\n            return isNonNullable(editor.formatter.matchNode(node, format, vars, true));\n          } else {\n            return false;\n          }\n        }\n      };\n      return findUntil$1(parents, isMatchingNode, isUnableToMatch);\n    };\n    const getParents = (editor, elm) => {\n      const element = elm !== null && elm !== void 0 ? elm : fallbackElement(editor);\n      return filter$6(getParents$2(editor.dom, element), node => isElement$6(node) && !isBogus$2(node));\n    };\n    const updateAndFireChangeCallbacks = (editor, elm, registeredCallbacks) => {\n      const parents = getParents(editor, elm);\n      each$f(registeredCallbacks, (data, format) => {\n        const runIfChanged = spec => {\n          const match = matchingNode(editor, parents, format, spec.similar, hasVars(spec) ? spec.vars : undefined);\n          const isSet = match.isSome();\n          if (spec.state.get() !== isSet) {\n            spec.state.set(isSet);\n            const node = match.getOr(elm);\n            if (hasVars(spec)) {\n              spec.callback(isSet, {\n                node,\n                format,\n                parents\n              });\n            } else {\n              each$g(spec.callbacks, callback => callback(isSet, {\n                node,\n                format,\n                parents\n              }));\n            }\n          }\n        };\n        each$g([\n          data.withSimilar,\n          data.withoutSimilar\n        ], runIfChanged);\n        each$g(data.withVars, runIfChanged);\n      });\n    };\n    const addListeners = (editor, registeredFormatListeners, formats, callback, similar, vars) => {\n      const formatChangeItems = registeredFormatListeners.get();\n      each$g(formats.split(','), format => {\n        const group = get$a(formatChangeItems, format).getOrThunk(() => {\n          const base = {\n            withSimilar: {\n              state: Cell(false),\n              similar: true,\n              callbacks: []\n            },\n            withoutSimilar: {\n              state: Cell(false),\n              similar: false,\n              callbacks: []\n            },\n            withVars: []\n          };\n          formatChangeItems[format] = base;\n          return base;\n        });\n        const getCurrent = () => {\n          const parents = getParents(editor);\n          return matchingNode(editor, parents, format, similar, vars).isSome();\n        };\n        if (isUndefined(vars)) {\n          const toAppendTo = similar ? group.withSimilar : group.withoutSimilar;\n          toAppendTo.callbacks.push(callback);\n          if (toAppendTo.callbacks.length === 1) {\n            toAppendTo.state.set(getCurrent());\n          }\n        } else {\n          group.withVars.push({\n            state: Cell(getCurrent()),\n            similar,\n            vars,\n            callback\n          });\n        }\n      });\n      registeredFormatListeners.set(formatChangeItems);\n    };\n    const removeListeners = (registeredFormatListeners, formats, callback) => {\n      const formatChangeItems = registeredFormatListeners.get();\n      each$g(formats.split(','), format => get$a(formatChangeItems, format).each(group => {\n        formatChangeItems[format] = {\n          withSimilar: {\n            ...group.withSimilar,\n            callbacks: filter$6(group.withSimilar.callbacks, cb => cb !== callback)\n          },\n          withoutSimilar: {\n            ...group.withoutSimilar,\n            callbacks: filter$6(group.withoutSimilar.callbacks, cb => cb !== callback)\n          },\n          withVars: filter$6(group.withVars, item => item.callback !== callback)\n        };\n      }));\n      registeredFormatListeners.set(formatChangeItems);\n    };\n    const formatChangedInternal = (editor, registeredFormatListeners, formats, callback, similar, vars) => {\n      if (registeredFormatListeners.get() === null) {\n        setup$t(registeredFormatListeners, editor);\n      }\n      addListeners(editor, registeredFormatListeners, formats, callback, similar, vars);\n      return { unbind: () => removeListeners(registeredFormatListeners, formats, callback) };\n    };\n\n    const toggle = (editor, name, vars, node) => {\n      const fmt = editor.formatter.get(name);\n      if (match$2(editor, name, vars, node) && (!('toggle' in fmt[0]) || fmt[0].toggle)) {\n        remove$2(editor, name, vars, node);\n      } else {\n        applyFormat$1(editor, name, vars, node);\n      }\n    };\n\n    function _toConsumableArray(arr) {\n      if (Array.isArray(arr)) {\n        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n          arr2[i] = arr[i];\n        }\n        return arr2;\n      } else {\n        return Array.from(arr);\n      }\n    }\n    var hasOwnProperty = Object.hasOwnProperty, setPrototypeOf = Object.setPrototypeOf, isFrozen = Object.isFrozen, getPrototypeOf = Object.getPrototypeOf, getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n    var freeze = Object.freeze, seal = Object.seal, create$7 = Object.create;\n    var _ref = typeof Reflect !== 'undefined' && Reflect, apply = _ref.apply, construct = _ref.construct;\n    if (!apply) {\n      apply = function apply(fun, thisValue, args) {\n        return fun.apply(thisValue, args);\n      };\n    }\n    if (!freeze) {\n      freeze = function freeze(x) {\n        return x;\n      };\n    }\n    if (!seal) {\n      seal = function seal(x) {\n        return x;\n      };\n    }\n    if (!construct) {\n      construct = function construct(Func, args) {\n        return new (Function.prototype.bind.apply(Func, [null].concat(_toConsumableArray(args))))();\n      };\n    }\n    var arrayForEach = unapply(Array.prototype.forEach);\n    var arrayPop = unapply(Array.prototype.pop);\n    var arrayPush = unapply(Array.prototype.push);\n    var stringToLowerCase = unapply(String.prototype.toLowerCase);\n    var stringMatch = unapply(String.prototype.match);\n    var stringReplace = unapply(String.prototype.replace);\n    var stringIndexOf = unapply(String.prototype.indexOf);\n    var stringTrim = unapply(String.prototype.trim);\n    var regExpTest = unapply(RegExp.prototype.test);\n    var typeErrorCreate = unconstruct(TypeError);\n    function unapply(func) {\n      return function (thisArg) {\n        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n        return apply(func, thisArg, args);\n      };\n    }\n    function unconstruct(func) {\n      return function () {\n        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n        return construct(func, args);\n      };\n    }\n    function addToSet(set, array) {\n      if (setPrototypeOf) {\n        setPrototypeOf(set, null);\n      }\n      var l = array.length;\n      while (l--) {\n        var element = array[l];\n        if (typeof element === 'string') {\n          var lcElement = stringToLowerCase(element);\n          if (lcElement !== element) {\n            if (!isFrozen(array)) {\n              array[l] = lcElement;\n            }\n            element = lcElement;\n          }\n        }\n        set[element] = true;\n      }\n      return set;\n    }\n    function clone(object) {\n      var newObject = create$7(null);\n      var property = void 0;\n      for (property in object) {\n        if (apply(hasOwnProperty, object, [property])) {\n          newObject[property] = object[property];\n        }\n      }\n      return newObject;\n    }\n    function lookupGetter(object, prop) {\n      while (object !== null) {\n        var desc = getOwnPropertyDescriptor(object, prop);\n        if (desc) {\n          if (desc.get) {\n            return unapply(desc.get);\n          }\n          if (typeof desc.value === 'function') {\n            return unapply(desc.value);\n          }\n        }\n        object = getPrototypeOf(object);\n      }\n      function fallbackValue(element) {\n        console.warn('fallback value for', element);\n        return null;\n      }\n      return fallbackValue;\n    }\n    var html = freeze([\n      'a',\n      'abbr',\n      'acronym',\n      'address',\n      'area',\n      'article',\n      'aside',\n      'audio',\n      'b',\n      'bdi',\n      'bdo',\n      'big',\n      'blink',\n      'blockquote',\n      'body',\n      'br',\n      'button',\n      'canvas',\n      'caption',\n      'center',\n      'cite',\n      'code',\n      'col',\n      'colgroup',\n      'content',\n      'data',\n      'datalist',\n      'dd',\n      'decorator',\n      'del',\n      'details',\n      'dfn',\n      'dialog',\n      'dir',\n      'div',\n      'dl',\n      'dt',\n      'element',\n      'em',\n      'fieldset',\n      'figcaption',\n      'figure',\n      'font',\n      'footer',\n      'form',\n      'h1',\n      'h2',\n      'h3',\n      'h4',\n      'h5',\n      'h6',\n      'head',\n      'header',\n      'hgroup',\n      'hr',\n      'html',\n      'i',\n      'img',\n      'input',\n      'ins',\n      'kbd',\n      'label',\n      'legend',\n      'li',\n      'main',\n      'map',\n      'mark',\n      'marquee',\n      'menu',\n      'menuitem',\n      'meter',\n      'nav',\n      'nobr',\n      'ol',\n      'optgroup',\n      'option',\n      'output',\n      'p',\n      'picture',\n      'pre',\n      'progress',\n      'q',\n      'rp',\n      'rt',\n      'ruby',\n      's',\n      'samp',\n      'section',\n      'select',\n      'shadow',\n      'small',\n      'source',\n      'spacer',\n      'span',\n      'strike',\n      'strong',\n      'style',\n      'sub',\n      'summary',\n      'sup',\n      'table',\n      'tbody',\n      'td',\n      'template',\n      'textarea',\n      'tfoot',\n      'th',\n      'thead',\n      'time',\n      'tr',\n      'track',\n      'tt',\n      'u',\n      'ul',\n      'var',\n      'video',\n      'wbr'\n    ]);\n    var svg = freeze([\n      'svg',\n      'a',\n      'altglyph',\n      'altglyphdef',\n      'altglyphitem',\n      'animatecolor',\n      'animatemotion',\n      'animatetransform',\n      'circle',\n      'clippath',\n      'defs',\n      'desc',\n      'ellipse',\n      'filter',\n      'font',\n      'g',\n      'glyph',\n      'glyphref',\n      'hkern',\n      'image',\n      'line',\n      'lineargradient',\n      'marker',\n      'mask',\n      'metadata',\n      'mpath',\n      'path',\n      'pattern',\n      'polygon',\n      'polyline',\n      'radialgradient',\n      'rect',\n      'stop',\n      'style',\n      'switch',\n      'symbol',\n      'text',\n      'textpath',\n      'title',\n      'tref',\n      'tspan',\n      'view',\n      'vkern'\n    ]);\n    var svgFilters = freeze([\n      'feBlend',\n      'feColorMatrix',\n      'feComponentTransfer',\n      'feComposite',\n      'feConvolveMatrix',\n      'feDiffuseLighting',\n      'feDisplacementMap',\n      'feDistantLight',\n      'feFlood',\n      'feFuncA',\n      'feFuncB',\n      'feFuncG',\n      'feFuncR',\n      'feGaussianBlur',\n      'feImage',\n      'feMerge',\n      'feMergeNode',\n      'feMorphology',\n      'feOffset',\n      'fePointLight',\n      'feSpecularLighting',\n      'feSpotLight',\n      'feTile',\n      'feTurbulence'\n    ]);\n    var svgDisallowed = freeze([\n      'animate',\n      'color-profile',\n      'cursor',\n      'discard',\n      'fedropshadow',\n      'font-face',\n      'font-face-format',\n      'font-face-name',\n      'font-face-src',\n      'font-face-uri',\n      'foreignobject',\n      'hatch',\n      'hatchpath',\n      'mesh',\n      'meshgradient',\n      'meshpatch',\n      'meshrow',\n      'missing-glyph',\n      'script',\n      'set',\n      'solidcolor',\n      'unknown',\n      'use'\n    ]);\n    var mathMl = freeze([\n      'math',\n      'menclose',\n      'merror',\n      'mfenced',\n      'mfrac',\n      'mglyph',\n      'mi',\n      'mlabeledtr',\n      'mmultiscripts',\n      'mn',\n      'mo',\n      'mover',\n      'mpadded',\n      'mphantom',\n      'mroot',\n      'mrow',\n      'ms',\n      'mspace',\n      'msqrt',\n      'mstyle',\n      'msub',\n      'msup',\n      'msubsup',\n      'mtable',\n      'mtd',\n      'mtext',\n      'mtr',\n      'munder',\n      'munderover'\n    ]);\n    var mathMlDisallowed = freeze([\n      'maction',\n      'maligngroup',\n      'malignmark',\n      'mlongdiv',\n      'mscarries',\n      'mscarry',\n      'msgroup',\n      'mstack',\n      'msline',\n      'msrow',\n      'semantics',\n      'annotation',\n      'annotation-xml',\n      'mprescripts',\n      'none'\n    ]);\n    var text = freeze(['#text']);\n    var html$1 = freeze([\n      'accept',\n      'action',\n      'align',\n      'alt',\n      'autocapitalize',\n      'autocomplete',\n      'autopictureinpicture',\n      'autoplay',\n      'background',\n      'bgcolor',\n      'border',\n      'capture',\n      'cellpadding',\n      'cellspacing',\n      'checked',\n      'cite',\n      'class',\n      'clear',\n      'color',\n      'cols',\n      'colspan',\n      'controls',\n      'controlslist',\n      'coords',\n      'crossorigin',\n      'datetime',\n      'decoding',\n      'default',\n      'dir',\n      'disabled',\n      'disablepictureinpicture',\n      'disableremoteplayback',\n      'download',\n      'draggable',\n      'enctype',\n      'enterkeyhint',\n      'face',\n      'for',\n      'headers',\n      'height',\n      'hidden',\n      'high',\n      'href',\n      'hreflang',\n      'id',\n      'inputmode',\n      'integrity',\n      'ismap',\n      'kind',\n      'label',\n      'lang',\n      'list',\n      'loading',\n      'loop',\n      'low',\n      'max',\n      'maxlength',\n      'media',\n      'method',\n      'min',\n      'minlength',\n      'multiple',\n      'muted',\n      'name',\n      'nonce',\n      'noshade',\n      'novalidate',\n      'nowrap',\n      'open',\n      'optimum',\n      'pattern',\n      'placeholder',\n      'playsinline',\n      'poster',\n      'preload',\n      'pubdate',\n      'radiogroup',\n      'readonly',\n      'rel',\n      'required',\n      'rev',\n      'reversed',\n      'role',\n      'rows',\n      'rowspan',\n      'spellcheck',\n      'scope',\n      'selected',\n      'shape',\n      'size',\n      'sizes',\n      'span',\n      'srclang',\n      'start',\n      'src',\n      'srcset',\n      'step',\n      'style',\n      'summary',\n      'tabindex',\n      'title',\n      'translate',\n      'type',\n      'usemap',\n      'valign',\n      'value',\n      'width',\n      'xmlns',\n      'slot'\n    ]);\n    var svg$1 = freeze([\n      'accent-height',\n      'accumulate',\n      'additive',\n      'alignment-baseline',\n      'ascent',\n      'attributename',\n      'attributetype',\n      'azimuth',\n      'basefrequency',\n      'baseline-shift',\n      'begin',\n      'bias',\n      'by',\n      'class',\n      'clip',\n      'clippathunits',\n      'clip-path',\n      'clip-rule',\n      'color',\n      'color-interpolation',\n      'color-interpolation-filters',\n      'color-profile',\n      'color-rendering',\n      'cx',\n      'cy',\n      'd',\n      'dx',\n      'dy',\n      'diffuseconstant',\n      'direction',\n      'display',\n      'divisor',\n      'dur',\n      'edgemode',\n      'elevation',\n      'end',\n      'fill',\n      'fill-opacity',\n      'fill-rule',\n      'filter',\n      'filterunits',\n      'flood-color',\n      'flood-opacity',\n      'font-family',\n      'font-size',\n      'font-size-adjust',\n      'font-stretch',\n      'font-style',\n      'font-variant',\n      'font-weight',\n      'fx',\n      'fy',\n      'g1',\n      'g2',\n      'glyph-name',\n      'glyphref',\n      'gradientunits',\n      'gradienttransform',\n      'height',\n      'href',\n      'id',\n      'image-rendering',\n      'in',\n      'in2',\n      'k',\n      'k1',\n      'k2',\n      'k3',\n      'k4',\n      'kerning',\n      'keypoints',\n      'keysplines',\n      'keytimes',\n      'lang',\n      'lengthadjust',\n      'letter-spacing',\n      'kernelmatrix',\n      'kernelunitlength',\n      'lighting-color',\n      'local',\n      'marker-end',\n      'marker-mid',\n      'marker-start',\n      'markerheight',\n      'markerunits',\n      'markerwidth',\n      'maskcontentunits',\n      'maskunits',\n      'max',\n      'mask',\n      'media',\n      'method',\n      'mode',\n      'min',\n      'name',\n      'numoctaves',\n      'offset',\n      'operator',\n      'opacity',\n      'order',\n      'orient',\n      'orientation',\n      'origin',\n      'overflow',\n      'paint-order',\n      'path',\n      'pathlength',\n      'patterncontentunits',\n      'patterntransform',\n      'patternunits',\n      'points',\n      'preservealpha',\n      'preserveaspectratio',\n      'primitiveunits',\n      'r',\n      'rx',\n      'ry',\n      'radius',\n      'refx',\n      'refy',\n      'repeatcount',\n      'repeatdur',\n      'restart',\n      'result',\n      'rotate',\n      'scale',\n      'seed',\n      'shape-rendering',\n      'specularconstant',\n      'specularexponent',\n      'spreadmethod',\n      'startoffset',\n      'stddeviation',\n      'stitchtiles',\n      'stop-color',\n      'stop-opacity',\n      'stroke-dasharray',\n      'stroke-dashoffset',\n      'stroke-linecap',\n      'stroke-linejoin',\n      'stroke-miterlimit',\n      'stroke-opacity',\n      'stroke',\n      'stroke-width',\n      'style',\n      'surfacescale',\n      'systemlanguage',\n      'tabindex',\n      'targetx',\n      'targety',\n      'transform',\n      'transform-origin',\n      'text-anchor',\n      'text-decoration',\n      'text-rendering',\n      'textlength',\n      'type',\n      'u1',\n      'u2',\n      'unicode',\n      'values',\n      'viewbox',\n      'visibility',\n      'version',\n      'vert-adv-y',\n      'vert-origin-x',\n      'vert-origin-y',\n      'width',\n      'word-spacing',\n      'wrap',\n      'writing-mode',\n      'xchannelselector',\n      'ychannelselector',\n      'x',\n      'x1',\n      'x2',\n      'xmlns',\n      'y',\n      'y1',\n      'y2',\n      'z',\n      'zoomandpan'\n    ]);\n    var mathMl$1 = freeze([\n      'accent',\n      'accentunder',\n      'align',\n      'bevelled',\n      'close',\n      'columnsalign',\n      'columnlines',\n      'columnspan',\n      'denomalign',\n      'depth',\n      'dir',\n      'display',\n      'displaystyle',\n      'encoding',\n      'fence',\n      'frame',\n      'height',\n      'href',\n      'id',\n      'largeop',\n      'length',\n      'linethickness',\n      'lspace',\n      'lquote',\n      'mathbackground',\n      'mathcolor',\n      'mathsize',\n      'mathvariant',\n      'maxsize',\n      'minsize',\n      'movablelimits',\n      'notation',\n      'numalign',\n      'open',\n      'rowalign',\n      'rowlines',\n      'rowspacing',\n      'rowspan',\n      'rspace',\n      'rquote',\n      'scriptlevel',\n      'scriptminsize',\n      'scriptsizemultiplier',\n      'selection',\n      'separator',\n      'separators',\n      'stretchy',\n      'subscriptshift',\n      'supscriptshift',\n      'symmetric',\n      'voffset',\n      'width',\n      'xmlns'\n    ]);\n    var xml = freeze([\n      'xlink:href',\n      'xml:id',\n      'xlink:title',\n      'xml:space',\n      'xmlns:xlink'\n    ]);\n    var MUSTACHE_EXPR = seal(/\\{\\{[\\s\\S]*|[\\s\\S]*\\}\\}/gm);\n    var ERB_EXPR = seal(/<%[\\s\\S]*|[\\s\\S]*%>/gm);\n    var DATA_ATTR = seal(/^data-[\\-\\w.\\u00B7-\\uFFFF]/);\n    var ARIA_ATTR = seal(/^aria-[\\-\\w]+$/);\n    var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i);\n    var IS_SCRIPT_OR_DATA = seal(/^(?:\\w+script|data):/i);\n    var ATTR_WHITESPACE = seal(/[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g);\n    var DOCTYPE_NAME = seal(/^html$/i);\n    var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {\n      return typeof obj;\n    } : function (obj) {\n      return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;\n    };\n    function _toConsumableArray$1(arr) {\n      if (Array.isArray(arr)) {\n        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n          arr2[i] = arr[i];\n        }\n        return arr2;\n      } else {\n        return Array.from(arr);\n      }\n    }\n    var getGlobal = function getGlobal() {\n      return typeof window === 'undefined' ? null : window;\n    };\n    var _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, document) {\n      if ((typeof trustedTypes === 'undefined' ? 'undefined' : _typeof(trustedTypes)) !== 'object' || typeof trustedTypes.createPolicy !== 'function') {\n        return null;\n      }\n      var suffix = null;\n      var ATTR_NAME = 'data-tt-policy-suffix';\n      if (document.currentScript && document.currentScript.hasAttribute(ATTR_NAME)) {\n        suffix = document.currentScript.getAttribute(ATTR_NAME);\n      }\n      var policyName = 'dompurify' + (suffix ? '#' + suffix : '');\n      try {\n        return trustedTypes.createPolicy(policyName, {\n          createHTML: function createHTML(html$$1) {\n            return html$$1;\n          }\n        });\n      } catch (_) {\n        console.warn('TrustedTypes policy ' + policyName + ' could not be created.');\n        return null;\n      }\n    };\n    function createDOMPurify() {\n      var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();\n      var DOMPurify = function DOMPurify(root) {\n        return createDOMPurify(root);\n      };\n      DOMPurify.version = '2.3.6';\n      DOMPurify.removed = [];\n      if (!window || !window.document || window.document.nodeType !== 9) {\n        DOMPurify.isSupported = false;\n        return DOMPurify;\n      }\n      var originalDocument = window.document;\n      var document = window.document;\n      var DocumentFragment = window.DocumentFragment, HTMLTemplateElement = window.HTMLTemplateElement, Node = window.Node, Element = window.Element, NodeFilter = window.NodeFilter, _window$NamedNodeMap = window.NamedNodeMap, NamedNodeMap = _window$NamedNodeMap === undefined ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap, HTMLFormElement = window.HTMLFormElement, DOMParser = window.DOMParser, trustedTypes = window.trustedTypes;\n      var ElementPrototype = Element.prototype;\n      var cloneNode = lookupGetter(ElementPrototype, 'cloneNode');\n      var getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');\n      var getChildNodes = lookupGetter(ElementPrototype, 'childNodes');\n      var getParentNode = lookupGetter(ElementPrototype, 'parentNode');\n      if (typeof HTMLTemplateElement === 'function') {\n        var template = document.createElement('template');\n        if (template.content && template.content.ownerDocument) {\n          document = template.content.ownerDocument;\n        }\n      }\n      var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);\n      var emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML('') : '';\n      var _document = document, implementation = _document.implementation, createNodeIterator = _document.createNodeIterator, createDocumentFragment = _document.createDocumentFragment, getElementsByTagName = _document.getElementsByTagName;\n      var importNode = originalDocument.importNode;\n      var documentMode = {};\n      try {\n        documentMode = clone(document).documentMode ? document.documentMode : {};\n      } catch (_) {\n      }\n      var hooks = {};\n      DOMPurify.isSupported = typeof getParentNode === 'function' && implementation && typeof implementation.createHTMLDocument !== 'undefined' && documentMode !== 9;\n      var MUSTACHE_EXPR$$1 = MUSTACHE_EXPR, ERB_EXPR$$1 = ERB_EXPR, DATA_ATTR$$1 = DATA_ATTR, ARIA_ATTR$$1 = ARIA_ATTR, IS_SCRIPT_OR_DATA$$1 = IS_SCRIPT_OR_DATA, ATTR_WHITESPACE$$1 = ATTR_WHITESPACE;\n      var IS_ALLOWED_URI$$1 = IS_ALLOWED_URI;\n      var ALLOWED_TAGS = null;\n      var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(html), _toConsumableArray$1(svg), _toConsumableArray$1(svgFilters), _toConsumableArray$1(mathMl), _toConsumableArray$1(text)));\n      var ALLOWED_ATTR = null;\n      var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray$1(html$1), _toConsumableArray$1(svg$1), _toConsumableArray$1(mathMl$1), _toConsumableArray$1(xml)));\n      var CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {\n        tagNameCheck: {\n          writable: true,\n          configurable: false,\n          enumerable: true,\n          value: null\n        },\n        attributeNameCheck: {\n          writable: true,\n          configurable: false,\n          enumerable: true,\n          value: null\n        },\n        allowCustomizedBuiltInElements: {\n          writable: true,\n          configurable: false,\n          enumerable: true,\n          value: false\n        }\n      }));\n      var FORBID_TAGS = null;\n      var FORBID_ATTR = null;\n      var ALLOW_ARIA_ATTR = true;\n      var ALLOW_DATA_ATTR = true;\n      var ALLOW_UNKNOWN_PROTOCOLS = false;\n      var SAFE_FOR_TEMPLATES = false;\n      var WHOLE_DOCUMENT = false;\n      var SET_CONFIG = false;\n      var FORCE_BODY = false;\n      var RETURN_DOM = false;\n      var RETURN_DOM_FRAGMENT = false;\n      var RETURN_TRUSTED_TYPE = false;\n      var SANITIZE_DOM = true;\n      var KEEP_CONTENT = true;\n      var IN_PLACE = false;\n      var USE_PROFILES = {};\n      var FORBID_CONTENTS = null;\n      var DEFAULT_FORBID_CONTENTS = addToSet({}, [\n        'annotation-xml',\n        'audio',\n        'colgroup',\n        'desc',\n        'foreignobject',\n        'head',\n        'iframe',\n        'math',\n        'mi',\n        'mn',\n        'mo',\n        'ms',\n        'mtext',\n        'noembed',\n        'noframes',\n        'noscript',\n        'plaintext',\n        'script',\n        'style',\n        'svg',\n        'template',\n        'thead',\n        'title',\n        'video',\n        'xmp'\n      ]);\n      var DATA_URI_TAGS = null;\n      var DEFAULT_DATA_URI_TAGS = addToSet({}, [\n        'audio',\n        'video',\n        'img',\n        'source',\n        'image',\n        'track'\n      ]);\n      var URI_SAFE_ATTRIBUTES = null;\n      var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, [\n        'alt',\n        'class',\n        'for',\n        'id',\n        'label',\n        'name',\n        'pattern',\n        'placeholder',\n        'role',\n        'summary',\n        'title',\n        'value',\n        'style',\n        'xmlns'\n      ]);\n      var MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\n      var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n      var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\n      var NAMESPACE = HTML_NAMESPACE;\n      var IS_EMPTY_INPUT = false;\n      var PARSER_MEDIA_TYPE = void 0;\n      var SUPPORTED_PARSER_MEDIA_TYPES = [\n        'application/xhtml+xml',\n        'text/html'\n      ];\n      var DEFAULT_PARSER_MEDIA_TYPE = 'text/html';\n      var transformCaseFunc = void 0;\n      var CONFIG = null;\n      var formElement = document.createElement('form');\n      var isRegexOrFunction = function isRegexOrFunction(testValue) {\n        return testValue instanceof RegExp || testValue instanceof Function;\n      };\n      var _parseConfig = function _parseConfig(cfg) {\n        if (CONFIG && CONFIG === cfg) {\n          return;\n        }\n        if (!cfg || (typeof cfg === 'undefined' ? 'undefined' : _typeof(cfg)) !== 'object') {\n          cfg = {};\n        }\n        cfg = clone(cfg);\n        ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;\n        ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;\n        URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR) : DEFAULT_URI_SAFE_ATTRIBUTES;\n        DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS) : DEFAULT_DATA_URI_TAGS;\n        FORBID_CONTENTS = 'FORBID_CONTENTS' in cfg ? addToSet({}, cfg.FORBID_CONTENTS) : DEFAULT_FORBID_CONTENTS;\n        FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};\n        FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};\n        USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;\n        ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;\n        ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;\n        ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;\n        SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;\n        WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;\n        RETURN_DOM = cfg.RETURN_DOM || false;\n        RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;\n        RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;\n        FORCE_BODY = cfg.FORCE_BODY || false;\n        SANITIZE_DOM = cfg.SANITIZE_DOM !== false;\n        KEEP_CONTENT = cfg.KEEP_CONTENT !== false;\n        IN_PLACE = cfg.IN_PLACE || false;\n        IS_ALLOWED_URI$$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$$1;\n        NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;\n        if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {\n          CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;\n        }\n        if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {\n          CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;\n        }\n        if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === 'boolean') {\n          CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;\n        }\n        PARSER_MEDIA_TYPE = SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE;\n        transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? function (x) {\n          return x;\n        } : stringToLowerCase;\n        if (SAFE_FOR_TEMPLATES) {\n          ALLOW_DATA_ATTR = false;\n        }\n        if (RETURN_DOM_FRAGMENT) {\n          RETURN_DOM = true;\n        }\n        if (USE_PROFILES) {\n          ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(text)));\n          ALLOWED_ATTR = [];\n          if (USE_PROFILES.html === true) {\n            addToSet(ALLOWED_TAGS, html);\n            addToSet(ALLOWED_ATTR, html$1);\n          }\n          if (USE_PROFILES.svg === true) {\n            addToSet(ALLOWED_TAGS, svg);\n            addToSet(ALLOWED_ATTR, svg$1);\n            addToSet(ALLOWED_ATTR, xml);\n          }\n          if (USE_PROFILES.svgFilters === true) {\n            addToSet(ALLOWED_TAGS, svgFilters);\n            addToSet(ALLOWED_ATTR, svg$1);\n            addToSet(ALLOWED_ATTR, xml);\n          }\n          if (USE_PROFILES.mathMl === true) {\n            addToSet(ALLOWED_TAGS, mathMl);\n            addToSet(ALLOWED_ATTR, mathMl$1);\n            addToSet(ALLOWED_ATTR, xml);\n          }\n        }\n        if (cfg.ADD_TAGS) {\n          if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {\n            ALLOWED_TAGS = clone(ALLOWED_TAGS);\n          }\n          addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);\n        }\n        if (cfg.ADD_ATTR) {\n          if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {\n            ALLOWED_ATTR = clone(ALLOWED_ATTR);\n          }\n          addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);\n        }\n        if (cfg.ADD_URI_SAFE_ATTR) {\n          addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);\n        }\n        if (cfg.FORBID_CONTENTS) {\n          if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {\n            FORBID_CONTENTS = clone(FORBID_CONTENTS);\n          }\n          addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS);\n        }\n        if (KEEP_CONTENT) {\n          ALLOWED_TAGS['#text'] = true;\n        }\n        if (WHOLE_DOCUMENT) {\n          addToSet(ALLOWED_TAGS, [\n            'html',\n            'head',\n            'body'\n          ]);\n        }\n        if (ALLOWED_TAGS.table) {\n          addToSet(ALLOWED_TAGS, ['tbody']);\n          delete FORBID_TAGS.tbody;\n        }\n        if (freeze) {\n          freeze(cfg);\n        }\n        CONFIG = cfg;\n      };\n      var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, [\n        'mi',\n        'mo',\n        'mn',\n        'ms',\n        'mtext'\n      ]);\n      var HTML_INTEGRATION_POINTS = addToSet({}, [\n        'foreignobject',\n        'desc',\n        'title',\n        'annotation-xml'\n      ]);\n      var COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, [\n        'title',\n        'style',\n        'font',\n        'a',\n        'script'\n      ]);\n      var ALL_SVG_TAGS = addToSet({}, svg);\n      addToSet(ALL_SVG_TAGS, svgFilters);\n      addToSet(ALL_SVG_TAGS, svgDisallowed);\n      var ALL_MATHML_TAGS = addToSet({}, mathMl);\n      addToSet(ALL_MATHML_TAGS, mathMlDisallowed);\n      var _checkValidNamespace = function _checkValidNamespace(element) {\n        var parent = getParentNode(element);\n        if (!parent || !parent.tagName) {\n          parent = {\n            namespaceURI: HTML_NAMESPACE,\n            tagName: 'template'\n          };\n        }\n        var tagName = stringToLowerCase(element.tagName);\n        var parentTagName = stringToLowerCase(parent.tagName);\n        if (element.namespaceURI === SVG_NAMESPACE) {\n          if (parent.namespaceURI === HTML_NAMESPACE) {\n            return tagName === 'svg';\n          }\n          if (parent.namespaceURI === MATHML_NAMESPACE) {\n            return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);\n          }\n          return Boolean(ALL_SVG_TAGS[tagName]);\n        }\n        if (element.namespaceURI === MATHML_NAMESPACE) {\n          if (parent.namespaceURI === HTML_NAMESPACE) {\n            return tagName === 'math';\n          }\n          if (parent.namespaceURI === SVG_NAMESPACE) {\n            return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];\n          }\n          return Boolean(ALL_MATHML_TAGS[tagName]);\n        }\n        if (element.namespaceURI === HTML_NAMESPACE) {\n          if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {\n            return false;\n          }\n          if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {\n            return false;\n          }\n          return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);\n        }\n        return false;\n      };\n      var _forceRemove = function _forceRemove(node) {\n        arrayPush(DOMPurify.removed, { element: node });\n        try {\n          node.parentNode.removeChild(node);\n        } catch (_) {\n          try {\n            node.outerHTML = emptyHTML;\n          } catch (_) {\n            node.remove();\n          }\n        }\n      };\n      var _removeAttribute = function _removeAttribute(name, node) {\n        try {\n          arrayPush(DOMPurify.removed, {\n            attribute: node.getAttributeNode(name),\n            from: node\n          });\n        } catch (_) {\n          arrayPush(DOMPurify.removed, {\n            attribute: null,\n            from: node\n          });\n        }\n        node.removeAttribute(name);\n        if (name === 'is' && !ALLOWED_ATTR[name]) {\n          if (RETURN_DOM || RETURN_DOM_FRAGMENT) {\n            try {\n              _forceRemove(node);\n            } catch (_) {\n            }\n          } else {\n            try {\n              node.setAttribute(name, '');\n            } catch (_) {\n            }\n          }\n        }\n      };\n      var _initDocument = function _initDocument(dirty) {\n        var doc = void 0;\n        var leadingWhitespace = void 0;\n        if (FORCE_BODY) {\n          dirty = '<remove></remove>' + dirty;\n        } else {\n          var matches = stringMatch(dirty, /^[\\r\\n\\t ]+/);\n          leadingWhitespace = matches && matches[0];\n        }\n        if (PARSER_MEDIA_TYPE === 'application/xhtml+xml') {\n          dirty = '<html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head><body>' + dirty + '</body></html>';\n        }\n        var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;\n        if (NAMESPACE === HTML_NAMESPACE) {\n          try {\n            doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);\n          } catch (_) {\n          }\n        }\n        if (!doc || !doc.documentElement) {\n          doc = implementation.createDocument(NAMESPACE, 'template', null);\n          try {\n            doc.documentElement.innerHTML = IS_EMPTY_INPUT ? '' : dirtyPayload;\n          } catch (_) {\n          }\n        }\n        var body = doc.body || doc.documentElement;\n        if (dirty && leadingWhitespace) {\n          body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);\n        }\n        if (NAMESPACE === HTML_NAMESPACE) {\n          return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];\n        }\n        return WHOLE_DOCUMENT ? doc.documentElement : body;\n      };\n      var _createIterator = function _createIterator(root) {\n        return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);\n      };\n      var _isClobbered = function _isClobbered(elm) {\n        return elm instanceof HTMLFormElement && (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string' || typeof elm.insertBefore !== 'function');\n      };\n      var _isNode = function _isNode(object) {\n        return (typeof Node === 'undefined' ? 'undefined' : _typeof(Node)) === 'object' ? object instanceof Node : object && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string';\n      };\n      var _executeHook = function _executeHook(entryPoint, currentNode, data) {\n        if (!hooks[entryPoint]) {\n          return;\n        }\n        arrayForEach(hooks[entryPoint], function (hook) {\n          hook.call(DOMPurify, currentNode, data, CONFIG);\n        });\n      };\n      var _sanitizeElements = function _sanitizeElements(currentNode) {\n        var content = void 0;\n        _executeHook('beforeSanitizeElements', currentNode, null);\n        if (_isClobbered(currentNode)) {\n          _forceRemove(currentNode);\n          return true;\n        }\n        if (regExpTest(/[\\u0080-\\uFFFF]/, currentNode.nodeName)) {\n          _forceRemove(currentNode);\n          return true;\n        }\n        var tagName = transformCaseFunc(currentNode.nodeName);\n        _executeHook('uponSanitizeElement', currentNode, {\n          tagName: tagName,\n          allowedTags: ALLOWED_TAGS\n        });\n        if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\\w]/g, currentNode.innerHTML) && regExpTest(/<[/\\w]/g, currentNode.textContent)) {\n          _forceRemove(currentNode);\n          return true;\n        }\n        if (tagName === 'select' && regExpTest(/<template/i, currentNode.innerHTML)) {\n          _forceRemove(currentNode);\n          return true;\n        }\n        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n          if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {\n            if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName))\n              return false;\n            if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName))\n              return false;\n          }\n          if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {\n            var parentNode = getParentNode(currentNode) || currentNode.parentNode;\n            var childNodes = getChildNodes(currentNode) || currentNode.childNodes;\n            if (childNodes && parentNode) {\n              var childCount = childNodes.length;\n              for (var i = childCount - 1; i >= 0; --i) {\n                parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));\n              }\n            }\n          }\n          _forceRemove(currentNode);\n          return true;\n        }\n        if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {\n          _forceRemove(currentNode);\n          return true;\n        }\n        if ((tagName === 'noscript' || tagName === 'noembed') && regExpTest(/<\\/no(script|embed)/i, currentNode.innerHTML)) {\n          _forceRemove(currentNode);\n          return true;\n        }\n        if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {\n          content = currentNode.textContent;\n          content = stringReplace(content, MUSTACHE_EXPR$$1, ' ');\n          content = stringReplace(content, ERB_EXPR$$1, ' ');\n          if (currentNode.textContent !== content) {\n            arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });\n            currentNode.textContent = content;\n          }\n        }\n        _executeHook('afterSanitizeElements', currentNode, null);\n        return false;\n      };\n      var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {\n        if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {\n          return false;\n        }\n        if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$$1, lcName));\n        else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$$1, lcName));\n        else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {\n          if (_basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || lcName === 'is' && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value)));\n          else {\n            return false;\n          }\n        } else if (URI_SAFE_ATTRIBUTES[lcName]);\n        else if (regExpTest(IS_ALLOWED_URI$$1, stringReplace(value, ATTR_WHITESPACE$$1, '')));\n        else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]);\n        else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$$1, stringReplace(value, ATTR_WHITESPACE$$1, '')));\n        else if (!value);\n        else {\n          return false;\n        }\n        return true;\n      };\n      var _basicCustomElementTest = function _basicCustomElementTest(tagName) {\n        return tagName.indexOf('-') > 0;\n      };\n      var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {\n        var attr = void 0;\n        var value = void 0;\n        var lcName = void 0;\n        var l = void 0;\n        _executeHook('beforeSanitizeAttributes', currentNode, null);\n        var attributes = currentNode.attributes;\n        if (!attributes) {\n          return;\n        }\n        var hookEvent = {\n          attrName: '',\n          attrValue: '',\n          keepAttr: true,\n          allowedAttributes: ALLOWED_ATTR\n        };\n        l = attributes.length;\n        while (l--) {\n          attr = attributes[l];\n          var _attr = attr, name = _attr.name, namespaceURI = _attr.namespaceURI;\n          value = stringTrim(attr.value);\n          lcName = transformCaseFunc(name);\n          var initValue = value;\n          hookEvent.attrName = lcName;\n          hookEvent.attrValue = value;\n          hookEvent.keepAttr = true;\n          hookEvent.forceKeepAttr = undefined;\n          _executeHook('uponSanitizeAttribute', currentNode, hookEvent);\n          value = hookEvent.attrValue;\n          if (hookEvent.forceKeepAttr) {\n            continue;\n          }\n          if (!hookEvent.keepAttr) {\n            _removeAttribute(name, currentNode);\n            continue;\n          }\n          if (regExpTest(/\\/>/i, value)) {\n            _removeAttribute(name, currentNode);\n            continue;\n          }\n          if (SAFE_FOR_TEMPLATES) {\n            value = stringReplace(value, MUSTACHE_EXPR$$1, ' ');\n            value = stringReplace(value, ERB_EXPR$$1, ' ');\n          }\n          var lcTag = transformCaseFunc(currentNode.nodeName);\n          if (!_isValidAttribute(lcTag, lcName, value)) {\n            _removeAttribute(name, currentNode);\n            continue;\n          }\n          if (value !== initValue) {\n            try {\n              if (namespaceURI) {\n                currentNode.setAttributeNS(namespaceURI, name, value);\n              } else {\n                currentNode.setAttribute(name, value);\n              }\n            } catch (_) {\n              _removeAttribute(name, currentNode);\n            }\n          }\n        }\n        _executeHook('afterSanitizeAttributes', currentNode, null);\n      };\n      var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {\n        var shadowNode = void 0;\n        var shadowIterator = _createIterator(fragment);\n        _executeHook('beforeSanitizeShadowDOM', fragment, null);\n        while (shadowNode = shadowIterator.nextNode()) {\n          _executeHook('uponSanitizeShadowNode', shadowNode, null);\n          if (_sanitizeElements(shadowNode)) {\n            continue;\n          }\n          if (shadowNode.content instanceof DocumentFragment) {\n            _sanitizeShadowDOM(shadowNode.content);\n          }\n          _sanitizeAttributes(shadowNode);\n        }\n        _executeHook('afterSanitizeShadowDOM', fragment, null);\n      };\n      DOMPurify.sanitize = function (dirty, cfg) {\n        var body = void 0;\n        var importedNode = void 0;\n        var currentNode = void 0;\n        var oldNode = void 0;\n        var returnNode = void 0;\n        IS_EMPTY_INPUT = !dirty;\n        if (IS_EMPTY_INPUT) {\n          dirty = '<!-->';\n        }\n        if (typeof dirty !== 'string' && !_isNode(dirty)) {\n          if (typeof dirty.toString !== 'function') {\n            throw typeErrorCreate('toString is not a function');\n          } else {\n            dirty = dirty.toString();\n            if (typeof dirty !== 'string') {\n              throw typeErrorCreate('dirty is not a string, aborting');\n            }\n          }\n        }\n        if (!DOMPurify.isSupported) {\n          if (_typeof(window.toStaticHTML) === 'object' || typeof window.toStaticHTML === 'function') {\n            if (typeof dirty === 'string') {\n              return window.toStaticHTML(dirty);\n            }\n            if (_isNode(dirty)) {\n              return window.toStaticHTML(dirty.outerHTML);\n            }\n          }\n          return dirty;\n        }\n        if (!SET_CONFIG) {\n          _parseConfig(cfg);\n        }\n        DOMPurify.removed = [];\n        if (typeof dirty === 'string') {\n          IN_PLACE = false;\n        }\n        if (IN_PLACE) {\n          if (dirty.nodeName) {\n            var tagName = transformCaseFunc(dirty.nodeName);\n            if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n              throw typeErrorCreate('root node is forbidden and cannot be sanitized in-place');\n            }\n          }\n        } else if (dirty instanceof Node) {\n          body = _initDocument('<!---->');\n          importedNode = body.ownerDocument.importNode(dirty, true);\n          if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {\n            body = importedNode;\n          } else if (importedNode.nodeName === 'HTML') {\n            body = importedNode;\n          } else {\n            body.appendChild(importedNode);\n          }\n        } else {\n          if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && dirty.indexOf('<') === -1) {\n            return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;\n          }\n          body = _initDocument(dirty);\n          if (!body) {\n            return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';\n          }\n        }\n        if (body && FORCE_BODY) {\n          _forceRemove(body.firstChild);\n        }\n        var nodeIterator = _createIterator(IN_PLACE ? dirty : body);\n        while (currentNode = nodeIterator.nextNode()) {\n          if (currentNode.nodeType === 3 && currentNode === oldNode) {\n            continue;\n          }\n          if (_sanitizeElements(currentNode)) {\n            continue;\n          }\n          if (currentNode.content instanceof DocumentFragment) {\n            _sanitizeShadowDOM(currentNode.content);\n          }\n          _sanitizeAttributes(currentNode);\n          oldNode = currentNode;\n        }\n        oldNode = null;\n        if (IN_PLACE) {\n          return dirty;\n        }\n        if (RETURN_DOM) {\n          if (RETURN_DOM_FRAGMENT) {\n            returnNode = createDocumentFragment.call(body.ownerDocument);\n            while (body.firstChild) {\n              returnNode.appendChild(body.firstChild);\n            }\n          } else {\n            returnNode = body;\n          }\n          if (ALLOWED_ATTR.shadowroot) {\n            returnNode = importNode.call(originalDocument, returnNode, true);\n          }\n          return returnNode;\n        }\n        var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;\n        if (WHOLE_DOCUMENT && ALLOWED_TAGS['!doctype'] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {\n          serializedHTML = '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\\n' + serializedHTML;\n        }\n        if (SAFE_FOR_TEMPLATES) {\n          serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$$1, ' ');\n          serializedHTML = stringReplace(serializedHTML, ERB_EXPR$$1, ' ');\n        }\n        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;\n      };\n      DOMPurify.setConfig = function (cfg) {\n        _parseConfig(cfg);\n        SET_CONFIG = true;\n      };\n      DOMPurify.clearConfig = function () {\n        CONFIG = null;\n        SET_CONFIG = false;\n      };\n      DOMPurify.isValidAttribute = function (tag, attr, value) {\n        if (!CONFIG) {\n          _parseConfig({});\n        }\n        var lcTag = transformCaseFunc(tag);\n        var lcName = transformCaseFunc(attr);\n        return _isValidAttribute(lcTag, lcName, value);\n      };\n      DOMPurify.addHook = function (entryPoint, hookFunction) {\n        if (typeof hookFunction !== 'function') {\n          return;\n        }\n        hooks[entryPoint] = hooks[entryPoint] || [];\n        arrayPush(hooks[entryPoint], hookFunction);\n      };\n      DOMPurify.removeHook = function (entryPoint) {\n        if (hooks[entryPoint]) {\n          arrayPop(hooks[entryPoint]);\n        }\n      };\n      DOMPurify.removeHooks = function (entryPoint) {\n        if (hooks[entryPoint]) {\n          hooks[entryPoint] = [];\n        }\n      };\n      DOMPurify.removeAllHooks = function () {\n        hooks = {};\n      };\n      return DOMPurify;\n    }\n    var purify = createDOMPurify();\n\n    const removeAttrs = (node, names) => {\n      each$g(names, name => {\n        node.attr(name, null);\n      });\n    };\n    const addFontToSpansFilter = (domParser, styles, fontSizes) => {\n      domParser.addNodeFilter('font', nodes => {\n        each$g(nodes, node => {\n          const props = styles.parse(node.attr('style'));\n          const color = node.attr('color');\n          const face = node.attr('face');\n          const size = node.attr('size');\n          if (color) {\n            props.color = color;\n          }\n          if (face) {\n            props['font-family'] = face;\n          }\n          if (size) {\n            props['font-size'] = fontSizes[parseInt(node.attr('size'), 10) - 1];\n          }\n          node.name = 'span';\n          node.attr('style', styles.serialize(props));\n          removeAttrs(node, [\n            'color',\n            'face',\n            'size'\n          ]);\n        });\n      });\n    };\n    const addStrikeFilter = (domParser, schema, styles) => {\n      domParser.addNodeFilter('strike', nodes => {\n        const convertToSTag = schema.type !== 'html4';\n        each$g(nodes, node => {\n          if (convertToSTag) {\n            node.name = 's';\n          } else {\n            const props = styles.parse(node.attr('style'));\n            props['text-decoration'] = 'line-through';\n            node.name = 'span';\n            node.attr('style', styles.serialize(props));\n          }\n        });\n      });\n    };\n    const addFilters = (domParser, settings, schema) => {\n      const styles = Styles();\n      if (settings.convert_fonts_to_spans) {\n        addFontToSpansFilter(domParser, styles, Tools.explode(settings.font_size_legacy_values));\n      }\n      addStrikeFilter(domParser, schema, styles);\n    };\n    const register$5 = (domParser, settings, schema) => {\n      if (settings.inline_styles) {\n        addFilters(domParser, settings, schema);\n      }\n    };\n\n    const blobUriToBlob = url => {\n      return new Promise((resolve, reject) => {\n        const rejectWithError = () => {\n          reject('Cannot convert ' + url + ' to Blob. Resource might not exist or is inaccessible.');\n        };\n        try {\n          const xhr = new XMLHttpRequest();\n          xhr.open('GET', url, true);\n          xhr.responseType = 'blob';\n          xhr.onload = () => {\n            if (xhr.status === 200) {\n              resolve(xhr.response);\n            } else {\n              rejectWithError();\n            }\n          };\n          xhr.onerror = rejectWithError;\n          xhr.send();\n        } catch (ex) {\n          rejectWithError();\n        }\n      });\n    };\n    const parseDataUri$1 = uri => {\n      let type;\n      const uriParts = decodeURIComponent(uri).split(',');\n      const matches = /data:([^;]+)/.exec(uriParts[0]);\n      if (matches) {\n        type = matches[1];\n      }\n      return {\n        type,\n        data: uriParts[1]\n      };\n    };\n    const buildBlob = (type, data) => {\n      let str;\n      try {\n        str = atob(data);\n      } catch (e) {\n        return Optional.none();\n      }\n      const arr = new Uint8Array(str.length);\n      for (let i = 0; i < arr.length; i++) {\n        arr[i] = str.charCodeAt(i);\n      }\n      return Optional.some(new Blob([arr], { type }));\n    };\n    const dataUriToBlob = uri => {\n      return new Promise(resolve => {\n        const {type, data} = parseDataUri$1(uri);\n        buildBlob(type, data).fold(() => resolve(new Blob([])), resolve);\n      });\n    };\n    const uriToBlob = url => {\n      if (url.indexOf('blob:') === 0) {\n        return blobUriToBlob(url);\n      }\n      if (url.indexOf('data:') === 0) {\n        return dataUriToBlob(url);\n      }\n      return null;\n    };\n    const blobToDataUri = blob => {\n      return new Promise(resolve => {\n        const reader = new FileReader();\n        reader.onloadend = () => {\n          resolve(reader.result);\n        };\n        reader.readAsDataURL(blob);\n      });\n    };\n\n    let count$1 = 0;\n    const uniqueId$1 = prefix => {\n      return (prefix || 'blobid') + count$1++;\n    };\n    const imageToBlobInfo = (blobCache, img, resolve, reject) => {\n      let base64, blobInfo;\n      if (img.src.indexOf('blob:') === 0) {\n        blobInfo = blobCache.getByUri(img.src);\n        if (blobInfo) {\n          resolve({\n            image: img,\n            blobInfo\n          });\n        } else {\n          uriToBlob(img.src).then(blob => {\n            blobToDataUri(blob).then(dataUri => {\n              base64 = parseDataUri$1(dataUri).data;\n              blobInfo = blobCache.create(uniqueId$1(), blob, base64);\n              blobCache.add(blobInfo);\n              resolve({\n                image: img,\n                blobInfo\n              });\n            });\n          }, err => {\n            reject(err);\n          });\n        }\n        return;\n      }\n      const {data, type} = parseDataUri$1(img.src);\n      base64 = data;\n      blobInfo = blobCache.getByData(base64, type);\n      if (blobInfo) {\n        resolve({\n          image: img,\n          blobInfo\n        });\n      } else {\n        uriToBlob(img.src).then(blob => {\n          blobInfo = blobCache.create(uniqueId$1(), blob, base64);\n          blobCache.add(blobInfo);\n          resolve({\n            image: img,\n            blobInfo\n          });\n        }, err => {\n          reject(err);\n        });\n      }\n    };\n    const getAllImages = elm => {\n      return elm ? from(elm.getElementsByTagName('img')) : [];\n    };\n    const ImageScanner = (uploadStatus, blobCache) => {\n      const cachedPromises = {};\n      const findAll = (elm, predicate) => {\n        if (!predicate) {\n          predicate = always;\n        }\n        const images = filter$6(getAllImages(elm), img => {\n          const src = img.src;\n          if (img.hasAttribute('data-mce-bogus')) {\n            return false;\n          }\n          if (img.hasAttribute('data-mce-placeholder')) {\n            return false;\n          }\n          if (!src || src === Env.transparentSrc) {\n            return false;\n          }\n          if (src.indexOf('blob:') === 0) {\n            return !uploadStatus.isUploaded(src) && predicate(img);\n          }\n          if (src.indexOf('data:') === 0) {\n            return predicate(img);\n          }\n          return false;\n        });\n        const promises = map$3(images, img => {\n          if (cachedPromises[img.src] !== undefined) {\n            return new Promise(resolve => {\n              cachedPromises[img.src].then(imageInfo => {\n                if (typeof imageInfo === 'string') {\n                  return imageInfo;\n                }\n                resolve({\n                  image: img,\n                  blobInfo: imageInfo.blobInfo\n                });\n              });\n            });\n          }\n          const newPromise = new Promise((resolve, reject) => {\n            imageToBlobInfo(blobCache, img, resolve, reject);\n          }).then(result => {\n            delete cachedPromises[result.image.src];\n            return result;\n          }).catch(error => {\n            delete cachedPromises[img.src];\n            return error;\n          });\n          cachedPromises[img.src] = newPromise;\n          return newPromise;\n        });\n        return Promise.all(promises);\n      };\n      return { findAll };\n    };\n\n    const parseDataUri = uri => {\n      const matches = /data:([^;]+);base64,([a-z0-9\\+\\/=\\s]+)/i.exec(uri);\n      if (matches) {\n        return Optional.some({\n          type: matches[1],\n          data: decodeURIComponent(matches[2])\n        });\n      } else {\n        return Optional.none();\n      }\n    };\n\n    const isBogusImage = img => isNonNullable(img.attr('data-mce-bogus'));\n    const isInternalImageSource = img => img.attr('src') === Env.transparentSrc || isNonNullable(img.attr('data-mce-placeholder'));\n    const registerBase64ImageFilter = (parser, settings) => {\n      const {blob_cache: blobCache} = settings;\n      const processImage = img => {\n        const inputSrc = img.attr('src');\n        if (isInternalImageSource(img) || isBogusImage(img)) {\n          return;\n        }\n        parseDataUri(inputSrc).bind(({type, data}) => Optional.from(blobCache.getByData(data, type)).orThunk(() => buildBlob(type, data).map(blob => {\n          const blobInfo = blobCache.create(uniqueId$1(), blob, data);\n          blobCache.add(blobInfo);\n          return blobInfo;\n        }))).each(blobInfo => {\n          img.attr('src', blobInfo.blobUri());\n        });\n      };\n      if (blobCache) {\n        parser.addAttributeFilter('src', nodes => each$g(nodes, processImage));\n      }\n    };\n    const register$4 = (parser, settings) => {\n      const schema = parser.schema;\n      if (settings.remove_trailing_brs) {\n        parser.addNodeFilter('br', (nodes, _, args) => {\n          const blockElements = Tools.extend({}, schema.getBlockElements());\n          const nonEmptyElements = schema.getNonEmptyElements();\n          const whitespaceElements = schema.getWhitespaceElements();\n          blockElements.body = 1;\n          for (let i = 0, l = nodes.length; i < l; i++) {\n            let node = nodes[i];\n            let parent = node.parent;\n            if (blockElements[node.parent.name] && node === parent.lastChild) {\n              let prev = node.prev;\n              while (prev) {\n                const prevName = prev.name;\n                if (prevName !== 'span' || prev.attr('data-mce-type') !== 'bookmark') {\n                  if (prevName === 'br') {\n                    node = null;\n                  }\n                  break;\n                }\n                prev = prev.prev;\n              }\n              if (node) {\n                node.remove();\n                if (isEmpty(schema, nonEmptyElements, whitespaceElements, parent)) {\n                  const elementRule = schema.getElementRule(parent.name);\n                  if (elementRule) {\n                    if (elementRule.removeEmpty) {\n                      parent.remove();\n                    } else if (elementRule.paddEmpty) {\n                      paddEmptyNode(settings, args, blockElements, parent);\n                    }\n                  }\n                }\n              }\n            } else {\n              let lastParent = node;\n              while (parent && parent.firstChild === lastParent && parent.lastChild === lastParent) {\n                lastParent = parent;\n                if (blockElements[parent.name]) {\n                  break;\n                }\n                parent = parent.parent;\n              }\n              if (lastParent === parent) {\n                const textNode = new AstNode('#text', 3);\n                textNode.value = nbsp;\n                node.replace(textNode);\n              }\n            }\n          }\n        });\n      }\n      parser.addAttributeFilter('href', nodes => {\n        let i = nodes.length;\n        const appendRel = rel => {\n          const parts = rel.split(' ').filter(p => p.length > 0);\n          return parts.concat(['noopener']).sort().join(' ');\n        };\n        const addNoOpener = rel => {\n          const newRel = rel ? Tools.trim(rel) : '';\n          if (!/\\b(noopener)\\b/g.test(newRel)) {\n            return appendRel(newRel);\n          } else {\n            return newRel;\n          }\n        };\n        if (!settings.allow_unsafe_link_target) {\n          while (i--) {\n            const node = nodes[i];\n            if (node.name === 'a' && node.attr('target') === '_blank') {\n              node.attr('rel', addNoOpener(node.attr('rel')));\n            }\n          }\n        }\n      });\n      if (!settings.allow_html_in_named_anchor) {\n        parser.addAttributeFilter('id,name', nodes => {\n          let i = nodes.length, sibling, prevSibling, parent, node;\n          while (i--) {\n            node = nodes[i];\n            if (node.name === 'a' && node.firstChild && !node.attr('href')) {\n              parent = node.parent;\n              sibling = node.lastChild;\n              do {\n                prevSibling = sibling.prev;\n                parent.insert(sibling, node);\n                sibling = prevSibling;\n              } while (sibling);\n            }\n          }\n        });\n      }\n      if (settings.fix_list_elements) {\n        parser.addNodeFilter('ul,ol', nodes => {\n          let i = nodes.length, node, parentNode;\n          while (i--) {\n            node = nodes[i];\n            parentNode = node.parent;\n            if (parentNode.name === 'ul' || parentNode.name === 'ol') {\n              if (node.prev && node.prev.name === 'li') {\n                node.prev.append(node);\n              } else {\n                const li = new AstNode('li', 1);\n                li.attr('style', 'list-style-type: none');\n                node.wrap(li);\n              }\n            }\n          }\n        });\n      }\n      if (settings.validate && schema.getValidClasses()) {\n        parser.addAttributeFilter('class', nodes => {\n          const validClasses = schema.getValidClasses();\n          let i = nodes.length;\n          while (i--) {\n            const node = nodes[i];\n            const classList = node.attr('class').split(' ');\n            let classValue = '';\n            for (let ci = 0; ci < classList.length; ci++) {\n              const className = classList[ci];\n              let valid = false;\n              let validClassesMap = validClasses['*'];\n              if (validClassesMap && validClassesMap[className]) {\n                valid = true;\n              }\n              validClassesMap = validClasses[node.name];\n              if (!valid && validClassesMap && validClassesMap[className]) {\n                valid = true;\n              }\n              if (valid) {\n                if (classValue) {\n                  classValue += ' ';\n                }\n                classValue += className;\n              }\n            }\n            if (!classValue.length) {\n              classValue = null;\n            }\n            node.attr('class', classValue);\n          }\n        });\n      }\n      registerBase64ImageFilter(parser, settings);\n    };\n\n    const each$5 = Tools.each, trim = Tools.trim;\n    const queryParts = 'source protocol authority userInfo user password host port relative path directory file query anchor'.split(' ');\n    const DEFAULT_PORTS = {\n      ftp: 21,\n      http: 80,\n      https: 443,\n      mailto: 25\n    };\n    const safeSvgDataUrlElements = [\n      'img',\n      'video'\n    ];\n    const blockSvgDataUris = (allowSvgDataUrls, tagName) => {\n      if (isNonNullable(allowSvgDataUrls)) {\n        return !allowSvgDataUrls;\n      } else {\n        return isNonNullable(tagName) ? !contains$2(safeSvgDataUrlElements, tagName) : true;\n      }\n    };\n    const decodeUri = encodedUri => {\n      try {\n        return decodeURIComponent(encodedUri);\n      } catch (ex) {\n        return unescape(encodedUri);\n      }\n    };\n    const isInvalidUri = (settings, uri, tagName) => {\n      const decodedUri = decodeUri(uri);\n      if (settings.allow_script_urls) {\n        return false;\n      } else if (/((java|vb)script|mhtml):/i.test(decodedUri)) {\n        return true;\n      } else if (settings.allow_html_data_urls) {\n        return false;\n      } else if (/^data:image\\//i.test(decodedUri)) {\n        return blockSvgDataUris(settings.allow_svg_data_urls, tagName) && /^data:image\\/svg\\+xml/i.test(decodedUri);\n      } else {\n        return /^data:/i.test(decodedUri);\n      }\n    };\n    class URI {\n      constructor(url, settings) {\n        url = trim(url);\n        this.settings = settings || {};\n        const baseUri = this.settings.base_uri;\n        const self = this;\n        if (/^([\\w\\-]+):([^\\/]{2})/i.test(url) || /^\\s*#/.test(url)) {\n          self.source = url;\n          return;\n        }\n        const isProtocolRelative = url.indexOf('//') === 0;\n        if (url.indexOf('/') === 0 && !isProtocolRelative) {\n          url = (baseUri ? baseUri.protocol || 'http' : 'http') + '://mce_host' + url;\n        }\n        if (!/^[\\w\\-]*:?\\/\\//.test(url)) {\n          const baseUrl = this.settings.base_uri ? this.settings.base_uri.path : new URI(document.location.href).directory;\n          if (this.settings.base_uri && this.settings.base_uri.protocol == '') {\n            url = '//mce_host' + self.toAbsPath(baseUrl, url);\n          } else {\n            const match = /([^#?]*)([#?]?.*)/.exec(url);\n            url = (baseUri && baseUri.protocol || 'http') + '://mce_host' + self.toAbsPath(baseUrl, match[1]) + match[2];\n          }\n        }\n        url = url.replace(/@@/g, '(mce_at)');\n        const urlMatch = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@\\/]*):?([^:@\\/]*))?@)?(\\[[a-zA-Z0-9:.%]+\\]|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/.exec(url);\n        each$5(queryParts, (v, i) => {\n          let part = urlMatch[i];\n          if (part) {\n            part = part.replace(/\\(mce_at\\)/g, '@@');\n          }\n          self[v] = part;\n        });\n        if (baseUri) {\n          if (!self.protocol) {\n            self.protocol = baseUri.protocol;\n          }\n          if (!self.userInfo) {\n            self.userInfo = baseUri.userInfo;\n          }\n          if (!self.port && self.host === 'mce_host') {\n            self.port = baseUri.port;\n          }\n          if (!self.host || self.host === 'mce_host') {\n            self.host = baseUri.host;\n          }\n          self.source = '';\n        }\n        if (isProtocolRelative) {\n          self.protocol = '';\n        }\n      }\n      static parseDataUri(uri) {\n        let type;\n        const uriComponents = decodeURIComponent(uri).split(',');\n        const matches = /data:([^;]+)/.exec(uriComponents[0]);\n        if (matches) {\n          type = matches[1];\n        }\n        return {\n          type,\n          data: uriComponents[1]\n        };\n      }\n      static isDomSafe(uri, context, options = {}) {\n        if (options.allow_script_urls) {\n          return true;\n        } else {\n          const decodedUri = Entities.decode(uri).replace(/[\\s\\u0000-\\u001F]+/g, '');\n          return !isInvalidUri(options, decodedUri, context);\n        }\n      }\n      static getDocumentBaseUrl(loc) {\n        let baseUrl;\n        if (loc.protocol.indexOf('http') !== 0 && loc.protocol !== 'file:') {\n          baseUrl = loc.href;\n        } else {\n          baseUrl = loc.protocol + '//' + loc.host + loc.pathname;\n        }\n        if (/^[^:]+:\\/\\/\\/?[^\\/]+\\//.test(baseUrl)) {\n          baseUrl = baseUrl.replace(/[\\?#].*$/, '').replace(/[\\/\\\\][^\\/]+$/, '');\n          if (!/[\\/\\\\]$/.test(baseUrl)) {\n            baseUrl += '/';\n          }\n        }\n        return baseUrl;\n      }\n      setPath(path) {\n        const pathMatch = /^(.*?)\\/?(\\w+)?$/.exec(path);\n        this.path = pathMatch[0];\n        this.directory = pathMatch[1];\n        this.file = pathMatch[2];\n        this.source = '';\n        this.getURI();\n      }\n      toRelative(uri) {\n        let output;\n        if (uri === './') {\n          return uri;\n        }\n        const relativeUri = new URI(uri, { base_uri: this });\n        if (relativeUri.host !== 'mce_host' && this.host !== relativeUri.host && relativeUri.host || this.port !== relativeUri.port || this.protocol !== relativeUri.protocol && relativeUri.protocol !== '') {\n          return relativeUri.getURI();\n        }\n        const tu = this.getURI(), uu = relativeUri.getURI();\n        if (tu === uu || tu.charAt(tu.length - 1) === '/' && tu.substr(0, tu.length - 1) === uu) {\n          return tu;\n        }\n        output = this.toRelPath(this.path, relativeUri.path);\n        if (relativeUri.query) {\n          output += '?' + relativeUri.query;\n        }\n        if (relativeUri.anchor) {\n          output += '#' + relativeUri.anchor;\n        }\n        return output;\n      }\n      toAbsolute(uri, noHost) {\n        const absoluteUri = new URI(uri, { base_uri: this });\n        return absoluteUri.getURI(noHost && this.isSameOrigin(absoluteUri));\n      }\n      isSameOrigin(uri) {\n        if (this.host == uri.host && this.protocol == uri.protocol) {\n          if (this.port == uri.port) {\n            return true;\n          }\n          const defaultPort = DEFAULT_PORTS[this.protocol];\n          if (defaultPort && (this.port || defaultPort) == (uri.port || defaultPort)) {\n            return true;\n          }\n        }\n        return false;\n      }\n      toRelPath(base, path) {\n        let breakPoint = 0, out = '', i, l;\n        const normalizedBase = base.substring(0, base.lastIndexOf('/')).split('/');\n        const items = path.split('/');\n        if (normalizedBase.length >= items.length) {\n          for (i = 0, l = normalizedBase.length; i < l; i++) {\n            if (i >= items.length || normalizedBase[i] !== items[i]) {\n              breakPoint = i + 1;\n              break;\n            }\n          }\n        }\n        if (normalizedBase.length < items.length) {\n          for (i = 0, l = items.length; i < l; i++) {\n            if (i >= normalizedBase.length || normalizedBase[i] !== items[i]) {\n              breakPoint = i + 1;\n              break;\n            }\n          }\n        }\n        if (breakPoint === 1) {\n          return path;\n        }\n        for (i = 0, l = normalizedBase.length - (breakPoint - 1); i < l; i++) {\n          out += '../';\n        }\n        for (i = breakPoint - 1, l = items.length; i < l; i++) {\n          if (i !== breakPoint - 1) {\n            out += '/' + items[i];\n          } else {\n            out += items[i];\n          }\n        }\n        return out;\n      }\n      toAbsPath(base, path) {\n        let i, nb = 0, o = [], outPath;\n        const tr = /\\/$/.test(path) ? '/' : '';\n        let normalizedBase = base.split('/');\n        const normalizedPath = path.split('/');\n        each$5(normalizedBase, k => {\n          if (k) {\n            o.push(k);\n          }\n        });\n        normalizedBase = o;\n        for (i = normalizedPath.length - 1, o = []; i >= 0; i--) {\n          if (normalizedPath[i].length === 0 || normalizedPath[i] === '.') {\n            continue;\n          }\n          if (normalizedPath[i] === '..') {\n            nb++;\n            continue;\n          }\n          if (nb > 0) {\n            nb--;\n            continue;\n          }\n          o.push(normalizedPath[i]);\n        }\n        i = normalizedBase.length - nb;\n        if (i <= 0) {\n          outPath = reverse(o).join('/');\n        } else {\n          outPath = normalizedBase.slice(0, i).join('/') + '/' + reverse(o).join('/');\n        }\n        if (outPath.indexOf('/') !== 0) {\n          outPath = '/' + outPath;\n        }\n        if (tr && outPath.lastIndexOf('/') !== outPath.length - 1) {\n          outPath += tr;\n        }\n        return outPath;\n      }\n      getURI(noProtoHost = false) {\n        let s;\n        if (!this.source || noProtoHost) {\n          s = '';\n          if (!noProtoHost) {\n            if (this.protocol) {\n              s += this.protocol + '://';\n            } else {\n              s += '//';\n            }\n            if (this.userInfo) {\n              s += this.userInfo + '@';\n            }\n            if (this.host) {\n              s += this.host;\n            }\n            if (this.port) {\n              s += ':' + this.port;\n            }\n          }\n          if (this.path) {\n            s += this.path;\n          }\n          if (this.query) {\n            s += '?' + this.query;\n          }\n          if (this.anchor) {\n            s += '#' + this.anchor;\n          }\n          this.source = s;\n        }\n        return this.source;\n      }\n    }\n\n    const makeMap = Tools.makeMap, each$4 = Tools.each, explode$1 = Tools.explode, extend$1 = Tools.extend;\n    const basePurifyConfig = {\n      IN_PLACE: true,\n      ALLOW_UNKNOWN_PROTOCOLS: true,\n      ALLOWED_TAGS: [\n        '#comment',\n        '#cdata-section',\n        'body'\n      ],\n      ALLOWED_ATTR: []\n    };\n    const filteredUrlAttrs = Tools.makeMap('src,href,data,background,action,formaction,poster,xlink:href');\n    const internalElementAttr = 'data-mce-type';\n    const getPurifyConfig = (settings, mimeType) => {\n      const config = { ...basePurifyConfig };\n      config.PARSER_MEDIA_TYPE = mimeType;\n      if (settings.allow_script_urls) {\n        config.ALLOWED_URI_REGEXP = /.*/;\n      } else if (settings.allow_html_data_urls) {\n        config.ALLOWED_URI_REGEXP = /^(?!(\\w+script|mhtml):)/i;\n      }\n      return config;\n    };\n    const setupPurify = (settings, schema) => {\n      const purify$1 = purify();\n      const validate = settings.validate;\n      let uid = 0;\n      purify$1.addHook('uponSanitizeElement', (ele, evt) => {\n        var _a, _b;\n        if (ele.nodeType === COMMENT && !settings.allow_conditional_comments && /^\\[if/i.test(ele.nodeValue)) {\n          ele.nodeValue = ' ' + ele.nodeValue;\n        }\n        const tagName = evt.tagName;\n        if (ele.nodeType !== ELEMENT || tagName === 'body') {\n          return;\n        }\n        const element = SugarElement.fromDom(ele);\n        const isInternalElement = has$1(element, internalElementAttr);\n        const bogus = get$9(element, 'data-mce-bogus');\n        if (!isInternalElement && isString(bogus)) {\n          if (bogus === 'all') {\n            remove$5(element);\n          } else {\n            unwrap(element);\n          }\n          return;\n        }\n        const rule = schema.getElementRule(tagName.toLowerCase());\n        if (validate && !rule) {\n          unwrap(element);\n          return;\n        } else {\n          evt.allowedTags[tagName] = true;\n        }\n        if (validate && !isInternalElement) {\n          each$g((_a = rule.attributesForced) !== null && _a !== void 0 ? _a : [], attr => {\n            set$2(element, attr.name, attr.value === '{$uid}' ? `mce_${ uid++ }` : attr.value);\n          });\n          each$g((_b = rule.attributesDefault) !== null && _b !== void 0 ? _b : [], attr => {\n            if (!has$1(element, attr.name)) {\n              set$2(element, attr.name, attr.value === '{$uid}' ? `mce_${ uid++ }` : attr.value);\n            }\n          });\n          if (rule.attributesRequired && !exists(rule.attributesRequired, attr => has$1(element, attr))) {\n            unwrap(element);\n            return;\n          }\n          if (rule.removeEmptyAttrs && hasNone(element)) {\n            unwrap(element);\n            return;\n          }\n          if (rule.outputName && rule.outputName !== tagName.toLowerCase()) {\n            mutate(element, rule.outputName);\n          }\n        }\n      });\n      purify$1.addHook('uponSanitizeAttribute', (ele, evt) => {\n        const tagName = ele.tagName.toLowerCase();\n        const {attrName, attrValue} = evt;\n        evt.keepAttr = !validate || schema.isValid(tagName, attrName) || startsWith(attrName, 'data-') || startsWith(attrName, 'aria-');\n        if (attrName in filteredUrlAttrs && isInvalidUri(settings, attrValue, tagName)) {\n          evt.keepAttr = false;\n        }\n        if (evt.keepAttr) {\n          evt.allowedAttributes[attrName] = true;\n          if (attrName in schema.getBoolAttrs()) {\n            evt.attrValue = attrName;\n          }\n          if (settings.allow_svg_data_urls && startsWith(attrValue, 'data:image/svg+xml')) {\n            evt.forceKeepAttr = true;\n          }\n        } else if (ele.hasAttribute(internalElementAttr) && (attrName === 'id' || attrName === 'class' || attrName === 'style')) {\n          evt.forceKeepAttr = true;\n        }\n      });\n      return purify$1;\n    };\n    const transferChildren = (parent, nativeParent, specialElements) => {\n      const parentName = parent.name;\n      const isSpecial = parentName in specialElements && parentName !== 'title' && parentName !== 'textarea';\n      const childNodes = nativeParent.childNodes;\n      for (let ni = 0, nl = childNodes.length; ni < nl; ni++) {\n        const nativeChild = childNodes[ni];\n        const child = new AstNode(nativeChild.nodeName.toLowerCase(), nativeChild.nodeType);\n        if (isElement$6(nativeChild)) {\n          const attributes = nativeChild.attributes;\n          for (let ai = 0, al = attributes.length; ai < al; ai++) {\n            const attr = attributes[ai];\n            child.attr(attr.name, attr.value);\n          }\n        } else if (isText$8(nativeChild)) {\n          child.value = nativeChild.data;\n          if (isSpecial) {\n            child.raw = true;\n          }\n        } else if (isComment(nativeChild) || isCData(nativeChild) || isPi(nativeChild)) {\n          child.value = nativeChild.data;\n        }\n        transferChildren(child, nativeChild, specialElements);\n        parent.append(child);\n      }\n    };\n    const walkTree = (root, preprocessors, postprocessors) => {\n      const traverseOrder = [];\n      for (let node = root, lastNode = node; isNonNullable(node); lastNode = node, node = node.walk()) {\n        each$g(preprocessors, preprocess => preprocess(node));\n        if (isNullable(node.parent) && node !== root) {\n          node = lastNode;\n        } else {\n          traverseOrder.push(node);\n        }\n      }\n      for (let i = traverseOrder.length - 1; i >= 0; i--) {\n        const node = traverseOrder[i];\n        each$g(postprocessors, postprocess => postprocess(node));\n      }\n    };\n    const whitespaceCleaner = (root, schema, settings, args) => {\n      const validate = settings.validate;\n      const nonEmptyElements = schema.getNonEmptyElements();\n      const whitespaceElements = schema.getWhitespaceElements();\n      const blockElements = extend$1(makeMap('script,style,head,html,body,title,meta,param'), schema.getBlockElements());\n      const textRootBlockElements = getTextRootBlockElements(schema);\n      const allWhiteSpaceRegExp = /[ \\t\\r\\n]+/g;\n      const startWhiteSpaceRegExp = /^[ \\t\\r\\n]+/;\n      const endWhiteSpaceRegExp = /[ \\t\\r\\n]+$/;\n      const hasWhitespaceParent = node => {\n        node = node.parent;\n        while (isNonNullable(node)) {\n          if (node.name in whitespaceElements) {\n            return true;\n          } else {\n            node = node.parent;\n          }\n        }\n        return false;\n      };\n      const isTextRootBlockEmpty = node => {\n        let tempNode = node;\n        while (isNonNullable(tempNode)) {\n          if (tempNode.name in textRootBlockElements) {\n            return isEmpty(schema, nonEmptyElements, whitespaceElements, tempNode);\n          } else {\n            tempNode = tempNode.parent;\n          }\n        }\n        return false;\n      };\n      const isAtEdgeOfBlock = (node, start) => {\n        const neighbour = start ? node.prev : node.next;\n        if (isNonNullable(neighbour)) {\n          return false;\n        }\n        return node.parent.name in blockElements && (node.parent !== root || args.isRootContent);\n      };\n      const preprocess = node => {\n        if (node.type === 3) {\n          if (!hasWhitespaceParent(node)) {\n            let text = node.value;\n            text = text.replace(allWhiteSpaceRegExp, ' ');\n            if (isLineBreakNode(node.prev, blockElements) || isAtEdgeOfBlock(node, true)) {\n              text = text.replace(startWhiteSpaceRegExp, '');\n            }\n            if (text.length === 0) {\n              node.remove();\n            } else {\n              node.value = text;\n            }\n          }\n        }\n      };\n      const postprocess = node => {\n        var _a;\n        if (node.type === 1) {\n          const elementRule = schema.getElementRule(node.name);\n          if (validate && elementRule) {\n            const isNodeEmpty = isEmpty(schema, nonEmptyElements, whitespaceElements, node);\n            if (elementRule.paddInEmptyBlock && isNodeEmpty && isTextRootBlockEmpty(node)) {\n              paddEmptyNode(settings, args, blockElements, node);\n            } else if (elementRule.removeEmpty && isNodeEmpty) {\n              if (blockElements[node.name]) {\n                node.remove();\n              } else {\n                node.unwrap();\n              }\n            } else if (elementRule.paddEmpty && (isNodeEmpty || isPaddedWithNbsp(node))) {\n              paddEmptyNode(settings, args, blockElements, node);\n            }\n          }\n        } else if (node.type === 3) {\n          if (!hasWhitespaceParent(node)) {\n            let text = node.value;\n            if (blockElements[(_a = node.next) === null || _a === void 0 ? void 0 : _a.name] || isAtEdgeOfBlock(node, false)) {\n              text = text.replace(endWhiteSpaceRegExp, '');\n            }\n            if (text.length === 0) {\n              node.remove();\n            } else {\n              node.value = text;\n            }\n          }\n        }\n      };\n      return [\n        preprocess,\n        postprocess\n      ];\n    };\n    const getRootBlockName = (settings, args) => {\n      var _a;\n      const name = (_a = args.forced_root_block) !== null && _a !== void 0 ? _a : settings.forced_root_block;\n      if (name === false) {\n        return '';\n      } else if (name === true) {\n        return 'p';\n      } else {\n        return name;\n      }\n    };\n    const DomParser = (settings = {}, schema = Schema()) => {\n      const nodeFilters = {};\n      const attributeFilters = [];\n      const defaultedSettings = {\n        validate: true,\n        root_name: 'body',\n        ...settings\n      };\n      const parser = new DOMParser();\n      const purify = setupPurify(defaultedSettings, schema);\n      const parseAndSanitizeWithContext = (html, rootName, format = 'html') => {\n        const mimeType = format === 'xhtml' ? 'application/xhtml+xml' : 'text/html';\n        const isSpecialRoot = has$2(schema.getSpecialElements(), rootName.toLowerCase());\n        const content = isSpecialRoot ? `<${ rootName }>${ html }</${ rootName }>` : html;\n        const wrappedHtml = format === 'xhtml' ? `<html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head><body>${ content }</body></html>` : `<body>${ content }</body>`;\n        const body = parser.parseFromString(wrappedHtml, mimeType).body;\n        purify.sanitize(body, getPurifyConfig(defaultedSettings, mimeType));\n        purify.removed = [];\n        return isSpecialRoot ? body.firstChild : body;\n      };\n      const addNodeFilter = (name, callback) => {\n        each$4(explode$1(name), name => {\n          let list = nodeFilters[name];\n          if (!list) {\n            nodeFilters[name] = list = [];\n          }\n          list.push(callback);\n        });\n      };\n      const getNodeFilters = () => {\n        const out = [];\n        for (const name in nodeFilters) {\n          if (has$2(nodeFilters, name)) {\n            out.push({\n              name,\n              callbacks: nodeFilters[name]\n            });\n          }\n        }\n        return out;\n      };\n      const addAttributeFilter = (name, callback) => {\n        each$4(explode$1(name), name => {\n          let i;\n          for (i = 0; i < attributeFilters.length; i++) {\n            if (attributeFilters[i].name === name) {\n              attributeFilters[i].callbacks.push(callback);\n              return;\n            }\n          }\n          attributeFilters.push({\n            name,\n            callbacks: [callback]\n          });\n        });\n      };\n      const getAttributeFilters = () => [].concat(attributeFilters);\n      const findInvalidChildren = (node, invalidChildren) => {\n        const parent = node.parent;\n        if (parent && schema.children[node.name] && !schema.isValidChild(parent.name, node.name)) {\n          invalidChildren.push(node);\n        }\n      };\n      const addRootBlocks = (rootNode, rootBlockName) => {\n        const blockElements = extend$1(makeMap('script,style,head,html,body,title,meta,param'), schema.getBlockElements());\n        const startWhiteSpaceRegExp = /^[ \\t\\r\\n]+/;\n        const endWhiteSpaceRegExp = /[ \\t\\r\\n]+$/;\n        let node = rootNode.firstChild, rootBlockNode = null;\n        const trim = rootBlock => {\n          if (rootBlock) {\n            node = rootBlock.firstChild;\n            if (node && node.type === 3) {\n              node.value = node.value.replace(startWhiteSpaceRegExp, '');\n            }\n            node = rootBlock.lastChild;\n            if (node && node.type === 3) {\n              node.value = node.value.replace(endWhiteSpaceRegExp, '');\n            }\n          }\n        };\n        if (!schema.isValidChild(rootNode.name, rootBlockName.toLowerCase())) {\n          return;\n        }\n        while (node) {\n          const next = node.next;\n          if (node.type === 3 || node.type === 1 && node.name !== 'p' && !blockElements[node.name] && !node.attr(internalElementAttr)) {\n            if (!rootBlockNode) {\n              rootBlockNode = new AstNode(rootBlockName, 1);\n              rootBlockNode.attr(defaultedSettings.forced_root_block_attrs);\n              rootNode.insert(rootBlockNode, node);\n              rootBlockNode.append(node);\n            } else {\n              rootBlockNode.append(node);\n            }\n          } else {\n            trim(rootBlockNode);\n            rootBlockNode = null;\n          }\n          node = next;\n        }\n        trim(rootBlockNode);\n      };\n      const parse = (html, args = {}) => {\n        var _a;\n        const validate = defaultedSettings.validate;\n        const rootName = (_a = args.context) !== null && _a !== void 0 ? _a : defaultedSettings.root_name;\n        const element = parseAndSanitizeWithContext(html, rootName, args.format);\n        const rootNode = new AstNode(rootName, 11);\n        transferChildren(rootNode, element, schema.getSpecialElements());\n        const [whitespacePre, whitespacePost] = whitespaceCleaner(rootNode, schema, defaultedSettings, args);\n        const invalidChildren = [];\n        const invalidFinder = validate ? node => findInvalidChildren(node, invalidChildren) : noop;\n        const nodeFilters = getNodeFilters();\n        const matches = {\n          nodes: {},\n          attributes: {}\n        };\n        const matchFinder = node => matchNode$1(nodeFilters, attributeFilters, node, matches);\n        walkTree(rootNode, [\n          whitespacePre,\n          matchFinder\n        ], [\n          whitespacePost,\n          invalidFinder\n        ]);\n        invalidChildren.reverse();\n        if (validate && invalidChildren.length > 0) {\n          if (args.context) {\n            const {\n              pass: topLevelChildren,\n              fail: otherChildren\n            } = partition$2(invalidChildren, child => child.parent === rootNode);\n            cleanInvalidNodes(otherChildren, schema, matchFinder);\n            args.invalid = topLevelChildren.length > 0;\n          } else {\n            cleanInvalidNodes(invalidChildren, schema, matchFinder);\n          }\n        }\n        const rootBlockName = getRootBlockName(defaultedSettings, args);\n        if (rootBlockName && (rootNode.name === 'body' || args.isRootContent)) {\n          addRootBlocks(rootNode, rootBlockName);\n        }\n        if (!args.invalid) {\n          runFilters(matches, args);\n        }\n        return rootNode;\n      };\n      const exports = {\n        schema,\n        addAttributeFilter,\n        getAttributeFilters,\n        addNodeFilter,\n        getNodeFilters,\n        parse\n      };\n      register$4(exports, defaultedSettings);\n      register$5(exports, defaultedSettings, schema);\n      return exports;\n    };\n\n    const serializeContent = content => isTreeNode(content) ? HtmlSerializer({ validate: false }).serialize(content) : content;\n    const withSerializedContent = (content, fireEvent) => {\n      const serializedContent = serializeContent(content);\n      const eventArgs = fireEvent(serializedContent);\n      if (eventArgs.isDefaultPrevented()) {\n        return eventArgs;\n      } else if (isTreeNode(content)) {\n        if (eventArgs.content !== serializedContent) {\n          const rootNode = DomParser({\n            validate: false,\n            forced_root_block: false\n          }).parse(eventArgs.content, { context: content.name });\n          return {\n            ...eventArgs,\n            content: rootNode\n          };\n        } else {\n          return {\n            ...eventArgs,\n            content\n          };\n        }\n      } else {\n        return eventArgs;\n      }\n    };\n    const preProcessGetContent = (editor, args) => {\n      if (args.no_events) {\n        return Result.value(args);\n      } else {\n        const eventArgs = fireBeforeGetContent(editor, args);\n        if (eventArgs.isDefaultPrevented()) {\n          return Result.error(fireGetContent(editor, {\n            content: '',\n            ...eventArgs\n          }).content);\n        } else {\n          return Result.value(eventArgs);\n        }\n      }\n    };\n    const postProcessGetContent = (editor, content, args) => {\n      if (args.no_events) {\n        return content;\n      } else {\n        const processedEventArgs = withSerializedContent(content, c => fireGetContent(editor, {\n          ...args,\n          content: c\n        }));\n        return processedEventArgs.content;\n      }\n    };\n    const preProcessSetContent = (editor, args) => {\n      if (args.no_events) {\n        return Result.value(args);\n      } else {\n        const processedEventArgs = withSerializedContent(args.content, content => fireBeforeSetContent(editor, {\n          ...args,\n          content\n        }));\n        if (processedEventArgs.isDefaultPrevented()) {\n          fireSetContent(editor, processedEventArgs);\n          return Result.error(undefined);\n        } else {\n          return Result.value(processedEventArgs);\n        }\n      }\n    };\n    const postProcessSetContent = (editor, content, args) => {\n      if (!args.no_events) {\n        fireSetContent(editor, {\n          ...args,\n          content\n        });\n      }\n    };\n\n    const tableModel = (element, width, rows) => ({\n      element,\n      width,\n      rows\n    });\n    const tableRow = (element, cells) => ({\n      element,\n      cells\n    });\n    const cellPosition = (x, y) => ({\n      x,\n      y\n    });\n    const getSpan = (td, key) => {\n      const value = parseInt(get$9(td, key), 10);\n      return isNaN(value) ? 1 : value;\n    };\n    const fillout = (table, x, y, tr, td) => {\n      const rowspan = getSpan(td, 'rowspan');\n      const colspan = getSpan(td, 'colspan');\n      const rows = table.rows;\n      for (let y2 = y; y2 < y + rowspan; y2++) {\n        if (!rows[y2]) {\n          rows[y2] = tableRow(deep$1(tr), []);\n        }\n        for (let x2 = x; x2 < x + colspan; x2++) {\n          const cells = rows[y2].cells;\n          cells[x2] = y2 === y && x2 === x ? td : shallow$1(td);\n        }\n      }\n    };\n    const cellExists = (table, x, y) => {\n      const rows = table.rows;\n      const cells = rows[y] ? rows[y].cells : [];\n      return !!cells[x];\n    };\n    const skipCellsX = (table, x, y) => {\n      while (cellExists(table, x, y)) {\n        x++;\n      }\n      return x;\n    };\n    const getWidth = rows => {\n      return foldl(rows, (acc, row) => {\n        return row.cells.length > acc ? row.cells.length : acc;\n      }, 0);\n    };\n    const findElementPos = (table, element) => {\n      const rows = table.rows;\n      for (let y = 0; y < rows.length; y++) {\n        const cells = rows[y].cells;\n        for (let x = 0; x < cells.length; x++) {\n          if (eq(cells[x], element)) {\n            return Optional.some(cellPosition(x, y));\n          }\n        }\n      }\n      return Optional.none();\n    };\n    const extractRows = (table, sx, sy, ex, ey) => {\n      const newRows = [];\n      const rows = table.rows;\n      for (let y = sy; y <= ey; y++) {\n        const cells = rows[y].cells;\n        const slice = sx < ex ? cells.slice(sx, ex + 1) : cells.slice(ex, sx + 1);\n        newRows.push(tableRow(rows[y].element, slice));\n      }\n      return newRows;\n    };\n    const subTable = (table, startPos, endPos) => {\n      const sx = startPos.x, sy = startPos.y;\n      const ex = endPos.x, ey = endPos.y;\n      const newRows = sy < ey ? extractRows(table, sx, sy, ex, ey) : extractRows(table, sx, ey, ex, sy);\n      return tableModel(table.element, getWidth(newRows), newRows);\n    };\n    const createDomTable = (table, rows) => {\n      const tableElement = shallow$1(table.element);\n      const tableBody = SugarElement.fromTag('tbody');\n      append(tableBody, rows);\n      append$1(tableElement, tableBody);\n      return tableElement;\n    };\n    const modelRowsToDomRows = table => {\n      return map$3(table.rows, row => {\n        const cells = map$3(row.cells, cell => {\n          const td = deep$1(cell);\n          remove$a(td, 'colspan');\n          remove$a(td, 'rowspan');\n          return td;\n        });\n        const tr = shallow$1(row.element);\n        append(tr, cells);\n        return tr;\n      });\n    };\n    const fromDom = tableElm => {\n      const table = tableModel(shallow$1(tableElm), 0, []);\n      each$g(descendants(tableElm, 'tr'), (tr, y) => {\n        each$g(descendants(tr, 'td,th'), (td, x) => {\n          fillout(table, skipCellsX(table, x, y), y, tr, td);\n        });\n      });\n      return tableModel(table.element, getWidth(table.rows), table.rows);\n    };\n    const toDom = table => {\n      return createDomTable(table, modelRowsToDomRows(table));\n    };\n    const subsection = (table, startElement, endElement) => {\n      return findElementPos(table, startElement).bind(startPos => {\n        return findElementPos(table, endElement).map(endPos => {\n          return subTable(table, startPos, endPos);\n        });\n      });\n    };\n\n    const findParentListContainer = parents => find$2(parents, elm => name(elm) === 'ul' || name(elm) === 'ol');\n    const getFullySelectedListWrappers = (parents, rng) => find$2(parents, elm => name(elm) === 'li' && hasAllContentsSelected(elm, rng)).fold(constant([]), _li => findParentListContainer(parents).map(listCont => {\n      const listElm = SugarElement.fromTag(name(listCont));\n      const listStyles = filter$5(getAllRaw(listCont), (_style, name) => startsWith(name, 'list-style'));\n      setAll(listElm, listStyles);\n      return [\n        SugarElement.fromTag('li'),\n        listElm\n      ];\n    }).getOr([]));\n    const wrap = (innerElm, elms) => {\n      const wrapped = foldl(elms, (acc, elm) => {\n        append$1(elm, acc);\n        return elm;\n      }, innerElm);\n      return elms.length > 0 ? fromElements([wrapped]) : wrapped;\n    };\n    const directListWrappers = commonAnchorContainer => {\n      if (isListItem(commonAnchorContainer)) {\n        return parent(commonAnchorContainer).filter(isList).fold(constant([]), listElm => [\n          commonAnchorContainer,\n          listElm\n        ]);\n      } else {\n        return isList(commonAnchorContainer) ? [commonAnchorContainer] : [];\n      }\n    };\n    const getWrapElements = (rootNode, rng) => {\n      const commonAnchorContainer = SugarElement.fromDom(rng.commonAncestorContainer);\n      const parents = parentsAndSelf(commonAnchorContainer, rootNode);\n      const wrapElements = filter$6(parents, elm => isInline$1(elm) || isHeading(elm));\n      const listWrappers = getFullySelectedListWrappers(parents, rng);\n      const allWrappers = wrapElements.concat(listWrappers.length ? listWrappers : directListWrappers(commonAnchorContainer));\n      return map$3(allWrappers, shallow$1);\n    };\n    const emptyFragment = () => fromElements([]);\n    const getFragmentFromRange = (rootNode, rng) => wrap(SugarElement.fromDom(rng.cloneContents()), getWrapElements(rootNode, rng));\n    const getParentTable = (rootElm, cell) => ancestor$2(cell, 'table', curry(eq, rootElm));\n    const getTableFragment = (rootNode, selectedTableCells) => getParentTable(rootNode, selectedTableCells[0]).bind(tableElm => {\n      const firstCell = selectedTableCells[0];\n      const lastCell = selectedTableCells[selectedTableCells.length - 1];\n      const fullTableModel = fromDom(tableElm);\n      return subsection(fullTableModel, firstCell, lastCell).map(sectionedTableModel => fromElements([toDom(sectionedTableModel)]));\n    }).getOrThunk(emptyFragment);\n    const getSelectionFragment = (rootNode, ranges) => ranges.length > 0 && ranges[0].collapsed ? emptyFragment() : getFragmentFromRange(rootNode, ranges[0]);\n    const read$3 = (rootNode, ranges) => {\n      const selectedCells = getCellsFromElementOrRanges(ranges, rootNode);\n      return selectedCells.length > 0 ? getTableFragment(rootNode, selectedCells) : getSelectionFragment(rootNode, ranges);\n    };\n\n    const isCollapsibleWhitespace = (text, index) => index >= 0 && index < text.length && isWhiteSpace(text.charAt(index));\n    const getInnerText = bin => {\n      return trim$1(bin.innerText);\n    };\n    const getContextNodeName = parentBlockOpt => parentBlockOpt.map(block => block.nodeName).getOr('div').toLowerCase();\n    const getTextContent = editor => Optional.from(editor.selection.getRng()).map(rng => {\n      const parentBlockOpt = Optional.from(editor.dom.getParent(rng.commonAncestorContainer, editor.dom.isBlock));\n      const body = editor.getBody();\n      const contextNodeName = getContextNodeName(parentBlockOpt);\n      const bin = editor.dom.add(body, contextNodeName, {\n        'data-mce-bogus': 'all',\n        'style': 'overflow: hidden; opacity: 0;'\n      }, rng.cloneContents());\n      const text = getInnerText(bin);\n      const nonRenderedText = trim$1(bin.textContent);\n      editor.dom.remove(bin);\n      if (isCollapsibleWhitespace(nonRenderedText, 0) || isCollapsibleWhitespace(nonRenderedText, nonRenderedText.length - 1)) {\n        const parentBlock = parentBlockOpt.getOr(body);\n        const parentBlockText = getInnerText(parentBlock);\n        const textIndex = parentBlockText.indexOf(text);\n        if (textIndex === -1) {\n          return text;\n        } else {\n          const hasProceedingSpace = isCollapsibleWhitespace(parentBlockText, textIndex - 1);\n          const hasTrailingSpace = isCollapsibleWhitespace(parentBlockText, textIndex + text.length);\n          return (hasProceedingSpace ? ' ' : '') + text + (hasTrailingSpace ? ' ' : '');\n        }\n      } else {\n        return text;\n      }\n    }).getOr('');\n    const getSerializedContent = (editor, args) => {\n      const rng = editor.selection.getRng(), tmpElm = editor.dom.create('body');\n      const sel = editor.selection.getSel();\n      const ranges = processRanges(editor, getRanges$1(sel));\n      const fragment = args.contextual ? read$3(SugarElement.fromDom(editor.getBody()), ranges).dom : rng.cloneContents();\n      if (fragment) {\n        tmpElm.appendChild(fragment);\n      }\n      return editor.selection.serializer.serialize(tmpElm, args);\n    };\n    const extractSelectedContent = (editor, args) => {\n      if (args.format === 'text') {\n        return getTextContent(editor);\n      } else {\n        const content = getSerializedContent(editor, args);\n        if (args.format === 'tree') {\n          return content;\n        } else {\n          return editor.selection.isCollapsed() ? '' : content;\n        }\n      }\n    };\n    const setupArgs$3 = (args, format) => ({\n      ...args,\n      format,\n      get: true,\n      selection: true,\n      getInner: true\n    });\n    const getSelectedContentInternal = (editor, format, args = {}) => {\n      const defaultedArgs = setupArgs$3(args, format);\n      return preProcessGetContent(editor, defaultedArgs).fold(identity, updatedArgs => {\n        const content = extractSelectedContent(editor, updatedArgs);\n        return postProcessGetContent(editor, content, updatedArgs);\n      });\n    };\n\n    const KEEP = 0, INSERT = 1, DELETE = 2;\n    const diff = (left, right) => {\n      const size = left.length + right.length + 2;\n      const vDown = new Array(size);\n      const vUp = new Array(size);\n      const snake = (start, end, diag) => {\n        return {\n          start,\n          end,\n          diag\n        };\n      };\n      const buildScript = (start1, end1, start2, end2, script) => {\n        const middle = getMiddleSnake(start1, end1, start2, end2);\n        if (middle === null || middle.start === end1 && middle.diag === end1 - end2 || middle.end === start1 && middle.diag === start1 - start2) {\n          let i = start1;\n          let j = start2;\n          while (i < end1 || j < end2) {\n            if (i < end1 && j < end2 && left[i] === right[j]) {\n              script.push([\n                KEEP,\n                left[i]\n              ]);\n              ++i;\n              ++j;\n            } else {\n              if (end1 - start1 > end2 - start2) {\n                script.push([\n                  DELETE,\n                  left[i]\n                ]);\n                ++i;\n              } else {\n                script.push([\n                  INSERT,\n                  right[j]\n                ]);\n                ++j;\n              }\n            }\n          }\n        } else {\n          buildScript(start1, middle.start, start2, middle.start - middle.diag, script);\n          for (let i2 = middle.start; i2 < middle.end; ++i2) {\n            script.push([\n              KEEP,\n              left[i2]\n            ]);\n          }\n          buildScript(middle.end, end1, middle.end - middle.diag, end2, script);\n        }\n      };\n      const buildSnake = (start, diag, end1, end2) => {\n        let end = start;\n        while (end - diag < end2 && end < end1 && left[end] === right[end - diag]) {\n          ++end;\n        }\n        return snake(start, end, diag);\n      };\n      const getMiddleSnake = (start1, end1, start2, end2) => {\n        const m = end1 - start1;\n        const n = end2 - start2;\n        if (m === 0 || n === 0) {\n          return null;\n        }\n        const delta = m - n;\n        const sum = n + m;\n        const offset = (sum % 2 === 0 ? sum : sum + 1) / 2;\n        vDown[1 + offset] = start1;\n        vUp[1 + offset] = end1 + 1;\n        let d, k, i, x, y;\n        for (d = 0; d <= offset; ++d) {\n          for (k = -d; k <= d; k += 2) {\n            i = k + offset;\n            if (k === -d || k !== d && vDown[i - 1] < vDown[i + 1]) {\n              vDown[i] = vDown[i + 1];\n            } else {\n              vDown[i] = vDown[i - 1] + 1;\n            }\n            x = vDown[i];\n            y = x - start1 + start2 - k;\n            while (x < end1 && y < end2 && left[x] === right[y]) {\n              vDown[i] = ++x;\n              ++y;\n            }\n            if (delta % 2 !== 0 && delta - d <= k && k <= delta + d) {\n              if (vUp[i - delta] <= vDown[i]) {\n                return buildSnake(vUp[i - delta], k + start1 - start2, end1, end2);\n              }\n            }\n          }\n          for (k = delta - d; k <= delta + d; k += 2) {\n            i = k + offset - delta;\n            if (k === delta - d || k !== delta + d && vUp[i + 1] <= vUp[i - 1]) {\n              vUp[i] = vUp[i + 1] - 1;\n            } else {\n              vUp[i] = vUp[i - 1];\n            }\n            x = vUp[i] - 1;\n            y = x - start1 + start2 - k;\n            while (x >= start1 && y >= start2 && left[x] === right[y]) {\n              vUp[i] = x--;\n              y--;\n            }\n            if (delta % 2 === 0 && -d <= k && k <= d) {\n              if (vUp[i] <= vDown[i + delta]) {\n                return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n              }\n            }\n          }\n        }\n      };\n      const script = [];\n      buildScript(0, left.length, 0, right.length, script);\n      return script;\n    };\n\n    const getOuterHtml = elm => {\n      if (isElement$6(elm)) {\n        return elm.outerHTML;\n      } else if (isText$8(elm)) {\n        return Entities.encodeRaw(elm.data, false);\n      } else if (isComment(elm)) {\n        return '<!--' + elm.data + '-->';\n      }\n      return '';\n    };\n    const createFragment = html => {\n      let node;\n      const container = document.createElement('div');\n      const frag = document.createDocumentFragment();\n      if (html) {\n        container.innerHTML = html;\n      }\n      while (node = container.firstChild) {\n        frag.appendChild(node);\n      }\n      return frag;\n    };\n    const insertAt = (elm, html, index) => {\n      const fragment = createFragment(html);\n      if (elm.hasChildNodes() && index < elm.childNodes.length) {\n        const target = elm.childNodes[index];\n        target.parentNode.insertBefore(fragment, target);\n      } else {\n        elm.appendChild(fragment);\n      }\n    };\n    const removeAt = (elm, index) => {\n      if (elm.hasChildNodes() && index < elm.childNodes.length) {\n        const target = elm.childNodes[index];\n        target.parentNode.removeChild(target);\n      }\n    };\n    const applyDiff = (diff, elm) => {\n      let index = 0;\n      each$g(diff, action => {\n        if (action[0] === KEEP) {\n          index++;\n        } else if (action[0] === INSERT) {\n          insertAt(elm, action[1], index);\n          index++;\n        } else if (action[0] === DELETE) {\n          removeAt(elm, index);\n        }\n      });\n    };\n    const read$2 = elm => {\n      return filter$6(map$3(from(elm.childNodes), getOuterHtml), item => {\n        return item.length > 0;\n      });\n    };\n    const write = (fragments, elm) => {\n      const currentFragments = map$3(from(elm.childNodes), getOuterHtml);\n      applyDiff(diff(currentFragments, fragments), elm);\n      return elm;\n    };\n\n    const lazyTempDocument = cached(() => document.implementation.createHTMLDocument('undo'));\n    const hasIframes = html => {\n      return html.indexOf('</iframe>') !== -1;\n    };\n    const createFragmentedLevel = fragments => {\n      return {\n        type: 'fragmented',\n        fragments,\n        content: '',\n        bookmark: null,\n        beforeBookmark: null\n      };\n    };\n    const createCompleteLevel = content => {\n      return {\n        type: 'complete',\n        fragments: null,\n        content,\n        bookmark: null,\n        beforeBookmark: null\n      };\n    };\n    const createFromEditor = editor => {\n      const fragments = read$2(editor.getBody());\n      const trimmedFragments = bind$3(fragments, html => {\n        const trimmed = trimInternal(editor.serializer, html);\n        return trimmed.length > 0 ? [trimmed] : [];\n      });\n      const content = trimmedFragments.join('');\n      return hasIframes(content) ? createFragmentedLevel(trimmedFragments) : createCompleteLevel(content);\n    };\n    const applyToEditor = (editor, level, before) => {\n      const bookmark = before ? level.beforeBookmark : level.bookmark;\n      if (level.type === 'fragmented') {\n        write(level.fragments, editor.getBody());\n      } else {\n        editor.setContent(level.content, {\n          format: 'raw',\n          no_selection: isNonNullable(bookmark) && isPathBookmark(bookmark) ? !bookmark.isFakeCaret : true\n        });\n      }\n      editor.selection.moveToBookmark(bookmark);\n    };\n    const getLevelContent = level => {\n      return level.type === 'fragmented' ? level.fragments.join('') : level.content;\n    };\n    const getCleanLevelContent = level => {\n      const elm = SugarElement.fromTag('body', lazyTempDocument());\n      set(elm, getLevelContent(level));\n      each$g(descendants(elm, '*[data-mce-bogus]'), unwrap);\n      return get$6(elm);\n    };\n    const hasEqualContent = (level1, level2) => getLevelContent(level1) === getLevelContent(level2);\n    const hasEqualCleanedContent = (level1, level2) => getCleanLevelContent(level1) === getCleanLevelContent(level2);\n    const isEq$1 = (level1, level2) => {\n      if (!level1 || !level2) {\n        return false;\n      } else if (hasEqualContent(level1, level2)) {\n        return true;\n      } else {\n        return hasEqualCleanedContent(level1, level2);\n      }\n    };\n\n    const isUnlocked = locks => locks.get() === 0;\n\n    const setTyping = (undoManager, typing, locks) => {\n      if (isUnlocked(locks)) {\n        undoManager.typing = typing;\n      }\n    };\n    const endTyping = (undoManager, locks) => {\n      if (undoManager.typing) {\n        setTyping(undoManager, false, locks);\n        undoManager.add();\n      }\n    };\n    const endTypingLevelIgnoreLocks = undoManager => {\n      if (undoManager.typing) {\n        undoManager.typing = false;\n        undoManager.add();\n      }\n    };\n\n    const beforeChange$1 = (editor, locks, beforeBookmark) => {\n      if (isUnlocked(locks)) {\n        beforeBookmark.set(getUndoBookmark(editor.selection));\n      }\n    };\n    const addUndoLevel$1 = (editor, undoManager, index, locks, beforeBookmark, level, event) => {\n      const currentLevel = createFromEditor(editor);\n      level = level || {};\n      level = Tools.extend(level, currentLevel);\n      if (isUnlocked(locks) === false || editor.removed) {\n        return null;\n      }\n      const lastLevel = undoManager.data[index.get()];\n      if (editor.dispatch('BeforeAddUndo', {\n          level,\n          lastLevel,\n          originalEvent: event\n        }).isDefaultPrevented()) {\n        return null;\n      }\n      if (lastLevel && isEq$1(lastLevel, level)) {\n        return null;\n      }\n      if (undoManager.data[index.get()]) {\n        beforeBookmark.get().each(bm => {\n          undoManager.data[index.get()].beforeBookmark = bm;\n        });\n      }\n      const customUndoRedoLevels = getCustomUndoRedoLevels(editor);\n      if (customUndoRedoLevels) {\n        if (undoManager.data.length > customUndoRedoLevels) {\n          for (let i = 0; i < undoManager.data.length - 1; i++) {\n            undoManager.data[i] = undoManager.data[i + 1];\n          }\n          undoManager.data.length--;\n          index.set(undoManager.data.length);\n        }\n      }\n      level.bookmark = getUndoBookmark(editor.selection);\n      if (index.get() < undoManager.data.length - 1) {\n        undoManager.data.length = index.get() + 1;\n      }\n      undoManager.data.push(level);\n      index.set(undoManager.data.length - 1);\n      const args = {\n        level,\n        lastLevel,\n        originalEvent: event\n      };\n      if (index.get() > 0) {\n        editor.setDirty(true);\n        editor.dispatch('AddUndo', args);\n        editor.dispatch('change', args);\n      } else {\n        editor.dispatch('AddUndo', args);\n      }\n      return level;\n    };\n    const clear$1 = (editor, undoManager, index) => {\n      undoManager.data = [];\n      index.set(0);\n      undoManager.typing = false;\n      editor.dispatch('ClearUndos');\n    };\n    const extra$1 = (editor, undoManager, index, callback1, callback2) => {\n      if (undoManager.transact(callback1)) {\n        const bookmark = undoManager.data[index.get()].bookmark;\n        const lastLevel = undoManager.data[index.get() - 1];\n        applyToEditor(editor, lastLevel, true);\n        if (undoManager.transact(callback2)) {\n          undoManager.data[index.get() - 1].beforeBookmark = bookmark;\n        }\n      }\n    };\n    const redo$1 = (editor, index, data) => {\n      let level;\n      if (index.get() < data.length - 1) {\n        index.set(index.get() + 1);\n        level = data[index.get()];\n        applyToEditor(editor, level, false);\n        editor.setDirty(true);\n        editor.dispatch('Redo', { level });\n      }\n      return level;\n    };\n    const undo$1 = (editor, undoManager, locks, index) => {\n      let level;\n      if (undoManager.typing) {\n        undoManager.add();\n        undoManager.typing = false;\n        setTyping(undoManager, false, locks);\n      }\n      if (index.get() > 0) {\n        index.set(index.get() - 1);\n        level = undoManager.data[index.get()];\n        applyToEditor(editor, level, true);\n        editor.setDirty(true);\n        editor.dispatch('Undo', { level });\n      }\n      return level;\n    };\n    const reset$1 = undoManager => {\n      undoManager.clear();\n      undoManager.add();\n    };\n    const hasUndo$1 = (editor, undoManager, index) => index.get() > 0 || undoManager.typing && undoManager.data[0] && !isEq$1(createFromEditor(editor), undoManager.data[0]);\n    const hasRedo$1 = (undoManager, index) => index.get() < undoManager.data.length - 1 && !undoManager.typing;\n    const transact$1 = (undoManager, locks, callback) => {\n      endTyping(undoManager, locks);\n      undoManager.beforeChange();\n      undoManager.ignore(callback);\n      return undoManager.add();\n    };\n    const ignore$1 = (locks, callback) => {\n      try {\n        locks.set(locks.get() + 1);\n        callback();\n      } finally {\n        locks.set(locks.get() - 1);\n      }\n    };\n\n    const addVisualInternal = (editor, elm) => {\n      const dom = editor.dom;\n      const scope = isNonNullable(elm) ? elm : editor.getBody();\n      if (isUndefined(editor.hasVisual)) {\n        editor.hasVisual = isVisualAidsEnabled(editor);\n      }\n      each$g(dom.select('table,a', scope), matchedElm => {\n        switch (matchedElm.nodeName) {\n        case 'TABLE':\n          const cls = getVisualAidsTableClass(editor);\n          const value = dom.getAttrib(matchedElm, 'border');\n          if ((!value || value === '0') && editor.hasVisual) {\n            dom.addClass(matchedElm, cls);\n          } else {\n            dom.removeClass(matchedElm, cls);\n          }\n          break;\n        case 'A':\n          if (!dom.getAttrib(matchedElm, 'href')) {\n            const value = dom.getAttrib(matchedElm, 'name') || matchedElm.id;\n            const cls = getVisualAidsAnchorClass(editor);\n            if (value && editor.hasVisual) {\n              dom.addClass(matchedElm, cls);\n            } else {\n              dom.removeClass(matchedElm, cls);\n            }\n          }\n          break;\n        }\n      });\n      editor.dispatch('VisualAid', {\n        element: elm,\n        hasVisual: editor.hasVisual\n      });\n    };\n\n    const makePlainAdaptor = editor => ({\n      init: { bindEvents: noop },\n      undoManager: {\n        beforeChange: (locks, beforeBookmark) => beforeChange$1(editor, locks, beforeBookmark),\n        add: (undoManager, index, locks, beforeBookmark, level, event) => addUndoLevel$1(editor, undoManager, index, locks, beforeBookmark, level, event),\n        undo: (undoManager, locks, index) => undo$1(editor, undoManager, locks, index),\n        redo: (index, data) => redo$1(editor, index, data),\n        clear: (undoManager, index) => clear$1(editor, undoManager, index),\n        reset: undoManager => reset$1(undoManager),\n        hasUndo: (undoManager, index) => hasUndo$1(editor, undoManager, index),\n        hasRedo: (undoManager, index) => hasRedo$1(undoManager, index),\n        transact: (undoManager, locks, callback) => transact$1(undoManager, locks, callback),\n        ignore: (locks, callback) => ignore$1(locks, callback),\n        extra: (undoManager, index, callback1, callback2) => extra$1(editor, undoManager, index, callback1, callback2)\n      },\n      formatter: {\n        match: (name, vars, node, similar) => match$2(editor, name, vars, node, similar),\n        matchAll: (names, vars) => matchAll(editor, names, vars),\n        matchNode: (node, name, vars, similar) => matchNode(editor, node, name, vars, similar),\n        canApply: name => canApply(editor, name),\n        closest: names => closest$1(editor, names),\n        apply: (name, vars, node) => applyFormat$1(editor, name, vars, node),\n        remove: (name, vars, node, similar) => remove$2(editor, name, vars, node, similar),\n        toggle: (name, vars, node) => toggle(editor, name, vars, node),\n        formatChanged: (registeredFormatListeners, formats, callback, similar, vars) => formatChangedInternal(editor, registeredFormatListeners, formats, callback, similar, vars)\n      },\n      editor: {\n        getContent: args => getContentInternal(editor, args),\n        setContent: (content, args) => setContentInternal(editor, content, args),\n        insertContent: (value, details) => insertHtmlAtCaret(editor, value, details),\n        addVisual: elm => addVisualInternal(editor, elm)\n      },\n      selection: { getContent: (format, args) => getSelectedContentInternal(editor, format, args) },\n      autocompleter: {\n        addDecoration: range => create$8(editor, range),\n        removeDecoration: () => remove$3(editor, SugarElement.fromDom(editor.getBody()))\n      },\n      raw: { getModel: () => Optional.none() }\n    });\n    const makeRtcAdaptor = rtcEditor => {\n      const defaultVars = vars => isObject(vars) ? vars : {};\n      const {init, undoManager, formatter, editor, selection, autocompleter, raw} = rtcEditor;\n      return {\n        init: { bindEvents: init.bindEvents },\n        undoManager: {\n          beforeChange: undoManager.beforeChange,\n          add: undoManager.add,\n          undo: undoManager.undo,\n          redo: undoManager.redo,\n          clear: undoManager.clear,\n          reset: undoManager.reset,\n          hasUndo: undoManager.hasUndo,\n          hasRedo: undoManager.hasRedo,\n          transact: (_undoManager, _locks, fn) => undoManager.transact(fn),\n          ignore: (_locks, callback) => undoManager.ignore(callback),\n          extra: (_undoManager, _index, callback1, callback2) => undoManager.extra(callback1, callback2)\n        },\n        formatter: {\n          match: (name, vars, _node, similar) => formatter.match(name, defaultVars(vars), similar),\n          matchAll: formatter.matchAll,\n          matchNode: formatter.matchNode,\n          canApply: name => formatter.canApply(name),\n          closest: names => formatter.closest(names),\n          apply: (name, vars, _node) => formatter.apply(name, defaultVars(vars)),\n          remove: (name, vars, _node, _similar) => formatter.remove(name, defaultVars(vars)),\n          toggle: (name, vars, _node) => formatter.toggle(name, defaultVars(vars)),\n          formatChanged: (_rfl, formats, callback, similar, vars) => formatter.formatChanged(formats, callback, similar, vars)\n        },\n        editor: {\n          getContent: args => editor.getContent(args),\n          setContent: (content, args) => {\n            return {\n              content: editor.setContent(content, args),\n              html: ''\n            };\n          },\n          insertContent: (content, _details) => {\n            editor.insertContent(content);\n            return '';\n          },\n          addVisual: editor.addVisual\n        },\n        selection: { getContent: (_format, args) => selection.getContent(args) },\n        autocompleter: {\n          addDecoration: autocompleter.addDecoration,\n          removeDecoration: autocompleter.removeDecoration\n        },\n        raw: { getModel: () => Optional.some(raw.getRawModel()) }\n      };\n    };\n    const makeNoopAdaptor = () => {\n      const nul = constant(null);\n      const empty = constant('');\n      return {\n        init: { bindEvents: noop },\n        undoManager: {\n          beforeChange: noop,\n          add: nul,\n          undo: nul,\n          redo: nul,\n          clear: noop,\n          reset: noop,\n          hasUndo: never,\n          hasRedo: never,\n          transact: nul,\n          ignore: noop,\n          extra: noop\n        },\n        formatter: {\n          match: never,\n          matchAll: constant([]),\n          matchNode: constant(undefined),\n          canApply: never,\n          closest: empty,\n          apply: noop,\n          remove: noop,\n          toggle: noop,\n          formatChanged: constant({ unbind: noop })\n        },\n        editor: {\n          getContent: empty,\n          setContent: constant({\n            content: '',\n            html: ''\n          }),\n          insertContent: constant(''),\n          addVisual: noop\n        },\n        selection: { getContent: empty },\n        autocompleter: {\n          addDecoration: noop,\n          removeDecoration: noop\n        },\n        raw: { getModel: constant(Optional.none()) }\n      };\n    };\n    const isRtc = editor => has$2(editor.plugins, 'rtc');\n    const getRtcSetup = editor => get$a(editor.plugins, 'rtc').bind(rtcPlugin => Optional.from(rtcPlugin.setup));\n    const setup$s = editor => {\n      const editorCast = editor;\n      return getRtcSetup(editor).fold(() => {\n        editorCast.rtcInstance = makePlainAdaptor(editor);\n        return Optional.none();\n      }, setup => {\n        editorCast.rtcInstance = makeNoopAdaptor();\n        return Optional.some(() => setup().then(rtcEditor => {\n          editorCast.rtcInstance = makeRtcAdaptor(rtcEditor);\n          return rtcEditor.rtc.isRemote;\n        }));\n      });\n    };\n    const getRtcInstanceWithFallback = editor => editor.rtcInstance ? editor.rtcInstance : makePlainAdaptor(editor);\n    const getRtcInstanceWithError = editor => {\n      const rtcInstance = editor.rtcInstance;\n      if (!rtcInstance) {\n        throw new Error('Failed to get RTC instance not yet initialized.');\n      } else {\n        return rtcInstance;\n      }\n    };\n    const beforeChange = (editor, locks, beforeBookmark) => {\n      getRtcInstanceWithError(editor).undoManager.beforeChange(locks, beforeBookmark);\n    };\n    const addUndoLevel = (editor, undoManager, index, locks, beforeBookmark, level, event) => getRtcInstanceWithError(editor).undoManager.add(undoManager, index, locks, beforeBookmark, level, event);\n    const undo = (editor, undoManager, locks, index) => getRtcInstanceWithError(editor).undoManager.undo(undoManager, locks, index);\n    const redo = (editor, index, data) => getRtcInstanceWithError(editor).undoManager.redo(index, data);\n    const clear = (editor, undoManager, index) => {\n      getRtcInstanceWithError(editor).undoManager.clear(undoManager, index);\n    };\n    const reset = (editor, undoManager) => {\n      getRtcInstanceWithError(editor).undoManager.reset(undoManager);\n    };\n    const hasUndo = (editor, undoManager, index) => getRtcInstanceWithError(editor).undoManager.hasUndo(undoManager, index);\n    const hasRedo = (editor, undoManager, index) => getRtcInstanceWithError(editor).undoManager.hasRedo(undoManager, index);\n    const transact = (editor, undoManager, locks, callback) => getRtcInstanceWithError(editor).undoManager.transact(undoManager, locks, callback);\n    const ignore = (editor, locks, callback) => {\n      getRtcInstanceWithError(editor).undoManager.ignore(locks, callback);\n    };\n    const extra = (editor, undoManager, index, callback1, callback2) => {\n      getRtcInstanceWithError(editor).undoManager.extra(undoManager, index, callback1, callback2);\n    };\n    const matchFormat = (editor, name, vars, node, similar) => getRtcInstanceWithError(editor).formatter.match(name, vars, node, similar);\n    const matchAllFormats = (editor, names, vars) => getRtcInstanceWithError(editor).formatter.matchAll(names, vars);\n    const matchNodeFormat = (editor, node, name, vars, similar) => getRtcInstanceWithError(editor).formatter.matchNode(node, name, vars, similar);\n    const canApplyFormat = (editor, name) => getRtcInstanceWithError(editor).formatter.canApply(name);\n    const closestFormat = (editor, names) => getRtcInstanceWithError(editor).formatter.closest(names);\n    const applyFormat = (editor, name, vars, node) => {\n      getRtcInstanceWithError(editor).formatter.apply(name, vars, node);\n    };\n    const removeFormat = (editor, name, vars, node, similar) => {\n      getRtcInstanceWithError(editor).formatter.remove(name, vars, node, similar);\n    };\n    const toggleFormat = (editor, name, vars, node) => {\n      getRtcInstanceWithError(editor).formatter.toggle(name, vars, node);\n    };\n    const formatChanged = (editor, registeredFormatListeners, formats, callback, similar, vars) => getRtcInstanceWithError(editor).formatter.formatChanged(registeredFormatListeners, formats, callback, similar, vars);\n    const getContent$2 = (editor, args) => getRtcInstanceWithFallback(editor).editor.getContent(args);\n    const setContent$2 = (editor, content, args) => getRtcInstanceWithFallback(editor).editor.setContent(content, args);\n    const insertContent$1 = (editor, value, details) => getRtcInstanceWithFallback(editor).editor.insertContent(value, details);\n    const getSelectedContent = (editor, format, args) => getRtcInstanceWithError(editor).selection.getContent(format, args);\n    const addVisual$1 = (editor, elm) => getRtcInstanceWithError(editor).editor.addVisual(elm);\n    const bindEvents = editor => getRtcInstanceWithError(editor).init.bindEvents();\n    const addAutocompleterDecoration = (editor, range) => getRtcInstanceWithError(editor).autocompleter.addDecoration(range);\n    const removeAutocompleterDecoration = editor => getRtcInstanceWithError(editor).autocompleter.removeDecoration();\n\n    const getContent$1 = (editor, args = {}) => {\n      const format = args.format ? args.format : 'html';\n      return getSelectedContent(editor, format, args);\n    };\n\n    const removeEmpty = text => {\n      if (text.dom.length === 0) {\n        remove$5(text);\n        return Optional.none();\n      } else {\n        return Optional.some(text);\n      }\n    };\n    const walkPastBookmark = (node, start) => node.filter(elm => BookmarkManager.isBookmarkNode(elm.dom)).bind(start ? nextSibling : prevSibling);\n    const merge$1 = (outer, inner, rng, start) => {\n      const outerElm = outer.dom;\n      const innerElm = inner.dom;\n      const oldLength = start ? outerElm.length : innerElm.length;\n      if (start) {\n        mergeTextNodes(outerElm, innerElm, false, !start);\n        rng.setStart(innerElm, oldLength);\n      } else {\n        mergeTextNodes(innerElm, outerElm, false, !start);\n        rng.setEnd(innerElm, oldLength);\n      }\n    };\n    const normalizeTextIfRequired = (inner, start) => {\n      parent(inner).each(root => {\n        const text = inner.dom;\n        if (start && needsToBeNbspLeft(root, CaretPosition(text, 0))) {\n          normalizeWhitespaceAfter(text, 0);\n        } else if (!start && needsToBeNbspRight(root, CaretPosition(text, text.length))) {\n          normalizeWhitespaceBefore(text, text.length);\n        }\n      });\n    };\n    const mergeAndNormalizeText = (outerNode, innerNode, rng, start) => {\n      outerNode.bind(outer => {\n        const normalizer = start ? normalizeWhitespaceBefore : normalizeWhitespaceAfter;\n        normalizer(outer.dom, start ? outer.dom.length : 0);\n        return innerNode.filter(isText$9).map(inner => merge$1(outer, inner, rng, start));\n      }).orThunk(() => {\n        const innerTextNode = walkPastBookmark(innerNode, start).or(innerNode).filter(isText$9);\n        return innerTextNode.map(inner => normalizeTextIfRequired(inner, start));\n      });\n    };\n    const rngSetContent = (rng, fragment) => {\n      const firstChild = Optional.from(fragment.firstChild).map(SugarElement.fromDom);\n      const lastChild = Optional.from(fragment.lastChild).map(SugarElement.fromDom);\n      rng.deleteContents();\n      rng.insertNode(fragment);\n      const prevText = firstChild.bind(prevSibling).filter(isText$9).bind(removeEmpty);\n      const nextText = lastChild.bind(nextSibling).filter(isText$9).bind(removeEmpty);\n      mergeAndNormalizeText(prevText, firstChild, rng, true);\n      mergeAndNormalizeText(nextText, lastChild, rng, false);\n      rng.collapse(false);\n    };\n    const setupArgs$2 = (args, content) => ({\n      format: 'html',\n      ...args,\n      set: true,\n      selection: true,\n      content\n    });\n    const cleanContent = (editor, args) => {\n      if (args.format !== 'raw') {\n        const rng = editor.selection.getRng();\n        const contextBlock = editor.dom.getParent(rng.commonAncestorContainer, editor.dom.isBlock);\n        const contextArgs = contextBlock ? { context: contextBlock.nodeName.toLowerCase() } : {};\n        const node = editor.parser.parse(args.content, {\n          forced_root_block: false,\n          ...contextArgs,\n          ...args\n        });\n        return HtmlSerializer({ validate: false }, editor.schema).serialize(node);\n      } else {\n        return args.content;\n      }\n    };\n    const setContent$1 = (editor, content, args = {}) => {\n      const defaultedArgs = setupArgs$2(args, content);\n      preProcessSetContent(editor, defaultedArgs).each(updatedArgs => {\n        const cleanedContent = cleanContent(editor, updatedArgs);\n        const rng = editor.selection.getRng();\n        rngSetContent(rng, rng.createContextualFragment(cleanedContent));\n        editor.selection.setRng(rng);\n        scrollRangeIntoView(editor, rng);\n        postProcessSetContent(editor, cleanedContent, updatedArgs);\n      });\n    };\n\n    const deleteFromCallbackMap = (callbackMap, selector, callback) => {\n      if (callbackMap && has$2(callbackMap, selector)) {\n        const newCallbacks = filter$6(callbackMap[selector], cb => cb !== callback);\n        if (newCallbacks.length === 0) {\n          delete callbackMap[selector];\n        } else {\n          callbackMap[selector] = newCallbacks;\n        }\n      }\n    };\n    var SelectorChanged = (dom, editor) => {\n      let selectorChangedData;\n      let currentSelectors;\n      const findMatchingNode = (selector, nodes) => find$2(nodes, node => dom.is(node, selector));\n      const getParents = elem => dom.getParents(elem, null, dom.getRoot());\n      return {\n        selectorChangedWithUnbind: (selector, callback) => {\n          if (!selectorChangedData) {\n            selectorChangedData = {};\n            currentSelectors = {};\n            editor.on('NodeChange', e => {\n              const node = e.element;\n              const parents = getParents(node);\n              const matchedSelectors = {};\n              Tools.each(selectorChangedData, (callbacks, selector) => {\n                findMatchingNode(selector, parents).each(node => {\n                  if (!currentSelectors[selector]) {\n                    each$g(callbacks, callback => {\n                      callback(true, {\n                        node,\n                        selector,\n                        parents\n                      });\n                    });\n                    currentSelectors[selector] = callbacks;\n                  }\n                  matchedSelectors[selector] = callbacks;\n                });\n              });\n              Tools.each(currentSelectors, (callbacks, selector) => {\n                if (!matchedSelectors[selector]) {\n                  delete currentSelectors[selector];\n                  Tools.each(callbacks, callback => {\n                    callback(false, {\n                      node,\n                      selector,\n                      parents\n                    });\n                  });\n                }\n              });\n            });\n          }\n          if (!selectorChangedData[selector]) {\n            selectorChangedData[selector] = [];\n          }\n          selectorChangedData[selector].push(callback);\n          findMatchingNode(selector, getParents(editor.selection.getStart())).each(() => {\n            currentSelectors[selector] = selectorChangedData[selector];\n          });\n          return {\n            unbind: () => {\n              deleteFromCallbackMap(selectorChangedData, selector, callback);\n              deleteFromCallbackMap(currentSelectors, selector, callback);\n            }\n          };\n        }\n      };\n    };\n\n    const isAttachedToDom = node => {\n      return !!(node && node.ownerDocument) && contains(SugarElement.fromDom(node.ownerDocument), SugarElement.fromDom(node));\n    };\n    const isValidRange = rng => {\n      if (!rng) {\n        return false;\n      } else {\n        return isAttachedToDom(rng.startContainer) && isAttachedToDom(rng.endContainer);\n      }\n    };\n    const EditorSelection = (dom, win, serializer, editor) => {\n      let selectedRange;\n      let explicitRange;\n      const {selectorChangedWithUnbind} = SelectorChanged(dom, editor);\n      const setCursorLocation = (node, offset) => {\n        const rng = dom.createRng();\n        if (isNonNullable(node) && isNonNullable(offset)) {\n          rng.setStart(node, offset);\n          rng.setEnd(node, offset);\n          setRng(rng);\n          collapse(false);\n        } else {\n          moveEndPoint(dom, rng, editor.getBody(), true);\n          setRng(rng);\n        }\n      };\n      const getContent = args => getContent$1(editor, args);\n      const setContent = (content, args) => setContent$1(editor, content, args);\n      const getStart$1 = real => getStart(editor.getBody(), getRng$1(), real);\n      const getEnd = real => getEnd$1(editor.getBody(), getRng$1(), real);\n      const getBookmark = (type, normalized) => bookmarkManager.getBookmark(type, normalized);\n      const moveToBookmark = bookmark => bookmarkManager.moveToBookmark(bookmark);\n      const select$1 = (node, content) => {\n        select(dom, node, content).each(setRng);\n        return node;\n      };\n      const isCollapsed = () => {\n        const rng = getRng$1(), sel = getSel();\n        if (!rng || rng.item) {\n          return false;\n        }\n        if (rng.compareEndPoints) {\n          return rng.compareEndPoints('StartToEnd', rng) === 0;\n        }\n        return !sel || rng.collapsed;\n      };\n      const collapse = toStart => {\n        const rng = getRng$1();\n        rng.collapse(!!toStart);\n        setRng(rng);\n      };\n      const getSel = () => win.getSelection ? win.getSelection() : win.document.selection;\n      const getRng$1 = () => {\n        let selection, rng, elm;\n        const tryCompareBoundaryPoints = (how, sourceRange, destinationRange) => {\n          try {\n            return sourceRange.compareBoundaryPoints(how, destinationRange);\n          } catch (ex) {\n            return -1;\n          }\n        };\n        const doc = win.document;\n        if (editor.bookmark !== undefined && hasFocus(editor) === false) {\n          const bookmark = getRng(editor);\n          if (bookmark.isSome()) {\n            return bookmark.map(r => processRanges(editor, [r])[0]).getOr(doc.createRange());\n          }\n        }\n        try {\n          if ((selection = getSel()) && !isRestrictedNode(selection.anchorNode)) {\n            if (selection.rangeCount > 0) {\n              rng = selection.getRangeAt(0);\n            } else {\n              rng = selection.createRange ? selection.createRange() : doc.createRange();\n            }\n            rng = processRanges(editor, [rng])[0];\n          }\n        } catch (ex) {\n        }\n        if (!rng) {\n          rng = doc.createRange();\n        }\n        if (rng.setStart && rng.startContainer.nodeType === 9 && rng.collapsed) {\n          elm = dom.getRoot();\n          rng.setStart(elm, 0);\n          rng.setEnd(elm, 0);\n        }\n        if (selectedRange && explicitRange) {\n          if (tryCompareBoundaryPoints(rng.START_TO_START, rng, selectedRange) === 0 && tryCompareBoundaryPoints(rng.END_TO_END, rng, selectedRange) === 0) {\n            rng = explicitRange;\n          } else {\n            selectedRange = null;\n            explicitRange = null;\n          }\n        }\n        return rng;\n      };\n      const setRng = (rng, forward) => {\n        let node;\n        if (!isValidRange(rng)) {\n          return;\n        }\n        const sel = getSel();\n        const evt = editor.dispatch('SetSelectionRange', {\n          range: rng,\n          forward\n        });\n        rng = evt.range;\n        if (sel) {\n          explicitRange = rng;\n          try {\n            sel.removeAllRanges();\n            sel.addRange(rng);\n          } catch (ex) {\n          }\n          if (forward === false && sel.extend) {\n            sel.collapse(rng.endContainer, rng.endOffset);\n            sel.extend(rng.startContainer, rng.startOffset);\n          }\n          selectedRange = sel.rangeCount > 0 ? sel.getRangeAt(0) : null;\n        }\n        if (!rng.collapsed && rng.startContainer === rng.endContainer && sel.setBaseAndExtent) {\n          if (rng.endOffset - rng.startOffset < 2) {\n            if (rng.startContainer.hasChildNodes()) {\n              node = rng.startContainer.childNodes[rng.startOffset];\n              if (node && node.tagName === 'IMG') {\n                sel.setBaseAndExtent(rng.startContainer, rng.startOffset, rng.endContainer, rng.endOffset);\n                if (sel.anchorNode !== rng.startContainer || sel.focusNode !== rng.endContainer) {\n                  sel.setBaseAndExtent(node, 0, node, 1);\n                }\n              }\n            }\n          }\n        }\n        editor.dispatch('AfterSetSelectionRange', {\n          range: rng,\n          forward\n        });\n      };\n      const setNode = elm => {\n        setContent(dom.getOuterHTML(elm));\n        return elm;\n      };\n      const getNode$1 = () => getNode(editor.getBody(), getRng$1());\n      const getSelectedBlocks$1 = (startElm, endElm) => getSelectedBlocks(dom, getRng$1(), startElm, endElm);\n      const isForward = () => {\n        const sel = getSel();\n        const anchorNode = sel === null || sel === void 0 ? void 0 : sel.anchorNode;\n        const focusNode = sel === null || sel === void 0 ? void 0 : sel.focusNode;\n        if (!sel || !anchorNode || !focusNode || isRestrictedNode(anchorNode) || isRestrictedNode(focusNode)) {\n          return true;\n        }\n        const anchorRange = dom.createRng();\n        anchorRange.setStart(anchorNode, sel.anchorOffset);\n        anchorRange.collapse(true);\n        const focusRange = dom.createRng();\n        focusRange.setStart(focusNode, sel.focusOffset);\n        focusRange.collapse(true);\n        return anchorRange.compareBoundaryPoints(anchorRange.START_TO_START, focusRange) <= 0;\n      };\n      const normalize = () => {\n        const rng = getRng$1();\n        const sel = getSel();\n        if (!hasMultipleRanges(sel) && hasAnyRanges(editor)) {\n          const normRng = normalize$2(dom, rng);\n          normRng.each(normRng => {\n            setRng(normRng, isForward());\n          });\n          return normRng.getOr(rng);\n        }\n        return rng;\n      };\n      const selectorChanged = (selector, callback) => {\n        selectorChangedWithUnbind(selector, callback);\n        return exports;\n      };\n      const getScrollContainer = () => {\n        let scrollContainer;\n        let node = dom.getRoot();\n        while (node && node.nodeName !== 'BODY') {\n          if (node.scrollHeight > node.clientHeight) {\n            scrollContainer = node;\n            break;\n          }\n          node = node.parentNode;\n        }\n        return scrollContainer;\n      };\n      const scrollIntoView = (elm, alignToTop) => {\n        if (isNonNullable(elm)) {\n          scrollElementIntoView(editor, elm, alignToTop);\n        } else {\n          scrollRangeIntoView(editor, getRng$1(), alignToTop);\n        }\n      };\n      const placeCaretAt = (clientX, clientY) => setRng(fromPoint(clientX, clientY, editor.getDoc()));\n      const getBoundingClientRect = () => {\n        const rng = getRng$1();\n        return rng.collapsed ? CaretPosition.fromRangeStart(rng).getClientRects()[0] : rng.getBoundingClientRect();\n      };\n      const destroy = () => {\n        win = selectedRange = explicitRange = null;\n        controlSelection.destroy();\n      };\n      const exports = {\n        bookmarkManager: null,\n        controlSelection: null,\n        dom,\n        win,\n        serializer,\n        editor,\n        collapse,\n        setCursorLocation,\n        getContent,\n        setContent,\n        getBookmark,\n        moveToBookmark,\n        select: select$1,\n        isCollapsed,\n        isForward,\n        setNode,\n        getNode: getNode$1,\n        getSel,\n        setRng,\n        getRng: getRng$1,\n        getStart: getStart$1,\n        getEnd,\n        getSelectedBlocks: getSelectedBlocks$1,\n        normalize,\n        selectorChanged,\n        selectorChangedWithUnbind,\n        getScrollContainer,\n        scrollIntoView,\n        placeCaretAt,\n        getBoundingClientRect,\n        destroy\n      };\n      const bookmarkManager = BookmarkManager(exports);\n      const controlSelection = ControlSelection(exports, editor);\n      exports.bookmarkManager = bookmarkManager;\n      exports.controlSelection = controlSelection;\n      return exports;\n    };\n\n    const register$3 = (htmlParser, settings, dom) => {\n      htmlParser.addAttributeFilter('data-mce-tabindex', (nodes, name) => {\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          node.attr('tabindex', node.attr('data-mce-tabindex'));\n          node.attr(name, null);\n        }\n      });\n      htmlParser.addAttributeFilter('src,href,style', (nodes, name) => {\n        const internalName = 'data-mce-' + name;\n        const urlConverter = settings.url_converter;\n        const urlConverterScope = settings.url_converter_scope;\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          let value = node.attr(internalName);\n          if (value !== undefined) {\n            node.attr(name, value.length > 0 ? value : null);\n            node.attr(internalName, null);\n          } else {\n            value = node.attr(name);\n            if (name === 'style') {\n              value = dom.serializeStyle(dom.parseStyle(value), node.name);\n            } else if (urlConverter) {\n              value = urlConverter.call(urlConverterScope, value, name, node.name);\n            }\n            node.attr(name, value.length > 0 ? value : null);\n          }\n        }\n      });\n      htmlParser.addAttributeFilter('class', nodes => {\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          let value = node.attr('class');\n          if (value) {\n            value = node.attr('class').replace(/(?:^|\\s)mce-item-\\w+(?!\\S)/g, '');\n            node.attr('class', value.length > 0 ? value : null);\n          }\n        }\n      });\n      htmlParser.addAttributeFilter('data-mce-type', (nodes, name, args) => {\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          if (node.attr('data-mce-type') === 'bookmark' && !args.cleanup) {\n            const hasChildren = Optional.from(node.firstChild).exists(firstChild => !isZwsp(firstChild.value));\n            if (hasChildren) {\n              node.unwrap();\n            } else {\n              node.remove();\n            }\n          }\n        }\n      });\n      htmlParser.addNodeFilter('noscript', nodes => {\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i].firstChild;\n          if (node) {\n            node.value = Entities.decode(node.value);\n          }\n        }\n      });\n      htmlParser.addNodeFilter('script,style', (nodes, name) => {\n        const trim = value => {\n          return value.replace(/(<!--\\[CDATA\\[|\\]\\]-->)/g, '\\n').replace(/^[\\r\\n]*|[\\r\\n]*$/g, '').replace(/^\\s*((<!--)?(\\s*\\/\\/)?\\s*<!\\[CDATA\\[|(<!--\\s*)?\\/\\*\\s*<!\\[CDATA\\[\\s*\\*\\/|(\\/\\/)?\\s*<!--|\\/\\*\\s*<!--\\s*\\*\\/)\\s*[\\r\\n]*/gi, '').replace(/\\s*(\\/\\*\\s*\\]\\]>\\s*\\*\\/(-->)?|\\s*\\/\\/\\s*\\]\\]>(-->)?|\\/\\/\\s*(-->)?|\\]\\]>|\\/\\*\\s*-->\\s*\\*\\/|\\s*-->\\s*)\\s*$/g, '');\n        };\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          const value = node.firstChild ? node.firstChild.value : '';\n          if (name === 'script') {\n            const type = node.attr('type');\n            if (type) {\n              node.attr('type', type === 'mce-no/type' ? null : type.replace(/^mce\\-/, ''));\n            }\n            if (settings.element_format === 'xhtml' && value.length > 0) {\n              node.firstChild.value = '// <![CDATA[\\n' + trim(value) + '\\n// ]]>';\n            }\n          } else {\n            if (settings.element_format === 'xhtml' && value.length > 0) {\n              node.firstChild.value = '<!--\\n' + trim(value) + '\\n-->';\n            }\n          }\n        }\n      });\n      htmlParser.addNodeFilter('#comment', nodes => {\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          if (settings.preserve_cdata && node.value.indexOf('[CDATA[') === 0) {\n            node.name = '#cdata';\n            node.type = 4;\n            node.value = dom.decode(node.value.replace(/^\\[CDATA\\[|\\]\\]$/g, ''));\n          } else if (node.value.indexOf('mce:protected ') === 0) {\n            node.name = '#text';\n            node.type = 3;\n            node.raw = true;\n            node.value = unescape(node.value).substr(14);\n          }\n        }\n      });\n      htmlParser.addNodeFilter('xml:namespace,input', (nodes, name) => {\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          if (node.type === 7) {\n            node.remove();\n          } else if (node.type === 1) {\n            if (name === 'input' && !node.attr('type')) {\n              node.attr('type', 'text');\n            }\n          }\n        }\n      });\n      htmlParser.addAttributeFilter('data-mce-type', nodes => {\n        each$g(nodes, node => {\n          if (node.attr('data-mce-type') === 'format-caret') {\n            if (node.isEmpty(htmlParser.schema.getNonEmptyElements())) {\n              node.remove();\n            } else {\n              node.unwrap();\n            }\n          }\n        });\n      });\n      htmlParser.addAttributeFilter('data-mce-src,data-mce-href,data-mce-style,' + 'data-mce-selected,data-mce-expando,' + 'data-mce-type,data-mce-resize,data-mce-placeholder', (nodes, name) => {\n        let i = nodes.length;\n        while (i--) {\n          nodes[i].attr(name, null);\n        }\n      });\n    };\n    const trimTrailingBr = rootNode => {\n      const isBr = node => {\n        return node && node.name === 'br';\n      };\n      const brNode1 = rootNode.lastChild;\n      if (isBr(brNode1)) {\n        const brNode2 = brNode1.prev;\n        if (isBr(brNode2)) {\n          brNode1.remove();\n          brNode2.remove();\n        }\n      }\n    };\n\n    const preProcess$1 = (editor, node, args) => {\n      let oldDoc;\n      const dom = editor.dom;\n      let clonedNode = node.cloneNode(true);\n      const impl = document.implementation;\n      if (impl.createHTMLDocument) {\n        const doc = impl.createHTMLDocument('');\n        Tools.each(clonedNode.nodeName === 'BODY' ? clonedNode.childNodes : [clonedNode], node => {\n          doc.body.appendChild(doc.importNode(node, true));\n        });\n        if (clonedNode.nodeName !== 'BODY') {\n          clonedNode = doc.body.firstChild;\n        } else {\n          clonedNode = doc.body;\n        }\n        oldDoc = dom.doc;\n        dom.doc = doc;\n      }\n      firePreProcess(editor, {\n        ...args,\n        node: clonedNode\n      });\n      if (oldDoc) {\n        dom.doc = oldDoc;\n      }\n      return clonedNode;\n    };\n    const shouldFireEvent = (editor, args) => {\n      return editor && editor.hasEventListeners('PreProcess') && !args.no_events;\n    };\n    const process$1 = (editor, node, args) => {\n      return shouldFireEvent(editor, args) ? preProcess$1(editor, node, args) : node;\n    };\n\n    const addTempAttr = (htmlParser, tempAttrs, name) => {\n      if (Tools.inArray(tempAttrs, name) === -1) {\n        htmlParser.addAttributeFilter(name, (nodes, name) => {\n          let i = nodes.length;\n          while (i--) {\n            nodes[i].attr(name, null);\n          }\n        });\n        tempAttrs.push(name);\n      }\n    };\n    const postProcess = (editor, args, content) => {\n      if (!args.no_events && editor) {\n        const outArgs = firePostProcess(editor, {\n          ...args,\n          content\n        });\n        return outArgs.content;\n      } else {\n        return content;\n      }\n    };\n    const getHtmlFromNode = (dom, node, args) => {\n      const html = trim$1(args.getInner ? node.innerHTML : dom.getOuterHTML(node));\n      return args.selection || isWsPreserveElement(SugarElement.fromDom(node)) ? html : Tools.trim(html);\n    };\n    const parseHtml = (htmlParser, html, args) => {\n      const parserArgs = args.selection ? {\n        forced_root_block: false,\n        ...args\n      } : args;\n      const rootNode = htmlParser.parse(html, parserArgs);\n      trimTrailingBr(rootNode);\n      return rootNode;\n    };\n    const serializeNode = (settings, schema, node) => {\n      const htmlSerializer = HtmlSerializer(settings, schema);\n      return htmlSerializer.serialize(node);\n    };\n    const toHtml = (editor, settings, schema, rootNode, args) => {\n      const content = serializeNode(settings, schema, rootNode);\n      return postProcess(editor, args, content);\n    };\n    const DomSerializerImpl = (settings, editor) => {\n      const tempAttrs = ['data-mce-selected'];\n      const dom = editor && editor.dom ? editor.dom : DOMUtils.DOM;\n      const schema = editor && editor.schema ? editor.schema : Schema(settings);\n      settings.entity_encoding = settings.entity_encoding || 'named';\n      settings.remove_trailing_brs = 'remove_trailing_brs' in settings ? settings.remove_trailing_brs : true;\n      const htmlParser = DomParser(settings, schema);\n      register$3(htmlParser, settings, dom);\n      const serialize = (node, parserArgs = {}) => {\n        const args = {\n          format: 'html',\n          ...parserArgs\n        };\n        const targetNode = process$1(editor, node, args);\n        const html = getHtmlFromNode(dom, targetNode, args);\n        const rootNode = parseHtml(htmlParser, html, args);\n        return args.format === 'tree' ? rootNode : toHtml(editor, settings, schema, rootNode, args);\n      };\n      return {\n        schema,\n        addNodeFilter: htmlParser.addNodeFilter,\n        addAttributeFilter: htmlParser.addAttributeFilter,\n        serialize: serialize,\n        addRules: schema.addValidElements,\n        setRules: schema.setValidElements,\n        addTempAttr: curry(addTempAttr, htmlParser, tempAttrs),\n        getTempAttrs: constant(tempAttrs),\n        getNodeFilters: htmlParser.getNodeFilters,\n        getAttributeFilters: htmlParser.getAttributeFilters\n      };\n    };\n\n    const DomSerializer = (settings, editor) => {\n      const domSerializer = DomSerializerImpl(settings, editor);\n      return {\n        schema: domSerializer.schema,\n        addNodeFilter: domSerializer.addNodeFilter,\n        addAttributeFilter: domSerializer.addAttributeFilter,\n        serialize: domSerializer.serialize,\n        addRules: domSerializer.addRules,\n        setRules: domSerializer.setRules,\n        addTempAttr: domSerializer.addTempAttr,\n        getTempAttrs: domSerializer.getTempAttrs,\n        getNodeFilters: domSerializer.getNodeFilters,\n        getAttributeFilters: domSerializer.getAttributeFilters\n      };\n    };\n\n    const defaultFormat$1 = 'html';\n    const setupArgs$1 = (args, format) => ({\n      ...args,\n      format,\n      get: true,\n      getInner: true\n    });\n    const getContent = (editor, args = {}) => {\n      const format = args.format ? args.format : defaultFormat$1;\n      const defaultedArgs = setupArgs$1(args, format);\n      return preProcessGetContent(editor, defaultedArgs).fold(identity, updatedArgs => {\n        const content = getContent$2(editor, updatedArgs);\n        return postProcessGetContent(editor, content, updatedArgs);\n      });\n    };\n\n    const defaultFormat = 'html';\n    const setupArgs = (args, content) => ({\n      format: defaultFormat,\n      ...args,\n      set: true,\n      content\n    });\n    const setContent = (editor, content, args = {}) => {\n      const defaultedArgs = setupArgs(args, content);\n      return preProcessSetContent(editor, defaultedArgs).map(updatedArgs => {\n        const result = setContent$2(editor, updatedArgs.content, updatedArgs);\n        postProcessSetContent(editor, result.html, updatedArgs);\n        return result.content;\n      }).getOr(content);\n    };\n\n    const removedOptions = ('autoresize_on_init,content_editable_state,padd_empty_with_br,block_elements,' + 'boolean_attributes,editor_deselector,editor_selector,elements,file_browser_callback_types,filepicker_validator_handler,' + 'force_hex_style_colors,force_p_newlines,gecko_spellcheck,images_dataimg_filter,media_scripts,mode,move_caret_before_on_enter_elements,' + 'non_empty_elements,self_closing_elements,short_ended_elements,special,spellchecker_select_languages,spellchecker_whitelist,' + 'tab_focus,tabfocus_elements,table_responsive_width,text_block_elements,text_inline_elements,toolbar_drawer,types,validate,whitespace_elements,' + 'paste_enable_default_filters,paste_filter_drop,paste_word_valid_elements,paste_retain_style_properties,paste_convert_word_fake_lists').split(',');\n    const removedPlugins = 'bbcode,colorpicker,contextmenu,fullpage,legacyoutput,spellchecker,textcolor'.split(',');\n    const getRemovedOptions = options => {\n      const settingNames = filter$6(removedOptions, setting => has$2(options, setting));\n      const forcedRootBlock = options.forced_root_block;\n      if (forcedRootBlock === false || forcedRootBlock === '') {\n        settingNames.push('forced_root_block (false only)');\n      }\n      return sort(settingNames);\n    };\n    const getRemovedPlugins = options => {\n      const plugins = Tools.makeMap(options.plugins, ' ');\n      const hasPlugin = plugin => has$2(plugins, plugin);\n      const pluginNames = filter$6(removedPlugins, hasPlugin);\n      return sort(pluginNames);\n    };\n    const logRemovedWarnings = (rawOptions, normalizedOptions) => {\n      const removedOptions = getRemovedOptions(rawOptions);\n      const removedPlugins = getRemovedPlugins(normalizedOptions);\n      const hasRemovedPlugins = removedPlugins.length > 0;\n      const hasRemovedOptions = removedOptions.length > 0;\n      const isLegacyMobileTheme = normalizedOptions.theme === 'mobile';\n      if (hasRemovedPlugins || hasRemovedOptions || isLegacyMobileTheme) {\n        const listJoiner = '\\n- ';\n        const themesMessage = isLegacyMobileTheme ? `\\n\\nThemes:${ listJoiner }mobile` : '';\n        const pluginsMessage = hasRemovedPlugins ? `\\n\\nPlugins:${ listJoiner }${ removedPlugins.join(listJoiner) }` : '';\n        const optionsMessage = hasRemovedOptions ? `\\n\\nOptions:${ listJoiner }${ removedOptions.join(listJoiner) }` : '';\n        console.warn('The following deprecated features are currently enabled and have been removed in TinyMCE 6.0. These features will no longer work and should be removed from the TinyMCE configuration. ' + 'See https://www.tiny.cloud/docs/tinymce/6/migration-from-5x/ for more information.' + themesMessage + pluginsMessage + optionsMessage);\n      }\n    };\n    const logWarnings = (rawOptions, normalizedOptions) => {\n      logRemovedWarnings(rawOptions, normalizedOptions);\n    };\n\n    const DOM$8 = DOMUtils.DOM;\n    const restoreOriginalStyles = editor => {\n      DOM$8.setStyle(editor.id, 'display', editor.orgDisplay);\n    };\n    const safeDestroy = x => Optional.from(x).each(x => x.destroy());\n    const clearDomReferences = editor => {\n      editor.contentAreaContainer = editor.formElement = editor.container = editor.editorContainer = null;\n      editor.bodyElement = editor.contentDocument = editor.contentWindow = null;\n      editor.iframeElement = editor.targetElm = null;\n      if (editor.selection) {\n        editor.selection = editor.selection.win = editor.selection.dom = editor.selection.dom.doc = null;\n      }\n    };\n    const restoreForm = editor => {\n      const form = editor.formElement;\n      if (form) {\n        if (form._mceOldSubmit) {\n          form.submit = form._mceOldSubmit;\n          form._mceOldSubmit = null;\n        }\n        DOM$8.unbind(form, 'submit reset', editor.formEventDelegate);\n      }\n    };\n    const remove$1 = editor => {\n      if (!editor.removed) {\n        const {_selectionOverrides, editorUpload} = editor;\n        const body = editor.getBody();\n        const element = editor.getElement();\n        if (body) {\n          editor.save({ is_removing: true });\n        }\n        editor.removed = true;\n        editor.unbindAllNativeEvents();\n        if (editor.hasHiddenInput && element) {\n          DOM$8.remove(element.nextSibling);\n        }\n        fireRemove(editor);\n        editor.editorManager.remove(editor);\n        if (!editor.inline && body) {\n          restoreOriginalStyles(editor);\n        }\n        fireDetach(editor);\n        DOM$8.remove(editor.getContainer());\n        safeDestroy(_selectionOverrides);\n        safeDestroy(editorUpload);\n        editor.destroy();\n      }\n    };\n    const destroy = (editor, automatic) => {\n      const {selection, dom} = editor;\n      if (editor.destroyed) {\n        return;\n      }\n      if (!automatic && !editor.removed) {\n        editor.remove();\n        return;\n      }\n      if (!automatic) {\n        editor.editorManager.off('beforeunload', editor._beforeUnload);\n        if (editor.theme && editor.theme.destroy) {\n          editor.theme.destroy();\n        }\n        safeDestroy(selection);\n        safeDestroy(dom);\n      }\n      restoreForm(editor);\n      clearDomReferences(editor);\n      editor.destroyed = true;\n    };\n\n    const CreateIconManager = () => {\n      const lookup = {};\n      const add = (id, iconPack) => {\n        lookup[id] = iconPack;\n      };\n      const get = id => {\n        if (lookup[id]) {\n          return lookup[id];\n        }\n        return { icons: {} };\n      };\n      const has = id => has$2(lookup, id);\n      return {\n        add,\n        get,\n        has\n      };\n    };\n    const IconManager = CreateIconManager();\n\n    const ModelManager = AddOnManager.ModelManager;\n\n    const getProp = (propName, elm) => {\n      const rawElm = elm.dom;\n      return rawElm[propName];\n    };\n    const getComputedSizeProp = (propName, elm) => parseInt(get$7(elm, propName), 10);\n    const getClientWidth = curry(getProp, 'clientWidth');\n    const getClientHeight = curry(getProp, 'clientHeight');\n    const getMarginTop = curry(getComputedSizeProp, 'margin-top');\n    const getMarginLeft = curry(getComputedSizeProp, 'margin-left');\n    const getBoundingClientRect = elm => elm.dom.getBoundingClientRect();\n    const isInsideElementContentArea = (bodyElm, clientX, clientY) => {\n      const clientWidth = getClientWidth(bodyElm);\n      const clientHeight = getClientHeight(bodyElm);\n      return clientX >= 0 && clientY >= 0 && clientX <= clientWidth && clientY <= clientHeight;\n    };\n    const transpose = (inline, elm, clientX, clientY) => {\n      const clientRect = getBoundingClientRect(elm);\n      const deltaX = inline ? clientRect.left + elm.dom.clientLeft + getMarginLeft(elm) : 0;\n      const deltaY = inline ? clientRect.top + elm.dom.clientTop + getMarginTop(elm) : 0;\n      const x = clientX - deltaX;\n      const y = clientY - deltaY;\n      return {\n        x,\n        y\n      };\n    };\n    const isXYInContentArea = (editor, clientX, clientY) => {\n      const bodyElm = SugarElement.fromDom(editor.getBody());\n      const targetElm = editor.inline ? bodyElm : documentElement(bodyElm);\n      const transposedPoint = transpose(editor.inline, targetElm, clientX, clientY);\n      return isInsideElementContentArea(targetElm, transposedPoint.x, transposedPoint.y);\n    };\n    const fromDomSafe = node => Optional.from(node).map(SugarElement.fromDom);\n    const isEditorAttachedToDom = editor => {\n      const rawContainer = editor.inline ? editor.getBody() : editor.getContentAreaContainer();\n      return fromDomSafe(rawContainer).map(inBody).getOr(false);\n    };\n\n    const NotificationManagerImpl = () => {\n      const unimplemented = () => {\n        throw new Error('Theme did not provide a NotificationManager implementation.');\n      };\n      return {\n        open: unimplemented,\n        close: unimplemented,\n        getArgs: unimplemented\n      };\n    };\n\n    const NotificationManager = editor => {\n      const notifications = [];\n      const getImplementation = () => {\n        const theme = editor.theme;\n        return theme && theme.getNotificationManagerImpl ? theme.getNotificationManagerImpl() : NotificationManagerImpl();\n      };\n      const getTopNotification = () => {\n        return Optional.from(notifications[0]);\n      };\n      const isEqual = (a, b) => {\n        return a.type === b.type && a.text === b.text && !a.progressBar && !a.timeout && !b.progressBar && !b.timeout;\n      };\n      const reposition = () => {\n        each$g(notifications, notification => {\n          notification.reposition();\n        });\n      };\n      const addNotification = notification => {\n        notifications.push(notification);\n      };\n      const closeNotification = notification => {\n        findIndex$2(notifications, otherNotification => {\n          return otherNotification === notification;\n        }).each(index => {\n          notifications.splice(index, 1);\n        });\n      };\n      const open = (spec, fireEvent = true) => {\n        if (editor.removed || !isEditorAttachedToDom(editor)) {\n          return;\n        }\n        if (fireEvent) {\n          editor.dispatch('BeforeOpenNotification', { notification: spec });\n        }\n        return find$2(notifications, notification => {\n          return isEqual(getImplementation().getArgs(notification), spec);\n        }).getOrThunk(() => {\n          editor.editorManager.setActive(editor);\n          const notification = getImplementation().open(spec, () => {\n            closeNotification(notification);\n            reposition();\n            getTopNotification().fold(() => editor.focus(), top => focus$1(SugarElement.fromDom(top.getEl())));\n          });\n          addNotification(notification);\n          reposition();\n          editor.dispatch('OpenNotification', { notification: { ...notification } });\n          return notification;\n        });\n      };\n      const close = () => {\n        getTopNotification().each(notification => {\n          getImplementation().close(notification);\n          closeNotification(notification);\n          reposition();\n        });\n      };\n      const getNotifications = constant(notifications);\n      const registerEvents = editor => {\n        editor.on('SkinLoaded', () => {\n          const serviceMessage = getServiceMessage(editor);\n          if (serviceMessage) {\n            open({\n              text: serviceMessage,\n              type: 'warning',\n              timeout: 0\n            }, false);\n          }\n          reposition();\n        });\n        editor.on('show ResizeEditor ResizeWindow NodeChange', () => {\n          requestAnimationFrame(reposition);\n        });\n        editor.on('remove', () => {\n          each$g(notifications.slice(), notification => {\n            getImplementation().close(notification);\n          });\n        });\n      };\n      registerEvents(editor);\n      return {\n        open,\n        close,\n        getNotifications\n      };\n    };\n\n    const PluginManager = AddOnManager.PluginManager;\n\n    const ThemeManager = AddOnManager.ThemeManager;\n\n    var WindowManagerImpl = () => {\n      const unimplemented = () => {\n        throw new Error('Theme did not provide a WindowManager implementation.');\n      };\n      return {\n        open: unimplemented,\n        openUrl: unimplemented,\n        alert: unimplemented,\n        confirm: unimplemented,\n        close: unimplemented,\n        getParams: unimplemented,\n        setParams: unimplemented\n      };\n    };\n\n    const WindowManager = editor => {\n      let dialogs = [];\n      const getImplementation = () => {\n        const theme = editor.theme;\n        return theme && theme.getWindowManagerImpl ? theme.getWindowManagerImpl() : WindowManagerImpl();\n      };\n      const funcBind = (scope, f) => {\n        return (...args) => {\n          return f ? f.apply(scope, args) : undefined;\n        };\n      };\n      const fireOpenEvent = dialog => {\n        editor.dispatch('OpenWindow', { dialog });\n      };\n      const fireCloseEvent = dialog => {\n        editor.dispatch('CloseWindow', { dialog });\n      };\n      const addDialog = dialog => {\n        dialogs.push(dialog);\n        fireOpenEvent(dialog);\n      };\n      const closeDialog = dialog => {\n        fireCloseEvent(dialog);\n        dialogs = filter$6(dialogs, otherDialog => {\n          return otherDialog !== dialog;\n        });\n        if (dialogs.length === 0) {\n          editor.focus();\n        }\n      };\n      const getTopDialog = () => {\n        return Optional.from(dialogs[dialogs.length - 1]);\n      };\n      const storeSelectionAndOpenDialog = openDialog => {\n        editor.editorManager.setActive(editor);\n        store(editor);\n        editor.ui.show();\n        const dialog = openDialog();\n        addDialog(dialog);\n        return dialog;\n      };\n      const open = (args, params) => {\n        return storeSelectionAndOpenDialog(() => getImplementation().open(args, params, closeDialog));\n      };\n      const openUrl = args => {\n        return storeSelectionAndOpenDialog(() => getImplementation().openUrl(args, closeDialog));\n      };\n      const alert = (message, callback, scope) => {\n        const windowManagerImpl = getImplementation();\n        windowManagerImpl.alert(message, funcBind(scope ? scope : windowManagerImpl, callback));\n      };\n      const confirm = (message, callback, scope) => {\n        const windowManagerImpl = getImplementation();\n        windowManagerImpl.confirm(message, funcBind(scope ? scope : windowManagerImpl, callback));\n      };\n      const close = () => {\n        getTopDialog().each(dialog => {\n          getImplementation().close(dialog);\n          closeDialog(dialog);\n        });\n      };\n      editor.on('remove', () => {\n        each$g(dialogs, dialog => {\n          getImplementation().close(dialog);\n        });\n      });\n      return {\n        open,\n        openUrl,\n        alert,\n        confirm,\n        close\n      };\n    };\n\n    const displayNotification = (editor, message) => {\n      editor.notificationManager.open({\n        type: 'error',\n        text: message\n      });\n    };\n    const displayError = (editor, message) => {\n      if (editor._skinLoaded) {\n        displayNotification(editor, message);\n      } else {\n        editor.on('SkinLoaded', () => {\n          displayNotification(editor, message);\n        });\n      }\n    };\n    const uploadError = (editor, message) => {\n      displayError(editor, I18n.translate([\n        'Failed to upload image: {0}',\n        message\n      ]));\n    };\n    const logError = (editor, errorType, msg) => {\n      fireError(editor, errorType, { message: msg });\n      console.error(msg);\n    };\n    const createLoadError = (type, url, name) => name ? `Failed to load ${ type }: ${ name } from url ${ url }` : `Failed to load ${ type } url: ${ url }`;\n    const pluginLoadError = (editor, url, name) => {\n      logError(editor, 'PluginLoadError', createLoadError('plugin', url, name));\n    };\n    const iconsLoadError = (editor, url, name) => {\n      logError(editor, 'IconsLoadError', createLoadError('icons', url, name));\n    };\n    const languageLoadError = (editor, url, name) => {\n      logError(editor, 'LanguageLoadError', createLoadError('language', url, name));\n    };\n    const themeLoadError = (editor, url, name) => {\n      logError(editor, 'ThemeLoadError', createLoadError('theme', url, name));\n    };\n    const modelLoadError = (editor, url, name) => {\n      logError(editor, 'ModelLoadError', createLoadError('model', url, name));\n    };\n    const pluginInitError = (editor, name, err) => {\n      const message = I18n.translate([\n        'Failed to initialize plugin: {0}',\n        name\n      ]);\n      fireError(editor, 'PluginLoadError', { message });\n      initError(message, err);\n      displayError(editor, message);\n    };\n    const initError = (message, ...x) => {\n      const console = window.console;\n      if (console) {\n        if (console.error) {\n          console.error(message, ...x);\n        } else {\n          console.log(message, ...x);\n        }\n      }\n    };\n\n    const isContentCssSkinName = url => /^[a-z0-9\\-]+$/i.test(url);\n    const getContentCssUrls = editor => {\n      return transformToUrls(editor, getContentCss(editor));\n    };\n    const getFontCssUrls = editor => {\n      return transformToUrls(editor, getFontCss(editor));\n    };\n    const transformToUrls = (editor, cssLinks) => {\n      const skinUrl = editor.editorManager.baseURL + '/skins/content';\n      const suffix = editor.editorManager.suffix;\n      const contentCssFile = `content${ suffix }.css`;\n      const inline = editor.inline === true;\n      return map$3(cssLinks, url => {\n        if (isContentCssSkinName(url) && !inline) {\n          return `${ skinUrl }/${ url }/${ contentCssFile }`;\n        } else {\n          return editor.documentBaseURI.toAbsolute(url);\n        }\n      });\n    };\n    const appendContentCssFromSettings = editor => {\n      editor.contentCSS = editor.contentCSS.concat(getContentCssUrls(editor), getFontCssUrls(editor));\n    };\n\n    const filter$1 = always;\n    const bind$1 = (element, event, handler) => bind$2(element, event, filter$1, handler);\n\n    const UploadStatus = () => {\n      const PENDING = 1, UPLOADED = 2;\n      let blobUriStatuses = {};\n      const createStatus = (status, resultUri) => {\n        return {\n          status,\n          resultUri\n        };\n      };\n      const hasBlobUri = blobUri => {\n        return blobUri in blobUriStatuses;\n      };\n      const getResultUri = blobUri => {\n        const result = blobUriStatuses[blobUri];\n        return result ? result.resultUri : null;\n      };\n      const isPending = blobUri => {\n        return hasBlobUri(blobUri) ? blobUriStatuses[blobUri].status === PENDING : false;\n      };\n      const isUploaded = blobUri => {\n        return hasBlobUri(blobUri) ? blobUriStatuses[blobUri].status === UPLOADED : false;\n      };\n      const markPending = blobUri => {\n        blobUriStatuses[blobUri] = createStatus(PENDING, null);\n      };\n      const markUploaded = (blobUri, resultUri) => {\n        blobUriStatuses[blobUri] = createStatus(UPLOADED, resultUri);\n      };\n      const removeFailed = blobUri => {\n        delete blobUriStatuses[blobUri];\n      };\n      const destroy = () => {\n        blobUriStatuses = {};\n      };\n      return {\n        hasBlobUri,\n        getResultUri,\n        isPending,\n        isUploaded,\n        markPending,\n        markUploaded,\n        removeFailed,\n        destroy\n      };\n    };\n\n    let count = 0;\n    const seed = () => {\n      const rnd = () => {\n        return Math.round(Math.random() * 4294967295).toString(36);\n      };\n      const now = new Date().getTime();\n      return 's' + now.toString(36) + rnd() + rnd() + rnd();\n    };\n    const uuid = prefix => {\n      return prefix + count++ + seed();\n    };\n\n    const BlobCache = () => {\n      let cache = [];\n      const mimeToExt = mime => {\n        const mimes = {\n          'image/jpeg': 'jpg',\n          'image/jpg': 'jpg',\n          'image/gif': 'gif',\n          'image/png': 'png',\n          'image/apng': 'apng',\n          'image/avif': 'avif',\n          'image/svg+xml': 'svg',\n          'image/webp': 'webp',\n          'image/bmp': 'bmp',\n          'image/tiff': 'tiff'\n        };\n        return mimes[mime.toLowerCase()] || 'dat';\n      };\n      const create = (o, blob, base64, name, filename) => {\n        if (isString(o)) {\n          const id = o;\n          return toBlobInfo({\n            id,\n            name,\n            filename,\n            blob,\n            base64\n          });\n        } else if (isObject(o)) {\n          return toBlobInfo(o);\n        } else {\n          throw new Error('Unknown input type');\n        }\n      };\n      const toBlobInfo = o => {\n        if (!o.blob || !o.base64) {\n          throw new Error('blob and base64 representations of the image are required for BlobInfo to be created');\n        }\n        const id = o.id || uuid('blobid');\n        const name = o.name || id;\n        const blob = o.blob;\n        return {\n          id: constant(id),\n          name: constant(name),\n          filename: constant(o.filename || name + '.' + mimeToExt(blob.type)),\n          blob: constant(blob),\n          base64: constant(o.base64),\n          blobUri: constant(o.blobUri || URL.createObjectURL(blob)),\n          uri: constant(o.uri)\n        };\n      };\n      const add = blobInfo => {\n        if (!get(blobInfo.id())) {\n          cache.push(blobInfo);\n        }\n      };\n      const findFirst = predicate => find$2(cache, predicate).getOrUndefined();\n      const get = id => findFirst(cachedBlobInfo => cachedBlobInfo.id() === id);\n      const getByUri = blobUri => findFirst(blobInfo => blobInfo.blobUri() === blobUri);\n      const getByData = (base64, type) => findFirst(blobInfo => blobInfo.base64() === base64 && blobInfo.blob().type === type);\n      const removeByUri = blobUri => {\n        cache = filter$6(cache, blobInfo => {\n          if (blobInfo.blobUri() === blobUri) {\n            URL.revokeObjectURL(blobInfo.blobUri());\n            return false;\n          }\n          return true;\n        });\n      };\n      const destroy = () => {\n        each$g(cache, cachedBlobInfo => {\n          URL.revokeObjectURL(cachedBlobInfo.blobUri());\n        });\n        cache = [];\n      };\n      return {\n        create,\n        add,\n        get,\n        getByUri,\n        getByData,\n        findFirst,\n        removeByUri,\n        destroy\n      };\n    };\n\n    const Uploader = (uploadStatus, settings) => {\n      const pendingPromises = {};\n      const pathJoin = (path1, path2) => {\n        if (path1) {\n          return path1.replace(/\\/$/, '') + '/' + path2.replace(/^\\//, '');\n        }\n        return path2;\n      };\n      const defaultHandler = (blobInfo, progress) => new Promise((success, failure) => {\n        const xhr = new XMLHttpRequest();\n        xhr.open('POST', settings.url);\n        xhr.withCredentials = settings.credentials;\n        xhr.upload.onprogress = e => {\n          progress(e.loaded / e.total * 100);\n        };\n        xhr.onerror = () => {\n          failure('Image upload failed due to a XHR Transport error. Code: ' + xhr.status);\n        };\n        xhr.onload = () => {\n          if (xhr.status < 200 || xhr.status >= 300) {\n            failure('HTTP Error: ' + xhr.status);\n            return;\n          }\n          const json = JSON.parse(xhr.responseText);\n          if (!json || !isString(json.location)) {\n            failure('Invalid JSON: ' + xhr.responseText);\n            return;\n          }\n          success(pathJoin(settings.basePath, json.location));\n        };\n        const formData = new FormData();\n        formData.append('file', blobInfo.blob(), blobInfo.filename());\n        xhr.send(formData);\n      });\n      const noUpload = () => new Promise(resolve => {\n        resolve([]);\n      });\n      const handlerSuccess = (blobInfo, url) => ({\n        url,\n        blobInfo,\n        status: true\n      });\n      const handlerFailure = (blobInfo, error) => ({\n        url: '',\n        blobInfo,\n        status: false,\n        error\n      });\n      const resolvePending = (blobUri, result) => {\n        Tools.each(pendingPromises[blobUri], resolve => {\n          resolve(result);\n        });\n        delete pendingPromises[blobUri];\n      };\n      const uploadBlobInfo = (blobInfo, handler, openNotification) => {\n        uploadStatus.markPending(blobInfo.blobUri());\n        return new Promise(resolve => {\n          let notification;\n          let progress;\n          try {\n            const closeNotification = () => {\n              if (notification) {\n                notification.close();\n                progress = noop;\n              }\n            };\n            const success = url => {\n              closeNotification();\n              uploadStatus.markUploaded(blobInfo.blobUri(), url);\n              resolvePending(blobInfo.blobUri(), handlerSuccess(blobInfo, url));\n              resolve(handlerSuccess(blobInfo, url));\n            };\n            const failure = error => {\n              closeNotification();\n              uploadStatus.removeFailed(blobInfo.blobUri());\n              resolvePending(blobInfo.blobUri(), handlerFailure(blobInfo, error));\n              resolve(handlerFailure(blobInfo, error));\n            };\n            progress = percent => {\n              if (percent < 0 || percent > 100) {\n                return;\n              }\n              Optional.from(notification).orThunk(() => Optional.from(openNotification).map(apply$1)).each(n => {\n                notification = n;\n                n.progressBar.value(percent);\n              });\n            };\n            handler(blobInfo, progress).then(success, err => {\n              failure(isString(err) ? { message: err } : err);\n            });\n          } catch (ex) {\n            resolve(handlerFailure(blobInfo, ex));\n          }\n        });\n      };\n      const isDefaultHandler = handler => handler === defaultHandler;\n      const pendingUploadBlobInfo = blobInfo => {\n        const blobUri = blobInfo.blobUri();\n        return new Promise(resolve => {\n          pendingPromises[blobUri] = pendingPromises[blobUri] || [];\n          pendingPromises[blobUri].push(resolve);\n        });\n      };\n      const uploadBlobs = (blobInfos, openNotification) => {\n        blobInfos = Tools.grep(blobInfos, blobInfo => !uploadStatus.isUploaded(blobInfo.blobUri()));\n        return Promise.all(Tools.map(blobInfos, blobInfo => uploadStatus.isPending(blobInfo.blobUri()) ? pendingUploadBlobInfo(blobInfo) : uploadBlobInfo(blobInfo, settings.handler, openNotification)));\n      };\n      const upload = (blobInfos, openNotification) => !settings.url && isDefaultHandler(settings.handler) ? noUpload() : uploadBlobs(blobInfos, openNotification);\n      if (isFunction(settings.handler) === false) {\n        settings.handler = defaultHandler;\n      }\n      return { upload };\n    };\n\n    const openNotification = editor => () => editor.notificationManager.open({\n      text: editor.translate('Image uploading...'),\n      type: 'info',\n      timeout: -1,\n      progressBar: true\n    });\n    const createUploader = (editor, uploadStatus) => Uploader(uploadStatus, {\n      url: getImageUploadUrl(editor),\n      basePath: getImageUploadBasePath(editor),\n      credentials: getImagesUploadCredentials(editor),\n      handler: getImagesUploadHandler(editor)\n    });\n    const ImageUploader = editor => {\n      const uploadStatus = UploadStatus();\n      const uploader = createUploader(editor, uploadStatus);\n      return { upload: (blobInfos, showNotification = true) => uploader.upload(blobInfos, showNotification ? openNotification(editor) : undefined) };\n    };\n\n    const UploadChangeHandler = editor => {\n      const lastChangedLevel = Cell(null);\n      editor.on('change AddUndo', e => {\n        lastChangedLevel.set({ ...e.level });\n      });\n      const fireIfChanged = () => {\n        const data = editor.undoManager.data;\n        last$3(data).filter(level => {\n          return !isEq$1(lastChangedLevel.get(), level);\n        }).each(level => {\n          editor.setDirty(true);\n          editor.dispatch('change', {\n            level,\n            lastLevel: get$b(data, data.length - 2).getOrNull()\n          });\n        });\n      };\n      return { fireIfChanged };\n    };\n    const EditorUpload = editor => {\n      const blobCache = BlobCache();\n      let uploader, imageScanner;\n      const uploadStatus = UploadStatus();\n      const urlFilters = [];\n      const changeHandler = UploadChangeHandler(editor);\n      const aliveGuard = callback => {\n        return result => {\n          if (editor.selection) {\n            return callback(result);\n          }\n          return [];\n        };\n      };\n      const cacheInvalidator = url => url + (url.indexOf('?') === -1 ? '?' : '&') + new Date().getTime();\n      const replaceString = (content, search, replace) => {\n        let index = 0;\n        do {\n          index = content.indexOf(search, index);\n          if (index !== -1) {\n            content = content.substring(0, index) + replace + content.substr(index + search.length);\n            index += replace.length - search.length + 1;\n          }\n        } while (index !== -1);\n        return content;\n      };\n      const replaceImageUrl = (content, targetUrl, replacementUrl) => {\n        const replacementString = `src=\"${ replacementUrl }\"${ replacementUrl === Env.transparentSrc ? ' data-mce-placeholder=\"1\"' : '' }`;\n        content = replaceString(content, `src=\"${ targetUrl }\"`, replacementString);\n        content = replaceString(content, 'data-mce-src=\"' + targetUrl + '\"', 'data-mce-src=\"' + replacementUrl + '\"');\n        return content;\n      };\n      const replaceUrlInUndoStack = (targetUrl, replacementUrl) => {\n        each$g(editor.undoManager.data, level => {\n          if (level.type === 'fragmented') {\n            level.fragments = map$3(level.fragments, fragment => replaceImageUrl(fragment, targetUrl, replacementUrl));\n          } else {\n            level.content = replaceImageUrl(level.content, targetUrl, replacementUrl);\n          }\n        });\n      };\n      const replaceImageUriInView = (image, resultUri) => {\n        const src = editor.convertURL(resultUri, 'src');\n        replaceUrlInUndoStack(image.src, resultUri);\n        setAll$1(SugarElement.fromDom(image), {\n          'src': shouldReuseFileName(editor) ? cacheInvalidator(resultUri) : resultUri,\n          'data-mce-src': src\n        });\n      };\n      const uploadImages = () => {\n        if (!uploader) {\n          uploader = createUploader(editor, uploadStatus);\n        }\n        return scanForImages().then(aliveGuard(imageInfos => {\n          const blobInfos = map$3(imageInfos, imageInfo => imageInfo.blobInfo);\n          return uploader.upload(blobInfos, openNotification(editor)).then(aliveGuard(result => {\n            const imagesToRemove = [];\n            const filteredResult = map$3(result, (uploadInfo, index) => {\n              const blobInfo = imageInfos[index].blobInfo;\n              const image = imageInfos[index].image;\n              let removed = false;\n              if (uploadInfo.status && shouldReplaceBlobUris(editor)) {\n                blobCache.removeByUri(image.src);\n                if (isRtc(editor)) ; else {\n                  replaceImageUriInView(image, uploadInfo.url);\n                }\n              } else if (uploadInfo.error) {\n                if (uploadInfo.error.remove) {\n                  replaceUrlInUndoStack(image.getAttribute('src'), Env.transparentSrc);\n                  imagesToRemove.push(image);\n                  removed = true;\n                }\n                uploadError(editor, uploadInfo.error.message);\n              }\n              return {\n                element: image,\n                status: uploadInfo.status,\n                uploadUri: uploadInfo.url,\n                blobInfo,\n                removed\n              };\n            });\n            if (filteredResult.length > 0) {\n              changeHandler.fireIfChanged();\n            }\n            if (imagesToRemove.length > 0 && !isRtc(editor)) {\n              editor.undoManager.transact(() => {\n                each$g(imagesToRemove, element => {\n                  editor.dom.remove(element);\n                  blobCache.removeByUri(element.src);\n                });\n              });\n            }\n            return filteredResult;\n          }));\n        }));\n      };\n      const uploadImagesAuto = () => isAutomaticUploadsEnabled(editor) ? uploadImages() : Promise.resolve([]);\n      const isValidDataUriImage = imgElm => forall(urlFilters, filter => filter(imgElm));\n      const addFilter = filter => {\n        urlFilters.push(filter);\n      };\n      const scanForImages = () => {\n        if (!imageScanner) {\n          imageScanner = ImageScanner(uploadStatus, blobCache);\n        }\n        return imageScanner.findAll(editor.getBody(), isValidDataUriImage).then(aliveGuard(result => {\n          result = filter$6(result, resultItem => {\n            if (typeof resultItem === 'string') {\n              displayError(editor, resultItem);\n              return false;\n            }\n            return true;\n          });\n          if (isRtc(editor)) ; else {\n            each$g(result, resultItem => {\n              replaceUrlInUndoStack(resultItem.image.src, resultItem.blobInfo.blobUri());\n              resultItem.image.src = resultItem.blobInfo.blobUri();\n              resultItem.image.removeAttribute('data-mce-src');\n            });\n          }\n          return result;\n        }));\n      };\n      const destroy = () => {\n        blobCache.destroy();\n        uploadStatus.destroy();\n        imageScanner = uploader = null;\n      };\n      const replaceBlobUris = content => {\n        return content.replace(/src=\"(blob:[^\"]+)\"/g, (match, blobUri) => {\n          const resultUri = uploadStatus.getResultUri(blobUri);\n          if (resultUri) {\n            return 'src=\"' + resultUri + '\"';\n          }\n          let blobInfo = blobCache.getByUri(blobUri);\n          if (!blobInfo) {\n            blobInfo = foldl(editor.editorManager.get(), (result, editor) => {\n              return result || editor.editorUpload && editor.editorUpload.blobCache.getByUri(blobUri);\n            }, null);\n          }\n          if (blobInfo) {\n            const blob = blobInfo.blob();\n            return 'src=\"data:' + blob.type + ';base64,' + blobInfo.base64() + '\"';\n          }\n          return match;\n        });\n      };\n      editor.on('SetContent', () => {\n        if (isAutomaticUploadsEnabled(editor)) {\n          uploadImagesAuto();\n        } else {\n          scanForImages();\n        }\n      });\n      editor.on('RawSaveContent', e => {\n        e.content = replaceBlobUris(e.content);\n      });\n      editor.on('GetContent', e => {\n        if (e.source_view || e.format === 'raw' || e.format === 'tree') {\n          return;\n        }\n        e.content = replaceBlobUris(e.content);\n      });\n      editor.on('PostRender', () => {\n        editor.parser.addNodeFilter('img', images => {\n          each$g(images, img => {\n            const src = img.attr('src');\n            if (blobCache.getByUri(src)) {\n              return;\n            }\n            const resultUri = uploadStatus.getResultUri(src);\n            if (resultUri) {\n              img.attr('src', resultUri);\n            }\n          });\n        });\n      });\n      return {\n        blobCache,\n        addFilter,\n        uploadImages,\n        uploadImagesAuto,\n        scanForImages,\n        destroy\n      };\n    };\n\n    const get$1 = editor => {\n      const dom = editor.dom;\n      const schemaType = editor.schema.type;\n      const formats = {\n        valigntop: [{\n            selector: 'td,th',\n            styles: { verticalAlign: 'top' }\n          }],\n        valignmiddle: [{\n            selector: 'td,th',\n            styles: { verticalAlign: 'middle' }\n          }],\n        valignbottom: [{\n            selector: 'td,th',\n            styles: { verticalAlign: 'bottom' }\n          }],\n        alignleft: [\n          {\n            selector: 'figure.image',\n            collapsed: false,\n            classes: 'align-left',\n            ceFalseOverride: true,\n            preview: 'font-family font-size'\n          },\n          {\n            selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li',\n            styles: { textAlign: 'left' },\n            inherit: false,\n            preview: false\n          },\n          {\n            selector: 'img,audio,video',\n            collapsed: false,\n            styles: { float: 'left' },\n            preview: 'font-family font-size'\n          },\n          {\n            selector: 'table',\n            collapsed: false,\n            styles: {\n              marginLeft: '0px',\n              marginRight: 'auto'\n            },\n            onformat: table => {\n              dom.setStyle(table, 'float', null);\n            },\n            preview: 'font-family font-size'\n          }\n        ],\n        aligncenter: [\n          {\n            selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li',\n            styles: { textAlign: 'center' },\n            inherit: false,\n            preview: 'font-family font-size'\n          },\n          {\n            selector: 'figure.image',\n            collapsed: false,\n            classes: 'align-center',\n            ceFalseOverride: true,\n            preview: 'font-family font-size'\n          },\n          {\n            selector: 'img,audio,video',\n            collapsed: false,\n            styles: {\n              display: 'block',\n              marginLeft: 'auto',\n              marginRight: 'auto'\n            },\n            preview: false\n          },\n          {\n            selector: 'table',\n            collapsed: false,\n            styles: {\n              marginLeft: 'auto',\n              marginRight: 'auto'\n            },\n            preview: 'font-family font-size'\n          }\n        ],\n        alignright: [\n          {\n            selector: 'figure.image',\n            collapsed: false,\n            classes: 'align-right',\n            ceFalseOverride: true,\n            preview: 'font-family font-size'\n          },\n          {\n            selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li',\n            styles: { textAlign: 'right' },\n            inherit: false,\n            preview: 'font-family font-size'\n          },\n          {\n            selector: 'img,audio,video',\n            collapsed: false,\n            styles: { float: 'right' },\n            preview: 'font-family font-size'\n          },\n          {\n            selector: 'table',\n            collapsed: false,\n            styles: {\n              marginRight: '0px',\n              marginLeft: 'auto'\n            },\n            onformat: table => {\n              dom.setStyle(table, 'float', null);\n            },\n            preview: 'font-family font-size'\n          }\n        ],\n        alignjustify: [{\n            selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li',\n            styles: { textAlign: 'justify' },\n            inherit: false,\n            preview: 'font-family font-size'\n          }],\n        bold: [\n          {\n            inline: 'strong',\n            remove: 'all',\n            preserve_attributes: [\n              'class',\n              'style'\n            ]\n          },\n          {\n            inline: 'span',\n            styles: { fontWeight: 'bold' }\n          },\n          {\n            inline: 'b',\n            remove: 'all',\n            preserve_attributes: [\n              'class',\n              'style'\n            ]\n          }\n        ],\n        italic: [\n          {\n            inline: 'em',\n            remove: 'all',\n            preserve_attributes: [\n              'class',\n              'style'\n            ]\n          },\n          {\n            inline: 'span',\n            styles: { fontStyle: 'italic' }\n          },\n          {\n            inline: 'i',\n            remove: 'all',\n            preserve_attributes: [\n              'class',\n              'style'\n            ]\n          }\n        ],\n        underline: [\n          {\n            inline: 'span',\n            styles: { textDecoration: 'underline' },\n            exact: true\n          },\n          {\n            inline: 'u',\n            remove: 'all',\n            preserve_attributes: [\n              'class',\n              'style'\n            ]\n          }\n        ],\n        strikethrough: (() => {\n          const span = {\n            inline: 'span',\n            styles: { textDecoration: 'line-through' },\n            exact: true\n          };\n          const strike = {\n            inline: 'strike',\n            remove: 'all',\n            preserve_attributes: [\n              'class',\n              'style'\n            ]\n          };\n          const s = {\n            inline: 's',\n            remove: 'all',\n            preserve_attributes: [\n              'class',\n              'style'\n            ]\n          };\n          return schemaType !== 'html4' ? [\n            s,\n            span,\n            strike\n          ] : [\n            span,\n            s,\n            strike\n          ];\n        })(),\n        forecolor: {\n          inline: 'span',\n          styles: { color: '%value' },\n          links: true,\n          remove_similar: true,\n          clear_child_styles: true\n        },\n        hilitecolor: {\n          inline: 'span',\n          styles: { backgroundColor: '%value' },\n          links: true,\n          remove_similar: true,\n          clear_child_styles: true\n        },\n        fontname: {\n          inline: 'span',\n          toggle: false,\n          styles: { fontFamily: '%value' },\n          clear_child_styles: true\n        },\n        fontsize: {\n          inline: 'span',\n          toggle: false,\n          styles: { fontSize: '%value' },\n          clear_child_styles: true\n        },\n        lineheight: {\n          selector: 'h1,h2,h3,h4,h5,h6,p,li,td,th,div',\n          styles: { lineHeight: '%value' }\n        },\n        fontsize_class: {\n          inline: 'span',\n          attributes: { class: '%value' }\n        },\n        blockquote: {\n          block: 'blockquote',\n          wrapper: true,\n          remove: 'all'\n        },\n        subscript: { inline: 'sub' },\n        superscript: { inline: 'sup' },\n        code: { inline: 'code' },\n        link: {\n          inline: 'a',\n          selector: 'a',\n          remove: 'all',\n          split: true,\n          deep: true,\n          onmatch: (node, _fmt, _itemName) => {\n            return isElement$6(node) && node.hasAttribute('href');\n          },\n          onformat: (elm, _fmt, vars) => {\n            Tools.each(vars, (value, key) => {\n              dom.setAttrib(elm, key, value);\n            });\n          }\n        },\n        lang: {\n          inline: 'span',\n          clear_child_styles: true,\n          remove_similar: true,\n          attributes: {\n            'lang': '%value',\n            'data-mce-lang': vars => {\n              var _a;\n              return (_a = vars === null || vars === void 0 ? void 0 : vars.customValue) !== null && _a !== void 0 ? _a : null;\n            }\n          }\n        },\n        removeformat: [\n          {\n            selector: 'b,strong,em,i,font,u,strike,s,sub,sup,dfn,code,samp,kbd,var,cite,mark,q,del,ins,small',\n            remove: 'all',\n            split: true,\n            expand: false,\n            block_expand: true,\n            deep: true\n          },\n          {\n            selector: 'span',\n            attributes: [\n              'style',\n              'class'\n            ],\n            remove: 'empty',\n            split: true,\n            expand: false,\n            deep: true\n          },\n          {\n            selector: '*',\n            attributes: [\n              'style',\n              'class'\n            ],\n            split: false,\n            expand: false,\n            deep: true\n          }\n        ]\n      };\n      Tools.each('p h1 h2 h3 h4 h5 h6 div address pre dt dd samp'.split(/\\s/), name => {\n        formats[name] = {\n          block: name,\n          remove: 'all'\n        };\n      });\n      return formats;\n    };\n\n    const genericBase = {\n      remove_similar: true,\n      inherit: false\n    };\n    const cellBase = {\n      selector: 'td,th',\n      ...genericBase\n    };\n    const cellFormats = {\n      tablecellbackgroundcolor: {\n        styles: { backgroundColor: '%value' },\n        ...cellBase\n      },\n      tablecellverticalalign: {\n        styles: { 'vertical-align': '%value' },\n        ...cellBase\n      },\n      tablecellbordercolor: {\n        styles: { borderColor: '%value' },\n        ...cellBase\n      },\n      tablecellclass: {\n        classes: ['%value'],\n        ...cellBase\n      },\n      tableclass: {\n        selector: 'table',\n        classes: ['%value'],\n        ...genericBase\n      },\n      tablecellborderstyle: {\n        styles: { borderStyle: '%value' },\n        ...cellBase\n      },\n      tablecellborderwidth: {\n        styles: { borderWidth: '%value' },\n        ...cellBase\n      }\n    };\n    const get = constant(cellFormats);\n\n    const FormatRegistry = editor => {\n      const formats = {};\n      const get$2 = name => isNonNullable(name) ? formats[name] : formats;\n      const has = name => has$2(formats, name);\n      const register = (name, format) => {\n        if (name) {\n          if (!isString(name)) {\n            each$f(name, (format, name) => {\n              register(name, format);\n            });\n          } else {\n            if (!isArray$1(format)) {\n              format = [format];\n            }\n            each$g(format, format => {\n              if (isUndefined(format.deep)) {\n                format.deep = !isSelectorFormat(format);\n              }\n              if (isUndefined(format.split)) {\n                format.split = !isSelectorFormat(format) || isInlineFormat(format);\n              }\n              if (isUndefined(format.remove) && isSelectorFormat(format) && !isInlineFormat(format)) {\n                format.remove = 'none';\n              }\n              if (isSelectorFormat(format) && isInlineFormat(format)) {\n                format.mixed = true;\n                format.block_expand = true;\n              }\n              if (isString(format.classes)) {\n                format.classes = format.classes.split(/\\s+/);\n              }\n            });\n            formats[name] = format;\n          }\n        }\n      };\n      const unregister = name => {\n        if (name && formats[name]) {\n          delete formats[name];\n        }\n        return formats;\n      };\n      register(get$1(editor));\n      register(get());\n      register(getFormats(editor));\n      return {\n        get: get$2,\n        has,\n        register,\n        unregister\n      };\n    };\n\n    const each$3 = Tools.each;\n    const dom = DOMUtils.DOM;\n    const parsedSelectorToHtml = (ancestry, editor) => {\n      let elm, item, fragment;\n      const schema = editor && editor.schema || Schema({});\n      const decorate = (elm, item) => {\n        if (item.classes.length) {\n          dom.addClass(elm, item.classes.join(' '));\n        }\n        dom.setAttribs(elm, item.attrs);\n      };\n      const createElement = sItem => {\n        item = typeof sItem === 'string' ? {\n          name: sItem,\n          classes: [],\n          attrs: {}\n        } : sItem;\n        const elm = dom.create(item.name);\n        decorate(elm, item);\n        return elm;\n      };\n      const getRequiredParent = (elm, candidate) => {\n        const name = typeof elm !== 'string' ? elm.nodeName.toLowerCase() : elm;\n        const elmRule = schema.getElementRule(name);\n        const parentsRequired = elmRule && elmRule.parentsRequired;\n        if (parentsRequired && parentsRequired.length) {\n          return candidate && Tools.inArray(parentsRequired, candidate) !== -1 ? candidate : parentsRequired[0];\n        } else {\n          return false;\n        }\n      };\n      const wrapInHtml = (elm, ancestry, siblings) => {\n        let parent, parentCandidate;\n        const ancestor = ancestry.length > 0 && ancestry[0];\n        const ancestorName = ancestor && ancestor.name;\n        const parentRequired = getRequiredParent(elm, ancestorName);\n        if (parentRequired) {\n          if (ancestorName === parentRequired) {\n            parentCandidate = ancestry[0];\n            ancestry = ancestry.slice(1);\n          } else {\n            parentCandidate = parentRequired;\n          }\n        } else if (ancestor) {\n          parentCandidate = ancestry[0];\n          ancestry = ancestry.slice(1);\n        } else if (!siblings) {\n          return elm;\n        }\n        if (parentCandidate) {\n          parent = createElement(parentCandidate);\n          parent.appendChild(elm);\n        }\n        if (siblings) {\n          if (!parent) {\n            parent = dom.create('div');\n            parent.appendChild(elm);\n          }\n          Tools.each(siblings, sibling => {\n            const siblingElm = createElement(sibling);\n            parent.insertBefore(siblingElm, elm);\n          });\n        }\n        return wrapInHtml(parent, ancestry, parentCandidate && parentCandidate.siblings);\n      };\n      if (ancestry && ancestry.length) {\n        item = ancestry[0];\n        elm = createElement(item);\n        fragment = dom.create('div');\n        fragment.appendChild(wrapInHtml(elm, ancestry.slice(1), item.siblings));\n        return fragment;\n      } else {\n        return '';\n      }\n    };\n    const parseSelectorItem = item => {\n      let tagName;\n      const obj = {\n        classes: [],\n        attrs: {}\n      };\n      item = obj.selector = Tools.trim(item);\n      if (item !== '*') {\n        tagName = item.replace(/(?:([#\\.]|::?)([\\w\\-]+)|(\\[)([^\\]]+)\\]?)/g, ($0, $1, $2, $3, $4) => {\n          switch ($1) {\n          case '#':\n            obj.attrs.id = $2;\n            break;\n          case '.':\n            obj.classes.push($2);\n            break;\n          case ':':\n            if (Tools.inArray('checked disabled enabled read-only required'.split(' '), $2) !== -1) {\n              obj.attrs[$2] = $2;\n            }\n            break;\n          }\n          if ($3 === '[') {\n            const m = $4.match(/([\\w\\-]+)(?:\\=\\\"([^\\\"]+))?/);\n            if (m) {\n              obj.attrs[m[1]] = m[2];\n            }\n          }\n          return '';\n        });\n      }\n      obj.name = tagName || 'div';\n      return obj;\n    };\n    const parseSelector = selector => {\n      if (!selector || typeof selector !== 'string') {\n        return [];\n      }\n      selector = selector.split(/\\s*,\\s*/)[0];\n      selector = selector.replace(/\\s*(~\\+|~|\\+|>)\\s*/g, '$1');\n      return Tools.map(selector.split(/(?:>|\\s+(?![^\\[\\]]+\\]))/), item => {\n        const siblings = Tools.map(item.split(/(?:~\\+|~|\\+)/), parseSelectorItem);\n        const obj = siblings.pop();\n        if (siblings.length) {\n          obj.siblings = siblings;\n        }\n        return obj;\n      }).reverse();\n    };\n    const getCssText = (editor, format) => {\n      let name, previewFrag;\n      let previewCss = '', parentFontSize;\n      let previewStyles = getPreviewStyles(editor);\n      if (previewStyles === '') {\n        return '';\n      }\n      const removeVars = val => {\n        return val.replace(/%(\\w+)/g, '');\n      };\n      if (typeof format === 'string') {\n        format = editor.formatter.get(format);\n        if (!format) {\n          return;\n        }\n        format = format[0];\n      }\n      if ('preview' in format) {\n        const previewOpt = get$a(format, 'preview');\n        if (is$2(previewOpt, false)) {\n          return '';\n        } else {\n          previewStyles = previewOpt.getOr(previewStyles);\n        }\n      }\n      name = format.block || format.inline || 'span';\n      const items = parseSelector(format.selector);\n      if (items.length) {\n        if (!items[0].name) {\n          items[0].name = name;\n        }\n        name = format.selector;\n        previewFrag = parsedSelectorToHtml(items, editor);\n      } else {\n        previewFrag = parsedSelectorToHtml([name], editor);\n      }\n      const previewElm = dom.select(name, previewFrag)[0] || previewFrag.firstChild;\n      each$3(format.styles, (value, name) => {\n        const newValue = removeVars(value);\n        if (newValue) {\n          dom.setStyle(previewElm, name, newValue);\n        }\n      });\n      each$3(format.attributes, (value, name) => {\n        const newValue = removeVars(value);\n        if (newValue) {\n          dom.setAttrib(previewElm, name, newValue);\n        }\n      });\n      each$3(format.classes, value => {\n        const newValue = removeVars(value);\n        if (!dom.hasClass(previewElm, newValue)) {\n          dom.addClass(previewElm, newValue);\n        }\n      });\n      editor.dispatch('PreviewFormats');\n      dom.setStyles(previewFrag, {\n        position: 'absolute',\n        left: -65535\n      });\n      editor.getBody().appendChild(previewFrag);\n      parentFontSize = dom.getStyle(editor.getBody(), 'fontSize', true);\n      parentFontSize = /px$/.test(parentFontSize) ? parseInt(parentFontSize, 10) : 0;\n      each$3(previewStyles.split(' '), name => {\n        let value = dom.getStyle(previewElm, name, true);\n        if (name === 'background-color' && /transparent|rgba\\s*\\([^)]+,\\s*0\\)/.test(value)) {\n          value = dom.getStyle(editor.getBody(), name, true);\n          if (rgbaToHexString(value).toLowerCase() === '#ffffff') {\n            return;\n          }\n        }\n        if (name === 'color') {\n          if (rgbaToHexString(value).toLowerCase() === '#000000') {\n            return;\n          }\n        }\n        if (name === 'font-size') {\n          if (/em|%$/.test(value)) {\n            if (parentFontSize === 0) {\n              return;\n            }\n            const numValue = parseFloat(value) / (/%$/.test(value) ? 100 : 1);\n            value = numValue * parentFontSize + 'px';\n          }\n        }\n        if (name === 'border' && value) {\n          previewCss += 'padding:0 2px;';\n        }\n        previewCss += name + ':' + value + ';';\n      });\n      editor.dispatch('AfterPreviewFormats');\n      dom.remove(previewFrag);\n      return previewCss;\n    };\n\n    const setup$r = editor => {\n      editor.addShortcut('meta+b', '', 'Bold');\n      editor.addShortcut('meta+i', '', 'Italic');\n      editor.addShortcut('meta+u', '', 'Underline');\n      for (let i = 1; i <= 6; i++) {\n        editor.addShortcut('access+' + i, '', [\n          'FormatBlock',\n          false,\n          'h' + i\n        ]);\n      }\n      editor.addShortcut('access+7', '', [\n        'FormatBlock',\n        false,\n        'p'\n      ]);\n      editor.addShortcut('access+8', '', [\n        'FormatBlock',\n        false,\n        'div'\n      ]);\n      editor.addShortcut('access+9', '', [\n        'FormatBlock',\n        false,\n        'address'\n      ]);\n    };\n\n    const Formatter = editor => {\n      const formats = FormatRegistry(editor);\n      const formatChangeState = Cell(null);\n      setup$r(editor);\n      setup$u(editor);\n      return {\n        get: formats.get,\n        has: formats.has,\n        register: formats.register,\n        unregister: formats.unregister,\n        apply: (name, vars, node) => {\n          applyFormat(editor, name, vars, node);\n        },\n        remove: (name, vars, node, similar) => {\n          removeFormat(editor, name, vars, node, similar);\n        },\n        toggle: (name, vars, node) => {\n          toggleFormat(editor, name, vars, node);\n        },\n        match: (name, vars, node, similar) => matchFormat(editor, name, vars, node, similar),\n        closest: names => closestFormat(editor, names),\n        matchAll: (names, vars) => matchAllFormats(editor, names, vars),\n        matchNode: (node, name, vars, similar) => matchNodeFormat(editor, node, name, vars, similar),\n        canApply: name => canApplyFormat(editor, name),\n        formatChanged: (formats, callback, similar, vars) => formatChanged(editor, formatChangeState, formats, callback, similar, vars),\n        getCssText: curry(getCssText, editor)\n      };\n    };\n\n    const shouldIgnoreCommand = cmd => {\n      switch (cmd.toLowerCase()) {\n      case 'undo':\n      case 'redo':\n      case 'mcefocus':\n        return true;\n      default:\n        return false;\n      }\n    };\n    const registerEvents = (editor, undoManager, locks) => {\n      const isFirstTypedCharacter = Cell(false);\n      const addNonTypingUndoLevel = e => {\n        setTyping(undoManager, false, locks);\n        undoManager.add({}, e);\n      };\n      editor.on('init', () => {\n        undoManager.add();\n      });\n      editor.on('BeforeExecCommand', e => {\n        const cmd = e.command;\n        if (!shouldIgnoreCommand(cmd)) {\n          endTyping(undoManager, locks);\n          undoManager.beforeChange();\n        }\n      });\n      editor.on('ExecCommand', e => {\n        const cmd = e.command;\n        if (!shouldIgnoreCommand(cmd)) {\n          addNonTypingUndoLevel(e);\n        }\n      });\n      editor.on('ObjectResizeStart cut', () => {\n        undoManager.beforeChange();\n      });\n      editor.on('SaveContent ObjectResized blur', addNonTypingUndoLevel);\n      editor.on('dragend', addNonTypingUndoLevel);\n      editor.on('keyup', e => {\n        const keyCode = e.keyCode;\n        if (e.isDefaultPrevented()) {\n          return;\n        }\n        if (keyCode >= 33 && keyCode <= 36 || keyCode >= 37 && keyCode <= 40 || keyCode === 45 || e.ctrlKey) {\n          addNonTypingUndoLevel();\n          editor.nodeChanged();\n        }\n        if (keyCode === 46 || keyCode === 8) {\n          editor.nodeChanged();\n        }\n        if (isFirstTypedCharacter.get() && undoManager.typing && isEq$1(createFromEditor(editor), undoManager.data[0]) === false) {\n          if (editor.isDirty() === false) {\n            editor.setDirty(true);\n          }\n          editor.dispatch('TypingUndo');\n          isFirstTypedCharacter.set(false);\n          editor.nodeChanged();\n        }\n      });\n      editor.on('keydown', e => {\n        const keyCode = e.keyCode;\n        if (e.isDefaultPrevented()) {\n          return;\n        }\n        if (keyCode >= 33 && keyCode <= 36 || keyCode >= 37 && keyCode <= 40 || keyCode === 45) {\n          if (undoManager.typing) {\n            addNonTypingUndoLevel(e);\n          }\n          return;\n        }\n        const modKey = e.ctrlKey && !e.altKey || e.metaKey;\n        if ((keyCode < 16 || keyCode > 20) && keyCode !== 224 && keyCode !== 91 && !undoManager.typing && !modKey) {\n          undoManager.beforeChange();\n          setTyping(undoManager, true, locks);\n          undoManager.add({}, e);\n          isFirstTypedCharacter.set(true);\n        }\n      });\n      editor.on('mousedown', e => {\n        if (undoManager.typing) {\n          addNonTypingUndoLevel(e);\n        }\n      });\n      const isInsertReplacementText = event => event.inputType === 'insertReplacementText';\n      const isInsertTextDataNull = event => event.inputType === 'insertText' && event.data === null;\n      const isInsertFromPasteOrDrop = event => event.inputType === 'insertFromPaste' || event.inputType === 'insertFromDrop';\n      editor.on('input', e => {\n        if (e.inputType && (isInsertReplacementText(e) || isInsertTextDataNull(e) || isInsertFromPasteOrDrop(e))) {\n          addNonTypingUndoLevel(e);\n        }\n      });\n      editor.on('AddUndo Undo Redo ClearUndos', e => {\n        if (!e.isDefaultPrevented()) {\n          editor.nodeChanged();\n        }\n      });\n    };\n    const addKeyboardShortcuts = editor => {\n      editor.addShortcut('meta+z', '', 'Undo');\n      editor.addShortcut('meta+y,meta+shift+z', '', 'Redo');\n    };\n\n    const UndoManager = editor => {\n      const beforeBookmark = value$2();\n      const locks = Cell(0);\n      const index = Cell(0);\n      const undoManager = {\n        data: [],\n        typing: false,\n        beforeChange: () => {\n          beforeChange(editor, locks, beforeBookmark);\n        },\n        add: (level, event) => {\n          return addUndoLevel(editor, undoManager, index, locks, beforeBookmark, level, event);\n        },\n        undo: () => {\n          return undo(editor, undoManager, locks, index);\n        },\n        redo: () => {\n          return redo(editor, index, undoManager.data);\n        },\n        clear: () => {\n          clear(editor, undoManager, index);\n        },\n        reset: () => {\n          reset(editor, undoManager);\n        },\n        hasUndo: () => {\n          return hasUndo(editor, undoManager, index);\n        },\n        hasRedo: () => {\n          return hasRedo(editor, undoManager, index);\n        },\n        transact: callback => {\n          return transact(editor, undoManager, locks, callback);\n        },\n        ignore: callback => {\n          ignore(editor, locks, callback);\n        },\n        extra: (callback1, callback2) => {\n          extra(editor, undoManager, index, callback1, callback2);\n        }\n      };\n      if (!isRtc(editor)) {\n        registerEvents(editor, undoManager, locks);\n      }\n      addKeyboardShortcuts(editor);\n      return undoManager;\n    };\n\n    const nonTypingKeycodes = [\n      9,\n      27,\n      VK.HOME,\n      VK.END,\n      19,\n      20,\n      44,\n      144,\n      145,\n      33,\n      34,\n      45,\n      16,\n      17,\n      18,\n      91,\n      92,\n      93,\n      VK.DOWN,\n      VK.UP,\n      VK.LEFT,\n      VK.RIGHT\n    ].concat(Env.browser.isFirefox() ? [224] : []);\n    const placeholderAttr = 'data-mce-placeholder';\n    const isKeyboardEvent = e => e.type === 'keydown' || e.type === 'keyup';\n    const isDeleteEvent = e => {\n      const keyCode = e.keyCode;\n      return keyCode === VK.BACKSPACE || keyCode === VK.DELETE;\n    };\n    const isNonTypingKeyboardEvent = e => {\n      if (isKeyboardEvent(e)) {\n        const keyCode = e.keyCode;\n        return !isDeleteEvent(e) && (VK.metaKeyPressed(e) || e.altKey || keyCode >= 112 && keyCode <= 123 || contains$2(nonTypingKeycodes, keyCode));\n      } else {\n        return false;\n      }\n    };\n    const isTypingKeyboardEvent = e => isKeyboardEvent(e) && !(isDeleteEvent(e) || e.type === 'keyup' && e.keyCode === 229);\n    const isVisuallyEmpty = (dom, rootElm, forcedRootBlock) => {\n      if (isEmpty$2(SugarElement.fromDom(rootElm), false)) {\n        const firstElement = rootElm.firstElementChild;\n        if (!firstElement) {\n          return true;\n        } else if (dom.getStyle(rootElm.firstElementChild, 'padding-left') || dom.getStyle(rootElm.firstElementChild, 'padding-right')) {\n          return false;\n        } else {\n          return forcedRootBlock === firstElement.nodeName.toLowerCase();\n        }\n      } else {\n        return false;\n      }\n    };\n    const setup$q = editor => {\n      const dom = editor.dom;\n      const rootBlock = getForcedRootBlock(editor);\n      const placeholder = getPlaceholder(editor);\n      const updatePlaceholder = (e, initial) => {\n        if (isNonTypingKeyboardEvent(e)) {\n          return;\n        }\n        const body = editor.getBody();\n        const showPlaceholder = isTypingKeyboardEvent(e) ? false : isVisuallyEmpty(dom, body, rootBlock);\n        const isPlaceholderShown = dom.getAttrib(body, placeholderAttr) !== '';\n        if (isPlaceholderShown !== showPlaceholder || initial) {\n          dom.setAttrib(body, placeholderAttr, showPlaceholder ? placeholder : null);\n          dom.setAttrib(body, 'aria-placeholder', showPlaceholder ? placeholder : null);\n          firePlaceholderToggle(editor, showPlaceholder);\n          editor.on(showPlaceholder ? 'keydown' : 'keyup', updatePlaceholder);\n          editor.off(showPlaceholder ? 'keyup' : 'keydown', updatePlaceholder);\n        }\n      };\n      if (placeholder) {\n        editor.on('init', e => {\n          updatePlaceholder(e, true);\n          editor.on('change SetContent ExecCommand', updatePlaceholder);\n          editor.on('paste', e => Delay.setEditorTimeout(editor, () => updatePlaceholder(e)));\n        });\n      }\n    };\n\n    const strongRtl = /[\\u0591-\\u07FF\\uFB1D-\\uFDFF\\uFE70-\\uFEFC]/;\n    const hasStrongRtl = text => strongRtl.test(text);\n\n    const isInlineTarget = (editor, elm) => is$1(SugarElement.fromDom(elm), getInlineBoundarySelector(editor));\n    const isRtl = element => DOMUtils.DOM.getStyle(element, 'direction', true) === 'rtl' || hasStrongRtl(element.textContent);\n    const findInlineParents = (isInlineTarget, rootNode, pos) => filter$6(DOMUtils.DOM.getParents(pos.container(), '*', rootNode), isInlineTarget);\n    const findRootInline = (isInlineTarget, rootNode, pos) => {\n      const parents = findInlineParents(isInlineTarget, rootNode, pos);\n      return Optional.from(parents[parents.length - 1]);\n    };\n    const hasSameParentBlock = (rootNode, node1, node2) => {\n      const block1 = getParentBlock$3(node1, rootNode);\n      const block2 = getParentBlock$3(node2, rootNode);\n      return block1 && block1 === block2;\n    };\n    const isAtZwsp = pos => isBeforeInline(pos) || isAfterInline(pos);\n    const normalizePosition = (forward, pos) => {\n      if (!pos) {\n        return pos;\n      }\n      const container = pos.container(), offset = pos.offset();\n      if (forward) {\n        if (isCaretContainerInline(container)) {\n          if (isText$8(container.nextSibling)) {\n            return CaretPosition(container.nextSibling, 0);\n          } else {\n            return CaretPosition.after(container);\n          }\n        } else {\n          return isBeforeInline(pos) ? CaretPosition(container, offset + 1) : pos;\n        }\n      } else {\n        if (isCaretContainerInline(container)) {\n          if (isText$8(container.previousSibling)) {\n            return CaretPosition(container.previousSibling, container.previousSibling.data.length);\n          } else {\n            return CaretPosition.before(container);\n          }\n        } else {\n          return isAfterInline(pos) ? CaretPosition(container, offset - 1) : pos;\n        }\n      }\n    };\n    const normalizeForwards = curry(normalizePosition, true);\n    const normalizeBackwards = curry(normalizePosition, false);\n\n    const execCommandIgnoreInputEvents = (editor, command) => {\n      const inputBlocker = e => e.stopImmediatePropagation();\n      editor.on('beforeinput input', inputBlocker, true);\n      editor.getDoc().execCommand(command);\n      editor.off('beforeinput input', inputBlocker);\n    };\n    const execDeleteCommand = editor => execCommandIgnoreInputEvents(editor, 'Delete');\n    const execForwardDeleteCommand = editor => execCommandIgnoreInputEvents(editor, 'ForwardDelete');\n    const isBeforeRoot = rootNode => elm => eq(rootNode, SugarElement.fromDom(elm.dom.parentNode));\n    const isTextBlockOrListItem = element => isTextBlock$2(element) || isListItem(element);\n    const getParentBlock$2 = (rootNode, elm) => {\n      if (contains(rootNode, elm)) {\n        return closest$4(elm, isTextBlockOrListItem, isBeforeRoot(rootNode));\n      } else {\n        return Optional.none();\n      }\n    };\n    const placeCaretInEmptyBody = editor => {\n      const body = editor.getBody();\n      const node = body.firstChild && editor.dom.isBlock(body.firstChild) ? body.firstChild : body;\n      editor.selection.setCursorLocation(node, 0);\n    };\n    const paddEmptyBody = editor => {\n      if (editor.dom.isEmpty(editor.getBody())) {\n        editor.setContent('');\n        placeCaretInEmptyBody(editor);\n      }\n    };\n    const willDeleteLastPositionInElement = (forward, fromPos, elm) => lift2(firstPositionIn(elm), lastPositionIn(elm), (firstPos, lastPos) => {\n      const normalizedFirstPos = normalizePosition(true, firstPos);\n      const normalizedLastPos = normalizePosition(false, lastPos);\n      const normalizedFromPos = normalizePosition(false, fromPos);\n      if (forward) {\n        return nextPosition(elm, normalizedFromPos).exists(nextPos => nextPos.isEqual(normalizedLastPos) && fromPos.isEqual(normalizedFirstPos));\n      } else {\n        return prevPosition(elm, normalizedFromPos).exists(prevPos => prevPos.isEqual(normalizedFirstPos) && fromPos.isEqual(normalizedLastPos));\n      }\n    }).getOr(true);\n\n    const blockPosition = (block, position) => ({\n      block,\n      position\n    });\n    const blockBoundary = (from, to) => ({\n      from,\n      to\n    });\n    const getBlockPosition = (rootNode, pos) => {\n      const rootElm = SugarElement.fromDom(rootNode);\n      const containerElm = SugarElement.fromDom(pos.container());\n      return getParentBlock$2(rootElm, containerElm).map(block => blockPosition(block, pos));\n    };\n    const isDifferentBlocks = blockBoundary => eq(blockBoundary.from.block, blockBoundary.to.block) === false;\n    const hasSameParent = blockBoundary => parent(blockBoundary.from.block).bind(parent1 => parent(blockBoundary.to.block).filter(parent2 => eq(parent1, parent2))).isSome();\n    const isEditable$2 = blockBoundary => isContentEditableFalse$a(blockBoundary.from.block.dom) === false && isContentEditableFalse$a(blockBoundary.to.block.dom) === false;\n    const skipLastBr = (rootNode, forward, blockPosition) => {\n      if (isBr$5(blockPosition.position.getNode()) && isEmpty$2(blockPosition.block) === false) {\n        return positionIn(false, blockPosition.block.dom).bind(lastPositionInBlock => {\n          if (lastPositionInBlock.isEqual(blockPosition.position)) {\n            return fromPosition(forward, rootNode, lastPositionInBlock).bind(to => getBlockPosition(rootNode, to));\n          } else {\n            return Optional.some(blockPosition);\n          }\n        }).getOr(blockPosition);\n      } else {\n        return blockPosition;\n      }\n    };\n    const readFromRange = (rootNode, forward, rng) => {\n      const fromBlockPos = getBlockPosition(rootNode, CaretPosition.fromRangeStart(rng));\n      const toBlockPos = fromBlockPos.bind(blockPos => fromPosition(forward, rootNode, blockPos.position).bind(to => getBlockPosition(rootNode, to).map(blockPos => skipLastBr(rootNode, forward, blockPos))));\n      return lift2(fromBlockPos, toBlockPos, blockBoundary).filter(blockBoundary => isDifferentBlocks(blockBoundary) && hasSameParent(blockBoundary) && isEditable$2(blockBoundary));\n    };\n    const read$1 = (rootNode, forward, rng) => rng.collapsed ? readFromRange(rootNode, forward, rng) : Optional.none();\n\n    const getChildrenUntilBlockBoundary = block => {\n      const children$1 = children(block);\n      return findIndex$2(children$1, isBlock$2).fold(constant(children$1), index => children$1.slice(0, index));\n    };\n    const extractChildren = block => {\n      const children = getChildrenUntilBlockBoundary(block);\n      each$g(children, remove$5);\n      return children;\n    };\n    const removeEmptyRoot = (rootNode, block) => {\n      const parents = parentsAndSelf(block, rootNode);\n      return find$2(parents.reverse(), element => isEmpty$2(element)).each(remove$5);\n    };\n    const isEmptyBefore = el => filter$6(prevSiblings(el), el => !isEmpty$2(el)).length === 0;\n    const nestedBlockMerge = (rootNode, fromBlock, toBlock, insertionPoint) => {\n      if (isEmpty$2(toBlock)) {\n        fillWithPaddingBr(toBlock);\n        return firstPositionIn(toBlock.dom);\n      }\n      if (isEmptyBefore(insertionPoint) && isEmpty$2(fromBlock)) {\n        before$3(insertionPoint, SugarElement.fromTag('br'));\n      }\n      const position = prevPosition(toBlock.dom, CaretPosition.before(insertionPoint.dom));\n      each$g(extractChildren(fromBlock), child => {\n        before$3(insertionPoint, child);\n      });\n      removeEmptyRoot(rootNode, fromBlock);\n      return position;\n    };\n    const sidelongBlockMerge = (rootNode, fromBlock, toBlock) => {\n      if (isEmpty$2(toBlock)) {\n        remove$5(toBlock);\n        if (isEmpty$2(fromBlock)) {\n          fillWithPaddingBr(fromBlock);\n        }\n        return firstPositionIn(fromBlock.dom);\n      }\n      const position = lastPositionIn(toBlock.dom);\n      each$g(extractChildren(fromBlock), child => {\n        append$1(toBlock, child);\n      });\n      removeEmptyRoot(rootNode, fromBlock);\n      return position;\n    };\n    const findInsertionPoint = (toBlock, block) => {\n      const parentsAndSelf$1 = parentsAndSelf(block, toBlock);\n      return Optional.from(parentsAndSelf$1[parentsAndSelf$1.length - 1]);\n    };\n    const getInsertionPoint = (fromBlock, toBlock) => contains(toBlock, fromBlock) ? findInsertionPoint(toBlock, fromBlock) : Optional.none();\n    const trimBr = (first, block) => {\n      positionIn(first, block.dom).map(position => position.getNode()).map(SugarElement.fromDom).filter(isBr$4).each(remove$5);\n    };\n    const mergeBlockInto = (rootNode, fromBlock, toBlock) => {\n      trimBr(true, fromBlock);\n      trimBr(false, toBlock);\n      return getInsertionPoint(fromBlock, toBlock).fold(curry(sidelongBlockMerge, rootNode, fromBlock, toBlock), curry(nestedBlockMerge, rootNode, fromBlock, toBlock));\n    };\n    const mergeBlocks = (rootNode, forward, block1, block2) => forward ? mergeBlockInto(rootNode, block2, block1) : mergeBlockInto(rootNode, block1, block2);\n\n    const backspaceDelete$8 = (editor, forward) => {\n      const rootNode = SugarElement.fromDom(editor.getBody());\n      const position = read$1(rootNode.dom, forward, editor.selection.getRng()).map(blockBoundary => () => {\n        mergeBlocks(rootNode, forward, blockBoundary.from.block, blockBoundary.to.block).each(pos => {\n          editor.selection.setRng(pos.toRange());\n        });\n      });\n      return position;\n    };\n\n    const deleteRangeMergeBlocks = (rootNode, selection) => {\n      const rng = selection.getRng();\n      return lift2(getParentBlock$2(rootNode, SugarElement.fromDom(rng.startContainer)), getParentBlock$2(rootNode, SugarElement.fromDom(rng.endContainer)), (block1, block2) => {\n        if (eq(block1, block2) === false) {\n          return Optional.some(() => {\n            rng.deleteContents();\n            mergeBlocks(rootNode, true, block1, block2).each(pos => {\n              selection.setRng(pos.toRange());\n            });\n          });\n        } else {\n          return Optional.none();\n        }\n      }).getOr(Optional.none());\n    };\n    const isRawNodeInTable = (root, rawNode) => {\n      const node = SugarElement.fromDom(rawNode);\n      const isRoot = curry(eq, root);\n      return ancestor$3(node, isTableCell$4, isRoot).isSome();\n    };\n    const isSelectionInTable = (root, rng) => isRawNodeInTable(root, rng.startContainer) || isRawNodeInTable(root, rng.endContainer);\n    const isEverythingSelected = (root, rng) => {\n      const noPrevious = prevPosition(root.dom, CaretPosition.fromRangeStart(rng)).isNone();\n      const noNext = nextPosition(root.dom, CaretPosition.fromRangeEnd(rng)).isNone();\n      return !isSelectionInTable(root, rng) && noPrevious && noNext;\n    };\n    const emptyEditor = editor => {\n      return Optional.some(() => {\n        editor.setContent('');\n        editor.selection.setCursorLocation();\n      });\n    };\n    const deleteRange$1 = editor => {\n      const rootNode = SugarElement.fromDom(editor.getBody());\n      const rng = editor.selection.getRng();\n      return isEverythingSelected(rootNode, rng) ? emptyEditor(editor) : deleteRangeMergeBlocks(rootNode, editor.selection);\n    };\n    const backspaceDelete$7 = (editor, _forward) => editor.selection.isCollapsed() ? Optional.none() : deleteRange$1(editor);\n\n    const isContentEditableTrue$1 = isContentEditableTrue$4;\n    const isContentEditableFalse$4 = isContentEditableFalse$a;\n    const showCaret = (direction, editor, node, before, scrollIntoView) => Optional.from(editor._selectionOverrides.showCaret(direction, node, before, scrollIntoView));\n    const getNodeRange = node => {\n      const rng = node.ownerDocument.createRange();\n      rng.selectNode(node);\n      return rng;\n    };\n    const selectNode = (editor, node) => {\n      const e = editor.dispatch('BeforeObjectSelected', { target: node });\n      if (e.isDefaultPrevented()) {\n        return Optional.none();\n      }\n      return Optional.some(getNodeRange(node));\n    };\n    const renderCaretAtRange = (editor, range, scrollIntoView) => {\n      const normalizedRange = normalizeRange(1, editor.getBody(), range);\n      const caretPosition = CaretPosition.fromRangeStart(normalizedRange);\n      const caretPositionNode = caretPosition.getNode();\n      if (isInlineFakeCaretTarget(caretPositionNode)) {\n        return showCaret(1, editor, caretPositionNode, !caretPosition.isAtEnd(), false);\n      }\n      const caretPositionBeforeNode = caretPosition.getNode(true);\n      if (isInlineFakeCaretTarget(caretPositionBeforeNode)) {\n        return showCaret(1, editor, caretPositionBeforeNode, false, false);\n      }\n      const ceRoot = editor.dom.getParent(caretPosition.getNode(), node => isContentEditableFalse$4(node) || isContentEditableTrue$1(node));\n      if (isInlineFakeCaretTarget(ceRoot)) {\n        return showCaret(1, editor, ceRoot, false, scrollIntoView);\n      }\n      return Optional.none();\n    };\n    const renderRangeCaret = (editor, range, scrollIntoView) => range.collapsed ? renderCaretAtRange(editor, range, scrollIntoView).getOr(range) : range;\n\n    const isBeforeBoundary = pos => isBeforeContentEditableFalse(pos) || isBeforeMedia(pos);\n    const isAfterBoundary = pos => isAfterContentEditableFalse(pos) || isAfterMedia(pos);\n    const trimEmptyTextNode = (dom, node) => {\n      if (isText$8(node) && node.data.length === 0) {\n        dom.remove(node);\n      }\n    };\n    const deleteContentAndShowCaret = (editor, range, node, direction, forward, peekCaretPosition) => {\n      showCaret(direction, editor, peekCaretPosition.getNode(!forward), forward, true).each(caretRange => {\n        if (range.collapsed) {\n          const deleteRange = range.cloneRange();\n          if (forward) {\n            deleteRange.setEnd(caretRange.startContainer, caretRange.startOffset);\n          } else {\n            deleteRange.setStart(caretRange.endContainer, caretRange.endOffset);\n          }\n          deleteRange.deleteContents();\n        } else {\n          range.deleteContents();\n        }\n        editor.selection.setRng(caretRange);\n      });\n      trimEmptyTextNode(editor.dom, node);\n    };\n    const deleteBoundaryText = (editor, forward) => {\n      const range = editor.selection.getRng();\n      if (!isText$8(range.commonAncestorContainer)) {\n        return Optional.none();\n      }\n      const direction = forward ? HDirection.Forwards : HDirection.Backwards;\n      const caretWalker = CaretWalker(editor.getBody());\n      const getNextPosFn = curry(getVisualCaretPosition, forward ? caretWalker.next : caretWalker.prev);\n      const isBeforeFn = forward ? isBeforeBoundary : isAfterBoundary;\n      const caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range);\n      const nextCaretPosition = normalizePosition(forward, getNextPosFn(caretPosition));\n      if (!nextCaretPosition || !isMoveInsideSameBlock(caretPosition, nextCaretPosition)) {\n        return Optional.none();\n      } else if (isBeforeFn(nextCaretPosition)) {\n        return Optional.some(() => deleteContentAndShowCaret(editor, range, caretPosition.getNode(), direction, forward, nextCaretPosition));\n      }\n      const peekCaretPosition = getNextPosFn(nextCaretPosition);\n      if (peekCaretPosition && isBeforeFn(peekCaretPosition)) {\n        if (isMoveInsideSameBlock(nextCaretPosition, peekCaretPosition)) {\n          return Optional.some(() => deleteContentAndShowCaret(editor, range, caretPosition.getNode(), direction, forward, peekCaretPosition));\n        }\n      }\n      return Optional.none();\n    };\n    const backspaceDelete$6 = (editor, forward) => deleteBoundaryText(editor, forward);\n\n    const isCompoundElement = node => isTableCell$4(SugarElement.fromDom(node)) || isListItem(SugarElement.fromDom(node));\n    const DeleteAction = Adt.generate([\n      { remove: ['element'] },\n      { moveToElement: ['element'] },\n      { moveToPosition: ['position'] }\n    ]);\n    const isAtContentEditableBlockCaret = (forward, from) => {\n      const elm = from.getNode(forward === false);\n      const caretLocation = forward ? 'after' : 'before';\n      return isElement$6(elm) && elm.getAttribute('data-mce-caret') === caretLocation;\n    };\n    const isDeleteFromCefDifferentBlocks = (root, forward, from, to) => {\n      const inSameBlock = elm => isInline$1(SugarElement.fromDom(elm)) && !isInSameBlock(from, to, root);\n      return getRelativeCefElm(!forward, from).fold(() => getRelativeCefElm(forward, to).fold(never, inSameBlock), inSameBlock);\n    };\n    const deleteEmptyBlockOrMoveToCef = (root, forward, from, to) => {\n      const toCefElm = to.getNode(forward === false);\n      return getParentBlock$2(SugarElement.fromDom(root), SugarElement.fromDom(from.getNode())).map(blockElm => isEmpty$2(blockElm) ? DeleteAction.remove(blockElm.dom) : DeleteAction.moveToElement(toCefElm)).orThunk(() => Optional.some(DeleteAction.moveToElement(toCefElm)));\n    };\n    const findCefPosition = (root, forward, from) => fromPosition(forward, root, from).bind(to => {\n      if (isCompoundElement(to.getNode())) {\n        return Optional.none();\n      } else if (isDeleteFromCefDifferentBlocks(root, forward, from, to)) {\n        return Optional.none();\n      } else if (forward && isContentEditableFalse$a(to.getNode())) {\n        return deleteEmptyBlockOrMoveToCef(root, forward, from, to);\n      } else if (forward === false && isContentEditableFalse$a(to.getNode(true))) {\n        return deleteEmptyBlockOrMoveToCef(root, forward, from, to);\n      } else if (forward && isAfterContentEditableFalse(from)) {\n        return Optional.some(DeleteAction.moveToPosition(to));\n      } else if (forward === false && isBeforeContentEditableFalse(from)) {\n        return Optional.some(DeleteAction.moveToPosition(to));\n      } else {\n        return Optional.none();\n      }\n    });\n    const getContentEditableBlockAction = (forward, elm) => {\n      if (forward && isContentEditableFalse$a(elm.nextSibling)) {\n        return Optional.some(DeleteAction.moveToElement(elm.nextSibling));\n      } else if (forward === false && isContentEditableFalse$a(elm.previousSibling)) {\n        return Optional.some(DeleteAction.moveToElement(elm.previousSibling));\n      } else {\n        return Optional.none();\n      }\n    };\n    const skipMoveToActionFromInlineCefToContent = (root, from, deleteAction) => deleteAction.fold(elm => Optional.some(DeleteAction.remove(elm)), elm => Optional.some(DeleteAction.moveToElement(elm)), to => {\n      if (isInSameBlock(from, to, root)) {\n        return Optional.none();\n      } else {\n        return Optional.some(DeleteAction.moveToPosition(to));\n      }\n    });\n    const getContentEditableAction = (root, forward, from) => {\n      if (isAtContentEditableBlockCaret(forward, from)) {\n        return getContentEditableBlockAction(forward, from.getNode(forward === false)).fold(() => findCefPosition(root, forward, from), Optional.some);\n      } else {\n        return findCefPosition(root, forward, from).bind(deleteAction => skipMoveToActionFromInlineCefToContent(root, from, deleteAction));\n      }\n    };\n    const read = (root, forward, rng) => {\n      const normalizedRange = normalizeRange(forward ? 1 : -1, root, rng);\n      const from = CaretPosition.fromRangeStart(normalizedRange);\n      const rootElement = SugarElement.fromDom(root);\n      if (forward === false && isAfterContentEditableFalse(from)) {\n        return Optional.some(DeleteAction.remove(from.getNode(true)));\n      } else if (forward && isBeforeContentEditableFalse(from)) {\n        return Optional.some(DeleteAction.remove(from.getNode()));\n      } else if (forward === false && isBeforeContentEditableFalse(from) && isAfterBr(rootElement, from)) {\n        return findPreviousBr(rootElement, from).map(br => DeleteAction.remove(br.getNode()));\n      } else if (forward && isAfterContentEditableFalse(from) && isBeforeBr$1(rootElement, from)) {\n        return findNextBr(rootElement, from).map(br => DeleteAction.remove(br.getNode()));\n      } else {\n        return getContentEditableAction(root, forward, from);\n      }\n    };\n\n    const deleteElement$1 = (editor, forward) => element => {\n      editor._selectionOverrides.hideFakeCaret();\n      deleteElement$2(editor, forward, SugarElement.fromDom(element));\n      return true;\n    };\n    const moveToElement = (editor, forward) => element => {\n      const pos = forward ? CaretPosition.before(element) : CaretPosition.after(element);\n      editor.selection.setRng(pos.toRange());\n      return true;\n    };\n    const moveToPosition = editor => pos => {\n      editor.selection.setRng(pos.toRange());\n      return true;\n    };\n    const getAncestorCe = (editor, node) => Optional.from(getContentEditableRoot$1(editor.getBody(), node));\n    const backspaceDeleteCaret = (editor, forward) => {\n      const selectedNode = editor.selection.getNode();\n      return getAncestorCe(editor, selectedNode).filter(isContentEditableFalse$a).fold(() => read(editor.getBody(), forward, editor.selection.getRng()).map(deleteAction => () => deleteAction.fold(deleteElement$1(editor, forward), moveToElement(editor, forward), moveToPosition(editor))), () => Optional.some(noop));\n    };\n    const deleteOffscreenSelection = rootElement => {\n      each$g(descendants(rootElement, '.mce-offscreen-selection'), remove$5);\n    };\n    const backspaceDeleteRange = (editor, forward) => {\n      const selectedNode = editor.selection.getNode();\n      if (isContentEditableFalse$a(selectedNode) && !isTableCell$5(selectedNode)) {\n        const hasCefAncestor = getAncestorCe(editor, selectedNode.parentNode).filter(isContentEditableFalse$a);\n        return hasCefAncestor.fold(() => Optional.some(() => {\n          deleteOffscreenSelection(SugarElement.fromDom(editor.getBody()));\n          deleteElement$2(editor, forward, SugarElement.fromDom(editor.selection.getNode()));\n          paddEmptyBody(editor);\n        }), () => Optional.some(noop));\n      }\n      return Optional.none();\n    };\n    const paddEmptyElement = editor => {\n      const dom = editor.dom, selection = editor.selection;\n      const ceRoot = getContentEditableRoot$1(editor.getBody(), selection.getNode());\n      if (isContentEditableTrue$4(ceRoot) && dom.isBlock(ceRoot) && dom.isEmpty(ceRoot)) {\n        const br = dom.create('br', { 'data-mce-bogus': '1' });\n        dom.setHTML(ceRoot, '');\n        ceRoot.appendChild(br);\n        selection.setRng(CaretPosition.before(br).toRange());\n      }\n      return true;\n    };\n    const backspaceDelete$5 = (editor, forward) => {\n      if (editor.selection.isCollapsed()) {\n        return backspaceDeleteCaret(editor, forward);\n      } else {\n        return backspaceDeleteRange(editor, forward);\n      }\n    };\n\n    const deleteCaret$2 = (editor, forward) => {\n      const fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());\n      return fromPosition(forward, editor.getBody(), fromPos).filter(pos => forward ? isBeforeImageBlock(pos) : isAfterImageBlock(pos)).bind(pos => Optional.from(getChildNodeAtRelativeOffset(forward ? 0 : -1, pos))).map(elm => () => editor.selection.select(elm));\n    };\n    const backspaceDelete$4 = (editor, forward) => editor.selection.isCollapsed() ? deleteCaret$2(editor, forward) : Optional.none();\n\n    const isText$1 = isText$8;\n    const startsWithCaretContainer = node => isText$1(node) && node.data[0] === ZWSP$1;\n    const endsWithCaretContainer = node => isText$1(node) && node.data[node.data.length - 1] === ZWSP$1;\n    const createZwsp = node => node.ownerDocument.createTextNode(ZWSP$1);\n    const insertBefore = node => {\n      if (isText$1(node.previousSibling)) {\n        if (endsWithCaretContainer(node.previousSibling)) {\n          return node.previousSibling;\n        } else {\n          node.previousSibling.appendData(ZWSP$1);\n          return node.previousSibling;\n        }\n      } else if (isText$1(node)) {\n        if (startsWithCaretContainer(node)) {\n          return node;\n        } else {\n          node.insertData(0, ZWSP$1);\n          return node;\n        }\n      } else {\n        const newNode = createZwsp(node);\n        node.parentNode.insertBefore(newNode, node);\n        return newNode;\n      }\n    };\n    const insertAfter = node => {\n      if (isText$1(node.nextSibling)) {\n        if (startsWithCaretContainer(node.nextSibling)) {\n          return node.nextSibling;\n        } else {\n          node.nextSibling.insertData(0, ZWSP$1);\n          return node.nextSibling;\n        }\n      } else if (isText$1(node)) {\n        if (endsWithCaretContainer(node)) {\n          return node;\n        } else {\n          node.appendData(ZWSP$1);\n          return node;\n        }\n      } else {\n        const newNode = createZwsp(node);\n        if (node.nextSibling) {\n          node.parentNode.insertBefore(newNode, node.nextSibling);\n        } else {\n          node.parentNode.appendChild(newNode);\n        }\n        return newNode;\n      }\n    };\n    const insertInline = (before, node) => before ? insertBefore(node) : insertAfter(node);\n    const insertInlineBefore = curry(insertInline, true);\n    const insertInlineAfter = curry(insertInline, false);\n\n    const insertInlinePos = (pos, before) => {\n      if (isText$8(pos.container())) {\n        return insertInline(before, pos.container());\n      } else {\n        return insertInline(before, pos.getNode());\n      }\n    };\n    const isPosCaretContainer = (pos, caret) => {\n      const caretNode = caret.get();\n      return caretNode && pos.container() === caretNode && isCaretContainerInline(caretNode);\n    };\n    const renderCaret = (caret, location) => location.fold(element => {\n      remove$4(caret.get());\n      const text = insertInlineBefore(element);\n      caret.set(text);\n      return Optional.some(CaretPosition(text, text.length - 1));\n    }, element => firstPositionIn(element).map(pos => {\n      if (!isPosCaretContainer(pos, caret)) {\n        remove$4(caret.get());\n        const text = insertInlinePos(pos, true);\n        caret.set(text);\n        return CaretPosition(text, 1);\n      } else {\n        return CaretPosition(caret.get(), 1);\n      }\n    }), element => lastPositionIn(element).map(pos => {\n      if (!isPosCaretContainer(pos, caret)) {\n        remove$4(caret.get());\n        const text = insertInlinePos(pos, false);\n        caret.set(text);\n        return CaretPosition(text, text.length - 1);\n      } else {\n        return CaretPosition(caret.get(), caret.get().length - 1);\n      }\n    }), element => {\n      remove$4(caret.get());\n      const text = insertInlineAfter(element);\n      caret.set(text);\n      return Optional.some(CaretPosition(text, 1));\n    });\n\n    const evaluateUntil = (fns, args) => {\n      for (let i = 0; i < fns.length; i++) {\n        const result = fns[i].apply(null, args);\n        if (result.isSome()) {\n          return result;\n        }\n      }\n      return Optional.none();\n    };\n\n    const Location = Adt.generate([\n      { before: ['element'] },\n      { start: ['element'] },\n      { end: ['element'] },\n      { after: ['element'] }\n    ]);\n    const rescope$1 = (rootNode, node) => {\n      const parentBlock = getParentBlock$3(node, rootNode);\n      return parentBlock ? parentBlock : rootNode;\n    };\n    const before = (isInlineTarget, rootNode, pos) => {\n      const nPos = normalizeForwards(pos);\n      const scope = rescope$1(rootNode, nPos.container());\n      return findRootInline(isInlineTarget, scope, nPos).fold(() => nextPosition(scope, nPos).bind(curry(findRootInline, isInlineTarget, scope)).map(inline => Location.before(inline)), Optional.none);\n    };\n    const isNotInsideFormatCaretContainer = (rootNode, elm) => getParentCaretContainer(rootNode, elm) === null;\n    const findInsideRootInline = (isInlineTarget, rootNode, pos) => findRootInline(isInlineTarget, rootNode, pos).filter(curry(isNotInsideFormatCaretContainer, rootNode));\n    const start$1 = (isInlineTarget, rootNode, pos) => {\n      const nPos = normalizeBackwards(pos);\n      return findInsideRootInline(isInlineTarget, rootNode, nPos).bind(inline => {\n        const prevPos = prevPosition(inline, nPos);\n        return prevPos.isNone() ? Optional.some(Location.start(inline)) : Optional.none();\n      });\n    };\n    const end = (isInlineTarget, rootNode, pos) => {\n      const nPos = normalizeForwards(pos);\n      return findInsideRootInline(isInlineTarget, rootNode, nPos).bind(inline => {\n        const nextPos = nextPosition(inline, nPos);\n        return nextPos.isNone() ? Optional.some(Location.end(inline)) : Optional.none();\n      });\n    };\n    const after = (isInlineTarget, rootNode, pos) => {\n      const nPos = normalizeBackwards(pos);\n      const scope = rescope$1(rootNode, nPos.container());\n      return findRootInline(isInlineTarget, scope, nPos).fold(() => prevPosition(scope, nPos).bind(curry(findRootInline, isInlineTarget, scope)).map(inline => Location.after(inline)), Optional.none);\n    };\n    const isValidLocation = location => isRtl(getElement(location)) === false;\n    const readLocation = (isInlineTarget, rootNode, pos) => {\n      const location = evaluateUntil([\n        before,\n        start$1,\n        end,\n        after\n      ], [\n        isInlineTarget,\n        rootNode,\n        pos\n      ]);\n      return location.filter(isValidLocation);\n    };\n    const getElement = location => location.fold(identity, identity, identity, identity);\n    const getName = location => location.fold(constant('before'), constant('start'), constant('end'), constant('after'));\n    const outside = location => location.fold(Location.before, Location.before, Location.after, Location.after);\n    const inside = location => location.fold(Location.start, Location.start, Location.end, Location.end);\n    const isEq = (location1, location2) => getName(location1) === getName(location2) && getElement(location1) === getElement(location2);\n    const betweenInlines = (forward, isInlineTarget, rootNode, from, to, location) => lift2(findRootInline(isInlineTarget, rootNode, from), findRootInline(isInlineTarget, rootNode, to), (fromInline, toInline) => {\n      if (fromInline !== toInline && hasSameParentBlock(rootNode, fromInline, toInline)) {\n        return Location.after(forward ? fromInline : toInline);\n      } else {\n        return location;\n      }\n    }).getOr(location);\n    const skipNoMovement = (fromLocation, toLocation) => fromLocation.fold(always, fromLocation => !isEq(fromLocation, toLocation));\n    const findLocationTraverse = (forward, isInlineTarget, rootNode, fromLocation, pos) => {\n      const from = normalizePosition(forward, pos);\n      const to = fromPosition(forward, rootNode, from).map(curry(normalizePosition, forward));\n      const location = to.fold(() => fromLocation.map(outside), to => readLocation(isInlineTarget, rootNode, to).map(curry(betweenInlines, forward, isInlineTarget, rootNode, from, to)).filter(curry(skipNoMovement, fromLocation)));\n      return location.filter(isValidLocation);\n    };\n    const findLocationSimple = (forward, location) => {\n      if (forward) {\n        return location.fold(compose(Optional.some, Location.start), Optional.none, compose(Optional.some, Location.after), Optional.none);\n      } else {\n        return location.fold(Optional.none, compose(Optional.some, Location.before), Optional.none, compose(Optional.some, Location.end));\n      }\n    };\n    const findLocation$1 = (forward, isInlineTarget, rootNode, pos) => {\n      const from = normalizePosition(forward, pos);\n      const fromLocation = readLocation(isInlineTarget, rootNode, from);\n      return readLocation(isInlineTarget, rootNode, from).bind(curry(findLocationSimple, forward)).orThunk(() => findLocationTraverse(forward, isInlineTarget, rootNode, fromLocation, pos));\n    };\n\n    const hasSelectionModifyApi = editor => {\n      return isFunction(editor.selection.getSel().modify);\n    };\n    const moveRel = (forward, selection, pos) => {\n      const delta = forward ? 1 : -1;\n      selection.setRng(CaretPosition(pos.container(), pos.offset() + delta).toRange());\n      selection.getSel().modify('move', forward ? 'forward' : 'backward', 'word');\n      return true;\n    };\n    const moveByWord = (forward, editor) => {\n      const rng = editor.selection.getRng();\n      const pos = forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);\n      if (!hasSelectionModifyApi(editor)) {\n        return false;\n      } else if (forward && isBeforeInline(pos)) {\n        return moveRel(true, editor.selection, pos);\n      } else if (!forward && isAfterInline(pos)) {\n        return moveRel(false, editor.selection, pos);\n      } else {\n        return false;\n      }\n    };\n\n    var BreakType;\n    (function (BreakType) {\n      BreakType[BreakType['Br'] = 0] = 'Br';\n      BreakType[BreakType['Block'] = 1] = 'Block';\n      BreakType[BreakType['Wrap'] = 2] = 'Wrap';\n      BreakType[BreakType['Eol'] = 3] = 'Eol';\n    }(BreakType || (BreakType = {})));\n    const flip = (direction, positions) => direction === HDirection.Backwards ? reverse(positions) : positions;\n    const walk$1 = (direction, caretWalker, pos) => direction === HDirection.Forwards ? caretWalker.next(pos) : caretWalker.prev(pos);\n    const getBreakType = (scope, direction, currentPos, nextPos) => {\n      if (isBr$5(nextPos.getNode(direction === HDirection.Forwards))) {\n        return BreakType.Br;\n      } else if (isInSameBlock(currentPos, nextPos) === false) {\n        return BreakType.Block;\n      } else {\n        return BreakType.Wrap;\n      }\n    };\n    const getPositionsUntil = (predicate, direction, scope, start) => {\n      const caretWalker = CaretWalker(scope);\n      let currentPos = start;\n      const positions = [];\n      while (currentPos) {\n        const nextPos = walk$1(direction, caretWalker, currentPos);\n        if (!nextPos) {\n          break;\n        }\n        if (isBr$5(nextPos.getNode(false))) {\n          if (direction === HDirection.Forwards) {\n            return {\n              positions: flip(direction, positions).concat([nextPos]),\n              breakType: BreakType.Br,\n              breakAt: Optional.some(nextPos)\n            };\n          } else {\n            return {\n              positions: flip(direction, positions),\n              breakType: BreakType.Br,\n              breakAt: Optional.some(nextPos)\n            };\n          }\n        }\n        if (!nextPos.isVisible()) {\n          currentPos = nextPos;\n          continue;\n        }\n        if (predicate(currentPos, nextPos)) {\n          const breakType = getBreakType(scope, direction, currentPos, nextPos);\n          return {\n            positions: flip(direction, positions),\n            breakType,\n            breakAt: Optional.some(nextPos)\n          };\n        }\n        positions.push(nextPos);\n        currentPos = nextPos;\n      }\n      return {\n        positions: flip(direction, positions),\n        breakType: BreakType.Eol,\n        breakAt: Optional.none()\n      };\n    };\n    const getAdjacentLinePositions = (direction, getPositionsUntilBreak, scope, start) => getPositionsUntilBreak(scope, start).breakAt.map(pos => {\n      const positions = getPositionsUntilBreak(scope, pos).positions;\n      return direction === HDirection.Backwards ? positions.concat(pos) : [pos].concat(positions);\n    }).getOr([]);\n    const findClosestHorizontalPositionFromPoint = (positions, x) => foldl(positions, (acc, newPos) => acc.fold(() => Optional.some(newPos), lastPos => lift2(head(lastPos.getClientRects()), head(newPos.getClientRects()), (lastRect, newRect) => {\n      const lastDist = Math.abs(x - lastRect.left);\n      const newDist = Math.abs(x - newRect.left);\n      return newDist <= lastDist ? newPos : lastPos;\n    }).or(acc)), Optional.none());\n    const findClosestHorizontalPosition = (positions, pos) => head(pos.getClientRects()).bind(targetRect => findClosestHorizontalPositionFromPoint(positions, targetRect.left));\n    const getPositionsUntilPreviousLine = curry(getPositionsUntil, CaretPosition.isAbove, -1);\n    const getPositionsUntilNextLine = curry(getPositionsUntil, CaretPosition.isBelow, 1);\n    const getPositionsAbove = curry(getAdjacentLinePositions, -1, getPositionsUntilPreviousLine);\n    const getPositionsBelow = curry(getAdjacentLinePositions, 1, getPositionsUntilNextLine);\n    const isAtFirstLine = (scope, pos) => getPositionsUntilPreviousLine(scope, pos).breakAt.isNone();\n    const isAtLastLine = (scope, pos) => getPositionsUntilNextLine(scope, pos).breakAt.isNone();\n    const getFirstLinePositions = scope => firstPositionIn(scope).map(pos => [pos].concat(getPositionsUntilNextLine(scope, pos).positions)).getOr([]);\n    const getLastLinePositions = scope => lastPositionIn(scope).map(pos => getPositionsUntilPreviousLine(scope, pos).positions.concat(pos)).getOr([]);\n\n    const isContentEditableFalse$3 = isContentEditableFalse$a;\n    const distanceToRectLeft$1 = (clientRect, clientX) => Math.abs(clientRect.left - clientX);\n    const distanceToRectRight$1 = (clientRect, clientX) => Math.abs(clientRect.right - clientX);\n    const isNodeClientRect = rect => hasNonNullableKey(rect, 'node');\n    const findClosestClientRect = (clientRects, clientX) => reduce(clientRects, (oldClientRect, clientRect) => {\n      const oldDistance = Math.min(distanceToRectLeft$1(oldClientRect, clientX), distanceToRectRight$1(oldClientRect, clientX));\n      const newDistance = Math.min(distanceToRectLeft$1(clientRect, clientX), distanceToRectRight$1(clientRect, clientX));\n      if (newDistance === oldDistance && isNodeClientRect(clientRect) && isContentEditableFalse$3(clientRect.node)) {\n        return clientRect;\n      }\n      if (newDistance < oldDistance) {\n        return clientRect;\n      }\n      return oldClientRect;\n    });\n\n    const getNodeClientRects = node => {\n      const toArrayWithNode = clientRects => {\n        return map$3(clientRects, rect => {\n          const clientRect = clone$1(rect);\n          clientRect.node = node;\n          return clientRect;\n        });\n      };\n      if (isElement$6(node)) {\n        return toArrayWithNode(node.getClientRects());\n      } else if (isText$8(node)) {\n        const rng = node.ownerDocument.createRange();\n        rng.setStart(node, 0);\n        rng.setEnd(node, node.data.length);\n        return toArrayWithNode(rng.getClientRects());\n      } else {\n        return [];\n      }\n    };\n    const getClientRects = nodes => bind$3(nodes, getNodeClientRects);\n\n    var VDirection;\n    (function (VDirection) {\n      VDirection[VDirection['Up'] = -1] = 'Up';\n      VDirection[VDirection['Down'] = 1] = 'Down';\n    }(VDirection || (VDirection = {})));\n    const findUntil = (direction, root, predicateFn, node) => {\n      while (node = findNode(node, direction, isEditableCaretCandidate$1, root)) {\n        if (predicateFn(node)) {\n          return;\n        }\n      }\n    };\n    const walkUntil = (direction, isAboveFn, isBeflowFn, root, predicateFn, caretPosition) => {\n      let line = 0;\n      const result = [];\n      const add = node => {\n        let clientRects = getClientRects([node]);\n        if (direction === -1) {\n          clientRects = clientRects.reverse();\n        }\n        for (let i = 0; i < clientRects.length; i++) {\n          const clientRect = clientRects[i];\n          if (isBeflowFn(clientRect, targetClientRect)) {\n            continue;\n          }\n          if (result.length > 0 && isAboveFn(clientRect, last$2(result))) {\n            line++;\n          }\n          clientRect.line = line;\n          if (predicateFn(clientRect)) {\n            return true;\n          }\n          result.push(clientRect);\n        }\n      };\n      const targetClientRect = last$2(caretPosition.getClientRects());\n      if (!targetClientRect) {\n        return result;\n      }\n      const node = caretPosition.getNode();\n      add(node);\n      findUntil(direction, root, add, node);\n      return result;\n    };\n    const aboveLineNumber = (lineNumber, clientRect) => clientRect.line > lineNumber;\n    const isLineNumber = (lineNumber, clientRect) => clientRect.line === lineNumber;\n    const upUntil = curry(walkUntil, VDirection.Up, isAbove$1, isBelow$1);\n    const downUntil = curry(walkUntil, VDirection.Down, isBelow$1, isAbove$1);\n    const positionsUntil = (direction, root, predicateFn, node) => {\n      const caretWalker = CaretWalker(root);\n      let walkFn;\n      let isBelowFn;\n      let isAboveFn;\n      let caretPosition;\n      const result = [];\n      let line = 0;\n      const getClientRect = caretPosition => {\n        if (direction === 1) {\n          return last$2(caretPosition.getClientRects());\n        }\n        return last$2(caretPosition.getClientRects());\n      };\n      if (direction === 1) {\n        walkFn = caretWalker.next;\n        isBelowFn = isBelow$1;\n        isAboveFn = isAbove$1;\n        caretPosition = CaretPosition.after(node);\n      } else {\n        walkFn = caretWalker.prev;\n        isBelowFn = isAbove$1;\n        isAboveFn = isBelow$1;\n        caretPosition = CaretPosition.before(node);\n      }\n      const targetClientRect = getClientRect(caretPosition);\n      do {\n        if (!caretPosition.isVisible()) {\n          continue;\n        }\n        const rect = getClientRect(caretPosition);\n        if (isAboveFn(rect, targetClientRect)) {\n          continue;\n        }\n        if (result.length > 0 && isBelowFn(rect, last$2(result))) {\n          line++;\n        }\n        const clientRect = clone$1(rect);\n        clientRect.position = caretPosition;\n        clientRect.line = line;\n        if (predicateFn(clientRect)) {\n          return result;\n        }\n        result.push(clientRect);\n      } while (caretPosition = walkFn(caretPosition));\n      return result;\n    };\n    const isAboveLine = lineNumber => clientRect => aboveLineNumber(lineNumber, clientRect);\n    const isLine = lineNumber => clientRect => isLineNumber(lineNumber, clientRect);\n\n    const moveToRange = (editor, rng) => {\n      editor.selection.setRng(rng);\n      scrollRangeIntoView(editor, editor.selection.getRng());\n    };\n    const renderRangeCaretOpt = (editor, range, scrollIntoView) => Optional.some(renderRangeCaret(editor, range, scrollIntoView));\n    const moveHorizontally = (editor, direction, range, isBefore, isAfter, isElement) => {\n      const forwards = direction === HDirection.Forwards;\n      const caretWalker = CaretWalker(editor.getBody());\n      const getNextPosFn = curry(getVisualCaretPosition, forwards ? caretWalker.next : caretWalker.prev);\n      const isBeforeFn = forwards ? isBefore : isAfter;\n      if (!range.collapsed) {\n        const node = getSelectedNode(range);\n        if (isElement(node)) {\n          return showCaret(direction, editor, node, direction === HDirection.Backwards, false);\n        }\n      }\n      const caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range);\n      if (isBeforeFn(caretPosition)) {\n        return selectNode(editor, caretPosition.getNode(!forwards));\n      }\n      const nextCaretPosition = normalizePosition(forwards, getNextPosFn(caretPosition));\n      const rangeIsInContainerBlock = isRangeInCaretContainerBlock(range);\n      if (!nextCaretPosition) {\n        return rangeIsInContainerBlock ? Optional.some(range) : Optional.none();\n      }\n      if (isBeforeFn(nextCaretPosition)) {\n        return showCaret(direction, editor, nextCaretPosition.getNode(!forwards), forwards, false);\n      }\n      const peekCaretPosition = getNextPosFn(nextCaretPosition);\n      if (peekCaretPosition && isBeforeFn(peekCaretPosition)) {\n        if (isMoveInsideSameBlock(nextCaretPosition, peekCaretPosition)) {\n          return showCaret(direction, editor, peekCaretPosition.getNode(!forwards), forwards, false);\n        }\n      }\n      if (rangeIsInContainerBlock) {\n        return renderRangeCaretOpt(editor, nextCaretPosition.toRange(), false);\n      }\n      return Optional.none();\n    };\n    const moveVertically = (editor, direction, range, isBefore, isAfter, isElement) => {\n      const caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range);\n      const caretClientRect = last$2(caretPosition.getClientRects());\n      const forwards = direction === VDirection.Down;\n      if (!caretClientRect) {\n        return Optional.none();\n      }\n      const walkerFn = forwards ? downUntil : upUntil;\n      const linePositions = walkerFn(editor.getBody(), isAboveLine(1), caretPosition);\n      const nextLinePositions = filter$6(linePositions, isLine(1));\n      const clientX = caretClientRect.left;\n      const nextLineRect = findClosestClientRect(nextLinePositions, clientX);\n      if (nextLineRect && isElement(nextLineRect.node)) {\n        const dist1 = Math.abs(clientX - nextLineRect.left);\n        const dist2 = Math.abs(clientX - nextLineRect.right);\n        return showCaret(direction, editor, nextLineRect.node, dist1 < dist2, false);\n      }\n      let currentNode;\n      if (isBefore(caretPosition)) {\n        currentNode = caretPosition.getNode();\n      } else if (isAfter(caretPosition)) {\n        currentNode = caretPosition.getNode(true);\n      } else {\n        currentNode = getSelectedNode(range);\n      }\n      if (currentNode) {\n        const caretPositions = positionsUntil(direction, editor.getBody(), isAboveLine(1), currentNode);\n        let closestNextLineRect = findClosestClientRect(filter$6(caretPositions, isLine(1)), clientX);\n        if (closestNextLineRect) {\n          return renderRangeCaretOpt(editor, closestNextLineRect.position.toRange(), false);\n        }\n        closestNextLineRect = last$2(filter$6(caretPositions, isLine(0)));\n        if (closestNextLineRect) {\n          return renderRangeCaretOpt(editor, closestNextLineRect.position.toRange(), false);\n        }\n      }\n      if (nextLinePositions.length === 0) {\n        return getLineEndPoint(editor, forwards).filter(forwards ? isAfter : isBefore).map(pos => renderRangeCaret(editor, pos.toRange(), false));\n      }\n      return Optional.none();\n    };\n    const getLineEndPoint = (editor, forward) => {\n      const rng = editor.selection.getRng();\n      const from = forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);\n      const host = getEditingHost(from.container(), editor.getBody());\n      if (forward) {\n        const lineInfo = getPositionsUntilNextLine(host, from);\n        return last$3(lineInfo.positions);\n      } else {\n        const lineInfo = getPositionsUntilPreviousLine(host, from);\n        return head(lineInfo.positions);\n      }\n    };\n    const moveToLineEndPoint$3 = (editor, forward, isElementPosition) => getLineEndPoint(editor, forward).filter(isElementPosition).exists(pos => {\n      editor.selection.setRng(pos.toRange());\n      return true;\n    });\n\n    const setCaretPosition = (editor, pos) => {\n      const rng = editor.dom.createRng();\n      rng.setStart(pos.container(), pos.offset());\n      rng.setEnd(pos.container(), pos.offset());\n      editor.selection.setRng(rng);\n    };\n    const setSelected = (state, elm) => {\n      if (state) {\n        elm.setAttribute('data-mce-selected', 'inline-boundary');\n      } else {\n        elm.removeAttribute('data-mce-selected');\n      }\n    };\n    const renderCaretLocation = (editor, caret, location) => renderCaret(caret, location).map(pos => {\n      setCaretPosition(editor, pos);\n      return location;\n    });\n    const findLocation = (editor, caret, forward) => {\n      const rootNode = editor.getBody();\n      const from = CaretPosition.fromRangeStart(editor.selection.getRng());\n      const isInlineTarget$1 = curry(isInlineTarget, editor);\n      const location = findLocation$1(forward, isInlineTarget$1, rootNode, from);\n      return location.bind(location => renderCaretLocation(editor, caret, location));\n    };\n    const toggleInlines = (isInlineTarget, dom, elms) => {\n      const inlineBoundaries = map$3(descendants(SugarElement.fromDom(dom.getRoot()), '*[data-mce-selected=\"inline-boundary\"]'), e => e.dom);\n      const selectedInlines = filter$6(inlineBoundaries, isInlineTarget);\n      const targetInlines = filter$6(elms, isInlineTarget);\n      each$g(difference(selectedInlines, targetInlines), curry(setSelected, false));\n      each$g(difference(targetInlines, selectedInlines), curry(setSelected, true));\n    };\n    const safeRemoveCaretContainer = (editor, caret) => {\n      if (editor.selection.isCollapsed() && editor.composing !== true && caret.get()) {\n        const pos = CaretPosition.fromRangeStart(editor.selection.getRng());\n        if (CaretPosition.isTextPosition(pos) && isAtZwsp(pos) === false) {\n          setCaretPosition(editor, removeAndReposition(caret.get(), pos));\n          caret.set(null);\n        }\n      }\n    };\n    const renderInsideInlineCaret = (isInlineTarget, editor, caret, elms) => {\n      if (editor.selection.isCollapsed()) {\n        const inlines = filter$6(elms, isInlineTarget);\n        each$g(inlines, _inline => {\n          const pos = CaretPosition.fromRangeStart(editor.selection.getRng());\n          readLocation(isInlineTarget, editor.getBody(), pos).bind(location => renderCaretLocation(editor, caret, location));\n        });\n      }\n    };\n    const move$2 = (editor, caret, forward) => isInlineBoundariesEnabled(editor) ? findLocation(editor, caret, forward).isSome() : false;\n    const moveWord = (forward, editor, _caret) => isInlineBoundariesEnabled(editor) ? moveByWord(forward, editor) : false;\n    const setupSelectedState = editor => {\n      const caret = Cell(null);\n      const isInlineTarget$1 = curry(isInlineTarget, editor);\n      editor.on('NodeChange', e => {\n        if (isInlineBoundariesEnabled(editor)) {\n          toggleInlines(isInlineTarget$1, editor.dom, e.parents);\n          safeRemoveCaretContainer(editor, caret);\n          renderInsideInlineCaret(isInlineTarget$1, editor, caret, e.parents);\n        }\n      });\n      return caret;\n    };\n    const moveNextWord = curry(moveWord, true);\n    const movePrevWord = curry(moveWord, false);\n    const moveToLineEndPoint$2 = (editor, forward, caret) => {\n      if (isInlineBoundariesEnabled(editor)) {\n        const linePoint = getLineEndPoint(editor, forward).getOrThunk(() => {\n          const rng = editor.selection.getRng();\n          return forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);\n        });\n        return readLocation(curry(isInlineTarget, editor), editor.getBody(), linePoint).exists(loc => {\n          const outsideLoc = outside(loc);\n          return renderCaret(caret, outsideLoc).exists(pos => {\n            setCaretPosition(editor, pos);\n            return true;\n          });\n        });\n      } else {\n        return false;\n      }\n    };\n\n    const rangeFromPositions = (from, to) => {\n      const range = document.createRange();\n      range.setStart(from.container(), from.offset());\n      range.setEnd(to.container(), to.offset());\n      return range;\n    };\n    const hasOnlyTwoOrLessPositionsLeft = elm => lift2(firstPositionIn(elm), lastPositionIn(elm), (firstPos, lastPos) => {\n      const normalizedFirstPos = normalizePosition(true, firstPos);\n      const normalizedLastPos = normalizePosition(false, lastPos);\n      return nextPosition(elm, normalizedFirstPos).forall(pos => pos.isEqual(normalizedLastPos));\n    }).getOr(true);\n    const setCaretLocation = (editor, caret) => location => renderCaret(caret, location).map(pos => () => setCaretPosition(editor, pos));\n    const deleteFromTo = (editor, caret, from, to) => {\n      const rootNode = editor.getBody();\n      const isInlineTarget$1 = curry(isInlineTarget, editor);\n      editor.undoManager.ignore(() => {\n        editor.selection.setRng(rangeFromPositions(from, to));\n        execDeleteCommand(editor);\n        readLocation(isInlineTarget$1, rootNode, CaretPosition.fromRangeStart(editor.selection.getRng())).map(inside).bind(setCaretLocation(editor, caret)).each(call);\n      });\n      editor.nodeChanged();\n    };\n    const rescope = (rootNode, node) => {\n      const parentBlock = getParentBlock$3(node, rootNode);\n      return parentBlock ? parentBlock : rootNode;\n    };\n    const backspaceDeleteCollapsed = (editor, caret, forward, from) => {\n      const rootNode = rescope(editor.getBody(), from.container());\n      const isInlineTarget$1 = curry(isInlineTarget, editor);\n      const fromLocation = readLocation(isInlineTarget$1, rootNode, from);\n      const location = fromLocation.bind(location => {\n        if (forward) {\n          return location.fold(constant(Optional.some(inside(location))), Optional.none, constant(Optional.some(outside(location))), Optional.none);\n        } else {\n          return location.fold(Optional.none, constant(Optional.some(outside(location))), Optional.none, constant(Optional.some(inside(location))));\n        }\n      });\n      return location.map(setCaretLocation(editor, caret)).getOrThunk(() => {\n        const toPosition = navigate(forward, rootNode, from);\n        const toLocation = toPosition.bind(pos => readLocation(isInlineTarget$1, rootNode, pos));\n        return lift2(fromLocation, toLocation, () => findRootInline(isInlineTarget$1, rootNode, from).bind(elm => {\n          if (hasOnlyTwoOrLessPositionsLeft(elm)) {\n            return Optional.some(() => {\n              deleteElement$2(editor, forward, SugarElement.fromDom(elm));\n            });\n          } else {\n            return Optional.none();\n          }\n        })).getOrThunk(() => toLocation.bind(() => toPosition.map(to => {\n          return () => {\n            if (forward) {\n              deleteFromTo(editor, caret, from, to);\n            } else {\n              deleteFromTo(editor, caret, to, from);\n            }\n          };\n        })));\n      });\n    };\n    const backspaceDelete$3 = (editor, caret, forward) => {\n      if (editor.selection.isCollapsed() && isInlineBoundariesEnabled(editor)) {\n        const from = CaretPosition.fromRangeStart(editor.selection.getRng());\n        return backspaceDeleteCollapsed(editor, caret, forward, from);\n      }\n      return Optional.none();\n    };\n\n    const getParentInlines = (rootElm, startElm) => {\n      const parents = parentsAndSelf(startElm, rootElm);\n      return findIndex$2(parents, isBlock$2).fold(constant(parents), index => parents.slice(0, index));\n    };\n    const hasOnlyOneChild = elm => childNodesCount(elm) === 1;\n    const deleteLastPosition = (forward, editor, target, parentInlines) => {\n      const isFormatElement$1 = curry(isFormatElement, editor);\n      const formatNodes = map$3(filter$6(parentInlines, isFormatElement$1), elm => elm.dom);\n      if (formatNodes.length === 0) {\n        deleteElement$2(editor, forward, target);\n      } else {\n        const pos = replaceWithCaretFormat(target.dom, formatNodes);\n        editor.selection.setRng(pos.toRange());\n      }\n    };\n    const deleteCaret$1 = (editor, forward) => {\n      const rootElm = SugarElement.fromDom(editor.getBody());\n      const startElm = SugarElement.fromDom(editor.selection.getStart());\n      const parentInlines = filter$6(getParentInlines(rootElm, startElm), hasOnlyOneChild);\n      return last$3(parentInlines).bind(target => {\n        const fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());\n        if (willDeleteLastPositionInElement(forward, fromPos, target.dom) && !isEmptyCaretFormatElement(target)) {\n          return Optional.some(() => deleteLastPosition(forward, editor, target, parentInlines));\n        } else {\n          return Optional.none();\n        }\n      });\n    };\n    const backspaceDelete$2 = (editor, forward) => editor.selection.isCollapsed() ? deleteCaret$1(editor, forward) : Optional.none();\n\n    const deleteElement = (editor, forward, element) => {\n      return Optional.some(() => {\n        editor._selectionOverrides.hideFakeCaret();\n        deleteElement$2(editor, forward, SugarElement.fromDom(element));\n      });\n    };\n    const deleteCaret = (editor, forward) => {\n      const isNearMedia = forward ? isBeforeMedia : isAfterMedia;\n      const direction = forward ? HDirection.Forwards : HDirection.Backwards;\n      const fromPos = getNormalizedRangeEndPoint(direction, editor.getBody(), editor.selection.getRng());\n      if (isNearMedia(fromPos)) {\n        return deleteElement(editor, forward, fromPos.getNode(!forward));\n      } else {\n        return Optional.from(normalizePosition(forward, fromPos)).filter(pos => isNearMedia(pos) && isMoveInsideSameBlock(fromPos, pos)).map(pos => () => deleteElement(editor, forward, pos.getNode(!forward)));\n      }\n    };\n    const deleteRange = (editor, forward) => {\n      const selectedNode = editor.selection.getNode();\n      return isMedia$2(selectedNode) ? deleteElement(editor, forward, selectedNode) : Optional.none();\n    };\n    const backspaceDelete$1 = (editor, forward) => editor.selection.isCollapsed() ? deleteCaret(editor, forward) : deleteRange(editor, forward);\n\n    const isEditable$1 = target => closest$4(target, elm => isContentEditableTrue$4(elm.dom) || isContentEditableFalse$a(elm.dom)).exists(elm => isContentEditableTrue$4(elm.dom));\n    const parseIndentValue = value => {\n      const number = parseInt(value, 10);\n      return isNaN(number) ? 0 : number;\n    };\n    const getIndentStyleName = (useMargin, element) => {\n      const indentStyleName = useMargin || isTable$2(element) ? 'margin' : 'padding';\n      const suffix = get$7(element, 'direction') === 'rtl' ? '-right' : '-left';\n      return indentStyleName + suffix;\n    };\n    const indentElement = (dom, command, useMargin, value, unit, element) => {\n      const indentStyleName = getIndentStyleName(useMargin, SugarElement.fromDom(element));\n      if (command === 'outdent') {\n        const styleValue = Math.max(0, parseIndentValue(element.style[indentStyleName]) - value);\n        dom.setStyle(element, indentStyleName, styleValue ? styleValue + unit : '');\n      } else {\n        const styleValue = parseIndentValue(element.style[indentStyleName]) + value + unit;\n        dom.setStyle(element, indentStyleName, styleValue);\n      }\n    };\n    const validateBlocks = (editor, blocks) => forall(blocks, block => {\n      const indentStyleName = getIndentStyleName(shouldIndentUseMargin(editor), block);\n      const intentValue = getRaw$1(block, indentStyleName).map(parseIndentValue).getOr(0);\n      const contentEditable = editor.dom.getContentEditable(block.dom);\n      return contentEditable !== 'false' && intentValue > 0;\n    });\n    const canOutdent = editor => {\n      const blocks = getBlocksToIndent(editor);\n      return !editor.mode.isReadOnly() && (blocks.length > 1 || validateBlocks(editor, blocks));\n    };\n    const isListComponent = el => isList(el) || isListItem(el);\n    const parentIsListComponent = el => parent(el).exists(isListComponent);\n    const getBlocksToIndent = editor => filter$6(fromDom$1(editor.selection.getSelectedBlocks()), el => !isListComponent(el) && !parentIsListComponent(el) && isEditable$1(el));\n    const handle = (editor, command) => {\n      const {dom} = editor;\n      const indentation = getIndentation(editor);\n      const indentUnit = /[a-z%]+$/i.exec(indentation)[0];\n      const indentValue = parseInt(indentation, 10);\n      const useMargin = shouldIndentUseMargin(editor);\n      each$g(getBlocksToIndent(editor), block => {\n        indentElement(dom, command, useMargin, indentValue, indentUnit, block.dom);\n      });\n    };\n    const indent = editor => handle(editor, 'indent');\n    const outdent = editor => handle(editor, 'outdent');\n\n    const backspaceDelete = editor => {\n      if (editor.selection.isCollapsed() && canOutdent(editor)) {\n        const dom = editor.dom;\n        const rng = editor.selection.getRng();\n        const pos = CaretPosition.fromRangeStart(rng);\n        const block = dom.getParent(rng.startContainer, dom.isBlock);\n        if (block !== null && isAtStartOfBlock(SugarElement.fromDom(block), pos)) {\n          return Optional.some(() => outdent(editor));\n        }\n      }\n      return Optional.none();\n    };\n\n    const findAction = (editor, caret, forward) => findMap([\n      backspaceDelete,\n      backspaceDelete$5,\n      backspaceDelete$6,\n      (editor, forward) => backspaceDelete$3(editor, caret, forward),\n      backspaceDelete$8,\n      backspaceDelete$9,\n      backspaceDelete$4,\n      backspaceDelete$1,\n      backspaceDelete$7,\n      backspaceDelete$2\n    ], item => item(editor, forward));\n    const deleteCommand = (editor, caret) => {\n      const result = findAction(editor, caret, false);\n      result.fold(() => {\n        execDeleteCommand(editor);\n        paddEmptyBody(editor);\n      }, call);\n    };\n    const forwardDeleteCommand = (editor, caret) => {\n      const result = findAction(editor, caret, true);\n      result.fold(() => execForwardDeleteCommand(editor), call);\n    };\n    const setup$p = (editor, caret) => {\n      editor.addCommand('delete', () => {\n        deleteCommand(editor, caret);\n      });\n      editor.addCommand('forwardDelete', () => {\n        forwardDeleteCommand(editor, caret);\n      });\n    };\n\n    const SIGNIFICANT_MOVE = 5;\n    const LONGPRESS_DELAY = 400;\n    const getTouch = event => {\n      if (event.touches === undefined || event.touches.length !== 1) {\n        return Optional.none();\n      }\n      return Optional.some(event.touches[0]);\n    };\n    const isFarEnough = (touch, data) => {\n      const distX = Math.abs(touch.clientX - data.x);\n      const distY = Math.abs(touch.clientY - data.y);\n      return distX > SIGNIFICANT_MOVE || distY > SIGNIFICANT_MOVE;\n    };\n    const setup$o = editor => {\n      const startData = value$2();\n      const longpressFired = Cell(false);\n      const debounceLongpress = last$1(e => {\n        editor.dispatch('longpress', {\n          ...e,\n          type: 'longpress'\n        });\n        longpressFired.set(true);\n      }, LONGPRESS_DELAY);\n      editor.on('touchstart', e => {\n        getTouch(e).each(touch => {\n          debounceLongpress.cancel();\n          const data = {\n            x: touch.clientX,\n            y: touch.clientY,\n            target: e.target\n          };\n          debounceLongpress.throttle(e);\n          longpressFired.set(false);\n          startData.set(data);\n        });\n      }, true);\n      editor.on('touchmove', e => {\n        debounceLongpress.cancel();\n        getTouch(e).each(touch => {\n          startData.on(data => {\n            if (isFarEnough(touch, data)) {\n              startData.clear();\n              longpressFired.set(false);\n              editor.dispatch('longpresscancel');\n            }\n          });\n        });\n      }, true);\n      editor.on('touchend touchcancel', e => {\n        debounceLongpress.cancel();\n        if (e.type === 'touchcancel') {\n          return;\n        }\n        startData.get().filter(data => data.target.isEqualNode(e.target)).each(() => {\n          if (longpressFired.get()) {\n            e.preventDefault();\n          } else {\n            editor.dispatch('tap', {\n              ...e,\n              type: 'tap'\n            });\n          }\n        });\n      }, true);\n    };\n\n    const isBlockElement = (blockElements, node) => has$2(blockElements, node.nodeName);\n    const isValidTarget = (blockElements, node) => {\n      if (isText$8(node)) {\n        return true;\n      } else if (isElement$6(node)) {\n        return !isBlockElement(blockElements, node) && !isBookmarkNode$1(node);\n      } else {\n        return false;\n      }\n    };\n    const hasBlockParent = (blockElements, root, node) => {\n      return exists(parents(SugarElement.fromDom(node), SugarElement.fromDom(root)), elm => {\n        return isBlockElement(blockElements, elm.dom);\n      });\n    };\n    const shouldRemoveTextNode = (blockElements, node) => {\n      if (isText$8(node)) {\n        if (node.nodeValue.length === 0) {\n          return true;\n        } else if (/^\\s+$/.test(node.nodeValue) && (!node.nextSibling || isBlockElement(blockElements, node.nextSibling))) {\n          return true;\n        }\n      }\n      return false;\n    };\n    const addRootBlocks = editor => {\n      const dom = editor.dom, selection = editor.selection;\n      const schema = editor.schema, blockElements = schema.getBlockElements();\n      let node = selection.getStart();\n      const rootNode = editor.getBody();\n      let rootBlockNode, tempNode, wrapped;\n      const forcedRootBlock = getForcedRootBlock(editor);\n      if (!node || !isElement$6(node)) {\n        return;\n      }\n      const rootNodeName = rootNode.nodeName.toLowerCase();\n      if (!schema.isValidChild(rootNodeName, forcedRootBlock.toLowerCase()) || hasBlockParent(blockElements, rootNode, node)) {\n        return;\n      }\n      const rng = selection.getRng();\n      const startContainer = rng.startContainer;\n      const startOffset = rng.startOffset;\n      const endContainer = rng.endContainer;\n      const endOffset = rng.endOffset;\n      const restoreSelection = hasFocus(editor);\n      node = rootNode.firstChild;\n      while (node) {\n        if (isValidTarget(blockElements, node)) {\n          if (shouldRemoveTextNode(blockElements, node)) {\n            tempNode = node;\n            node = node.nextSibling;\n            dom.remove(tempNode);\n            continue;\n          }\n          if (!rootBlockNode) {\n            rootBlockNode = dom.create(forcedRootBlock, getForcedRootBlockAttrs(editor));\n            node.parentNode.insertBefore(rootBlockNode, node);\n            wrapped = true;\n          }\n          tempNode = node;\n          node = node.nextSibling;\n          rootBlockNode.appendChild(tempNode);\n        } else {\n          rootBlockNode = null;\n          node = node.nextSibling;\n        }\n      }\n      if (wrapped && restoreSelection) {\n        rng.setStart(startContainer, startOffset);\n        rng.setEnd(endContainer, endOffset);\n        selection.setRng(rng);\n        editor.nodeChanged();\n      }\n    };\n    const setup$n = editor => {\n      editor.on('NodeChange', curry(addRootBlocks, editor));\n    };\n\n    const hasClass = checkClassName => node => (' ' + node.attr('class') + ' ').indexOf(checkClassName) !== -1;\n    const replaceMatchWithSpan = (editor, content, cls) => {\n      return function (match) {\n        const args = arguments, index = args[args.length - 2];\n        const prevChar = index > 0 ? content.charAt(index - 1) : '';\n        if (prevChar === '\"') {\n          return match;\n        }\n        if (prevChar === '>') {\n          const findStartTagIndex = content.lastIndexOf('<', index);\n          if (findStartTagIndex !== -1) {\n            const tagHtml = content.substring(findStartTagIndex, index);\n            if (tagHtml.indexOf('contenteditable=\"false\"') !== -1) {\n              return match;\n            }\n          }\n        }\n        return '<span class=\"' + cls + '\" data-mce-content=\"' + editor.dom.encode(args[0]) + '\">' + editor.dom.encode(typeof args[1] === 'string' ? args[1] : args[0]) + '</span>';\n      };\n    };\n    const convertRegExpsToNonEditable = (editor, nonEditableRegExps, e) => {\n      let i = nonEditableRegExps.length, content = e.content;\n      if (e.format === 'raw') {\n        return;\n      }\n      while (i--) {\n        content = content.replace(nonEditableRegExps[i], replaceMatchWithSpan(editor, content, getNonEditableClass(editor)));\n      }\n      e.content = content;\n    };\n    const setup$m = editor => {\n      const contentEditableAttrName = 'contenteditable';\n      const editClass = ' ' + Tools.trim(getEditableClass(editor)) + ' ';\n      const nonEditClass = ' ' + Tools.trim(getNonEditableClass(editor)) + ' ';\n      const hasEditClass = hasClass(editClass);\n      const hasNonEditClass = hasClass(nonEditClass);\n      const nonEditableRegExps = getNonEditableRegExps(editor);\n      if (nonEditableRegExps.length > 0) {\n        editor.on('BeforeSetContent', e => {\n          convertRegExpsToNonEditable(editor, nonEditableRegExps, e);\n        });\n      }\n      editor.parser.addAttributeFilter('class', nodes => {\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          if (hasEditClass(node)) {\n            node.attr(contentEditableAttrName, 'true');\n          } else if (hasNonEditClass(node)) {\n            node.attr(contentEditableAttrName, 'false');\n          }\n        }\n      });\n      editor.serializer.addAttributeFilter(contentEditableAttrName, nodes => {\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          if (!hasEditClass(node) && !hasNonEditClass(node)) {\n            continue;\n          }\n          if (nonEditableRegExps.length > 0 && node.attr('data-mce-content')) {\n            node.name = '#text';\n            node.type = 3;\n            node.raw = true;\n            node.value = node.attr('data-mce-content');\n          } else {\n            node.attr(contentEditableAttrName, null);\n          }\n        }\n      });\n    };\n\n    const findBlockCaretContainer = editor => descendant(SugarElement.fromDom(editor.getBody()), '*[data-mce-caret]').map(elm => elm.dom).getOrNull();\n    const showBlockCaretContainer = (editor, blockCaretContainer) => {\n      if (blockCaretContainer.hasAttribute('data-mce-caret')) {\n        showCaretContainerBlock(blockCaretContainer);\n        editor.selection.setRng(editor.selection.getRng());\n        editor.selection.scrollIntoView(blockCaretContainer);\n      }\n    };\n    const handleBlockContainer = (editor, e) => {\n      const blockCaretContainer = findBlockCaretContainer(editor);\n      if (!blockCaretContainer) {\n        return;\n      }\n      if (e.type === 'compositionstart') {\n        e.preventDefault();\n        e.stopPropagation();\n        showBlockCaretContainer(editor, blockCaretContainer);\n        return;\n      }\n      if (hasContent(blockCaretContainer)) {\n        showBlockCaretContainer(editor, blockCaretContainer);\n        editor.undoManager.add();\n      }\n    };\n    const setup$l = editor => {\n      editor.on('keyup compositionstart', curry(handleBlockContainer, editor));\n    };\n\n    const isContentEditableFalse$2 = isContentEditableFalse$a;\n    const moveToCeFalseHorizontally = (direction, editor, range) => moveHorizontally(editor, direction, range, isBeforeContentEditableFalse, isAfterContentEditableFalse, isContentEditableFalse$2);\n    const moveToCeFalseVertically = (direction, editor, range) => {\n      const isBefore = caretPosition => isBeforeContentEditableFalse(caretPosition) || isBeforeTable(caretPosition);\n      const isAfter = caretPosition => isAfterContentEditableFalse(caretPosition) || isAfterTable(caretPosition);\n      return moveVertically(editor, direction, range, isBefore, isAfter, isContentEditableFalse$2);\n    };\n    const createTextBlock = editor => {\n      const textBlock = editor.dom.create(getForcedRootBlock(editor));\n      textBlock.innerHTML = '<br data-mce-bogus=\"1\">';\n      return textBlock;\n    };\n    const exitPreBlock = (editor, direction, range) => {\n      const caretWalker = CaretWalker(editor.getBody());\n      const getVisualCaretPosition$1 = curry(getVisualCaretPosition, direction === 1 ? caretWalker.next : caretWalker.prev);\n      if (range.collapsed) {\n        const pre = editor.dom.getParent(range.startContainer, 'PRE');\n        if (!pre) {\n          return;\n        }\n        const caretPos = getVisualCaretPosition$1(CaretPosition.fromRangeStart(range));\n        if (!caretPos) {\n          const newBlock = SugarElement.fromDom(createTextBlock(editor));\n          if (direction === 1) {\n            after$4(SugarElement.fromDom(pre), newBlock);\n          } else {\n            before$3(SugarElement.fromDom(pre), newBlock);\n          }\n          editor.selection.select(newBlock.dom, true);\n          editor.selection.collapse();\n        }\n      }\n    };\n    const getHorizontalRange = (editor, forward) => {\n      const direction = forward ? HDirection.Forwards : HDirection.Backwards;\n      const range = editor.selection.getRng();\n      return moveToCeFalseHorizontally(direction, editor, range).orThunk(() => {\n        exitPreBlock(editor, direction, range);\n        return Optional.none();\n      });\n    };\n    const getVerticalRange = (editor, down) => {\n      const direction = down ? 1 : -1;\n      const range = editor.selection.getRng();\n      return moveToCeFalseVertically(direction, editor, range).orThunk(() => {\n        exitPreBlock(editor, direction, range);\n        return Optional.none();\n      });\n    };\n    const moveH$2 = (editor, forward) => getHorizontalRange(editor, forward).exists(newRange => {\n      moveToRange(editor, newRange);\n      return true;\n    });\n    const moveV$3 = (editor, down) => getVerticalRange(editor, down).exists(newRange => {\n      moveToRange(editor, newRange);\n      return true;\n    });\n    const moveToLineEndPoint$1 = (editor, forward) => {\n      const isCefPosition = forward ? isAfterContentEditableFalse : isBeforeContentEditableFalse;\n      return moveToLineEndPoint$3(editor, forward, isCefPosition);\n    };\n\n    const isTarget = node => contains$2(['figcaption'], name(node));\n    const rangeBefore = target => {\n      const rng = document.createRange();\n      rng.setStartBefore(target.dom);\n      rng.setEndBefore(target.dom);\n      return rng;\n    };\n    const insertElement = (root, elm, forward) => {\n      if (forward) {\n        append$1(root, elm);\n      } else {\n        prepend(root, elm);\n      }\n    };\n    const insertEmptyLine = (root, forward, blockName, attrs) => {\n      const block = SugarElement.fromTag(blockName);\n      const br = SugarElement.fromTag('br');\n      setAll$1(block, attrs);\n      append$1(block, br);\n      insertElement(root, block, forward);\n      return rangeBefore(br);\n    };\n    const getClosestTargetBlock = (pos, root) => {\n      const isRoot = curry(eq, root);\n      return closest$4(SugarElement.fromDom(pos.container()), isBlock$2, isRoot).filter(isTarget);\n    };\n    const isAtFirstOrLastLine = (root, forward, pos) => forward ? isAtLastLine(root.dom, pos) : isAtFirstLine(root.dom, pos);\n    const moveCaretToNewEmptyLine = (editor, forward) => {\n      const root = SugarElement.fromDom(editor.getBody());\n      const pos = CaretPosition.fromRangeStart(editor.selection.getRng());\n      const rootBlock = getForcedRootBlock(editor);\n      const rootBlockAttrs = getForcedRootBlockAttrs(editor);\n      return getClosestTargetBlock(pos, root).exists(() => {\n        if (isAtFirstOrLastLine(root, forward, pos)) {\n          const rng = insertEmptyLine(root, forward, rootBlock, rootBlockAttrs);\n          editor.selection.setRng(rng);\n          return true;\n        } else {\n          return false;\n        }\n      });\n    };\n    const moveV$2 = (editor, forward) => {\n      if (editor.selection.isCollapsed()) {\n        return moveCaretToNewEmptyLine(editor, forward);\n      } else {\n        return false;\n      }\n    };\n\n    const baseKeyPattern = {\n      shiftKey: false,\n      altKey: false,\n      ctrlKey: false,\n      metaKey: false,\n      keyCode: 0\n    };\n    const defaultPatterns = patterns => map$3(patterns, pattern => ({\n      ...baseKeyPattern,\n      action: noop,\n      ...pattern\n    }));\n    const defaultDelayedPatterns = patterns => map$3(patterns, pattern => ({\n      ...baseKeyPattern,\n      action: () => Optional.none(),\n      ...pattern\n    }));\n    const matchesEvent = (pattern, evt) => evt.keyCode === pattern.keyCode && evt.shiftKey === pattern.shiftKey && evt.altKey === pattern.altKey && evt.ctrlKey === pattern.ctrlKey && evt.metaKey === pattern.metaKey;\n    const match$1 = (patterns, evt) => bind$3(defaultPatterns(patterns), pattern => matchesEvent(pattern, evt) ? [pattern] : []);\n    const matchDelayed = (patterns, evt) => bind$3(defaultDelayedPatterns(patterns), pattern => matchesEvent(pattern, evt) ? [pattern] : []);\n    const action = (f, ...x) => () => f.apply(null, x);\n    const execute = (patterns, evt) => find$2(match$1(patterns, evt), pattern => pattern.action());\n    const executeWithDelayedAction = (patterns, evt) => findMap(matchDelayed(patterns, evt), pattern => pattern.action());\n\n    const moveH$1 = (editor, forward) => {\n      const direction = forward ? HDirection.Forwards : HDirection.Backwards;\n      const range = editor.selection.getRng();\n      return moveHorizontally(editor, direction, range, isBeforeMedia, isAfterMedia, isMedia$2).exists(newRange => {\n        moveToRange(editor, newRange);\n        return true;\n      });\n    };\n    const moveV$1 = (editor, down) => {\n      const direction = down ? 1 : -1;\n      const range = editor.selection.getRng();\n      return moveVertically(editor, direction, range, isBeforeMedia, isAfterMedia, isMedia$2).exists(newRange => {\n        moveToRange(editor, newRange);\n        return true;\n      });\n    };\n    const moveToLineEndPoint = (editor, forward) => {\n      const isNearMedia = forward ? isAfterMedia : isBeforeMedia;\n      return moveToLineEndPoint$3(editor, forward, isNearMedia);\n    };\n\n    const adt = Adt.generate([\n      { none: ['current'] },\n      { first: ['current'] },\n      {\n        middle: [\n          'current',\n          'target'\n        ]\n      },\n      { last: ['current'] }\n    ]);\n    const none = current => adt.none(current);\n    const CellLocation = {\n      ...adt,\n      none\n    };\n\n    const firstLayer = (scope, selector) => {\n      return filterFirstLayer(scope, selector, always);\n    };\n    const filterFirstLayer = (scope, selector, predicate) => {\n      return bind$3(children(scope), x => {\n        if (is$1(x, selector)) {\n          return predicate(x) ? [x] : [];\n        } else {\n          return filterFirstLayer(x, selector, predicate);\n        }\n      });\n    };\n\n    const lookup$1 = (tags, element, isRoot = never) => {\n      if (isRoot(element)) {\n        return Optional.none();\n      }\n      if (contains$2(tags, name(element))) {\n        return Optional.some(element);\n      }\n      const isRootOrUpperTable = elm => is$1(elm, 'table') || isRoot(elm);\n      return ancestor$2(element, tags.join(','), isRootOrUpperTable);\n    };\n    const cell = (element, isRoot) => lookup$1([\n      'td',\n      'th'\n    ], element, isRoot);\n    const cells = ancestor => firstLayer(ancestor, 'th,td');\n    const table = (element, isRoot) => closest$3(element, 'table', isRoot);\n\n    const walk = (all, current, index, direction, isEligible = always) => {\n      const forwards = direction === 1;\n      if (!forwards && index <= 0) {\n        return CellLocation.first(all[0]);\n      } else if (forwards && index >= all.length - 1) {\n        return CellLocation.last(all[all.length - 1]);\n      } else {\n        const newIndex = index + direction;\n        const elem = all[newIndex];\n        return isEligible(elem) ? CellLocation.middle(current, elem) : walk(all, current, newIndex, direction, isEligible);\n      }\n    };\n    const detect = (current, isRoot) => {\n      return table(current, isRoot).bind(table => {\n        const all = cells(table);\n        const index = findIndex$2(all, x => eq(current, x));\n        return index.map(index => ({\n          index,\n          all\n        }));\n      });\n    };\n    const next = (current, isEligible, isRoot) => {\n      const detection = detect(current, isRoot);\n      return detection.fold(() => {\n        return CellLocation.none(current);\n      }, info => {\n        return walk(info.all, current, info.index, 1, isEligible);\n      });\n    };\n    const prev = (current, isEligible, isRoot) => {\n      const detection = detect(current, isRoot);\n      return detection.fold(() => {\n        return CellLocation.none();\n      }, info => {\n        return walk(info.all, current, info.index, -1, isEligible);\n      });\n    };\n\n    const closest = target => closest$3(target, '[contenteditable]');\n    const isEditable = (element, assumeEditable = false) => {\n      if (inBody(element)) {\n        return element.dom.isContentEditable;\n      } else {\n        return closest(element).fold(constant(assumeEditable), editable => getRaw(editable) === 'true');\n      }\n    };\n    const getRaw = element => element.dom.contentEditable;\n\n    const deflate = (rect, delta) => ({\n      left: rect.left - delta,\n      top: rect.top - delta,\n      right: rect.right + delta * 2,\n      bottom: rect.bottom + delta * 2,\n      width: rect.width + delta,\n      height: rect.height + delta\n    });\n    const getCorners = (getYAxisValue, tds) => bind$3(tds, td => {\n      const rect = deflate(clone$1(td.getBoundingClientRect()), -1);\n      return [\n        {\n          x: rect.left,\n          y: getYAxisValue(rect),\n          cell: td\n        },\n        {\n          x: rect.right,\n          y: getYAxisValue(rect),\n          cell: td\n        }\n      ];\n    });\n    const findClosestCorner = (corners, x, y) => foldl(corners, (acc, newCorner) => acc.fold(() => Optional.some(newCorner), oldCorner => {\n      const oldDist = Math.sqrt(Math.abs(oldCorner.x - x) + Math.abs(oldCorner.y - y));\n      const newDist = Math.sqrt(Math.abs(newCorner.x - x) + Math.abs(newCorner.y - y));\n      return Optional.some(newDist < oldDist ? newCorner : oldCorner);\n    }), Optional.none());\n    const getClosestCell = (getYAxisValue, isTargetCorner, table, x, y) => {\n      const cells = descendants(SugarElement.fromDom(table), 'td,th,caption').map(e => e.dom);\n      const corners = filter$6(getCorners(getYAxisValue, cells), corner => isTargetCorner(corner, y));\n      return findClosestCorner(corners, x, y).map(corner => corner.cell);\n    };\n    const getBottomValue = rect => rect.bottom;\n    const getTopValue = rect => rect.top;\n    const isAbove = (corner, y) => corner.y < y;\n    const isBelow = (corner, y) => corner.y > y;\n    const getClosestCellAbove = curry(getClosestCell, getBottomValue, isAbove);\n    const getClosestCellBelow = curry(getClosestCell, getTopValue, isBelow);\n    const findClosestPositionInAboveCell = (table, pos) => head(pos.getClientRects()).bind(rect => getClosestCellAbove(table, rect.left, rect.top)).bind(cell => findClosestHorizontalPosition(getLastLinePositions(cell), pos));\n    const findClosestPositionInBelowCell = (table, pos) => last$3(pos.getClientRects()).bind(rect => getClosestCellBelow(table, rect.left, rect.top)).bind(cell => findClosestHorizontalPosition(getFirstLinePositions(cell), pos));\n\n    const hasNextBreak = (getPositionsUntil, scope, lineInfo) => lineInfo.breakAt.exists(breakPos => getPositionsUntil(scope, breakPos).breakAt.isSome());\n    const startsWithWrapBreak = lineInfo => lineInfo.breakType === BreakType.Wrap && lineInfo.positions.length === 0;\n    const startsWithBrBreak = lineInfo => lineInfo.breakType === BreakType.Br && lineInfo.positions.length === 1;\n    const isAtTableCellLine = (getPositionsUntil, scope, pos) => {\n      const lineInfo = getPositionsUntil(scope, pos);\n      if (startsWithWrapBreak(lineInfo) || !isBr$5(pos.getNode()) && startsWithBrBreak(lineInfo)) {\n        return !hasNextBreak(getPositionsUntil, scope, lineInfo);\n      } else {\n        return lineInfo.breakAt.isNone();\n      }\n    };\n    const isAtFirstTableCellLine = curry(isAtTableCellLine, getPositionsUntilPreviousLine);\n    const isAtLastTableCellLine = curry(isAtTableCellLine, getPositionsUntilNextLine);\n    const isCaretAtStartOrEndOfTable = (forward, rng, table) => {\n      const caretPos = CaretPosition.fromRangeStart(rng);\n      return positionIn(!forward, table).exists(pos => pos.isEqual(caretPos));\n    };\n    const navigateHorizontally = (editor, forward, table, _td) => {\n      const rng = editor.selection.getRng();\n      const direction = forward ? 1 : -1;\n      if (isFakeCaretTableBrowser() && isCaretAtStartOrEndOfTable(forward, rng, table)) {\n        showCaret(direction, editor, table, !forward, false).each(newRng => {\n          moveToRange(editor, newRng);\n        });\n        return true;\n      }\n      return false;\n    };\n    const getClosestAbovePosition = (root, table, start) => findClosestPositionInAboveCell(table, start).orThunk(() => head(start.getClientRects()).bind(rect => findClosestHorizontalPositionFromPoint(getPositionsAbove(root, CaretPosition.before(table)), rect.left))).getOr(CaretPosition.before(table));\n    const getClosestBelowPosition = (root, table, start) => findClosestPositionInBelowCell(table, start).orThunk(() => head(start.getClientRects()).bind(rect => findClosestHorizontalPositionFromPoint(getPositionsBelow(root, CaretPosition.after(table)), rect.left))).getOr(CaretPosition.after(table));\n    const getTable = (previous, pos) => {\n      const node = pos.getNode(previous);\n      return isElement$6(node) && node.nodeName === 'TABLE' ? Optional.some(node) : Optional.none();\n    };\n    const renderBlock = (down, editor, table) => {\n      const forcedRootBlock = getForcedRootBlock(editor);\n      editor.undoManager.transact(() => {\n        const element = SugarElement.fromTag(forcedRootBlock);\n        setAll$1(element, getForcedRootBlockAttrs(editor));\n        append$1(element, SugarElement.fromTag('br'));\n        if (down) {\n          after$4(SugarElement.fromDom(table), element);\n        } else {\n          before$3(SugarElement.fromDom(table), element);\n        }\n        const rng = editor.dom.createRng();\n        rng.setStart(element.dom, 0);\n        rng.setEnd(element.dom, 0);\n        moveToRange(editor, rng);\n      });\n    };\n    const moveCaret = (editor, down, pos) => {\n      const table = down ? getTable(true, pos) : getTable(false, pos);\n      const last = down === false;\n      table.fold(() => moveToRange(editor, pos.toRange()), table => positionIn(last, editor.getBody()).filter(lastPos => lastPos.isEqual(pos)).fold(() => moveToRange(editor, pos.toRange()), _ => renderBlock(down, editor, table)));\n    };\n    const navigateVertically = (editor, down, table, td) => {\n      const rng = editor.selection.getRng();\n      const pos = CaretPosition.fromRangeStart(rng);\n      const root = editor.getBody();\n      if (!down && isAtFirstTableCellLine(td, pos)) {\n        const newPos = getClosestAbovePosition(root, table, pos);\n        moveCaret(editor, down, newPos);\n        return true;\n      } else if (down && isAtLastTableCellLine(td, pos)) {\n        const newPos = getClosestBelowPosition(root, table, pos);\n        moveCaret(editor, down, newPos);\n        return true;\n      } else {\n        return false;\n      }\n    };\n    const move$1 = (editor, forward, mover) => Optional.from(editor.dom.getParent(editor.selection.getNode(), 'td,th')).bind(td => Optional.from(editor.dom.getParent(td, 'table')).map(table => mover(editor, forward, table, td))).getOr(false);\n    const moveH = (editor, forward) => move$1(editor, forward, navigateHorizontally);\n    const moveV = (editor, forward) => move$1(editor, forward, navigateVertically);\n    const getCellFirstCursorPosition = cell => {\n      const selection = SimSelection.exact(cell, 0, cell, 0);\n      return toNative(selection);\n    };\n    const tabGo = (editor, isRoot, cell) => {\n      return cell.fold(Optional.none, Optional.none, (_current, next) => {\n        return first(next).map(cell => {\n          return getCellFirstCursorPosition(cell);\n        });\n      }, current => {\n        editor.execCommand('mceTableInsertRowAfter');\n        return tabForward(editor, isRoot, current);\n      });\n    };\n    const tabForward = (editor, isRoot, cell) => tabGo(editor, isRoot, next(cell, isEditable));\n    const tabBackward = (editor, isRoot, cell) => tabGo(editor, isRoot, prev(cell, isEditable));\n    const handleTab = (editor, forward) => {\n      const rootElements = [\n        'table',\n        'li',\n        'dl'\n      ];\n      const body = SugarElement.fromDom(editor.getBody());\n      const isRoot = element => {\n        const name$1 = name(element);\n        return eq(element, body) || contains$2(rootElements, name$1);\n      };\n      const rng = editor.selection.getRng();\n      const container = SugarElement.fromDom(!forward ? rng.startContainer : rng.endContainer);\n      return cell(container, isRoot).map(cell => {\n        table(cell, isRoot).each(table => {\n          editor.model.table.clearSelectedCells(table.dom);\n        });\n        editor.selection.collapse(!forward);\n        const navigation = !forward ? tabBackward : tabForward;\n        const rng = navigation(editor, isRoot, cell);\n        rng.each(range => {\n          editor.selection.setRng(range);\n        });\n        return true;\n      }).getOr(false);\n    };\n\n    const executeKeydownOverride$4 = (editor, caret, evt) => {\n      const os = detect$2().os;\n      execute([\n        {\n          keyCode: VK.RIGHT,\n          action: action(moveH$2, editor, true)\n        },\n        {\n          keyCode: VK.LEFT,\n          action: action(moveH$2, editor, false)\n        },\n        {\n          keyCode: VK.UP,\n          action: action(moveV$3, editor, false)\n        },\n        {\n          keyCode: VK.DOWN,\n          action: action(moveV$3, editor, true)\n        },\n        {\n          keyCode: VK.RIGHT,\n          action: action(moveH, editor, true)\n        },\n        {\n          keyCode: VK.LEFT,\n          action: action(moveH, editor, false)\n        },\n        {\n          keyCode: VK.UP,\n          action: action(moveV, editor, false)\n        },\n        {\n          keyCode: VK.DOWN,\n          action: action(moveV, editor, true)\n        },\n        {\n          keyCode: VK.RIGHT,\n          action: action(moveH$1, editor, true)\n        },\n        {\n          keyCode: VK.LEFT,\n          action: action(moveH$1, editor, false)\n        },\n        {\n          keyCode: VK.UP,\n          action: action(moveV$1, editor, false)\n        },\n        {\n          keyCode: VK.DOWN,\n          action: action(moveV$1, editor, true)\n        },\n        {\n          keyCode: VK.RIGHT,\n          action: action(move$2, editor, caret, true)\n        },\n        {\n          keyCode: VK.LEFT,\n          action: action(move$2, editor, caret, false)\n        },\n        {\n          keyCode: VK.RIGHT,\n          ctrlKey: !os.isMacOS(),\n          altKey: os.isMacOS(),\n          action: action(moveNextWord, editor, caret)\n        },\n        {\n          keyCode: VK.LEFT,\n          ctrlKey: !os.isMacOS(),\n          altKey: os.isMacOS(),\n          action: action(movePrevWord, editor, caret)\n        },\n        {\n          keyCode: VK.UP,\n          action: action(moveV$2, editor, false)\n        },\n        {\n          keyCode: VK.DOWN,\n          action: action(moveV$2, editor, true)\n        }\n      ], evt).each(_ => {\n        evt.preventDefault();\n      });\n    };\n    const setup$k = (editor, caret) => {\n      editor.on('keydown', evt => {\n        if (evt.isDefaultPrevented() === false) {\n          executeKeydownOverride$4(editor, caret, evt);\n        }\n      });\n    };\n\n    const point = (container, offset) => ({\n      container,\n      offset\n    });\n\n    const DOM$7 = DOMUtils.DOM;\n    const alwaysNext = startNode => node => startNode === node ? -1 : 0;\n    const isBoundary = dom => node => dom.isBlock(node) || contains$2([\n      'BR',\n      'IMG',\n      'HR',\n      'INPUT'\n    ], node.nodeName) || dom.getContentEditable(node) === 'false';\n    const textBefore = (node, offset, rootNode) => {\n      if (isText$8(node) && offset >= 0) {\n        return Optional.some(point(node, offset));\n      } else {\n        const textSeeker = TextSeeker(DOM$7);\n        return Optional.from(textSeeker.backwards(node, offset, alwaysNext(node), rootNode)).map(prev => point(prev.container, prev.container.data.length));\n      }\n    };\n    const textAfter = (node, offset, rootNode) => {\n      if (isText$8(node) && offset >= node.length) {\n        return Optional.some(point(node, offset));\n      } else {\n        const textSeeker = TextSeeker(DOM$7);\n        return Optional.from(textSeeker.forwards(node, offset, alwaysNext(node), rootNode)).map(prev => point(prev.container, 0));\n      }\n    };\n    const scanLeft = (node, offset, rootNode) => {\n      if (!isText$8(node)) {\n        return Optional.none();\n      }\n      const text = node.textContent;\n      if (offset >= 0 && offset <= text.length) {\n        return Optional.some(point(node, offset));\n      } else {\n        const textSeeker = TextSeeker(DOM$7);\n        return Optional.from(textSeeker.backwards(node, offset, alwaysNext(node), rootNode)).bind(prev => {\n          const prevText = prev.container.data;\n          return scanLeft(prev.container, offset + prevText.length, rootNode);\n        });\n      }\n    };\n    const scanRight = (node, offset, rootNode) => {\n      if (!isText$8(node)) {\n        return Optional.none();\n      }\n      const text = node.textContent;\n      if (offset <= text.length) {\n        return Optional.some(point(node, offset));\n      } else {\n        const textSeeker = TextSeeker(DOM$7);\n        return Optional.from(textSeeker.forwards(node, offset, alwaysNext(node), rootNode)).bind(next => scanRight(next.container, offset - text.length, rootNode));\n      }\n    };\n    const repeatLeft = (dom, node, offset, process, rootNode) => {\n      const search = TextSeeker(dom, isBoundary(dom));\n      return Optional.from(search.backwards(node, offset, process, rootNode));\n    };\n\n    const isValidTextRange = rng => rng.collapsed && rng.startContainer.nodeType === 3;\n    const getText = rng => rng.toString().replace(/\\u00A0/g, ' ').replace(/\\uFEFF/g, '');\n    const isWhitespace = chr => chr !== '' && ' \\xA0\\f\\n\\r\\t\\x0B'.indexOf(chr) !== -1;\n\n    const stripTriggerChar = (text, triggerCh) => text.substring(triggerCh.length);\n    const findChar = (text, index, ch) => {\n      let i;\n      for (i = index - 1; i >= 0; i--) {\n        const char = text.charAt(i);\n        if (isWhitespace(char)) {\n          return Optional.none();\n        }\n        if (char === ch) {\n          break;\n        }\n      }\n      return Optional.some(i);\n    };\n    const findStart = (dom, initRange, ch, minChars = 0) => {\n      if (!isValidTextRange(initRange)) {\n        return Optional.none();\n      }\n      const findTriggerChIndex = (element, offset, text) => findChar(text, offset, ch).getOr(offset);\n      const root = dom.getParent(initRange.startContainer, dom.isBlock) || dom.getRoot();\n      return repeatLeft(dom, initRange.startContainer, initRange.startOffset, findTriggerChIndex, root).bind(spot => {\n        const range = initRange.cloneRange();\n        range.setStart(spot.container, spot.offset);\n        range.setEnd(initRange.endContainer, initRange.endOffset);\n        if (range.collapsed) {\n          return Optional.none();\n        }\n        const text = getText(range);\n        const triggerCharIndex = text.lastIndexOf(ch);\n        if (triggerCharIndex !== 0 || stripTriggerChar(text, ch).length < minChars) {\n          return Optional.none();\n        } else {\n          return Optional.some({\n            text: stripTriggerChar(text, ch),\n            range,\n            triggerChar: ch\n          });\n        }\n      });\n    };\n    const getContext = (dom, initRange, ch, minChars = 0) => detect$1(SugarElement.fromDom(initRange.startContainer)).fold(() => findStart(dom, initRange, ch, minChars), elm => {\n      const range = dom.createRng();\n      range.selectNode(elm.dom);\n      const text = getText(range);\n      return Optional.some({\n        range,\n        text: stripTriggerChar(text, ch),\n        triggerChar: ch\n      });\n    });\n\n    const isText = node => node.nodeType === TEXT;\n    const isElement = node => node.nodeType === ELEMENT;\n    const toLast = node => {\n      if (isText(node)) {\n        return point(node, node.data.length);\n      } else {\n        const children = node.childNodes;\n        return children.length > 0 ? toLast(children[children.length - 1]) : point(node, children.length);\n      }\n    };\n    const toLeaf = (node, offset) => {\n      const children = node.childNodes;\n      if (children.length > 0 && offset < children.length) {\n        return toLeaf(children[offset], 0);\n      } else if (children.length > 0 && isElement(node) && children.length === offset) {\n        return toLast(children[children.length - 1]);\n      } else {\n        return point(node, offset);\n      }\n    };\n\n    const isPreviousCharContent = (dom, leaf) => repeatLeft(dom, leaf.container, leaf.offset, (element, offset) => offset === 0 ? -1 : offset, dom.getRoot()).filter(spot => {\n      const char = spot.container.data.charAt(spot.offset - 1);\n      return !isWhitespace(char);\n    }).isSome();\n    const isStartOfWord = dom => rng => {\n      const leaf = toLeaf(rng.startContainer, rng.startOffset);\n      return !isPreviousCharContent(dom, leaf);\n    };\n    const getTriggerContext = (dom, initRange, database) => findMap(database.triggerChars, ch => getContext(dom, initRange, ch));\n    const lookup = (editor, getDatabase) => {\n      const database = getDatabase();\n      const rng = editor.selection.getRng();\n      return getTriggerContext(editor.dom, rng, database).bind(context => lookupWithContext(editor, getDatabase, context));\n    };\n    const lookupWithContext = (editor, getDatabase, context, fetchOptions = {}) => {\n      const database = getDatabase();\n      const rng = editor.selection.getRng();\n      const startText = rng.startContainer.nodeValue;\n      const autocompleters = filter$6(database.lookupByChar(context.triggerChar), autocompleter => context.text.length >= autocompleter.minChars && autocompleter.matches.getOrThunk(() => isStartOfWord(editor.dom))(context.range, startText, context.text));\n      if (autocompleters.length === 0) {\n        return Optional.none();\n      }\n      const lookupData = Promise.all(map$3(autocompleters, ac => {\n        const fetchResult = ac.fetch(context.text, ac.maxResults, fetchOptions);\n        return fetchResult.then(results => ({\n          matchText: context.text,\n          items: results,\n          columns: ac.columns,\n          onAction: ac.onAction,\n          highlightOn: ac.highlightOn\n        }));\n      }));\n      return Optional.some({\n        lookupData,\n        context\n      });\n    };\n\n    var SimpleResultType;\n    (function (SimpleResultType) {\n      SimpleResultType[SimpleResultType['Error'] = 0] = 'Error';\n      SimpleResultType[SimpleResultType['Value'] = 1] = 'Value';\n    }(SimpleResultType || (SimpleResultType = {})));\n    const fold$1 = (res, onError, onValue) => res.stype === SimpleResultType.Error ? onError(res.serror) : onValue(res.svalue);\n    const partition = results => {\n      const values = [];\n      const errors = [];\n      each$g(results, obj => {\n        fold$1(obj, err => errors.push(err), val => values.push(val));\n      });\n      return {\n        values,\n        errors\n      };\n    };\n    const mapError = (res, f) => {\n      if (res.stype === SimpleResultType.Error) {\n        return {\n          stype: SimpleResultType.Error,\n          serror: f(res.serror)\n        };\n      } else {\n        return res;\n      }\n    };\n    const map = (res, f) => {\n      if (res.stype === SimpleResultType.Value) {\n        return {\n          stype: SimpleResultType.Value,\n          svalue: f(res.svalue)\n        };\n      } else {\n        return res;\n      }\n    };\n    const bind = (res, f) => {\n      if (res.stype === SimpleResultType.Value) {\n        return f(res.svalue);\n      } else {\n        return res;\n      }\n    };\n    const bindError = (res, f) => {\n      if (res.stype === SimpleResultType.Error) {\n        return f(res.serror);\n      } else {\n        return res;\n      }\n    };\n    const svalue = v => ({\n      stype: SimpleResultType.Value,\n      svalue: v\n    });\n    const serror = e => ({\n      stype: SimpleResultType.Error,\n      serror: e\n    });\n    const toResult = res => fold$1(res, Result.error, Result.value);\n    const fromResult = res => res.fold(serror, svalue);\n    const SimpleResult = {\n      fromResult,\n      toResult,\n      svalue,\n      partition,\n      serror,\n      bind,\n      bindError,\n      map,\n      mapError,\n      fold: fold$1\n    };\n\n    const formatObj = input => {\n      return isObject(input) && keys(input).length > 100 ? ' removed due to size' : JSON.stringify(input, null, 2);\n    };\n    const formatErrors = errors => {\n      const es = errors.length > 10 ? errors.slice(0, 10).concat([{\n          path: [],\n          getErrorInfo: constant('... (only showing first ten failures)')\n        }]) : errors;\n      return map$3(es, e => {\n        return 'Failed path: (' + e.path.join(' > ') + ')\\n' + e.getErrorInfo();\n      });\n    };\n\n    const nu = (path, getErrorInfo) => {\n      return SimpleResult.serror([{\n          path,\n          getErrorInfo\n        }]);\n    };\n    const missingRequired = (path, key, obj) => nu(path, () => 'Could not find valid *required* value for \"' + key + '\" in ' + formatObj(obj));\n    const missingKey = (path, key) => nu(path, () => 'Choice schema did not contain choice key: \"' + key + '\"');\n    const missingBranch = (path, branches, branch) => nu(path, () => 'The chosen schema: \"' + branch + '\" did not exist in branches: ' + formatObj(branches));\n    const custom = (path, err) => nu(path, constant(err));\n\n    const chooseFrom = (path, input, branches, ch) => {\n      const fields = get$a(branches, ch);\n      return fields.fold(() => missingBranch(path, branches, ch), vp => vp.extract(path.concat(['branch: ' + ch]), input));\n    };\n    const choose$1 = (key, branches) => {\n      const extract = (path, input) => {\n        const choice = get$a(input, key);\n        return choice.fold(() => missingKey(path, key), chosen => chooseFrom(path, input, branches, chosen));\n      };\n      const toString = () => 'chooseOn(' + key + '). Possible values: ' + keys(branches);\n      return {\n        extract,\n        toString\n      };\n    };\n\n    const shallow = (old, nu) => {\n      return nu;\n    };\n    const deep = (old, nu) => {\n      const bothObjects = isPlainObject(old) && isPlainObject(nu);\n      return bothObjects ? deepMerge(old, nu) : nu;\n    };\n    const baseMerge = merger => {\n      return (...objects) => {\n        if (objects.length === 0) {\n          throw new Error(`Can't merge zero objects`);\n        }\n        const ret = {};\n        for (let j = 0; j < objects.length; j++) {\n          const curObject = objects[j];\n          for (const key in curObject) {\n            if (has$2(curObject, key)) {\n              ret[key] = merger(ret[key], curObject[key]);\n            }\n          }\n        }\n        return ret;\n      };\n    };\n    const deepMerge = baseMerge(deep);\n    const merge = baseMerge(shallow);\n\n    const required = () => ({\n      tag: 'required',\n      process: {}\n    });\n    const defaultedThunk = fallbackThunk => ({\n      tag: 'defaultedThunk',\n      process: fallbackThunk\n    });\n    const defaulted$1 = fallback => defaultedThunk(constant(fallback));\n    const asOption = () => ({\n      tag: 'option',\n      process: {}\n    });\n\n    const mergeValues = (values, base) => values.length > 0 ? SimpleResult.svalue(deepMerge(base, merge.apply(undefined, values))) : SimpleResult.svalue(base);\n    const mergeErrors = errors => compose(SimpleResult.serror, flatten)(errors);\n    const consolidateObj = (objects, base) => {\n      const partition = SimpleResult.partition(objects);\n      return partition.errors.length > 0 ? mergeErrors(partition.errors) : mergeValues(partition.values, base);\n    };\n    const consolidateArr = objects => {\n      const partitions = SimpleResult.partition(objects);\n      return partitions.errors.length > 0 ? mergeErrors(partitions.errors) : SimpleResult.svalue(partitions.values);\n    };\n    const ResultCombine = {\n      consolidateObj,\n      consolidateArr\n    };\n\n    const field$1 = (key, newKey, presence, prop) => ({\n      tag: 'field',\n      key,\n      newKey,\n      presence,\n      prop\n    });\n    const customField$1 = (newKey, instantiator) => ({\n      tag: 'custom',\n      newKey,\n      instantiator\n    });\n    const fold = (value, ifField, ifCustom) => {\n      switch (value.tag) {\n      case 'field':\n        return ifField(value.key, value.newKey, value.presence, value.prop);\n      case 'custom':\n        return ifCustom(value.newKey, value.instantiator);\n      }\n    };\n\n    const value = validator => {\n      const extract = (path, val) => {\n        return SimpleResult.bindError(validator(val), err => custom(path, err));\n      };\n      const toString = constant('val');\n      return {\n        extract,\n        toString\n      };\n    };\n    const anyValue$1 = value(SimpleResult.svalue);\n\n    const requiredAccess = (path, obj, key, bundle) => get$a(obj, key).fold(() => missingRequired(path, key, obj), bundle);\n    const fallbackAccess = (obj, key, fallback, bundle) => {\n      const v = get$a(obj, key).getOrThunk(() => fallback(obj));\n      return bundle(v);\n    };\n    const optionAccess = (obj, key, bundle) => bundle(get$a(obj, key));\n    const optionDefaultedAccess = (obj, key, fallback, bundle) => {\n      const opt = get$a(obj, key).map(val => val === true ? fallback(obj) : val);\n      return bundle(opt);\n    };\n    const extractField = (field, path, obj, key, prop) => {\n      const bundle = av => prop.extract(path.concat([key]), av);\n      const bundleAsOption = optValue => optValue.fold(() => SimpleResult.svalue(Optional.none()), ov => {\n        const result = prop.extract(path.concat([key]), ov);\n        return SimpleResult.map(result, Optional.some);\n      });\n      switch (field.tag) {\n      case 'required':\n        return requiredAccess(path, obj, key, bundle);\n      case 'defaultedThunk':\n        return fallbackAccess(obj, key, field.process, bundle);\n      case 'option':\n        return optionAccess(obj, key, bundleAsOption);\n      case 'defaultedOptionThunk':\n        return optionDefaultedAccess(obj, key, field.process, bundleAsOption);\n      case 'mergeWithThunk': {\n          return fallbackAccess(obj, key, constant({}), v => {\n            const result = deepMerge(field.process(obj), v);\n            return bundle(result);\n          });\n        }\n      }\n    };\n    const extractFields = (path, obj, fields) => {\n      const success = {};\n      const errors = [];\n      for (const field of fields) {\n        fold(field, (key, newKey, presence, prop) => {\n          const result = extractField(presence, path, obj, key, prop);\n          SimpleResult.fold(result, err => {\n            errors.push(...err);\n          }, res => {\n            success[newKey] = res;\n          });\n        }, (newKey, instantiator) => {\n          success[newKey] = instantiator(obj);\n        });\n      }\n      return errors.length > 0 ? SimpleResult.serror(errors) : SimpleResult.svalue(success);\n    };\n    const objOf = values => {\n      const extract = (path, o) => extractFields(path, o, values);\n      const toString = () => {\n        const fieldStrings = map$3(values, value => fold(value, (key, _okey, _presence, prop) => key + ' -> ' + prop.toString(), (newKey, _instantiator) => 'state(' + newKey + ')'));\n        return 'obj{\\n' + fieldStrings.join('\\n') + '}';\n      };\n      return {\n        extract,\n        toString\n      };\n    };\n    const arrOf = prop => {\n      const extract = (path, array) => {\n        const results = map$3(array, (a, i) => prop.extract(path.concat(['[' + i + ']']), a));\n        return ResultCombine.consolidateArr(results);\n      };\n      const toString = () => 'array(' + prop.toString() + ')';\n      return {\n        extract,\n        toString\n      };\n    };\n\n    const valueOf = validator => value(v => validator(v).fold(SimpleResult.serror, SimpleResult.svalue));\n    const extractValue = (label, prop, obj) => {\n      const res = prop.extract([label], obj);\n      return SimpleResult.mapError(res, errs => ({\n        input: obj,\n        errors: errs\n      }));\n    };\n    const asRaw = (label, prop, obj) => SimpleResult.toResult(extractValue(label, prop, obj));\n    const formatError = errInfo => {\n      return 'Errors: \\n' + formatErrors(errInfo.errors).join('\\n') + '\\n\\nInput object: ' + formatObj(errInfo.input);\n    };\n    const choose = (key, branches) => choose$1(key, map$2(branches, objOf));\n\n    const anyValue = constant(anyValue$1);\n    const typedValue = (validator, expectedType) => value(a => {\n      const actualType = typeof a;\n      return validator(a) ? SimpleResult.svalue(a) : SimpleResult.serror(`Expected type: ${ expectedType } but got: ${ actualType }`);\n    });\n    const number = typedValue(isNumber, 'number');\n    const string = typedValue(isString, 'string');\n    const boolean = typedValue(isBoolean, 'boolean');\n    const functionProcessor = typedValue(isFunction, 'function');\n\n    const field = field$1;\n    const customField = customField$1;\n    const validateEnum = values => valueOf(value => contains$2(values, value) ? Result.value(value) : Result.error(`Unsupported value: \"${ value }\", choose one of \"${ values.join(', ') }\".`));\n    const requiredOf = (key, schema) => field(key, key, required(), schema);\n    const requiredString = key => requiredOf(key, string);\n    const requiredFunction = key => requiredOf(key, functionProcessor);\n    const requiredArrayOf = (key, schema) => field(key, key, required(), arrOf(schema));\n    const optionOf = (key, schema) => field(key, key, asOption(), schema);\n    const optionString = key => optionOf(key, string);\n    const optionFunction = key => optionOf(key, functionProcessor);\n    const defaulted = (key, fallback) => field(key, key, defaulted$1(fallback), anyValue());\n    const defaultedOf = (key, fallback, schema) => field(key, key, defaulted$1(fallback), schema);\n    const defaultedNumber = (key, fallback) => defaultedOf(key, fallback, number);\n    const defaultedString = (key, fallback) => defaultedOf(key, fallback, string);\n    const defaultedStringEnum = (key, fallback, values) => defaultedOf(key, fallback, validateEnum(values));\n    const defaultedBoolean = (key, fallback) => defaultedOf(key, fallback, boolean);\n    const defaultedFunction = (key, fallback) => defaultedOf(key, fallback, functionProcessor);\n    const defaultedArrayOf = (key, fallback, schema) => defaultedOf(key, fallback, arrOf(schema));\n\n    const type = requiredString('type');\n    const fetch = requiredFunction('fetch');\n    const onAction = requiredFunction('onAction');\n    const onSetup = defaultedFunction('onSetup', () => noop);\n    const optionalText = optionString('text');\n    const optionalIcon = optionString('icon');\n    const optionalTooltip = optionString('tooltip');\n    const optionalLabel = optionString('label');\n    const active = defaultedBoolean('active', false);\n    const enabled = defaultedBoolean('enabled', true);\n    const primary = defaultedBoolean('primary', false);\n    const defaultedColumns = num => defaulted('columns', num);\n    const defaultedType = type => defaultedString('type', type);\n\n    const autocompleterSchema = objOf([\n      type,\n      requiredString('ch'),\n      defaultedNumber('minChars', 1),\n      defaultedColumns(1),\n      defaultedNumber('maxResults', 10),\n      optionFunction('matches'),\n      fetch,\n      onAction,\n      defaultedArrayOf('highlightOn', [], string)\n    ]);\n    const createAutocompleter = spec => asRaw('Autocompleter', autocompleterSchema, spec);\n\n    const baseToolbarButtonFields = [\n      enabled,\n      optionalTooltip,\n      optionalIcon,\n      optionalText,\n      onSetup\n    ];\n\n    const baseToolbarToggleButtonFields = [active].concat(baseToolbarButtonFields);\n\n    const contextBarFields = [\n      defaultedFunction('predicate', never),\n      defaultedStringEnum('scope', 'node', [\n        'node',\n        'editor'\n      ]),\n      defaultedStringEnum('position', 'selection', [\n        'node',\n        'selection',\n        'line'\n      ])\n    ];\n\n    const contextButtonFields = baseToolbarButtonFields.concat([\n      defaultedType('contextformbutton'),\n      primary,\n      onAction,\n      customField('original', identity)\n    ]);\n    const contextToggleButtonFields = baseToolbarToggleButtonFields.concat([\n      defaultedType('contextformbutton'),\n      primary,\n      onAction,\n      customField('original', identity)\n    ]);\n    const launchButtonFields = baseToolbarButtonFields.concat([defaultedType('contextformbutton')]);\n    const launchToggleButtonFields = baseToolbarToggleButtonFields.concat([defaultedType('contextformtogglebutton')]);\n    const toggleOrNormal = choose('type', {\n      contextformbutton: contextButtonFields,\n      contextformtogglebutton: contextToggleButtonFields\n    });\n    objOf([\n      defaultedType('contextform'),\n      defaultedFunction('initValue', constant('')),\n      optionalLabel,\n      requiredArrayOf('commands', toggleOrNormal),\n      optionOf('launch', choose('type', {\n        contextformbutton: launchButtonFields,\n        contextformtogglebutton: launchToggleButtonFields\n      }))\n    ].concat(contextBarFields));\n\n    const register$2 = editor => {\n      const popups = editor.ui.registry.getAll().popups;\n      const dataset = map$2(popups, popup => createAutocompleter(popup).fold(err => {\n        throw new Error(formatError(err));\n      }, identity));\n      const triggerChars = stringArray(mapToArray(dataset, v => v.ch));\n      const datasetValues = values(dataset);\n      const lookupByChar = ch => filter$6(datasetValues, dv => dv.ch === ch);\n      return {\n        dataset,\n        triggerChars,\n        lookupByChar\n      };\n    };\n\n    const setupEditorInput = (editor, api) => {\n      const update = last$1(api.load, 50);\n      editor.on('keypress compositionend', e => {\n        if (e.which === 27) {\n          return;\n        }\n        update.throttle();\n      });\n      editor.on('keydown', e => {\n        const keyCode = e.which;\n        if (keyCode === 8) {\n          update.throttle();\n        } else if (keyCode === 27) {\n          api.cancelIfNecessary();\n        }\n      });\n      editor.on('remove', update.cancel);\n    };\n    const setup$j = editor => {\n      const activeAutocompleter = value$2();\n      const uiActive = Cell(false);\n      const isActive = activeAutocompleter.isSet;\n      const cancelIfNecessary = () => {\n        if (isActive()) {\n          removeAutocompleterDecoration(editor);\n          fireAutocompleterEnd(editor);\n          uiActive.set(false);\n          activeAutocompleter.clear();\n        }\n      };\n      const commenceIfNecessary = context => {\n        if (!isActive()) {\n          addAutocompleterDecoration(editor, context.range);\n          activeAutocompleter.set({\n            triggerChar: context.triggerChar,\n            matchLength: context.text.length\n          });\n        }\n      };\n      const getAutocompleters = cached(() => register$2(editor));\n      const doLookup = fetchOptions => activeAutocompleter.get().map(ac => getContext(editor.dom, editor.selection.getRng(), ac.triggerChar).bind(newContext => lookupWithContext(editor, getAutocompleters, newContext, fetchOptions))).getOrThunk(() => lookup(editor, getAutocompleters));\n      const load = fetchOptions => {\n        doLookup(fetchOptions).fold(cancelIfNecessary, lookupInfo => {\n          commenceIfNecessary(lookupInfo.context);\n          lookupInfo.lookupData.then(lookupData => {\n            activeAutocompleter.get().map(ac => {\n              const context = lookupInfo.context;\n              if (ac.triggerChar === context.triggerChar) {\n                if (context.text.length - ac.matchLength >= 10) {\n                  cancelIfNecessary();\n                } else {\n                  activeAutocompleter.set({\n                    ...ac,\n                    matchLength: context.text.length\n                  });\n                  if (uiActive.get()) {\n                    fireAutocompleterUpdate(editor, { lookupData });\n                  } else {\n                    uiActive.set(true);\n                    fireAutocompleterStart(editor, { lookupData });\n                  }\n                }\n              }\n            });\n          });\n        });\n      };\n      editor.addCommand('mceAutocompleterReload', (_ui, value) => {\n        const fetchOptions = isObject(value) ? value.fetchOptions : {};\n        load(fetchOptions);\n      });\n      editor.addCommand('mceAutocompleterClose', cancelIfNecessary);\n      setupEditorInput(editor, {\n        cancelIfNecessary,\n        load\n      });\n    };\n\n    const createAndFireInputEvent = eventType => (editor, inputType, specifics = {}) => {\n      const target = editor.getBody();\n      const overrides = {\n        bubbles: true,\n        composed: true,\n        data: null,\n        isComposing: false,\n        detail: 0,\n        view: null,\n        target,\n        currentTarget: target,\n        eventPhase: Event.AT_TARGET,\n        originalTarget: target,\n        explicitOriginalTarget: target,\n        isTrusted: false,\n        srcElement: target,\n        cancelable: false,\n        preventDefault: noop,\n        inputType\n      };\n      const input = clone$3(new InputEvent(eventType));\n      return editor.dispatch(eventType, {\n        ...input,\n        ...overrides,\n        ...specifics\n      });\n    };\n    const fireFakeInputEvent = createAndFireInputEvent('input');\n    const fireFakeBeforeInputEvent = createAndFireInputEvent('beforeinput');\n\n    const executeKeydownOverride$3 = (editor, caret, evt) => {\n      const inputType = evt.keyCode === VK.BACKSPACE ? 'deleteContentBackward' : 'deleteContentForward';\n      executeWithDelayedAction([\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete, editor)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$5, editor, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$5, editor, true)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$6, editor, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$6, editor, true)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$3, editor, caret, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$3, editor, caret, true)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$9, editor, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$9, editor, true)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$4, editor, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$4, editor, true)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$1, editor, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$1, editor, true)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$7, editor, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$7, editor, true)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$8, editor, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$8, editor, true)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$2, editor, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$2, editor, true)\n        }\n      ], evt).each(applyAction => {\n        evt.preventDefault();\n        const beforeInput = fireFakeBeforeInputEvent(editor, inputType);\n        if (!beforeInput.isDefaultPrevented()) {\n          applyAction();\n          fireFakeInputEvent(editor, inputType);\n        }\n      });\n    };\n    const executeKeyupOverride = (editor, evt) => {\n      execute([\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(paddEmptyElement, editor)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(paddEmptyElement, editor)\n        }\n      ], evt);\n    };\n    const setup$i = (editor, caret) => {\n      editor.on('keydown', evt => {\n        if (evt.isDefaultPrevented() === false) {\n          executeKeydownOverride$3(editor, caret, evt);\n        }\n      });\n      editor.on('keyup', evt => {\n        if (evt.isDefaultPrevented() === false) {\n          executeKeyupOverride(editor, evt);\n        }\n      });\n    };\n\n    const firstNonWhiteSpaceNodeSibling = node => {\n      while (node) {\n        if (node.nodeType === 1 || node.nodeType === 3 && node.data && /[\\r\\n\\s]/.test(node.data)) {\n          return node;\n        }\n        node = node.nextSibling;\n      }\n    };\n    const moveToCaretPosition = (editor, root) => {\n      let node, lastNode = root;\n      const dom = editor.dom;\n      const moveCaretBeforeOnEnterElementsMap = editor.schema.getMoveCaretBeforeOnEnterElements();\n      if (!root) {\n        return;\n      }\n      if (/^(LI|DT|DD)$/.test(root.nodeName)) {\n        const firstChild = firstNonWhiteSpaceNodeSibling(root.firstChild);\n        if (firstChild && /^(UL|OL|DL)$/.test(firstChild.nodeName)) {\n          root.insertBefore(dom.doc.createTextNode(nbsp), root.firstChild);\n        }\n      }\n      const rng = dom.createRng();\n      root.normalize();\n      if (root.hasChildNodes()) {\n        const walker = new DomTreeWalker(root, root);\n        while (node = walker.current()) {\n          if (isText$8(node)) {\n            rng.setStart(node, 0);\n            rng.setEnd(node, 0);\n            break;\n          }\n          if (moveCaretBeforeOnEnterElementsMap[node.nodeName.toLowerCase()]) {\n            rng.setStartBefore(node);\n            rng.setEndBefore(node);\n            break;\n          }\n          lastNode = node;\n          node = walker.next();\n        }\n        if (!node) {\n          rng.setStart(lastNode, 0);\n          rng.setEnd(lastNode, 0);\n        }\n      } else {\n        if (isBr$5(root)) {\n          if (root.nextSibling && dom.isBlock(root.nextSibling)) {\n            rng.setStartBefore(root);\n            rng.setEndBefore(root);\n          } else {\n            rng.setStartAfter(root);\n            rng.setEndAfter(root);\n          }\n        } else {\n          rng.setStart(root, 0);\n          rng.setEnd(root, 0);\n        }\n      }\n      editor.selection.setRng(rng);\n      scrollRangeIntoView(editor, rng);\n    };\n    const getEditableRoot$1 = (dom, node) => {\n      const root = dom.getRoot();\n      let parent, editableRoot;\n      parent = node;\n      while (parent !== root && dom.getContentEditable(parent) !== 'false') {\n        if (dom.getContentEditable(parent) === 'true') {\n          editableRoot = parent;\n        }\n        parent = parent.parentNode;\n      }\n      return parent !== root ? editableRoot : root;\n    };\n    const getParentBlock$1 = editor => {\n      return Optional.from(editor.dom.getParent(editor.selection.getStart(true), editor.dom.isBlock));\n    };\n    const getParentBlockName = editor => {\n      return getParentBlock$1(editor).fold(constant(''), parentBlock => {\n        return parentBlock.nodeName.toUpperCase();\n      });\n    };\n    const isListItemParentBlock = editor => {\n      return getParentBlock$1(editor).filter(elm => {\n        return isListItem(SugarElement.fromDom(elm));\n      }).isSome();\n    };\n\n    const hasFirstChild = (elm, name) => {\n      return elm.firstChild && elm.firstChild.nodeName === name;\n    };\n    const isFirstChild = elm => {\n      var _a;\n      return ((_a = elm.parentNode) === null || _a === void 0 ? void 0 : _a.firstChild) === elm;\n    };\n    const hasParent = (elm, parentName) => {\n      return elm && elm.parentNode && elm.parentNode.nodeName === parentName;\n    };\n    const isListBlock = elm => {\n      return elm && /^(OL|UL|LI)$/.test(elm.nodeName);\n    };\n    const isNestedList = elm => {\n      return isListBlock(elm) && isListBlock(elm.parentNode);\n    };\n    const getContainerBlock = containerBlock => {\n      const containerBlockParent = containerBlock.parentNode;\n      if (/^(LI|DT|DD)$/.test(containerBlockParent.nodeName)) {\n        return containerBlockParent;\n      }\n      return containerBlock;\n    };\n    const isFirstOrLastLi = (containerBlock, parentBlock, first) => {\n      let node = containerBlock[first ? 'firstChild' : 'lastChild'];\n      while (node) {\n        if (isElement$6(node)) {\n          break;\n        }\n        node = node[first ? 'nextSibling' : 'previousSibling'];\n      }\n      return node === parentBlock;\n    };\n    const insert$3 = (editor, createNewBlock, containerBlock, parentBlock, newBlockName) => {\n      const dom = editor.dom;\n      const rng = editor.selection.getRng();\n      if (containerBlock === editor.getBody()) {\n        return;\n      }\n      if (isNestedList(containerBlock)) {\n        newBlockName = 'LI';\n      }\n      let newBlock = createNewBlock(newBlockName);\n      if (isFirstOrLastLi(containerBlock, parentBlock, true) && isFirstOrLastLi(containerBlock, parentBlock, false)) {\n        if (hasParent(containerBlock, 'LI')) {\n          const containerBlockParent = getContainerBlock(containerBlock);\n          dom.insertAfter(newBlock, containerBlockParent);\n          if (isFirstChild(containerBlock)) {\n            dom.remove(containerBlockParent);\n          } else {\n            dom.remove(containerBlock);\n          }\n        } else {\n          dom.replace(newBlock, containerBlock);\n        }\n      } else if (isFirstOrLastLi(containerBlock, parentBlock, true)) {\n        if (hasParent(containerBlock, 'LI')) {\n          dom.insertAfter(newBlock, getContainerBlock(containerBlock));\n          newBlock.appendChild(dom.doc.createTextNode(' '));\n          newBlock.appendChild(containerBlock);\n        } else {\n          containerBlock.parentNode.insertBefore(newBlock, containerBlock);\n        }\n        dom.remove(parentBlock);\n      } else if (isFirstOrLastLi(containerBlock, parentBlock, false)) {\n        dom.insertAfter(newBlock, getContainerBlock(containerBlock));\n        dom.remove(parentBlock);\n      } else {\n        containerBlock = getContainerBlock(containerBlock);\n        const tmpRng = rng.cloneRange();\n        tmpRng.setStartAfter(parentBlock);\n        tmpRng.setEndAfter(containerBlock);\n        const fragment = tmpRng.extractContents();\n        if (newBlockName === 'LI' && hasFirstChild(fragment, 'LI')) {\n          newBlock = fragment.firstChild;\n          dom.insertAfter(fragment, containerBlock);\n        } else {\n          dom.insertAfter(fragment, containerBlock);\n          dom.insertAfter(newBlock, containerBlock);\n        }\n        dom.remove(parentBlock);\n      }\n      moveToCaretPosition(editor, newBlock);\n    };\n\n    const trimZwsp = fragment => {\n      each$g(descendants$1(SugarElement.fromDom(fragment), isText$9), text => {\n        const rawNode = text.dom;\n        rawNode.nodeValue = trim$1(rawNode.nodeValue);\n      });\n    };\n    const isEmptyAnchor = (dom, elm) => {\n      return elm && elm.nodeName === 'A' && dom.isEmpty(elm);\n    };\n    const isTableCell = node => {\n      return node && /^(TD|TH|CAPTION)$/.test(node.nodeName);\n    };\n    const emptyBlock = elm => {\n      elm.innerHTML = '<br data-mce-bogus=\"1\">';\n    };\n    const containerAndSiblingName = (container, nodeName) => {\n      return container.nodeName === nodeName || container.previousSibling && container.previousSibling.nodeName === nodeName;\n    };\n    const canSplitBlock = (dom, node) => {\n      return node && dom.isBlock(node) && !/^(TD|TH|CAPTION|FORM)$/.test(node.nodeName) && !/^(fixed|absolute)/i.test(node.style.position) && dom.getContentEditable(node) !== 'true';\n    };\n    const trimInlineElementsOnLeftSideOfBlock = (dom, nonEmptyElementsMap, block) => {\n      let node = block;\n      const firstChilds = [];\n      let i;\n      if (!node) {\n        return;\n      }\n      while (node = node.firstChild) {\n        if (dom.isBlock(node)) {\n          return;\n        }\n        if (isElement$6(node) && !nonEmptyElementsMap[node.nodeName.toLowerCase()]) {\n          firstChilds.push(node);\n        }\n      }\n      i = firstChilds.length;\n      while (i--) {\n        node = firstChilds[i];\n        if (!node.hasChildNodes() || node.firstChild === node.lastChild && node.firstChild.nodeValue === '') {\n          dom.remove(node);\n        } else {\n          if (isEmptyAnchor(dom, node)) {\n            dom.remove(node);\n          }\n        }\n      }\n    };\n    const normalizeZwspOffset = (start, container, offset) => {\n      if (isText$8(container) === false) {\n        return offset;\n      } else if (start) {\n        return offset === 1 && container.data.charAt(offset - 1) === ZWSP$1 ? 0 : offset;\n      } else {\n        return offset === container.data.length - 1 && container.data.charAt(offset) === ZWSP$1 ? container.data.length : offset;\n      }\n    };\n    const includeZwspInRange = rng => {\n      const newRng = rng.cloneRange();\n      newRng.setStart(rng.startContainer, normalizeZwspOffset(true, rng.startContainer, rng.startOffset));\n      newRng.setEnd(rng.endContainer, normalizeZwspOffset(false, rng.endContainer, rng.endOffset));\n      return newRng;\n    };\n    const trimLeadingLineBreaks = node => {\n      do {\n        if (isText$8(node)) {\n          node.nodeValue = node.nodeValue.replace(/^[\\r\\n]+/, '');\n        }\n        node = node.firstChild;\n      } while (node);\n    };\n    const getEditableRoot = (dom, node) => {\n      const root = dom.getRoot();\n      let parent, editableRoot;\n      parent = node;\n      while (parent !== root && dom.getContentEditable(parent) !== 'false') {\n        if (dom.getContentEditable(parent) === 'true') {\n          editableRoot = parent;\n        }\n        parent = parent.parentNode;\n      }\n      return parent !== root ? editableRoot : root;\n    };\n    const applyAttributes = (editor, node, forcedRootBlockAttrs) => {\n      const dom = editor.dom;\n      Optional.from(forcedRootBlockAttrs.style).map(dom.parseStyle).each(attrStyles => {\n        const currentStyles = getAllRaw(SugarElement.fromDom(node));\n        const newStyles = {\n          ...currentStyles,\n          ...attrStyles\n        };\n        dom.setStyles(node, newStyles);\n      });\n      const attrClassesOpt = Optional.from(forcedRootBlockAttrs.class).map(attrClasses => attrClasses.split(/\\s+/));\n      const currentClassesOpt = Optional.from(node.className).map(currentClasses => filter$6(currentClasses.split(/\\s+/), clazz => clazz !== ''));\n      lift2(attrClassesOpt, currentClassesOpt, (attrClasses, currentClasses) => {\n        const filteredClasses = filter$6(currentClasses, clazz => !contains$2(attrClasses, clazz));\n        const newClasses = [\n          ...attrClasses,\n          ...filteredClasses\n        ];\n        dom.setAttrib(node, 'class', newClasses.join(' '));\n      });\n      const appliedAttrs = [\n        'style',\n        'class'\n      ];\n      const remainingAttrs = filter$5(forcedRootBlockAttrs, (_, attrs) => !contains$2(appliedAttrs, attrs));\n      dom.setAttribs(node, remainingAttrs);\n    };\n    const setForcedBlockAttrs = (editor, node) => {\n      const forcedRootBlockName = getForcedRootBlock(editor);\n      if (forcedRootBlockName.toLowerCase() === node.tagName.toLowerCase()) {\n        const forcedRootBlockAttrs = getForcedRootBlockAttrs(editor);\n        applyAttributes(editor, node, forcedRootBlockAttrs);\n      }\n    };\n    const wrapSelfAndSiblingsInDefaultBlock = (editor, newBlockName, rng, container, offset) => {\n      let newBlock, parentBlock, startNode, node, next, rootBlockName;\n      const dom = editor.dom, editableRoot = getEditableRoot(dom, container);\n      parentBlock = dom.getParent(container, dom.isBlock);\n      if (!parentBlock || !canSplitBlock(dom, parentBlock)) {\n        parentBlock = parentBlock || editableRoot;\n        if (parentBlock === editor.getBody() || isTableCell(parentBlock)) {\n          rootBlockName = parentBlock.nodeName.toLowerCase();\n        } else {\n          rootBlockName = parentBlock.parentNode.nodeName.toLowerCase();\n        }\n        if (!parentBlock.hasChildNodes()) {\n          newBlock = dom.create(newBlockName);\n          setForcedBlockAttrs(editor, newBlock);\n          parentBlock.appendChild(newBlock);\n          rng.setStart(newBlock, 0);\n          rng.setEnd(newBlock, 0);\n          return newBlock;\n        }\n        node = container;\n        while (node.parentNode !== parentBlock) {\n          node = node.parentNode;\n        }\n        while (node && !dom.isBlock(node)) {\n          startNode = node;\n          node = node.previousSibling;\n        }\n        if (startNode && editor.schema.isValidChild(rootBlockName, newBlockName.toLowerCase())) {\n          newBlock = dom.create(newBlockName);\n          setForcedBlockAttrs(editor, newBlock);\n          startNode.parentNode.insertBefore(newBlock, startNode);\n          node = startNode;\n          while (node && !dom.isBlock(node)) {\n            next = node.nextSibling;\n            newBlock.appendChild(node);\n            node = next;\n          }\n          rng.setStart(container, offset);\n          rng.setEnd(container, offset);\n        }\n      }\n      return container;\n    };\n    const addBrToBlockIfNeeded = (dom, block) => {\n      block.normalize();\n      const lastChild = block.lastChild;\n      if (!lastChild || /^(left|right)$/gi.test(dom.getStyle(lastChild, 'float', true))) {\n        dom.add(block, 'br');\n      }\n    };\n    const insert$2 = (editor, evt) => {\n      let tmpRng, container, offset, parentBlock;\n      let newBlock, fragment, containerBlock, parentBlockName, isAfterLastNodeInContainer;\n      const dom = editor.dom;\n      const schema = editor.schema, nonEmptyElementsMap = schema.getNonEmptyElements();\n      const rng = editor.selection.getRng();\n      const newBlockName = getForcedRootBlock(editor);\n      const createNewBlock = name => {\n        let node = container, block, clonedNode, caretNode;\n        const textInlineElements = schema.getTextInlineElements();\n        if (name || parentBlockName === 'TABLE' || parentBlockName === 'HR') {\n          block = dom.create(name || newBlockName);\n        } else {\n          block = parentBlock.cloneNode(false);\n        }\n        caretNode = block;\n        if (shouldKeepStyles(editor) === false) {\n          dom.setAttrib(block, 'style', null);\n          dom.setAttrib(block, 'class', null);\n        } else {\n          do {\n            if (textInlineElements[node.nodeName]) {\n              if (isCaretNode(node) || isBookmarkNode$1(node)) {\n                continue;\n              }\n              clonedNode = node.cloneNode(false);\n              dom.setAttrib(clonedNode, 'id', '');\n              if (block.hasChildNodes()) {\n                clonedNode.appendChild(block.firstChild);\n                block.appendChild(clonedNode);\n              } else {\n                caretNode = clonedNode;\n                block.appendChild(clonedNode);\n              }\n            }\n          } while ((node = node.parentNode) && node !== editableRoot);\n        }\n        setForcedBlockAttrs(editor, block);\n        emptyBlock(caretNode);\n        return block;\n      };\n      const isCaretAtStartOrEndOfBlock = start => {\n        let node, name;\n        const normalizedOffset = normalizeZwspOffset(start, container, offset);\n        if (isText$8(container) && (start ? normalizedOffset > 0 : normalizedOffset < container.nodeValue.length)) {\n          return false;\n        }\n        if (container.parentNode === parentBlock && isAfterLastNodeInContainer && !start) {\n          return true;\n        }\n        if (start && isElement$6(container) && container === parentBlock.firstChild) {\n          return true;\n        }\n        if (containerAndSiblingName(container, 'TABLE') || containerAndSiblingName(container, 'HR')) {\n          return isAfterLastNodeInContainer && !start || !isAfterLastNodeInContainer && start;\n        }\n        const walker = new DomTreeWalker(container, parentBlock);\n        if (isText$8(container)) {\n          if (start && normalizedOffset === 0) {\n            walker.prev();\n          } else if (!start && normalizedOffset === container.nodeValue.length) {\n            walker.next();\n          }\n        }\n        while (node = walker.current()) {\n          if (isElement$6(node)) {\n            if (!node.getAttribute('data-mce-bogus')) {\n              name = node.nodeName.toLowerCase();\n              if (nonEmptyElementsMap[name] && name !== 'br') {\n                return false;\n              }\n            }\n          } else if (isText$8(node) && !isWhitespaceText(node.nodeValue)) {\n            return false;\n          }\n          if (start) {\n            walker.prev();\n          } else {\n            walker.next();\n          }\n        }\n        return true;\n      };\n      const insertNewBlockAfter = () => {\n        if (/^(H[1-6]|PRE|FIGURE)$/.test(parentBlockName) && containerBlockName !== 'HGROUP') {\n          newBlock = createNewBlock(newBlockName);\n        } else {\n          newBlock = createNewBlock();\n        }\n        if (shouldEndContainerOnEmptyBlock(editor) && canSplitBlock(dom, containerBlock) && dom.isEmpty(parentBlock)) {\n          newBlock = dom.split(containerBlock, parentBlock);\n        } else {\n          dom.insertAfter(newBlock, parentBlock);\n        }\n        moveToCaretPosition(editor, newBlock);\n      };\n      normalize$2(dom, rng).each(normRng => {\n        rng.setStart(normRng.startContainer, normRng.startOffset);\n        rng.setEnd(normRng.endContainer, normRng.endOffset);\n      });\n      container = rng.startContainer;\n      offset = rng.startOffset;\n      const shiftKey = !!(evt && evt.shiftKey);\n      const ctrlKey = !!(evt && evt.ctrlKey);\n      if (isElement$6(container) && container.hasChildNodes()) {\n        isAfterLastNodeInContainer = offset > container.childNodes.length - 1;\n        container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;\n        if (isAfterLastNodeInContainer && isText$8(container)) {\n          offset = container.nodeValue.length;\n        } else {\n          offset = 0;\n        }\n      }\n      const editableRoot = getEditableRoot(dom, container);\n      if (!editableRoot) {\n        return;\n      }\n      if (!shiftKey) {\n        container = wrapSelfAndSiblingsInDefaultBlock(editor, newBlockName, rng, container, offset);\n      }\n      parentBlock = dom.getParent(container, dom.isBlock);\n      containerBlock = parentBlock ? dom.getParent(parentBlock.parentNode, dom.isBlock) : null;\n      parentBlockName = parentBlock ? parentBlock.nodeName.toUpperCase() : '';\n      const containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : '';\n      if (containerBlockName === 'LI' && !ctrlKey) {\n        parentBlock = containerBlock;\n        containerBlock = containerBlock.parentNode;\n        parentBlockName = containerBlockName;\n      }\n      if (/^(LI|DT|DD)$/.test(parentBlockName)) {\n        if (dom.isEmpty(parentBlock)) {\n          insert$3(editor, createNewBlock, containerBlock, parentBlock, newBlockName);\n          return;\n        }\n      }\n      if (parentBlock === editor.getBody()) {\n        return;\n      }\n      if (isCaretContainerBlock$1(parentBlock)) {\n        newBlock = showCaretContainerBlock(parentBlock);\n        if (dom.isEmpty(parentBlock)) {\n          emptyBlock(parentBlock);\n        }\n        setForcedBlockAttrs(editor, newBlock);\n        moveToCaretPosition(editor, newBlock);\n      } else if (isCaretAtStartOrEndOfBlock()) {\n        insertNewBlockAfter();\n      } else if (isCaretAtStartOrEndOfBlock(true)) {\n        newBlock = parentBlock.parentNode.insertBefore(createNewBlock(), parentBlock);\n        moveToCaretPosition(editor, containerAndSiblingName(parentBlock, 'HR') ? newBlock : parentBlock);\n      } else {\n        tmpRng = includeZwspInRange(rng).cloneRange();\n        tmpRng.setEndAfter(parentBlock);\n        fragment = tmpRng.extractContents();\n        trimZwsp(fragment);\n        trimLeadingLineBreaks(fragment);\n        newBlock = fragment.firstChild;\n        dom.insertAfter(fragment, parentBlock);\n        trimInlineElementsOnLeftSideOfBlock(dom, nonEmptyElementsMap, newBlock);\n        addBrToBlockIfNeeded(dom, parentBlock);\n        if (dom.isEmpty(parentBlock)) {\n          emptyBlock(parentBlock);\n        }\n        newBlock.normalize();\n        if (dom.isEmpty(newBlock)) {\n          dom.remove(newBlock);\n          insertNewBlockAfter();\n        } else {\n          setForcedBlockAttrs(editor, newBlock);\n          moveToCaretPosition(editor, newBlock);\n        }\n      }\n      dom.setAttrib(newBlock, 'id', '');\n      editor.dispatch('NewBlock', { newBlock });\n    };\n\n    const hasRightSideContent = (schema, container, parentBlock) => {\n      const walker = new DomTreeWalker(container, parentBlock);\n      let node;\n      const nonEmptyElementsMap = schema.getNonEmptyElements();\n      while (node = walker.next()) {\n        if (nonEmptyElementsMap[node.nodeName.toLowerCase()] || node.length > 0) {\n          return true;\n        }\n      }\n    };\n    const moveSelectionToBr = (editor, brElm, extraBr) => {\n      const rng = editor.dom.createRng();\n      if (!extraBr) {\n        rng.setStartAfter(brElm);\n        rng.setEndAfter(brElm);\n      } else {\n        rng.setStartBefore(brElm);\n        rng.setEndBefore(brElm);\n      }\n      editor.selection.setRng(rng);\n      scrollRangeIntoView(editor, rng);\n    };\n    const insertBrAtCaret = (editor, evt) => {\n      const selection = editor.selection;\n      const dom = editor.dom;\n      const rng = selection.getRng();\n      let brElm;\n      let extraBr;\n      normalize$2(dom, rng).each(normRng => {\n        rng.setStart(normRng.startContainer, normRng.startOffset);\n        rng.setEnd(normRng.endContainer, normRng.endOffset);\n      });\n      let offset = rng.startOffset;\n      let container = rng.startContainer;\n      if (container.nodeType === 1 && container.hasChildNodes()) {\n        const isAfterLastNodeInContainer = offset > container.childNodes.length - 1;\n        container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;\n        if (isAfterLastNodeInContainer && container.nodeType === 3) {\n          offset = container.nodeValue.length;\n        } else {\n          offset = 0;\n        }\n      }\n      let parentBlock = dom.getParent(container, dom.isBlock);\n      const containerBlock = parentBlock ? dom.getParent(parentBlock.parentNode, dom.isBlock) : null;\n      const containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : '';\n      const isControlKey = !!(evt && evt.ctrlKey);\n      if (containerBlockName === 'LI' && !isControlKey) {\n        parentBlock = containerBlock;\n      }\n      if (container && container.nodeType === 3 && offset >= container.nodeValue.length) {\n        if (!hasRightSideContent(editor.schema, container, parentBlock)) {\n          brElm = dom.create('br');\n          rng.insertNode(brElm);\n          rng.setStartAfter(brElm);\n          rng.setEndAfter(brElm);\n          extraBr = true;\n        }\n      }\n      brElm = dom.create('br');\n      rangeInsertNode(dom, rng, brElm);\n      moveSelectionToBr(editor, brElm, extraBr);\n      editor.undoManager.add();\n    };\n    const insertBrBefore = (editor, inline) => {\n      const br = SugarElement.fromTag('br');\n      before$3(SugarElement.fromDom(inline), br);\n      editor.undoManager.add();\n    };\n    const insertBrAfter = (editor, inline) => {\n      if (!hasBrAfter(editor.getBody(), inline)) {\n        after$4(SugarElement.fromDom(inline), SugarElement.fromTag('br'));\n      }\n      const br = SugarElement.fromTag('br');\n      after$4(SugarElement.fromDom(inline), br);\n      moveSelectionToBr(editor, br.dom, false);\n      editor.undoManager.add();\n    };\n    const isBeforeBr = pos => {\n      return isBr$5(pos.getNode());\n    };\n    const hasBrAfter = (rootNode, startNode) => {\n      if (isBeforeBr(CaretPosition.after(startNode))) {\n        return true;\n      } else {\n        return nextPosition(rootNode, CaretPosition.after(startNode)).map(pos => {\n          return isBr$5(pos.getNode());\n        }).getOr(false);\n      }\n    };\n    const isAnchorLink = elm => {\n      return elm && elm.nodeName === 'A' && 'href' in elm;\n    };\n    const isInsideAnchor = location => {\n      return location.fold(never, isAnchorLink, isAnchorLink, never);\n    };\n    const readInlineAnchorLocation = editor => {\n      const isInlineTarget$1 = curry(isInlineTarget, editor);\n      const position = CaretPosition.fromRangeStart(editor.selection.getRng());\n      return readLocation(isInlineTarget$1, editor.getBody(), position).filter(isInsideAnchor);\n    };\n    const insertBrOutsideAnchor = (editor, location) => {\n      location.fold(noop, curry(insertBrBefore, editor), curry(insertBrAfter, editor), noop);\n    };\n    const insert$1 = (editor, evt) => {\n      const anchorLocation = readInlineAnchorLocation(editor);\n      if (anchorLocation.isSome()) {\n        anchorLocation.each(curry(insertBrOutsideAnchor, editor));\n      } else {\n        insertBrAtCaret(editor, evt);\n      }\n    };\n\n    const matchesSelector = (editor, selector) => {\n      return getParentBlock$1(editor).filter(parentBlock => {\n        return selector.length > 0 && is$1(SugarElement.fromDom(parentBlock), selector);\n      }).isSome();\n    };\n    const shouldInsertBr = editor => {\n      return matchesSelector(editor, getBrNewLineSelector(editor));\n    };\n    const shouldBlockNewLine$1 = editor => {\n      return matchesSelector(editor, getNoNewLineSelector(editor));\n    };\n\n    const newLineAction = Adt.generate([\n      { br: [] },\n      { block: [] },\n      { none: [] }\n    ]);\n    const shouldBlockNewLine = (editor, _shiftKey) => {\n      return shouldBlockNewLine$1(editor);\n    };\n    const inListBlock = requiredState => {\n      return (editor, _shiftKey) => {\n        return isListItemParentBlock(editor) === requiredState;\n      };\n    };\n    const inBlock = (blockName, requiredState) => (editor, _shiftKey) => {\n      const state = getParentBlockName(editor) === blockName.toUpperCase();\n      return state === requiredState;\n    };\n    const inPreBlock = requiredState => inBlock('pre', requiredState);\n    const inSummaryBlock = () => inBlock('summary', true);\n    const shouldPutBrInPre = requiredState => {\n      return (editor, _shiftKey) => {\n        return shouldPutBrInPre$1(editor) === requiredState;\n      };\n    };\n    const inBrContext = (editor, _shiftKey) => {\n      return shouldInsertBr(editor);\n    };\n    const hasShiftKey = (_editor, shiftKey) => {\n      return shiftKey;\n    };\n    const canInsertIntoEditableRoot = editor => {\n      const forcedRootBlock = getForcedRootBlock(editor);\n      const rootEditable = getEditableRoot$1(editor.dom, editor.selection.getStart());\n      return rootEditable && editor.schema.isValidChild(rootEditable.nodeName, forcedRootBlock);\n    };\n    const match = (predicates, action) => {\n      return (editor, shiftKey) => {\n        const isMatch = foldl(predicates, (res, p) => {\n          return res && p(editor, shiftKey);\n        }, true);\n        return isMatch ? Optional.some(action) : Optional.none();\n      };\n    };\n    const getAction = (editor, evt) => {\n      return evaluateUntil([\n        match([shouldBlockNewLine], newLineAction.none()),\n        match([inSummaryBlock()], newLineAction.br()),\n        match([\n          inPreBlock(true),\n          shouldPutBrInPre(false),\n          hasShiftKey\n        ], newLineAction.br()),\n        match([\n          inPreBlock(true),\n          shouldPutBrInPre(false)\n        ], newLineAction.block()),\n        match([\n          inPreBlock(true),\n          shouldPutBrInPre(true),\n          hasShiftKey\n        ], newLineAction.block()),\n        match([\n          inPreBlock(true),\n          shouldPutBrInPre(true)\n        ], newLineAction.br()),\n        match([\n          inListBlock(true),\n          hasShiftKey\n        ], newLineAction.br()),\n        match([inListBlock(true)], newLineAction.block()),\n        match([inBrContext], newLineAction.br()),\n        match([hasShiftKey], newLineAction.br()),\n        match([canInsertIntoEditableRoot], newLineAction.block())\n      ], [\n        editor,\n        !!(evt && evt.shiftKey)\n      ]).getOr(newLineAction.none());\n    };\n\n    const insert = (editor, evt) => {\n      getAction(editor, evt).fold(() => {\n        if (isNonNullable(evt)) {\n          const event = fireFakeBeforeInputEvent(editor, 'insertLineBreak');\n          if (event.isDefaultPrevented()) {\n            return;\n          }\n        }\n        insert$1(editor, evt);\n        if (isNonNullable(evt)) {\n          fireFakeInputEvent(editor, 'insertLineBreak');\n        }\n      }, () => {\n        if (isNonNullable(evt)) {\n          const event = fireFakeBeforeInputEvent(editor, 'insertParagraph');\n          if (event.isDefaultPrevented()) {\n            return;\n          }\n        }\n        insert$2(editor, evt);\n        if (isNonNullable(evt)) {\n          fireFakeInputEvent(editor, 'insertParagraph');\n        }\n      }, noop);\n    };\n\n    const handleEnterKeyEvent = (editor, event) => {\n      if (event.isDefaultPrevented()) {\n        return;\n      }\n      event.preventDefault();\n      endTypingLevelIgnoreLocks(editor.undoManager);\n      editor.undoManager.transact(() => {\n        if (editor.selection.isCollapsed() === false) {\n          execDeleteCommand(editor);\n        }\n        insert(editor, event);\n      });\n    };\n    const setup$h = editor => {\n      editor.on('keydown', event => {\n        if (event.keyCode === VK.ENTER) {\n          handleEnterKeyEvent(editor, event);\n        }\n      });\n    };\n\n    const executeKeydownOverride$2 = (editor, caret, evt) => {\n      execute([\n        {\n          keyCode: VK.END,\n          action: action(moveToLineEndPoint$1, editor, true)\n        },\n        {\n          keyCode: VK.HOME,\n          action: action(moveToLineEndPoint$1, editor, false)\n        },\n        {\n          keyCode: VK.END,\n          action: action(moveToLineEndPoint, editor, true)\n        },\n        {\n          keyCode: VK.HOME,\n          action: action(moveToLineEndPoint, editor, false)\n        },\n        {\n          keyCode: VK.END,\n          action: action(moveToLineEndPoint$2, editor, true, caret)\n        },\n        {\n          keyCode: VK.HOME,\n          action: action(moveToLineEndPoint$2, editor, false, caret)\n        }\n      ], evt).each(_ => {\n        evt.preventDefault();\n      });\n    };\n    const setup$g = (editor, caret) => {\n      editor.on('keydown', evt => {\n        if (evt.isDefaultPrevented() === false) {\n          executeKeydownOverride$2(editor, caret, evt);\n        }\n      });\n    };\n\n    const setup$f = editor => {\n      editor.on('input', e => {\n        if (e.isComposing === false) {\n          normalizeNbspsInEditor(editor);\n        }\n      });\n    };\n\n    const platform = detect$2();\n    const executeKeyupAction = (editor, caret, evt) => {\n      execute([\n        {\n          keyCode: VK.PAGE_UP,\n          action: action(moveToLineEndPoint$2, editor, false, caret)\n        },\n        {\n          keyCode: VK.PAGE_DOWN,\n          action: action(moveToLineEndPoint$2, editor, true, caret)\n        }\n      ], evt);\n    };\n    const stopImmediatePropagation = e => e.stopImmediatePropagation();\n    const isPageUpDown = evt => evt.keyCode === VK.PAGE_UP || evt.keyCode === VK.PAGE_DOWN;\n    const setNodeChangeBlocker = (blocked, editor, block) => {\n      if (block && !blocked.get()) {\n        editor.on('NodeChange', stopImmediatePropagation, true);\n      } else if (!block && blocked.get()) {\n        editor.off('NodeChange', stopImmediatePropagation);\n      }\n      blocked.set(block);\n    };\n    const setup$e = (editor, caret) => {\n      if (platform.os.isMacOS()) {\n        return;\n      }\n      const blocked = Cell(false);\n      editor.on('keydown', evt => {\n        if (isPageUpDown(evt)) {\n          setNodeChangeBlocker(blocked, editor, true);\n        }\n      });\n      editor.on('keyup', evt => {\n        if (evt.isDefaultPrevented() === false) {\n          executeKeyupAction(editor, caret, evt);\n        }\n        if (isPageUpDown(evt) && blocked.get()) {\n          setNodeChangeBlocker(blocked, editor, false);\n          editor.nodeChanged();\n        }\n      });\n    };\n\n    const insertTextAtPosition = (text, pos) => {\n      const container = pos.container();\n      const offset = pos.offset();\n      if (isText$8(container)) {\n        container.insertData(offset, text);\n        return Optional.some(CaretPosition(container, offset + text.length));\n      } else {\n        return getElementFromPosition(pos).map(elm => {\n          const textNode = SugarElement.fromText(text);\n          if (pos.isAtEnd()) {\n            after$4(elm, textNode);\n          } else {\n            before$3(elm, textNode);\n          }\n          return CaretPosition(textNode.dom, text.length);\n        });\n      }\n    };\n    const insertNbspAtPosition = curry(insertTextAtPosition, nbsp);\n    const insertSpaceAtPosition = curry(insertTextAtPosition, ' ');\n\n    const locationToCaretPosition = root => location => location.fold(element => prevPosition(root.dom, CaretPosition.before(element)), element => firstPositionIn(element), element => lastPositionIn(element), element => nextPosition(root.dom, CaretPosition.after(element)));\n    const insertInlineBoundarySpaceOrNbsp = (root, pos) => checkPos => needsToHaveNbsp(root, checkPos) ? insertNbspAtPosition(pos) : insertSpaceAtPosition(pos);\n    const setSelection = editor => pos => {\n      editor.selection.setRng(pos.toRange());\n      editor.nodeChanged();\n      return true;\n    };\n    const insertSpaceOrNbspAtSelection = editor => {\n      const pos = CaretPosition.fromRangeStart(editor.selection.getRng());\n      const root = SugarElement.fromDom(editor.getBody());\n      if (editor.selection.isCollapsed()) {\n        const isInlineTarget$1 = curry(isInlineTarget, editor);\n        const caretPosition = CaretPosition.fromRangeStart(editor.selection.getRng());\n        return readLocation(isInlineTarget$1, editor.getBody(), caretPosition).bind(locationToCaretPosition(root)).map(checkPos => () => insertInlineBoundarySpaceOrNbsp(root, pos)(checkPos).each(setSelection(editor)));\n      } else {\n        return Optional.none();\n      }\n    };\n\n    const executeKeydownOverride$1 = (editor, evt) => {\n      executeWithDelayedAction([{\n          keyCode: VK.SPACEBAR,\n          action: action(insertSpaceOrNbspAtSelection, editor)\n        }], evt).each(applyAction => {\n        evt.preventDefault();\n        const event = fireFakeBeforeInputEvent(editor, 'insertText', { data: ' ' });\n        if (!event.isDefaultPrevented()) {\n          applyAction();\n          fireFakeInputEvent(editor, 'insertText', { data: ' ' });\n        }\n      });\n    };\n    const setup$d = editor => {\n      editor.on('keydown', evt => {\n        if (evt.isDefaultPrevented() === false) {\n          executeKeydownOverride$1(editor, evt);\n        }\n      });\n    };\n\n    const tableTabNavigation = editor => {\n      if (hasTableTabNavigation(editor)) {\n        return [\n          {\n            keyCode: VK.TAB,\n            action: action(handleTab, editor, true)\n          },\n          {\n            keyCode: VK.TAB,\n            shiftKey: true,\n            action: action(handleTab, editor, false)\n          }\n        ];\n      } else {\n        return [];\n      }\n    };\n    const executeKeydownOverride = (editor, evt) => {\n      execute([...tableTabNavigation(editor)], evt).each(_ => {\n        evt.preventDefault();\n      });\n    };\n    const setup$c = editor => {\n      editor.on('keydown', evt => {\n        if (evt.isDefaultPrevented() === false) {\n          executeKeydownOverride(editor, evt);\n        }\n      });\n    };\n\n    const setup$b = editor => {\n      editor.addShortcut('Meta+P', '', 'mcePrint');\n      setup$j(editor);\n      if (isRtc(editor)) {\n        return Cell(null);\n      } else {\n        const caret = setupSelectedState(editor);\n        setup$l(editor);\n        setup$k(editor, caret);\n        setup$i(editor, caret);\n        setup$h(editor);\n        setup$d(editor);\n        setup$f(editor);\n        setup$c(editor);\n        setup$g(editor, caret);\n        setup$e(editor, caret);\n        return caret;\n      }\n    };\n\n    class NodeChange {\n      constructor(editor) {\n        this.lastPath = [];\n        this.editor = editor;\n        let lastRng;\n        const self = this;\n        if (!('onselectionchange' in editor.getDoc())) {\n          editor.on('NodeChange click mouseup keyup focus', e => {\n            const nativeRng = editor.selection.getRng();\n            const fakeRng = {\n              startContainer: nativeRng.startContainer,\n              startOffset: nativeRng.startOffset,\n              endContainer: nativeRng.endContainer,\n              endOffset: nativeRng.endOffset\n            };\n            if (e.type === 'nodechange' || !isEq$4(fakeRng, lastRng)) {\n              editor.dispatch('SelectionChange');\n            }\n            lastRng = fakeRng;\n          });\n        }\n        editor.on('contextmenu', () => {\n          editor.dispatch('SelectionChange');\n        });\n        editor.on('SelectionChange', () => {\n          const startElm = editor.selection.getStart(true);\n          if (!startElm) {\n            return;\n          }\n          if (hasAnyRanges(editor) && !self.isSameElementPath(startElm) && editor.dom.isChildOf(startElm, editor.getBody())) {\n            editor.nodeChanged({ selectionChange: true });\n          }\n        });\n        editor.on('mouseup', e => {\n          if (!e.isDefaultPrevented() && hasAnyRanges(editor)) {\n            if (editor.selection.getNode().nodeName === 'IMG') {\n              Delay.setEditorTimeout(editor, () => {\n                editor.nodeChanged();\n              });\n            } else {\n              editor.nodeChanged();\n            }\n          }\n        });\n      }\n      nodeChanged(args) {\n        const selection = this.editor.selection;\n        let node, parents, root;\n        if (this.editor.initialized && selection && !shouldDisableNodeChange(this.editor) && !this.editor.mode.isReadOnly()) {\n          root = this.editor.getBody();\n          node = selection.getStart(true) || root;\n          if (node.ownerDocument !== this.editor.getDoc() || !this.editor.dom.isChildOf(node, root)) {\n            node = root;\n          }\n          parents = [];\n          this.editor.dom.getParent(node, node => {\n            if (node === root) {\n              return true;\n            }\n            parents.push(node);\n          });\n          args = args || {};\n          args.element = node;\n          args.parents = parents;\n          this.editor.dispatch('NodeChange', args);\n        }\n      }\n      isSameElementPath(startElm) {\n        let i;\n        const editor = this.editor;\n        const currentPath = reverse(editor.dom.getParents(startElm, always, editor.getBody()));\n        if (currentPath.length === this.lastPath.length) {\n          for (i = currentPath.length; i >= 0; i--) {\n            if (currentPath[i] !== this.lastPath[i]) {\n              break;\n            }\n          }\n          if (i === -1) {\n            this.lastPath = currentPath;\n            return true;\n          }\n        }\n        this.lastPath = currentPath;\n        return false;\n      }\n    }\n\n    const internalMimeType = 'x-tinymce/html';\n    const internalHtmlMime = constant(internalMimeType);\n    const internalMark = '<!-- ' + internalMimeType + ' -->';\n    const mark = html => internalMark + html;\n    const unmark = html => html.replace(internalMark, '');\n    const isMarked = html => html.indexOf(internalMark) !== -1;\n\n    const isPlainText = text => {\n      return !/<(?:\\/?(?!(?:div|p|br|span)>)\\w+|(?:(?!(?:span style=\"white-space:\\s?pre;?\">)|br\\s?\\/>))\\w+\\s[^>]+)>/i.test(text);\n    };\n    const openContainer = (rootTag, rootAttrs) => {\n      let tag = '<' + rootTag;\n      const attrs = mapToArray(rootAttrs, (value, key) => key + '=\"' + Entities.encodeAllRaw(value) + '\"');\n      if (attrs.length) {\n        tag += ' ' + attrs.join(' ');\n      }\n      return tag + '>';\n    };\n    const toBlockElements = (text, rootTag, rootAttrs) => {\n      const blocks = text.split(/\\n\\n/);\n      const tagOpen = openContainer(rootTag, rootAttrs);\n      const tagClose = '</' + rootTag + '>';\n      const paragraphs = map$3(blocks, p => {\n        return p.split(/\\n/).join('<br />');\n      });\n      const stitch = p => {\n        return tagOpen + p + tagClose;\n      };\n      return paragraphs.length === 1 ? paragraphs[0] : map$3(paragraphs, stitch).join('');\n    };\n\n    const pasteBinDefaultContent = '%MCEPASTEBIN%';\n    const create$6 = (editor, lastRngCell) => {\n      const {dom, selection} = editor;\n      const body = editor.getBody();\n      lastRngCell.set(selection.getRng());\n      const pasteBinElm = dom.add(editor.getBody(), 'div', {\n        'id': 'mcepastebin',\n        'class': 'mce-pastebin',\n        'contentEditable': true,\n        'data-mce-bogus': 'all',\n        'style': 'position: fixed; top: 50%; width: 10px; height: 10px; overflow: hidden; opacity: 0'\n      }, pasteBinDefaultContent);\n      if (Env.browser.isFirefox()) {\n        dom.setStyle(pasteBinElm, 'left', dom.getStyle(body, 'direction', true) === 'rtl' ? 65535 : -65535);\n      }\n      dom.bind(pasteBinElm, 'beforedeactivate focusin focusout', e => {\n        e.stopPropagation();\n      });\n      pasteBinElm.focus();\n      selection.select(pasteBinElm, true);\n    };\n    const remove = (editor, lastRngCell) => {\n      const dom = editor.dom;\n      if (getEl(editor)) {\n        let pasteBinClone;\n        const lastRng = lastRngCell.get();\n        while (pasteBinClone = getEl(editor)) {\n          dom.remove(pasteBinClone);\n          dom.unbind(pasteBinClone);\n        }\n        if (lastRng) {\n          editor.selection.setRng(lastRng);\n        }\n      }\n      lastRngCell.set(null);\n    };\n    const getEl = editor => editor.dom.get('mcepastebin');\n    const isPasteBin = elm => elm && elm.id === 'mcepastebin';\n    const getHtml = editor => {\n      const dom = editor.dom;\n      const copyAndRemove = (toElm, fromElm) => {\n        toElm.appendChild(fromElm);\n        dom.remove(fromElm, true);\n      };\n      const [pasteBinElm, ...pasteBinClones] = filter$6(editor.getBody().childNodes, isPasteBin);\n      each$g(pasteBinClones, pasteBinClone => {\n        copyAndRemove(pasteBinElm, pasteBinClone);\n      });\n      const dirtyWrappers = dom.select('div[id=mcepastebin]', pasteBinElm);\n      for (let i = dirtyWrappers.length - 1; i >= 0; i--) {\n        const cleanWrapper = dom.create('div');\n        pasteBinElm.insertBefore(cleanWrapper, dirtyWrappers[i]);\n        copyAndRemove(cleanWrapper, dirtyWrappers[i]);\n      }\n      return pasteBinElm ? pasteBinElm.innerHTML : '';\n    };\n    const isDefaultPasteBinContent = content => content === pasteBinDefaultContent;\n    const PasteBin = editor => {\n      const lastRng = Cell(null);\n      return {\n        create: () => create$6(editor, lastRng),\n        remove: () => remove(editor, lastRng),\n        getEl: () => getEl(editor),\n        getHtml: () => getHtml(editor),\n        getLastRng: lastRng.get\n      };\n    };\n\n    const filter = (content, items) => {\n      Tools.each(items, v => {\n        if (is$4(v, RegExp)) {\n          content = content.replace(v, '');\n        } else {\n          content = content.replace(v[0], v[1]);\n        }\n      });\n      return content;\n    };\n    const innerText = html => {\n      const schema = Schema();\n      const domParser = DomParser({}, schema);\n      let text = '';\n      const voidElements = schema.getVoidElements();\n      const ignoreElements = Tools.makeMap('script noscript style textarea video audio iframe object', ' ');\n      const blockElements = schema.getBlockElements();\n      const walk = node => {\n        const name = node.name, currentNode = node;\n        if (name === 'br') {\n          text += '\\n';\n          return;\n        }\n        if (name === 'wbr') {\n          return;\n        }\n        if (voidElements[name]) {\n          text += ' ';\n        }\n        if (ignoreElements[name]) {\n          text += ' ';\n          return;\n        }\n        if (node.type === 3) {\n          text += node.value;\n        }\n        if (!(node.name in schema.getVoidElements())) {\n          if (node = node.firstChild) {\n            do {\n              walk(node);\n            } while (node = node.next);\n          }\n        }\n        if (blockElements[name] && currentNode.next) {\n          text += '\\n';\n          if (name === 'p') {\n            text += '\\n';\n          }\n        }\n      };\n      html = filter(html, [/<!\\[[^\\]]+\\]>/g]);\n      walk(domParser.parse(html));\n      return text;\n    };\n    const trimHtml = html => {\n      const trimSpaces = (all, s1, s2) => {\n        if (!s1 && !s2) {\n          return ' ';\n        }\n        return nbsp;\n      };\n      html = filter(html, [\n        /^[\\s\\S]*<body[^>]*>\\s*|\\s*<\\/body[^>]*>[\\s\\S]*$/ig,\n        /<!--StartFragment-->|<!--EndFragment-->/g,\n        [\n          /( ?)<span class=\"Apple-converted-space\">\\u00a0<\\/span>( ?)/g,\n          trimSpaces\n        ],\n        /<br class=\"Apple-interchange-newline\">/g,\n        /<br>$/i\n      ]);\n      return html;\n    };\n    const createIdGenerator = prefix => {\n      let count = 0;\n      return () => {\n        return prefix + count++;\n      };\n    };\n    const getImageMimeType = ext => {\n      const lowerExt = ext.toLowerCase();\n      const mimeOverrides = {\n        jpg: 'jpeg',\n        jpe: 'jpeg',\n        jfi: 'jpeg',\n        jif: 'jpeg',\n        jfif: 'jpeg',\n        pjpeg: 'jpeg',\n        pjp: 'jpeg',\n        svg: 'svg+xml'\n      };\n      return Tools.hasOwn(mimeOverrides, lowerExt) ? 'image/' + mimeOverrides[lowerExt] : 'image/' + lowerExt;\n    };\n\n    const preProcess = (editor, html) => {\n      const parser = DomParser({}, editor.schema);\n      parser.addNodeFilter('meta', nodes => {\n        Tools.each(nodes, node => {\n          node.remove();\n        });\n      });\n      const fragment = parser.parse(html, {\n        forced_root_block: false,\n        isRootContent: true\n      });\n      return HtmlSerializer({ validate: true }, editor.schema).serialize(fragment);\n    };\n    const processResult = (content, cancelled) => ({\n      content,\n      cancelled\n    });\n    const postProcessFilter = (editor, html, internal) => {\n      const tempBody = editor.dom.create('div', { style: 'display:none' }, html);\n      const postProcessArgs = firePastePostProcess(editor, tempBody, internal);\n      return processResult(postProcessArgs.node.innerHTML, postProcessArgs.isDefaultPrevented());\n    };\n    const filterContent = (editor, content, internal) => {\n      const preProcessArgs = firePastePreProcess(editor, content, internal);\n      const filteredContent = preProcess(editor, preProcessArgs.content);\n      if (editor.hasEventListeners('PastePostProcess') && !preProcessArgs.isDefaultPrevented()) {\n        return postProcessFilter(editor, filteredContent, internal);\n      } else {\n        return processResult(filteredContent, preProcessArgs.isDefaultPrevented());\n      }\n    };\n    const process = (editor, html, internal) => {\n      return filterContent(editor, html, internal);\n    };\n\n    const pasteHtml$1 = (editor, html) => {\n      editor.insertContent(html, {\n        merge: shouldPasteMergeFormats(editor),\n        paste: true\n      });\n      return true;\n    };\n    const isAbsoluteUrl = url => /^https?:\\/\\/[\\w\\?\\-\\/+=.&%@~#]+$/i.test(url);\n    const isImageUrl = (editor, url) => {\n      return isAbsoluteUrl(url) && exists(getAllowedImageFileTypes(editor), type => endsWith(url.toLowerCase(), `.${ type.toLowerCase() }`));\n    };\n    const createImage = (editor, url, pasteHtmlFn) => {\n      editor.undoManager.extra(() => {\n        pasteHtmlFn(editor, url);\n      }, () => {\n        editor.insertContent('<img src=\"' + url + '\">');\n      });\n      return true;\n    };\n    const createLink = (editor, url, pasteHtmlFn) => {\n      editor.undoManager.extra(() => {\n        pasteHtmlFn(editor, url);\n      }, () => {\n        editor.execCommand('mceInsertLink', false, url);\n      });\n      return true;\n    };\n    const linkSelection = (editor, html, pasteHtmlFn) => !editor.selection.isCollapsed() && isAbsoluteUrl(html) ? createLink(editor, html, pasteHtmlFn) : false;\n    const insertImage = (editor, html, pasteHtmlFn) => isImageUrl(editor, html) ? createImage(editor, html, pasteHtmlFn) : false;\n    const smartInsertContent = (editor, html) => {\n      Tools.each([\n        linkSelection,\n        insertImage,\n        pasteHtml$1\n      ], action => {\n        return action(editor, html, pasteHtml$1) !== true;\n      });\n    };\n    const insertContent = (editor, html, pasteAsText) => {\n      if (pasteAsText || !isSmartPasteEnabled(editor)) {\n        pasteHtml$1(editor, html);\n      } else {\n        smartInsertContent(editor, html);\n      }\n    };\n\n    const uniqueId = createIdGenerator('mceclip');\n    const doPaste = (editor, content, internal, pasteAsText) => {\n      const args = process(editor, content, internal);\n      if (args.cancelled === false) {\n        insertContent(editor, args.content, pasteAsText);\n      }\n    };\n    const pasteHtml = (editor, html, internalFlag) => {\n      const internal = internalFlag ? internalFlag : isMarked(html);\n      doPaste(editor, unmark(html), internal, false);\n    };\n    const pasteText = (editor, text) => {\n      const encodedText = editor.dom.encode(text).replace(/\\r\\n/g, '\\n');\n      const normalizedText = normalize$4(encodedText, getPasteTabSpaces(editor));\n      const html = toBlockElements(normalizedText, getForcedRootBlock(editor), getForcedRootBlockAttrs(editor));\n      doPaste(editor, html, false, true);\n    };\n    const getDataTransferItems = dataTransfer => {\n      const items = {};\n      if (dataTransfer && dataTransfer.types) {\n        for (let i = 0; i < dataTransfer.types.length; i++) {\n          const contentType = dataTransfer.types[i];\n          try {\n            items[contentType] = dataTransfer.getData(contentType);\n          } catch (ex) {\n            items[contentType] = '';\n          }\n        }\n      }\n      return items;\n    };\n    const hasContentType = (clipboardContent, mimeType) => mimeType in clipboardContent && clipboardContent[mimeType].length > 0;\n    const hasHtmlOrText = content => hasContentType(content, 'text/html') || hasContentType(content, 'text/plain');\n    const extractFilename = (editor, str) => {\n      const m = str.match(/([\\s\\S]+?)(?:\\.[a-z0-9.]+)$/i);\n      return isNonNullable(m) ? editor.dom.encode(m[1]) : null;\n    };\n    const createBlobInfo = (editor, blobCache, file, base64) => {\n      const id = uniqueId();\n      const useFileName = shouldReuseFileName(editor) && isNonNullable(file.name);\n      const name = useFileName ? extractFilename(editor, file.name) : id;\n      const filename = useFileName ? file.name : undefined;\n      const blobInfo = blobCache.create(id, file, base64, name, filename);\n      blobCache.add(blobInfo);\n      return blobInfo;\n    };\n    const pasteImage = (editor, imageItem) => {\n      const {\n        data: base64,\n        type\n      } = parseDataUri$1(imageItem.uri);\n      const file = imageItem.file;\n      const blobCache = editor.editorUpload.blobCache;\n      const existingBlobInfo = blobCache.getByData(base64, type);\n      const blobInfo = existingBlobInfo !== null && existingBlobInfo !== void 0 ? existingBlobInfo : createBlobInfo(editor, blobCache, file, base64);\n      pasteHtml(editor, `<img src=\"${ blobInfo.blobUri() }\">`, false);\n    };\n    const isClipboardEvent = event => event.type === 'paste';\n    const readFilesAsDataUris = items => Promise.all(map$3(items, file => {\n      return blobToDataUri(file).then(uri => ({\n        file,\n        uri\n      }));\n    }));\n    const isImage = editor => {\n      const allowedExtensions = getAllowedImageFileTypes(editor);\n      return file => startsWith(file.type, 'image/') && exists(allowedExtensions, extension => {\n        return getImageMimeType(extension) === file.type;\n      });\n    };\n    const getImagesFromDataTransfer = (editor, dataTransfer) => {\n      const items = dataTransfer.items ? bind$3(from(dataTransfer.items), item => {\n        return item.kind === 'file' ? [item.getAsFile()] : [];\n      }) : [];\n      const files = dataTransfer.files ? from(dataTransfer.files) : [];\n      return filter$6(items.length > 0 ? items : files, isImage(editor));\n    };\n    const pasteImageData = (editor, e, rng) => {\n      const dataTransfer = isClipboardEvent(e) ? e.clipboardData : e.dataTransfer;\n      if (shouldPasteDataImages(editor) && dataTransfer) {\n        const images = getImagesFromDataTransfer(editor, dataTransfer);\n        if (images.length > 0) {\n          e.preventDefault();\n          readFilesAsDataUris(images).then(fileResults => {\n            if (rng) {\n              editor.selection.setRng(rng);\n            }\n            each$g(fileResults, result => {\n              pasteImage(editor, result);\n            });\n          });\n          return true;\n        }\n      }\n      return false;\n    };\n    const isBrokenAndroidClipboardEvent = e => {\n      var _a, _b;\n      return Env.os.isAndroid() && ((_b = (_a = e.clipboardData) === null || _a === void 0 ? void 0 : _a.items) === null || _b === void 0 ? void 0 : _b.length) === 0;\n    };\n    const isKeyboardPasteEvent = e => VK.metaKeyPressed(e) && e.keyCode === 86 || e.shiftKey && e.keyCode === 45;\n    const insertClipboardContent = (editor, clipboardContent, html, plainTextMode) => {\n      let content = trimHtml(html);\n      const isInternal = hasContentType(clipboardContent, internalHtmlMime()) || isMarked(html);\n      const isPlainTextHtml = !isInternal && isPlainText(content);\n      const isAbsoluteUrl$1 = isAbsoluteUrl(content);\n      if (isDefaultPasteBinContent(content) || !content.length || isPlainTextHtml && !isAbsoluteUrl$1) {\n        plainTextMode = true;\n      }\n      if (plainTextMode || isAbsoluteUrl$1) {\n        if (hasContentType(clipboardContent, 'text/plain') && isPlainTextHtml) {\n          content = clipboardContent['text/plain'];\n        } else {\n          content = innerText(content);\n        }\n      }\n      if (isDefaultPasteBinContent(content)) {\n        return;\n      }\n      if (plainTextMode) {\n        pasteText(editor, content);\n      } else {\n        pasteHtml(editor, content, isInternal);\n      }\n    };\n    const registerEventHandlers = (editor, pasteBin, pasteFormat) => {\n      let keyboardPastePlainTextState;\n      const getLastRng = () => pasteBin.getLastRng() || editor.selection.getRng();\n      editor.on('keydown', e => {\n        if (isKeyboardPasteEvent(e) && !e.isDefaultPrevented()) {\n          keyboardPastePlainTextState = e.shiftKey && e.keyCode === 86;\n        }\n      });\n      editor.on('paste', e => {\n        if (e.isDefaultPrevented() || isBrokenAndroidClipboardEvent(e)) {\n          return;\n        }\n        const plainTextMode = pasteFormat.get() === 'text' || keyboardPastePlainTextState;\n        keyboardPastePlainTextState = false;\n        const clipboardContent = getDataTransferItems(e.clipboardData);\n        if (!hasHtmlOrText(clipboardContent) && pasteImageData(editor, e, getLastRng())) {\n          return;\n        }\n        if (hasContentType(clipboardContent, 'text/html')) {\n          e.preventDefault();\n          insertClipboardContent(editor, clipboardContent, clipboardContent['text/html'], plainTextMode);\n        } else {\n          pasteBin.create();\n          Delay.setEditorTimeout(editor, () => {\n            const html = pasteBin.getHtml();\n            pasteBin.remove();\n            insertClipboardContent(editor, clipboardContent, html, plainTextMode);\n          }, 0);\n        }\n      });\n    };\n    const registerDataImageFilter = editor => {\n      const isWebKitFakeUrl = src => startsWith(src, 'webkit-fake-url');\n      const isDataUri = src => startsWith(src, 'data:');\n      const isPasteInsert = args => {\n        var _a;\n        return ((_a = args.data) === null || _a === void 0 ? void 0 : _a.paste) === true;\n      };\n      editor.parser.addNodeFilter('img', (nodes, name, args) => {\n        if (!shouldPasteDataImages(editor) && isPasteInsert(args)) {\n          for (const node of nodes) {\n            const src = node.attr('src');\n            if (isString(src) && !node.attr('data-mce-object') && src !== Env.transparentSrc) {\n              if (isWebKitFakeUrl(src)) {\n                node.remove();\n              } else if (!shouldAllowHtmlDataUrls(editor) && isDataUri(src)) {\n                node.remove();\n              }\n            }\n          }\n        }\n      });\n    };\n    const registerEventsAndFilters = (editor, pasteBin, pasteFormat) => {\n      registerEventHandlers(editor, pasteBin, pasteFormat);\n      registerDataImageFilter(editor);\n    };\n\n    const togglePlainTextPaste = (editor, pasteFormat) => {\n      if (pasteFormat.get() === 'text') {\n        pasteFormat.set('html');\n        firePastePlainTextToggle(editor, false);\n      } else {\n        pasteFormat.set('text');\n        firePastePlainTextToggle(editor, true);\n      }\n      editor.focus();\n    };\n    const register$1 = (editor, pasteFormat) => {\n      editor.addCommand('mceTogglePlainTextPaste', () => {\n        togglePlainTextPaste(editor, pasteFormat);\n      });\n      editor.addCommand('mceInsertClipboardContent', (ui, value) => {\n        if (value.html) {\n          pasteHtml(editor, value.html, value.internal);\n        }\n        if (value.text) {\n          pasteText(editor, value.text);\n        }\n      });\n    };\n\n    const setHtml5Clipboard = (clipboardData, html, text) => {\n      try {\n        clipboardData.clearData();\n        clipboardData.setData('text/html', html);\n        clipboardData.setData('text/plain', text);\n        clipboardData.setData(internalHtmlMime(), html);\n        return true;\n      } catch (e) {\n        return false;\n      }\n    };\n    const setClipboardData = (evt, data, fallback, done) => {\n      if (setHtml5Clipboard(evt.clipboardData, data.html, data.text)) {\n        evt.preventDefault();\n        done();\n      } else {\n        fallback(data.html, done);\n      }\n    };\n    const fallback = editor => (html, done) => {\n      const {dom, selection} = editor;\n      const outer = dom.create('div', {\n        'contenteditable': 'false',\n        'data-mce-bogus': 'all'\n      });\n      const inner = dom.create('div', { contenteditable: 'true' }, html);\n      dom.setStyles(outer, {\n        position: 'fixed',\n        top: '0',\n        left: '-3000px',\n        width: '1000px',\n        overflow: 'hidden'\n      });\n      outer.appendChild(inner);\n      dom.add(editor.getBody(), outer);\n      const range = selection.getRng();\n      inner.focus();\n      const offscreenRange = dom.createRng();\n      offscreenRange.selectNodeContents(inner);\n      selection.setRng(offscreenRange);\n      Delay.setEditorTimeout(editor, () => {\n        selection.setRng(range);\n        dom.remove(outer);\n        done();\n      }, 0);\n    };\n    const getData = editor => ({\n      html: mark(editor.selection.getContent({ contextual: true })),\n      text: editor.selection.getContent({ format: 'text' })\n    });\n    const isTableSelection = editor => !!editor.dom.getParent(editor.selection.getStart(), 'td[data-mce-selected],th[data-mce-selected]', editor.getBody());\n    const hasSelectedContent = editor => !editor.selection.isCollapsed() || isTableSelection(editor);\n    const cut = editor => evt => {\n      if (!evt.isDefaultPrevented() && hasSelectedContent(editor)) {\n        setClipboardData(evt, getData(editor), fallback(editor), () => {\n          if (Env.browser.isChromium() || Env.browser.isFirefox()) {\n            const rng = editor.selection.getRng();\n            Delay.setEditorTimeout(editor, () => {\n              editor.selection.setRng(rng);\n              editor.execCommand('Delete');\n            }, 0);\n          } else {\n            editor.execCommand('Delete');\n          }\n        });\n      }\n    };\n    const copy = editor => evt => {\n      if (!evt.isDefaultPrevented() && hasSelectedContent(editor)) {\n        setClipboardData(evt, getData(editor), fallback(editor), noop);\n      }\n    };\n    const register = editor => {\n      editor.on('cut', cut(editor));\n      editor.on('copy', copy(editor));\n    };\n\n    const getCaretRangeFromEvent = (editor, e) => {\n      var _a, _b;\n      return RangeUtils.getCaretRangeFromPoint((_a = e.clientX) !== null && _a !== void 0 ? _a : 0, (_b = e.clientY) !== null && _b !== void 0 ? _b : 0, editor.getDoc());\n    };\n    const isPlainTextFileUrl = content => {\n      const plainTextContent = content['text/plain'];\n      return plainTextContent ? plainTextContent.indexOf('file://') === 0 : false;\n    };\n    const setFocusedRange = (editor, rng) => {\n      editor.focus();\n      if (rng) {\n        editor.selection.setRng(rng);\n      }\n    };\n    const hasImage = dataTransfer => exists(dataTransfer.files, file => /^image\\//.test(file.type));\n    const setup$a = (editor, draggingInternallyState) => {\n      if (shouldPasteBlockDrop(editor)) {\n        editor.on('dragend dragover draggesture dragdrop drop drag', e => {\n          e.preventDefault();\n          e.stopPropagation();\n        });\n      }\n      if (!shouldPasteDataImages(editor)) {\n        editor.on('drop', e => {\n          const dataTransfer = e.dataTransfer;\n          if (dataTransfer && hasImage(dataTransfer)) {\n            e.preventDefault();\n          }\n        });\n      }\n      editor.on('drop', e => {\n        if (e.isDefaultPrevented() || draggingInternallyState.get()) {\n          return;\n        }\n        const rng = getCaretRangeFromEvent(editor, e);\n        if (isNullable(rng)) {\n          return;\n        }\n        const dropContent = getDataTransferItems(e.dataTransfer);\n        const internal = hasContentType(dropContent, internalHtmlMime());\n        if ((!hasHtmlOrText(dropContent) || isPlainTextFileUrl(dropContent)) && pasteImageData(editor, e, rng)) {\n          return;\n        }\n        const internalContent = dropContent[internalHtmlMime()];\n        const content = internalContent || dropContent['text/html'] || dropContent['text/plain'];\n        if (content) {\n          e.preventDefault();\n          Delay.setEditorTimeout(editor, () => {\n            editor.undoManager.transact(() => {\n              if (internalContent) {\n                editor.execCommand('Delete');\n              }\n              setFocusedRange(editor, rng);\n              const trimmedContent = trimHtml(content);\n              if (dropContent['text/html']) {\n                pasteHtml(editor, trimmedContent, internal);\n              } else {\n                pasteText(editor, trimmedContent);\n              }\n            });\n          });\n        }\n      });\n      editor.on('dragstart', _e => {\n        draggingInternallyState.set(true);\n      });\n      editor.on('dragover dragend', e => {\n        if (shouldPasteDataImages(editor) && draggingInternallyState.get() === false) {\n          e.preventDefault();\n          setFocusedRange(editor, getCaretRangeFromEvent(editor, e));\n        }\n        if (e.type === 'dragend') {\n          draggingInternallyState.set(false);\n        }\n      });\n    };\n\n    const setup$9 = editor => {\n      const processEvent = f => e => {\n        f(editor, e);\n      };\n      const preProcess = getPastePreProcess(editor);\n      if (isFunction(preProcess)) {\n        editor.on('PastePreProcess', processEvent(preProcess));\n      }\n      const postProcess = getPastePostProcess(editor);\n      if (isFunction(postProcess)) {\n        editor.on('PastePostProcess', processEvent(postProcess));\n      }\n    };\n\n    const addPreProcessFilter = (editor, filterFunc) => {\n      editor.on('PastePreProcess', e => {\n        e.content = filterFunc(editor, e.content, e.internal);\n      });\n    };\n    const rgbRegExp = /rgb\\s*\\(\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*\\)/gi;\n    const rgbToHex = value => Tools.trim(value).replace(rgbRegExp, rgbaToHexString).toLowerCase();\n    const removeWebKitStyles = (editor, content, internal) => {\n      const webKitStylesOption = getPasteWebkitStyles(editor);\n      if (internal || webKitStylesOption === 'all' || !shouldPasteRemoveWebKitStyles(editor)) {\n        return content;\n      }\n      const webKitStyles = webKitStylesOption ? webKitStylesOption.split(/[, ]/) : [];\n      if (webKitStyles && webKitStylesOption !== 'none') {\n        const dom = editor.dom, node = editor.selection.getNode();\n        content = content.replace(/(<[^>]+) style=\"([^\"]*)\"([^>]*>)/gi, (all, before, value, after) => {\n          const inputStyles = dom.parseStyle(dom.decode(value));\n          const outputStyles = {};\n          for (let i = 0; i < webKitStyles.length; i++) {\n            const inputValue = inputStyles[webKitStyles[i]];\n            let compareInput = inputValue;\n            let currentValue = dom.getStyle(node, webKitStyles[i], true);\n            if (/color/.test(webKitStyles[i])) {\n              compareInput = rgbToHex(compareInput);\n              currentValue = rgbToHex(currentValue);\n            }\n            if (currentValue !== compareInput) {\n              outputStyles[webKitStyles[i]] = inputValue;\n            }\n          }\n          const outputStyle = dom.serializeStyle(outputStyles, 'span');\n          if (outputStyle) {\n            return before + ' style=\"' + outputStyle + '\"' + after;\n          }\n          return before + after;\n        });\n      } else {\n        content = content.replace(/(<[^>]+) style=\"([^\"]*)\"([^>]*>)/gi, '$1$3');\n      }\n      content = content.replace(/(<[^>]+) data-mce-style=\"([^\"]+)\"([^>]*>)/gi, (all, before, value, after) => {\n        return before + ' style=\"' + value + '\"' + after;\n      });\n      return content;\n    };\n    const setup$8 = editor => {\n      if (Env.browser.isChromium() || Env.browser.isSafari()) {\n        addPreProcessFilter(editor, removeWebKitStyles);\n      }\n    };\n\n    const setup$7 = editor => {\n      const draggingInternallyState = Cell(false);\n      const pasteFormat = Cell(isPasteAsTextEnabled(editor) ? 'text' : 'html');\n      const pasteBin = PasteBin(editor);\n      setup$8(editor);\n      register$1(editor, pasteFormat);\n      setup$9(editor);\n      editor.on('PreInit', () => {\n        register(editor);\n        setup$a(editor, draggingInternallyState);\n        registerEventsAndFilters(editor, pasteBin, pasteFormat);\n      });\n    };\n\n    const preventSummaryToggle = editor => {\n      editor.on('click', e => {\n        if (editor.dom.getParent(e.target, 'details')) {\n          e.preventDefault();\n        }\n      });\n    };\n    const filterDetails = editor => {\n      editor.parser.addNodeFilter('details', elms => {\n        each$g(elms, details => {\n          details.attr('data-mce-open', details.attr('open'));\n          details.attr('open', 'open');\n        });\n      });\n      editor.serializer.addNodeFilter('details', elms => {\n        each$g(elms, details => {\n          const open = details.attr('data-mce-open');\n          details.attr('open', isString(open) ? open : null);\n          details.attr('data-mce-open', null);\n        });\n      });\n    };\n    const setup$6 = editor => {\n      preventSummaryToggle(editor);\n      filterDetails(editor);\n    };\n\n    const isTextBlockNode = node => isElement$6(node) && isTextBlock$2(SugarElement.fromDom(node));\n    const normalizeSelection = editor => {\n      const rng = editor.selection.getRng();\n      const startPos = CaretPosition.fromRangeStart(rng);\n      const endPos = CaretPosition.fromRangeEnd(rng);\n      if (CaretPosition.isElementPosition(startPos)) {\n        const container = startPos.container();\n        if (isTextBlockNode(container)) {\n          firstPositionIn(container).each(pos => rng.setStart(pos.container(), pos.offset()));\n        }\n      }\n      if (CaretPosition.isElementPosition(endPos)) {\n        const container = startPos.container();\n        if (isTextBlockNode(container)) {\n          lastPositionIn(container).each(pos => rng.setEnd(pos.container(), pos.offset()));\n        }\n      }\n      editor.selection.setRng(normalize(rng));\n    };\n    const setup$5 = editor => {\n      editor.on('click', e => {\n        if (e.detail >= 3) {\n          normalizeSelection(editor);\n        }\n      });\n    };\n\n    var FakeCaretPosition;\n    (function (FakeCaretPosition) {\n      FakeCaretPosition['Before'] = 'before';\n      FakeCaretPosition['After'] = 'after';\n    }(FakeCaretPosition || (FakeCaretPosition = {})));\n    const distanceToRectLeft = (clientRect, clientX) => Math.abs(clientRect.left - clientX);\n    const distanceToRectRight = (clientRect, clientX) => Math.abs(clientRect.right - clientX);\n    const isInsideY = (clientY, clientRect) => clientY >= clientRect.top && clientY <= clientRect.bottom;\n    const collidesY = (r1, r2) => r1.top < r2.bottom && r1.bottom > r2.top;\n    const isOverlapping = (r1, r2) => {\n      const overlap = overlapY(r1, r2) / Math.min(r1.height, r2.height);\n      return collidesY(r1, r2) && overlap > 0.5;\n    };\n    const splitRectsPerAxis = (rects, y) => {\n      const intersectingRects = filter$6(rects, rect => isInsideY(y, rect));\n      return boundingClientRectFromRects(intersectingRects).fold(() => [\n        [],\n        rects\n      ], boundingRect => {\n        const {\n          pass: horizontal,\n          fail: vertical\n        } = partition$2(rects, rect => isOverlapping(rect, boundingRect));\n        return [\n          horizontal,\n          vertical\n        ];\n      });\n    };\n    const clientInfo = (rect, clientX) => {\n      return {\n        node: rect.node,\n        position: distanceToRectLeft(rect, clientX) < distanceToRectRight(rect, clientX) ? FakeCaretPosition.Before : FakeCaretPosition.After\n      };\n    };\n    const horizontalDistance = (rect, x, _y) => x > rect.left && x < rect.right ? 0 : Math.min(Math.abs(rect.left - x), Math.abs(rect.right - x));\n    const closestChildCaretCandidateNodeRect = (children, clientX, clientY) => {\n      const caretCandidateRect = rect => {\n        if (isCaretCandidate$3(rect.node)) {\n          return Optional.some(rect);\n        } else if (isElement$6(rect.node)) {\n          return closestChildCaretCandidateNodeRect(from(rect.node.childNodes), clientX, clientY);\n        } else {\n          return Optional.none();\n        }\n      };\n      const getClosestTextNode = (rects, distance) => {\n        if (rects.length >= 2) {\n          const r1 = caretCandidateRect(rects[0]).getOr(rects[0]);\n          const r2 = caretCandidateRect(rects[1]).getOr(rects[1]);\n          const deltaDistance = Math.abs(distance(r1, clientX, clientY) - distance(r2, clientX, clientY));\n          if (deltaDistance < 2) {\n            if (isText$8(r1.node)) {\n              return Optional.some(r1);\n            } else if (isText$8(r2.node)) {\n              return Optional.some(r2);\n            }\n          }\n        }\n        return Optional.none();\n      };\n      const findClosestCaretCandidateNodeRect = (rects, distance) => {\n        const sortedRects = sort(rects, (r1, r2) => distance(r1, clientX, clientY) - distance(r2, clientX, clientY));\n        return getClosestTextNode(sortedRects, distance).orThunk(() => findMap(sortedRects, caretCandidateRect));\n      };\n      const [horizontalRects, verticalRects] = splitRectsPerAxis(getClientRects(children), clientY);\n      const {\n        pass: above,\n        fail: below\n      } = partition$2(verticalRects, rect => rect.top < clientY);\n      return findClosestCaretCandidateNodeRect(horizontalRects, horizontalDistance).orThunk(() => findClosestCaretCandidateNodeRect(below, distanceToRectEdgeFromXY)).orThunk(() => findClosestCaretCandidateNodeRect(above, distanceToRectEdgeFromXY));\n    };\n    const traverseUp = (rootElm, scope, clientX, clientY) => {\n      const helper = (scope, prevScope) => {\n        return prevScope.fold(() => closestChildCaretCandidateNodeRect(from(scope.dom.childNodes), clientX, clientY), prevScope => {\n          const uncheckedChildren = filter$6(from(scope.dom.childNodes), node => node !== prevScope.dom);\n          return closestChildCaretCandidateNodeRect(uncheckedChildren, clientX, clientY);\n        }).orThunk(() => {\n          const parent = eq(scope, rootElm) ? Optional.none() : parentElement(scope);\n          return parent.bind(newScope => helper(newScope, Optional.some(scope)));\n        });\n      };\n      return helper(scope, Optional.none());\n    };\n    const closestCaretCandidateNodeRect = (root, clientX, clientY) => {\n      const rootElm = SugarElement.fromDom(root);\n      const ownerDoc = documentOrOwner(rootElm);\n      const elementAtPoint = SugarElement.fromPoint(ownerDoc, clientX, clientY).filter(elm => contains(rootElm, elm));\n      const element = elementAtPoint.getOr(rootElm);\n      return traverseUp(rootElm, element, clientX, clientY);\n    };\n    const closestFakeCaretCandidate = (root, clientX, clientY) => closestCaretCandidateNodeRect(root, clientX, clientY).filter(rect => isFakeCaretTarget(rect.node)).map(rect => clientInfo(rect, clientX));\n\n    const getAbsolutePosition = elm => {\n      const clientRect = elm.getBoundingClientRect();\n      const doc = elm.ownerDocument;\n      const docElem = doc.documentElement;\n      const win = doc.defaultView;\n      return {\n        top: clientRect.top + win.pageYOffset - docElem.clientTop,\n        left: clientRect.left + win.pageXOffset - docElem.clientLeft\n      };\n    };\n    const getBodyPosition = editor => editor.inline ? getAbsolutePosition(editor.getBody()) : {\n      left: 0,\n      top: 0\n    };\n    const getScrollPosition = editor => {\n      const body = editor.getBody();\n      return editor.inline ? {\n        left: body.scrollLeft,\n        top: body.scrollTop\n      } : {\n        left: 0,\n        top: 0\n      };\n    };\n    const getBodyScroll = editor => {\n      const body = editor.getBody(), docElm = editor.getDoc().documentElement;\n      const inlineScroll = {\n        left: body.scrollLeft,\n        top: body.scrollTop\n      };\n      const iframeScroll = {\n        left: body.scrollLeft || docElm.scrollLeft,\n        top: body.scrollTop || docElm.scrollTop\n      };\n      return editor.inline ? inlineScroll : iframeScroll;\n    };\n    const getMousePosition = (editor, event) => {\n      if (event.target.ownerDocument !== editor.getDoc()) {\n        const iframePosition = getAbsolutePosition(editor.getContentAreaContainer());\n        const scrollPosition = getBodyScroll(editor);\n        return {\n          left: event.pageX - iframePosition.left + scrollPosition.left,\n          top: event.pageY - iframePosition.top + scrollPosition.top\n        };\n      }\n      return {\n        left: event.pageX,\n        top: event.pageY\n      };\n    };\n    const calculatePosition = (bodyPosition, scrollPosition, mousePosition) => ({\n      pageX: mousePosition.left - bodyPosition.left + scrollPosition.left,\n      pageY: mousePosition.top - bodyPosition.top + scrollPosition.top\n    });\n    const calc = (editor, event) => calculatePosition(getBodyPosition(editor), getScrollPosition(editor), getMousePosition(editor, event));\n\n    const isContentEditableFalse$1 = isContentEditableFalse$a, isContentEditableTrue = isContentEditableTrue$4;\n    const isDraggable = (rootElm, elm) => isContentEditableFalse$1(elm) && elm !== rootElm;\n    const isValidDropTarget = (editor, targetElement, dragElement) => {\n      if (targetElement === dragElement || editor.dom.isChildOf(targetElement, dragElement)) {\n        return false;\n      }\n      return !isContentEditableFalse$1(targetElement);\n    };\n    const cloneElement = elm => {\n      const cloneElm = elm.cloneNode(true);\n      cloneElm.removeAttribute('data-mce-selected');\n      return cloneElm;\n    };\n    const createGhost = (editor, elm, width, height) => {\n      const dom = editor.dom;\n      const clonedElm = elm.cloneNode(true);\n      dom.setStyles(clonedElm, {\n        width,\n        height\n      });\n      dom.setAttrib(clonedElm, 'data-mce-selected', null);\n      const ghostElm = dom.create('div', {\n        'class': 'mce-drag-container',\n        'data-mce-bogus': 'all',\n        'unselectable': 'on',\n        'contenteditable': 'false'\n      });\n      dom.setStyles(ghostElm, {\n        position: 'absolute',\n        opacity: 0.5,\n        overflow: 'hidden',\n        border: 0,\n        padding: 0,\n        margin: 0,\n        width,\n        height\n      });\n      dom.setStyles(clonedElm, {\n        margin: 0,\n        boxSizing: 'border-box'\n      });\n      ghostElm.appendChild(clonedElm);\n      return ghostElm;\n    };\n    const appendGhostToBody = (ghostElm, bodyElm) => {\n      if (ghostElm.parentNode !== bodyElm) {\n        bodyElm.appendChild(ghostElm);\n      }\n    };\n    const moveGhost = (ghostElm, position, width, height, maxX, maxY) => {\n      let overflowX = 0, overflowY = 0;\n      ghostElm.style.left = position.pageX + 'px';\n      ghostElm.style.top = position.pageY + 'px';\n      if (position.pageX + width > maxX) {\n        overflowX = position.pageX + width - maxX;\n      }\n      if (position.pageY + height > maxY) {\n        overflowY = position.pageY + height - maxY;\n      }\n      ghostElm.style.width = width - overflowX + 'px';\n      ghostElm.style.height = height - overflowY + 'px';\n    };\n    const removeElement = elm => {\n      if (elm && elm.parentNode) {\n        elm.parentNode.removeChild(elm);\n      }\n    };\n    const isLeftMouseButtonPressed = e => e.button === 0;\n    const applyRelPos = (state, position) => ({\n      pageX: position.pageX - state.relX,\n      pageY: position.pageY + 5\n    });\n    const start = (state, editor) => e => {\n      if (isLeftMouseButtonPressed(e)) {\n        const ceElm = find$2(editor.dom.getParents(e.target), or(isContentEditableFalse$1, isContentEditableTrue)).getOr(null);\n        if (isDraggable(editor.getBody(), ceElm)) {\n          const elmPos = editor.dom.getPos(ceElm);\n          const bodyElm = editor.getBody();\n          const docElm = editor.getDoc().documentElement;\n          state.set({\n            element: ceElm,\n            dragging: false,\n            screenX: e.screenX,\n            screenY: e.screenY,\n            maxX: (editor.inline ? bodyElm.scrollWidth : docElm.offsetWidth) - 2,\n            maxY: (editor.inline ? bodyElm.scrollHeight : docElm.offsetHeight) - 2,\n            relX: e.pageX - elmPos.x,\n            relY: e.pageY - elmPos.y,\n            width: ceElm.offsetWidth,\n            height: ceElm.offsetHeight,\n            ghost: createGhost(editor, ceElm, ceElm.offsetWidth, ceElm.offsetHeight)\n          });\n        }\n      }\n    };\n    const move = (state, editor) => {\n      const throttledPlaceCaretAt = first$1((clientX, clientY) => {\n        editor._selectionOverrides.hideFakeCaret();\n        editor.selection.placeCaretAt(clientX, clientY);\n      }, 0);\n      editor.on('remove', throttledPlaceCaretAt.cancel);\n      return e => state.on(state => {\n        const movement = Math.max(Math.abs(e.screenX - state.screenX), Math.abs(e.screenY - state.screenY));\n        if (!state.dragging && movement > 10) {\n          const args = editor.dispatch('dragstart', { target: state.element });\n          if (args.isDefaultPrevented()) {\n            return;\n          }\n          state.dragging = true;\n          editor.focus();\n        }\n        if (state.dragging) {\n          const targetPos = applyRelPos(state, calc(editor, e));\n          appendGhostToBody(state.ghost, editor.getBody());\n          moveGhost(state.ghost, targetPos, state.width, state.height, state.maxX, state.maxY);\n          throttledPlaceCaretAt.throttle(e.clientX, e.clientY);\n        }\n      });\n    };\n    const getRawTarget = selection => {\n      const rng = selection.getSel().getRangeAt(0);\n      const startContainer = rng.startContainer;\n      return startContainer.nodeType === 3 ? startContainer.parentNode : startContainer;\n    };\n    const drop = (state, editor) => e => {\n      state.on(state => {\n        if (state.dragging) {\n          if (isValidDropTarget(editor, getRawTarget(editor.selection), state.element)) {\n            const targetClone = cloneElement(state.element);\n            const args = editor.dispatch('drop', {\n              clientX: e.clientX,\n              clientY: e.clientY\n            });\n            if (!args.isDefaultPrevented()) {\n              editor.undoManager.transact(() => {\n                removeElement(state.element);\n                editor.insertContent(editor.dom.getOuterHTML(targetClone));\n                editor._selectionOverrides.hideFakeCaret();\n              });\n            }\n          }\n          editor.dispatch('dragend');\n        }\n      });\n      removeDragState(state);\n    };\n    const stop = (state, editor) => () => {\n      state.on(state => {\n        if (state.dragging) {\n          editor.dispatch('dragend');\n        }\n      });\n      removeDragState(state);\n    };\n    const removeDragState = state => {\n      state.on(state => {\n        removeElement(state.ghost);\n      });\n      state.clear();\n    };\n    const bindFakeDragEvents = editor => {\n      const state = value$2();\n      const pageDom = DOMUtils.DOM;\n      const rootDocument = document;\n      const dragStartHandler = start(state, editor);\n      const dragHandler = move(state, editor);\n      const dropHandler = drop(state, editor);\n      const dragEndHandler = stop(state, editor);\n      editor.on('mousedown', dragStartHandler);\n      editor.on('mousemove', dragHandler);\n      editor.on('mouseup', dropHandler);\n      pageDom.bind(rootDocument, 'mousemove', dragHandler);\n      pageDom.bind(rootDocument, 'mouseup', dragEndHandler);\n      editor.on('remove', () => {\n        pageDom.unbind(rootDocument, 'mousemove', dragHandler);\n        pageDom.unbind(rootDocument, 'mouseup', dragEndHandler);\n      });\n      editor.on('keydown', e => {\n        if (e.keyCode === VK.ESC) {\n          dragEndHandler();\n        }\n      });\n    };\n    const blockUnsupportedFileDrop = editor => {\n      const preventFileDrop = e => {\n        if (!e.isDefaultPrevented()) {\n          const dataTransfer = e.dataTransfer;\n          if (dataTransfer && (contains$2(dataTransfer.types, 'Files') || dataTransfer.files.length > 0)) {\n            e.preventDefault();\n            if (e.type === 'drop') {\n              displayError(editor, 'Dropped file type is not supported');\n            }\n          }\n        }\n      };\n      const preventFileDropIfUIElement = e => {\n        if (isUIElement(editor, e.target)) {\n          preventFileDrop(e);\n        }\n      };\n      const setup = () => {\n        const pageDom = DOMUtils.DOM;\n        const dom = editor.dom;\n        const doc = document;\n        const editorRoot = editor.inline ? editor.getBody() : editor.getDoc();\n        const eventNames = [\n          'drop',\n          'dragover'\n        ];\n        each$g(eventNames, name => {\n          pageDom.bind(doc, name, preventFileDropIfUIElement);\n          dom.bind(editorRoot, name, preventFileDrop);\n        });\n        editor.on('remove', () => {\n          each$g(eventNames, name => {\n            pageDom.unbind(doc, name, preventFileDropIfUIElement);\n            dom.unbind(editorRoot, name, preventFileDrop);\n          });\n        });\n      };\n      editor.on('init', () => {\n        Delay.setEditorTimeout(editor, setup, 0);\n      });\n    };\n    const init$2 = editor => {\n      bindFakeDragEvents(editor);\n      if (shouldBlockUnsupportedDrop(editor)) {\n        blockUnsupportedFileDrop(editor);\n      }\n    };\n\n    const setup$4 = editor => {\n      const renderFocusCaret = first$1(() => {\n        if (!editor.removed && editor.getBody().contains(document.activeElement)) {\n          const rng = editor.selection.getRng();\n          if (rng.collapsed) {\n            const caretRange = renderRangeCaret(editor, rng, false);\n            editor.selection.setRng(caretRange);\n          }\n        }\n      }, 0);\n      editor.on('focus', () => {\n        renderFocusCaret.throttle();\n      });\n      editor.on('blur', () => {\n        renderFocusCaret.cancel();\n      });\n    };\n\n    const setup$3 = editor => {\n      editor.on('init', () => {\n        editor.on('focusin', e => {\n          const target = e.target;\n          if (isMedia$2(target)) {\n            const ceRoot = getContentEditableRoot$1(editor.getBody(), target);\n            const node = isContentEditableFalse$a(ceRoot) ? ceRoot : target;\n            if (editor.selection.getNode() !== node) {\n              selectNode(editor, node).each(rng => editor.selection.setRng(rng));\n            }\n          }\n        });\n      });\n    };\n\n    const isContentEditableFalse = isContentEditableFalse$a;\n    const getContentEditableRoot = (editor, node) => getContentEditableRoot$1(editor.getBody(), node);\n    const SelectionOverrides = editor => {\n      const selection = editor.selection, dom = editor.dom;\n      const isBlock = dom.isBlock;\n      const rootNode = editor.getBody();\n      const fakeCaret = FakeCaret(editor, rootNode, isBlock, () => hasFocus(editor));\n      const realSelectionId = 'sel-' + dom.uniqueId();\n      const elementSelectionAttr = 'data-mce-selected';\n      let selectedElement;\n      const isFakeSelectionElement = node => dom.hasClass(node, 'mce-offscreen-selection');\n      const isFakeSelectionTargetElement = node => node !== rootNode && (isContentEditableFalse(node) || isMedia$2(node)) && dom.isChildOf(node, rootNode);\n      const setRange = range => {\n        if (range) {\n          selection.setRng(range);\n        }\n      };\n      const showCaret = (direction, node, before, scrollIntoView = true) => {\n        const e = editor.dispatch('ShowCaret', {\n          target: node,\n          direction,\n          before\n        });\n        if (e.isDefaultPrevented()) {\n          return null;\n        }\n        if (scrollIntoView) {\n          selection.scrollIntoView(node, direction === -1);\n        }\n        return fakeCaret.show(before, node);\n      };\n      const showBlockCaretContainer = blockCaretContainer => {\n        if (blockCaretContainer.hasAttribute('data-mce-caret')) {\n          showCaretContainerBlock(blockCaretContainer);\n          selection.scrollIntoView(blockCaretContainer);\n        }\n      };\n      const registerEvents = () => {\n        editor.on('click', e => {\n          const contentEditableRoot = getContentEditableRoot(editor, e.target);\n          if (contentEditableRoot) {\n            if (isContentEditableFalse(contentEditableRoot)) {\n              e.preventDefault();\n              editor.focus();\n            }\n          }\n        });\n        editor.on('blur NewBlock', removeElementSelection);\n        editor.on('ResizeWindow FullscreenStateChanged', fakeCaret.reposition);\n        editor.on('tap', e => {\n          const targetElm = e.target;\n          const contentEditableRoot = getContentEditableRoot(editor, targetElm);\n          if (isContentEditableFalse(contentEditableRoot)) {\n            e.preventDefault();\n            selectNode(editor, contentEditableRoot).each(setElementSelection);\n          } else if (isFakeSelectionTargetElement(targetElm)) {\n            selectNode(editor, targetElm).each(setElementSelection);\n          }\n        }, true);\n        editor.on('mousedown', e => {\n          const targetElm = e.target;\n          if (targetElm !== rootNode && targetElm.nodeName !== 'HTML' && !dom.isChildOf(targetElm, rootNode)) {\n            return;\n          }\n          if (isXYInContentArea(editor, e.clientX, e.clientY) === false) {\n            return;\n          }\n          removeElementSelection();\n          hideFakeCaret();\n          const closestContentEditable = getContentEditableRoot(editor, targetElm);\n          if (isContentEditableFalse(closestContentEditable)) {\n            e.preventDefault();\n            selectNode(editor, closestContentEditable).each(setElementSelection);\n          } else {\n            closestFakeCaretCandidate(rootNode, e.clientX, e.clientY).each(caretInfo => {\n              e.preventDefault();\n              const range = showCaret(1, caretInfo.node, caretInfo.position === FakeCaretPosition.Before, false);\n              setRange(range);\n              if (isElement$6(closestContentEditable)) {\n                closestContentEditable.focus();\n              } else {\n                editor.getBody().focus();\n              }\n            });\n          }\n        });\n        editor.on('keypress', e => {\n          if (VK.modifierPressed(e)) {\n            return;\n          }\n          if (isContentEditableFalse(selection.getNode())) {\n            e.preventDefault();\n          }\n        });\n        editor.on('GetSelectionRange', e => {\n          let rng = e.range;\n          if (selectedElement) {\n            if (!selectedElement.parentNode) {\n              selectedElement = null;\n              return;\n            }\n            rng = rng.cloneRange();\n            rng.selectNode(selectedElement);\n            e.range = rng;\n          }\n        });\n        editor.on('SetSelectionRange', e => {\n          e.range = normalizeVoidElementSelection(e.range);\n          const rng = setElementSelection(e.range, e.forward);\n          if (rng) {\n            e.range = rng;\n          }\n        });\n        const isPasteBin = node => node.id === 'mcepastebin';\n        editor.on('AfterSetSelectionRange', e => {\n          const rng = e.range;\n          const parentNode = rng.startContainer.parentNode;\n          if (!isRangeInCaretContainer(rng) && !isPasteBin(parentNode)) {\n            hideFakeCaret();\n          }\n          if (!isFakeSelectionElement(parentNode)) {\n            removeElementSelection();\n          }\n        });\n        init$2(editor);\n        setup$4(editor);\n        setup$3(editor);\n      };\n      const isWithinCaretContainer = node => isCaretContainer$2(node) || startsWithCaretContainer$1(node) || endsWithCaretContainer$1(node);\n      const isRangeInCaretContainer = rng => isWithinCaretContainer(rng.startContainer) || isWithinCaretContainer(rng.endContainer);\n      const normalizeVoidElementSelection = rng => {\n        const voidElements = editor.schema.getVoidElements();\n        const newRng = dom.createRng();\n        const startContainer = rng.startContainer;\n        const startOffset = rng.startOffset;\n        const endContainer = rng.endContainer;\n        const endOffset = rng.endOffset;\n        if (has$2(voidElements, startContainer.nodeName.toLowerCase())) {\n          if (startOffset === 0) {\n            newRng.setStartBefore(startContainer);\n          } else {\n            newRng.setStartAfter(startContainer);\n          }\n        } else {\n          newRng.setStart(startContainer, startOffset);\n        }\n        if (has$2(voidElements, endContainer.nodeName.toLowerCase())) {\n          if (endOffset === 0) {\n            newRng.setEndBefore(endContainer);\n          } else {\n            newRng.setEndAfter(endContainer);\n          }\n        } else {\n          newRng.setEnd(endContainer, endOffset);\n        }\n        return newRng;\n      };\n      const setupOffscreenSelection = (node, targetClone) => {\n        const body = SugarElement.fromDom(editor.getBody());\n        const doc = editor.getDoc();\n        const realSelectionContainer = descendant(body, '#' + realSelectionId).getOrThunk(() => {\n          const newContainer = SugarElement.fromHtml('<div data-mce-bogus=\"all\" class=\"mce-offscreen-selection\"></div>', doc);\n          set$2(newContainer, 'id', realSelectionId);\n          append$1(body, newContainer);\n          return newContainer;\n        });\n        const newRange = dom.createRng();\n        empty(realSelectionContainer);\n        append(realSelectionContainer, [\n          SugarElement.fromText(nbsp, doc),\n          SugarElement.fromDom(targetClone),\n          SugarElement.fromText(nbsp, doc)\n        ]);\n        newRange.setStart(realSelectionContainer.dom.firstChild, 1);\n        newRange.setEnd(realSelectionContainer.dom.lastChild, 0);\n        setAll(realSelectionContainer, { top: dom.getPos(node, editor.getBody()).y + 'px' });\n        focus$1(realSelectionContainer);\n        const sel = selection.getSel();\n        sel.removeAllRanges();\n        sel.addRange(newRange);\n        return newRange;\n      };\n      const selectElement = elm => {\n        const targetClone = elm.cloneNode(true);\n        const e = editor.dispatch('ObjectSelected', {\n          target: elm,\n          targetClone\n        });\n        if (e.isDefaultPrevented()) {\n          return null;\n        }\n        const range = setupOffscreenSelection(elm, e.targetClone);\n        const nodeElm = SugarElement.fromDom(elm);\n        each$g(descendants(SugarElement.fromDom(editor.getBody()), '*[data-mce-selected]'), elm => {\n          if (!eq(nodeElm, elm)) {\n            remove$a(elm, elementSelectionAttr);\n          }\n        });\n        if (!dom.getAttrib(elm, elementSelectionAttr)) {\n          elm.setAttribute(elementSelectionAttr, '1');\n        }\n        selectedElement = elm;\n        hideFakeCaret();\n        return range;\n      };\n      const setElementSelection = (range, forward) => {\n        if (!range) {\n          return null;\n        }\n        if (range.collapsed) {\n          if (!isRangeInCaretContainer(range)) {\n            const dir = forward ? 1 : -1;\n            const caretPosition = getNormalizedRangeEndPoint(dir, rootNode, range);\n            const beforeNode = caretPosition.getNode(!forward);\n            if (isFakeCaretTarget(beforeNode)) {\n              return showCaret(dir, beforeNode, forward ? !caretPosition.isAtEnd() : false, false);\n            }\n            const afterNode = caretPosition.getNode(forward);\n            if (isFakeCaretTarget(afterNode)) {\n              return showCaret(dir, afterNode, forward ? false : !caretPosition.isAtEnd(), false);\n            }\n          }\n          return null;\n        }\n        let startContainer = range.startContainer;\n        let startOffset = range.startOffset;\n        const endOffset = range.endOffset;\n        if (startContainer.nodeType === 3 && startOffset === 0 && isContentEditableFalse(startContainer.parentNode)) {\n          startContainer = startContainer.parentNode;\n          startOffset = dom.nodeIndex(startContainer);\n          startContainer = startContainer.parentNode;\n        }\n        if (startContainer.nodeType !== 1) {\n          return null;\n        }\n        if (endOffset === startOffset + 1 && startContainer === range.endContainer) {\n          const node = startContainer.childNodes[startOffset];\n          if (isFakeSelectionTargetElement(node)) {\n            return selectElement(node);\n          }\n        }\n        return null;\n      };\n      const removeElementSelection = () => {\n        if (selectedElement) {\n          selectedElement.removeAttribute(elementSelectionAttr);\n        }\n        descendant(SugarElement.fromDom(editor.getBody()), '#' + realSelectionId).each(remove$5);\n        selectedElement = null;\n      };\n      const destroy = () => {\n        fakeCaret.destroy();\n        selectedElement = null;\n      };\n      const hideFakeCaret = () => {\n        fakeCaret.hide();\n      };\n      if (!isRtc(editor)) {\n        registerEvents();\n      }\n      return {\n        showCaret,\n        showBlockCaretContainer,\n        hideFakeCaret,\n        destroy\n      };\n    };\n\n    const generatePath = (root, node, offset) => {\n      if (isText$8(node) && (offset < 0 || offset > node.data.length)) {\n        return [];\n      }\n      const p = [offset];\n      let current = node;\n      while (current !== root && current.parentNode) {\n        const parent = current.parentNode;\n        for (let i = 0; i < parent.childNodes.length; i++) {\n          if (parent.childNodes[i] === current) {\n            p.push(i);\n            break;\n          }\n        }\n        current = parent;\n      }\n      return current === root ? p.reverse() : [];\n    };\n    const generatePathRange = (root, startNode, startOffset, endNode, endOffset) => {\n      const start = generatePath(root, startNode, startOffset);\n      const end = generatePath(root, endNode, endOffset);\n      return {\n        start,\n        end\n      };\n    };\n    const resolvePath = (root, path) => {\n      const nodePath = path.slice();\n      const offset = nodePath.pop();\n      const resolvedNode = foldl(nodePath, (optNode, index) => optNode.bind(node => Optional.from(node.childNodes[index])), Optional.some(root));\n      return resolvedNode.bind(node => {\n        if (isText$8(node) && (offset < 0 || offset > node.data.length)) {\n          return Optional.none();\n        } else {\n          return Optional.some({\n            node,\n            offset\n          });\n        }\n      });\n    };\n    const resolvePathRange = (root, range) => resolvePath(root, range.start).bind(({\n      node: startNode,\n      offset: startOffset\n    }) => resolvePath(root, range.end).map(({\n      node: endNode,\n      offset: endOffset\n    }) => {\n      const rng = document.createRange();\n      rng.setStart(startNode, startOffset);\n      rng.setEnd(endNode, endOffset);\n      return rng;\n    }));\n    const generatePathRangeFromRange = (root, range) => generatePathRange(root, range.startContainer, range.startOffset, range.endContainer, range.endOffset);\n\n    const cleanEmptyNodes = (dom, node, isRoot) => {\n      if (node && dom.isEmpty(node) && !isRoot(node)) {\n        const parent = node.parentNode;\n        dom.remove(node);\n        cleanEmptyNodes(dom, parent, isRoot);\n      }\n    };\n    const deleteRng = (dom, rng, isRoot, clean = true) => {\n      const startParent = rng.startContainer.parentNode;\n      const endParent = rng.endContainer.parentNode;\n      rng.deleteContents();\n      if (clean && !isRoot(rng.startContainer)) {\n        if (isText$8(rng.startContainer) && rng.startContainer.data.length === 0) {\n          dom.remove(rng.startContainer);\n        }\n        if (isText$8(rng.endContainer) && rng.endContainer.data.length === 0) {\n          dom.remove(rng.endContainer);\n        }\n        cleanEmptyNodes(dom, startParent, isRoot);\n        if (startParent !== endParent) {\n          cleanEmptyNodes(dom, endParent, isRoot);\n        }\n      }\n    };\n    const getParentBlock = (editor, rng) => Optional.from(editor.dom.getParent(rng.startContainer, editor.dom.isBlock));\n\n    const stripPattern = (dom, block, pattern) => {\n      const firstTextNode = textAfter(block, 0, block);\n      firstTextNode.each(spot => {\n        const node = spot.container;\n        scanRight(node, pattern.start.length, block).each(end => {\n          const rng = dom.createRng();\n          rng.setStart(node, 0);\n          rng.setEnd(end.container, end.offset);\n          deleteRng(dom, rng, e => e === block);\n        });\n      });\n    };\n    const applyPattern$1 = (editor, match) => {\n      const dom = editor.dom;\n      const pattern = match.pattern;\n      const rng = resolvePathRange(dom.getRoot(), match.range).getOrDie('Unable to resolve path range');\n      const isBlockFormatName = (name, formatter) => {\n        const formatSet = formatter.get(name);\n        return isArray$1(formatSet) && head(formatSet).exists(format => has$2(format, 'block'));\n      };\n      getParentBlock(editor, rng).each(block => {\n        if (pattern.type === 'block-format') {\n          if (isBlockFormatName(pattern.format, editor.formatter)) {\n            editor.undoManager.transact(() => {\n              stripPattern(editor.dom, block, pattern);\n              editor.formatter.apply(pattern.format);\n            });\n          }\n        } else if (pattern.type === 'block-command') {\n          editor.undoManager.transact(() => {\n            stripPattern(editor.dom, block, pattern);\n            editor.execCommand(pattern.cmd, false, pattern.value);\n          });\n        }\n      });\n      return true;\n    };\n    const findPattern$1 = (patterns, text) => {\n      const nuText = text.replace(nbsp, ' ');\n      return find$2(patterns, pattern => text.indexOf(pattern.start) === 0 || nuText.indexOf(pattern.start) === 0);\n    };\n    const findPatterns$1 = (editor, patterns) => {\n      const dom = editor.dom;\n      const rng = editor.selection.getRng();\n      return getParentBlock(editor, rng).filter(block => {\n        const forcedRootBlock = getForcedRootBlock(editor);\n        const matchesForcedRootBlock = dom.is(block, forcedRootBlock);\n        return block !== null && matchesForcedRootBlock;\n      }).bind(block => {\n        const blockText = block.textContent;\n        const matchedPattern = findPattern$1(patterns, blockText);\n        return matchedPattern.map(pattern => {\n          if (Tools.trim(blockText).length === pattern.start.length) {\n            return [];\n          }\n          return [{\n              pattern,\n              range: generatePathRange(dom.getRoot(), block, 0, block, 0)\n            }];\n        });\n      }).getOr([]);\n    };\n    const applyMatches$1 = (editor, matches) => {\n      if (matches.length === 0) {\n        return;\n      }\n      const bookmark = editor.selection.getBookmark();\n      each$g(matches, match => applyPattern$1(editor, match));\n      editor.selection.moveToBookmark(bookmark);\n    };\n\n    const newMarker = (dom, id) => dom.create('span', {\n      'data-mce-type': 'bookmark',\n      id\n    });\n    const rangeFromMarker = (dom, marker) => {\n      const rng = dom.createRng();\n      rng.setStartAfter(marker.start);\n      rng.setEndBefore(marker.end);\n      return rng;\n    };\n    const createMarker = (dom, markerPrefix, pathRange) => {\n      const rng = resolvePathRange(dom.getRoot(), pathRange).getOrDie('Unable to resolve path range');\n      const startNode = rng.startContainer;\n      const endNode = rng.endContainer;\n      const textEnd = rng.endOffset === 0 ? endNode : endNode.splitText(rng.endOffset);\n      const textStart = rng.startOffset === 0 ? startNode : startNode.splitText(rng.startOffset);\n      return {\n        prefix: markerPrefix,\n        end: textEnd.parentNode.insertBefore(newMarker(dom, markerPrefix + '-end'), textEnd),\n        start: textStart.parentNode.insertBefore(newMarker(dom, markerPrefix + '-start'), textStart)\n      };\n    };\n    const removeMarker = (dom, marker, isRoot) => {\n      cleanEmptyNodes(dom, dom.get(marker.prefix + '-end'), isRoot);\n      cleanEmptyNodes(dom, dom.get(marker.prefix + '-start'), isRoot);\n    };\n\n    const isReplacementPattern = pattern => pattern.start.length === 0;\n    const matchesPattern = patternContent => (element, offset) => {\n      const text = element.data;\n      const searchText = text.substring(0, offset);\n      const startEndIndex = searchText.lastIndexOf(patternContent.charAt(patternContent.length - 1));\n      const startIndex = searchText.lastIndexOf(patternContent);\n      if (startIndex !== -1) {\n        return startIndex + patternContent.length;\n      } else if (startEndIndex !== -1) {\n        return startEndIndex + 1;\n      } else {\n        return -1;\n      }\n    };\n    const findPatternStartFromSpot = (dom, pattern, block, spot) => {\n      const startPattern = pattern.start;\n      const startSpot = repeatLeft(dom, spot.container, spot.offset, matchesPattern(startPattern), block);\n      return startSpot.bind(spot => {\n        if (spot.offset >= startPattern.length) {\n          const rng = dom.createRng();\n          rng.setStart(spot.container, spot.offset - startPattern.length);\n          rng.setEnd(spot.container, spot.offset);\n          return Optional.some(rng);\n        } else {\n          const offset = spot.offset - startPattern.length;\n          return scanLeft(spot.container, offset, block).map(nextSpot => {\n            const rng = dom.createRng();\n            rng.setStart(nextSpot.container, nextSpot.offset);\n            rng.setEnd(spot.container, spot.offset);\n            return rng;\n          }).filter(rng => rng.toString() === startPattern).orThunk(() => findPatternStartFromSpot(dom, pattern, block, point(spot.container, 0)));\n        }\n      });\n    };\n    const findPatternStart = (dom, pattern, node, offset, block, requireGap = false) => {\n      if (pattern.start.length === 0 && !requireGap) {\n        const rng = dom.createRng();\n        rng.setStart(node, offset);\n        rng.setEnd(node, offset);\n        return Optional.some(rng);\n      }\n      return textBefore(node, offset, block).bind(spot => {\n        const start = findPatternStartFromSpot(dom, pattern, block, spot);\n        return start.bind(startRange => {\n          if (requireGap) {\n            if (startRange.endContainer === spot.container && startRange.endOffset === spot.offset) {\n              return Optional.none();\n            } else if (spot.offset === 0 && startRange.endContainer.textContent.length === startRange.endOffset) {\n              return Optional.none();\n            }\n          }\n          return Optional.some(startRange);\n        });\n      });\n    };\n    const findPattern = (editor, block, details) => {\n      const dom = editor.dom;\n      const root = dom.getRoot();\n      const pattern = details.pattern;\n      const endNode = details.position.container;\n      const endOffset = details.position.offset;\n      return scanLeft(endNode, endOffset - details.pattern.end.length, block).bind(spot => {\n        const endPathRng = generatePathRange(root, spot.container, spot.offset, endNode, endOffset);\n        if (isReplacementPattern(pattern)) {\n          return Optional.some({\n            matches: [{\n                pattern,\n                startRng: endPathRng,\n                endRng: endPathRng\n              }],\n            position: spot\n          });\n        } else {\n          const resultsOpt = findPatternsRec(editor, details.remainingPatterns, spot.container, spot.offset, block);\n          const results = resultsOpt.getOr({\n            matches: [],\n            position: spot\n          });\n          const pos = results.position;\n          const start = findPatternStart(dom, pattern, pos.container, pos.offset, block, resultsOpt.isNone());\n          return start.map(startRng => {\n            const startPathRng = generatePathRangeFromRange(root, startRng);\n            return {\n              matches: results.matches.concat([{\n                  pattern,\n                  startRng: startPathRng,\n                  endRng: endPathRng\n                }]),\n              position: point(startRng.startContainer, startRng.startOffset)\n            };\n          });\n        }\n      });\n    };\n    const findPatternsRec = (editor, patterns, node, offset, block) => {\n      const dom = editor.dom;\n      return textBefore(node, offset, dom.getRoot()).bind(endSpot => {\n        const rng = dom.createRng();\n        rng.setStart(block, 0);\n        rng.setEnd(node, offset);\n        const text = rng.toString();\n        for (let i = 0; i < patterns.length; i++) {\n          const pattern = patterns[i];\n          if (!endsWith(text, pattern.end)) {\n            continue;\n          }\n          const patternsWithoutCurrent = patterns.slice();\n          patternsWithoutCurrent.splice(i, 1);\n          const result = findPattern(editor, block, {\n            pattern,\n            remainingPatterns: patternsWithoutCurrent,\n            position: endSpot\n          });\n          if (result.isSome()) {\n            return result;\n          }\n        }\n        return Optional.none();\n      });\n    };\n    const applyPattern = (editor, pattern, patternRange) => {\n      editor.selection.setRng(patternRange);\n      if (pattern.type === 'inline-format') {\n        each$g(pattern.format, format => {\n          editor.formatter.apply(format);\n        });\n      } else {\n        editor.execCommand(pattern.cmd, false, pattern.value);\n      }\n    };\n    const applyReplacementPattern = (editor, pattern, marker, isRoot) => {\n      const markerRange = rangeFromMarker(editor.dom, marker);\n      deleteRng(editor.dom, markerRange, isRoot);\n      applyPattern(editor, pattern, markerRange);\n    };\n    const applyPatternWithContent = (editor, pattern, startMarker, endMarker, isRoot) => {\n      const dom = editor.dom;\n      const markerEndRange = rangeFromMarker(dom, endMarker);\n      const markerStartRange = rangeFromMarker(dom, startMarker);\n      deleteRng(dom, markerStartRange, isRoot);\n      deleteRng(dom, markerEndRange, isRoot);\n      const patternMarker = {\n        prefix: startMarker.prefix,\n        start: startMarker.end,\n        end: endMarker.start\n      };\n      const patternRange = rangeFromMarker(dom, patternMarker);\n      applyPattern(editor, pattern, patternRange);\n    };\n    const addMarkers = (dom, matches) => {\n      const markerPrefix = generate$1('mce_textpattern');\n      const matchesWithEnds = foldr(matches, (acc, match) => {\n        const endMarker = createMarker(dom, markerPrefix + `_end${ acc.length }`, match.endRng);\n        return acc.concat([{\n            ...match,\n            endMarker\n          }]);\n      }, []);\n      return foldr(matchesWithEnds, (acc, match) => {\n        const idx = matchesWithEnds.length - acc.length - 1;\n        const startMarker = isReplacementPattern(match.pattern) ? match.endMarker : createMarker(dom, markerPrefix + `_start${ idx }`, match.startRng);\n        return acc.concat([{\n            ...match,\n            startMarker\n          }]);\n      }, []);\n    };\n    const findPatterns = (editor, patterns, space) => {\n      const rng = editor.selection.getRng();\n      if (rng.collapsed === false) {\n        return [];\n      }\n      return getParentBlock(editor, rng).bind(block => {\n        const offset = Math.max(0, rng.startOffset - (space ? 1 : 0));\n        return findPatternsRec(editor, patterns, rng.startContainer, offset, block);\n      }).fold(() => [], result => result.matches);\n    };\n    const applyMatches = (editor, matches) => {\n      if (matches.length === 0) {\n        return;\n      }\n      const dom = editor.dom;\n      const bookmark = editor.selection.getBookmark();\n      const matchesWithMarkers = addMarkers(dom, matches);\n      each$g(matchesWithMarkers, match => {\n        const block = dom.getParent(match.startMarker.start, dom.isBlock);\n        const isRoot = node => node === block;\n        if (isReplacementPattern(match.pattern)) {\n          applyReplacementPattern(editor, match.pattern, match.endMarker, isRoot);\n        } else {\n          applyPatternWithContent(editor, match.pattern, match.startMarker, match.endMarker, isRoot);\n        }\n        removeMarker(dom, match.endMarker, isRoot);\n        removeMarker(dom, match.startMarker, isRoot);\n      });\n      editor.selection.moveToBookmark(bookmark);\n    };\n\n    const hasPatterns = patternSet => patternSet.inlinePatterns.length > 0 || patternSet.blockPatterns.length > 0;\n    const handleEnter = (editor, patternSet) => {\n      if (!editor.selection.isCollapsed() || !hasPatterns(patternSet)) {\n        return false;\n      }\n      const inlineMatches = findPatterns(editor, patternSet.inlinePatterns, false);\n      const blockMatches = findPatterns$1(editor, patternSet.blockPatterns);\n      if (blockMatches.length > 0 || inlineMatches.length > 0) {\n        editor.undoManager.add();\n        editor.undoManager.extra(() => {\n          editor.execCommand('mceInsertNewLine');\n        }, () => {\n          editor.insertContent(zeroWidth);\n          applyMatches(editor, inlineMatches);\n          applyMatches$1(editor, blockMatches);\n          const range = editor.selection.getRng();\n          const spot = textBefore(range.startContainer, range.startOffset, editor.dom.getRoot());\n          editor.execCommand('mceInsertNewLine');\n          spot.each(s => {\n            const node = s.container;\n            if (node.data.charAt(s.offset - 1) === zeroWidth) {\n              node.deleteData(s.offset - 1, 1);\n              cleanEmptyNodes(editor.dom, node.parentNode, e => e === editor.dom.getRoot());\n            }\n          });\n        });\n        return true;\n      }\n      return false;\n    };\n    const handleInlineKey = (editor, inlinePatterns) => {\n      if (inlinePatterns.length > 0) {\n        const inlineMatches = findPatterns(editor, inlinePatterns, true);\n        if (inlineMatches.length > 0) {\n          editor.undoManager.transact(() => {\n            applyMatches(editor, inlineMatches);\n          });\n        }\n      }\n    };\n    const checkKeyEvent = (codes, event, predicate) => {\n      for (let i = 0; i < codes.length; i++) {\n        if (predicate(codes[i], event)) {\n          return true;\n        }\n      }\n      return false;\n    };\n    const checkKeyCode = (codes, event) => checkKeyEvent(codes, event, (code, event) => {\n      return code === event.keyCode && VK.modifierPressed(event) === false;\n    });\n    const checkCharCode = (chars, event) => checkKeyEvent(chars, event, (chr, event) => {\n      return chr.charCodeAt(0) === event.charCode;\n    });\n\n    const setup$2 = editor => {\n      const charCodes = [\n        ',',\n        '.',\n        ';',\n        ':',\n        '!',\n        '?'\n      ];\n      const keyCodes = [32];\n      const getPatternSet = () => createPatternSet(getTextPatterns(editor));\n      const getInlinePatterns$1 = () => getInlinePatterns(getTextPatterns(editor));\n      editor.on('keydown', e => {\n        if (e.keyCode === 13 && !VK.modifierPressed(e)) {\n          if (handleEnter(editor, getPatternSet())) {\n            e.preventDefault();\n          }\n        }\n      }, true);\n      editor.on('keyup', e => {\n        if (checkKeyCode(keyCodes, e)) {\n          handleInlineKey(editor, getInlinePatterns$1());\n        }\n      });\n      editor.on('keypress', e => {\n        if (checkCharCode(charCodes, e)) {\n          Delay.setEditorTimeout(editor, () => {\n            handleInlineKey(editor, getInlinePatterns$1());\n          });\n        }\n      });\n    };\n\n    const setup$1 = editor => {\n      setup$2(editor);\n    };\n\n    const Quirks = editor => {\n      const each = Tools.each;\n      const BACKSPACE = VK.BACKSPACE, DELETE = VK.DELETE, dom = editor.dom, selection = editor.selection, parser = editor.parser;\n      const browser = Env.browser;\n      const isGecko = browser.isFirefox();\n      const isWebKit = browser.isChromium() || browser.isSafari();\n      const isiOS = Env.deviceType.isiPhone() || Env.deviceType.isiPad();\n      const isMac = Env.os.isMacOS() || Env.os.isiOS();\n      const setEditorCommandState = (cmd, state) => {\n        try {\n          editor.getDoc().execCommand(cmd, false, state);\n        } catch (ex) {\n        }\n      };\n      const isDefaultPrevented = e => {\n        return e.isDefaultPrevented();\n      };\n      const emptyEditorWhenDeleting = () => {\n        const serializeRng = rng => {\n          const body = dom.create('body');\n          const contents = rng.cloneContents();\n          body.appendChild(contents);\n          return selection.serializer.serialize(body, { format: 'html' });\n        };\n        const allContentsSelected = rng => {\n          const selection = serializeRng(rng);\n          const allRng = dom.createRng();\n          allRng.selectNode(editor.getBody());\n          const allSelection = serializeRng(allRng);\n          return selection === allSelection;\n        };\n        editor.on('keydown', e => {\n          const keyCode = e.keyCode;\n          let isCollapsed, body;\n          if (!isDefaultPrevented(e) && (keyCode === DELETE || keyCode === BACKSPACE)) {\n            isCollapsed = editor.selection.isCollapsed();\n            body = editor.getBody();\n            if (isCollapsed && !dom.isEmpty(body)) {\n              return;\n            }\n            if (!isCollapsed && !allContentsSelected(editor.selection.getRng())) {\n              return;\n            }\n            e.preventDefault();\n            editor.setContent('');\n            if (body.firstChild && dom.isBlock(body.firstChild)) {\n              editor.selection.setCursorLocation(body.firstChild, 0);\n            } else {\n              editor.selection.setCursorLocation(body, 0);\n            }\n            editor.nodeChanged();\n          }\n        });\n      };\n      const selectAll = () => {\n        editor.shortcuts.add('meta+a', null, 'SelectAll');\n      };\n      const documentElementEditingFocus = () => {\n        if (!editor.inline) {\n          dom.bind(editor.getDoc(), 'mousedown mouseup', e => {\n            let rng;\n            if (e.target === editor.getDoc().documentElement) {\n              rng = selection.getRng();\n              editor.getBody().focus();\n              if (e.type === 'mousedown') {\n                if (isCaretContainer$2(rng.startContainer)) {\n                  return;\n                }\n                selection.placeCaretAt(e.clientX, e.clientY);\n              } else {\n                selection.setRng(rng);\n              }\n            }\n          });\n        }\n      };\n      const removeHrOnBackspace = () => {\n        editor.on('keydown', e => {\n          if (!isDefaultPrevented(e) && e.keyCode === BACKSPACE) {\n            if (!editor.getBody().getElementsByTagName('hr').length) {\n              return;\n            }\n            if (selection.isCollapsed() && selection.getRng().startOffset === 0) {\n              const node = selection.getNode();\n              const previousSibling = node.previousSibling;\n              if (node.nodeName === 'HR') {\n                dom.remove(node);\n                e.preventDefault();\n                return;\n              }\n              if (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === 'hr') {\n                dom.remove(previousSibling);\n                e.preventDefault();\n              }\n            }\n          }\n        });\n      };\n      const focusBody = () => {\n        if (!Range.prototype.getClientRects) {\n          editor.on('mousedown', e => {\n            if (!isDefaultPrevented(e) && e.target.nodeName === 'HTML') {\n              const body = editor.getBody();\n              body.blur();\n              Delay.setEditorTimeout(editor, () => {\n                body.focus();\n              });\n            }\n          });\n        }\n      };\n      const selectControlElements = () => {\n        const visualAidsAnchorClass = getVisualAidsAnchorClass(editor);\n        editor.on('click', e => {\n          const target = e.target;\n          if (/^(IMG|HR)$/.test(target.nodeName) && dom.getContentEditableParent(target) !== 'false') {\n            e.preventDefault();\n            editor.selection.select(target);\n            editor.nodeChanged();\n          }\n          if (target.nodeName === 'A' && dom.hasClass(target, visualAidsAnchorClass) && target.childNodes.length === 0) {\n            e.preventDefault();\n            selection.select(target);\n          }\n        });\n      };\n      const removeStylesWhenDeletingAcrossBlockElements = () => {\n        const getAttributeApplyFunction = () => {\n          const template = dom.getAttribs(selection.getStart().cloneNode(false));\n          return () => {\n            const target = selection.getStart();\n            if (target !== editor.getBody()) {\n              dom.setAttrib(target, 'style', null);\n              each(template, attr => {\n                target.setAttributeNode(attr.cloneNode(true));\n              });\n            }\n          };\n        };\n        const isSelectionAcrossElements = () => {\n          return !selection.isCollapsed() && dom.getParent(selection.getStart(), dom.isBlock) !== dom.getParent(selection.getEnd(), dom.isBlock);\n        };\n        editor.on('keypress', e => {\n          let applyAttributes;\n          if (!isDefaultPrevented(e) && (e.keyCode === 8 || e.keyCode === 46) && isSelectionAcrossElements()) {\n            applyAttributes = getAttributeApplyFunction();\n            editor.getDoc().execCommand('delete', false, null);\n            applyAttributes();\n            e.preventDefault();\n            return false;\n          }\n        });\n        dom.bind(editor.getDoc(), 'cut', e => {\n          let applyAttributes;\n          if (!isDefaultPrevented(e) && isSelectionAcrossElements()) {\n            applyAttributes = getAttributeApplyFunction();\n            Delay.setEditorTimeout(editor, () => {\n              applyAttributes();\n            });\n          }\n        });\n      };\n      const disableBackspaceIntoATable = () => {\n        editor.on('keydown', e => {\n          if (!isDefaultPrevented(e) && e.keyCode === BACKSPACE) {\n            if (selection.isCollapsed() && selection.getRng().startOffset === 0) {\n              const previousSibling = selection.getNode().previousSibling;\n              if (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === 'table') {\n                e.preventDefault();\n                return false;\n              }\n            }\n          }\n        });\n      };\n      const removeBlockQuoteOnBackSpace = () => {\n        editor.on('keydown', e => {\n          let rng, parent;\n          if (isDefaultPrevented(e) || e.keyCode !== VK.BACKSPACE) {\n            return;\n          }\n          rng = selection.getRng();\n          const container = rng.startContainer;\n          const offset = rng.startOffset;\n          const root = dom.getRoot();\n          parent = container;\n          if (!rng.collapsed || offset !== 0) {\n            return;\n          }\n          while (parent && parent.parentNode && parent.parentNode.firstChild === parent && parent.parentNode !== root) {\n            parent = parent.parentNode;\n          }\n          if (parent.tagName === 'BLOCKQUOTE') {\n            editor.formatter.toggle('blockquote', null, parent);\n            rng = dom.createRng();\n            rng.setStart(container, 0);\n            rng.setEnd(container, 0);\n            selection.setRng(rng);\n          }\n        });\n      };\n      const setGeckoEditingOptions = () => {\n        const setOpts = () => {\n          setEditorCommandState('StyleWithCSS', false);\n          setEditorCommandState('enableInlineTableEditing', false);\n          if (!getObjectResizing(editor)) {\n            setEditorCommandState('enableObjectResizing', false);\n          }\n        };\n        if (!isReadOnly$1(editor)) {\n          editor.on('BeforeExecCommand mousedown', setOpts);\n        }\n      };\n      const addBrAfterLastLinks = () => {\n        const fixLinks = () => {\n          each(dom.select('a'), node => {\n            let parentNode = node.parentNode;\n            const root = dom.getRoot();\n            if (parentNode.lastChild === node) {\n              while (parentNode && !dom.isBlock(parentNode)) {\n                if (parentNode.parentNode.lastChild !== parentNode || parentNode === root) {\n                  return;\n                }\n                parentNode = parentNode.parentNode;\n              }\n              dom.add(parentNode, 'br', { 'data-mce-bogus': 1 });\n            }\n          });\n        };\n        editor.on('SetContent ExecCommand', e => {\n          if (e.type === 'setcontent' || e.command === 'mceInsertLink') {\n            fixLinks();\n          }\n        });\n      };\n      const setDefaultBlockType = () => {\n        editor.on('init', () => {\n          setEditorCommandState('DefaultParagraphSeparator', getForcedRootBlock(editor));\n        });\n      };\n      const normalizeSelection = () => {\n        editor.on('keyup focusin mouseup', e => {\n          if (!VK.modifierPressed(e)) {\n            selection.normalize();\n          }\n        }, true);\n      };\n      const showBrokenImageIcon = () => {\n        editor.contentStyles.push('img:-moz-broken {' + '-moz-force-broken-image-icon:1;' + 'min-width:24px;' + 'min-height:24px' + '}');\n      };\n      const restoreFocusOnKeyDown = () => {\n        if (!editor.inline) {\n          editor.on('keydown', () => {\n            if (document.activeElement === document.body) {\n              editor.getWin().focus();\n            }\n          });\n        }\n      };\n      const bodyHeight = () => {\n        if (!editor.inline) {\n          editor.contentStyles.push('body {min-height: 150px}');\n          editor.on('click', e => {\n            let rng;\n            if (e.target.nodeName === 'HTML') {\n              rng = editor.selection.getRng();\n              editor.getBody().focus();\n              editor.selection.setRng(rng);\n              editor.selection.normalize();\n              editor.nodeChanged();\n            }\n          });\n        }\n      };\n      const blockCmdArrowNavigation = () => {\n        if (isMac) {\n          editor.on('keydown', e => {\n            if (VK.metaKeyPressed(e) && !e.shiftKey && (e.keyCode === 37 || e.keyCode === 39)) {\n              e.preventDefault();\n              const selection = editor.selection.getSel();\n              selection.modify('move', e.keyCode === 37 ? 'backward' : 'forward', 'lineboundary');\n            }\n          });\n        }\n      };\n      const tapLinksAndImages = () => {\n        editor.on('click', e => {\n          let elm = e.target;\n          do {\n            if (elm.tagName === 'A') {\n              e.preventDefault();\n              return;\n            }\n          } while (elm = elm.parentNode);\n        });\n        editor.contentStyles.push('.mce-content-body {-webkit-touch-callout: none}');\n      };\n      const blockFormSubmitInsideEditor = () => {\n        editor.on('init', () => {\n          editor.dom.bind(editor.getBody(), 'submit', e => {\n            e.preventDefault();\n          });\n        });\n      };\n      const removeAppleInterchangeBrs = () => {\n        parser.addNodeFilter('br', nodes => {\n          let i = nodes.length;\n          while (i--) {\n            if (nodes[i].attr('class') === 'Apple-interchange-newline') {\n              nodes[i].remove();\n            }\n          }\n        });\n      };\n      const refreshContentEditable = noop;\n      const isHidden = () => {\n        if (!isGecko || editor.removed) {\n          return false;\n        }\n        const sel = editor.selection.getSel();\n        return !sel || !sel.rangeCount || sel.rangeCount === 0;\n      };\n      const setupRtc = () => {\n        if (isWebKit) {\n          documentElementEditingFocus();\n          selectControlElements();\n          blockFormSubmitInsideEditor();\n          selectAll();\n          if (isiOS) {\n            restoreFocusOnKeyDown();\n            bodyHeight();\n            tapLinksAndImages();\n          }\n        }\n        if (isGecko) {\n          focusBody();\n          setGeckoEditingOptions();\n          showBrokenImageIcon();\n          blockCmdArrowNavigation();\n        }\n      };\n      const setup = () => {\n        removeBlockQuoteOnBackSpace();\n        emptyEditorWhenDeleting();\n        if (!Env.windowsPhone) {\n          normalizeSelection();\n        }\n        if (isWebKit) {\n          documentElementEditingFocus();\n          selectControlElements();\n          setDefaultBlockType();\n          blockFormSubmitInsideEditor();\n          disableBackspaceIntoATable();\n          removeAppleInterchangeBrs();\n          if (isiOS) {\n            restoreFocusOnKeyDown();\n            bodyHeight();\n            tapLinksAndImages();\n          } else {\n            selectAll();\n          }\n        }\n        if (isGecko) {\n          removeHrOnBackspace();\n          focusBody();\n          removeStylesWhenDeletingAcrossBlockElements();\n          setGeckoEditingOptions();\n          addBrAfterLastLinks();\n          showBrokenImageIcon();\n          blockCmdArrowNavigation();\n          disableBackspaceIntoATable();\n        }\n      };\n      if (isRtc(editor)) {\n        setupRtc();\n      } else {\n        setup();\n      }\n      return {\n        refreshContentEditable,\n        isHidden\n      };\n    };\n\n    const DOM$6 = DOMUtils.DOM;\n    const appendStyle = (editor, text) => {\n      const body = SugarElement.fromDom(editor.getBody());\n      const container = getStyleContainer(getRootNode(body));\n      const style = SugarElement.fromTag('style');\n      set$2(style, 'type', 'text/css');\n      append$1(style, SugarElement.fromText(text));\n      append$1(container, style);\n      editor.on('remove', () => {\n        remove$5(style);\n      });\n    };\n    const getRootName = editor => editor.inline ? editor.getElement().nodeName.toLowerCase() : undefined;\n    const removeUndefined = obj => filter$5(obj, v => isUndefined(v) === false);\n    const mkParserSettings = editor => {\n      const getOption = editor.options.get;\n      const blobCache = editor.editorUpload.blobCache;\n      return removeUndefined({\n        allow_conditional_comments: getOption('allow_conditional_comments'),\n        allow_html_data_urls: getOption('allow_html_data_urls'),\n        allow_svg_data_urls: getOption('allow_svg_data_urls'),\n        allow_html_in_named_anchor: getOption('allow_html_in_named_anchor'),\n        allow_script_urls: getOption('allow_script_urls'),\n        allow_unsafe_link_target: getOption('allow_unsafe_link_target'),\n        convert_fonts_to_spans: getOption('convert_fonts_to_spans'),\n        fix_list_elements: getOption('fix_list_elements'),\n        font_size_legacy_values: getOption('font_size_legacy_values'),\n        forced_root_block: getOption('forced_root_block'),\n        forced_root_block_attrs: getOption('forced_root_block_attrs'),\n        preserve_cdata: getOption('preserve_cdata'),\n        remove_trailing_brs: getOption('remove_trailing_brs'),\n        inline_styles: getOption('inline_styles'),\n        root_name: getRootName(editor),\n        validate: true,\n        blob_cache: blobCache,\n        document: editor.getDoc()\n      });\n    };\n    const mkSchemaSettings = editor => {\n      const getOption = editor.options.get;\n      return removeUndefined({\n        custom_elements: getOption('custom_elements'),\n        extended_valid_elements: getOption('extended_valid_elements'),\n        invalid_elements: getOption('invalid_elements'),\n        invalid_styles: getOption('invalid_styles'),\n        schema: getOption('schema'),\n        valid_children: getOption('valid_children'),\n        valid_classes: getOption('valid_classes'),\n        valid_elements: getOption('valid_elements'),\n        valid_styles: getOption('valid_styles'),\n        verify_html: getOption('verify_html'),\n        padd_empty_block_inline_children: getOption('format_empty_lines')\n      });\n    };\n    const mkSerializerSettings = editor => {\n      const getOption = editor.options.get;\n      return {\n        ...mkParserSettings(editor),\n        ...mkSchemaSettings(editor),\n        ...removeUndefined({\n          url_converter: getOption('url_converter'),\n          url_converter_scope: getOption('url_converter_scope'),\n          element_format: getOption('element_format'),\n          entities: getOption('entities'),\n          entity_encoding: getOption('entity_encoding'),\n          indent: getOption('indent'),\n          indent_after: getOption('indent_after'),\n          indent_before: getOption('indent_before')\n        })\n      };\n    };\n    const createParser = editor => {\n      const parser = DomParser(mkParserSettings(editor), editor.schema);\n      parser.addAttributeFilter('src,href,style,tabindex', (nodes, name) => {\n        let i = nodes.length, node, value;\n        const dom = editor.dom;\n        const internalName = 'data-mce-' + name;\n        while (i--) {\n          node = nodes[i];\n          value = node.attr(name);\n          if (value && !node.attr(internalName)) {\n            if (value.indexOf('data:') === 0 || value.indexOf('blob:') === 0) {\n              continue;\n            }\n            if (name === 'style') {\n              value = dom.serializeStyle(dom.parseStyle(value), node.name);\n              if (!value.length) {\n                value = null;\n              }\n              node.attr(internalName, value);\n              node.attr(name, value);\n            } else if (name === 'tabindex') {\n              node.attr(internalName, value);\n              node.attr(name, null);\n            } else {\n              node.attr(internalName, editor.convertURL(value, name, node.name));\n            }\n          }\n        }\n      });\n      parser.addNodeFilter('script', nodes => {\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          const type = node.attr('type') || 'no/type';\n          if (type.indexOf('mce-') !== 0) {\n            node.attr('type', 'mce-' + type);\n          }\n        }\n      });\n      if (editor.options.get('preserve_cdata')) {\n        parser.addNodeFilter('#cdata', nodes => {\n          let i = nodes.length;\n          while (i--) {\n            const node = nodes[i];\n            node.type = 8;\n            node.name = '#comment';\n            node.value = '[CDATA[' + editor.dom.encode(node.value) + ']]';\n          }\n        });\n      }\n      parser.addNodeFilter('p,h1,h2,h3,h4,h5,h6,div', nodes => {\n        let i = nodes.length;\n        const nonEmptyElements = editor.schema.getNonEmptyElements();\n        while (i--) {\n          const node = nodes[i];\n          if (node.isEmpty(nonEmptyElements) && node.getAll('br').length === 0) {\n            node.append(new AstNode('br', 1));\n          }\n        }\n      });\n      return parser;\n    };\n    const autoFocus = editor => {\n      const autoFocus = getAutoFocus(editor);\n      if (autoFocus) {\n        Delay.setEditorTimeout(editor, () => {\n          let focusEditor;\n          if (autoFocus === true) {\n            focusEditor = editor;\n          } else {\n            focusEditor = editor.editorManager.get(autoFocus);\n          }\n          if (!focusEditor.destroyed) {\n            focusEditor.focus();\n          }\n        }, 100);\n      }\n    };\n    const moveSelectionToFirstCaretPosition = editor => {\n      const root = editor.dom.getRoot();\n      if (!editor.inline && (!hasAnyRanges(editor) || editor.selection.getStart(true) === root)) {\n        firstPositionIn(root).each(pos => {\n          const node = pos.getNode();\n          const caretPos = isTable$3(node) ? firstPositionIn(node).getOr(pos) : pos;\n          editor.selection.setRng(caretPos.toRange());\n        });\n      }\n    };\n    const initEditor = editor => {\n      editor.bindPendingEventDelegates();\n      editor.initialized = true;\n      fireInit(editor);\n      editor.focus(true);\n      moveSelectionToFirstCaretPosition(editor);\n      editor.nodeChanged({ initial: true });\n      const initInstanceCallback = getInitInstanceCallback(editor);\n      if (isFunction(initInstanceCallback)) {\n        initInstanceCallback.call(editor, editor);\n      }\n      autoFocus(editor);\n    };\n    const getStyleSheetLoader$1 = editor => editor.inline ? editor.ui.styleSheetLoader : editor.dom.styleSheetLoader;\n    const makeStylesheetLoadingPromises = (editor, css, framedFonts) => {\n      const promises = [getStyleSheetLoader$1(editor).loadAll(css)];\n      if (editor.inline) {\n        return promises;\n      } else {\n        return promises.concat([editor.ui.styleSheetLoader.loadAll(framedFonts)]);\n      }\n    };\n    const loadContentCss = editor => {\n      const styleSheetLoader = getStyleSheetLoader$1(editor);\n      const fontCss = getFontCss(editor);\n      const css = editor.contentCSS;\n      const removeCss = () => {\n        styleSheetLoader.unloadAll(css);\n        if (!editor.inline) {\n          editor.ui.styleSheetLoader.unloadAll(fontCss);\n        }\n      };\n      const loaded = () => {\n        if (editor.removed) {\n          removeCss();\n        } else {\n          editor.on('remove', removeCss);\n        }\n      };\n      if (editor.contentStyles.length > 0) {\n        let contentCssText = '';\n        Tools.each(editor.contentStyles, style => {\n          contentCssText += style + '\\r\\n';\n        });\n        editor.dom.addStyle(contentCssText);\n      }\n      const allStylesheets = Promise.all(makeStylesheetLoadingPromises(editor, css, fontCss)).then(loaded).catch(loaded);\n      const contentStyle = getContentStyle(editor);\n      if (contentStyle) {\n        appendStyle(editor, contentStyle);\n      }\n      return allStylesheets;\n    };\n    const preInit = editor => {\n      const doc = editor.getDoc(), body = editor.getBody();\n      firePreInit(editor);\n      if (!shouldBrowserSpellcheck(editor)) {\n        doc.body.spellcheck = false;\n        DOM$6.setAttrib(body, 'spellcheck', 'false');\n      }\n      editor.quirks = Quirks(editor);\n      firePostRender(editor);\n      const directionality = getDirectionality(editor);\n      if (directionality !== undefined) {\n        body.dir = directionality;\n      }\n      const protect = getProtect(editor);\n      if (protect) {\n        editor.on('BeforeSetContent', e => {\n          Tools.each(protect, pattern => {\n            e.content = e.content.replace(pattern, str => {\n              return '<!--mce:protected ' + escape(str) + '-->';\n            });\n          });\n        });\n      }\n      editor.on('SetContent', () => {\n        editor.addVisual(editor.getBody());\n      });\n      editor.on('compositionstart compositionend', e => {\n        editor.composing = e.type === 'compositionstart';\n      });\n    };\n    const loadInitialContent = editor => {\n      if (!isRtc(editor)) {\n        editor.load({\n          initial: true,\n          format: 'html'\n        });\n      }\n      editor.startContent = editor.getContent({ format: 'raw' });\n    };\n    const initEditorWithInitialContent = editor => {\n      if (editor.removed !== true) {\n        loadInitialContent(editor);\n        initEditor(editor);\n      }\n    };\n    const contentBodyLoaded = editor => {\n      const targetElm = editor.getElement();\n      let doc = editor.getDoc();\n      if (editor.inline) {\n        DOM$6.addClass(targetElm, 'mce-content-body');\n        editor.contentDocument = doc = document;\n        editor.contentWindow = window;\n        editor.bodyElement = targetElm;\n        editor.contentAreaContainer = targetElm;\n      }\n      const body = editor.getBody();\n      body.disabled = true;\n      editor.readonly = isReadOnly$1(editor);\n      if (!editor.readonly) {\n        if (editor.inline && DOM$6.getStyle(body, 'position', true) === 'static') {\n          body.style.position = 'relative';\n        }\n        body.contentEditable = 'true';\n      }\n      body.disabled = false;\n      editor.editorUpload = EditorUpload(editor);\n      editor.schema = Schema(mkSchemaSettings(editor));\n      editor.dom = DOMUtils(doc, {\n        keep_values: true,\n        url_converter: editor.convertURL,\n        url_converter_scope: editor,\n        update_styles: true,\n        root_element: editor.inline ? editor.getBody() : null,\n        collect: () => editor.inline,\n        schema: editor.schema,\n        contentCssCors: shouldUseContentCssCors(editor),\n        referrerPolicy: getReferrerPolicy(editor),\n        onSetAttrib: e => {\n          editor.dispatch('SetAttrib', e);\n        }\n      });\n      editor.parser = createParser(editor);\n      editor.serializer = DomSerializer(mkSerializerSettings(editor), editor);\n      editor.selection = EditorSelection(editor.dom, editor.getWin(), editor.serializer, editor);\n      editor.annotator = Annotator(editor);\n      editor.formatter = Formatter(editor);\n      editor.undoManager = UndoManager(editor);\n      editor._nodeChangeDispatcher = new NodeChange(editor);\n      editor._selectionOverrides = SelectionOverrides(editor);\n      setup$o(editor);\n      setup$6(editor);\n      setup$m(editor);\n      if (!isRtc(editor)) {\n        setup$5(editor);\n        setup$1(editor);\n      }\n      const caret = setup$b(editor);\n      setup$p(editor, caret);\n      setup$n(editor);\n      setup$q(editor);\n      setup$7(editor);\n      const setupRtcThunk = setup$s(editor);\n      preInit(editor);\n      setupRtcThunk.fold(() => {\n        loadContentCss(editor).then(() => initEditorWithInitialContent(editor));\n      }, setupRtc => {\n        editor.setProgressState(true);\n        loadContentCss(editor).then(() => {\n          setupRtc().then(_rtcMode => {\n            editor.setProgressState(false);\n            initEditorWithInitialContent(editor);\n            bindEvents(editor);\n          }, err => {\n            editor.notificationManager.open({\n              type: 'error',\n              text: String(err)\n            });\n            initEditorWithInitialContent(editor);\n            bindEvents(editor);\n          });\n        });\n      });\n    };\n    const initContentBody = (editor, skipWrite) => {\n      if (!editor.inline) {\n        editor.getElement().style.visibility = editor.orgVisibility;\n      }\n      if (!skipWrite && !editor.inline) {\n        const iframe = editor.iframeElement;\n        const binder = bind$1(SugarElement.fromDom(iframe), 'load', () => {\n          binder.unbind();\n          editor.contentDocument = iframe.contentDocument;\n          contentBodyLoaded(editor);\n        });\n        iframe.srcdoc = editor.iframeHTML;\n      } else {\n        contentBodyLoaded(editor);\n      }\n    };\n\n    const DOM$5 = DOMUtils.DOM;\n    const createIframeElement = (id, title, customAttrs, tabindex) => {\n      const iframe = SugarElement.fromTag('iframe');\n      tabindex.each(t => set$2(iframe, 'tabindex', t));\n      setAll$1(iframe, customAttrs);\n      setAll$1(iframe, {\n        id: id + '_ifr',\n        frameBorder: '0',\n        allowTransparency: 'true',\n        title\n      });\n      add$2(iframe, 'tox-edit-area__iframe');\n      return iframe;\n    };\n    const getIframeHtml = editor => {\n      let iframeHTML = getDocType(editor) + '<html><head>';\n      if (getDocumentBaseUrl(editor) !== editor.documentBaseUrl) {\n        iframeHTML += '<base href=\"' + editor.documentBaseURI.getURI() + '\" />';\n      }\n      iframeHTML += '<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" />';\n      const bodyId = getBodyId(editor);\n      const bodyClass = getBodyClass(editor);\n      const translatedAriaText = editor.translate(getIframeAriaText(editor));\n      if (getContentSecurityPolicy(editor)) {\n        iframeHTML += '<meta http-equiv=\"Content-Security-Policy\" content=\"' + getContentSecurityPolicy(editor) + '\" />';\n      }\n      iframeHTML += '</head>' + `<body id=\"${ bodyId }\" class=\"mce-content-body ${ bodyClass }\" data-id=\"${ editor.id }\" aria-label=\"${ translatedAriaText }\">` + '<br>' + '</body></html>';\n      return iframeHTML;\n    };\n    const createIframe = (editor, boxInfo) => {\n      const iframeTitle = editor.translate('Rich Text Area');\n      const tabindex = getOpt(SugarElement.fromDom(editor.getElement()), 'tabindex').bind(toInt);\n      const ifr = createIframeElement(editor.id, iframeTitle, getIframeAttrs(editor), tabindex).dom;\n      ifr.onload = () => {\n        ifr.onload = null;\n        editor.dispatch('load');\n      };\n      editor.contentAreaContainer = boxInfo.iframeContainer;\n      editor.iframeElement = ifr;\n      editor.iframeHTML = getIframeHtml(editor);\n      DOM$5.add(boxInfo.iframeContainer, ifr);\n    };\n    const init$1 = (editor, boxInfo) => {\n      createIframe(editor, boxInfo);\n      if (boxInfo.editorContainer) {\n        DOM$5.get(boxInfo.editorContainer).style.display = editor.orgDisplay;\n        editor.hidden = DOM$5.isHidden(boxInfo.editorContainer);\n      }\n      editor.getElement().style.display = 'none';\n      DOM$5.setAttrib(editor.id, 'aria-hidden', 'true');\n      initContentBody(editor);\n    };\n\n    const DOM$4 = DOMUtils.DOM;\n    const initPlugin = (editor, initializedPlugins, plugin) => {\n      const Plugin = PluginManager.get(plugin);\n      const pluginUrl = PluginManager.urls[plugin] || editor.documentBaseUrl.replace(/\\/$/, '');\n      plugin = Tools.trim(plugin);\n      if (Plugin && Tools.inArray(initializedPlugins, plugin) === -1) {\n        if (editor.plugins[plugin]) {\n          return;\n        }\n        try {\n          const pluginInstance = Plugin(editor, pluginUrl) || {};\n          editor.plugins[plugin] = pluginInstance;\n          if (isFunction(pluginInstance.init)) {\n            pluginInstance.init(editor, pluginUrl);\n            initializedPlugins.push(plugin);\n          }\n        } catch (e) {\n          pluginInitError(editor, plugin, e);\n        }\n      }\n    };\n    const trimLegacyPrefix = name => {\n      return name.replace(/^\\-/, '');\n    };\n    const initPlugins = editor => {\n      const initializedPlugins = [];\n      each$g(getPlugins(editor), name => {\n        initPlugin(editor, initializedPlugins, trimLegacyPrefix(name));\n      });\n    };\n    const initIcons = editor => {\n      const iconPackName = Tools.trim(getIconPackName(editor));\n      const currentIcons = editor.ui.registry.getAll().icons;\n      const loadIcons = {\n        ...IconManager.get('default').icons,\n        ...IconManager.get(iconPackName).icons\n      };\n      each$f(loadIcons, (svgData, icon) => {\n        if (!has$2(currentIcons, icon)) {\n          editor.ui.registry.addIcon(icon, svgData);\n        }\n      });\n    };\n    const initTheme = editor => {\n      const theme = getTheme(editor);\n      if (isString(theme)) {\n        const Theme = ThemeManager.get(theme);\n        editor.theme = Theme(editor, ThemeManager.urls[theme]) || {};\n        if (isFunction(editor.theme.init)) {\n          editor.theme.init(editor, ThemeManager.urls[theme] || editor.documentBaseUrl.replace(/\\/$/, ''));\n        }\n      } else {\n        editor.theme = {};\n      }\n    };\n    const initModel = editor => {\n      const model = getModel(editor);\n      const Model = ModelManager.get(model);\n      editor.model = Model(editor, ModelManager.urls[model]);\n    };\n    const renderFromLoadedTheme = editor => {\n      return editor.theme.renderUI();\n    };\n    const renderFromThemeFunc = editor => {\n      const elm = editor.getElement();\n      const theme = getTheme(editor);\n      const info = theme(editor, elm);\n      if (info.editorContainer.nodeType) {\n        info.editorContainer.id = info.editorContainer.id || editor.id + '_parent';\n      }\n      if (info.iframeContainer && info.iframeContainer.nodeType) {\n        info.iframeContainer.id = info.iframeContainer.id || editor.id + '_iframecontainer';\n      }\n      info.height = info.iframeHeight ? info.iframeHeight : elm.offsetHeight;\n      return info;\n    };\n    const createThemeFalseResult = element => {\n      return {\n        editorContainer: element,\n        iframeContainer: element,\n        api: {}\n      };\n    };\n    const renderThemeFalseIframe = targetElement => {\n      const iframeContainer = DOM$4.create('div');\n      DOM$4.insertAfter(iframeContainer, targetElement);\n      return createThemeFalseResult(iframeContainer);\n    };\n    const renderThemeFalse = editor => {\n      const targetElement = editor.getElement();\n      return editor.inline ? createThemeFalseResult(null) : renderThemeFalseIframe(targetElement);\n    };\n    const renderThemeUi = editor => {\n      const elm = editor.getElement();\n      editor.orgDisplay = elm.style.display;\n      if (isString(getTheme(editor))) {\n        return renderFromLoadedTheme(editor);\n      } else if (isFunction(getTheme(editor))) {\n        return renderFromThemeFunc(editor);\n      } else {\n        return renderThemeFalse(editor);\n      }\n    };\n    const augmentEditorUiApi = (editor, api) => {\n      const uiApiFacade = {\n        show: Optional.from(api.show).getOr(noop),\n        hide: Optional.from(api.hide).getOr(noop),\n        isEnabled: Optional.from(api.isEnabled).getOr(always),\n        setEnabled: state => {\n          if (!editor.mode.isReadOnly()) {\n            Optional.from(api.setEnabled).each(f => f(state));\n          }\n        }\n      };\n      editor.ui = {\n        ...editor.ui,\n        ...uiApiFacade\n      };\n    };\n    const init = editor => {\n      editor.dispatch('ScriptsLoaded');\n      initIcons(editor);\n      initTheme(editor);\n      initModel(editor);\n      initPlugins(editor);\n      const renderInfo = renderThemeUi(editor);\n      augmentEditorUiApi(editor, Optional.from(renderInfo.api).getOr({}));\n      const boxInfo = {\n        editorContainer: renderInfo.editorContainer,\n        iframeContainer: renderInfo.iframeContainer\n      };\n      editor.editorContainer = boxInfo.editorContainer ? boxInfo.editorContainer : null;\n      appendContentCssFromSettings(editor);\n      if (editor.inline) {\n        return initContentBody(editor);\n      } else {\n        return init$1(editor, boxInfo);\n      }\n    };\n\n    const DOM$3 = DOMUtils.DOM;\n    const hasSkipLoadPrefix = name => name.charAt(0) === '-';\n    const loadLanguage = (scriptLoader, editor) => {\n      const languageCode = getLanguageCode(editor);\n      const languageUrl = getLanguageUrl(editor);\n      if (I18n.hasCode(languageCode) === false && languageCode !== 'en') {\n        const url = isNotEmpty(languageUrl) ? languageUrl : `${ editor.editorManager.baseURL }/langs/${ languageCode }.js`;\n        scriptLoader.add(url).catch(() => {\n          languageLoadError(editor, url, languageCode);\n        });\n      }\n    };\n    const loadTheme = (editor, suffix) => {\n      const theme = getTheme(editor);\n      if (isString(theme) && !hasSkipLoadPrefix(theme) && !has$2(ThemeManager.urls, theme)) {\n        const themeUrl = getThemeUrl(editor);\n        const url = themeUrl ? editor.documentBaseURI.toAbsolute(themeUrl) : `themes/${ theme }/theme${ suffix }.js`;\n        ThemeManager.load(theme, url).catch(() => {\n          themeLoadError(editor, url, theme);\n        });\n      }\n    };\n    const loadModel = (editor, suffix) => {\n      const model = getModel(editor);\n      if (model !== 'plugin' && !has$2(ModelManager.urls, model)) {\n        const modelUrl = getModelUrl(editor);\n        const url = isString(modelUrl) ? editor.documentBaseURI.toAbsolute(modelUrl) : `models/${ model }/model${ suffix }.js`;\n        ModelManager.load(model, url).catch(() => {\n          modelLoadError(editor, url, model);\n        });\n      }\n    };\n    const getIconsUrlMetaFromUrl = editor => Optional.from(getIconsUrl(editor)).filter(isNotEmpty).map(url => ({\n      url,\n      name: Optional.none()\n    }));\n    const getIconsUrlMetaFromName = (editor, name, suffix) => Optional.from(name).filter(name => isNotEmpty(name) && !IconManager.has(name)).map(name => ({\n      url: `${ editor.editorManager.baseURL }/icons/${ name }/icons${ suffix }.js`,\n      name: Optional.some(name)\n    }));\n    const loadIcons = (scriptLoader, editor, suffix) => {\n      const defaultIconsUrl = getIconsUrlMetaFromName(editor, 'default', suffix);\n      const customIconsUrl = getIconsUrlMetaFromUrl(editor).orThunk(() => getIconsUrlMetaFromName(editor, getIconPackName(editor), ''));\n      each$g(cat([\n        defaultIconsUrl,\n        customIconsUrl\n      ]), urlMeta => {\n        scriptLoader.add(urlMeta.url).catch(() => {\n          iconsLoadError(editor, urlMeta.url, urlMeta.name.getOrUndefined());\n        });\n      });\n    };\n    const loadPlugins = (editor, suffix) => {\n      const loadPlugin = (name, url) => {\n        PluginManager.load(name, url).catch(() => {\n          pluginLoadError(editor, url, name);\n        });\n      };\n      each$f(getExternalPlugins$1(editor), (url, name) => {\n        loadPlugin(name, url);\n        editor.options.set('plugins', getPlugins(editor).concat(name));\n      });\n      each$g(getPlugins(editor), plugin => {\n        plugin = Tools.trim(plugin);\n        if (plugin && !PluginManager.urls[plugin] && !hasSkipLoadPrefix(plugin)) {\n          loadPlugin(plugin, `plugins/${ plugin }/plugin${ suffix }.js`);\n        }\n      });\n    };\n    const isThemeLoaded = editor => {\n      const theme = getTheme(editor);\n      return !isString(theme) || isNonNullable(ThemeManager.get(theme));\n    };\n    const isModelLoaded = editor => {\n      const model = getModel(editor);\n      return isNonNullable(ModelManager.get(model));\n    };\n    const loadScripts = (editor, suffix) => {\n      const scriptLoader = ScriptLoader.ScriptLoader;\n      const initEditor = () => {\n        if (!editor.removed && isThemeLoaded(editor) && isModelLoaded(editor)) {\n          init(editor);\n        }\n      };\n      loadTheme(editor, suffix);\n      loadModel(editor, suffix);\n      loadLanguage(scriptLoader, editor);\n      loadIcons(scriptLoader, editor, suffix);\n      loadPlugins(editor, suffix);\n      scriptLoader.loadQueue().then(initEditor, initEditor);\n    };\n    const getStyleSheetLoader = (element, editor) => instance.forElement(element, {\n      contentCssCors: hasContentCssCors(editor),\n      referrerPolicy: getReferrerPolicy(editor)\n    });\n    const render = editor => {\n      const id = editor.id;\n      I18n.setCode(getLanguageCode(editor));\n      const readyHandler = () => {\n        DOM$3.unbind(window, 'ready', readyHandler);\n        editor.render();\n      };\n      if (!EventUtils.Event.domLoaded) {\n        DOM$3.bind(window, 'ready', readyHandler);\n        return;\n      }\n      if (!editor.getElement()) {\n        return;\n      }\n      const element = SugarElement.fromDom(editor.getElement());\n      const snapshot = clone$4(element);\n      editor.on('remove', () => {\n        eachr(element.dom.attributes, attr => remove$a(element, attr.name));\n        setAll$1(element, snapshot);\n      });\n      editor.ui.styleSheetLoader = getStyleSheetLoader(element, editor);\n      if (!isInline(editor)) {\n        editor.orgVisibility = editor.getElement().style.visibility;\n        editor.getElement().style.visibility = 'hidden';\n      } else {\n        editor.inline = true;\n      }\n      const form = editor.getElement().form || DOM$3.getParent(id, 'form');\n      if (form) {\n        editor.formElement = form;\n        if (hasHiddenInput(editor) && !isTextareaOrInput(editor.getElement())) {\n          DOM$3.insertAfter(DOM$3.create('input', {\n            type: 'hidden',\n            name: id\n          }), id);\n          editor.hasHiddenInput = true;\n        }\n        editor.formEventDelegate = e => {\n          editor.dispatch(e.type, e);\n        };\n        DOM$3.bind(form, 'submit reset', editor.formEventDelegate);\n        editor.on('reset', () => {\n          editor.resetContent();\n        });\n        if (shouldPatchSubmit(editor) && !form.submit.nodeType && !form.submit.length && !form._mceOldSubmit) {\n          form._mceOldSubmit = form.submit;\n          form.submit = () => {\n            editor.editorManager.triggerSave();\n            editor.setDirty(false);\n            return form._mceOldSubmit(form);\n          };\n        }\n      }\n      editor.windowManager = WindowManager(editor);\n      editor.notificationManager = NotificationManager(editor);\n      if (isEncodingXml(editor)) {\n        editor.on('GetContent', e => {\n          if (e.save) {\n            e.content = DOM$3.encode(e.content);\n          }\n        });\n      }\n      if (shouldAddFormSubmitTrigger(editor)) {\n        editor.on('submit', () => {\n          if (editor.initialized) {\n            editor.save();\n          }\n        });\n      }\n      if (shouldAddUnloadTrigger(editor)) {\n        editor._beforeUnload = () => {\n          if (editor.initialized && !editor.destroyed && !editor.isHidden()) {\n            editor.save({\n              format: 'raw',\n              no_events: true,\n              set_dirty: false\n            });\n          }\n        };\n        editor.editorManager.on('BeforeUnload', editor._beforeUnload);\n      }\n      editor.editorManager.add(editor);\n      loadScripts(editor, editor.suffix);\n    };\n\n    const sectionResult = (sections, settings) => ({\n      sections: constant(sections),\n      options: constant(settings)\n    });\n    const deviceDetection = detect$2().deviceType;\n    const isPhone = deviceDetection.isPhone();\n    const isTablet = deviceDetection.isTablet();\n    const normalizePlugins = plugins => {\n      if (isNullable(plugins)) {\n        return [];\n      } else {\n        const pluginNames = isArray$1(plugins) ? plugins : plugins.split(/[ ,]/);\n        const trimmedPlugins = map$3(pluginNames, trim$3);\n        return filter$6(trimmedPlugins, isNotEmpty);\n      }\n    };\n    const extractSections = (keys, options) => {\n      const result = bifilter(options, (value, key) => {\n        return contains$2(keys, key);\n      });\n      return sectionResult(result.t, result.f);\n    };\n    const getSection = (sectionResult, name, defaults = {}) => {\n      const sections = sectionResult.sections();\n      const sectionOptions = get$a(sections, name).getOr({});\n      return Tools.extend({}, defaults, sectionOptions);\n    };\n    const hasSection = (sectionResult, name) => {\n      return has$2(sectionResult.sections(), name);\n    };\n    const getSectionConfig = (sectionResult, name) => {\n      return hasSection(sectionResult, name) ? sectionResult.sections()[name] : {};\n    };\n    const getMobileOverrideOptions = (mobileOptions, isPhone) => {\n      const defaultMobileOptions = {\n        table_grid: false,\n        object_resizing: false,\n        resize: false,\n        toolbar_mode: get$a(mobileOptions, 'toolbar_mode').getOr('scrolling'),\n        toolbar_sticky: false\n      };\n      const defaultPhoneOptions = { menubar: false };\n      return {\n        ...defaultMobileOptions,\n        ...isPhone ? defaultPhoneOptions : {}\n      };\n    };\n    const getExternalPlugins = (overrideOptions, options) => {\n      var _a;\n      const userDefinedExternalPlugins = (_a = options.external_plugins) !== null && _a !== void 0 ? _a : {};\n      if (overrideOptions && overrideOptions.external_plugins) {\n        return Tools.extend({}, overrideOptions.external_plugins, userDefinedExternalPlugins);\n      } else {\n        return userDefinedExternalPlugins;\n      }\n    };\n    const combinePlugins = (forcedPlugins, plugins) => {\n      return [].concat(normalizePlugins(forcedPlugins)).concat(normalizePlugins(plugins));\n    };\n    const getPlatformPlugins = (isMobileDevice, sectionResult, desktopPlugins, mobilePlugins) => {\n      if (isMobileDevice && hasSection(sectionResult, 'mobile')) {\n        return mobilePlugins;\n      } else {\n        return desktopPlugins;\n      }\n    };\n    const processPlugins = (isMobileDevice, sectionResult, defaultOverrideOptions, options) => {\n      const forcedPlugins = normalizePlugins(defaultOverrideOptions.forced_plugins);\n      const desktopPlugins = normalizePlugins(options.plugins);\n      const mobileConfig = getSectionConfig(sectionResult, 'mobile');\n      const mobilePlugins = mobileConfig.plugins ? normalizePlugins(mobileConfig.plugins) : desktopPlugins;\n      const platformPlugins = getPlatformPlugins(isMobileDevice, sectionResult, desktopPlugins, mobilePlugins);\n      const combinedPlugins = combinePlugins(forcedPlugins, platformPlugins);\n      return Tools.extend(options, {\n        forced_plugins: forcedPlugins,\n        plugins: combinedPlugins\n      });\n    };\n    const isOnMobile = (isMobileDevice, sectionResult) => {\n      return isMobileDevice && hasSection(sectionResult, 'mobile');\n    };\n    const combineOptions = (isMobileDevice, isPhone, defaultOptions, defaultOverrideOptions, options) => {\n      var _a;\n      const deviceOverrideOptions = isMobileDevice ? { mobile: getMobileOverrideOptions((_a = options.mobile) !== null && _a !== void 0 ? _a : {}, isPhone) } : {};\n      const sectionResult = extractSections(['mobile'], deepMerge(deviceOverrideOptions, options));\n      const extendedOptions = Tools.extend(defaultOptions, defaultOverrideOptions, sectionResult.options(), isOnMobile(isMobileDevice, sectionResult) ? getSection(sectionResult, 'mobile') : {}, { external_plugins: getExternalPlugins(defaultOverrideOptions, sectionResult.options()) });\n      return processPlugins(isMobileDevice, sectionResult, defaultOverrideOptions, extendedOptions);\n    };\n    const normalizeOptions = (defaultOverrideOptions, options) => combineOptions(isPhone || isTablet, isPhone, options, defaultOverrideOptions, options);\n\n    const addVisual = (editor, elm) => addVisual$1(editor, elm);\n\n    const registerExecCommands$3 = editor => {\n      const toggleFormat = (name, value) => {\n        editor.formatter.toggle(name, value);\n        editor.nodeChanged();\n      };\n      const toggleAlign = align => () => {\n        each$g('left,center,right,justify'.split(','), name => {\n          if (align !== name) {\n            editor.formatter.remove('align' + name);\n          }\n        });\n        if (align !== 'none') {\n          toggleFormat('align' + align);\n        }\n      };\n      editor.editorCommands.addCommands({\n        JustifyLeft: toggleAlign('left'),\n        JustifyCenter: toggleAlign('center'),\n        JustifyRight: toggleAlign('right'),\n        JustifyFull: toggleAlign('justify'),\n        JustifyNone: toggleAlign('none')\n      });\n    };\n    const registerQueryStateCommands$1 = editor => {\n      const alignStates = name => () => {\n        const selection = editor.selection;\n        const nodes = selection.isCollapsed() ? [editor.dom.getParent(selection.getNode(), editor.dom.isBlock)] : selection.getSelectedBlocks();\n        return exists(nodes, node => isNonNullable(editor.formatter.matchNode(node, name)));\n      };\n      editor.editorCommands.addCommands({\n        JustifyLeft: alignStates('alignleft'),\n        JustifyCenter: alignStates('aligncenter'),\n        JustifyRight: alignStates('alignright'),\n        JustifyFull: alignStates('alignjustify')\n      }, 'state');\n    };\n    const registerCommands$a = editor => {\n      registerExecCommands$3(editor);\n      registerQueryStateCommands$1(editor);\n    };\n\n    const registerCommands$9 = editor => {\n      editor.editorCommands.addCommands({\n        'Cut,Copy,Paste': command => {\n          const doc = editor.getDoc();\n          let failed;\n          try {\n            doc.execCommand(command);\n          } catch (ex) {\n            failed = true;\n          }\n          if (command === 'paste' && !doc.queryCommandEnabled(command)) {\n            failed = true;\n          }\n          if (failed || !doc.queryCommandSupported(command)) {\n            let msg = editor.translate(`Your browser doesn't support direct access to the clipboard. ` + 'Please use the Ctrl+X/C/V keyboard shortcuts instead.');\n            if (Env.os.isMacOS() || Env.os.isiOS()) {\n              msg = msg.replace(/Ctrl\\+/g, '\\u2318+');\n            }\n            editor.notificationManager.open({\n              text: msg,\n              type: 'error'\n            });\n          }\n        }\n      });\n    };\n\n    const trimOrPadLeftRight = (dom, rng, html) => {\n      const root = SugarElement.fromDom(dom.getRoot());\n      if (needsToBeNbspLeft(root, CaretPosition.fromRangeStart(rng))) {\n        html = html.replace(/^ /, '&nbsp;');\n      } else {\n        html = html.replace(/^&nbsp;/, ' ');\n      }\n      if (needsToBeNbspRight(root, CaretPosition.fromRangeEnd(rng))) {\n        html = html.replace(/(&nbsp;| )(<br( \\/)>)?$/, '&nbsp;');\n      } else {\n        html = html.replace(/&nbsp;(<br( \\/)?>)?$/, ' ');\n      }\n      return html;\n    };\n\n    const processValue$1 = value => {\n      if (typeof value !== 'string') {\n        const details = Tools.extend({\n          paste: value.paste,\n          data: { paste: value.paste }\n        }, value);\n        return {\n          content: value.content,\n          details\n        };\n      }\n      return {\n        content: value,\n        details: {}\n      };\n    };\n    const trimOrPad = (editor, value) => {\n      const selection = editor.selection;\n      const dom = editor.dom;\n      if (/^ | $/.test(value)) {\n        return trimOrPadLeftRight(dom, selection.getRng(), value);\n      } else {\n        return value;\n      }\n    };\n    const insertAtCaret = (editor, value) => {\n      const {content, details} = processValue$1(value);\n      preProcessSetContent(editor, {\n        content: trimOrPad(editor, content),\n        format: 'html',\n        set: false,\n        selection: true,\n        paste: details.paste\n      }).each(args => {\n        const insertedContent = insertContent$1(editor, args.content, details);\n        postProcessSetContent(editor, insertedContent, args);\n        editor.addVisual();\n      });\n    };\n\n    const registerCommands$8 = editor => {\n      editor.editorCommands.addCommands({\n        mceCleanup: () => {\n          const bm = editor.selection.getBookmark();\n          editor.setContent(editor.getContent());\n          editor.selection.moveToBookmark(bm);\n        },\n        insertImage: (_command, _ui, value) => {\n          insertAtCaret(editor, editor.dom.createHTML('img', { src: value }));\n        },\n        insertHorizontalRule: () => {\n          editor.execCommand('mceInsertContent', false, '<hr>');\n        },\n        insertText: (_command, _ui, value) => {\n          insertAtCaret(editor, editor.dom.encode(value));\n        },\n        insertHTML: (_command, _ui, value) => {\n          insertAtCaret(editor, value);\n        },\n        mceInsertContent: (_command, _ui, value) => {\n          insertAtCaret(editor, value);\n        },\n        mceSetContent: (_command, _ui, value) => {\n          editor.setContent(value);\n        },\n        mceReplaceContent: (_command, _ui, value) => {\n          editor.execCommand('mceInsertContent', false, value.replace(/\\{\\$selection\\}/g, editor.selection.getContent({ format: 'text' })));\n        },\n        mceNewDocument: () => {\n          editor.setContent('');\n        }\n      });\n    };\n\n    const legacyPropNames = {\n      'font-size': 'size',\n      'font-family': 'face'\n    };\n    const getSpecifiedFontProp = (propName, rootElm, elm) => {\n      const getProperty = elm => getRaw$1(elm, propName).orThunk(() => {\n        if (name(elm) === 'font') {\n          return get$a(legacyPropNames, propName).bind(legacyPropName => getOpt(elm, legacyPropName));\n        } else {\n          return Optional.none();\n        }\n      });\n      const isRoot = elm => eq(SugarElement.fromDom(rootElm), elm);\n      return closest$2(SugarElement.fromDom(elm), elm => getProperty(elm), isRoot);\n    };\n    const normalizeFontFamily = fontFamily => fontFamily.replace(/[\\'\\\"\\\\]/g, '').replace(/,\\s+/g, ',');\n    const getComputedFontProp = (propName, elm) => Optional.from(DOMUtils.DOM.getStyle(elm, propName, true));\n    const getFontProp = propName => (rootElm, elm) => Optional.from(elm).map(SugarElement.fromDom).filter(isElement$7).bind(element => getSpecifiedFontProp(propName, rootElm, element.dom).or(getComputedFontProp(propName, element.dom))).getOr('');\n    const getFontSize = getFontProp('font-size');\n    const getFontFamily = compose(normalizeFontFamily, getFontProp('font-family'));\n\n    const findFirstCaretElement = editor => firstPositionIn(editor.getBody()).map(caret => {\n      const container = caret.container();\n      return isText$8(container) ? container.parentNode : container;\n    });\n    const getCaretElement = editor => Optional.from(editor.selection.getRng()).bind(rng => {\n      const root = editor.getBody();\n      const atStartOfNode = rng.startContainer === root && rng.startOffset === 0;\n      return atStartOfNode ? Optional.none() : Optional.from(editor.selection.getStart(true));\n    });\n    const bindRange = (editor, binder) => getCaretElement(editor).orThunk(curry(findFirstCaretElement, editor)).map(SugarElement.fromDom).filter(isElement$7).bind(binder);\n    const mapRange = (editor, mapper) => bindRange(editor, compose1(Optional.some, mapper));\n\n    const fromFontSizeNumber = (editor, value) => {\n      if (/^[0-9.]+$/.test(value)) {\n        const fontSizeNumber = parseInt(value, 10);\n        if (fontSizeNumber >= 1 && fontSizeNumber <= 7) {\n          const fontSizes = getFontStyleValues(editor);\n          const fontClasses = getFontSizeClasses(editor);\n          if (fontClasses) {\n            return fontClasses[fontSizeNumber - 1] || value;\n          } else {\n            return fontSizes[fontSizeNumber - 1] || value;\n          }\n        } else {\n          return value;\n        }\n      } else {\n        return value;\n      }\n    };\n    const normalizeFontNames = font => {\n      const fonts = font.split(/\\s*,\\s*/);\n      return map$3(fonts, font => {\n        if (font.indexOf(' ') !== -1 && !(startsWith(font, '\"') || startsWith(font, `'`))) {\n          return `'${ font }'`;\n        } else {\n          return font;\n        }\n      }).join(',');\n    };\n    const fontNameAction = (editor, value) => {\n      const font = fromFontSizeNumber(editor, value);\n      editor.formatter.toggle('fontname', { value: normalizeFontNames(font) });\n      editor.nodeChanged();\n    };\n    const fontNameQuery = editor => mapRange(editor, elm => getFontFamily(editor.getBody(), elm.dom)).getOr('');\n    const fontSizeAction = (editor, value) => {\n      editor.formatter.toggle('fontsize', { value: fromFontSizeNumber(editor, value) });\n      editor.nodeChanged();\n    };\n    const fontSizeQuery = editor => mapRange(editor, elm => getFontSize(editor.getBody(), elm.dom)).getOr('');\n\n    const lineHeightQuery = editor => mapRange(editor, elm => {\n      const root = SugarElement.fromDom(editor.getBody());\n      const specifiedStyle = closest$2(elm, elm => getRaw$1(elm, 'line-height'), curry(eq, root));\n      const computedStyle = () => {\n        const lineHeight = parseFloat(get$7(elm, 'line-height'));\n        const fontSize = parseFloat(get$7(elm, 'font-size'));\n        return String(lineHeight / fontSize);\n      };\n      return specifiedStyle.getOrThunk(computedStyle);\n    }).getOr('');\n    const lineHeightAction = (editor, lineHeight) => {\n      editor.formatter.toggle('lineheight', { value: String(lineHeight) });\n      editor.nodeChanged();\n    };\n\n    const registerExecCommands$2 = editor => {\n      const toggleFormat = (name, value) => {\n        editor.formatter.toggle(name, value);\n        editor.nodeChanged();\n      };\n      editor.editorCommands.addCommands({\n        'Bold,Italic,Underline,Strikethrough,Superscript,Subscript': command => {\n          toggleFormat(command);\n        },\n        'ForeColor,HiliteColor': (command, _ui, value) => {\n          toggleFormat(command, { value });\n        },\n        'BackColor': (_command, _ui, value) => {\n          toggleFormat('hilitecolor', { value });\n        },\n        'FontName': (_command, _ui, value) => {\n          fontNameAction(editor, value);\n        },\n        'FontSize': (_command, _ui, value) => {\n          fontSizeAction(editor, value);\n        },\n        'LineHeight': (_command, _ui, value) => {\n          lineHeightAction(editor, value);\n        },\n        'Lang': (command, _ui, lang) => {\n          toggleFormat(command, {\n            value: lang.code,\n            customValue: lang.customCode\n          });\n        },\n        'RemoveFormat': command => {\n          editor.formatter.remove(command);\n        },\n        'mceBlockQuote': () => {\n          toggleFormat('blockquote');\n        },\n        'FormatBlock': (_command, _ui, value) => {\n          toggleFormat(isString(value) ? value : 'p');\n        },\n        'mceToggleFormat': (_command, _ui, value) => {\n          toggleFormat(value);\n        }\n      });\n    };\n    const registerQueryValueCommands = editor => {\n      const isFormatMatch = name => editor.formatter.match(name);\n      editor.editorCommands.addCommands({\n        'Bold,Italic,Underline,Strikethrough,Superscript,Subscript': command => isFormatMatch(command),\n        'mceBlockQuote': () => isFormatMatch('blockquote')\n      }, 'state');\n      editor.editorCommands.addQueryValueHandler('FontName', () => fontNameQuery(editor));\n      editor.editorCommands.addQueryValueHandler('FontSize', () => fontSizeQuery(editor));\n      editor.editorCommands.addQueryValueHandler('LineHeight', () => lineHeightQuery(editor));\n    };\n    const registerCommands$7 = editor => {\n      registerExecCommands$2(editor);\n      registerQueryValueCommands(editor);\n    };\n\n    const registerCommands$6 = editor => {\n      editor.editorCommands.addCommands({\n        mceAddUndoLevel: () => {\n          editor.undoManager.add();\n        },\n        mceEndUndoLevel: () => {\n          editor.undoManager.add();\n        },\n        Undo: () => {\n          editor.undoManager.undo();\n        },\n        Redo: () => {\n          editor.undoManager.redo();\n        }\n      });\n    };\n\n    const registerCommands$5 = editor => {\n      editor.editorCommands.addCommands({\n        Indent: () => {\n          indent(editor);\n        },\n        Outdent: () => {\n          outdent(editor);\n        }\n      });\n      editor.editorCommands.addCommands({ Outdent: () => canOutdent(editor) }, 'state');\n    };\n\n    const registerCommands$4 = editor => {\n      const applyLinkToSelection = (_command, _ui, value) => {\n        const linkDetails = isString(value) ? { href: value } : value;\n        const anchor = editor.dom.getParent(editor.selection.getNode(), 'a');\n        if (isObject(linkDetails) && isString(linkDetails.href)) {\n          linkDetails.href = linkDetails.href.replace(/ /g, '%20');\n          if (!anchor || !linkDetails.href) {\n            editor.formatter.remove('link');\n          }\n          if (linkDetails.href) {\n            editor.formatter.apply('link', linkDetails, anchor);\n          }\n        }\n      };\n      editor.editorCommands.addCommands({\n        unlink: () => {\n          if (editor.selection.isCollapsed()) {\n            const elm = editor.dom.getParent(editor.selection.getStart(), 'a');\n            if (elm) {\n              editor.dom.remove(elm, true);\n            }\n            return;\n          }\n          editor.formatter.remove('link');\n        },\n        mceInsertLink: applyLinkToSelection,\n        createLink: applyLinkToSelection\n      });\n    };\n\n    const registerExecCommands$1 = editor => {\n      editor.editorCommands.addCommands({\n        'InsertUnorderedList,InsertOrderedList': command => {\n          editor.getDoc().execCommand(command);\n          const listElm = editor.dom.getParent(editor.selection.getNode(), 'ol,ul');\n          if (listElm) {\n            const listParent = listElm.parentNode;\n            if (/^(H[1-6]|P|ADDRESS|PRE)$/.test(listParent.nodeName)) {\n              const bm = editor.selection.getBookmark();\n              editor.dom.split(listParent, listElm);\n              editor.selection.moveToBookmark(bm);\n            }\n          }\n        }\n      });\n    };\n    const registerQueryStateCommands = editor => {\n      editor.editorCommands.addCommands({\n        'InsertUnorderedList,InsertOrderedList': command => {\n          const list = editor.dom.getParent(editor.selection.getNode(), 'ul,ol');\n          return list && (command === 'insertunorderedlist' && list.tagName === 'UL' || command === 'insertorderedlist' && list.tagName === 'OL');\n        }\n      }, 'state');\n    };\n    const registerCommands$3 = editor => {\n      registerExecCommands$1(editor);\n      registerQueryStateCommands(editor);\n    };\n\n    const registerCommands$2 = editor => {\n      editor.editorCommands.addCommands({\n        insertParagraph: () => {\n          insert(editor);\n        },\n        mceInsertNewLine: (_command, _ui, value) => {\n          insert(editor, value);\n        },\n        InsertLineBreak: (_command, _ui, value) => {\n          insert$1(editor, value);\n        }\n      });\n    };\n\n    const registerCommands$1 = editor => {\n      editor.editorCommands.addCommands({\n        mceSelectNodeDepth: (_command, _ui, value) => {\n          let counter = 0;\n          editor.dom.getParent(editor.selection.getNode(), node => {\n            if (node.nodeType === 1 && counter++ === value) {\n              editor.selection.select(node);\n              return false;\n            }\n          }, editor.getBody());\n        },\n        mceSelectNode: (_command, _ui, value) => {\n          editor.selection.select(value);\n        },\n        selectAll: () => {\n          const editingHost = editor.dom.getParent(editor.selection.getStart(), isContentEditableTrue$4);\n          if (editingHost) {\n            const rng = editor.dom.createRng();\n            rng.selectNodeContents(editingHost);\n            editor.selection.setRng(rng);\n          }\n        }\n      });\n    };\n\n    const registerExecCommands = editor => {\n      editor.editorCommands.addCommands({\n        mceRemoveNode: (_command, _ui, value) => {\n          const node = value !== null && value !== void 0 ? value : editor.selection.getNode();\n          if (node !== editor.getBody()) {\n            const bm = editor.selection.getBookmark();\n            editor.dom.remove(node, true);\n            editor.selection.moveToBookmark(bm);\n          }\n        },\n        mcePrint: () => {\n          editor.getWin().print();\n        },\n        mceFocus: (_command, _ui, value) => {\n          focus(editor, value);\n        },\n        mceToggleVisualAid: () => {\n          editor.hasVisual = !editor.hasVisual;\n          editor.addVisual();\n        }\n      });\n    };\n    const registerCommands = editor => {\n      registerCommands$a(editor);\n      registerCommands$9(editor);\n      registerCommands$6(editor);\n      registerCommands$1(editor);\n      registerCommands$8(editor);\n      registerCommands$4(editor);\n      registerCommands$5(editor);\n      registerCommands$2(editor);\n      registerCommands$3(editor);\n      registerCommands$7(editor);\n      registerExecCommands(editor);\n    };\n\n    class EditorCommands {\n      constructor(editor) {\n        this.commands = {\n          state: {},\n          exec: {},\n          value: {}\n        };\n        this.editor = editor;\n      }\n      execCommand(command, ui, value, args) {\n        const editor = this.editor;\n        const lowerCaseCommand = command.toLowerCase();\n        const skipFocus = args === null || args === void 0 ? void 0 : args.skip_focus;\n        if (editor.removed) {\n          return false;\n        }\n        if (lowerCaseCommand !== 'mcefocus') {\n          if (!/^(mceAddUndoLevel|mceEndUndoLevel)$/i.test(lowerCaseCommand) && !skipFocus) {\n            editor.focus();\n          } else {\n            restore(editor);\n          }\n        }\n        const eventArgs = editor.dispatch('BeforeExecCommand', {\n          command,\n          ui,\n          value\n        });\n        if (eventArgs.isDefaultPrevented()) {\n          return false;\n        }\n        const func = this.commands.exec[lowerCaseCommand];\n        if (isFunction(func)) {\n          func(lowerCaseCommand, ui, value);\n          editor.dispatch('ExecCommand', {\n            command,\n            ui,\n            value\n          });\n          return true;\n        }\n        return false;\n      }\n      queryCommandState(command) {\n        if (this.editor.quirks.isHidden() || this.editor.removed) {\n          return false;\n        }\n        const lowerCaseCommand = command.toLowerCase();\n        const func = this.commands.state[lowerCaseCommand];\n        if (isFunction(func)) {\n          return func(lowerCaseCommand);\n        }\n        return false;\n      }\n      queryCommandValue(command) {\n        if (this.editor.quirks.isHidden() || this.editor.removed) {\n          return '';\n        }\n        const lowerCaseCommand = command.toLowerCase();\n        const func = this.commands.value[lowerCaseCommand];\n        if (isFunction(func)) {\n          return func(lowerCaseCommand);\n        }\n        return '';\n      }\n      addCommands(commandList, type = 'exec') {\n        const commands = this.commands;\n        each$f(commandList, (callback, command) => {\n          each$g(command.toLowerCase().split(','), command => {\n            commands[type][command] = callback;\n          });\n        });\n      }\n      addCommand(command, callback, scope) {\n        const lowerCaseCommand = command.toLowerCase();\n        this.commands.exec[lowerCaseCommand] = (_command, ui, value) => callback.call(scope !== null && scope !== void 0 ? scope : this.editor, ui, value);\n      }\n      queryCommandSupported(command) {\n        const lowerCaseCommand = command.toLowerCase();\n        if (this.commands.exec[lowerCaseCommand]) {\n          return true;\n        }\n        return false;\n      }\n      addQueryStateHandler(command, callback, scope) {\n        this.commands.state[command.toLowerCase()] = () => callback.call(scope !== null && scope !== void 0 ? scope : this.editor);\n      }\n      addQueryValueHandler(command, callback, scope) {\n        this.commands.value[command.toLowerCase()] = () => callback.call(scope !== null && scope !== void 0 ? scope : this.editor);\n      }\n    }\n\n    const internalContentEditableAttr = 'data-mce-contenteditable';\n    const toggleClass = (elm, cls, state) => {\n      if (has(elm, cls) && state === false) {\n        remove$7(elm, cls);\n      } else if (state) {\n        add$2(elm, cls);\n      }\n    };\n    const setEditorCommandState = (editor, cmd, state) => {\n      try {\n        editor.getDoc().execCommand(cmd, false, String(state));\n      } catch (ex) {\n      }\n    };\n    const setContentEditable = (elm, state) => {\n      elm.dom.contentEditable = state ? 'true' : 'false';\n    };\n    const switchOffContentEditableTrue = elm => {\n      each$g(descendants(elm, '*[contenteditable=\"true\"]'), elm => {\n        set$2(elm, internalContentEditableAttr, 'true');\n        setContentEditable(elm, false);\n      });\n    };\n    const switchOnContentEditableTrue = elm => {\n      each$g(descendants(elm, `*[${ internalContentEditableAttr }=\"true\"]`), elm => {\n        remove$a(elm, internalContentEditableAttr);\n        setContentEditable(elm, true);\n      });\n    };\n    const removeFakeSelection = editor => {\n      Optional.from(editor.selection.getNode()).each(elm => {\n        elm.removeAttribute('data-mce-selected');\n      });\n    };\n    const restoreFakeSelection = editor => {\n      editor.selection.setRng(editor.selection.getRng());\n    };\n    const toggleReadOnly = (editor, state) => {\n      const body = SugarElement.fromDom(editor.getBody());\n      toggleClass(body, 'mce-content-readonly', state);\n      if (state) {\n        editor.selection.controlSelection.hideResizeRect();\n        editor._selectionOverrides.hideFakeCaret();\n        removeFakeSelection(editor);\n        editor.readonly = true;\n        setContentEditable(body, false);\n        switchOffContentEditableTrue(body);\n      } else {\n        editor.readonly = false;\n        setContentEditable(body, true);\n        switchOnContentEditableTrue(body);\n        setEditorCommandState(editor, 'StyleWithCSS', false);\n        setEditorCommandState(editor, 'enableInlineTableEditing', false);\n        setEditorCommandState(editor, 'enableObjectResizing', false);\n        if (hasEditorOrUiFocus(editor)) {\n          editor.focus();\n        }\n        restoreFakeSelection(editor);\n        editor.nodeChanged();\n      }\n    };\n    const isReadOnly = editor => editor.readonly;\n    const registerFilters = editor => {\n      editor.parser.addAttributeFilter('contenteditable', nodes => {\n        if (isReadOnly(editor)) {\n          each$g(nodes, node => {\n            node.attr(internalContentEditableAttr, node.attr('contenteditable'));\n            node.attr('contenteditable', 'false');\n          });\n        }\n      });\n      editor.serializer.addAttributeFilter(internalContentEditableAttr, nodes => {\n        if (isReadOnly(editor)) {\n          each$g(nodes, node => {\n            node.attr('contenteditable', node.attr(internalContentEditableAttr));\n          });\n        }\n      });\n      editor.serializer.addTempAttr(internalContentEditableAttr);\n    };\n    const registerReadOnlyContentFilters = editor => {\n      if (editor.serializer) {\n        registerFilters(editor);\n      } else {\n        editor.on('PreInit', () => {\n          registerFilters(editor);\n        });\n      }\n    };\n    const isClickEvent = e => e.type === 'click';\n    const getAnchorHrefOpt = (editor, elm) => {\n      const isRoot = elm => eq(elm, SugarElement.fromDom(editor.getBody()));\n      return closest$3(elm, 'a', isRoot).bind(a => getOpt(a, 'href'));\n    };\n    const processReadonlyEvents = (editor, e) => {\n      if (isClickEvent(e) && !VK.metaKeyPressed(e)) {\n        const elm = SugarElement.fromDom(e.target);\n        getAnchorHrefOpt(editor, elm).each(href => {\n          e.preventDefault();\n          if (/^#/.test(href)) {\n            const targetEl = editor.dom.select(`${ href },[name=\"${ removeLeading(href, '#') }\"]`);\n            if (targetEl.length) {\n              editor.selection.scrollIntoView(targetEl[0], true);\n            }\n          } else {\n            window.open(href, '_blank', 'rel=noopener noreferrer,menubar=yes,toolbar=yes,location=yes,status=yes,resizable=yes,scrollbars=yes');\n          }\n        });\n      }\n    };\n    const registerReadOnlySelectionBlockers = editor => {\n      editor.on('ShowCaret', e => {\n        if (isReadOnly(editor)) {\n          e.preventDefault();\n        }\n      });\n      editor.on('ObjectSelected', e => {\n        if (isReadOnly(editor)) {\n          e.preventDefault();\n        }\n      });\n    };\n\n    const nativeEvents = Tools.makeMap('focus blur focusin focusout click dblclick mousedown mouseup mousemove mouseover beforepaste paste cut copy selectionchange ' + 'mouseout mouseenter mouseleave wheel keydown keypress keyup input beforeinput contextmenu dragstart dragend dragover ' + 'draggesture dragdrop drop drag submit ' + 'compositionstart compositionend compositionupdate touchstart touchmove touchend touchcancel', ' ');\n    class EventDispatcher {\n      constructor(settings) {\n        this.bindings = {};\n        this.settings = settings || {};\n        this.scope = this.settings.scope || this;\n        this.toggleEvent = this.settings.toggleEvent || never;\n      }\n      static isNative(name) {\n        return !!nativeEvents[name.toLowerCase()];\n      }\n      fire(name, args) {\n        return this.dispatch(name, args);\n      }\n      dispatch(name, args) {\n        const lcName = name.toLowerCase();\n        const event = normalize$3(lcName, args !== null && args !== void 0 ? args : {}, this.scope);\n        if (this.settings.beforeFire) {\n          this.settings.beforeFire(event);\n        }\n        const handlers = this.bindings[lcName];\n        if (handlers) {\n          for (let i = 0, l = handlers.length; i < l; i++) {\n            const callback = handlers[i];\n            if (callback.removed) {\n              continue;\n            }\n            if (callback.once) {\n              this.off(lcName, callback.func);\n            }\n            if (event.isImmediatePropagationStopped()) {\n              return event;\n            }\n            if (callback.func.call(this.scope, event) === false) {\n              event.preventDefault();\n              return event;\n            }\n          }\n        }\n        return event;\n      }\n      on(name, callback, prepend, extra) {\n        if (callback === false) {\n          callback = never;\n        }\n        if (callback) {\n          const wrappedCallback = {\n            func: callback,\n            removed: false\n          };\n          if (extra) {\n            Tools.extend(wrappedCallback, extra);\n          }\n          const names = name.toLowerCase().split(' ');\n          let i = names.length;\n          while (i--) {\n            const currentName = names[i];\n            let handlers = this.bindings[currentName];\n            if (!handlers) {\n              handlers = [];\n              this.toggleEvent(currentName, true);\n            }\n            if (prepend) {\n              handlers = [\n                wrappedCallback,\n                ...handlers\n              ];\n            } else {\n              handlers = [\n                ...handlers,\n                wrappedCallback\n              ];\n            }\n            this.bindings[currentName] = handlers;\n          }\n        }\n        return this;\n      }\n      off(name, callback) {\n        if (name) {\n          const names = name.toLowerCase().split(' ');\n          let i = names.length;\n          while (i--) {\n            const currentName = names[i];\n            let handlers = this.bindings[currentName];\n            if (!currentName) {\n              each$f(this.bindings, (_value, bindingName) => {\n                this.toggleEvent(bindingName, false);\n                delete this.bindings[bindingName];\n              });\n              return this;\n            }\n            if (handlers) {\n              if (!callback) {\n                handlers.length = 0;\n              } else {\n                const filteredHandlers = partition$2(handlers, handler => handler.func === callback);\n                handlers = filteredHandlers.fail;\n                this.bindings[currentName] = handlers;\n                each$g(filteredHandlers.pass, handler => {\n                  handler.removed = true;\n                });\n              }\n              if (!handlers.length) {\n                this.toggleEvent(name, false);\n                delete this.bindings[currentName];\n              }\n            }\n          }\n        } else {\n          each$f(this.bindings, (_value, name) => {\n            this.toggleEvent(name, false);\n          });\n          this.bindings = {};\n        }\n        return this;\n      }\n      once(name, callback, prepend) {\n        return this.on(name, callback, prepend, { once: true });\n      }\n      has(name) {\n        name = name.toLowerCase();\n        return !(!this.bindings[name] || this.bindings[name].length === 0);\n      }\n    }\n\n    const getEventDispatcher = obj => {\n      if (!obj._eventDispatcher) {\n        obj._eventDispatcher = new EventDispatcher({\n          scope: obj,\n          toggleEvent: (name, state) => {\n            if (EventDispatcher.isNative(name) && obj.toggleNativeEvent) {\n              obj.toggleNativeEvent(name, state);\n            }\n          }\n        });\n      }\n      return obj._eventDispatcher;\n    };\n    const Observable = {\n      fire(name, args, bubble) {\n        return this.dispatch(name, args, bubble);\n      },\n      dispatch(name, args, bubble) {\n        const self = this;\n        if (self.removed && name !== 'remove' && name !== 'detach') {\n          return normalize$3(name.toLowerCase(), args !== null && args !== void 0 ? args : {}, self);\n        }\n        const dispatcherArgs = getEventDispatcher(self).dispatch(name, args);\n        if (bubble !== false && self.parent) {\n          let parent = self.parent();\n          while (parent && !dispatcherArgs.isPropagationStopped()) {\n            parent.dispatch(name, dispatcherArgs, false);\n            parent = parent.parent();\n          }\n        }\n        return dispatcherArgs;\n      },\n      on(name, callback, prepend) {\n        return getEventDispatcher(this).on(name, callback, prepend);\n      },\n      off(name, callback) {\n        return getEventDispatcher(this).off(name, callback);\n      },\n      once(name, callback) {\n        return getEventDispatcher(this).once(name, callback);\n      },\n      hasEventListeners(name) {\n        return getEventDispatcher(this).has(name);\n      }\n    };\n\n    const DOM$2 = DOMUtils.DOM;\n    let customEventRootDelegates;\n    const getEventTarget = (editor, eventName) => {\n      if (eventName === 'selectionchange') {\n        return editor.getDoc();\n      }\n      if (!editor.inline && /^mouse|touch|click|contextmenu|drop|dragover|dragend/.test(eventName)) {\n        return editor.getDoc().documentElement;\n      }\n      const eventRoot = getEventRoot(editor);\n      if (eventRoot) {\n        if (!editor.eventRoot) {\n          editor.eventRoot = DOM$2.select(eventRoot)[0];\n        }\n        return editor.eventRoot;\n      }\n      return editor.getBody();\n    };\n    const isListening = editor => !editor.hidden && !isReadOnly(editor);\n    const fireEvent = (editor, eventName, e) => {\n      if (isListening(editor)) {\n        editor.dispatch(eventName, e);\n      } else if (isReadOnly(editor)) {\n        processReadonlyEvents(editor, e);\n      }\n    };\n    const bindEventDelegate = (editor, eventName) => {\n      let delegate;\n      if (!editor.delegates) {\n        editor.delegates = {};\n      }\n      if (editor.delegates[eventName] || editor.removed) {\n        return;\n      }\n      const eventRootElm = getEventTarget(editor, eventName);\n      if (getEventRoot(editor)) {\n        if (!customEventRootDelegates) {\n          customEventRootDelegates = {};\n          editor.editorManager.on('removeEditor', () => {\n            if (!editor.editorManager.activeEditor) {\n              if (customEventRootDelegates) {\n                each$f(customEventRootDelegates, (_value, name) => {\n                  editor.dom.unbind(getEventTarget(editor, name));\n                });\n                customEventRootDelegates = null;\n              }\n            }\n          });\n        }\n        if (customEventRootDelegates[eventName]) {\n          return;\n        }\n        delegate = e => {\n          const target = e.target;\n          const editors = editor.editorManager.get();\n          let i = editors.length;\n          while (i--) {\n            const body = editors[i].getBody();\n            if (body === target || DOM$2.isChildOf(target, body)) {\n              fireEvent(editors[i], eventName, e);\n            }\n          }\n        };\n        customEventRootDelegates[eventName] = delegate;\n        DOM$2.bind(eventRootElm, eventName, delegate);\n      } else {\n        delegate = e => {\n          fireEvent(editor, eventName, e);\n        };\n        DOM$2.bind(eventRootElm, eventName, delegate);\n        editor.delegates[eventName] = delegate;\n      }\n    };\n    const EditorObservable = {\n      ...Observable,\n      bindPendingEventDelegates() {\n        const self = this;\n        Tools.each(self._pendingNativeEvents, name => {\n          bindEventDelegate(self, name);\n        });\n      },\n      toggleNativeEvent(name, state) {\n        const self = this;\n        if (name === 'focus' || name === 'blur') {\n          return;\n        }\n        if (self.removed) {\n          return;\n        }\n        if (state) {\n          if (self.initialized) {\n            bindEventDelegate(self, name);\n          } else {\n            if (!self._pendingNativeEvents) {\n              self._pendingNativeEvents = [name];\n            } else {\n              self._pendingNativeEvents.push(name);\n            }\n          }\n        } else if (self.initialized) {\n          self.dom.unbind(getEventTarget(self, name), name, self.delegates[name]);\n          delete self.delegates[name];\n        }\n      },\n      unbindAllNativeEvents() {\n        const self = this;\n        const body = self.getBody();\n        const dom = self.dom;\n        if (self.delegates) {\n          each$f(self.delegates, (value, name) => {\n            self.dom.unbind(getEventTarget(self, name), name, value);\n          });\n          delete self.delegates;\n        }\n        if (!self.inline && body && dom) {\n          body.onload = null;\n          dom.unbind(self.getWin());\n          dom.unbind(self.getDoc());\n        }\n        if (dom) {\n          dom.unbind(body);\n          dom.unbind(self.getContainer());\n        }\n      }\n    };\n\n    const stringListProcessor = value => {\n      if (isString(value)) {\n        return {\n          value: value.split(/[ ,]/),\n          valid: true\n        };\n      } else if (isArrayOf(value, isString)) {\n        return {\n          value,\n          valid: true\n        };\n      } else {\n        return {\n          valid: false,\n          message: `The value must be a string[] or a comma/space separated string.`\n        };\n      }\n    };\n    const getBuiltInProcessor = type => {\n      const validator = (() => {\n        switch (type) {\n        case 'array':\n          return isArray$1;\n        case 'boolean':\n          return isBoolean;\n        case 'function':\n          return isFunction;\n        case 'number':\n          return isNumber;\n        case 'object':\n          return isObject;\n        case 'string':\n          return isString;\n        case 'string[]':\n          return stringListProcessor;\n        case 'object[]':\n          return val => isArrayOf(val, isObject);\n        case 'regexp':\n          return val => is$4(val, RegExp);\n        }\n      })();\n      return value => processValue(value, validator, `The value must be a ${ type }.`);\n    };\n    const isBuiltInSpec = spec => isString(spec.processor);\n    const getErrorMessage = (message, result) => {\n      const additionalText = isEmpty$3(result.message) ? '' : `. ${ result.message }`;\n      return message + additionalText;\n    };\n    const isValidResult = result => result.valid;\n    const processValue = (value, processor, message = '') => {\n      const result = processor(value);\n      if (isBoolean(result)) {\n        return result ? {\n          value: value,\n          valid: true\n        } : {\n          valid: false,\n          message\n        };\n      } else {\n        return result;\n      }\n    };\n    const processDefaultValue = (name, defaultValue, processor) => {\n      if (!isUndefined(defaultValue)) {\n        const result = processValue(defaultValue, processor);\n        if (isValidResult(result)) {\n          return result.value;\n        } else {\n          console.error(getErrorMessage(`Invalid default value passed for the \"${ name }\" option`, result));\n        }\n      }\n      return undefined;\n    };\n    const create$5 = (editor, initialOptions) => {\n      const registry = {};\n      const values = {};\n      const setValue = (name, value, processor) => {\n        const result = processValue(value, processor);\n        if (isValidResult(result)) {\n          values[name] = result.value;\n          return true;\n        } else {\n          console.warn(getErrorMessage(`Invalid value passed for the ${ name } option`, result));\n          return false;\n        }\n      };\n      const register = (name, spec) => {\n        const processor = isBuiltInSpec(spec) ? getBuiltInProcessor(spec.processor) : spec.processor;\n        const defaultValue = processDefaultValue(name, spec.default, processor);\n        registry[name] = {\n          ...spec,\n          default: defaultValue,\n          processor\n        };\n        const initValue = get$a(values, name).orThunk(() => get$a(initialOptions, name));\n        initValue.each(value => setValue(name, value, processor));\n      };\n      const isRegistered = name => has$2(registry, name);\n      const get = name => get$a(values, name).orThunk(() => get$a(registry, name).map(spec => spec.default)).getOrUndefined();\n      const set = (name, value) => {\n        if (!isRegistered(name)) {\n          console.warn(`\"${ name }\" is not a registered option. Ensure the option has been registered before setting a value.`);\n          return false;\n        } else {\n          const spec = registry[name];\n          if (spec.immutable) {\n            console.error(`\"${ name }\" is an immutable option and cannot be updated`);\n            return false;\n          } else {\n            return setValue(name, value, spec.processor);\n          }\n        }\n      };\n      const unset = name => {\n        const registered = isRegistered(name);\n        if (registered) {\n          delete values[name];\n        }\n        return registered;\n      };\n      const isSet = name => has$2(values, name);\n      return {\n        register,\n        isRegistered,\n        get,\n        set,\n        unset,\n        isSet\n      };\n    };\n\n    const defaultModes = [\n      'design',\n      'readonly'\n    ];\n    const switchToMode = (editor, activeMode, availableModes, mode) => {\n      const oldMode = availableModes[activeMode.get()];\n      const newMode = availableModes[mode];\n      try {\n        newMode.activate();\n      } catch (e) {\n        console.error(`problem while activating editor mode ${ mode }:`, e);\n        return;\n      }\n      oldMode.deactivate();\n      if (oldMode.editorReadOnly !== newMode.editorReadOnly) {\n        toggleReadOnly(editor, newMode.editorReadOnly);\n      }\n      activeMode.set(mode);\n      fireSwitchMode(editor, mode);\n    };\n    const setMode = (editor, availableModes, activeMode, mode) => {\n      if (mode === activeMode.get()) {\n        return;\n      } else if (!has$2(availableModes, mode)) {\n        throw new Error(`Editor mode '${ mode }' is invalid`);\n      }\n      if (editor.initialized) {\n        switchToMode(editor, activeMode, availableModes, mode);\n      } else {\n        editor.on('init', () => switchToMode(editor, activeMode, availableModes, mode));\n      }\n    };\n    const registerMode = (availableModes, mode, api) => {\n      if (contains$2(defaultModes, mode)) {\n        throw new Error(`Cannot override default mode ${ mode }`);\n      }\n      return {\n        ...availableModes,\n        [mode]: {\n          ...api,\n          deactivate: () => {\n            try {\n              api.deactivate();\n            } catch (e) {\n              console.error(`problem while deactivating editor mode ${ mode }:`, e);\n            }\n          }\n        }\n      };\n    };\n\n    const create$4 = editor => {\n      const activeMode = Cell('design');\n      const availableModes = Cell({\n        design: {\n          activate: noop,\n          deactivate: noop,\n          editorReadOnly: false\n        },\n        readonly: {\n          activate: noop,\n          deactivate: noop,\n          editorReadOnly: true\n        }\n      });\n      registerReadOnlyContentFilters(editor);\n      registerReadOnlySelectionBlockers(editor);\n      return {\n        isReadOnly: () => isReadOnly(editor),\n        set: mode => setMode(editor, availableModes.get(), activeMode, mode),\n        get: () => activeMode.get(),\n        register: (mode, api) => {\n          availableModes.set(registerMode(availableModes.get(), mode, api));\n        }\n      };\n    };\n\n    const each$2 = Tools.each, explode = Tools.explode;\n    const keyCodeLookup = {\n      f1: 112,\n      f2: 113,\n      f3: 114,\n      f4: 115,\n      f5: 116,\n      f6: 117,\n      f7: 118,\n      f8: 119,\n      f9: 120,\n      f10: 121,\n      f11: 122,\n      f12: 123\n    };\n    const modifierNames = Tools.makeMap('alt,ctrl,shift,meta,access');\n    const parseShortcut = pattern => {\n      let key;\n      const shortcut = {};\n      const isMac = Env.os.isMacOS() || Env.os.isiOS();\n      each$2(explode(pattern.toLowerCase(), '+'), value => {\n        if (value in modifierNames) {\n          shortcut[value] = true;\n        } else {\n          if (/^[0-9]{2,}$/.test(value)) {\n            shortcut.keyCode = parseInt(value, 10);\n          } else {\n            shortcut.charCode = value.charCodeAt(0);\n            shortcut.keyCode = keyCodeLookup[value] || value.toUpperCase().charCodeAt(0);\n          }\n        }\n      });\n      const id = [shortcut.keyCode];\n      for (key in modifierNames) {\n        if (shortcut[key]) {\n          id.push(key);\n        } else {\n          shortcut[key] = false;\n        }\n      }\n      shortcut.id = id.join(',');\n      if (shortcut.access) {\n        shortcut.alt = true;\n        if (isMac) {\n          shortcut.ctrl = true;\n        } else {\n          shortcut.shift = true;\n        }\n      }\n      if (shortcut.meta) {\n        if (isMac) {\n          shortcut.meta = true;\n        } else {\n          shortcut.ctrl = true;\n          shortcut.meta = false;\n        }\n      }\n      return shortcut;\n    };\n    class Shortcuts {\n      constructor(editor) {\n        this.shortcuts = {};\n        this.pendingPatterns = [];\n        this.editor = editor;\n        const self = this;\n        editor.on('keyup keypress keydown', e => {\n          if ((self.hasModifier(e) || self.isFunctionKey(e)) && !e.isDefaultPrevented()) {\n            each$2(self.shortcuts, shortcut => {\n              if (self.matchShortcut(e, shortcut)) {\n                self.pendingPatterns = shortcut.subpatterns.slice(0);\n                if (e.type === 'keydown') {\n                  self.executeShortcutAction(shortcut);\n                }\n                return true;\n              }\n            });\n            if (self.matchShortcut(e, self.pendingPatterns[0])) {\n              if (self.pendingPatterns.length === 1) {\n                if (e.type === 'keydown') {\n                  self.executeShortcutAction(self.pendingPatterns[0]);\n                }\n              }\n              self.pendingPatterns.shift();\n            }\n          }\n        });\n      }\n      add(pattern, desc, cmdFunc, scope) {\n        const self = this;\n        const func = self.normalizeCommandFunc(cmdFunc);\n        each$2(explode(Tools.trim(pattern)), pattern => {\n          const shortcut = self.createShortcut(pattern, desc, func, scope);\n          self.shortcuts[shortcut.id] = shortcut;\n        });\n        return true;\n      }\n      remove(pattern) {\n        const shortcut = this.createShortcut(pattern);\n        if (this.shortcuts[shortcut.id]) {\n          delete this.shortcuts[shortcut.id];\n          return true;\n        }\n        return false;\n      }\n      normalizeCommandFunc(cmdFunc) {\n        const self = this;\n        const cmd = cmdFunc;\n        if (typeof cmd === 'string') {\n          return () => {\n            self.editor.execCommand(cmd, false, null);\n          };\n        } else if (Tools.isArray(cmd)) {\n          return () => {\n            self.editor.execCommand(cmd[0], cmd[1], cmd[2]);\n          };\n        } else {\n          return cmd;\n        }\n      }\n      createShortcut(pattern, desc, cmdFunc, scope) {\n        const shortcuts = Tools.map(explode(pattern, '>'), parseShortcut);\n        shortcuts[shortcuts.length - 1] = Tools.extend(shortcuts[shortcuts.length - 1], {\n          func: cmdFunc,\n          scope: scope || this.editor\n        });\n        return Tools.extend(shortcuts[0], {\n          desc: this.editor.translate(desc),\n          subpatterns: shortcuts.slice(1)\n        });\n      }\n      hasModifier(e) {\n        return e.altKey || e.ctrlKey || e.metaKey;\n      }\n      isFunctionKey(e) {\n        return e.type === 'keydown' && e.keyCode >= 112 && e.keyCode <= 123;\n      }\n      matchShortcut(e, shortcut) {\n        if (!shortcut) {\n          return false;\n        }\n        if (shortcut.ctrl !== e.ctrlKey || shortcut.meta !== e.metaKey) {\n          return false;\n        }\n        if (shortcut.alt !== e.altKey || shortcut.shift !== e.shiftKey) {\n          return false;\n        }\n        if (e.keyCode === shortcut.keyCode || e.charCode && e.charCode === shortcut.charCode) {\n          e.preventDefault();\n          return true;\n        }\n        return false;\n      }\n      executeShortcutAction(shortcut) {\n        return shortcut.func ? shortcut.func.call(shortcut.scope) : null;\n      }\n    }\n\n    const create$3 = () => {\n      const buttons = {};\n      const menuItems = {};\n      const popups = {};\n      const icons = {};\n      const contextMenus = {};\n      const contextToolbars = {};\n      const sidebars = {};\n      const add = (collection, type) => (name, spec) => collection[name.toLowerCase()] = {\n        ...spec,\n        type\n      };\n      const addIcon = (name, svgData) => icons[name.toLowerCase()] = svgData;\n      return {\n        addButton: add(buttons, 'button'),\n        addGroupToolbarButton: add(buttons, 'grouptoolbarbutton'),\n        addToggleButton: add(buttons, 'togglebutton'),\n        addMenuButton: add(buttons, 'menubutton'),\n        addSplitButton: add(buttons, 'splitbutton'),\n        addMenuItem: add(menuItems, 'menuitem'),\n        addNestedMenuItem: add(menuItems, 'nestedmenuitem'),\n        addToggleMenuItem: add(menuItems, 'togglemenuitem'),\n        addAutocompleter: add(popups, 'autocompleter'),\n        addContextMenu: add(contextMenus, 'contextmenu'),\n        addContextToolbar: add(contextToolbars, 'contexttoolbar'),\n        addContextForm: add(contextToolbars, 'contextform'),\n        addSidebar: add(sidebars, 'sidebar'),\n        addIcon,\n        getAll: () => ({\n          buttons,\n          menuItems,\n          icons,\n          popups,\n          contextMenus,\n          contextToolbars,\n          sidebars\n        })\n      };\n    };\n\n    const registry = () => {\n      const bridge = create$3();\n      return {\n        addAutocompleter: bridge.addAutocompleter,\n        addButton: bridge.addButton,\n        addContextForm: bridge.addContextForm,\n        addContextMenu: bridge.addContextMenu,\n        addContextToolbar: bridge.addContextToolbar,\n        addIcon: bridge.addIcon,\n        addMenuButton: bridge.addMenuButton,\n        addMenuItem: bridge.addMenuItem,\n        addNestedMenuItem: bridge.addNestedMenuItem,\n        addSidebar: bridge.addSidebar,\n        addSplitButton: bridge.addSplitButton,\n        addToggleButton: bridge.addToggleButton,\n        addGroupToolbarButton: bridge.addGroupToolbarButton,\n        addToggleMenuItem: bridge.addToggleMenuItem,\n        getAll: bridge.getAll\n      };\n    };\n\n    const DOM$1 = DOMUtils.DOM;\n    const extend = Tools.extend, each$1 = Tools.each;\n    class Editor {\n      constructor(id, options, editorManager) {\n        this.plugins = {};\n        this.contentCSS = [];\n        this.contentStyles = [];\n        this.loadedCSS = {};\n        this.isNotDirty = false;\n        this.editorManager = editorManager;\n        this.documentBaseUrl = editorManager.documentBaseURL;\n        extend(this, EditorObservable);\n        const self = this;\n        this.id = id;\n        this.hidden = false;\n        const normalizedOptions = normalizeOptions(editorManager.defaultOptions, options);\n        this.options = create$5(self, normalizedOptions);\n        register$7(self);\n        const getOption = this.options.get;\n        if (getOption('deprecation_warnings')) {\n          logWarnings(options, normalizedOptions);\n        }\n        const suffix = getOption('suffix');\n        if (suffix) {\n          editorManager.suffix = suffix;\n        }\n        this.suffix = editorManager.suffix;\n        const baseUrl = getOption('base_url');\n        if (baseUrl) {\n          editorManager._setBaseUrl(baseUrl);\n        }\n        this.baseUri = editorManager.baseURI;\n        const referrerPolicy = getReferrerPolicy(self);\n        if (referrerPolicy) {\n          ScriptLoader.ScriptLoader._setReferrerPolicy(referrerPolicy);\n          DOMUtils.DOM.styleSheetLoader._setReferrerPolicy(referrerPolicy);\n        }\n        AddOnManager.languageLoad = getOption('language_load');\n        AddOnManager.baseURL = editorManager.baseURL;\n        this.setDirty(false);\n        this.documentBaseURI = new URI(getDocumentBaseUrl(self), { base_uri: this.baseUri });\n        this.baseURI = this.baseUri;\n        this.inline = isInline(self);\n        this.shortcuts = new Shortcuts(this);\n        this.editorCommands = new EditorCommands(this);\n        registerCommands(this);\n        const cacheSuffix = getOption('cache_suffix');\n        if (cacheSuffix) {\n          Env.cacheSuffix = cacheSuffix.replace(/^[\\?\\&]+/, '');\n        }\n        this.ui = {\n          registry: registry(),\n          styleSheetLoader: undefined,\n          show: noop,\n          hide: noop,\n          setEnabled: noop,\n          isEnabled: always\n        };\n        this.mode = create$4(self);\n        editorManager.dispatch('SetupEditor', { editor: this });\n        const setupCallback = getSetupCallback(self);\n        if (isFunction(setupCallback)) {\n          setupCallback.call(self, self);\n        }\n      }\n      render() {\n        render(this);\n      }\n      focus(skipFocus) {\n        this.execCommand('mceFocus', false, skipFocus);\n      }\n      hasFocus() {\n        return hasFocus(this);\n      }\n      translate(text) {\n        return I18n.translate(text);\n      }\n      getParam(name, defaultVal, type) {\n        const options = this.options;\n        if (!options.isRegistered(name)) {\n          if (isNonNullable(type)) {\n            options.register(name, {\n              processor: type,\n              default: defaultVal\n            });\n          } else {\n            options.register(name, {\n              processor: always,\n              default: defaultVal\n            });\n          }\n        }\n        return !options.isSet(name) && !isUndefined(defaultVal) ? defaultVal : options.get(name);\n      }\n      hasPlugin(name, loaded) {\n        const hasPlugin = contains$2(getPlugins(this), name);\n        if (hasPlugin) {\n          return loaded ? PluginManager.get(name) !== undefined : true;\n        } else {\n          return false;\n        }\n      }\n      nodeChanged(args) {\n        this._nodeChangeDispatcher.nodeChanged(args);\n      }\n      addCommand(name, callback, scope) {\n        this.editorCommands.addCommand(name, callback, scope);\n      }\n      addQueryStateHandler(name, callback, scope) {\n        this.editorCommands.addQueryStateHandler(name, callback, scope);\n      }\n      addQueryValueHandler(name, callback, scope) {\n        this.editorCommands.addQueryValueHandler(name, callback, scope);\n      }\n      addShortcut(pattern, desc, cmdFunc, scope) {\n        this.shortcuts.add(pattern, desc, cmdFunc, scope);\n      }\n      execCommand(cmd, ui, value, args) {\n        return this.editorCommands.execCommand(cmd, ui, value, args);\n      }\n      queryCommandState(cmd) {\n        return this.editorCommands.queryCommandState(cmd);\n      }\n      queryCommandValue(cmd) {\n        return this.editorCommands.queryCommandValue(cmd);\n      }\n      queryCommandSupported(cmd) {\n        return this.editorCommands.queryCommandSupported(cmd);\n      }\n      show() {\n        const self = this;\n        if (self.hidden) {\n          self.hidden = false;\n          if (self.inline) {\n            self.getBody().contentEditable = 'true';\n          } else {\n            DOM$1.show(self.getContainer());\n            DOM$1.hide(self.id);\n          }\n          self.load();\n          self.dispatch('show');\n        }\n      }\n      hide() {\n        const self = this;\n        if (!self.hidden) {\n          self.save();\n          if (self.inline) {\n            self.getBody().contentEditable = 'false';\n            if (self === self.editorManager.focusedEditor) {\n              self.editorManager.focusedEditor = null;\n            }\n          } else {\n            DOM$1.hide(self.getContainer());\n            DOM$1.setStyle(self.id, 'display', self.orgDisplay);\n          }\n          self.hidden = true;\n          self.dispatch('hide');\n        }\n      }\n      isHidden() {\n        return this.hidden;\n      }\n      setProgressState(state, time) {\n        this.dispatch('ProgressState', {\n          state,\n          time\n        });\n      }\n      load(args) {\n        const self = this;\n        let elm = self.getElement(), html;\n        if (self.removed) {\n          return '';\n        }\n        if (elm) {\n          args = args || {};\n          args.load = true;\n          const value = isTextareaOrInput(elm) ? elm.value : elm.innerHTML;\n          html = self.setContent(value, args);\n          args.element = elm;\n          if (!args.no_events) {\n            self.dispatch('LoadContent', args);\n          }\n          args.element = elm = null;\n          return html;\n        }\n      }\n      save(args) {\n        const self = this;\n        let elm = self.getElement(), html, form;\n        if (!elm || !self.initialized || self.removed) {\n          return;\n        }\n        args = args || {};\n        args.save = true;\n        args.element = elm;\n        html = args.content = self.getContent(args);\n        if (!args.no_events) {\n          self.dispatch('SaveContent', args);\n        }\n        if (args.format === 'raw') {\n          self.dispatch('RawSaveContent', args);\n        }\n        html = args.content;\n        if (!isTextareaOrInput(elm)) {\n          if (args.is_removing || !self.inline) {\n            elm.innerHTML = html;\n          }\n          if (form = DOM$1.getParent(self.id, 'form')) {\n            each$1(form.elements, elm => {\n              if (elm.name === self.id) {\n                elm.value = html;\n                return false;\n              }\n            });\n          }\n        } else {\n          elm.value = html;\n        }\n        args.element = elm = null;\n        if (args.set_dirty !== false) {\n          self.setDirty(false);\n        }\n        return html;\n      }\n      setContent(content, args) {\n        return setContent(this, content, args);\n      }\n      getContent(args) {\n        return getContent(this, args);\n      }\n      insertContent(content, args) {\n        if (args) {\n          content = extend({ content }, args);\n        }\n        this.execCommand('mceInsertContent', false, content);\n      }\n      resetContent(initialContent) {\n        if (initialContent === undefined) {\n          setContent(this, this.startContent, { format: 'raw' });\n        } else {\n          setContent(this, initialContent);\n        }\n        this.undoManager.reset();\n        this.setDirty(false);\n        this.nodeChanged();\n      }\n      isDirty() {\n        return !this.isNotDirty;\n      }\n      setDirty(state) {\n        const oldState = !this.isNotDirty;\n        this.isNotDirty = !state;\n        if (state && state !== oldState) {\n          this.dispatch('dirty');\n        }\n      }\n      getContainer() {\n        const self = this;\n        if (!self.container) {\n          self.container = DOM$1.get(self.editorContainer || self.id + '_parent');\n        }\n        return self.container;\n      }\n      getContentAreaContainer() {\n        return this.contentAreaContainer;\n      }\n      getElement() {\n        if (!this.targetElm) {\n          this.targetElm = DOM$1.get(this.id);\n        }\n        return this.targetElm;\n      }\n      getWin() {\n        const self = this;\n        let elm;\n        if (!self.contentWindow) {\n          elm = self.iframeElement;\n          if (elm) {\n            self.contentWindow = elm.contentWindow;\n          }\n        }\n        return self.contentWindow;\n      }\n      getDoc() {\n        const self = this;\n        let win;\n        if (!self.contentDocument) {\n          win = self.getWin();\n          if (win) {\n            self.contentDocument = win.document;\n          }\n        }\n        return self.contentDocument;\n      }\n      getBody() {\n        const doc = this.getDoc();\n        return this.bodyElement || (doc ? doc.body : null);\n      }\n      convertURL(url, name, elm) {\n        const self = this, getOption = self.options.get;\n        const urlConverterCallback = getUrlConverterCallback(self);\n        if (isFunction(urlConverterCallback)) {\n          return urlConverterCallback.call(self, url, elm, true, name);\n        }\n        if (!getOption('convert_urls') || elm && elm.nodeName === 'LINK' || url.indexOf('file:') === 0 || url.length === 0) {\n          return url;\n        }\n        if (getOption('relative_urls')) {\n          return self.documentBaseURI.toRelative(url);\n        }\n        url = self.documentBaseURI.toAbsolute(url, getOption('remove_script_host'));\n        return url;\n      }\n      addVisual(elm) {\n        addVisual(this, elm);\n      }\n      remove() {\n        remove$1(this);\n      }\n      destroy(automatic) {\n        destroy(this, automatic);\n      }\n      uploadImages() {\n        return this.editorUpload.uploadImages();\n      }\n      _scanForImages() {\n        return this.editorUpload.scanForImages();\n      }\n    }\n\n    const DOM = DOMUtils.DOM;\n    const each = Tools.each;\n    let boundGlobalEvents = false;\n    let beforeUnloadDelegate;\n    let editors = [];\n    const globalEventDelegate = e => {\n      const type = e.type;\n      each(EditorManager.get(), editor => {\n        switch (type) {\n        case 'scroll':\n          editor.dispatch('ScrollWindow', e);\n          break;\n        case 'resize':\n          editor.dispatch('ResizeWindow', e);\n          break;\n        }\n      });\n    };\n    const toggleGlobalEvents = state => {\n      if (state !== boundGlobalEvents) {\n        const DOM = DOMUtils.DOM;\n        if (state) {\n          DOM.bind(window, 'resize', globalEventDelegate);\n          DOM.bind(window, 'scroll', globalEventDelegate);\n        } else {\n          DOM.unbind(window, 'resize', globalEventDelegate);\n          DOM.unbind(window, 'scroll', globalEventDelegate);\n        }\n        boundGlobalEvents = state;\n      }\n    };\n    const removeEditorFromList = targetEditor => {\n      const oldEditors = editors;\n      editors = filter$6(editors, editor => {\n        return targetEditor !== editor;\n      });\n      if (EditorManager.activeEditor === targetEditor) {\n        EditorManager.activeEditor = editors.length > 0 ? editors[0] : null;\n      }\n      if (EditorManager.focusedEditor === targetEditor) {\n        EditorManager.focusedEditor = null;\n      }\n      return oldEditors.length !== editors.length;\n    };\n    const purgeDestroyedEditor = editor => {\n      if (editor && editor.initialized && !(editor.getContainer() || editor.getBody()).parentNode) {\n        removeEditorFromList(editor);\n        editor.unbindAllNativeEvents();\n        editor.destroy(true);\n        editor.removed = true;\n        editor = null;\n      }\n      return editor;\n    };\n    const isQuirksMode = document.compatMode !== 'CSS1Compat';\n    const EditorManager = {\n      ...Observable,\n      baseURI: null,\n      baseURL: null,\n      defaultOptions: {},\n      documentBaseURL: null,\n      suffix: null,\n      majorVersion: '6',\n      minorVersion: '0.3',\n      releaseDate: '2022-05-25',\n      i18n: I18n,\n      activeEditor: null,\n      focusedEditor: null,\n      setup() {\n        const self = this;\n        let baseURL, documentBaseURL, suffix = '';\n        documentBaseURL = URI.getDocumentBaseUrl(document.location);\n        if (/^[^:]+:\\/\\/\\/?[^\\/]+\\//.test(documentBaseURL)) {\n          documentBaseURL = documentBaseURL.replace(/[\\?#].*$/, '').replace(/[\\/\\\\][^\\/]+$/, '');\n          if (!/[\\/\\\\]$/.test(documentBaseURL)) {\n            documentBaseURL += '/';\n          }\n        }\n        const preInit = window.tinymce || window.tinyMCEPreInit;\n        if (preInit) {\n          baseURL = preInit.base || preInit.baseURL;\n          suffix = preInit.suffix;\n        } else {\n          const scripts = document.getElementsByTagName('script');\n          for (let i = 0; i < scripts.length; i++) {\n            const src = scripts[i].src || '';\n            if (src === '') {\n              continue;\n            }\n            const srcScript = src.substring(src.lastIndexOf('/'));\n            if (/tinymce(\\.full|\\.jquery|)(\\.min|\\.dev|)\\.js/.test(src)) {\n              if (srcScript.indexOf('.min') !== -1) {\n                suffix = '.min';\n              }\n              baseURL = src.substring(0, src.lastIndexOf('/'));\n              break;\n            }\n          }\n          if (!baseURL && document.currentScript) {\n            const src = document.currentScript.src;\n            if (src.indexOf('.min') !== -1) {\n              suffix = '.min';\n            }\n            baseURL = src.substring(0, src.lastIndexOf('/'));\n          }\n        }\n        self.baseURL = new URI(documentBaseURL).toAbsolute(baseURL);\n        self.documentBaseURL = documentBaseURL;\n        self.baseURI = new URI(self.baseURL);\n        self.suffix = suffix;\n        setup$v(self);\n      },\n      overrideDefaults(defaultOptions) {\n        const baseUrl = defaultOptions.base_url;\n        if (baseUrl) {\n          this._setBaseUrl(baseUrl);\n        }\n        const suffix = defaultOptions.suffix;\n        if (defaultOptions.suffix) {\n          this.suffix = suffix;\n        }\n        this.defaultOptions = defaultOptions;\n        const pluginBaseUrls = defaultOptions.plugin_base_urls;\n        if (pluginBaseUrls !== undefined) {\n          each$f(pluginBaseUrls, (pluginBaseUrl, pluginName) => {\n            AddOnManager.PluginManager.urls[pluginName] = pluginBaseUrl;\n          });\n        }\n      },\n      init(options) {\n        const self = this;\n        let result;\n        const invalidInlineTargets = Tools.makeMap('area base basefont br col frame hr img input isindex link meta param embed source wbr track ' + 'colgroup option table tbody tfoot thead tr th td script noscript style textarea video audio iframe object menu', ' ');\n        const isInvalidInlineTarget = (options, elm) => options.inline && elm.tagName.toLowerCase() in invalidInlineTargets;\n        const createId = elm => {\n          let id = elm.id;\n          if (!id) {\n            id = get$a(elm, 'name').filter(name => !DOM.get(name)).getOrThunk(DOM.uniqueId);\n            elm.setAttribute('id', id);\n          }\n          return id;\n        };\n        const execCallback = name => {\n          const callback = options[name];\n          if (!callback) {\n            return;\n          }\n          return callback.apply(self, []);\n        };\n        const findTargets = options => {\n          if (Env.browser.isIE() || Env.browser.isEdge()) {\n            initError('TinyMCE does not support the browser you are using. For a list of supported' + ' browsers please see: https://www.tiny.cloud/docs/tinymce/6/support/#supportedwebbrowsers');\n            return [];\n          } else if (isQuirksMode) {\n            initError('Failed to initialize the editor as the document is not in standards mode. ' + 'TinyMCE requires standards mode.');\n            return [];\n          } else if (isString(options.selector)) {\n            return DOM.select(options.selector);\n          } else if (isNonNullable(options.target)) {\n            return [options.target];\n          } else {\n            return [];\n          }\n        };\n        let provideResults = editors => {\n          result = editors;\n        };\n        const initEditors = () => {\n          let initCount = 0;\n          const editors = [];\n          let targets;\n          const createEditor = (id, options, targetElm) => {\n            const editor = new Editor(id, options, self);\n            editors.push(editor);\n            editor.on('init', () => {\n              if (++initCount === targets.length) {\n                provideResults(editors);\n              }\n            });\n            editor.targetElm = editor.targetElm || targetElm;\n            editor.render();\n          };\n          DOM.unbind(window, 'ready', initEditors);\n          execCallback('onpageload');\n          targets = unique$1(findTargets(options));\n          Tools.each(targets, elm => {\n            purgeDestroyedEditor(self.get(elm.id));\n          });\n          targets = Tools.grep(targets, elm => {\n            return !self.get(elm.id);\n          });\n          if (targets.length === 0) {\n            provideResults([]);\n          } else {\n            each(targets, elm => {\n              if (isInvalidInlineTarget(options, elm)) {\n                initError('Could not initialize inline editor on invalid inline target element', elm);\n              } else {\n                createEditor(createId(elm), options, elm);\n              }\n            });\n          }\n        };\n        DOM.bind(window, 'ready', initEditors);\n        return new Promise(resolve => {\n          if (result) {\n            resolve(result);\n          } else {\n            provideResults = editors => {\n              resolve(editors);\n            };\n          }\n        });\n      },\n      get(id) {\n        if (arguments.length === 0) {\n          return editors.slice(0);\n        } else if (isString(id)) {\n          return find$2(editors, editor => {\n            return editor.id === id;\n          }).getOr(null);\n        } else if (isNumber(id)) {\n          return editors[id] ? editors[id] : null;\n        } else {\n          return null;\n        }\n      },\n      add(editor) {\n        const self = this;\n        const existingEditor = self.get(editor.id);\n        if (existingEditor === editor) {\n          return editor;\n        }\n        if (existingEditor === null) {\n          editors.push(editor);\n        }\n        toggleGlobalEvents(true);\n        self.activeEditor = editor;\n        self.dispatch('AddEditor', { editor });\n        if (!beforeUnloadDelegate) {\n          beforeUnloadDelegate = e => {\n            const event = self.dispatch('BeforeUnload');\n            if (event.returnValue) {\n              e.preventDefault();\n              e.returnValue = event.returnValue;\n              return event.returnValue;\n            }\n          };\n          window.addEventListener('beforeunload', beforeUnloadDelegate);\n        }\n        return editor;\n      },\n      createEditor(id, options) {\n        return this.add(new Editor(id, options, this));\n      },\n      remove(selector) {\n        const self = this;\n        let i, editor;\n        if (!selector) {\n          for (i = editors.length - 1; i >= 0; i--) {\n            self.remove(editors[i]);\n          }\n          return;\n        }\n        if (isString(selector)) {\n          each(DOM.select(selector), elm => {\n            editor = self.get(elm.id);\n            if (editor) {\n              self.remove(editor);\n            }\n          });\n          return;\n        }\n        editor = selector;\n        if (isNull(self.get(editor.id))) {\n          return null;\n        }\n        if (removeEditorFromList(editor)) {\n          self.dispatch('RemoveEditor', { editor });\n        }\n        if (editors.length === 0) {\n          window.removeEventListener('beforeunload', beforeUnloadDelegate);\n        }\n        editor.remove();\n        toggleGlobalEvents(editors.length > 0);\n        return editor;\n      },\n      execCommand(cmd, ui, value) {\n        var _a;\n        const self = this;\n        const editorId = isObject(value) ? (_a = value.id) !== null && _a !== void 0 ? _a : value.index : value;\n        switch (cmd) {\n        case 'mceAddEditor': {\n            if (!self.get(editorId)) {\n              const editorOptions = value.options;\n              new Editor(editorId, editorOptions, self).render();\n            }\n            return true;\n          }\n        case 'mceRemoveEditor': {\n            const editor = self.get(editorId);\n            if (editor) {\n              editor.remove();\n            }\n            return true;\n          }\n        case 'mceToggleEditor': {\n            const editor = self.get(editorId);\n            if (!editor) {\n              self.execCommand('mceAddEditor', false, value);\n              return true;\n            }\n            if (editor.isHidden()) {\n              editor.show();\n            } else {\n              editor.hide();\n            }\n            return true;\n          }\n        }\n        if (self.activeEditor) {\n          return self.activeEditor.execCommand(cmd, ui, value);\n        }\n        return false;\n      },\n      triggerSave: () => {\n        each(editors, editor => {\n          editor.save();\n        });\n      },\n      addI18n: (code, items) => {\n        I18n.add(code, items);\n      },\n      translate: text => {\n        return I18n.translate(text);\n      },\n      setActive(editor) {\n        const activeEditor = this.activeEditor;\n        if (this.activeEditor !== editor) {\n          if (activeEditor) {\n            activeEditor.dispatch('deactivate', { relatedTarget: editor });\n          }\n          editor.dispatch('activate', { relatedTarget: activeEditor });\n        }\n        this.activeEditor = editor;\n      },\n      _setBaseUrl(baseUrl) {\n        this.baseURL = new URI(this.documentBaseURL).toAbsolute(baseUrl.replace(/\\/+$/, ''));\n        this.baseURI = new URI(this.baseURL);\n      }\n    };\n    EditorManager.setup();\n\n    const setup = () => {\n      const dataValue = value$2();\n      const FakeClipboardItem = items => ({\n        items,\n        types: keys(items),\n        getType: type => get$a(items, type).getOrUndefined()\n      });\n      const write = data => {\n        dataValue.set(data);\n      };\n      const read = () => dataValue.get().getOrUndefined();\n      const clear = dataValue.clear;\n      return {\n        FakeClipboardItem,\n        write,\n        read,\n        clear\n      };\n    };\n    const FakeClipboard = setup();\n\n    const min = Math.min, max = Math.max, round = Math.round;\n    const relativePosition = (rect, targetRect, rel) => {\n      let x = targetRect.x;\n      let y = targetRect.y;\n      const w = rect.w;\n      const h = rect.h;\n      const targetW = targetRect.w;\n      const targetH = targetRect.h;\n      const relChars = (rel || '').split('');\n      if (relChars[0] === 'b') {\n        y += targetH;\n      }\n      if (relChars[1] === 'r') {\n        x += targetW;\n      }\n      if (relChars[0] === 'c') {\n        y += round(targetH / 2);\n      }\n      if (relChars[1] === 'c') {\n        x += round(targetW / 2);\n      }\n      if (relChars[3] === 'b') {\n        y -= h;\n      }\n      if (relChars[4] === 'r') {\n        x -= w;\n      }\n      if (relChars[3] === 'c') {\n        y -= round(h / 2);\n      }\n      if (relChars[4] === 'c') {\n        x -= round(w / 2);\n      }\n      return create$2(x, y, w, h);\n    };\n    const findBestRelativePosition = (rect, targetRect, constrainRect, rels) => {\n      let pos, i;\n      for (i = 0; i < rels.length; i++) {\n        pos = relativePosition(rect, targetRect, rels[i]);\n        if (pos.x >= constrainRect.x && pos.x + pos.w <= constrainRect.w + constrainRect.x && pos.y >= constrainRect.y && pos.y + pos.h <= constrainRect.h + constrainRect.y) {\n          return rels[i];\n        }\n      }\n      return null;\n    };\n    const inflate = (rect, w, h) => {\n      return create$2(rect.x - w, rect.y - h, rect.w + w * 2, rect.h + h * 2);\n    };\n    const intersect = (rect, cropRect) => {\n      const x1 = max(rect.x, cropRect.x);\n      const y1 = max(rect.y, cropRect.y);\n      const x2 = min(rect.x + rect.w, cropRect.x + cropRect.w);\n      const y2 = min(rect.y + rect.h, cropRect.y + cropRect.h);\n      if (x2 - x1 < 0 || y2 - y1 < 0) {\n        return null;\n      }\n      return create$2(x1, y1, x2 - x1, y2 - y1);\n    };\n    const clamp = (rect, clampRect, fixedSize) => {\n      let x1 = rect.x;\n      let y1 = rect.y;\n      let x2 = rect.x + rect.w;\n      let y2 = rect.y + rect.h;\n      const cx2 = clampRect.x + clampRect.w;\n      const cy2 = clampRect.y + clampRect.h;\n      const underflowX1 = max(0, clampRect.x - x1);\n      const underflowY1 = max(0, clampRect.y - y1);\n      const overflowX2 = max(0, x2 - cx2);\n      const overflowY2 = max(0, y2 - cy2);\n      x1 += underflowX1;\n      y1 += underflowY1;\n      if (fixedSize) {\n        x2 += underflowX1;\n        y2 += underflowY1;\n        x1 -= overflowX2;\n        y1 -= overflowY2;\n      }\n      x2 -= overflowX2;\n      y2 -= overflowY2;\n      return create$2(x1, y1, x2 - x1, y2 - y1);\n    };\n    const create$2 = (x, y, w, h) => {\n      return {\n        x,\n        y,\n        w,\n        h\n      };\n    };\n    const fromClientRect = clientRect => {\n      return create$2(clientRect.left, clientRect.top, clientRect.width, clientRect.height);\n    };\n    const Rect = {\n      inflate,\n      relativePosition,\n      findBestRelativePosition,\n      intersect,\n      clamp,\n      create: create$2,\n      fromClientRect\n    };\n\n    const awaiter = (resolveCb, rejectCb, timeout = 1000) => {\n      let done = false;\n      let timer = null;\n      const complete = completer => (...args) => {\n        if (!done) {\n          done = true;\n          if (timer !== null) {\n            clearTimeout(timer);\n            timer = null;\n          }\n          completer.apply(null, args);\n        }\n      };\n      const resolve = complete(resolveCb);\n      const reject = complete(rejectCb);\n      const start = (...args) => {\n        if (!done && timer === null) {\n          timer = setTimeout(() => reject.apply(null, args), timeout);\n        }\n      };\n      return {\n        start,\n        resolve,\n        reject\n      };\n    };\n    const create$1 = () => {\n      const tasks = {};\n      const resultFns = {};\n      const load = (id, url) => {\n        const loadErrMsg = `Script at URL \"${ url }\" failed to load`;\n        const runErrMsg = `Script at URL \"${ url }\" did not call \\`tinymce.Resource.add('${ id }', data)\\` within 1 second`;\n        if (tasks[id] !== undefined) {\n          return tasks[id];\n        } else {\n          const task = new Promise((resolve, reject) => {\n            const waiter = awaiter(resolve, reject);\n            resultFns[id] = waiter.resolve;\n            ScriptLoader.ScriptLoader.loadScript(url).then(() => waiter.start(runErrMsg), () => waiter.reject(loadErrMsg));\n          });\n          tasks[id] = task;\n          return task;\n        }\n      };\n      const add = (id, data) => {\n        if (resultFns[id] !== undefined) {\n          resultFns[id](data);\n          delete resultFns[id];\n        }\n        tasks[id] = Promise.resolve(data);\n      };\n      const unload = id => {\n        delete tasks[id];\n      };\n      return {\n        load,\n        add,\n        unload\n      };\n    };\n    const Resource = create$1();\n\n    const create = () => (() => {\n      let data = {};\n      let keys = [];\n      const storage = {\n        getItem: key => {\n          const item = data[key];\n          return item ? item : null;\n        },\n        setItem: (key, value) => {\n          keys.push(key);\n          data[key] = String(value);\n        },\n        key: index => {\n          return keys[index];\n        },\n        removeItem: key => {\n          keys = keys.filter(k => k === key);\n          delete data[key];\n        },\n        clear: () => {\n          keys = [];\n          data = {};\n        },\n        length: 0\n      };\n      Object.defineProperty(storage, 'length', {\n        get: () => keys.length,\n        configurable: false,\n        enumerable: false\n      });\n      return storage;\n    })();\n\n    let localStorage;\n    try {\n      const test = '__storage_test__';\n      localStorage = window.localStorage;\n      localStorage.setItem(test, test);\n      localStorage.removeItem(test);\n    } catch (e) {\n      localStorage = create();\n    }\n    var LocalStorage = localStorage;\n\n    const publicApi = {\n      geom: { Rect },\n      util: {\n        Delay,\n        Tools,\n        VK,\n        URI,\n        EventDispatcher,\n        Observable,\n        I18n,\n        LocalStorage,\n        ImageUploader\n      },\n      dom: {\n        EventUtils,\n        TreeWalker: DomTreeWalker,\n        TextSeeker,\n        DOMUtils,\n        ScriptLoader,\n        RangeUtils,\n        Serializer: DomSerializer,\n        StyleSheetLoader,\n        ControlSelection,\n        BookmarkManager,\n        Selection: EditorSelection,\n        Event: EventUtils.Event\n      },\n      html: {\n        Styles,\n        Entities,\n        Node: AstNode,\n        Schema,\n        DomParser,\n        Writer,\n        Serializer: HtmlSerializer\n      },\n      Env,\n      AddOnManager,\n      Annotator,\n      Formatter,\n      UndoManager,\n      EditorCommands,\n      WindowManager,\n      NotificationManager,\n      EditorObservable,\n      Shortcuts,\n      Editor,\n      FocusManager,\n      EditorManager,\n      DOM: DOMUtils.DOM,\n      ScriptLoader: ScriptLoader.ScriptLoader,\n      PluginManager,\n      ThemeManager,\n      ModelManager,\n      IconManager,\n      Resource,\n      FakeClipboard,\n      trim: Tools.trim,\n      isArray: Tools.isArray,\n      is: Tools.is,\n      toArray: Tools.toArray,\n      makeMap: Tools.makeMap,\n      each: Tools.each,\n      map: Tools.map,\n      grep: Tools.grep,\n      inArray: Tools.inArray,\n      extend: Tools.extend,\n      walk: Tools.walk,\n      resolve: Tools.resolve,\n      explode: Tools.explode,\n      _addCacheSuffix: Tools._addCacheSuffix\n    };\n    const tinymce = Tools.extend(EditorManager, publicApi);\n\n    const exportToModuleLoaders = tinymce => {\n      if (true) {\n        try {\n          module.exports = tinymce;\n        } catch (_) {\n        }\n      }\n    };\n    const exportToWindowGlobal = tinymce => {\n      window.tinymce = tinymce;\n      window.tinyMCE = tinymce;\n    };\n    exportToWindowGlobal(tinymce);\n    exportToModuleLoaders(tinymce);\n\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGlueW1jZS90aW55bWNlLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsU0FBUztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsWUFBWTtBQUMvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1FQUFtRTs7QUFFbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGtCQUFrQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDRCQUE0QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLG9DQUFvQztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLE9BQU87QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHVCQUF1QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGVBQWU7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFdBQVc7QUFDWCxXQUFXO0FBQ1gsWUFBWTtBQUNaLGFBQWE7QUFDYixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHFHQUFxRztBQUNyRztBQUNBLCtEQUErRDtBQUMvRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVHQUF1RztBQUN2RztBQUNBLDRDQUE0QztBQUM1QyxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLE9BQU87QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFNBQVM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNkMsSUFBSTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE1BQU07QUFDaEQsa0JBQWtCLDBCQUEwQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsb0NBQW9DO0FBQ3BDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxPQUFPO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLCtFQUErRTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLDZFQUE2RTtBQUM3RTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsWUFBWTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsNkJBQTZCLFlBQVk7QUFDekMsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELE9BQU87QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxNQUFNO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxNQUFNO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1QkFBdUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELE9BQU87QUFDNUQsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsVUFBVTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsWUFBWTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELFVBQVU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLGtCQUFrQixLQUFLLElBQUk7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsb0JBQW9CLDhCQUE4QixrQkFBa0I7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG9CQUFvQixLQUFLLEtBQUs7QUFDbEU7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGtCQUFrQixLQUFLLE1BQU07QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsYUFBYSxJQUFJLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGVBQWU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyx3QkFBd0I7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpQ0FBaUM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELFNBQVMsUUFBUTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLElBQUk7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsbUNBQW1DLHFCQUFxQjtBQUN4RCxpQ0FBaUMscUJBQXFCO0FBQ3RELGlDQUFpQyxxQkFBcUI7QUFDdEQsdUNBQXVDLHFCQUFxQjtBQUM1RCxtQ0FBbUMscUJBQXFCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCx3Q0FBd0Msc0JBQXNCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsZ0RBQWdELHVCQUF1QjtBQUN2RTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1Asd0NBQXdDLHFCQUFxQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxxQ0FBcUMscUJBQXFCO0FBQzFELDBDQUEwQyxxQkFBcUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLG9DQUFvQyxxQkFBcUI7QUFDekQsa0NBQWtDLHFCQUFxQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLG1DQUFtQyxxQkFBcUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsMkNBQTJDLHFCQUFxQjtBQUNoRSx5Q0FBeUMsdUJBQXVCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxvQ0FBb0MscUJBQXFCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsZ0NBQWdDLHVCQUF1QjtBQUN2RCxpREFBaUQsdUJBQXVCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsZ0RBQWdELHVCQUF1QjtBQUN2RTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDhDQUE4QyxzQkFBc0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCw4Q0FBOEMsc0JBQXNCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxtQ0FBbUMscUJBQXFCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCwwQ0FBMEMscUJBQXFCO0FBQy9ELGtEQUFrRCxxQkFBcUI7QUFDdkUsMkNBQTJDLHFCQUFxQjtBQUNoRSx5Q0FBeUMsb0NBQW9DO0FBQzdFLHlDQUF5QyxxQkFBcUI7QUFDOUQsd0NBQXdDLG9DQUFvQztBQUM1RSx5Q0FBeUMscUJBQXFCO0FBQzlELHVDQUF1QyxvQ0FBb0M7QUFDM0U7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLHFDQUFxQyx1REFBdUQ7QUFDNUY7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLGtDQUFrQyxvQkFBb0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1Asa0NBQWtDLHFCQUFxQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDJDQUEyQyx1QkFBdUI7QUFDbEUsNENBQTRDLHVCQUF1QjtBQUNuRTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUNBQWlDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxpQ0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsZUFBZTtBQUMzRCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLCtDQUErQyx3QkFBd0IsNkJBQTZCLG9DQUFvQyxNQUFNLCtCQUErQixtQkFBbUIsTUFBTSx3QkFBd0Isd0JBQXdCLG1CQUFtQixpQkFBaUIsWUFBWSxlQUFlLGdCQUFnQixNQUFNO0FBQzNVO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSywrQkFBK0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxRQUFRO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE1BQU07QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxNQUFNO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlDQUFpQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvQkFBb0I7QUFDMUMsd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFNBQVM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzREFBc0Q7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGtCQUFrQjtBQUM1QztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMEJBQTBCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELDBCQUEwQjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLDBDQUEwQyxnQkFBZ0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsNENBQTRDO0FBQy9FO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDLHdCQUF3QixrQkFBa0I7QUFDMUMsYUFBYSxlQUFlLGdCQUFnQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx1REFBdUQsU0FBUztBQUNoRTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxNQUFNO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RixPQUFPO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGtHQUFrRyxPQUFPOztBQUV6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMseUJBQXlCO0FBQzlELFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxtQkFBbUI7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxQkFBcUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsVUFBVTtBQUM5RCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEscUJBQXFCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxtQkFBbUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHVCQUF1QjtBQUNwRTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsOEJBQThCO0FBQ25FO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MscUJBQXFCO0FBQzNEO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELHFCQUFxQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EseURBQXlELE9BQU87QUFDaEU7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsMkJBQTJCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLEtBQUs7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLE1BQU07QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLE1BQU07QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxNQUFNO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0QyxXQUFXLGFBQWEsT0FBTyw2QkFBNkIsV0FBVztBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxPQUFPO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxrREFBa0QsT0FBTztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxRQUFRLHNCQUFzQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxzQkFBc0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRJQUE0SSxXQUFXO0FBQ3ZKLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMLDJJQUEySSxXQUFXO0FBQ3RKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELG9CQUFvQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxTQUFTO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxTQUFTO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLCtGQUErRjtBQUNsSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHdCQUF3QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsMERBQTBELDBDQUEwQztBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsK0NBQStDLGlCQUFpQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsa0RBQWtEO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLGtEQUFrRCx1QkFBdUI7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxnQkFBZ0I7QUFDMUQsbUZBQW1GO0FBQ25GLDBCQUEwQixPQUFPO0FBQ2pDLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0EsK0JBQStCLFNBQVM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE1BQU07QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxZQUFZO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxxQ0FBcUMsaUJBQWlCO0FBQ3REO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxpQkFBaUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViwwQkFBMEIsa0JBQWtCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsb0JBQW9CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxRQUFRO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsTUFBTTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsU0FBUztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsNEJBQTRCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsVUFBVTtBQUNsQixRQUFRLGtCQUFrQjtBQUMxQixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsdUNBQXVDO0FBQ3ZGO0FBQ0EsMEJBQTBCLHVCQUF1QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLE9BQU87QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGFBQWE7QUFDYjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvSEFBb0g7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtEQUFrRCxnQkFBZ0I7QUFDbEU7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRkFBMkYsYUFBYTtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxlQUFlO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxFQUFFLGlCQUFpQixFQUFFO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxnQkFBZ0I7QUFDbEU7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRCwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRSx3REFBd0Q7QUFDeEQsd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGVBQWU7QUFDdEQ7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxrQ0FBa0M7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBLDZDQUE2QyxNQUFNO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2YsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0EsZ0NBQWdDLElBQUk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHVCQUF1QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFdBQVc7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsdUJBQXVCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixFQUFFO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsZ0JBQWdCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsZ0JBQWdCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsT0FBTztBQUN6RTtBQUNBO0FBQ0EsbURBQW1ELE9BQU87QUFDMUQ7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esb0RBQW9ELFFBQVE7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxLQUFLLFlBQVksT0FBTztBQUMvRSxXQUFXO0FBQ1g7QUFDQTtBQUNBLHlEQUF5RCxLQUFLLFlBQVksT0FBTztBQUNqRjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLGVBQWUscUJBQXFCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxTQUFTO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMscUJBQXFCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxVQUFVLElBQUksTUFBTSxLQUFLLFVBQVU7QUFDaEYsbUhBQW1ILFNBQVMsNEJBQTRCLFNBQVM7QUFDaks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNkJBQTZCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0VBQStFLGlCQUFpQjtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw2QkFBNkIsdUJBQXVCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0JBQWtCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixrQkFBa0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFdBQVc7QUFDL0MsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxzQ0FBc0MsaUJBQWlCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGdCQUFnQjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlDQUFpQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLGNBQWMsa0JBQWtCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLG1CQUFtQixnRkFBZ0Y7QUFDbkc7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLGFBQWE7QUFDYixLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWEscUVBQXFFO0FBQ2xGO0FBQ0EsZ0JBQWdCLDZCQUE2QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNULHFCQUFxQiwyREFBMkQ7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNULHFCQUFxQixtQkFBbUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsK0NBQStDO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGdDQUFnQyxpQkFBaUI7QUFDakQsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLG1CQUFtQjtBQUNuQjtBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDJCQUEyQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsWUFBWTtBQUMvRSxtRUFBbUUsWUFBWSxHQUFHLGlDQUFpQztBQUNuSCxtRUFBbUUsWUFBWSxHQUFHLGlDQUFpQztBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1DQUFtQztBQUNsRDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELG9CQUFvQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsZ0RBQWdELGdCQUFnQixtQkFBbUI7QUFDbkY7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLEVBQUU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsY0FBYztBQUNuRDtBQUNBO0FBQ0EsMkVBQTJFLE1BQU0sS0FBSyxPQUFPLFlBQVksS0FBSyx1QkFBdUIsT0FBTyxRQUFRLEtBQUs7QUFDeko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxFQUFFO0FBQ3pDO0FBQ0E7QUFDQSw2Q0FBNkMsU0FBUztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVMsSUFBSSxLQUFLLElBQUksZ0JBQWdCO0FBQzNELFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0Esd0NBQXdDLGVBQWU7QUFDdkQsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixZQUFZO0FBQzNDLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxnQkFBZ0IsSUFBSSwwRUFBMEU7QUFDekksa0RBQWtELFdBQVc7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsZUFBZTtBQUNmO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsV0FBVztBQUNYO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsV0FBVztBQUNYO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFCQUFxQjtBQUMzQztBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLHNCQUFzQixvQkFBb0I7QUFDMUM7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw2QkFBNkI7QUFDbkQ7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdDQUFnQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixTQUFTO0FBQ1Q7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QscUJBQXFCLGVBQWU7QUFDcEMsdUJBQXVCLGVBQWU7QUFDdEMsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDJCQUEyQjtBQUM3QztBQUNBLE9BQU87QUFDUDtBQUNBLGtCQUFrQiw0QkFBNEI7QUFDOUM7QUFDQSxPQUFPO0FBQ1A7QUFDQSxrQkFBa0IsdUJBQXVCO0FBQ3pDO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGtCQUFrQix1QkFBdUI7QUFDekM7QUFDQSxPQUFPO0FBQ1A7QUFDQSxrQkFBa0IsdUJBQXVCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsNkNBQTZDO0FBQzdDLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGNBQWM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRLHFCQUFxQjtBQUM3QixRQUFRLDRCQUE0QjtBQUNwQyxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsdUJBQXVCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxxQkFBcUI7QUFDN0IsUUFBUSxvQkFBb0I7QUFDNUIsUUFBUSxrQkFBa0I7QUFDMUIsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLDZCQUE2QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSywrQkFBK0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxtQkFBbUI7QUFDM0IsUUFBUSxvQkFBb0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFFBQVE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSywyQ0FBMkM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0NBQWtDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEYsZUFBZSxZQUFZLFlBQVk7QUFDbkksS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwySUFBMkksT0FBTyxxQkFBcUIsbUJBQW1CO0FBQzFMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLHNEQUFzRCxZQUFZO0FBQ2xFLG9CQUFvQjtBQUNwQjtBQUNBLHFEQUFxRCxZQUFZO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxVQUFVO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsUUFBUTtBQUNoQixRQUFRLFdBQVc7QUFDbkIsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHVFQUF1RSxXQUFXO0FBQ2xGO0FBQ0E7QUFDQSxxREFBcUQsV0FBVztBQUNoRTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx1QkFBdUI7QUFDeEQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3RkFBd0Y7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFVBQVUsYUFBYSxjQUFjLGtCQUFrQjtBQUMxRixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCw4QkFBOEIsZ0JBQWdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esa0RBQWtELHVCQUF1QjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFIQUFxSCxvQkFBb0I7QUFDekk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLCtCQUErQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msb0JBQW9CO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCx3Q0FBd0MseUJBQXlCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSwrQ0FBK0Msa0JBQWtCO0FBQ2pFLDBDQUEwQyxnQkFBZ0I7QUFDMUQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHlCQUF5QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLDZDQUE2QztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsdUJBQXVCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsa0RBQWtEO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDhCQUE4QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLFlBQVk7QUFDL0U7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLE9BQU87QUFDUDtBQUNBO0FBQ0EsK0hBQStILEtBQUs7QUFDcEk7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsZ0JBQWdCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxxQkFBcUI7QUFDL0Q7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9EQUFvRCxvQ0FBb0Msb0JBQW9CLDBCQUEwQjtBQUN0STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxrQkFBa0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLFNBQVM7QUFDVCxzREFBc0QsNEJBQTRCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZUFBZTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsZ0RBQWdELGVBQWU7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxRQUFRLDZCQUE2QixXQUFXLGNBQWMsV0FBVyxpQkFBaUIsb0JBQW9CO0FBQzVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsOEJBQThCLFVBQVUsY0FBYztBQUN0SDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3RixPQUFPLFNBQVMsUUFBUTtBQUNoSDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtHQUFrRyxPQUFPLFNBQVMsUUFBUTtBQUMxSDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxlQUFlLDhCQUE4QixVQUFVLE1BQU0sU0FBUyxRQUFRO0FBQzlFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsUUFBUSxVQUFVLFFBQVE7QUFDbkU7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBLDJEQUEyRDtBQUMzRCw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCwwRkFBMEYsYUFBYTtBQUM5SjtBQUNBLGdNQUFnTSxJQUFJLHVGQUF1RjtBQUMzUjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMsUUFBUTtBQUNSLG9DQUFvQztBQUNwQztBQUNBO0FBQ0Esb0NBQW9DLDBCQUEwQjtBQUM5RCxRQUFRO0FBQ1IsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSwrREFBK0QsWUFBWTtBQUMzRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EseUVBQXlFLGFBQWEsa0NBQWtDLGdCQUFnQjtBQUN4SSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE1BQU07QUFDNUIsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGlDQUFpQztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QywwQ0FBMEM7QUFDdEY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDhDQUE4QywyQkFBMkI7QUFDekU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esa0NBQWtDLE9BQU87QUFDekMsU0FBUztBQUNUO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0MsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsMENBQTBDLG1DQUFtQztBQUM3RTs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWdELGNBQWM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLG9DQUFvQyw2QkFBNkI7QUFDakU7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELE1BQU0sV0FBVywwQkFBMEI7QUFDOUY7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0Y7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxPQUFPO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsWUFBWTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSw2RkFBNkY7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDZFQUE2RSxNQUFNO0FBQ25GO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxnQkFBZ0I7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLGtGQUFrRixNQUFNO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVix3RUFBd0UsT0FBTztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsTUFBTTtBQUNsQztBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsK0JBQStCLE1BQU07QUFDckM7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUiwrREFBK0QsTUFBTTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IseUNBQXlDLE1BQU07QUFDL0M7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsTUFBTTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLHVFQUF1RSxNQUFNO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Ysc0JBQXNCLEdBQUc7QUFDekI7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLHdCQUF3QjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsY0FBYztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsU0FBUztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGVBQWU7QUFDL0QsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLDBCQUEwQixvQkFBb0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFFBQVE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsdUJBQXVCO0FBQ3pFO0FBQ0Esd0NBQXdDLDZCQUE2QjtBQUNyRTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsS0FBSztBQUNuRCw2Q0FBNkMsS0FBSywwQ0FBMEMsSUFBSTtBQUNoRztBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxJQUEwQjtBQUNwQztBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RpbnltY2UvdGlueW1jZS5qcz9mY2VlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGlueU1DRSB2ZXJzaW9uIDYuMC4zICgyMDIyLTA1LTI1KVxuICovXG5cbihmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIHR5cGVPZiQxID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIGlmICh4ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgICB9XG4gICAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgICAgIH1cbiAgICAgIHZhciB0ID0gdHlwZW9mIHg7XG4gICAgICBpZiAodCA9PT0gJ29iamVjdCcgJiYgKEFycmF5LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKHgpIHx8IHguY29uc3RydWN0b3IgJiYgeC5jb25zdHJ1Y3Rvci5uYW1lID09PSAnQXJyYXknKSkge1xuICAgICAgICByZXR1cm4gJ2FycmF5JztcbiAgICAgIH1cbiAgICAgIGlmICh0ID09PSAnb2JqZWN0JyAmJiAoU3RyaW5nLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKHgpIHx8IHguY29uc3RydWN0b3IgJiYgeC5jb25zdHJ1Y3Rvci5uYW1lID09PSAnU3RyaW5nJykpIHtcbiAgICAgICAgcmV0dXJuICdzdHJpbmcnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICB2YXIgaXNFcXVhdGFibGVUeXBlID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgICd1bmRlZmluZWQnLFxuICAgICAgICAnYm9vbGVhbicsXG4gICAgICAgICdudW1iZXInLFxuICAgICAgICAnc3RyaW5nJyxcbiAgICAgICAgJ2Z1bmN0aW9uJyxcbiAgICAgICAgJ3htbCcsXG4gICAgICAgICdudWxsJ1xuICAgICAgXS5pbmRleE9mKHgpICE9PSAtMTtcbiAgICB9O1xuXG4gICAgdmFyIHNvcnQkMSA9IGZ1bmN0aW9uICh4cywgY29tcGFyZUZuKSB7XG4gICAgICB2YXIgY2xvbmUgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh4cyk7XG4gICAgICByZXR1cm4gY2xvbmUuc29ydChjb21wYXJlRm4pO1xuICAgIH07XG5cbiAgICB2YXIgY29udHJhbWFwID0gZnVuY3Rpb24gKGVxYSwgZikge1xuICAgICAgcmV0dXJuIGVxJDIoZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIGVxYS5lcShmKHgpLCBmKHkpKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdmFyIGVxJDIgPSBmdW5jdGlvbiAoZikge1xuICAgICAgcmV0dXJuIHsgZXE6IGYgfTtcbiAgICB9O1xuICAgIHZhciB0cmlwbGVFcSA9IGVxJDIoZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIHJldHVybiB4ID09PSB5O1xuICAgIH0pO1xuICAgIHZhciBlcVN0cmluZyA9IHRyaXBsZUVxO1xuICAgIHZhciBlcUFycmF5ID0gZnVuY3Rpb24gKGVxYSkge1xuICAgICAgcmV0dXJuIGVxJDIoZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgaWYgKHgubGVuZ3RoICE9PSB5Lmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVuID0geC5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAoIWVxYS5lcSh4W2ldLCB5W2ldKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdmFyIGVxU29ydGVkQXJyYXkgPSBmdW5jdGlvbiAoZXFhLCBjb21wYXJlRm4pIHtcbiAgICAgIHJldHVybiBjb250cmFtYXAoZXFBcnJheShlcWEpLCBmdW5jdGlvbiAoeHMpIHtcbiAgICAgICAgcmV0dXJuIHNvcnQkMSh4cywgY29tcGFyZUZuKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdmFyIGVxUmVjb3JkID0gZnVuY3Rpb24gKGVxYSkge1xuICAgICAgcmV0dXJuIGVxJDIoZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgdmFyIGt4ID0gT2JqZWN0LmtleXMoeCk7XG4gICAgICAgIHZhciBreSA9IE9iamVjdC5rZXlzKHkpO1xuICAgICAgICBpZiAoIWVxU29ydGVkQXJyYXkoZXFTdHJpbmcpLmVxKGt4LCBreSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlbiA9IGt4Lmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHZhciBxID0ga3hbaV07XG4gICAgICAgICAgaWYgKCFlcWEuZXEoeFtxXSwgeVtxXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHZhciBlcUFueSA9IGVxJDIoZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIHR4ID0gdHlwZU9mJDEoeCk7XG4gICAgICB2YXIgdHkgPSB0eXBlT2YkMSh5KTtcbiAgICAgIGlmICh0eCAhPT0gdHkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGlzRXF1YXRhYmxlVHlwZSh0eCkpIHtcbiAgICAgICAgcmV0dXJuIHggPT09IHk7XG4gICAgICB9IGVsc2UgaWYgKHR4ID09PSAnYXJyYXknKSB7XG4gICAgICAgIHJldHVybiBlcUFycmF5KGVxQW55KS5lcSh4LCB5KTtcbiAgICAgIH0gZWxzZSBpZiAodHggPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBlcVJlY29yZChlcUFueSkuZXEoeCwgeSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG5cbiAgICBjb25zdCBnZXRQcm90b3R5cGVPZiQxID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICAgIGNvbnN0IGhhc1Byb3RvID0gKHYsIGNvbnN0cnVjdG9yLCBwcmVkaWNhdGUpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmIChwcmVkaWNhdGUodiwgY29uc3RydWN0b3IucHJvdG90eXBlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAoKF9hID0gdi5jb25zdHJ1Y3RvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5hbWUpID09PSBjb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgdHlwZU9mID0geCA9PiB7XG4gICAgICBjb25zdCB0ID0gdHlwZW9mIHg7XG4gICAgICBpZiAoeCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJ251bGwnO1xuICAgICAgfSBlbHNlIGlmICh0ID09PSAnb2JqZWN0JyAmJiBBcnJheS5pc0FycmF5KHgpKSB7XG4gICAgICAgIHJldHVybiAnYXJyYXknO1xuICAgICAgfSBlbHNlIGlmICh0ID09PSAnb2JqZWN0JyAmJiBoYXNQcm90byh4LCBTdHJpbmcsIChvLCBwcm90bykgPT4gcHJvdG8uaXNQcm90b3R5cGVPZihvKSkpIHtcbiAgICAgICAgcmV0dXJuICdzdHJpbmcnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBpc1R5cGUkMSA9IHR5cGUgPT4gdmFsdWUgPT4gdHlwZU9mKHZhbHVlKSA9PT0gdHlwZTtcbiAgICBjb25zdCBpc1NpbXBsZVR5cGUgPSB0eXBlID0+IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gdHlwZTtcbiAgICBjb25zdCBlcSQxID0gdCA9PiBhID0+IHQgPT09IGE7XG4gICAgY29uc3QgaXMkNCA9ICh2YWx1ZSwgY29uc3RydWN0b3IpID0+IGlzT2JqZWN0KHZhbHVlKSAmJiBoYXNQcm90byh2YWx1ZSwgY29uc3RydWN0b3IsIChvLCBwcm90bykgPT4gZ2V0UHJvdG90eXBlT2YkMShvKSA9PT0gcHJvdG8pO1xuICAgIGNvbnN0IGlzU3RyaW5nID0gaXNUeXBlJDEoJ3N0cmluZycpO1xuICAgIGNvbnN0IGlzT2JqZWN0ID0gaXNUeXBlJDEoJ29iamVjdCcpO1xuICAgIGNvbnN0IGlzUGxhaW5PYmplY3QgPSB2YWx1ZSA9PiBpcyQ0KHZhbHVlLCBPYmplY3QpO1xuICAgIGNvbnN0IGlzQXJyYXkkMSA9IGlzVHlwZSQxKCdhcnJheScpO1xuICAgIGNvbnN0IGlzTnVsbCA9IGVxJDEobnVsbCk7XG4gICAgY29uc3QgaXNCb29sZWFuID0gaXNTaW1wbGVUeXBlKCdib29sZWFuJyk7XG4gICAgY29uc3QgaXNVbmRlZmluZWQgPSBlcSQxKHVuZGVmaW5lZCk7XG4gICAgY29uc3QgaXNOdWxsYWJsZSA9IGEgPT4gYSA9PT0gbnVsbCB8fCBhID09PSB1bmRlZmluZWQ7XG4gICAgY29uc3QgaXNOb25OdWxsYWJsZSA9IGEgPT4gIWlzTnVsbGFibGUoYSk7XG4gICAgY29uc3QgaXNGdW5jdGlvbiA9IGlzU2ltcGxlVHlwZSgnZnVuY3Rpb24nKTtcbiAgICBjb25zdCBpc051bWJlciA9IGlzU2ltcGxlVHlwZSgnbnVtYmVyJyk7XG4gICAgY29uc3QgaXNBcnJheU9mID0gKHZhbHVlLCBwcmVkKSA9PiB7XG4gICAgICBpZiAoaXNBcnJheSQxKHZhbHVlKSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdmFsdWUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICBpZiAoIXByZWQodmFsdWVbaV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBjb25zdCBub29wID0gKCkgPT4ge1xuICAgIH07XG4gICAgY29uc3QgY29tcG9zZSA9IChmYSwgZmIpID0+IHtcbiAgICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgICAgICByZXR1cm4gZmEoZmIuYXBwbHkobnVsbCwgYXJncykpO1xuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IGNvbXBvc2UxID0gKGZiYywgZmFiKSA9PiBhID0+IGZiYyhmYWIoYSkpO1xuICAgIGNvbnN0IGNvbnN0YW50ID0gdmFsdWUgPT4ge1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IGlkZW50aXR5ID0geCA9PiB7XG4gICAgICByZXR1cm4geDtcbiAgICB9O1xuICAgIGNvbnN0IHRyaXBsZUVxdWFscyA9IChhLCBiKSA9PiB7XG4gICAgICByZXR1cm4gYSA9PT0gYjtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGN1cnJ5KGZuLCAuLi5pbml0aWFsQXJncykge1xuICAgICAgcmV0dXJuICguLi5yZXN0QXJncykgPT4ge1xuICAgICAgICBjb25zdCBhbGwgPSBpbml0aWFsQXJncy5jb25jYXQocmVzdEFyZ3MpO1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgYWxsKTtcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IG5vdCA9IGYgPT4gdCA9PiAhZih0KTtcbiAgICBjb25zdCBkaWUgPSBtc2cgPT4ge1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgYXBwbHkkMSA9IGYgPT4ge1xuICAgICAgcmV0dXJuIGYoKTtcbiAgICB9O1xuICAgIGNvbnN0IGNhbGwgPSBmID0+IHtcbiAgICAgIGYoKTtcbiAgICB9O1xuICAgIGNvbnN0IG5ldmVyID0gY29uc3RhbnQoZmFsc2UpO1xuICAgIGNvbnN0IGFsd2F5cyA9IGNvbnN0YW50KHRydWUpO1xuXG4gICAgY2xhc3MgT3B0aW9uYWwge1xuICAgICAgY29uc3RydWN0b3IodGFnLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnRhZyA9IHRhZztcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgc3RhdGljIHNvbWUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBPcHRpb25hbCh0cnVlLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICBzdGF0aWMgbm9uZSgpIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNpbmdsZXRvbk5vbmU7XG4gICAgICB9XG4gICAgICBmb2xkKG9uTm9uZSwgb25Tb21lKSB7XG4gICAgICAgIGlmICh0aGlzLnRhZykge1xuICAgICAgICAgIHJldHVybiBvblNvbWUodGhpcy52YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG9uTm9uZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpc1NvbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhZztcbiAgICAgIH1cbiAgICAgIGlzTm9uZSgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLnRhZztcbiAgICAgIH1cbiAgICAgIG1hcChtYXBwZXIpIHtcbiAgICAgICAgaWYgKHRoaXMudGFnKSB7XG4gICAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUobWFwcGVyKHRoaXMudmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBiaW5kKGJpbmRlcikge1xuICAgICAgICBpZiAodGhpcy50YWcpIHtcbiAgICAgICAgICByZXR1cm4gYmluZGVyKHRoaXMudmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGV4aXN0cyhwcmVkaWNhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFnICYmIHByZWRpY2F0ZSh0aGlzLnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGZvcmFsbChwcmVkaWNhdGUpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLnRhZyB8fCBwcmVkaWNhdGUodGhpcy52YWx1ZSk7XG4gICAgICB9XG4gICAgICBmaWx0ZXIocHJlZGljYXRlKSB7XG4gICAgICAgIGlmICghdGhpcy50YWcgfHwgcHJlZGljYXRlKHRoaXMudmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZ2V0T3IocmVwbGFjZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFnID8gdGhpcy52YWx1ZSA6IHJlcGxhY2VtZW50O1xuICAgICAgfVxuICAgICAgb3IocmVwbGFjZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFnID8gdGhpcyA6IHJlcGxhY2VtZW50O1xuICAgICAgfVxuICAgICAgZ2V0T3JUaHVuayh0aHVuaykge1xuICAgICAgICByZXR1cm4gdGhpcy50YWcgPyB0aGlzLnZhbHVlIDogdGh1bmsoKTtcbiAgICAgIH1cbiAgICAgIG9yVGh1bmsodGh1bmspIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFnID8gdGhpcyA6IHRodW5rKCk7XG4gICAgICB9XG4gICAgICBnZXRPckRpZShtZXNzYWdlKSB7XG4gICAgICAgIGlmICghdGhpcy50YWcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSAhPT0gbnVsbCAmJiBtZXNzYWdlICE9PSB2b2lkIDAgPyBtZXNzYWdlIDogJ0NhbGxlZCBnZXRPckRpZSBvbiBOb25lJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0YXRpYyBmcm9tKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpc05vbk51bGxhYmxlKHZhbHVlKSA/IE9wdGlvbmFsLnNvbWUodmFsdWUpIDogT3B0aW9uYWwubm9uZSgpO1xuICAgICAgfVxuICAgICAgZ2V0T3JOdWxsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50YWcgPyB0aGlzLnZhbHVlIDogbnVsbDtcbiAgICAgIH1cbiAgICAgIGdldE9yVW5kZWZpbmVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICAgIH1cbiAgICAgIGVhY2god29ya2VyKSB7XG4gICAgICAgIGlmICh0aGlzLnRhZykge1xuICAgICAgICAgIHdvcmtlcih0aGlzLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdG9BcnJheSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFnID8gW3RoaXMudmFsdWVdIDogW107XG4gICAgICB9XG4gICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFnID8gYHNvbWUoJHsgdGhpcy52YWx1ZSB9KWAgOiAnbm9uZSgpJztcbiAgICAgIH1cbiAgICB9XG4gICAgT3B0aW9uYWwuc2luZ2xldG9uTm9uZSA9IG5ldyBPcHRpb25hbChmYWxzZSk7XG5cbiAgICBjb25zdCBuYXRpdmVTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbiAgICBjb25zdCBuYXRpdmVJbmRleE9mID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2Y7XG4gICAgY29uc3QgbmF0aXZlUHVzaCA9IEFycmF5LnByb3RvdHlwZS5wdXNoO1xuICAgIGNvbnN0IHJhd0luZGV4T2YgPSAodHMsIHQpID0+IG5hdGl2ZUluZGV4T2YuY2FsbCh0cywgdCk7XG4gICAgY29uc3QgaW5kZXhPZiQxID0gKHhzLCB4KSA9PiB7XG4gICAgICBjb25zdCByID0gcmF3SW5kZXhPZih4cywgeCk7XG4gICAgICByZXR1cm4gciA9PT0gLTEgPyBPcHRpb25hbC5ub25lKCkgOiBPcHRpb25hbC5zb21lKHIpO1xuICAgIH07XG4gICAgY29uc3QgY29udGFpbnMkMiA9ICh4cywgeCkgPT4gcmF3SW5kZXhPZih4cywgeCkgPiAtMTtcbiAgICBjb25zdCBleGlzdHMgPSAoeHMsIHByZWQpID0+IHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB4cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb25zdCB4ID0geHNbaV07XG4gICAgICAgIGlmIChwcmVkKHgsIGkpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIGNvbnN0IG1hcCQzID0gKHhzLCBmKSA9PiB7XG4gICAgICBjb25zdCBsZW4gPSB4cy5sZW5ndGg7XG4gICAgICBjb25zdCByID0gbmV3IEFycmF5KGxlbik7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHggPSB4c1tpXTtcbiAgICAgICAgcltpXSA9IGYoeCwgaSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcjtcbiAgICB9O1xuICAgIGNvbnN0IGVhY2gkZyA9ICh4cywgZikgPT4ge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHhzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHggPSB4c1tpXTtcbiAgICAgICAgZih4LCBpKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGVhY2hyID0gKHhzLCBmKSA9PiB7XG4gICAgICBmb3IgKGxldCBpID0geHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3QgeCA9IHhzW2ldO1xuICAgICAgICBmKHgsIGkpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcGFydGl0aW9uJDIgPSAoeHMsIHByZWQpID0+IHtcbiAgICAgIGNvbnN0IHBhc3MgPSBbXTtcbiAgICAgIGNvbnN0IGZhaWwgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB4cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb25zdCB4ID0geHNbaV07XG4gICAgICAgIGNvbnN0IGFyciA9IHByZWQoeCwgaSkgPyBwYXNzIDogZmFpbDtcbiAgICAgICAgYXJyLnB1c2goeCk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXNzLFxuICAgICAgICBmYWlsXG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgZmlsdGVyJDYgPSAoeHMsIHByZWQpID0+IHtcbiAgICAgIGNvbnN0IHIgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB4cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb25zdCB4ID0geHNbaV07XG4gICAgICAgIGlmIChwcmVkKHgsIGkpKSB7XG4gICAgICAgICAgci5wdXNoKHgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcjtcbiAgICB9O1xuICAgIGNvbnN0IGZvbGRyID0gKHhzLCBmLCBhY2MpID0+IHtcbiAgICAgIGVhY2hyKHhzLCAoeCwgaSkgPT4ge1xuICAgICAgICBhY2MgPSBmKGFjYywgeCwgaSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfTtcbiAgICBjb25zdCBmb2xkbCA9ICh4cywgZiwgYWNjKSA9PiB7XG4gICAgICBlYWNoJGcoeHMsICh4LCBpKSA9PiB7XG4gICAgICAgIGFjYyA9IGYoYWNjLCB4LCBpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9O1xuICAgIGNvbnN0IGZpbmRVbnRpbCQxID0gKHhzLCBwcmVkLCB1bnRpbCkgPT4ge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHhzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHggPSB4c1tpXTtcbiAgICAgICAgaWYgKHByZWQoeCwgaSkpIHtcbiAgICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZSh4KTtcbiAgICAgICAgfSBlbHNlIGlmICh1bnRpbCh4LCBpKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgIH07XG4gICAgY29uc3QgZmluZCQyID0gKHhzLCBwcmVkKSA9PiB7XG4gICAgICByZXR1cm4gZmluZFVudGlsJDEoeHMsIHByZWQsIG5ldmVyKTtcbiAgICB9O1xuICAgIGNvbnN0IGZpbmRJbmRleCQyID0gKHhzLCBwcmVkKSA9PiB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0geHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgeCA9IHhzW2ldO1xuICAgICAgICBpZiAocHJlZCh4LCBpKSkge1xuICAgICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgIH07XG4gICAgY29uc3QgZmxhdHRlbiA9IHhzID0+IHtcbiAgICAgIGNvbnN0IHIgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB4cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBpZiAoIWlzQXJyYXkkMSh4c1tpXSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Fyci5mbGF0dGVuIGl0ZW0gJyArIGkgKyAnIHdhcyBub3QgYW4gYXJyYXksIGlucHV0OiAnICsgeHMpO1xuICAgICAgICB9XG4gICAgICAgIG5hdGl2ZVB1c2guYXBwbHkociwgeHNbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHI7XG4gICAgfTtcbiAgICBjb25zdCBiaW5kJDMgPSAoeHMsIGYpID0+IGZsYXR0ZW4obWFwJDMoeHMsIGYpKTtcbiAgICBjb25zdCBmb3JhbGwgPSAoeHMsIHByZWQpID0+IHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB4cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBjb25zdCB4ID0geHNbaV07XG4gICAgICAgIGlmIChwcmVkKHgsIGkpICE9PSB0cnVlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIGNvbnN0IHJldmVyc2UgPSB4cyA9PiB7XG4gICAgICBjb25zdCByID0gbmF0aXZlU2xpY2UuY2FsbCh4cywgMCk7XG4gICAgICByLnJldmVyc2UoKTtcbiAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgY29uc3QgZGlmZmVyZW5jZSA9IChhMSwgYTIpID0+IGZpbHRlciQ2KGExLCB4ID0+ICFjb250YWlucyQyKGEyLCB4KSk7XG4gICAgY29uc3QgbWFwVG9PYmplY3QgPSAoeHMsIGYpID0+IHtcbiAgICAgIGNvbnN0IHIgPSB7fTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB4cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb25zdCB4ID0geHNbaV07XG4gICAgICAgIHJbU3RyaW5nKHgpXSA9IGYoeCwgaSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcjtcbiAgICB9O1xuICAgIGNvbnN0IHNvcnQgPSAoeHMsIGNvbXBhcmF0b3IpID0+IHtcbiAgICAgIGNvbnN0IGNvcHkgPSBuYXRpdmVTbGljZS5jYWxsKHhzLCAwKTtcbiAgICAgIGNvcHkuc29ydChjb21wYXJhdG9yKTtcbiAgICAgIHJldHVybiBjb3B5O1xuICAgIH07XG4gICAgY29uc3QgZ2V0JGIgPSAoeHMsIGkpID0+IGkgPj0gMCAmJiBpIDwgeHMubGVuZ3RoID8gT3B0aW9uYWwuc29tZSh4c1tpXSkgOiBPcHRpb25hbC5ub25lKCk7XG4gICAgY29uc3QgaGVhZCA9IHhzID0+IGdldCRiKHhzLCAwKTtcbiAgICBjb25zdCBsYXN0JDMgPSB4cyA9PiBnZXQkYih4cywgeHMubGVuZ3RoIC0gMSk7XG4gICAgY29uc3QgZnJvbSA9IGlzRnVuY3Rpb24oQXJyYXkuZnJvbSkgPyBBcnJheS5mcm9tIDogeCA9PiBuYXRpdmVTbGljZS5jYWxsKHgpO1xuICAgIGNvbnN0IGZpbmRNYXAgPSAoYXJyLCBmKSA9PiB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCByID0gZihhcnJbaV0sIGkpO1xuICAgICAgICBpZiAoci5pc1NvbWUoKSkge1xuICAgICAgICAgIHJldHVybiByO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgIH07XG4gICAgY29uc3QgdW5pcXVlJDEgPSAoeHMsIGNvbXBhcmF0b3IpID0+IHtcbiAgICAgIGNvbnN0IHIgPSBbXTtcbiAgICAgIGNvbnN0IGlzRHVwbGljYXRlZCA9IGlzRnVuY3Rpb24oY29tcGFyYXRvcikgPyB4ID0+IGV4aXN0cyhyLCBpID0+IGNvbXBhcmF0b3IoaSwgeCkpIDogeCA9PiBjb250YWlucyQyKHIsIHgpO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHhzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHggPSB4c1tpXTtcbiAgICAgICAgaWYgKCFpc0R1cGxpY2F0ZWQoeCkpIHtcbiAgICAgICAgICByLnB1c2goeCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByO1xuICAgIH07XG5cbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXM7XG4gICAgY29uc3QgaGFzT3duUHJvcGVydHkkMiA9IE9iamVjdC5oYXNPd25Qcm9wZXJ0eTtcbiAgICBjb25zdCBlYWNoJGYgPSAob2JqLCBmKSA9PiB7XG4gICAgICBjb25zdCBwcm9wcyA9IGtleXMob2JqKTtcbiAgICAgIGZvciAobGV0IGsgPSAwLCBsZW4gPSBwcm9wcy5sZW5ndGg7IGsgPCBsZW47IGsrKykge1xuICAgICAgICBjb25zdCBpID0gcHJvcHNba107XG4gICAgICAgIGNvbnN0IHggPSBvYmpbaV07XG4gICAgICAgIGYoeCwgaSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBtYXAkMiA9IChvYmosIGYpID0+IHtcbiAgICAgIHJldHVybiB0dXBsZU1hcChvYmosICh4LCBpKSA9PiAoe1xuICAgICAgICBrOiBpLFxuICAgICAgICB2OiBmKHgsIGkpXG4gICAgICB9KSk7XG4gICAgfTtcbiAgICBjb25zdCB0dXBsZU1hcCA9IChvYmosIGYpID0+IHtcbiAgICAgIGNvbnN0IHIgPSB7fTtcbiAgICAgIGVhY2gkZihvYmosICh4LCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IHR1cGxlID0gZih4LCBpKTtcbiAgICAgICAgclt0dXBsZS5rXSA9IHR1cGxlLnY7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgY29uc3Qgb2JqQWNjID0gciA9PiAoeCwgaSkgPT4ge1xuICAgICAgcltpXSA9IHg7XG4gICAgfTtcbiAgICBjb25zdCBpbnRlcm5hbEZpbHRlciA9IChvYmosIHByZWQsIG9uVHJ1ZSwgb25GYWxzZSkgPT4ge1xuICAgICAgY29uc3QgciA9IHt9O1xuICAgICAgZWFjaCRmKG9iaiwgKHgsIGkpID0+IHtcbiAgICAgICAgKHByZWQoeCwgaSkgPyBvblRydWUgOiBvbkZhbHNlKSh4LCBpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfTtcbiAgICBjb25zdCBiaWZpbHRlciA9IChvYmosIHByZWQpID0+IHtcbiAgICAgIGNvbnN0IHQgPSB7fTtcbiAgICAgIGNvbnN0IGYgPSB7fTtcbiAgICAgIGludGVybmFsRmlsdGVyKG9iaiwgcHJlZCwgb2JqQWNjKHQpLCBvYmpBY2MoZikpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdCxcbiAgICAgICAgZlxuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IGZpbHRlciQ1ID0gKG9iaiwgcHJlZCkgPT4ge1xuICAgICAgY29uc3QgdCA9IHt9O1xuICAgICAgaW50ZXJuYWxGaWx0ZXIob2JqLCBwcmVkLCBvYmpBY2ModCksIG5vb3ApO1xuICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICBjb25zdCBtYXBUb0FycmF5ID0gKG9iaiwgZikgPT4ge1xuICAgICAgY29uc3QgciA9IFtdO1xuICAgICAgZWFjaCRmKG9iaiwgKHZhbHVlLCBuYW1lKSA9PiB7XG4gICAgICAgIHIucHVzaChmKHZhbHVlLCBuYW1lKSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgY29uc3QgdmFsdWVzID0gb2JqID0+IHtcbiAgICAgIHJldHVybiBtYXBUb0FycmF5KG9iaiwgaWRlbnRpdHkpO1xuICAgIH07XG4gICAgY29uc3QgZ2V0JGEgPSAob2JqLCBrZXkpID0+IHtcbiAgICAgIHJldHVybiBoYXMkMihvYmosIGtleSkgPyBPcHRpb25hbC5mcm9tKG9ialtrZXldKSA6IE9wdGlvbmFsLm5vbmUoKTtcbiAgICB9O1xuICAgIGNvbnN0IGhhcyQyID0gKG9iaiwga2V5KSA9PiBoYXNPd25Qcm9wZXJ0eSQyLmNhbGwob2JqLCBrZXkpO1xuICAgIGNvbnN0IGhhc05vbk51bGxhYmxlS2V5ID0gKG9iaiwga2V5KSA9PiBoYXMkMihvYmosIGtleSkgJiYgb2JqW2tleV0gIT09IHVuZGVmaW5lZCAmJiBvYmpba2V5XSAhPT0gbnVsbDtcbiAgICBjb25zdCBlcXVhbCQxID0gKGExLCBhMiwgZXEgPSBlcUFueSkgPT4gZXFSZWNvcmQoZXEpLmVxKGExLCBhMik7XG5cbiAgICBjb25zdCBzdHJpbmdBcnJheSA9IGEgPT4ge1xuICAgICAgY29uc3QgYWxsID0ge307XG4gICAgICBlYWNoJGcoYSwga2V5ID0+IHtcbiAgICAgICAgYWxsW2tleV0gPSB7fTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGtleXMoYWxsKTtcbiAgICB9O1xuXG4gICAgY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG4gICAgY29uc3QgdG9BcnJheSQxID0gb2JqID0+IHtcbiAgICAgIGlmICghaXNBcnJheShvYmopKSB7XG4gICAgICAgIGNvbnN0IGFycmF5ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGFycmF5W2ldID0gb2JqW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBlYWNoJGUgPSAobywgY2IsIHMpID0+IHtcbiAgICAgIGxldCBuLCBsO1xuICAgICAgaWYgKCFvKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHMgPSBzIHx8IG87XG4gICAgICBpZiAoby5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBmb3IgKG4gPSAwLCBsID0gby5sZW5ndGg7IG4gPCBsOyBuKyspIHtcbiAgICAgICAgICBpZiAoY2IuY2FsbChzLCBvW25dLCBuLCBvKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobiBpbiBvKSB7XG4gICAgICAgICAgaWYgKGhhcyQyKG8sIG4pKSB7XG4gICAgICAgICAgICBpZiAoY2IuY2FsbChzLCBvW25dLCBuLCBvKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBjb25zdCBtYXAkMSA9IChhcnJheSwgY2FsbGJhY2spID0+IHtcbiAgICAgIGNvbnN0IG91dCA9IFtdO1xuICAgICAgZWFjaCRlKGFycmF5LCAoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgb3V0LnB1c2goY2FsbGJhY2soaXRlbSwgaW5kZXgsIGFycmF5KSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICBjb25zdCBmaWx0ZXIkNCA9IChhLCBmKSA9PiB7XG4gICAgICBjb25zdCBvID0gW107XG4gICAgICBlYWNoJGUoYSwgKHYsIGluZGV4KSA9PiB7XG4gICAgICAgIGlmICghZiB8fCBmKHYsIGluZGV4LCBhKSkge1xuICAgICAgICAgIG8ucHVzaCh2KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbztcbiAgICB9O1xuICAgIGNvbnN0IGluZGV4T2YgPSAoYSwgdikgPT4ge1xuICAgICAgaWYgKGEpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGlmIChhW2ldID09PSB2KSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuICAgIGNvbnN0IHJlZHVjZSA9IChjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIHRoaXNBcmcpID0+IHtcbiAgICAgIGxldCBhY2MgPSBpc1VuZGVmaW5lZChhY2N1bXVsYXRvcikgPyBjb2xsZWN0aW9uWzBdIDogYWNjdW11bGF0b3I7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbGxlY3Rpb24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYWNjID0gaXRlcmF0ZWUuY2FsbCh0aGlzQXJnLCBhY2MsIGNvbGxlY3Rpb25baV0sIGkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9O1xuICAgIGNvbnN0IGZpbmRJbmRleCQxID0gKGFycmF5LCBwcmVkaWNhdGUsIHRoaXNBcmcpID0+IHtcbiAgICAgIGxldCBpLCBsO1xuICAgICAgZm9yIChpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAocHJlZGljYXRlLmNhbGwodGhpc0FyZywgYXJyYXlbaV0sIGksIGFycmF5KSkge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgICBjb25zdCBsYXN0JDIgPSBjb2xsZWN0aW9uID0+IGNvbGxlY3Rpb25bY29sbGVjdGlvbi5sZW5ndGggLSAxXTtcblxuICAgIGNvbnN0IGNhY2hlZCA9IGYgPT4ge1xuICAgICAgbGV0IGNhbGxlZCA9IGZhbHNlO1xuICAgICAgbGV0IHI7XG4gICAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICAgIHIgPSBmLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgY29uc3QgRGV2aWNlVHlwZSA9IChvcywgYnJvd3NlciwgdXNlckFnZW50LCBtZWRpYU1hdGNoKSA9PiB7XG4gICAgICBjb25zdCBpc2lQYWQgPSBvcy5pc2lPUygpICYmIC9pcGFkL2kudGVzdCh1c2VyQWdlbnQpID09PSB0cnVlO1xuICAgICAgY29uc3QgaXNpUGhvbmUgPSBvcy5pc2lPUygpICYmICFpc2lQYWQ7XG4gICAgICBjb25zdCBpc01vYmlsZSA9IG9zLmlzaU9TKCkgfHwgb3MuaXNBbmRyb2lkKCk7XG4gICAgICBjb25zdCBpc1RvdWNoID0gaXNNb2JpbGUgfHwgbWVkaWFNYXRjaCgnKHBvaW50ZXI6Y29hcnNlKScpO1xuICAgICAgY29uc3QgaXNUYWJsZXQgPSBpc2lQYWQgfHwgIWlzaVBob25lICYmIGlzTW9iaWxlICYmIG1lZGlhTWF0Y2goJyhtaW4tZGV2aWNlLXdpZHRoOjc2OHB4KScpO1xuICAgICAgY29uc3QgaXNQaG9uZSA9IGlzaVBob25lIHx8IGlzTW9iaWxlICYmICFpc1RhYmxldDtcbiAgICAgIGNvbnN0IGlPU3dlYnZpZXcgPSBicm93c2VyLmlzU2FmYXJpKCkgJiYgb3MuaXNpT1MoKSAmJiAvc2FmYXJpL2kudGVzdCh1c2VyQWdlbnQpID09PSBmYWxzZTtcbiAgICAgIGNvbnN0IGlzRGVza3RvcCA9ICFpc1Bob25lICYmICFpc1RhYmxldCAmJiAhaU9Td2VidmlldztcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzaVBhZDogY29uc3RhbnQoaXNpUGFkKSxcbiAgICAgICAgaXNpUGhvbmU6IGNvbnN0YW50KGlzaVBob25lKSxcbiAgICAgICAgaXNUYWJsZXQ6IGNvbnN0YW50KGlzVGFibGV0KSxcbiAgICAgICAgaXNQaG9uZTogY29uc3RhbnQoaXNQaG9uZSksXG4gICAgICAgIGlzVG91Y2g6IGNvbnN0YW50KGlzVG91Y2gpLFxuICAgICAgICBpc0FuZHJvaWQ6IG9zLmlzQW5kcm9pZCxcbiAgICAgICAgaXNpT1M6IG9zLmlzaU9TLFxuICAgICAgICBpc1dlYlZpZXc6IGNvbnN0YW50KGlPU3dlYnZpZXcpLFxuICAgICAgICBpc0Rlc2t0b3A6IGNvbnN0YW50KGlzRGVza3RvcClcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IGZpcnN0TWF0Y2ggPSAocmVnZXhlcywgcykgPT4ge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWdleGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHggPSByZWdleGVzW2ldO1xuICAgICAgICBpZiAoeC50ZXN0KHMpKSB7XG4gICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBjb25zdCBmaW5kJDEgPSAocmVnZXhlcywgYWdlbnQpID0+IHtcbiAgICAgIGNvbnN0IHIgPSBmaXJzdE1hdGNoKHJlZ2V4ZXMsIGFnZW50KTtcbiAgICAgIGlmICghcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1ham9yOiAwLFxuICAgICAgICAgIG1pbm9yOiAwXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCBncm91cCA9IGkgPT4ge1xuICAgICAgICByZXR1cm4gTnVtYmVyKGFnZW50LnJlcGxhY2UociwgJyQnICsgaSkpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBudSQzKGdyb3VwKDEpLCBncm91cCgyKSk7XG4gICAgfTtcbiAgICBjb25zdCBkZXRlY3QkNSA9ICh2ZXJzaW9uUmVnZXhlcywgYWdlbnQpID0+IHtcbiAgICAgIGNvbnN0IGNsZWFuZWRBZ2VudCA9IFN0cmluZyhhZ2VudCkudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmICh2ZXJzaW9uUmVnZXhlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHVua25vd24kMigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZpbmQkMSh2ZXJzaW9uUmVnZXhlcywgY2xlYW5lZEFnZW50KTtcbiAgICB9O1xuICAgIGNvbnN0IHVua25vd24kMiA9ICgpID0+IHtcbiAgICAgIHJldHVybiBudSQzKDAsIDApO1xuICAgIH07XG4gICAgY29uc3QgbnUkMyA9IChtYWpvciwgbWlub3IpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1ham9yLFxuICAgICAgICBtaW5vclxuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IFZlcnNpb24gPSB7XG4gICAgICBudTogbnUkMyxcbiAgICAgIGRldGVjdDogZGV0ZWN0JDUsXG4gICAgICB1bmtub3duOiB1bmtub3duJDJcbiAgICB9O1xuXG4gICAgY29uc3QgZGV0ZWN0QnJvd3NlciQxID0gKGJyb3dzZXJzLCB1c2VyQWdlbnREYXRhKSA9PiB7XG4gICAgICByZXR1cm4gZmluZE1hcCh1c2VyQWdlbnREYXRhLmJyYW5kcywgdWFCcmFuZCA9PiB7XG4gICAgICAgIGNvbnN0IGxjQnJhbmQgPSB1YUJyYW5kLmJyYW5kLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiBmaW5kJDIoYnJvd3NlcnMsIGJyb3dzZXIgPT4ge1xuICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICByZXR1cm4gbGNCcmFuZCA9PT0gKChfYSA9IGJyb3dzZXIuYnJhbmQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgfSkubWFwKGluZm8gPT4gKHtcbiAgICAgICAgICBjdXJyZW50OiBpbmZvLm5hbWUsXG4gICAgICAgICAgdmVyc2lvbjogVmVyc2lvbi5udShwYXJzZUludCh1YUJyYW5kLnZlcnNpb24sIDEwKSwgMClcbiAgICAgICAgfSkpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGRldGVjdCQ0ID0gKGNhbmRpZGF0ZXMsIHVzZXJBZ2VudCkgPT4ge1xuICAgICAgY29uc3QgYWdlbnQgPSBTdHJpbmcodXNlckFnZW50KS50b0xvd2VyQ2FzZSgpO1xuICAgICAgcmV0dXJuIGZpbmQkMihjYW5kaWRhdGVzLCBjYW5kaWRhdGUgPT4ge1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlLnNlYXJjaChhZ2VudCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGRldGVjdEJyb3dzZXIgPSAoYnJvd3NlcnMsIHVzZXJBZ2VudCkgPT4ge1xuICAgICAgcmV0dXJuIGRldGVjdCQ0KGJyb3dzZXJzLCB1c2VyQWdlbnQpLm1hcChicm93c2VyID0+IHtcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9IFZlcnNpb24uZGV0ZWN0KGJyb3dzZXIudmVyc2lvblJlZ2V4ZXMsIHVzZXJBZ2VudCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY3VycmVudDogYnJvd3Nlci5uYW1lLFxuICAgICAgICAgIHZlcnNpb25cbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgZGV0ZWN0T3MgPSAob3NlcywgdXNlckFnZW50KSA9PiB7XG4gICAgICByZXR1cm4gZGV0ZWN0JDQob3NlcywgdXNlckFnZW50KS5tYXAob3MgPT4ge1xuICAgICAgICBjb25zdCB2ZXJzaW9uID0gVmVyc2lvbi5kZXRlY3Qob3MudmVyc2lvblJlZ2V4ZXMsIHVzZXJBZ2VudCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY3VycmVudDogb3MubmFtZSxcbiAgICAgICAgICB2ZXJzaW9uXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3QgcmVtb3ZlRnJvbVN0YXJ0ID0gKHN0ciwgbnVtQ2hhcnMpID0+IHtcbiAgICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKG51bUNoYXJzKTtcbiAgICB9O1xuXG4gICAgY29uc3QgY2hlY2tSYW5nZSA9IChzdHIsIHN1YnN0ciwgc3RhcnQpID0+IHN1YnN0ciA9PT0gJycgfHwgc3RyLmxlbmd0aCA+PSBzdWJzdHIubGVuZ3RoICYmIHN0ci5zdWJzdHIoc3RhcnQsIHN0YXJ0ICsgc3Vic3RyLmxlbmd0aCkgPT09IHN1YnN0cjtcbiAgICBjb25zdCByZW1vdmVMZWFkaW5nID0gKHN0ciwgcHJlZml4KSA9PiB7XG4gICAgICByZXR1cm4gc3RhcnRzV2l0aChzdHIsIHByZWZpeCkgPyByZW1vdmVGcm9tU3RhcnQoc3RyLCBwcmVmaXgubGVuZ3RoKSA6IHN0cjtcbiAgICB9O1xuICAgIGNvbnN0IGNvbnRhaW5zJDEgPSAoc3RyLCBzdWJzdHIpID0+IHtcbiAgICAgIHJldHVybiBzdHIuaW5kZXhPZihzdWJzdHIpICE9PSAtMTtcbiAgICB9O1xuICAgIGNvbnN0IHN0YXJ0c1dpdGggPSAoc3RyLCBwcmVmaXgpID0+IHtcbiAgICAgIHJldHVybiBjaGVja1JhbmdlKHN0ciwgcHJlZml4LCAwKTtcbiAgICB9O1xuICAgIGNvbnN0IGVuZHNXaXRoID0gKHN0ciwgc3VmZml4KSA9PiB7XG4gICAgICByZXR1cm4gY2hlY2tSYW5nZShzdHIsIHN1ZmZpeCwgc3RyLmxlbmd0aCAtIHN1ZmZpeC5sZW5ndGgpO1xuICAgIH07XG4gICAgY29uc3QgYmxhbmsgPSByID0+IHMgPT4gcy5yZXBsYWNlKHIsICcnKTtcbiAgICBjb25zdCB0cmltJDMgPSBibGFuaygvXlxccyt8XFxzKyQvZyk7XG4gICAgY29uc3QgbFRyaW0gPSBibGFuaygvXlxccysvZyk7XG4gICAgY29uc3QgclRyaW0gPSBibGFuaygvXFxzKyQvZyk7XG4gICAgY29uc3QgaXNOb3RFbXB0eSA9IHMgPT4gcy5sZW5ndGggPiAwO1xuICAgIGNvbnN0IGlzRW1wdHkkMyA9IHMgPT4gIWlzTm90RW1wdHkocyk7XG4gICAgY29uc3QgcmVwZWF0ID0gKHMsIGNvdW50KSA9PiBjb3VudCA8PSAwID8gJycgOiBuZXcgQXJyYXkoY291bnQgKyAxKS5qb2luKHMpO1xuICAgIGNvbnN0IHRvSW50ID0gKHZhbHVlLCByYWRpeCA9IDEwKSA9PiB7XG4gICAgICBjb25zdCBudW0gPSBwYXJzZUludCh2YWx1ZSwgcmFkaXgpO1xuICAgICAgcmV0dXJuIGlzTmFOKG51bSkgPyBPcHRpb25hbC5ub25lKCkgOiBPcHRpb25hbC5zb21lKG51bSk7XG4gICAgfTtcblxuICAgIGNvbnN0IG5vcm1hbFZlcnNpb25SZWdleCA9IC8uKj92ZXJzaW9uXFwvXFwgPyhbMC05XSspXFwuKFswLTldKykuKi87XG4gICAgY29uc3QgY2hlY2tDb250YWlucyA9IHRhcmdldCA9PiB7XG4gICAgICByZXR1cm4gdWFzdHJpbmcgPT4ge1xuICAgICAgICByZXR1cm4gY29udGFpbnMkMSh1YXN0cmluZywgdGFyZ2V0KTtcbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBicm93c2VycyA9IFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ0VkZ2UnLFxuICAgICAgICB2ZXJzaW9uUmVnZXhlczogWy8uKj9lZGdlXFwvID8oWzAtOV0rKVxcLihbMC05XSspJC9dLFxuICAgICAgICBzZWFyY2g6IHVhc3RyaW5nID0+IHtcbiAgICAgICAgICByZXR1cm4gY29udGFpbnMkMSh1YXN0cmluZywgJ2VkZ2UvJykgJiYgY29udGFpbnMkMSh1YXN0cmluZywgJ2Nocm9tZScpICYmIGNvbnRhaW5zJDEodWFzdHJpbmcsICdzYWZhcmknKSAmJiBjb250YWlucyQxKHVhc3RyaW5nLCAnYXBwbGV3ZWJraXQnKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ0Nocm9taXVtJyxcbiAgICAgICAgYnJhbmQ6ICdDaHJvbWl1bScsXG4gICAgICAgIHZlcnNpb25SZWdleGVzOiBbXG4gICAgICAgICAgLy4qP2Nocm9tZVxcLyhbMC05XSspXFwuKFswLTldKykuKi8sXG4gICAgICAgICAgbm9ybWFsVmVyc2lvblJlZ2V4XG4gICAgICAgIF0sXG4gICAgICAgIHNlYXJjaDogdWFzdHJpbmcgPT4ge1xuICAgICAgICAgIHJldHVybiBjb250YWlucyQxKHVhc3RyaW5nLCAnY2hyb21lJykgJiYgIWNvbnRhaW5zJDEodWFzdHJpbmcsICdjaHJvbWVmcmFtZScpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiAnSUUnLFxuICAgICAgICB2ZXJzaW9uUmVnZXhlczogW1xuICAgICAgICAgIC8uKj9tc2llXFwgPyhbMC05XSspXFwuKFswLTldKykuKi8sXG4gICAgICAgICAgLy4qP3J2OihbMC05XSspXFwuKFswLTldKykuKi9cbiAgICAgICAgXSxcbiAgICAgICAgc2VhcmNoOiB1YXN0cmluZyA9PiB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRhaW5zJDEodWFzdHJpbmcsICdtc2llJykgfHwgY29udGFpbnMkMSh1YXN0cmluZywgJ3RyaWRlbnQnKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ09wZXJhJyxcbiAgICAgICAgdmVyc2lvblJlZ2V4ZXM6IFtcbiAgICAgICAgICBub3JtYWxWZXJzaW9uUmVnZXgsXG4gICAgICAgICAgLy4qP29wZXJhXFwvKFswLTldKylcXC4oWzAtOV0rKS4qL1xuICAgICAgICBdLFxuICAgICAgICBzZWFyY2g6IGNoZWNrQ29udGFpbnMoJ29wZXJhJylcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdGaXJlZm94JyxcbiAgICAgICAgdmVyc2lvblJlZ2V4ZXM6IFsvLio/ZmlyZWZveFxcL1xcID8oWzAtOV0rKVxcLihbMC05XSspLiovXSxcbiAgICAgICAgc2VhcmNoOiBjaGVja0NvbnRhaW5zKCdmaXJlZm94JylcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdTYWZhcmknLFxuICAgICAgICB2ZXJzaW9uUmVnZXhlczogW1xuICAgICAgICAgIG5vcm1hbFZlcnNpb25SZWdleCxcbiAgICAgICAgICAvLio/Y3B1IG9zIChbMC05XSspXyhbMC05XSspLiovXG4gICAgICAgIF0sXG4gICAgICAgIHNlYXJjaDogdWFzdHJpbmcgPT4ge1xuICAgICAgICAgIHJldHVybiAoY29udGFpbnMkMSh1YXN0cmluZywgJ3NhZmFyaScpIHx8IGNvbnRhaW5zJDEodWFzdHJpbmcsICdtb2JpbGUvJykpICYmIGNvbnRhaW5zJDEodWFzdHJpbmcsICdhcHBsZXdlYmtpdCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgXTtcbiAgICBjb25zdCBvc2VzID0gW1xuICAgICAge1xuICAgICAgICBuYW1lOiAnV2luZG93cycsXG4gICAgICAgIHNlYXJjaDogY2hlY2tDb250YWlucygnd2luJyksXG4gICAgICAgIHZlcnNpb25SZWdleGVzOiBbLy4qP3dpbmRvd3NcXCBudFxcID8oWzAtOV0rKVxcLihbMC05XSspLiovXVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2lPUycsXG4gICAgICAgIHNlYXJjaDogdWFzdHJpbmcgPT4ge1xuICAgICAgICAgIHJldHVybiBjb250YWlucyQxKHVhc3RyaW5nLCAnaXBob25lJykgfHwgY29udGFpbnMkMSh1YXN0cmluZywgJ2lwYWQnKTtcbiAgICAgICAgfSxcbiAgICAgICAgdmVyc2lvblJlZ2V4ZXM6IFtcbiAgICAgICAgICAvLio/dmVyc2lvblxcL1xcID8oWzAtOV0rKVxcLihbMC05XSspLiovLFxuICAgICAgICAgIC8uKmNwdSBvcyAoWzAtOV0rKV8oWzAtOV0rKS4qLyxcbiAgICAgICAgICAvLipjcHUgaXBob25lIG9zIChbMC05XSspXyhbMC05XSspLiovXG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdBbmRyb2lkJyxcbiAgICAgICAgc2VhcmNoOiBjaGVja0NvbnRhaW5zKCdhbmRyb2lkJyksXG4gICAgICAgIHZlcnNpb25SZWdleGVzOiBbLy4qP2FuZHJvaWRcXCA/KFswLTldKylcXC4oWzAtOV0rKS4qL11cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdtYWNPUycsXG4gICAgICAgIHNlYXJjaDogY2hlY2tDb250YWlucygnbWFjIG9zIHgnKSxcbiAgICAgICAgdmVyc2lvblJlZ2V4ZXM6IFsvLio/bWFjXFwgb3NcXCB4XFwgPyhbMC05XSspXyhbMC05XSspLiovXVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ0xpbnV4JyxcbiAgICAgICAgc2VhcmNoOiBjaGVja0NvbnRhaW5zKCdsaW51eCcpLFxuICAgICAgICB2ZXJzaW9uUmVnZXhlczogW11cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdTb2xhcmlzJyxcbiAgICAgICAgc2VhcmNoOiBjaGVja0NvbnRhaW5zKCdzdW5vcycpLFxuICAgICAgICB2ZXJzaW9uUmVnZXhlczogW11cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdGcmVlQlNEJyxcbiAgICAgICAgc2VhcmNoOiBjaGVja0NvbnRhaW5zKCdmcmVlYnNkJyksXG4gICAgICAgIHZlcnNpb25SZWdleGVzOiBbXVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ0Nocm9tZU9TJyxcbiAgICAgICAgc2VhcmNoOiBjaGVja0NvbnRhaW5zKCdjcm9zJyksXG4gICAgICAgIHZlcnNpb25SZWdleGVzOiBbLy4qP2Nocm9tZVxcLyhbMC05XSspXFwuKFswLTldKykuKi9dXG4gICAgICB9XG4gICAgXTtcbiAgICBjb25zdCBQbGF0Zm9ybUluZm8gPSB7XG4gICAgICBicm93c2VyczogY29uc3RhbnQoYnJvd3NlcnMpLFxuICAgICAgb3NlczogY29uc3RhbnQob3NlcylcbiAgICB9O1xuXG4gICAgY29uc3QgZWRnZSA9ICdFZGdlJztcbiAgICBjb25zdCBjaHJvbWl1bSA9ICdDaHJvbWl1bSc7XG4gICAgY29uc3QgaWUgPSAnSUUnO1xuICAgIGNvbnN0IG9wZXJhID0gJ09wZXJhJztcbiAgICBjb25zdCBmaXJlZm94ID0gJ0ZpcmVmb3gnO1xuICAgIGNvbnN0IHNhZmFyaSA9ICdTYWZhcmknO1xuICAgIGNvbnN0IHVua25vd24kMSA9ICgpID0+IHtcbiAgICAgIHJldHVybiBudSQyKHtcbiAgICAgICAgY3VycmVudDogdW5kZWZpbmVkLFxuICAgICAgICB2ZXJzaW9uOiBWZXJzaW9uLnVua25vd24oKVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBudSQyID0gaW5mbyA9PiB7XG4gICAgICBjb25zdCBjdXJyZW50ID0gaW5mby5jdXJyZW50O1xuICAgICAgY29uc3QgdmVyc2lvbiA9IGluZm8udmVyc2lvbjtcbiAgICAgIGNvbnN0IGlzQnJvd3NlciA9IG5hbWUgPT4gKCkgPT4gY3VycmVudCA9PT0gbmFtZTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGN1cnJlbnQsXG4gICAgICAgIHZlcnNpb24sXG4gICAgICAgIGlzRWRnZTogaXNCcm93c2VyKGVkZ2UpLFxuICAgICAgICBpc0Nocm9taXVtOiBpc0Jyb3dzZXIoY2hyb21pdW0pLFxuICAgICAgICBpc0lFOiBpc0Jyb3dzZXIoaWUpLFxuICAgICAgICBpc09wZXJhOiBpc0Jyb3dzZXIob3BlcmEpLFxuICAgICAgICBpc0ZpcmVmb3g6IGlzQnJvd3NlcihmaXJlZm94KSxcbiAgICAgICAgaXNTYWZhcmk6IGlzQnJvd3NlcihzYWZhcmkpXG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgQnJvd3NlciA9IHtcbiAgICAgIHVua25vd246IHVua25vd24kMSxcbiAgICAgIG51OiBudSQyLFxuICAgICAgZWRnZTogY29uc3RhbnQoZWRnZSksXG4gICAgICBjaHJvbWl1bTogY29uc3RhbnQoY2hyb21pdW0pLFxuICAgICAgaWU6IGNvbnN0YW50KGllKSxcbiAgICAgIG9wZXJhOiBjb25zdGFudChvcGVyYSksXG4gICAgICBmaXJlZm94OiBjb25zdGFudChmaXJlZm94KSxcbiAgICAgIHNhZmFyaTogY29uc3RhbnQoc2FmYXJpKVxuICAgIH07XG5cbiAgICBjb25zdCB3aW5kb3dzID0gJ1dpbmRvd3MnO1xuICAgIGNvbnN0IGlvcyA9ICdpT1MnO1xuICAgIGNvbnN0IGFuZHJvaWQgPSAnQW5kcm9pZCc7XG4gICAgY29uc3QgbGludXggPSAnTGludXgnO1xuICAgIGNvbnN0IG1hY29zID0gJ21hY09TJztcbiAgICBjb25zdCBzb2xhcmlzID0gJ1NvbGFyaXMnO1xuICAgIGNvbnN0IGZyZWVic2QgPSAnRnJlZUJTRCc7XG4gICAgY29uc3QgY2hyb21lb3MgPSAnQ2hyb21lT1MnO1xuICAgIGNvbnN0IHVua25vd24gPSAoKSA9PiB7XG4gICAgICByZXR1cm4gbnUkMSh7XG4gICAgICAgIGN1cnJlbnQ6IHVuZGVmaW5lZCxcbiAgICAgICAgdmVyc2lvbjogVmVyc2lvbi51bmtub3duKClcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgbnUkMSA9IGluZm8gPT4ge1xuICAgICAgY29uc3QgY3VycmVudCA9IGluZm8uY3VycmVudDtcbiAgICAgIGNvbnN0IHZlcnNpb24gPSBpbmZvLnZlcnNpb247XG4gICAgICBjb25zdCBpc09TID0gbmFtZSA9PiAoKSA9PiBjdXJyZW50ID09PSBuYW1lO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY3VycmVudCxcbiAgICAgICAgdmVyc2lvbixcbiAgICAgICAgaXNXaW5kb3dzOiBpc09TKHdpbmRvd3MpLFxuICAgICAgICBpc2lPUzogaXNPUyhpb3MpLFxuICAgICAgICBpc0FuZHJvaWQ6IGlzT1MoYW5kcm9pZCksXG4gICAgICAgIGlzTWFjT1M6IGlzT1MobWFjb3MpLFxuICAgICAgICBpc0xpbnV4OiBpc09TKGxpbnV4KSxcbiAgICAgICAgaXNTb2xhcmlzOiBpc09TKHNvbGFyaXMpLFxuICAgICAgICBpc0ZyZWVCU0Q6IGlzT1MoZnJlZWJzZCksXG4gICAgICAgIGlzQ2hyb21lT1M6IGlzT1MoY2hyb21lb3MpXG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgT3BlcmF0aW5nU3lzdGVtID0ge1xuICAgICAgdW5rbm93bixcbiAgICAgIG51OiBudSQxLFxuICAgICAgd2luZG93czogY29uc3RhbnQod2luZG93cyksXG4gICAgICBpb3M6IGNvbnN0YW50KGlvcyksXG4gICAgICBhbmRyb2lkOiBjb25zdGFudChhbmRyb2lkKSxcbiAgICAgIGxpbnV4OiBjb25zdGFudChsaW51eCksXG4gICAgICBtYWNvczogY29uc3RhbnQobWFjb3MpLFxuICAgICAgc29sYXJpczogY29uc3RhbnQoc29sYXJpcyksXG4gICAgICBmcmVlYnNkOiBjb25zdGFudChmcmVlYnNkKSxcbiAgICAgIGNocm9tZW9zOiBjb25zdGFudChjaHJvbWVvcylcbiAgICB9O1xuXG4gICAgY29uc3QgZGV0ZWN0JDMgPSAodXNlckFnZW50LCB1c2VyQWdlbnREYXRhT3B0LCBtZWRpYU1hdGNoKSA9PiB7XG4gICAgICBjb25zdCBicm93c2VycyA9IFBsYXRmb3JtSW5mby5icm93c2VycygpO1xuICAgICAgY29uc3Qgb3NlcyA9IFBsYXRmb3JtSW5mby5vc2VzKCk7XG4gICAgICBjb25zdCBicm93c2VyID0gdXNlckFnZW50RGF0YU9wdC5iaW5kKHVzZXJBZ2VudERhdGEgPT4gZGV0ZWN0QnJvd3NlciQxKGJyb3dzZXJzLCB1c2VyQWdlbnREYXRhKSkub3JUaHVuaygoKSA9PiBkZXRlY3RCcm93c2VyKGJyb3dzZXJzLCB1c2VyQWdlbnQpKS5mb2xkKEJyb3dzZXIudW5rbm93biwgQnJvd3Nlci5udSk7XG4gICAgICBjb25zdCBvcyA9IGRldGVjdE9zKG9zZXMsIHVzZXJBZ2VudCkuZm9sZChPcGVyYXRpbmdTeXN0ZW0udW5rbm93biwgT3BlcmF0aW5nU3lzdGVtLm51KTtcbiAgICAgIGNvbnN0IGRldmljZVR5cGUgPSBEZXZpY2VUeXBlKG9zLCBicm93c2VyLCB1c2VyQWdlbnQsIG1lZGlhTWF0Y2gpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYnJvd3NlcixcbiAgICAgICAgb3MsXG4gICAgICAgIGRldmljZVR5cGVcbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBQbGF0Zm9ybURldGVjdGlvbiA9IHsgZGV0ZWN0OiBkZXRlY3QkMyB9O1xuXG4gICAgY29uc3QgbWVkaWFNYXRjaCA9IHF1ZXJ5ID0+IHdpbmRvdy5tYXRjaE1lZGlhKHF1ZXJ5KS5tYXRjaGVzO1xuICAgIGxldCBwbGF0Zm9ybSQyID0gY2FjaGVkKCgpID0+IFBsYXRmb3JtRGV0ZWN0aW9uLmRldGVjdChuYXZpZ2F0b3IudXNlckFnZW50LCBPcHRpb25hbC5mcm9tKG5hdmlnYXRvci51c2VyQWdlbnREYXRhKSwgbWVkaWFNYXRjaCkpO1xuICAgIGNvbnN0IGRldGVjdCQyID0gKCkgPT4gcGxhdGZvcm0kMigpO1xuXG4gICAgY29uc3QgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgICBjb25zdCBwbGF0Zm9ybSQxID0gZGV0ZWN0JDIoKTtcbiAgICBjb25zdCBicm93c2VyJDEgPSBwbGF0Zm9ybSQxLmJyb3dzZXI7XG4gICAgY29uc3Qgb3MgPSBwbGF0Zm9ybSQxLm9zO1xuICAgIGNvbnN0IGRldmljZVR5cGUgPSBwbGF0Zm9ybSQxLmRldmljZVR5cGU7XG4gICAgY29uc3Qgd2luZG93c1Bob25lID0gdXNlckFnZW50LmluZGV4T2YoJ1dpbmRvd3MgUGhvbmUnKSAhPT0gLTE7XG4gICAgY29uc3QgRW52ID0ge1xuICAgICAgdHJhbnNwYXJlbnRTcmM6ICdkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUlBQUFBQUFBUC8vL3lINUJBRUFBQUFBTEFBQUFBQUJBQUVBQUFJQlJBQTcnLFxuICAgICAgZG9jdW1lbnRNb2RlOiBicm93c2VyJDEuaXNJRSgpID8gZG9jdW1lbnQuZG9jdW1lbnRNb2RlIHx8IDcgOiAxMCxcbiAgICAgIGNhY2hlU3VmZml4OiBudWxsLFxuICAgICAgY29udGFpbmVyOiBudWxsLFxuICAgICAgY2FuSGF2ZUNTUDogIWJyb3dzZXIkMS5pc0lFKCksXG4gICAgICB3aW5kb3dzUGhvbmUsXG4gICAgICBicm93c2VyOiB7XG4gICAgICAgIGN1cnJlbnQ6IGJyb3dzZXIkMS5jdXJyZW50LFxuICAgICAgICB2ZXJzaW9uOiBicm93c2VyJDEudmVyc2lvbixcbiAgICAgICAgaXNDaHJvbWl1bTogYnJvd3NlciQxLmlzQ2hyb21pdW0sXG4gICAgICAgIGlzRWRnZTogYnJvd3NlciQxLmlzRWRnZSxcbiAgICAgICAgaXNGaXJlZm94OiBicm93c2VyJDEuaXNGaXJlZm94LFxuICAgICAgICBpc0lFOiBicm93c2VyJDEuaXNJRSxcbiAgICAgICAgaXNPcGVyYTogYnJvd3NlciQxLmlzT3BlcmEsXG4gICAgICAgIGlzU2FmYXJpOiBicm93c2VyJDEuaXNTYWZhcmlcbiAgICAgIH0sXG4gICAgICBvczoge1xuICAgICAgICBjdXJyZW50OiBvcy5jdXJyZW50LFxuICAgICAgICB2ZXJzaW9uOiBvcy52ZXJzaW9uLFxuICAgICAgICBpc0FuZHJvaWQ6IG9zLmlzQW5kcm9pZCxcbiAgICAgICAgaXNDaHJvbWVPUzogb3MuaXNDaHJvbWVPUyxcbiAgICAgICAgaXNGcmVlQlNEOiBvcy5pc0ZyZWVCU0QsXG4gICAgICAgIGlzaU9TOiBvcy5pc2lPUyxcbiAgICAgICAgaXNMaW51eDogb3MuaXNMaW51eCxcbiAgICAgICAgaXNNYWNPUzogb3MuaXNNYWNPUyxcbiAgICAgICAgaXNTb2xhcmlzOiBvcy5pc1NvbGFyaXMsXG4gICAgICAgIGlzV2luZG93czogb3MuaXNXaW5kb3dzXG4gICAgICB9LFxuICAgICAgZGV2aWNlVHlwZToge1xuICAgICAgICBpc0Rlc2t0b3A6IGRldmljZVR5cGUuaXNEZXNrdG9wLFxuICAgICAgICBpc2lQYWQ6IGRldmljZVR5cGUuaXNpUGFkLFxuICAgICAgICBpc2lQaG9uZTogZGV2aWNlVHlwZS5pc2lQaG9uZSxcbiAgICAgICAgaXNQaG9uZTogZGV2aWNlVHlwZS5pc1Bob25lLFxuICAgICAgICBpc1RhYmxldDogZGV2aWNlVHlwZS5pc1RhYmxldCxcbiAgICAgICAgaXNUb3VjaDogZGV2aWNlVHlwZS5pc1RvdWNoLFxuICAgICAgICBpc1dlYlZpZXc6IGRldmljZVR5cGUuaXNXZWJWaWV3XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IHdoaXRlU3BhY2VSZWdFeHAkMSA9IC9eXFxzKnxcXHMqJC9nO1xuICAgIGNvbnN0IHRyaW0kMiA9IHN0ciA9PiB7XG4gICAgICByZXR1cm4gc3RyID09PSBudWxsIHx8IHN0ciA9PT0gdW5kZWZpbmVkID8gJycgOiAoJycgKyBzdHIpLnJlcGxhY2Uod2hpdGVTcGFjZVJlZ0V4cCQxLCAnJyk7XG4gICAgfTtcbiAgICBjb25zdCBpcyQzID0gKG9iaiwgdHlwZSkgPT4ge1xuICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgIHJldHVybiBvYmogIT09IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09PSAnYXJyYXknICYmIGlzQXJyYXkob2JqKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSB0eXBlO1xuICAgIH07XG4gICAgY29uc3QgbWFrZU1hcCQ0ID0gKGl0ZW1zLCBkZWxpbSwgbWFwKSA9PiB7XG4gICAgICBsZXQgaTtcbiAgICAgIGl0ZW1zID0gaXRlbXMgfHwgW107XG4gICAgICBkZWxpbSA9IGRlbGltIHx8ICcsJztcbiAgICAgIGlmICh0eXBlb2YgaXRlbXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGl0ZW1zID0gaXRlbXMuc3BsaXQoZGVsaW0pO1xuICAgICAgfVxuICAgICAgbWFwID0gbWFwIHx8IHt9O1xuICAgICAgaSA9IGl0ZW1zLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgbWFwW2l0ZW1zW2ldXSA9IHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hcDtcbiAgICB9O1xuICAgIGNvbnN0IGhhc093blByb3BlcnR5JDEgPSBoYXMkMjtcbiAgICBjb25zdCBleHRlbmQkMyA9IChvYmosIC4uLmV4dHMpID0+IHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXh0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBleHQgPSBleHRzW2ldO1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gZXh0KSB7XG4gICAgICAgICAgaWYgKGhhcyQyKGV4dCwgbmFtZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZXh0W25hbWVdO1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgb2JqW25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH07XG4gICAgY29uc3Qgd2FsayQ0ID0gZnVuY3Rpb24gKG8sIGYsIG4sIHMpIHtcbiAgICAgIHMgPSBzIHx8IHRoaXM7XG4gICAgICBpZiAobykge1xuICAgICAgICBpZiAobikge1xuICAgICAgICAgIG8gPSBvW25dO1xuICAgICAgICB9XG4gICAgICAgIGVhY2gkZShvLCAobywgaSkgPT4ge1xuICAgICAgICAgIGlmIChmLmNhbGwocywgbywgaSwgbikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdhbGskNChvLCBmLCBuLCBzKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCByZXNvbHZlJDIgPSAobiwgbykgPT4ge1xuICAgICAgbGV0IGksIGw7XG4gICAgICBvID0gbyB8fCB3aW5kb3c7XG4gICAgICBuID0gbi5zcGxpdCgnLicpO1xuICAgICAgZm9yIChpID0gMCwgbCA9IG4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIG8gPSBvW25baV1dO1xuICAgICAgICBpZiAoIW8pIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG87XG4gICAgfTtcbiAgICBjb25zdCBleHBsb2RlJDMgPSAocywgZCkgPT4ge1xuICAgICAgaWYgKCFzIHx8IGlzJDMocywgJ2FycmF5JykpIHtcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFwJDEocy5zcGxpdChkIHx8ICcsJyksIHRyaW0kMik7XG4gICAgfTtcbiAgICBjb25zdCBfYWRkQ2FjaGVTdWZmaXggPSB1cmwgPT4ge1xuICAgICAgY29uc3QgY2FjaGVTdWZmaXggPSBFbnYuY2FjaGVTdWZmaXg7XG4gICAgICBpZiAoY2FjaGVTdWZmaXgpIHtcbiAgICAgICAgdXJsICs9ICh1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgKyBjYWNoZVN1ZmZpeDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1cmw7XG4gICAgfTtcbiAgICBjb25zdCBUb29scyA9IHtcbiAgICAgIHRyaW06IHRyaW0kMixcbiAgICAgIGlzQXJyYXk6IGlzQXJyYXksXG4gICAgICBpczogaXMkMyxcbiAgICAgIHRvQXJyYXk6IHRvQXJyYXkkMSxcbiAgICAgIG1ha2VNYXA6IG1ha2VNYXAkNCxcbiAgICAgIGVhY2g6IGVhY2gkZSxcbiAgICAgIG1hcDogbWFwJDEsXG4gICAgICBncmVwOiBmaWx0ZXIkNCxcbiAgICAgIGluQXJyYXk6IGluZGV4T2YsXG4gICAgICBoYXNPd246IGhhc093blByb3BlcnR5JDEsXG4gICAgICBleHRlbmQ6IGV4dGVuZCQzLFxuICAgICAgd2Fsazogd2FsayQ0LFxuICAgICAgcmVzb2x2ZTogcmVzb2x2ZSQyLFxuICAgICAgZXhwbG9kZTogZXhwbG9kZSQzLFxuICAgICAgX2FkZENhY2hlU3VmZml4XG4gICAgfTtcblxuICAgIGNvbnN0IGlzJDIgPSAobGhzLCByaHMsIGNvbXBhcmF0b3IgPSB0cmlwbGVFcXVhbHMpID0+IGxocy5leGlzdHMobGVmdCA9PiBjb21wYXJhdG9yKGxlZnQsIHJocykpO1xuICAgIGNvbnN0IGNhdCA9IGFyciA9PiB7XG4gICAgICBjb25zdCByID0gW107XG4gICAgICBjb25zdCBwdXNoID0geCA9PiB7XG4gICAgICAgIHIucHVzaCh4KTtcbiAgICAgIH07XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJbaV0uZWFjaChwdXNoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgY29uc3QgbGlmdDIgPSAob2EsIG9iLCBmKSA9PiBvYS5pc1NvbWUoKSAmJiBvYi5pc1NvbWUoKSA/IE9wdGlvbmFsLnNvbWUoZihvYS5nZXRPckRpZSgpLCBvYi5nZXRPckRpZSgpKSkgOiBPcHRpb25hbC5ub25lKCk7XG4gICAgY29uc3QgbGlmdDMgPSAob2EsIG9iLCBvYywgZikgPT4gb2EuaXNTb21lKCkgJiYgb2IuaXNTb21lKCkgJiYgb2MuaXNTb21lKCkgPyBPcHRpb25hbC5zb21lKGYob2EuZ2V0T3JEaWUoKSwgb2IuZ2V0T3JEaWUoKSwgb2MuZ2V0T3JEaWUoKSkpIDogT3B0aW9uYWwubm9uZSgpO1xuICAgIGNvbnN0IHNvbWVJZiA9IChiLCBhKSA9PiBiID8gT3B0aW9uYWwuc29tZShhKSA6IE9wdGlvbmFsLm5vbmUoKTtcblxuICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogRnVuY3Rpb24oJ3JldHVybiB0aGlzOycpKCk7XG5cbiAgICBjb25zdCBDT01NRU5UID0gODtcbiAgICBjb25zdCBET0NVTUVOVCA9IDk7XG4gICAgY29uc3QgRE9DVU1FTlRfRlJBR01FTlQgPSAxMTtcbiAgICBjb25zdCBFTEVNRU5UID0gMTtcbiAgICBjb25zdCBURVhUID0gMztcblxuICAgIGNvbnN0IG5hbWUgPSBlbGVtZW50ID0+IHtcbiAgICAgIGNvbnN0IHIgPSBlbGVtZW50LmRvbS5ub2RlTmFtZTtcbiAgICAgIHJldHVybiByLnRvTG93ZXJDYXNlKCk7XG4gICAgfTtcbiAgICBjb25zdCB0eXBlJDEgPSBlbGVtZW50ID0+IGVsZW1lbnQuZG9tLm5vZGVUeXBlO1xuICAgIGNvbnN0IGlzVHlwZSA9IHQgPT4gZWxlbWVudCA9PiB0eXBlJDEoZWxlbWVudCkgPT09IHQ7XG4gICAgY29uc3QgaXNDb21tZW50JDEgPSBlbGVtZW50ID0+IHR5cGUkMShlbGVtZW50KSA9PT0gQ09NTUVOVCB8fCBuYW1lKGVsZW1lbnQpID09PSAnI2NvbW1lbnQnO1xuICAgIGNvbnN0IGlzRWxlbWVudCQ3ID0gaXNUeXBlKEVMRU1FTlQpO1xuICAgIGNvbnN0IGlzVGV4dCQ5ID0gaXNUeXBlKFRFWFQpO1xuICAgIGNvbnN0IGlzRG9jdW1lbnQkMiA9IGlzVHlwZShET0NVTUVOVCk7XG4gICAgY29uc3QgaXNEb2N1bWVudEZyYWdtZW50JDEgPSBpc1R5cGUoRE9DVU1FTlRfRlJBR01FTlQpO1xuICAgIGNvbnN0IGlzVGFnID0gdGFnID0+IGUgPT4gaXNFbGVtZW50JDcoZSkgJiYgbmFtZShlKSA9PT0gdGFnO1xuXG4gICAgY29uc3QgcmF3U2V0ID0gKGRvbSwga2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgaWYgKGlzU3RyaW5nKHZhbHVlKSB8fCBpc0Jvb2xlYW4odmFsdWUpIHx8IGlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICBkb20uc2V0QXR0cmlidXRlKGtleSwgdmFsdWUgKyAnJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIGNhbGwgdG8gQXR0cmlidXRlLnNldC4gS2V5ICcsIGtleSwgJzo6IFZhbHVlICcsIHZhbHVlLCAnOjogRWxlbWVudCAnLCBkb20pO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dHJpYnV0ZSB2YWx1ZSB3YXMgbm90IHNpbXBsZScpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgc2V0JDIgPSAoZWxlbWVudCwga2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgcmF3U2V0KGVsZW1lbnQuZG9tLCBrZXksIHZhbHVlKTtcbiAgICB9O1xuICAgIGNvbnN0IHNldEFsbCQxID0gKGVsZW1lbnQsIGF0dHJzKSA9PiB7XG4gICAgICBjb25zdCBkb20gPSBlbGVtZW50LmRvbTtcbiAgICAgIGVhY2gkZihhdHRycywgKHYsIGspID0+IHtcbiAgICAgICAgcmF3U2V0KGRvbSwgaywgdik7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGdldCQ5ID0gKGVsZW1lbnQsIGtleSkgPT4ge1xuICAgICAgY29uc3QgdiA9IGVsZW1lbnQuZG9tLmdldEF0dHJpYnV0ZShrZXkpO1xuICAgICAgcmV0dXJuIHYgPT09IG51bGwgPyB1bmRlZmluZWQgOiB2O1xuICAgIH07XG4gICAgY29uc3QgZ2V0T3B0ID0gKGVsZW1lbnQsIGtleSkgPT4gT3B0aW9uYWwuZnJvbShnZXQkOShlbGVtZW50LCBrZXkpKTtcbiAgICBjb25zdCBoYXMkMSA9IChlbGVtZW50LCBrZXkpID0+IHtcbiAgICAgIGNvbnN0IGRvbSA9IGVsZW1lbnQuZG9tO1xuICAgICAgcmV0dXJuIGRvbSAmJiBkb20uaGFzQXR0cmlidXRlID8gZG9tLmhhc0F0dHJpYnV0ZShrZXkpIDogZmFsc2U7XG4gICAgfTtcbiAgICBjb25zdCByZW1vdmUkYSA9IChlbGVtZW50LCBrZXkpID0+IHtcbiAgICAgIGVsZW1lbnQuZG9tLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgIH07XG4gICAgY29uc3QgaGFzTm9uZSA9IGVsZW1lbnQgPT4ge1xuICAgICAgY29uc3QgYXR0cnMgPSBlbGVtZW50LmRvbS5hdHRyaWJ1dGVzO1xuICAgICAgcmV0dXJuIGF0dHJzID09PSB1bmRlZmluZWQgfHwgYXR0cnMgPT09IG51bGwgfHwgYXR0cnMubGVuZ3RoID09PSAwO1xuICAgIH07XG4gICAgY29uc3QgY2xvbmUkNCA9IGVsZW1lbnQgPT4gZm9sZGwoZWxlbWVudC5kb20uYXR0cmlidXRlcywgKGFjYywgYXR0cikgPT4ge1xuICAgICAgYWNjW2F0dHIubmFtZV0gPSBhdHRyLnZhbHVlO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG5cbiAgICBjb25zdCByZWFkJDQgPSAoZWxlbWVudCwgYXR0cikgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSBnZXQkOShlbGVtZW50LCBhdHRyKTtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSAnJyA/IFtdIDogdmFsdWUuc3BsaXQoJyAnKTtcbiAgICB9O1xuICAgIGNvbnN0IGFkZCQ0ID0gKGVsZW1lbnQsIGF0dHIsIGlkKSA9PiB7XG4gICAgICBjb25zdCBvbGQgPSByZWFkJDQoZWxlbWVudCwgYXR0cik7XG4gICAgICBjb25zdCBudSA9IG9sZC5jb25jYXQoW2lkXSk7XG4gICAgICBzZXQkMihlbGVtZW50LCBhdHRyLCBudS5qb2luKCcgJykpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBjb25zdCByZW1vdmUkOSA9IChlbGVtZW50LCBhdHRyLCBpZCkgPT4ge1xuICAgICAgY29uc3QgbnUgPSBmaWx0ZXIkNihyZWFkJDQoZWxlbWVudCwgYXR0ciksIHYgPT4gdiAhPT0gaWQpO1xuICAgICAgaWYgKG51Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgc2V0JDIoZWxlbWVudCwgYXR0ciwgbnUuam9pbignICcpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbW92ZSRhKGVsZW1lbnQsIGF0dHIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBjb25zdCBzdXBwb3J0cyA9IGVsZW1lbnQgPT4gZWxlbWVudC5kb20uY2xhc3NMaXN0ICE9PSB1bmRlZmluZWQ7XG4gICAgY29uc3QgZ2V0JDggPSBlbGVtZW50ID0+IHJlYWQkNChlbGVtZW50LCAnY2xhc3MnKTtcbiAgICBjb25zdCBhZGQkMyA9IChlbGVtZW50LCBjbGF6eikgPT4gYWRkJDQoZWxlbWVudCwgJ2NsYXNzJywgY2xhenopO1xuICAgIGNvbnN0IHJlbW92ZSQ4ID0gKGVsZW1lbnQsIGNsYXp6KSA9PiByZW1vdmUkOShlbGVtZW50LCAnY2xhc3MnLCBjbGF6eik7XG4gICAgY29uc3QgdG9nZ2xlJDIgPSAoZWxlbWVudCwgY2xhenopID0+IHtcbiAgICAgIGlmIChjb250YWlucyQyKGdldCQ4KGVsZW1lbnQpLCBjbGF6eikpIHtcbiAgICAgICAgcmV0dXJuIHJlbW92ZSQ4KGVsZW1lbnQsIGNsYXp6KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBhZGQkMyhlbGVtZW50LCBjbGF6eik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGFkZCQyID0gKGVsZW1lbnQsIGNsYXp6KSA9PiB7XG4gICAgICBpZiAoc3VwcG9ydHMoZWxlbWVudCkpIHtcbiAgICAgICAgZWxlbWVudC5kb20uY2xhc3NMaXN0LmFkZChjbGF6eik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZGQkMyhlbGVtZW50LCBjbGF6eik7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBjbGVhbkNsYXNzID0gZWxlbWVudCA9PiB7XG4gICAgICBjb25zdCBjbGFzc0xpc3QgPSBzdXBwb3J0cyhlbGVtZW50KSA/IGVsZW1lbnQuZG9tLmNsYXNzTGlzdCA6IGdldCQ4KGVsZW1lbnQpO1xuICAgICAgaWYgKGNsYXNzTGlzdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmVtb3ZlJGEoZWxlbWVudCwgJ2NsYXNzJyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCByZW1vdmUkNyA9IChlbGVtZW50LCBjbGF6eikgPT4ge1xuICAgICAgaWYgKHN1cHBvcnRzKGVsZW1lbnQpKSB7XG4gICAgICAgIGNvbnN0IGNsYXNzTGlzdCA9IGVsZW1lbnQuZG9tLmNsYXNzTGlzdDtcbiAgICAgICAgY2xhc3NMaXN0LnJlbW92ZShjbGF6eik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW1vdmUkOChlbGVtZW50LCBjbGF6eik7XG4gICAgICB9XG4gICAgICBjbGVhbkNsYXNzKGVsZW1lbnQpO1xuICAgIH07XG4gICAgY29uc3QgdG9nZ2xlJDEgPSAoZWxlbWVudCwgY2xhenopID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHN1cHBvcnRzKGVsZW1lbnQpID8gZWxlbWVudC5kb20uY2xhc3NMaXN0LnRvZ2dsZShjbGF6eikgOiB0b2dnbGUkMihlbGVtZW50LCBjbGF6eik7XG4gICAgICBjbGVhbkNsYXNzKGVsZW1lbnQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIGNvbnN0IGhhcyA9IChlbGVtZW50LCBjbGF6eikgPT4gc3VwcG9ydHMoZWxlbWVudCkgJiYgZWxlbWVudC5kb20uY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXp6KTtcblxuICAgIGNvbnN0IGlzU3VwcG9ydGVkJDEgPSBkb20gPT4gZG9tLnN0eWxlICE9PSB1bmRlZmluZWQgJiYgaXNGdW5jdGlvbihkb20uc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSk7XG5cbiAgICBjb25zdCBmcm9tSHRtbCQxID0gKGh0bWwsIHNjb3BlKSA9PiB7XG4gICAgICBjb25zdCBkb2MgPSBzY29wZSB8fCBkb2N1bWVudDtcbiAgICAgIGNvbnN0IGRpdiA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGRpdi5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgaWYgKCFkaXYuaGFzQ2hpbGROb2RlcygpIHx8IGRpdi5jaGlsZE5vZGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9ICdIVE1MIGRvZXMgbm90IGhhdmUgYSBzaW5nbGUgcm9vdCBub2RlJztcbiAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlLCBodG1sKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21Eb20kMihkaXYuY2hpbGROb2Rlc1swXSk7XG4gICAgfTtcbiAgICBjb25zdCBmcm9tVGFnID0gKHRhZywgc2NvcGUpID0+IHtcbiAgICAgIGNvbnN0IGRvYyA9IHNjb3BlIHx8IGRvY3VtZW50O1xuICAgICAgY29uc3Qgbm9kZSA9IGRvYy5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICByZXR1cm4gZnJvbURvbSQyKG5vZGUpO1xuICAgIH07XG4gICAgY29uc3QgZnJvbVRleHQgPSAodGV4dCwgc2NvcGUpID0+IHtcbiAgICAgIGNvbnN0IGRvYyA9IHNjb3BlIHx8IGRvY3VtZW50O1xuICAgICAgY29uc3Qgbm9kZSA9IGRvYy5jcmVhdGVUZXh0Tm9kZSh0ZXh0KTtcbiAgICAgIHJldHVybiBmcm9tRG9tJDIobm9kZSk7XG4gICAgfTtcbiAgICBjb25zdCBmcm9tRG9tJDIgPSBub2RlID0+IHtcbiAgICAgIGlmIChub2RlID09PSBudWxsIHx8IG5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vZGUgY2Fubm90IGJlIG51bGwgb3IgdW5kZWZpbmVkJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBkb206IG5vZGUgfTtcbiAgICB9O1xuICAgIGNvbnN0IGZyb21Qb2ludCQyID0gKGRvY0VsbSwgeCwgeSkgPT4gT3B0aW9uYWwuZnJvbShkb2NFbG0uZG9tLmVsZW1lbnRGcm9tUG9pbnQoeCwgeSkpLm1hcChmcm9tRG9tJDIpO1xuICAgIGNvbnN0IFN1Z2FyRWxlbWVudCA9IHtcbiAgICAgIGZyb21IdG1sOiBmcm9tSHRtbCQxLFxuICAgICAgZnJvbVRhZyxcbiAgICAgIGZyb21UZXh0LFxuICAgICAgZnJvbURvbTogZnJvbURvbSQyLFxuICAgICAgZnJvbVBvaW50OiBmcm9tUG9pbnQkMlxuICAgIH07XG5cbiAgICBjb25zdCB0b0FycmF5ID0gKHRhcmdldCwgZikgPT4ge1xuICAgICAgY29uc3QgciA9IFtdO1xuICAgICAgY29uc3QgcmVjdXJzZSA9IGUgPT4ge1xuICAgICAgICByLnB1c2goZSk7XG4gICAgICAgIHJldHVybiBmKGUpO1xuICAgICAgfTtcbiAgICAgIGxldCBjdXIgPSBmKHRhcmdldCk7XG4gICAgICBkbyB7XG4gICAgICAgIGN1ciA9IGN1ci5iaW5kKHJlY3Vyc2UpO1xuICAgICAgfSB3aGlsZSAoY3VyLmlzU29tZSgpKTtcbiAgICAgIHJldHVybiByO1xuICAgIH07XG5cbiAgICBjb25zdCBpcyQxID0gKGVsZW1lbnQsIHNlbGVjdG9yKSA9PiB7XG4gICAgICBjb25zdCBkb20gPSBlbGVtZW50LmRvbTtcbiAgICAgIGlmIChkb20ubm9kZVR5cGUgIT09IEVMRU1FTlQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZWxlbSA9IGRvbTtcbiAgICAgICAgaWYgKGVsZW0ubWF0Y2hlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIGVsZW0ubWF0Y2hlcyhzZWxlY3Rvcik7XG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbS5tc01hdGNoZXNTZWxlY3RvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIGVsZW0ubXNNYXRjaGVzU2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgICAgICB9IGVsc2UgaWYgKGVsZW0ud2Via2l0TWF0Y2hlc1NlbGVjdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gZWxlbS53ZWJraXRNYXRjaGVzU2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgICAgICB9IGVsc2UgaWYgKGVsZW0ubW96TWF0Y2hlc1NlbGVjdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gZWxlbS5tb3pNYXRjaGVzU2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQnJvd3NlciBsYWNrcyBuYXRpdmUgc2VsZWN0b3JzJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGJ5cGFzc1NlbGVjdG9yID0gZG9tID0+IGRvbS5ub2RlVHlwZSAhPT0gRUxFTUVOVCAmJiBkb20ubm9kZVR5cGUgIT09IERPQ1VNRU5UICYmIGRvbS5ub2RlVHlwZSAhPT0gRE9DVU1FTlRfRlJBR01FTlQgfHwgZG9tLmNoaWxkRWxlbWVudENvdW50ID09PSAwO1xuICAgIGNvbnN0IGFsbCA9IChzZWxlY3Rvciwgc2NvcGUpID0+IHtcbiAgICAgIGNvbnN0IGJhc2UgPSBzY29wZSA9PT0gdW5kZWZpbmVkID8gZG9jdW1lbnQgOiBzY29wZS5kb207XG4gICAgICByZXR1cm4gYnlwYXNzU2VsZWN0b3IoYmFzZSkgPyBbXSA6IG1hcCQzKGJhc2UucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvciksIFN1Z2FyRWxlbWVudC5mcm9tRG9tKTtcbiAgICB9O1xuICAgIGNvbnN0IG9uZSA9IChzZWxlY3Rvciwgc2NvcGUpID0+IHtcbiAgICAgIGNvbnN0IGJhc2UgPSBzY29wZSA9PT0gdW5kZWZpbmVkID8gZG9jdW1lbnQgOiBzY29wZS5kb207XG4gICAgICByZXR1cm4gYnlwYXNzU2VsZWN0b3IoYmFzZSkgPyBPcHRpb25hbC5ub25lKCkgOiBPcHRpb25hbC5mcm9tKGJhc2UucXVlcnlTZWxlY3RvcihzZWxlY3RvcikpLm1hcChTdWdhckVsZW1lbnQuZnJvbURvbSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGVxID0gKGUxLCBlMikgPT4gZTEuZG9tID09PSBlMi5kb207XG4gICAgY29uc3QgY29udGFpbnMgPSAoZTEsIGUyKSA9PiB7XG4gICAgICBjb25zdCBkMSA9IGUxLmRvbTtcbiAgICAgIGNvbnN0IGQyID0gZTIuZG9tO1xuICAgICAgcmV0dXJuIGQxID09PSBkMiA/IGZhbHNlIDogZDEuY29udGFpbnMoZDIpO1xuICAgIH07XG5cbiAgICBjb25zdCBvd25lciQxID0gZWxlbWVudCA9PiBTdWdhckVsZW1lbnQuZnJvbURvbShlbGVtZW50LmRvbS5vd25lckRvY3VtZW50KTtcbiAgICBjb25zdCBkb2N1bWVudE9yT3duZXIgPSBkb3MgPT4gaXNEb2N1bWVudCQyKGRvcykgPyBkb3MgOiBvd25lciQxKGRvcyk7XG4gICAgY29uc3QgZG9jdW1lbnRFbGVtZW50ID0gZWxlbWVudCA9PiBTdWdhckVsZW1lbnQuZnJvbURvbShkb2N1bWVudE9yT3duZXIoZWxlbWVudCkuZG9tLmRvY3VtZW50RWxlbWVudCk7XG4gICAgY29uc3QgZGVmYXVsdFZpZXcgPSBlbGVtZW50ID0+IFN1Z2FyRWxlbWVudC5mcm9tRG9tKGRvY3VtZW50T3JPd25lcihlbGVtZW50KS5kb20uZGVmYXVsdFZpZXcpO1xuICAgIGNvbnN0IHBhcmVudCA9IGVsZW1lbnQgPT4gT3B0aW9uYWwuZnJvbShlbGVtZW50LmRvbS5wYXJlbnROb2RlKS5tYXAoU3VnYXJFbGVtZW50LmZyb21Eb20pO1xuICAgIGNvbnN0IHBhcmVudEVsZW1lbnQgPSBlbGVtZW50ID0+IE9wdGlvbmFsLmZyb20oZWxlbWVudC5kb20ucGFyZW50RWxlbWVudCkubWFwKFN1Z2FyRWxlbWVudC5mcm9tRG9tKTtcbiAgICBjb25zdCBwYXJlbnRzJDEgPSAoZWxlbWVudCwgaXNSb290KSA9PiB7XG4gICAgICBjb25zdCBzdG9wID0gaXNGdW5jdGlvbihpc1Jvb3QpID8gaXNSb290IDogbmV2ZXI7XG4gICAgICBsZXQgZG9tID0gZWxlbWVudC5kb207XG4gICAgICBjb25zdCByZXQgPSBbXTtcbiAgICAgIHdoaWxlIChkb20ucGFyZW50Tm9kZSAhPT0gbnVsbCAmJiBkb20ucGFyZW50Tm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHJhd1BhcmVudCA9IGRvbS5wYXJlbnROb2RlO1xuICAgICAgICBjb25zdCBwID0gU3VnYXJFbGVtZW50LmZyb21Eb20ocmF3UGFyZW50KTtcbiAgICAgICAgcmV0LnB1c2gocCk7XG4gICAgICAgIGlmIChzdG9wKHApID09PSB0cnVlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZG9tID0gcmF3UGFyZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgY29uc3Qgc2libGluZ3MgPSBlbGVtZW50ID0+IHtcbiAgICAgIGNvbnN0IGZpbHRlclNlbGYgPSBlbGVtZW50cyA9PiBmaWx0ZXIkNihlbGVtZW50cywgeCA9PiAhZXEoZWxlbWVudCwgeCkpO1xuICAgICAgcmV0dXJuIHBhcmVudChlbGVtZW50KS5tYXAoY2hpbGRyZW4pLm1hcChmaWx0ZXJTZWxmKS5nZXRPcihbXSk7XG4gICAgfTtcbiAgICBjb25zdCBwcmV2U2libGluZyA9IGVsZW1lbnQgPT4gT3B0aW9uYWwuZnJvbShlbGVtZW50LmRvbS5wcmV2aW91c1NpYmxpbmcpLm1hcChTdWdhckVsZW1lbnQuZnJvbURvbSk7XG4gICAgY29uc3QgbmV4dFNpYmxpbmcgPSBlbGVtZW50ID0+IE9wdGlvbmFsLmZyb20oZWxlbWVudC5kb20ubmV4dFNpYmxpbmcpLm1hcChTdWdhckVsZW1lbnQuZnJvbURvbSk7XG4gICAgY29uc3QgcHJldlNpYmxpbmdzID0gZWxlbWVudCA9PiByZXZlcnNlKHRvQXJyYXkoZWxlbWVudCwgcHJldlNpYmxpbmcpKTtcbiAgICBjb25zdCBuZXh0U2libGluZ3MgPSBlbGVtZW50ID0+IHRvQXJyYXkoZWxlbWVudCwgbmV4dFNpYmxpbmcpO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gZWxlbWVudCA9PiBtYXAkMyhlbGVtZW50LmRvbS5jaGlsZE5vZGVzLCBTdWdhckVsZW1lbnQuZnJvbURvbSk7XG4gICAgY29uc3QgY2hpbGQkMSA9IChlbGVtZW50LCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgY3MgPSBlbGVtZW50LmRvbS5jaGlsZE5vZGVzO1xuICAgICAgcmV0dXJuIE9wdGlvbmFsLmZyb20oY3NbaW5kZXhdKS5tYXAoU3VnYXJFbGVtZW50LmZyb21Eb20pO1xuICAgIH07XG4gICAgY29uc3QgZmlyc3RDaGlsZCA9IGVsZW1lbnQgPT4gY2hpbGQkMShlbGVtZW50LCAwKTtcbiAgICBjb25zdCBsYXN0Q2hpbGQgPSBlbGVtZW50ID0+IGNoaWxkJDEoZWxlbWVudCwgZWxlbWVudC5kb20uY2hpbGROb2Rlcy5sZW5ndGggLSAxKTtcbiAgICBjb25zdCBjaGlsZE5vZGVzQ291bnQgPSBlbGVtZW50ID0+IGVsZW1lbnQuZG9tLmNoaWxkTm9kZXMubGVuZ3RoO1xuXG4gICAgY29uc3QgZ2V0SGVhZCA9IGRvYyA9PiB7XG4gICAgICBjb25zdCBiID0gZG9jLmRvbS5oZWFkO1xuICAgICAgaWYgKGIgPT09IG51bGwgfHwgYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGVhZCBpcyBub3QgYXZhaWxhYmxlIHlldCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFN1Z2FyRWxlbWVudC5mcm9tRG9tKGIpO1xuICAgIH07XG5cbiAgICBjb25zdCBpc1NoYWRvd1Jvb3QgPSBkb3MgPT4gaXNEb2N1bWVudEZyYWdtZW50JDEoZG9zKSAmJiBpc05vbk51bGxhYmxlKGRvcy5kb20uaG9zdCk7XG4gICAgY29uc3Qgc3VwcG9ydGVkID0gaXNGdW5jdGlvbihFbGVtZW50LnByb3RvdHlwZS5hdHRhY2hTaGFkb3cpICYmIGlzRnVuY3Rpb24oTm9kZS5wcm90b3R5cGUuZ2V0Um9vdE5vZGUpO1xuICAgIGNvbnN0IGlzU3VwcG9ydGVkID0gY29uc3RhbnQoc3VwcG9ydGVkKTtcbiAgICBjb25zdCBnZXRSb290Tm9kZSA9IHN1cHBvcnRlZCA/IGUgPT4gU3VnYXJFbGVtZW50LmZyb21Eb20oZS5kb20uZ2V0Um9vdE5vZGUoKSkgOiBkb2N1bWVudE9yT3duZXI7XG4gICAgY29uc3QgZ2V0U3R5bGVDb250YWluZXIgPSBkb3MgPT4gaXNTaGFkb3dSb290KGRvcykgPyBkb3MgOiBnZXRIZWFkKGRvY3VtZW50T3JPd25lcihkb3MpKTtcbiAgICBjb25zdCBnZXRTaGFkb3dSb290ID0gZSA9PiB7XG4gICAgICBjb25zdCByID0gZ2V0Um9vdE5vZGUoZSk7XG4gICAgICByZXR1cm4gaXNTaGFkb3dSb290KHIpID8gT3B0aW9uYWwuc29tZShyKSA6IE9wdGlvbmFsLm5vbmUoKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldFNoYWRvd0hvc3QgPSBlID0+IFN1Z2FyRWxlbWVudC5mcm9tRG9tKGUuZG9tLmhvc3QpO1xuICAgIGNvbnN0IGdldE9yaWdpbmFsRXZlbnRUYXJnZXQgPSBldmVudCA9PiB7XG4gICAgICBpZiAoaXNTdXBwb3J0ZWQoKSAmJiBpc05vbk51bGxhYmxlKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgY29uc3QgZWwgPSBTdWdhckVsZW1lbnQuZnJvbURvbShldmVudC50YXJnZXQpO1xuICAgICAgICBpZiAoaXNFbGVtZW50JDcoZWwpICYmIGlzT3BlblNoYWRvd0hvc3QoZWwpKSB7XG4gICAgICAgICAgaWYgKGV2ZW50LmNvbXBvc2VkICYmIGV2ZW50LmNvbXBvc2VkUGF0aCkge1xuICAgICAgICAgICAgY29uc3QgY29tcG9zZWRQYXRoID0gZXZlbnQuY29tcG9zZWRQYXRoKCk7XG4gICAgICAgICAgICBpZiAoY29tcG9zZWRQYXRoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoZWFkKGNvbXBvc2VkUGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gT3B0aW9uYWwuZnJvbShldmVudC50YXJnZXQpO1xuICAgIH07XG4gICAgY29uc3QgaXNPcGVuU2hhZG93SG9zdCA9IGVsZW1lbnQgPT4gaXNOb25OdWxsYWJsZShlbGVtZW50LmRvbS5zaGFkb3dSb290KTtcblxuICAgIGNvbnN0IGluQm9keSA9IGVsZW1lbnQgPT4ge1xuICAgICAgY29uc3QgZG9tID0gaXNUZXh0JDkoZWxlbWVudCkgPyBlbGVtZW50LmRvbS5wYXJlbnROb2RlIDogZWxlbWVudC5kb207XG4gICAgICBpZiAoZG9tID09PSB1bmRlZmluZWQgfHwgZG9tID09PSBudWxsIHx8IGRvbS5vd25lckRvY3VtZW50ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRvYyA9IGRvbS5vd25lckRvY3VtZW50O1xuICAgICAgcmV0dXJuIGdldFNoYWRvd1Jvb3QoU3VnYXJFbGVtZW50LmZyb21Eb20oZG9tKSkuZm9sZCgoKSA9PiBkb2MuYm9keS5jb250YWlucyhkb20pLCBjb21wb3NlMShpbkJvZHksIGdldFNoYWRvd0hvc3QpKTtcbiAgICB9O1xuXG4gICAgY29uc3QgaW50ZXJuYWxTZXQgPSAoZG9tLCBwcm9wZXJ0eSwgdmFsdWUpID0+IHtcbiAgICAgIGlmICghaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgY2FsbCB0byBDU1Muc2V0LiBQcm9wZXJ0eSAnLCBwcm9wZXJ0eSwgJzo6IFZhbHVlICcsIHZhbHVlLCAnOjogRWxlbWVudCAnLCBkb20pO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NTUyB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nOiAnICsgdmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKGlzU3VwcG9ydGVkJDEoZG9tKSkge1xuICAgICAgICBkb20uc3R5bGUuc2V0UHJvcGVydHkocHJvcGVydHksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGludGVybmFsUmVtb3ZlID0gKGRvbSwgcHJvcGVydHkpID0+IHtcbiAgICAgIGlmIChpc1N1cHBvcnRlZCQxKGRvbSkpIHtcbiAgICAgICAgZG9tLnN0eWxlLnJlbW92ZVByb3BlcnR5KHByb3BlcnR5KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHNldCQxID0gKGVsZW1lbnQsIHByb3BlcnR5LCB2YWx1ZSkgPT4ge1xuICAgICAgY29uc3QgZG9tID0gZWxlbWVudC5kb207XG4gICAgICBpbnRlcm5hbFNldChkb20sIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgfTtcbiAgICBjb25zdCBzZXRBbGwgPSAoZWxlbWVudCwgY3NzKSA9PiB7XG4gICAgICBjb25zdCBkb20gPSBlbGVtZW50LmRvbTtcbiAgICAgIGVhY2gkZihjc3MsICh2LCBrKSA9PiB7XG4gICAgICAgIGludGVybmFsU2V0KGRvbSwgaywgdik7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGdldCQ3ID0gKGVsZW1lbnQsIHByb3BlcnR5KSA9PiB7XG4gICAgICBjb25zdCBkb20gPSBlbGVtZW50LmRvbTtcbiAgICAgIGNvbnN0IHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvbSk7XG4gICAgICBjb25zdCByID0gc3R5bGVzLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpO1xuICAgICAgcmV0dXJuIHIgPT09ICcnICYmICFpbkJvZHkoZWxlbWVudCkgPyBnZXRVbnNhZmVQcm9wZXJ0eShkb20sIHByb3BlcnR5KSA6IHI7XG4gICAgfTtcbiAgICBjb25zdCBnZXRVbnNhZmVQcm9wZXJ0eSA9IChkb20sIHByb3BlcnR5KSA9PiBpc1N1cHBvcnRlZCQxKGRvbSkgPyBkb20uc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eSkgOiAnJztcbiAgICBjb25zdCBnZXRSYXckMSA9IChlbGVtZW50LCBwcm9wZXJ0eSkgPT4ge1xuICAgICAgY29uc3QgZG9tID0gZWxlbWVudC5kb207XG4gICAgICBjb25zdCByYXcgPSBnZXRVbnNhZmVQcm9wZXJ0eShkb20sIHByb3BlcnR5KTtcbiAgICAgIHJldHVybiBPcHRpb25hbC5mcm9tKHJhdykuZmlsdGVyKHIgPT4gci5sZW5ndGggPiAwKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldEFsbFJhdyA9IGVsZW1lbnQgPT4ge1xuICAgICAgY29uc3QgY3NzID0ge307XG4gICAgICBjb25zdCBkb20gPSBlbGVtZW50LmRvbTtcbiAgICAgIGlmIChpc1N1cHBvcnRlZCQxKGRvbSkpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkb20uc3R5bGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBydWxlTmFtZSA9IGRvbS5zdHlsZS5pdGVtKGkpO1xuICAgICAgICAgIGNzc1tydWxlTmFtZV0gPSBkb20uc3R5bGVbcnVsZU5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY3NzO1xuICAgIH07XG4gICAgY29uc3QgcmVtb3ZlJDYgPSAoZWxlbWVudCwgcHJvcGVydHkpID0+IHtcbiAgICAgIGNvbnN0IGRvbSA9IGVsZW1lbnQuZG9tO1xuICAgICAgaW50ZXJuYWxSZW1vdmUoZG9tLCBwcm9wZXJ0eSk7XG4gICAgICBpZiAoaXMkMihnZXRPcHQoZWxlbWVudCwgJ3N0eWxlJykubWFwKHRyaW0kMyksICcnKSkge1xuICAgICAgICByZW1vdmUkYShlbGVtZW50LCAnc3R5bGUnKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlZmxvdyA9IGUgPT4gZS5kb20ub2Zmc2V0V2lkdGg7XG5cbiAgICBjb25zdCBiZWZvcmUkMyA9IChtYXJrZXIsIGVsZW1lbnQpID0+IHtcbiAgICAgIGNvbnN0IHBhcmVudCQxID0gcGFyZW50KG1hcmtlcik7XG4gICAgICBwYXJlbnQkMS5lYWNoKHYgPT4ge1xuICAgICAgICB2LmRvbS5pbnNlcnRCZWZvcmUoZWxlbWVudC5kb20sIG1hcmtlci5kb20pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBhZnRlciQ0ID0gKG1hcmtlciwgZWxlbWVudCkgPT4ge1xuICAgICAgY29uc3Qgc2libGluZyA9IG5leHRTaWJsaW5nKG1hcmtlcik7XG4gICAgICBzaWJsaW5nLmZvbGQoKCkgPT4ge1xuICAgICAgICBjb25zdCBwYXJlbnQkMSA9IHBhcmVudChtYXJrZXIpO1xuICAgICAgICBwYXJlbnQkMS5lYWNoKHYgPT4ge1xuICAgICAgICAgIGFwcGVuZCQxKHYsIGVsZW1lbnQpO1xuICAgICAgICB9KTtcbiAgICAgIH0sIHYgPT4ge1xuICAgICAgICBiZWZvcmUkMyh2LCBlbGVtZW50KTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgcHJlcGVuZCA9IChwYXJlbnQsIGVsZW1lbnQpID0+IHtcbiAgICAgIGNvbnN0IGZpcnN0Q2hpbGQkMSA9IGZpcnN0Q2hpbGQocGFyZW50KTtcbiAgICAgIGZpcnN0Q2hpbGQkMS5mb2xkKCgpID0+IHtcbiAgICAgICAgYXBwZW5kJDEocGFyZW50LCBlbGVtZW50KTtcbiAgICAgIH0sIHYgPT4ge1xuICAgICAgICBwYXJlbnQuZG9tLmluc2VydEJlZm9yZShlbGVtZW50LmRvbSwgdi5kb20pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBhcHBlbmQkMSA9IChwYXJlbnQsIGVsZW1lbnQpID0+IHtcbiAgICAgIHBhcmVudC5kb20uYXBwZW5kQ2hpbGQoZWxlbWVudC5kb20pO1xuICAgIH07XG4gICAgY29uc3Qgd3JhcCQyID0gKGVsZW1lbnQsIHdyYXBwZXIpID0+IHtcbiAgICAgIGJlZm9yZSQzKGVsZW1lbnQsIHdyYXBwZXIpO1xuICAgICAgYXBwZW5kJDEod3JhcHBlciwgZWxlbWVudCk7XG4gICAgfTtcblxuICAgIGNvbnN0IGFmdGVyJDMgPSAobWFya2VyLCBlbGVtZW50cykgPT4ge1xuICAgICAgZWFjaCRnKGVsZW1lbnRzLCAoeCwgaSkgPT4ge1xuICAgICAgICBjb25zdCBlID0gaSA9PT0gMCA/IG1hcmtlciA6IGVsZW1lbnRzW2kgLSAxXTtcbiAgICAgICAgYWZ0ZXIkNChlLCB4KTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgYXBwZW5kID0gKHBhcmVudCwgZWxlbWVudHMpID0+IHtcbiAgICAgIGVhY2gkZyhlbGVtZW50cywgeCA9PiB7XG4gICAgICAgIGFwcGVuZCQxKHBhcmVudCwgeCk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3QgZW1wdHkgPSBlbGVtZW50ID0+IHtcbiAgICAgIGVsZW1lbnQuZG9tLnRleHRDb250ZW50ID0gJyc7XG4gICAgICBlYWNoJGcoY2hpbGRyZW4oZWxlbWVudCksIHJvZ3VlID0+IHtcbiAgICAgICAgcmVtb3ZlJDUocm9ndWUpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCByZW1vdmUkNSA9IGVsZW1lbnQgPT4ge1xuICAgICAgY29uc3QgZG9tID0gZWxlbWVudC5kb207XG4gICAgICBpZiAoZG9tLnBhcmVudE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgZG9tLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZG9tKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHVud3JhcCA9IHdyYXBwZXIgPT4ge1xuICAgICAgY29uc3QgY2hpbGRyZW4kMSA9IGNoaWxkcmVuKHdyYXBwZXIpO1xuICAgICAgaWYgKGNoaWxkcmVuJDEubGVuZ3RoID4gMCkge1xuICAgICAgICBhZnRlciQzKHdyYXBwZXIsIGNoaWxkcmVuJDEpO1xuICAgICAgfVxuICAgICAgcmVtb3ZlJDUod3JhcHBlcik7XG4gICAgfTtcblxuICAgIGNvbnN0IGZyb21IdG1sID0gKGh0bWwsIHNjb3BlKSA9PiB7XG4gICAgICBjb25zdCBkb2MgPSBzY29wZSB8fCBkb2N1bWVudDtcbiAgICAgIGNvbnN0IGRpdiA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGRpdi5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgcmV0dXJuIGNoaWxkcmVuKFN1Z2FyRWxlbWVudC5mcm9tRG9tKGRpdikpO1xuICAgIH07XG4gICAgY29uc3QgZnJvbURvbSQxID0gbm9kZXMgPT4gbWFwJDMobm9kZXMsIFN1Z2FyRWxlbWVudC5mcm9tRG9tKTtcblxuICAgIGNvbnN0IGdldCQ2ID0gZWxlbWVudCA9PiBlbGVtZW50LmRvbS5pbm5lckhUTUw7XG4gICAgY29uc3Qgc2V0ID0gKGVsZW1lbnQsIGNvbnRlbnQpID0+IHtcbiAgICAgIGNvbnN0IG93bmVyID0gb3duZXIkMShlbGVtZW50KTtcbiAgICAgIGNvbnN0IGRvY0RvbSA9IG93bmVyLmRvbTtcbiAgICAgIGNvbnN0IGZyYWdtZW50ID0gU3VnYXJFbGVtZW50LmZyb21Eb20oZG9jRG9tLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSk7XG4gICAgICBjb25zdCBjb250ZW50RWxlbWVudHMgPSBmcm9tSHRtbChjb250ZW50LCBkb2NEb20pO1xuICAgICAgYXBwZW5kKGZyYWdtZW50LCBjb250ZW50RWxlbWVudHMpO1xuICAgICAgZW1wdHkoZWxlbWVudCk7XG4gICAgICBhcHBlbmQkMShlbGVtZW50LCBmcmFnbWVudCk7XG4gICAgfTtcbiAgICBjb25zdCBnZXRPdXRlciA9IGVsZW1lbnQgPT4ge1xuICAgICAgY29uc3QgY29udGFpbmVyID0gU3VnYXJFbGVtZW50LmZyb21UYWcoJ2RpdicpO1xuICAgICAgY29uc3QgY2xvbmUgPSBTdWdhckVsZW1lbnQuZnJvbURvbShlbGVtZW50LmRvbS5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgICAgYXBwZW5kJDEoY29udGFpbmVyLCBjbG9uZSk7XG4gICAgICByZXR1cm4gZ2V0JDYoY29udGFpbmVyKTtcbiAgICB9O1xuXG4gICAgY29uc3QgbWtFdmVudCA9ICh0YXJnZXQsIHgsIHksIHN0b3AsIHByZXZlbnQsIGtpbGwsIHJhdykgPT4gKHtcbiAgICAgIHRhcmdldCxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgc3RvcCxcbiAgICAgIHByZXZlbnQsXG4gICAgICBraWxsLFxuICAgICAgcmF3XG4gICAgfSk7XG4gICAgY29uc3QgZnJvbVJhd0V2ZW50ID0gcmF3RXZlbnQgPT4ge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gU3VnYXJFbGVtZW50LmZyb21Eb20oZ2V0T3JpZ2luYWxFdmVudFRhcmdldChyYXdFdmVudCkuZ2V0T3IocmF3RXZlbnQudGFyZ2V0KSk7XG4gICAgICBjb25zdCBzdG9wID0gKCkgPT4gcmF3RXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBjb25zdCBwcmV2ZW50ID0gKCkgPT4gcmF3RXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGNvbnN0IGtpbGwgPSBjb21wb3NlKHByZXZlbnQsIHN0b3ApO1xuICAgICAgcmV0dXJuIG1rRXZlbnQodGFyZ2V0LCByYXdFdmVudC5jbGllbnRYLCByYXdFdmVudC5jbGllbnRZLCBzdG9wLCBwcmV2ZW50LCBraWxsLCByYXdFdmVudCk7XG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGUkMSA9IChmaWx0ZXIsIGhhbmRsZXIpID0+IHJhd0V2ZW50ID0+IHtcbiAgICAgIGlmIChmaWx0ZXIocmF3RXZlbnQpKSB7XG4gICAgICAgIGhhbmRsZXIoZnJvbVJhd0V2ZW50KHJhd0V2ZW50KSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBiaW5kZXIgPSAoZWxlbWVudCwgZXZlbnQsIGZpbHRlciwgaGFuZGxlciwgdXNlQ2FwdHVyZSkgPT4ge1xuICAgICAgY29uc3Qgd3JhcHBlZCA9IGhhbmRsZSQxKGZpbHRlciwgaGFuZGxlcik7XG4gICAgICBlbGVtZW50LmRvbS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCB3cmFwcGVkLCB1c2VDYXB0dXJlKTtcbiAgICAgIHJldHVybiB7IHVuYmluZDogY3VycnkodW5iaW5kLCBlbGVtZW50LCBldmVudCwgd3JhcHBlZCwgdXNlQ2FwdHVyZSkgfTtcbiAgICB9O1xuICAgIGNvbnN0IGJpbmQkMiA9IChlbGVtZW50LCBldmVudCwgZmlsdGVyLCBoYW5kbGVyKSA9PiBiaW5kZXIoZWxlbWVudCwgZXZlbnQsIGZpbHRlciwgaGFuZGxlciwgZmFsc2UpO1xuICAgIGNvbnN0IHVuYmluZCA9IChlbGVtZW50LCBldmVudCwgaGFuZGxlciwgdXNlQ2FwdHVyZSkgPT4ge1xuICAgICAgZWxlbWVudC5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgdXNlQ2FwdHVyZSk7XG4gICAgfTtcblxuICAgIGNvbnN0IHIgPSAobGVmdCwgdG9wKSA9PiB7XG4gICAgICBjb25zdCB0cmFuc2xhdGUgPSAoeCwgeSkgPT4gcihsZWZ0ICsgeCwgdG9wICsgeSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0LFxuICAgICAgICB0b3AsXG4gICAgICAgIHRyYW5zbGF0ZVxuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IFN1Z2FyUG9zaXRpb24gPSByO1xuXG4gICAgY29uc3QgYm94UG9zaXRpb24gPSBkb20gPT4ge1xuICAgICAgY29uc3QgYm94ID0gZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgcmV0dXJuIFN1Z2FyUG9zaXRpb24oYm94LmxlZnQsIGJveC50b3ApO1xuICAgIH07XG4gICAgY29uc3QgZmlyc3REZWZpbmVkT3JaZXJvID0gKGEsIGIpID0+IHtcbiAgICAgIGlmIChhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYiAhPT0gdW5kZWZpbmVkID8gYiA6IDA7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBhYnNvbHV0ZSA9IGVsZW1lbnQgPT4ge1xuICAgICAgY29uc3QgZG9jID0gZWxlbWVudC5kb20ub3duZXJEb2N1bWVudDtcbiAgICAgIGNvbnN0IGJvZHkgPSBkb2MuYm9keTtcbiAgICAgIGNvbnN0IHdpbiA9IGRvYy5kZWZhdWx0VmlldztcbiAgICAgIGNvbnN0IGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgaWYgKGJvZHkgPT09IGVsZW1lbnQuZG9tKSB7XG4gICAgICAgIHJldHVybiBTdWdhclBvc2l0aW9uKGJvZHkub2Zmc2V0TGVmdCwgYm9keS5vZmZzZXRUb3ApO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2Nyb2xsVG9wID0gZmlyc3REZWZpbmVkT3JaZXJvKHdpbiA9PT0gbnVsbCB8fCB3aW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdpbi5wYWdlWU9mZnNldCwgaHRtbC5zY3JvbGxUb3ApO1xuICAgICAgY29uc3Qgc2Nyb2xsTGVmdCA9IGZpcnN0RGVmaW5lZE9yWmVybyh3aW4gPT09IG51bGwgfHwgd2luID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3aW4ucGFnZVhPZmZzZXQsIGh0bWwuc2Nyb2xsTGVmdCk7XG4gICAgICBjb25zdCBjbGllbnRUb3AgPSBmaXJzdERlZmluZWRPclplcm8oaHRtbC5jbGllbnRUb3AsIGJvZHkuY2xpZW50VG9wKTtcbiAgICAgIGNvbnN0IGNsaWVudExlZnQgPSBmaXJzdERlZmluZWRPclplcm8oaHRtbC5jbGllbnRMZWZ0LCBib2R5LmNsaWVudExlZnQpO1xuICAgICAgcmV0dXJuIHZpZXdwb3J0KGVsZW1lbnQpLnRyYW5zbGF0ZShzY3JvbGxMZWZ0IC0gY2xpZW50TGVmdCwgc2Nyb2xsVG9wIC0gY2xpZW50VG9wKTtcbiAgICB9O1xuICAgIGNvbnN0IHZpZXdwb3J0ID0gZWxlbWVudCA9PiB7XG4gICAgICBjb25zdCBkb20gPSBlbGVtZW50LmRvbTtcbiAgICAgIGNvbnN0IGRvYyA9IGRvbS5vd25lckRvY3VtZW50O1xuICAgICAgY29uc3QgYm9keSA9IGRvYy5ib2R5O1xuICAgICAgaWYgKGJvZHkgPT09IGRvbSkge1xuICAgICAgICByZXR1cm4gU3VnYXJQb3NpdGlvbihib2R5Lm9mZnNldExlZnQsIGJvZHkub2Zmc2V0VG9wKTtcbiAgICAgIH1cbiAgICAgIGlmICghaW5Cb2R5KGVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBTdWdhclBvc2l0aW9uKDAsIDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJveFBvc2l0aW9uKGRvbSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGdldCQ1ID0gX0RPQyA9PiB7XG4gICAgICBjb25zdCBkb2MgPSBfRE9DICE9PSB1bmRlZmluZWQgPyBfRE9DLmRvbSA6IGRvY3VtZW50O1xuICAgICAgY29uc3QgeCA9IGRvYy5ib2R5LnNjcm9sbExlZnQgfHwgZG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0O1xuICAgICAgY29uc3QgeSA9IGRvYy5ib2R5LnNjcm9sbFRvcCB8fCBkb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcDtcbiAgICAgIHJldHVybiBTdWdhclBvc2l0aW9uKHgsIHkpO1xuICAgIH07XG4gICAgY29uc3QgdG8gPSAoeCwgeSwgX0RPQykgPT4ge1xuICAgICAgY29uc3QgZG9jID0gX0RPQyAhPT0gdW5kZWZpbmVkID8gX0RPQy5kb20gOiBkb2N1bWVudDtcbiAgICAgIGNvbnN0IHdpbiA9IGRvYy5kZWZhdWx0VmlldztcbiAgICAgIGlmICh3aW4pIHtcbiAgICAgICAgd2luLnNjcm9sbFRvKHgsIHkpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaW50b1ZpZXcgPSAoZWxlbWVudCwgYWxpZ25Ub1RvcCkgPT4ge1xuICAgICAgY29uc3QgaXNTYWZhcmkgPSBkZXRlY3QkMigpLmJyb3dzZXIuaXNTYWZhcmkoKTtcbiAgICAgIGlmIChpc1NhZmFyaSAmJiBpc0Z1bmN0aW9uKGVsZW1lbnQuZG9tLnNjcm9sbEludG9WaWV3SWZOZWVkZWQpKSB7XG4gICAgICAgIGVsZW1lbnQuZG9tLnNjcm9sbEludG9WaWV3SWZOZWVkZWQoZmFsc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5kb20uc2Nyb2xsSW50b1ZpZXcoYWxpZ25Ub1RvcCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGdldCQ0ID0gX3dpbiA9PiB7XG4gICAgICBjb25zdCB3aW4gPSBfd2luID09PSB1bmRlZmluZWQgPyB3aW5kb3cgOiBfd2luO1xuICAgICAgaWYgKGRldGVjdCQyKCkuYnJvd3Nlci5pc0ZpcmVmb3goKSkge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLmZyb20od2luLnZpc3VhbFZpZXdwb3J0KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGJvdW5kcyA9ICh4LCB5LCB3aWR0aCwgaGVpZ2h0KSA9PiAoe1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHJpZ2h0OiB4ICsgd2lkdGgsXG4gICAgICBib3R0b206IHkgKyBoZWlnaHRcbiAgICB9KTtcbiAgICBjb25zdCBnZXRCb3VuZHMgPSBfd2luID0+IHtcbiAgICAgIGNvbnN0IHdpbiA9IF93aW4gPT09IHVuZGVmaW5lZCA/IHdpbmRvdyA6IF93aW47XG4gICAgICBjb25zdCBkb2MgPSB3aW4uZG9jdW1lbnQ7XG4gICAgICBjb25zdCBzY3JvbGwgPSBnZXQkNShTdWdhckVsZW1lbnQuZnJvbURvbShkb2MpKTtcbiAgICAgIHJldHVybiBnZXQkNCh3aW4pLmZvbGQoKCkgPT4ge1xuICAgICAgICBjb25zdCBodG1sID0gd2luLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBodG1sLmNsaWVudFdpZHRoO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBodG1sLmNsaWVudEhlaWdodDtcbiAgICAgICAgcmV0dXJuIGJvdW5kcyhzY3JvbGwubGVmdCwgc2Nyb2xsLnRvcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB9LCB2aXN1YWxWaWV3cG9ydCA9PiBib3VuZHMoTWF0aC5tYXgodmlzdWFsVmlld3BvcnQucGFnZUxlZnQsIHNjcm9sbC5sZWZ0KSwgTWF0aC5tYXgodmlzdWFsVmlld3BvcnQucGFnZVRvcCwgc2Nyb2xsLnRvcCksIHZpc3VhbFZpZXdwb3J0LndpZHRoLCB2aXN1YWxWaWV3cG9ydC5oZWlnaHQpKTtcbiAgICB9O1xuXG4gICAgY29uc3QgaXNOb2RlVHlwZSA9IHR5cGUgPT4ge1xuICAgICAgcmV0dXJuIG5vZGUgPT4ge1xuICAgICAgICByZXR1cm4gISFub2RlICYmIG5vZGUubm9kZVR5cGUgPT09IHR5cGU7XG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgaXNSZXN0cmljdGVkTm9kZSA9IG5vZGUgPT4gISFub2RlICYmICFPYmplY3QuZ2V0UHJvdG90eXBlT2Yobm9kZSk7XG4gICAgY29uc3QgaXNFbGVtZW50JDYgPSBpc05vZGVUeXBlKDEpO1xuICAgIGNvbnN0IG1hdGNoTm9kZU5hbWVzID0gbmFtZXMgPT4ge1xuICAgICAgY29uc3QgbG93ZXJjYXNlZE5hbWVzID0gbmFtZXMubWFwKHMgPT4gcy50b0xvd2VyQ2FzZSgpKTtcbiAgICAgIHJldHVybiBub2RlID0+IHtcbiAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS5ub2RlTmFtZSkge1xuICAgICAgICAgIGNvbnN0IG5vZGVOYW1lID0gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIHJldHVybiBjb250YWlucyQyKGxvd2VyY2FzZWROYW1lcywgbm9kZU5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBtYXRjaFN0eWxlVmFsdWVzID0gKG5hbWUsIHZhbHVlcykgPT4ge1xuICAgICAgY29uc3QgaXRlbXMgPSB2YWx1ZXMudG9Mb3dlckNhc2UoKS5zcGxpdCgnICcpO1xuICAgICAgcmV0dXJuIG5vZGUgPT4ge1xuICAgICAgICBpZiAoaXNFbGVtZW50JDYobm9kZSkpIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjb21wdXRlZCA9IG5vZGUub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKG5vZGUsIG51bGwpO1xuICAgICAgICAgICAgY29uc3QgY3NzVmFsdWUgPSBjb21wdXRlZCA/IGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUobmFtZSkgOiBudWxsO1xuICAgICAgICAgICAgaWYgKGNzc1ZhbHVlID09PSBpdGVtc1tpXSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IGhhc0F0dHJpYnV0ZSA9IGF0dHJOYW1lID0+IHtcbiAgICAgIHJldHVybiBub2RlID0+IHtcbiAgICAgICAgcmV0dXJuIGlzRWxlbWVudCQ2KG5vZGUpICYmIG5vZGUuaGFzQXR0cmlidXRlKGF0dHJOYW1lKTtcbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBoYXNBdHRyaWJ1dGVWYWx1ZSA9IChhdHRyTmFtZSwgYXR0clZhbHVlKSA9PiB7XG4gICAgICByZXR1cm4gbm9kZSA9PiB7XG4gICAgICAgIHJldHVybiBpc0VsZW1lbnQkNihub2RlKSAmJiBub2RlLmdldEF0dHJpYnV0ZShhdHRyTmFtZSkgPT09IGF0dHJWYWx1ZTtcbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBpc0JvZ3VzJDIgPSBub2RlID0+IGlzRWxlbWVudCQ2KG5vZGUpICYmIG5vZGUuaGFzQXR0cmlidXRlKCdkYXRhLW1jZS1ib2d1cycpO1xuICAgIGNvbnN0IGlzQm9ndXNBbGwkMSA9IG5vZGUgPT4gaXNFbGVtZW50JDYobm9kZSkgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtbWNlLWJvZ3VzJykgPT09ICdhbGwnO1xuICAgIGNvbnN0IGlzVGFibGUkMyA9IG5vZGUgPT4gaXNFbGVtZW50JDYobm9kZSkgJiYgbm9kZS50YWdOYW1lID09PSAnVEFCTEUnO1xuICAgIGNvbnN0IGhhc0NvbnRlbnRFZGl0YWJsZVN0YXRlID0gdmFsdWUgPT4ge1xuICAgICAgcmV0dXJuIG5vZGUgPT4ge1xuICAgICAgICBpZiAoaXNFbGVtZW50JDYobm9kZSkpIHtcbiAgICAgICAgICBpZiAobm9kZS5jb250ZW50RWRpdGFibGUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLW1jZS1jb250ZW50ZWRpdGFibGUnKSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgaXNUZXh0YXJlYU9ySW5wdXQgPSBtYXRjaE5vZGVOYW1lcyhbXG4gICAgICAndGV4dGFyZWEnLFxuICAgICAgJ2lucHV0J1xuICAgIF0pO1xuICAgIGNvbnN0IGlzVGV4dCQ4ID0gaXNOb2RlVHlwZSgzKTtcbiAgICBjb25zdCBpc0NEYXRhID0gaXNOb2RlVHlwZSg0KTtcbiAgICBjb25zdCBpc1BpID0gaXNOb2RlVHlwZSg3KTtcbiAgICBjb25zdCBpc0NvbW1lbnQgPSBpc05vZGVUeXBlKDgpO1xuICAgIGNvbnN0IGlzRG9jdW1lbnQkMSA9IGlzTm9kZVR5cGUoOSk7XG4gICAgY29uc3QgaXNEb2N1bWVudEZyYWdtZW50ID0gaXNOb2RlVHlwZSgxMSk7XG4gICAgY29uc3QgaXNCciQ1ID0gbWF0Y2hOb2RlTmFtZXMoWydiciddKTtcbiAgICBjb25zdCBpc0ltZyA9IG1hdGNoTm9kZU5hbWVzKFsnaW1nJ10pO1xuICAgIGNvbnN0IGlzQ29udGVudEVkaXRhYmxlVHJ1ZSQ0ID0gaGFzQ29udGVudEVkaXRhYmxlU3RhdGUoJ3RydWUnKTtcbiAgICBjb25zdCBpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJGEgPSBoYXNDb250ZW50RWRpdGFibGVTdGF0ZSgnZmFsc2UnKTtcbiAgICBjb25zdCBpc1RhYmxlQ2VsbCQ1ID0gbWF0Y2hOb2RlTmFtZXMoW1xuICAgICAgJ3RkJyxcbiAgICAgICd0aCdcbiAgICBdKTtcbiAgICBjb25zdCBpc01lZGlhJDIgPSBtYXRjaE5vZGVOYW1lcyhbXG4gICAgICAndmlkZW8nLFxuICAgICAgJ2F1ZGlvJyxcbiAgICAgICdvYmplY3QnLFxuICAgICAgJ2VtYmVkJ1xuICAgIF0pO1xuXG4gICAgY29uc3QgYnJvd3NlciA9IGRldGVjdCQyKCkuYnJvd3NlcjtcbiAgICBjb25zdCBmaXJzdEVsZW1lbnQgPSBub2RlcyA9PiBmaW5kJDIobm9kZXMsIGlzRWxlbWVudCQ3KTtcbiAgICBjb25zdCBnZXRUYWJsZUNhcHRpb25EZWx0YVkgPSBlbG0gPT4ge1xuICAgICAgaWYgKGJyb3dzZXIuaXNGaXJlZm94KCkgJiYgbmFtZShlbG0pID09PSAndGFibGUnKSB7XG4gICAgICAgIHJldHVybiBmaXJzdEVsZW1lbnQoY2hpbGRyZW4oZWxtKSkuZmlsdGVyKGVsbSA9PiB7XG4gICAgICAgICAgcmV0dXJuIG5hbWUoZWxtKSA9PT0gJ2NhcHRpb24nO1xuICAgICAgICB9KS5iaW5kKGNhcHRpb24gPT4ge1xuICAgICAgICAgIHJldHVybiBmaXJzdEVsZW1lbnQobmV4dFNpYmxpbmdzKGNhcHRpb24pKS5tYXAoYm9keSA9PiB7XG4gICAgICAgICAgICBjb25zdCBib2R5VG9wID0gYm9keS5kb20ub2Zmc2V0VG9wO1xuICAgICAgICAgICAgY29uc3QgY2FwdGlvblRvcCA9IGNhcHRpb24uZG9tLm9mZnNldFRvcDtcbiAgICAgICAgICAgIGNvbnN0IGNhcHRpb25IZWlnaHQgPSBjYXB0aW9uLmRvbS5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICByZXR1cm4gYm9keVRvcCA8PSBjYXB0aW9uVG9wID8gLWNhcHRpb25IZWlnaHQgOiAwO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KS5nZXRPcigwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaGFzQ2hpbGQgPSAoZWxtLCBjaGlsZCkgPT4gZWxtLmNoaWxkcmVuICYmIGNvbnRhaW5zJDIoZWxtLmNoaWxkcmVuLCBjaGlsZCk7XG4gICAgY29uc3QgZ2V0UG9zID0gKGJvZHksIGVsbSwgcm9vdEVsbSkgPT4ge1xuICAgICAgbGV0IHggPSAwLCB5ID0gMDtcbiAgICAgIGNvbnN0IGRvYyA9IGJvZHkub3duZXJEb2N1bWVudDtcbiAgICAgIHJvb3RFbG0gPSByb290RWxtID8gcm9vdEVsbSA6IGJvZHk7XG4gICAgICBpZiAoZWxtKSB7XG4gICAgICAgIGlmIChyb290RWxtID09PSBib2R5ICYmIGVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QgJiYgZ2V0JDcoU3VnYXJFbGVtZW50LmZyb21Eb20oYm9keSksICdwb3NpdGlvbicpID09PSAnc3RhdGljJykge1xuICAgICAgICAgIGNvbnN0IHBvcyA9IGVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICB4ID0gcG9zLmxlZnQgKyAoZG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0IHx8IGJvZHkuc2Nyb2xsTGVmdCkgLSBkb2MuZG9jdW1lbnRFbGVtZW50LmNsaWVudExlZnQ7XG4gICAgICAgICAgeSA9IHBvcy50b3AgKyAoZG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgfHwgYm9keS5zY3JvbGxUb3ApIC0gZG9jLmRvY3VtZW50RWxlbWVudC5jbGllbnRUb3A7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHgsXG4gICAgICAgICAgICB5XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb2Zmc2V0UGFyZW50ID0gZWxtO1xuICAgICAgICB3aGlsZSAob2Zmc2V0UGFyZW50ICYmIG9mZnNldFBhcmVudCAhPT0gcm9vdEVsbSAmJiBvZmZzZXRQYXJlbnQubm9kZVR5cGUgJiYgIWhhc0NoaWxkKG9mZnNldFBhcmVudCwgcm9vdEVsbSkpIHtcbiAgICAgICAgICBjb25zdCBjYXN0T2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50O1xuICAgICAgICAgIHggKz0gY2FzdE9mZnNldFBhcmVudC5vZmZzZXRMZWZ0IHx8IDA7XG4gICAgICAgICAgeSArPSBjYXN0T2Zmc2V0UGFyZW50Lm9mZnNldFRvcCB8fCAwO1xuICAgICAgICAgIG9mZnNldFBhcmVudCA9IGNhc3RPZmZzZXRQYXJlbnQub2Zmc2V0UGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIG9mZnNldFBhcmVudCA9IGVsbS5wYXJlbnROb2RlO1xuICAgICAgICB3aGlsZSAob2Zmc2V0UGFyZW50ICYmIG9mZnNldFBhcmVudCAhPT0gcm9vdEVsbSAmJiBvZmZzZXRQYXJlbnQubm9kZVR5cGUgJiYgIWhhc0NoaWxkKG9mZnNldFBhcmVudCwgcm9vdEVsbSkpIHtcbiAgICAgICAgICB4IC09IG9mZnNldFBhcmVudC5zY3JvbGxMZWZ0IHx8IDA7XG4gICAgICAgICAgeSAtPSBvZmZzZXRQYXJlbnQuc2Nyb2xsVG9wIHx8IDA7XG4gICAgICAgICAgb2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50LnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgeSArPSBnZXRUYWJsZUNhcHRpb25EZWx0YVkoU3VnYXJFbGVtZW50LmZyb21Eb20oZWxtKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgQ2xvc2VzdE9yQW5jZXN0b3IgPSAoaXMsIGFuY2VzdG9yLCBzY29wZSwgYSwgaXNSb290KSA9PiB7XG4gICAgICBpZiAoaXMoc2NvcGUsIGEpKSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKHNjb3BlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihpc1Jvb3QpICYmIGlzUm9vdChzY29wZSkpIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBhbmNlc3RvcihzY29wZSwgYSwgaXNSb290KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgYW5jZXN0b3IkMyA9IChzY29wZSwgcHJlZGljYXRlLCBpc1Jvb3QpID0+IHtcbiAgICAgIGxldCBlbGVtZW50ID0gc2NvcGUuZG9tO1xuICAgICAgY29uc3Qgc3RvcCA9IGlzRnVuY3Rpb24oaXNSb290KSA/IGlzUm9vdCA6IG5ldmVyO1xuICAgICAgd2hpbGUgKGVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgICBjb25zdCBlbCA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVsZW1lbnQpO1xuICAgICAgICBpZiAocHJlZGljYXRlKGVsKSkge1xuICAgICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKGVsKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdG9wKGVsKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgIH07XG4gICAgY29uc3QgY2xvc2VzdCQ0ID0gKHNjb3BlLCBwcmVkaWNhdGUsIGlzUm9vdCkgPT4ge1xuICAgICAgY29uc3QgaXMgPSAocywgdGVzdCkgPT4gdGVzdChzKTtcbiAgICAgIHJldHVybiBDbG9zZXN0T3JBbmNlc3RvcihpcywgYW5jZXN0b3IkMywgc2NvcGUsIHByZWRpY2F0ZSwgaXNSb290KTtcbiAgICB9O1xuICAgIGNvbnN0IHNpYmxpbmckMSA9IChzY29wZSwgcHJlZGljYXRlKSA9PiB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gc2NvcGUuZG9tO1xuICAgICAgaWYgKCFlbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjaGlsZChTdWdhckVsZW1lbnQuZnJvbURvbShlbGVtZW50LnBhcmVudE5vZGUpLCB4ID0+ICFlcShzY29wZSwgeCkgJiYgcHJlZGljYXRlKHgpKTtcbiAgICB9O1xuICAgIGNvbnN0IGNoaWxkID0gKHNjb3BlLCBwcmVkaWNhdGUpID0+IHtcbiAgICAgIGNvbnN0IHByZWQgPSBub2RlID0+IHByZWRpY2F0ZShTdWdhckVsZW1lbnQuZnJvbURvbShub2RlKSk7XG4gICAgICBjb25zdCByZXN1bHQgPSBmaW5kJDIoc2NvcGUuZG9tLmNoaWxkTm9kZXMsIHByZWQpO1xuICAgICAgcmV0dXJuIHJlc3VsdC5tYXAoU3VnYXJFbGVtZW50LmZyb21Eb20pO1xuICAgIH07XG4gICAgY29uc3QgZGVzY2VuZGFudCQxID0gKHNjb3BlLCBwcmVkaWNhdGUpID0+IHtcbiAgICAgIGNvbnN0IGRlc2NlbmQgPSBub2RlID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBjaGlsZCA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKG5vZGUuY2hpbGROb2Rlc1tpXSk7XG4gICAgICAgICAgaWYgKHByZWRpY2F0ZShjaGlsZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKGNoaWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgcmVzID0gZGVzY2VuZChub2RlLmNoaWxkTm9kZXNbaV0pO1xuICAgICAgICAgIGlmIChyZXMuaXNTb21lKCkpIHtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGRlc2NlbmQoc2NvcGUuZG9tKTtcbiAgICB9O1xuXG4gICAgY29uc3QgYW5jZXN0b3IkMiA9IChzY29wZSwgc2VsZWN0b3IsIGlzUm9vdCkgPT4gYW5jZXN0b3IkMyhzY29wZSwgZSA9PiBpcyQxKGUsIHNlbGVjdG9yKSwgaXNSb290KTtcbiAgICBjb25zdCBkZXNjZW5kYW50ID0gKHNjb3BlLCBzZWxlY3RvcikgPT4gb25lKHNlbGVjdG9yLCBzY29wZSk7XG4gICAgY29uc3QgY2xvc2VzdCQzID0gKHNjb3BlLCBzZWxlY3RvciwgaXNSb290KSA9PiB7XG4gICAgICBjb25zdCBpcyA9IChlbGVtZW50LCBzZWxlY3RvcikgPT4gaXMkMShlbGVtZW50LCBzZWxlY3Rvcik7XG4gICAgICByZXR1cm4gQ2xvc2VzdE9yQW5jZXN0b3IoaXMsIGFuY2VzdG9yJDIsIHNjb3BlLCBzZWxlY3RvciwgaXNSb290KTtcbiAgICB9O1xuXG4gICAgY29uc3QgU3R5bGVTaGVldExvYWRlciA9IChkb2N1bWVudE9yU2hhZG93Um9vdCwgc2V0dGluZ3MgPSB7fSkgPT4ge1xuICAgICAgbGV0IGlkQ291bnQgPSAwO1xuICAgICAgY29uc3QgbG9hZGVkU3RhdGVzID0ge307XG4gICAgICBjb25zdCBlZG9zID0gU3VnYXJFbGVtZW50LmZyb21Eb20oZG9jdW1lbnRPclNoYWRvd1Jvb3QpO1xuICAgICAgY29uc3QgZG9jID0gZG9jdW1lbnRPck93bmVyKGVkb3MpO1xuICAgICAgY29uc3QgbWF4TG9hZFRpbWUgPSBzZXR0aW5ncy5tYXhMb2FkVGltZSB8fCA1MDAwO1xuICAgICAgY29uc3QgX3NldFJlZmVycmVyUG9saWN5ID0gcmVmZXJyZXJQb2xpY3kgPT4ge1xuICAgICAgICBzZXR0aW5ncy5yZWZlcnJlclBvbGljeSA9IHJlZmVycmVyUG9saWN5O1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGFkZFN0eWxlID0gZWxlbWVudCA9PiB7XG4gICAgICAgIGFwcGVuZCQxKGdldFN0eWxlQ29udGFpbmVyKGVkb3MpLCBlbGVtZW50KTtcbiAgICAgIH07XG4gICAgICBjb25zdCByZW1vdmVTdHlsZSA9IGlkID0+IHtcbiAgICAgICAgY29uc3Qgc3R5bGVDb250YWluZXIgPSBnZXRTdHlsZUNvbnRhaW5lcihlZG9zKTtcbiAgICAgICAgZGVzY2VuZGFudChzdHlsZUNvbnRhaW5lciwgJyMnICsgaWQpLmVhY2gocmVtb3ZlJDUpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGdldE9yQ3JlYXRlU3RhdGUgPSB1cmwgPT4gZ2V0JGEobG9hZGVkU3RhdGVzLCB1cmwpLmdldE9yVGh1bmsoKCkgPT4gKHtcbiAgICAgICAgaWQ6ICdtY2UtdScgKyBpZENvdW50KyssXG4gICAgICAgIHBhc3NlZDogW10sXG4gICAgICAgIGZhaWxlZDogW10sXG4gICAgICAgIGNvdW50OiAwXG4gICAgICB9KSk7XG4gICAgICBjb25zdCBsb2FkID0gdXJsID0+IG5ldyBQcm9taXNlKChzdWNjZXNzLCBmYWlsdXJlKSA9PiB7XG4gICAgICAgIGxldCBsaW5rO1xuICAgICAgICBjb25zdCB1cmxXaXRoU3VmZml4ID0gVG9vbHMuX2FkZENhY2hlU3VmZml4KHVybCk7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gZ2V0T3JDcmVhdGVTdGF0ZSh1cmxXaXRoU3VmZml4KTtcbiAgICAgICAgbG9hZGVkU3RhdGVzW3VybFdpdGhTdWZmaXhdID0gc3RhdGU7XG4gICAgICAgIHN0YXRlLmNvdW50Kys7XG4gICAgICAgIGNvbnN0IHJlc29sdmUgPSAoY2FsbGJhY2tzLCBzdGF0dXMpID0+IHtcbiAgICAgICAgICBlYWNoJGcoY2FsbGJhY2tzLCBjYWxsKTtcbiAgICAgICAgICBzdGF0ZS5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgICAgc3RhdGUucGFzc2VkID0gW107XG4gICAgICAgICAgc3RhdGUuZmFpbGVkID0gW107XG4gICAgICAgICAgaWYgKGxpbmspIHtcbiAgICAgICAgICAgIGxpbmsub25sb2FkID0gbnVsbDtcbiAgICAgICAgICAgIGxpbmsub25lcnJvciA9IG51bGw7XG4gICAgICAgICAgICBsaW5rID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHBhc3NlZCA9ICgpID0+IHJlc29sdmUoc3RhdGUucGFzc2VkLCAyKTtcbiAgICAgICAgY29uc3QgZmFpbGVkID0gKCkgPT4gcmVzb2x2ZShzdGF0ZS5mYWlsZWQsIDMpO1xuICAgICAgICBjb25zdCB3YWl0ID0gKHRlc3RDYWxsYmFjaywgd2FpdENhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgaWYgKCF0ZXN0Q2FsbGJhY2soKSkge1xuICAgICAgICAgICAgaWYgKERhdGUubm93KCkgLSBzdGFydFRpbWUgPCBtYXhMb2FkVGltZSkge1xuICAgICAgICAgICAgICBzZXRUaW1lb3V0KHdhaXRDYWxsYmFjayk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmYWlsZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHdhaXRGb3JXZWJLaXRMaW5rTG9hZGVkID0gKCkgPT4ge1xuICAgICAgICAgIHdhaXQoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3R5bGVTaGVldHMgPSBkb2N1bWVudE9yU2hhZG93Um9vdC5zdHlsZVNoZWV0cztcbiAgICAgICAgICAgIGxldCBpID0gc3R5bGVTaGVldHMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICBjb25zdCBzdHlsZVNoZWV0ID0gc3R5bGVTaGVldHNbaV07XG4gICAgICAgICAgICAgIGNvbnN0IG93bmVyID0gc3R5bGVTaGVldC5vd25lck5vZGU7XG4gICAgICAgICAgICAgIGlmIChvd25lciAmJiBvd25lci5pZCA9PT0gbGluay5pZCkge1xuICAgICAgICAgICAgICAgIHBhc3NlZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSwgd2FpdEZvcldlYktpdExpbmtMb2FkZWQpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgIHN0YXRlLnBhc3NlZC5wdXNoKHN1Y2Nlc3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmYWlsdXJlKSB7XG4gICAgICAgICAgc3RhdGUuZmFpbGVkLnB1c2goZmFpbHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLnN0YXR1cyA9PT0gMSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuc3RhdHVzID09PSAyKSB7XG4gICAgICAgICAgcGFzc2VkKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5zdGF0dXMgPT09IDMpIHtcbiAgICAgICAgICBmYWlsZWQoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuc3RhdHVzID0gMTtcbiAgICAgICAgY29uc3QgbGlua0VsZW0gPSBTdWdhckVsZW1lbnQuZnJvbVRhZygnbGluaycsIGRvYy5kb20pO1xuICAgICAgICBzZXRBbGwkMShsaW5rRWxlbSwge1xuICAgICAgICAgIHJlbDogJ3N0eWxlc2hlZXQnLFxuICAgICAgICAgIHR5cGU6ICd0ZXh0L2NzcycsXG4gICAgICAgICAgaWQ6IHN0YXRlLmlkXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBpZiAoc2V0dGluZ3MuY29udGVudENzc0NvcnMpIHtcbiAgICAgICAgICBzZXQkMihsaW5rRWxlbSwgJ2Nyb3NzT3JpZ2luJywgJ2Fub255bW91cycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXR0aW5ncy5yZWZlcnJlclBvbGljeSkge1xuICAgICAgICAgIHNldCQyKGxpbmtFbGVtLCAncmVmZXJyZXJwb2xpY3knLCBzZXR0aW5ncy5yZWZlcnJlclBvbGljeSk7XG4gICAgICAgIH1cbiAgICAgICAgbGluayA9IGxpbmtFbGVtLmRvbTtcbiAgICAgICAgbGluay5vbmxvYWQgPSB3YWl0Rm9yV2ViS2l0TGlua0xvYWRlZDtcbiAgICAgICAgbGluay5vbmVycm9yID0gZmFpbGVkO1xuICAgICAgICBhZGRTdHlsZShsaW5rRWxlbSk7XG4gICAgICAgIHNldCQyKGxpbmtFbGVtLCAnaHJlZicsIHVybFdpdGhTdWZmaXgpO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBsb2FkQWxsID0gdXJscyA9PiB7XG4gICAgICAgIGNvbnN0IGxvYWRlZFVybHMgPSBQcm9taXNlLmFsbFNldHRsZWQobWFwJDModXJscywgdXJsID0+IGxvYWQodXJsKS50aGVuKGNvbnN0YW50KHVybCkpKSk7XG4gICAgICAgIHJldHVybiBsb2FkZWRVcmxzLnRoZW4ocmVzdWx0cyA9PiB7XG4gICAgICAgICAgY29uc3QgcGFydHMgPSBwYXJ0aXRpb24kMihyZXN1bHRzLCByID0+IHIuc3RhdHVzID09PSAnZnVsZmlsbGVkJyk7XG4gICAgICAgICAgaWYgKHBhcnRzLmZhaWwubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG1hcCQzKHBhcnRzLmZhaWwsIHJlc3VsdCA9PiByZXN1bHQucmVhc29uKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBtYXAkMyhwYXJ0cy5wYXNzLCByZXN1bHQgPT4gcmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHVubG9hZCA9IHVybCA9PiB7XG4gICAgICAgIGNvbnN0IHVybFdpdGhTdWZmaXggPSBUb29scy5fYWRkQ2FjaGVTdWZmaXgodXJsKTtcbiAgICAgICAgZ2V0JGEobG9hZGVkU3RhdGVzLCB1cmxXaXRoU3VmZml4KS5lYWNoKHN0YXRlID0+IHtcbiAgICAgICAgICBjb25zdCBjb3VudCA9IC0tc3RhdGUuY291bnQ7XG4gICAgICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICBkZWxldGUgbG9hZGVkU3RhdGVzW3VybFdpdGhTdWZmaXhdO1xuICAgICAgICAgICAgcmVtb3ZlU3R5bGUoc3RhdGUuaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgdW5sb2FkQWxsID0gdXJscyA9PiB7XG4gICAgICAgIGVhY2gkZyh1cmxzLCB1cmwgPT4ge1xuICAgICAgICAgIHVubG9hZCh1cmwpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsb2FkLFxuICAgICAgICBsb2FkQWxsLFxuICAgICAgICB1bmxvYWQsXG4gICAgICAgIHVubG9hZEFsbCxcbiAgICAgICAgX3NldFJlZmVycmVyUG9saWN5XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCBjcmVhdGUkYyA9ICgpID0+IHtcbiAgICAgIGNvbnN0IG1hcCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICBjb25zdCBmb3JFbGVtZW50ID0gKHJlZmVyZW5jZUVsZW1lbnQsIHNldHRpbmdzKSA9PiB7XG4gICAgICAgIGNvbnN0IHJvb3QgPSBnZXRSb290Tm9kZShyZWZlcmVuY2VFbGVtZW50KTtcbiAgICAgICAgY29uc3Qgcm9vdERvbSA9IHJvb3QuZG9tO1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwuZnJvbShtYXAuZ2V0KHJvb3REb20pKS5nZXRPclRodW5rKCgpID0+IHtcbiAgICAgICAgICBjb25zdCBzbCA9IFN0eWxlU2hlZXRMb2FkZXIocm9vdERvbSwgc2V0dGluZ3MpO1xuICAgICAgICAgIG1hcC5zZXQocm9vdERvbSwgc2wpO1xuICAgICAgICAgIHJldHVybiBzbDtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHsgZm9yRWxlbWVudCB9O1xuICAgIH07XG4gICAgY29uc3QgaW5zdGFuY2UgPSBjcmVhdGUkYygpO1xuXG4gICAgY2xhc3MgRG9tVHJlZVdhbGtlciB7XG4gICAgICBjb25zdHJ1Y3RvcihzdGFydE5vZGUsIHJvb3ROb2RlKSB7XG4gICAgICAgIHRoaXMubm9kZSA9IHN0YXJ0Tm9kZTtcbiAgICAgICAgdGhpcy5yb290Tm9kZSA9IHJvb3ROb2RlO1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLmN1cnJlbnQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5uZXh0ID0gdGhpcy5uZXh0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucHJldiA9IHRoaXMucHJldi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnByZXYyID0gdGhpcy5wcmV2Mi5iaW5kKHRoaXMpO1xuICAgICAgfVxuICAgICAgY3VycmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZTtcbiAgICAgIH1cbiAgICAgIG5leHQoc2hhbGxvdykge1xuICAgICAgICB0aGlzLm5vZGUgPSB0aGlzLmZpbmRTaWJsaW5nKHRoaXMubm9kZSwgJ2ZpcnN0Q2hpbGQnLCAnbmV4dFNpYmxpbmcnLCBzaGFsbG93KTtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZTtcbiAgICAgIH1cbiAgICAgIHByZXYoc2hhbGxvdykge1xuICAgICAgICB0aGlzLm5vZGUgPSB0aGlzLmZpbmRTaWJsaW5nKHRoaXMubm9kZSwgJ2xhc3RDaGlsZCcsICdwcmV2aW91c1NpYmxpbmcnLCBzaGFsbG93KTtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZTtcbiAgICAgIH1cbiAgICAgIHByZXYyKHNoYWxsb3cpIHtcbiAgICAgICAgdGhpcy5ub2RlID0gdGhpcy5maW5kUHJldmlvdXNOb2RlKHRoaXMubm9kZSwgJ2xhc3RDaGlsZCcsICdwcmV2aW91c1NpYmxpbmcnLCBzaGFsbG93KTtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZTtcbiAgICAgIH1cbiAgICAgIGZpbmRTaWJsaW5nKG5vZGUsIHN0YXJ0TmFtZSwgc2libGluZ05hbWUsIHNoYWxsb3cpIHtcbiAgICAgICAgbGV0IHNpYmxpbmcsIHBhcmVudDtcbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICBpZiAoIXNoYWxsb3cgJiYgbm9kZVtzdGFydE5hbWVdKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZVtzdGFydE5hbWVdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobm9kZSAhPT0gdGhpcy5yb290Tm9kZSkge1xuICAgICAgICAgICAgc2libGluZyA9IG5vZGVbc2libGluZ05hbWVdO1xuICAgICAgICAgICAgaWYgKHNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTsgcGFyZW50ICYmIHBhcmVudCAhPT0gdGhpcy5yb290Tm9kZTsgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgc2libGluZyA9IHBhcmVudFtzaWJsaW5nTmFtZV07XG4gICAgICAgICAgICAgIGlmIChzaWJsaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpYmxpbmc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZpbmRQcmV2aW91c05vZGUobm9kZSwgc3RhcnROYW1lLCBzaWJsaW5nTmFtZSwgc2hhbGxvdykge1xuICAgICAgICBsZXQgc2libGluZywgcGFyZW50LCBjaGlsZDtcbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICBzaWJsaW5nID0gbm9kZVtzaWJsaW5nTmFtZV07XG4gICAgICAgICAgaWYgKHRoaXMucm9vdE5vZGUgJiYgc2libGluZyA9PT0gdGhpcy5yb290Tm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2libGluZykge1xuICAgICAgICAgICAgaWYgKCFzaGFsbG93KSB7XG4gICAgICAgICAgICAgIGZvciAoY2hpbGQgPSBzaWJsaW5nW3N0YXJ0TmFtZV07IGNoaWxkOyBjaGlsZCA9IGNoaWxkW3N0YXJ0TmFtZV0pIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNoaWxkW3N0YXJ0TmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzaWJsaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQgIT09IHRoaXMucm9vdE5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgYmxvY2tzID0gW1xuICAgICAgJ2FydGljbGUnLFxuICAgICAgJ2FzaWRlJyxcbiAgICAgICdkZXRhaWxzJyxcbiAgICAgICdkaXYnLFxuICAgICAgJ2R0JyxcbiAgICAgICdmaWdjYXB0aW9uJyxcbiAgICAgICdmb290ZXInLFxuICAgICAgJ2Zvcm0nLFxuICAgICAgJ2ZpZWxkc2V0JyxcbiAgICAgICdoZWFkZXInLFxuICAgICAgJ2hncm91cCcsXG4gICAgICAnaHRtbCcsXG4gICAgICAnbWFpbicsXG4gICAgICAnbmF2JyxcbiAgICAgICdzZWN0aW9uJyxcbiAgICAgICdzdW1tYXJ5JyxcbiAgICAgICdib2R5JyxcbiAgICAgICdwJyxcbiAgICAgICdkbCcsXG4gICAgICAnbXVsdGljb2wnLFxuICAgICAgJ2RkJyxcbiAgICAgICdmaWd1cmUnLFxuICAgICAgJ2FkZHJlc3MnLFxuICAgICAgJ2NlbnRlcicsXG4gICAgICAnYmxvY2txdW90ZScsXG4gICAgICAnaDEnLFxuICAgICAgJ2gyJyxcbiAgICAgICdoMycsXG4gICAgICAnaDQnLFxuICAgICAgJ2g1JyxcbiAgICAgICdoNicsXG4gICAgICAnbGlzdGluZycsXG4gICAgICAneG1wJyxcbiAgICAgICdwcmUnLFxuICAgICAgJ3BsYWludGV4dCcsXG4gICAgICAnbWVudScsXG4gICAgICAnZGlyJyxcbiAgICAgICd1bCcsXG4gICAgICAnb2wnLFxuICAgICAgJ2xpJyxcbiAgICAgICdocicsXG4gICAgICAndGFibGUnLFxuICAgICAgJ3Rib2R5JyxcbiAgICAgICd0aGVhZCcsXG4gICAgICAndGZvb3QnLFxuICAgICAgJ3RoJyxcbiAgICAgICd0cicsXG4gICAgICAndGQnLFxuICAgICAgJ2NhcHRpb24nXG4gICAgXTtcbiAgICBjb25zdCB0YWJsZUNlbGxzID0gW1xuICAgICAgJ3RkJyxcbiAgICAgICd0aCdcbiAgICBdO1xuICAgIGNvbnN0IHRhYmxlU2VjdGlvbnMgPSBbXG4gICAgICAndGhlYWQnLFxuICAgICAgJ3Rib2R5JyxcbiAgICAgICd0Zm9vdCdcbiAgICBdO1xuICAgIGNvbnN0IHRleHRCbG9ja3MgPSBbXG4gICAgICAnaDEnLFxuICAgICAgJ2gyJyxcbiAgICAgICdoMycsXG4gICAgICAnaDQnLFxuICAgICAgJ2g1JyxcbiAgICAgICdoNicsXG4gICAgICAncCcsXG4gICAgICAnZGl2JyxcbiAgICAgICdhZGRyZXNzJyxcbiAgICAgICdwcmUnLFxuICAgICAgJ2Zvcm0nLFxuICAgICAgJ2Jsb2NrcXVvdGUnLFxuICAgICAgJ2NlbnRlcicsXG4gICAgICAnZGlyJyxcbiAgICAgICdmaWVsZHNldCcsXG4gICAgICAnaGVhZGVyJyxcbiAgICAgICdmb290ZXInLFxuICAgICAgJ2FydGljbGUnLFxuICAgICAgJ3NlY3Rpb24nLFxuICAgICAgJ2hncm91cCcsXG4gICAgICAnYXNpZGUnLFxuICAgICAgJ25hdicsXG4gICAgICAnZmlndXJlJ1xuICAgIF07XG4gICAgY29uc3QgaGVhZGluZ3MgPSBbXG4gICAgICAnaDEnLFxuICAgICAgJ2gyJyxcbiAgICAgICdoMycsXG4gICAgICAnaDQnLFxuICAgICAgJ2g1JyxcbiAgICAgICdoNidcbiAgICBdO1xuICAgIGNvbnN0IGxpc3RJdGVtcyQxID0gW1xuICAgICAgJ2xpJyxcbiAgICAgICdkZCcsXG4gICAgICAnZHQnXG4gICAgXTtcbiAgICBjb25zdCBsaXN0cyA9IFtcbiAgICAgICd1bCcsXG4gICAgICAnb2wnLFxuICAgICAgJ2RsJ1xuICAgIF07XG4gICAgY29uc3Qgd3NFbGVtZW50cyA9IFtcbiAgICAgICdwcmUnLFxuICAgICAgJ3NjcmlwdCcsXG4gICAgICAndGV4dGFyZWEnLFxuICAgICAgJ3N0eWxlJ1xuICAgIF07XG4gICAgY29uc3QgbGF6eUxvb2t1cCA9IGl0ZW1zID0+IHtcbiAgICAgIGxldCBsb29rdXA7XG4gICAgICByZXR1cm4gbm9kZSA9PiB7XG4gICAgICAgIGxvb2t1cCA9IGxvb2t1cCA/IGxvb2t1cCA6IG1hcFRvT2JqZWN0KGl0ZW1zLCBhbHdheXMpO1xuICAgICAgICByZXR1cm4gaGFzJDIobG9va3VwLCBuYW1lKG5vZGUpKTtcbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBpc0hlYWRpbmcgPSBsYXp5TG9va3VwKGhlYWRpbmdzKTtcbiAgICBjb25zdCBpc0Jsb2NrJDIgPSBsYXp5TG9va3VwKGJsb2Nrcyk7XG4gICAgY29uc3QgaXNUYWJsZSQyID0gbm9kZSA9PiBuYW1lKG5vZGUpID09PSAndGFibGUnO1xuICAgIGNvbnN0IGlzSW5saW5lJDEgPSBub2RlID0+IGlzRWxlbWVudCQ3KG5vZGUpICYmICFpc0Jsb2NrJDIobm9kZSk7XG4gICAgY29uc3QgaXNCciQ0ID0gbm9kZSA9PiBpc0VsZW1lbnQkNyhub2RlKSAmJiBuYW1lKG5vZGUpID09PSAnYnInO1xuICAgIGNvbnN0IGlzVGV4dEJsb2NrJDIgPSBsYXp5TG9va3VwKHRleHRCbG9ja3MpO1xuICAgIGNvbnN0IGlzTGlzdCA9IGxhenlMb29rdXAobGlzdHMpO1xuICAgIGNvbnN0IGlzTGlzdEl0ZW0gPSBsYXp5TG9va3VwKGxpc3RJdGVtcyQxKTtcbiAgICBjb25zdCBpc1RhYmxlU2VjdGlvbiA9IGxhenlMb29rdXAodGFibGVTZWN0aW9ucyk7XG4gICAgY29uc3QgaXNUYWJsZUNlbGwkNCA9IGxhenlMb29rdXAodGFibGVDZWxscyk7XG4gICAgY29uc3QgaXNXc1ByZXNlcnZlRWxlbWVudCA9IGxhenlMb29rdXAod3NFbGVtZW50cyk7XG5cbiAgICBjb25zdCBhbmNlc3RvciQxID0gKHNjb3BlLCBzZWxlY3RvciwgaXNSb290KSA9PiBhbmNlc3RvciQyKHNjb3BlLCBzZWxlY3RvciwgaXNSb290KS5pc1NvbWUoKTtcblxuICAgIGNvbnN0IHplcm9XaWR0aCA9ICdcXHVGRUZGJztcbiAgICBjb25zdCBuYnNwID0gJ1xceEEwJztcbiAgICBjb25zdCBpc1p3c3AkMSA9IGNoYXIgPT4gY2hhciA9PT0gemVyb1dpZHRoO1xuICAgIGNvbnN0IHJlbW92ZVp3c3AgPSBzID0+IHMucmVwbGFjZSgvXFx1RkVGRi9nLCAnJyk7XG5cbiAgICBjb25zdCBaV1NQJDEgPSB6ZXJvV2lkdGg7XG4gICAgY29uc3QgaXNad3NwID0gaXNad3NwJDE7XG4gICAgY29uc3QgdHJpbSQxID0gcmVtb3ZlWndzcDtcblxuICAgIGNvbnN0IGlzRWxlbWVudCQ1ID0gaXNFbGVtZW50JDY7XG4gICAgY29uc3QgaXNUZXh0JDcgPSBpc1RleHQkODtcbiAgICBjb25zdCBpc0NhcmV0Q29udGFpbmVyQmxvY2skMSA9IG5vZGUgPT4ge1xuICAgICAgaWYgKGlzVGV4dCQ3KG5vZGUpKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNFbGVtZW50JDUobm9kZSkgJiYgbm9kZS5oYXNBdHRyaWJ1dGUoJ2RhdGEtbWNlLWNhcmV0Jyk7XG4gICAgfTtcbiAgICBjb25zdCBpc0NhcmV0Q29udGFpbmVySW5saW5lID0gbm9kZSA9PiBpc1RleHQkNyhub2RlKSAmJiBpc1p3c3Aobm9kZS5kYXRhKTtcbiAgICBjb25zdCBpc0NhcmV0Q29udGFpbmVyJDIgPSBub2RlID0+IGlzQ2FyZXRDb250YWluZXJCbG9jayQxKG5vZGUpIHx8IGlzQ2FyZXRDb250YWluZXJJbmxpbmUobm9kZSk7XG4gICAgY29uc3QgaGFzQ29udGVudCA9IG5vZGUgPT4gbm9kZS5maXJzdENoaWxkICE9PSBub2RlLmxhc3RDaGlsZCB8fCAhaXNCciQ1KG5vZGUuZmlyc3RDaGlsZCk7XG4gICAgY29uc3QgaW5zZXJ0SW5saW5lJDEgPSAobm9kZSwgYmVmb3JlKSA9PiB7XG4gICAgICBjb25zdCBkb2MgPSBub2RlLm93bmVyRG9jdW1lbnQ7XG4gICAgICBjb25zdCB0ZXh0Tm9kZSA9IGRvYy5jcmVhdGVUZXh0Tm9kZShaV1NQJDEpO1xuICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgIGlmICghYmVmb3JlKSB7XG4gICAgICAgIGNvbnN0IHNpYmxpbmcgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgICBpZiAoaXNUZXh0JDcoc2libGluZykpIHtcbiAgICAgICAgICBpZiAoaXNDYXJldENvbnRhaW5lciQyKHNpYmxpbmcpKSB7XG4gICAgICAgICAgICByZXR1cm4gc2libGluZztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXJ0c1dpdGhDYXJldENvbnRhaW5lciQxKHNpYmxpbmcpKSB7XG4gICAgICAgICAgICBzaWJsaW5nLnNwbGl0VGV4dCgxKTtcbiAgICAgICAgICAgIHJldHVybiBzaWJsaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5uZXh0U2libGluZykge1xuICAgICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRleHROb2RlLCBub2RlLm5leHRTaWJsaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJlbnROb2RlLmFwcGVuZENoaWxkKHRleHROb2RlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgc2libGluZyA9IG5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICBpZiAoaXNUZXh0JDcoc2libGluZykpIHtcbiAgICAgICAgICBpZiAoaXNDYXJldENvbnRhaW5lciQyKHNpYmxpbmcpKSB7XG4gICAgICAgICAgICByZXR1cm4gc2libGluZztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVuZHNXaXRoQ2FyZXRDb250YWluZXIkMShzaWJsaW5nKSkge1xuICAgICAgICAgICAgcmV0dXJuIHNpYmxpbmcuc3BsaXRUZXh0KHNpYmxpbmcuZGF0YS5sZW5ndGggLSAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGV4dE5vZGUsIG5vZGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRleHROb2RlO1xuICAgIH07XG4gICAgY29uc3QgaXNCZWZvcmVJbmxpbmUgPSBwb3MgPT4ge1xuICAgICAgY29uc3QgY29udGFpbmVyID0gcG9zLmNvbnRhaW5lcigpO1xuICAgICAgaWYgKCFpc1RleHQkOChjb250YWluZXIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb250YWluZXIuZGF0YS5jaGFyQXQocG9zLm9mZnNldCgpKSA9PT0gWldTUCQxIHx8IHBvcy5pc0F0U3RhcnQoKSAmJiBpc0NhcmV0Q29udGFpbmVySW5saW5lKGNvbnRhaW5lci5wcmV2aW91c1NpYmxpbmcpO1xuICAgIH07XG4gICAgY29uc3QgaXNBZnRlcklubGluZSA9IHBvcyA9PiB7XG4gICAgICBjb25zdCBjb250YWluZXIgPSBwb3MuY29udGFpbmVyKCk7XG4gICAgICBpZiAoIWlzVGV4dCQ4KGNvbnRhaW5lcikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbnRhaW5lci5kYXRhLmNoYXJBdChwb3Mub2Zmc2V0KCkgLSAxKSA9PT0gWldTUCQxIHx8IHBvcy5pc0F0RW5kKCkgJiYgaXNDYXJldENvbnRhaW5lcklubGluZShjb250YWluZXIubmV4dFNpYmxpbmcpO1xuICAgIH07XG4gICAgY29uc3QgY3JlYXRlQm9ndXNCciA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGJyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnInKTtcbiAgICAgIGJyLnNldEF0dHJpYnV0ZSgnZGF0YS1tY2UtYm9ndXMnLCAnMScpO1xuICAgICAgcmV0dXJuIGJyO1xuICAgIH07XG4gICAgY29uc3QgaW5zZXJ0QmxvY2sgPSAoYmxvY2tOYW1lLCBub2RlLCBiZWZvcmUpID0+IHtcbiAgICAgIGNvbnN0IGRvYyA9IG5vZGUub3duZXJEb2N1bWVudDtcbiAgICAgIGNvbnN0IGJsb2NrTm9kZSA9IGRvYy5jcmVhdGVFbGVtZW50KGJsb2NrTmFtZSk7XG4gICAgICBibG9ja05vZGUuc2V0QXR0cmlidXRlKCdkYXRhLW1jZS1jYXJldCcsIGJlZm9yZSA/ICdiZWZvcmUnIDogJ2FmdGVyJyk7XG4gICAgICBibG9ja05vZGUuc2V0QXR0cmlidXRlKCdkYXRhLW1jZS1ib2d1cycsICdhbGwnKTtcbiAgICAgIGJsb2NrTm9kZS5hcHBlbmRDaGlsZChjcmVhdGVCb2d1c0JyKCkpO1xuICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgIGlmICghYmVmb3JlKSB7XG4gICAgICAgIGlmIChub2RlLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYmxvY2tOb2RlLCBub2RlLm5leHRTaWJsaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJlbnROb2RlLmFwcGVuZENoaWxkKGJsb2NrTm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGJsb2NrTm9kZSwgbm9kZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmxvY2tOb2RlO1xuICAgIH07XG4gICAgY29uc3Qgc3RhcnRzV2l0aENhcmV0Q29udGFpbmVyJDEgPSBub2RlID0+IGlzVGV4dCQ3KG5vZGUpICYmIG5vZGUuZGF0YVswXSA9PT0gWldTUCQxO1xuICAgIGNvbnN0IGVuZHNXaXRoQ2FyZXRDb250YWluZXIkMSA9IG5vZGUgPT4gaXNUZXh0JDcobm9kZSkgJiYgbm9kZS5kYXRhW25vZGUuZGF0YS5sZW5ndGggLSAxXSA9PT0gWldTUCQxO1xuICAgIGNvbnN0IHRyaW1Cb2d1c0JyID0gZWxtID0+IHtcbiAgICAgIGNvbnN0IGJycyA9IGVsbS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYnInKTtcbiAgICAgIGNvbnN0IGxhc3RCciA9IGJyc1ticnMubGVuZ3RoIC0gMV07XG4gICAgICBpZiAoaXNCb2d1cyQyKGxhc3RCcikpIHtcbiAgICAgICAgbGFzdEJyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobGFzdEJyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHNob3dDYXJldENvbnRhaW5lckJsb2NrID0gY2FyZXRDb250YWluZXIgPT4ge1xuICAgICAgaWYgKGNhcmV0Q29udGFpbmVyICYmIGNhcmV0Q29udGFpbmVyLmhhc0F0dHJpYnV0ZSgnZGF0YS1tY2UtY2FyZXQnKSkge1xuICAgICAgICB0cmltQm9ndXNCcihjYXJldENvbnRhaW5lcik7XG4gICAgICAgIGNhcmV0Q29udGFpbmVyLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1tY2UtY2FyZXQnKTtcbiAgICAgICAgY2FyZXRDb250YWluZXIucmVtb3ZlQXR0cmlidXRlKCdkYXRhLW1jZS1ib2d1cycpO1xuICAgICAgICBjYXJldENvbnRhaW5lci5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICAgIGNhcmV0Q29udGFpbmVyLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1tY2Utc3R5bGUnKTtcbiAgICAgICAgY2FyZXRDb250YWluZXIucmVtb3ZlQXR0cmlidXRlKCdfbW96X2Fic3BvcycpO1xuICAgICAgICByZXR1cm4gY2FyZXRDb250YWluZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIGNvbnN0IGlzUmFuZ2VJbkNhcmV0Q29udGFpbmVyQmxvY2sgPSByYW5nZSA9PiBpc0NhcmV0Q29udGFpbmVyQmxvY2skMShyYW5nZS5zdGFydENvbnRhaW5lcik7XG5cbiAgICBjb25zdCBpc0NvbnRlbnRFZGl0YWJsZVRydWUkMyA9IGlzQ29udGVudEVkaXRhYmxlVHJ1ZSQ0O1xuICAgIGNvbnN0IGlzQ29udGVudEVkaXRhYmxlRmFsc2UkOSA9IGlzQ29udGVudEVkaXRhYmxlRmFsc2UkYTtcbiAgICBjb25zdCBpc0JyJDMgPSBpc0JyJDU7XG4gICAgY29uc3QgaXNUZXh0JDYgPSBpc1RleHQkODtcbiAgICBjb25zdCBpc0ludmFsaWRUZXh0RWxlbWVudCA9IG1hdGNoTm9kZU5hbWVzKFtcbiAgICAgICdzY3JpcHQnLFxuICAgICAgJ3N0eWxlJyxcbiAgICAgICd0ZXh0YXJlYSdcbiAgICBdKTtcbiAgICBjb25zdCBpc0F0b21pY0lubGluZSA9IG1hdGNoTm9kZU5hbWVzKFtcbiAgICAgICdpbWcnLFxuICAgICAgJ2lucHV0JyxcbiAgICAgICd0ZXh0YXJlYScsXG4gICAgICAnaHInLFxuICAgICAgJ2lmcmFtZScsXG4gICAgICAndmlkZW8nLFxuICAgICAgJ2F1ZGlvJyxcbiAgICAgICdvYmplY3QnLFxuICAgICAgJ2VtYmVkJ1xuICAgIF0pO1xuICAgIGNvbnN0IGlzVGFibGUkMSA9IG1hdGNoTm9kZU5hbWVzKFsndGFibGUnXSk7XG4gICAgY29uc3QgaXNDYXJldENvbnRhaW5lciQxID0gaXNDYXJldENvbnRhaW5lciQyO1xuICAgIGNvbnN0IGlzQ2FyZXRDYW5kaWRhdGUkMyA9IG5vZGUgPT4ge1xuICAgICAgaWYgKGlzQ2FyZXRDb250YWluZXIkMShub2RlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoaXNUZXh0JDYobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuICFpc0ludmFsaWRUZXh0RWxlbWVudChub2RlLnBhcmVudE5vZGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzQXRvbWljSW5saW5lKG5vZGUpIHx8IGlzQnIkMyhub2RlKSB8fCBpc1RhYmxlJDEobm9kZSkgfHwgaXNOb25VaUNvbnRlbnRFZGl0YWJsZUZhbHNlKG5vZGUpO1xuICAgIH07XG4gICAgY29uc3QgaXNVbnNlbGVjdGFibGUgPSBub2RlID0+IGlzRWxlbWVudCQ2KG5vZGUpICYmIG5vZGUuZ2V0QXR0cmlidXRlKCd1bnNlbGVjdGFibGUnKSA9PT0gJ3RydWUnO1xuICAgIGNvbnN0IGlzTm9uVWlDb250ZW50RWRpdGFibGVGYWxzZSA9IG5vZGUgPT4gaXNVbnNlbGVjdGFibGUobm9kZSkgPT09IGZhbHNlICYmIGlzQ29udGVudEVkaXRhYmxlRmFsc2UkOShub2RlKTtcbiAgICBjb25zdCBpc0luRWRpdGFibGUgPSAobm9kZSwgcm9vdCkgPT4ge1xuICAgICAgZm9yIChub2RlID0gbm9kZS5wYXJlbnROb2RlOyBub2RlICYmIG5vZGUgIT09IHJvb3Q7IG5vZGUgPSBub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgaWYgKGlzTm9uVWlDb250ZW50RWRpdGFibGVGYWxzZShub2RlKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDb250ZW50RWRpdGFibGVUcnVlJDMobm9kZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBjb25zdCBpc0F0b21pY0NvbnRlbnRFZGl0YWJsZUZhbHNlID0gbm9kZSA9PiB7XG4gICAgICBpZiAoIWlzTm9uVWlDb250ZW50RWRpdGFibGVGYWxzZShub2RlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gZm9sZGwoZnJvbShub2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKCcqJykpLCAocmVzdWx0LCBlbG0pID0+IHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCB8fCBpc0NvbnRlbnRFZGl0YWJsZVRydWUkMyhlbG0pO1xuICAgICAgfSwgZmFsc2UpICE9PSB0cnVlO1xuICAgIH07XG4gICAgY29uc3QgaXNBdG9taWMkMSA9IG5vZGUgPT4gaXNBdG9taWNJbmxpbmUobm9kZSkgfHwgaXNBdG9taWNDb250ZW50RWRpdGFibGVGYWxzZShub2RlKTtcbiAgICBjb25zdCBpc0VkaXRhYmxlQ2FyZXRDYW5kaWRhdGUkMSA9IChub2RlLCByb290KSA9PiBpc0NhcmV0Q2FuZGlkYXRlJDMobm9kZSkgJiYgaXNJbkVkaXRhYmxlKG5vZGUsIHJvb3QpO1xuXG4gICAgY29uc3Qgd2hpdGVTcGFjZVJlZ0V4cCA9IC9eWyBcXHRcXHJcXG5dKiQvO1xuICAgIGNvbnN0IGlzV2hpdGVzcGFjZVRleHQgPSB0ZXh0ID0+IHdoaXRlU3BhY2VSZWdFeHAudGVzdCh0ZXh0KTtcbiAgICBjb25zdCBpc0NvbGxhcHNpYmxlV2hpdGVzcGFjZSQxID0gYyA9PiAnIFxcZlxcdFxceDBCJy5pbmRleE9mKGMpICE9PSAtMTtcbiAgICBjb25zdCBpc05ld0xpbmVDaGFyID0gYyA9PiBjID09PSAnXFxuJyB8fCBjID09PSAnXFxyJztcbiAgICBjb25zdCBpc05ld2xpbmUgPSAodGV4dCwgaWR4KSA9PiBpZHggPCB0ZXh0Lmxlbmd0aCAmJiBpZHggPj0gMCA/IGlzTmV3TGluZUNoYXIodGV4dFtpZHhdKSA6IGZhbHNlO1xuICAgIGNvbnN0IG5vcm1hbGl6ZSQ0ID0gKHRleHQsIHRhYlNwYWNlcyA9IDQsIGlzU3RhcnRPZkNvbnRlbnQgPSB0cnVlLCBpc0VuZE9mQ29udGVudCA9IHRydWUpID0+IHtcbiAgICAgIGNvbnN0IHRhYlNwYWNlID0gcmVwZWF0KCcgJywgdGFiU3BhY2VzKTtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRUZXh0ID0gdGV4dC5yZXBsYWNlKC9cXHQvZywgdGFiU3BhY2UpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gZm9sZGwobm9ybWFsaXplZFRleHQsIChhY2MsIGMpID0+IHtcbiAgICAgICAgaWYgKGlzQ29sbGFwc2libGVXaGl0ZXNwYWNlJDEoYykgfHwgYyA9PT0gbmJzcCkge1xuICAgICAgICAgIGlmIChhY2MucGNJc1NwYWNlIHx8IGFjYy5zdHIgPT09ICcnICYmIGlzU3RhcnRPZkNvbnRlbnQgfHwgYWNjLnN0ci5sZW5ndGggPT09IG5vcm1hbGl6ZWRUZXh0Lmxlbmd0aCAtIDEgJiYgaXNFbmRPZkNvbnRlbnQgfHwgaXNOZXdsaW5lKG5vcm1hbGl6ZWRUZXh0LCBhY2Muc3RyLmxlbmd0aCArIDEpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBwY0lzU3BhY2U6IGZhbHNlLFxuICAgICAgICAgICAgICBzdHI6IGFjYy5zdHIgKyBuYnNwXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBwY0lzU3BhY2U6IHRydWUsXG4gICAgICAgICAgICAgIHN0cjogYWNjLnN0ciArICcgJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBjSXNTcGFjZTogaXNOZXdMaW5lQ2hhcihjKSxcbiAgICAgICAgICAgIHN0cjogYWNjLnN0ciArIGNcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIHBjSXNTcGFjZTogZmFsc2UsXG4gICAgICAgIHN0cjogJydcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdC5zdHI7XG4gICAgfTtcblxuICAgIGNvbnN0IGhhc1doaXRlc3BhY2VQcmVzZXJ2ZVBhcmVudCA9IChub2RlLCByb290Tm9kZSkgPT4ge1xuICAgICAgY29uc3Qgcm9vdEVsZW1lbnQgPSBTdWdhckVsZW1lbnQuZnJvbURvbShyb290Tm9kZSk7XG4gICAgICBjb25zdCBzdGFydE5vZGUgPSBTdWdhckVsZW1lbnQuZnJvbURvbShub2RlKTtcbiAgICAgIHJldHVybiBhbmNlc3RvciQxKHN0YXJ0Tm9kZSwgJ3ByZSxjb2RlJywgY3VycnkoZXEsIHJvb3RFbGVtZW50KSk7XG4gICAgfTtcbiAgICBjb25zdCBpc1doaXRlc3BhY2UkMSA9IChub2RlLCByb290Tm9kZSkgPT4ge1xuICAgICAgcmV0dXJuIGlzVGV4dCQ4KG5vZGUpICYmIGlzV2hpdGVzcGFjZVRleHQobm9kZS5kYXRhKSAmJiBoYXNXaGl0ZXNwYWNlUHJlc2VydmVQYXJlbnQobm9kZSwgcm9vdE5vZGUpID09PSBmYWxzZTtcbiAgICB9O1xuICAgIGNvbnN0IGlzTmFtZWRBbmNob3IgPSBub2RlID0+IHtcbiAgICAgIHJldHVybiBpc0VsZW1lbnQkNihub2RlKSAmJiBub2RlLm5vZGVOYW1lID09PSAnQScgJiYgIW5vZGUuaGFzQXR0cmlidXRlKCdocmVmJykgJiYgKG5vZGUuaGFzQXR0cmlidXRlKCduYW1lJykgfHwgbm9kZS5oYXNBdHRyaWJ1dGUoJ2lkJykpO1xuICAgIH07XG4gICAgY29uc3QgaXNDb250ZW50JDEgPSAobm9kZSwgcm9vdE5vZGUpID0+IHtcbiAgICAgIHJldHVybiBpc0NhcmV0Q2FuZGlkYXRlJDMobm9kZSkgJiYgaXNXaGl0ZXNwYWNlJDEobm9kZSwgcm9vdE5vZGUpID09PSBmYWxzZSB8fCBpc05hbWVkQW5jaG9yKG5vZGUpIHx8IGlzQm9va21hcmsobm9kZSk7XG4gICAgfTtcbiAgICBjb25zdCBpc0Jvb2ttYXJrID0gaGFzQXR0cmlidXRlKCdkYXRhLW1jZS1ib29rbWFyaycpO1xuICAgIGNvbnN0IGlzQm9ndXMkMSA9IGhhc0F0dHJpYnV0ZSgnZGF0YS1tY2UtYm9ndXMnKTtcbiAgICBjb25zdCBpc0JvZ3VzQWxsID0gaGFzQXR0cmlidXRlVmFsdWUoJ2RhdGEtbWNlLWJvZ3VzJywgJ2FsbCcpO1xuICAgIGNvbnN0IGlzRW1wdHlOb2RlID0gKHRhcmdldE5vZGUsIHNraXBCb2d1cykgPT4ge1xuICAgICAgbGV0IGJyQ291bnQgPSAwO1xuICAgICAgaWYgKGlzQ29udGVudCQxKHRhcmdldE5vZGUsIHRhcmdldE5vZGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBub2RlID0gdGFyZ2V0Tm9kZS5maXJzdENoaWxkO1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3YWxrZXIgPSBuZXcgRG9tVHJlZVdhbGtlcihub2RlLCB0YXJnZXROb2RlKTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIGlmIChza2lwQm9ndXMpIHtcbiAgICAgICAgICAgIGlmIChpc0JvZ3VzQWxsKG5vZGUpKSB7XG4gICAgICAgICAgICAgIG5vZGUgPSB3YWxrZXIubmV4dCh0cnVlKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNCb2d1cyQxKG5vZGUpKSB7XG4gICAgICAgICAgICAgIG5vZGUgPSB3YWxrZXIubmV4dCgpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzQnIkNShub2RlKSkge1xuICAgICAgICAgICAgYnJDb3VudCsrO1xuICAgICAgICAgICAgbm9kZSA9IHdhbGtlci5uZXh0KCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzQ29udGVudCQxKG5vZGUsIHRhcmdldE5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUgPSB3YWxrZXIubmV4dCgpO1xuICAgICAgICB9IHdoaWxlIChub2RlKTtcbiAgICAgICAgcmV0dXJuIGJyQ291bnQgPD0gMTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGlzRW1wdHkkMiA9IChlbG0sIHNraXBCb2d1cyA9IHRydWUpID0+IGlzRW1wdHlOb2RlKGVsbS5kb20sIHNraXBCb2d1cyk7XG5cbiAgICBjb25zdCBpc1NwYW4gPSBub2RlID0+IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3NwYW4nO1xuICAgIGNvbnN0IGlzSW5saW5lQ29udGVudCA9IChub2RlLCByb290KSA9PiBpc05vbk51bGxhYmxlKG5vZGUpICYmIChpc0NvbnRlbnQkMShub2RlLCByb290KSB8fCBpc0lubGluZSQxKFN1Z2FyRWxlbWVudC5mcm9tRG9tKG5vZGUpKSk7XG4gICAgY29uc3Qgc3Vycm91bmRlZEJ5SW5saW5lQ29udGVudCA9IChub2RlLCByb290KSA9PiB7XG4gICAgICBjb25zdCBwcmV2ID0gbmV3IERvbVRyZWVXYWxrZXIobm9kZSwgcm9vdCkucHJldihmYWxzZSk7XG4gICAgICBjb25zdCBuZXh0ID0gbmV3IERvbVRyZWVXYWxrZXIobm9kZSwgcm9vdCkubmV4dChmYWxzZSk7XG4gICAgICBjb25zdCBwcmV2SXNJbmxpbmUgPSBpc1VuZGVmaW5lZChwcmV2KSB8fCBpc0lubGluZUNvbnRlbnQocHJldiwgcm9vdCk7XG4gICAgICBjb25zdCBuZXh0SXNJbmxpbmUgPSBpc1VuZGVmaW5lZChuZXh0KSB8fCBpc0lubGluZUNvbnRlbnQobmV4dCwgcm9vdCk7XG4gICAgICByZXR1cm4gcHJldklzSW5saW5lICYmIG5leHRJc0lubGluZTtcbiAgICB9O1xuICAgIGNvbnN0IGlzQm9va21hcmtOb2RlJDIgPSBub2RlID0+IGlzU3Bhbihub2RlKSAmJiBub2RlLmdldEF0dHJpYnV0ZSgnZGF0YS1tY2UtdHlwZScpID09PSAnYm9va21hcmsnO1xuICAgIGNvbnN0IGlzS2VlcFRleHROb2RlID0gKG5vZGUsIHJvb3QpID0+IGlzVGV4dCQ4KG5vZGUpICYmIG5vZGUuZGF0YS5sZW5ndGggPiAwICYmIHN1cnJvdW5kZWRCeUlubGluZUNvbnRlbnQobm9kZSwgcm9vdCk7XG4gICAgY29uc3QgaXNLZWVwRWxlbWVudCA9IG5vZGUgPT4gaXNFbGVtZW50JDYobm9kZSkgPyBub2RlLmNoaWxkTm9kZXMubGVuZ3RoID4gMCA6IGZhbHNlO1xuICAgIGNvbnN0IGlzRG9jdW1lbnQgPSBub2RlID0+IGlzRG9jdW1lbnRGcmFnbWVudChub2RlKSB8fCBpc0RvY3VtZW50JDEobm9kZSk7XG4gICAgY29uc3QgdHJpbU5vZGUgPSAoZG9tLCBub2RlLCByb290KSA9PiB7XG4gICAgICBjb25zdCByb290Tm9kZSA9IHJvb3QgfHwgbm9kZTtcbiAgICAgIGlmIChpc0VsZW1lbnQkNihub2RlKSAmJiBpc0Jvb2ttYXJrTm9kZSQyKG5vZGUpKSB7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuICAgICAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmNoaWxkTm9kZXM7XG4gICAgICBmb3IgKGxldCBpID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdHJpbU5vZGUoZG9tLCBjaGlsZHJlbltpXSwgcm9vdE5vZGUpO1xuICAgICAgfVxuICAgICAgaWYgKGlzRWxlbWVudCQ2KG5vZGUpKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRDaGlsZHJlbiA9IG5vZGUuY2hpbGROb2RlcztcbiAgICAgICAgaWYgKGN1cnJlbnRDaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgaXNCb29rbWFya05vZGUkMihjdXJyZW50Q2hpbGRyZW5bMF0pKSB7XG4gICAgICAgICAgbm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShjdXJyZW50Q2hpbGRyZW5bMF0sIG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWlzRG9jdW1lbnQobm9kZSkgJiYgIWlzQ29udGVudCQxKG5vZGUsIHJvb3ROb2RlKSAmJiAhaXNLZWVwRWxlbWVudChub2RlKSAmJiAhaXNLZWVwVGV4dE5vZGUobm9kZSwgcm9vdE5vZGUpKSB7XG4gICAgICAgIGRvbS5yZW1vdmUobm9kZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuXG4gICAgY29uc3QgbWFrZU1hcCQzID0gVG9vbHMubWFrZU1hcDtcbiAgICBjb25zdCBhdHRyc0NoYXJzUmVnRXhwID0gL1smPD5cXFwiXFx1MDA2MFxcdTAwN0UtXFx1RDdGRlxcdUUwMDAtXFx1RkZFRl18W1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXS9nO1xuICAgIGNvbnN0IHRleHRDaGFyc1JlZ0V4cCA9IC9bPD4mXFx1MDA3RS1cXHVEN0ZGXFx1RTAwMC1cXHVGRkVGXXxbXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdL2c7XG4gICAgY29uc3QgcmF3Q2hhcnNSZWdFeHAgPSAvWzw+JlxcXCJcXCddL2c7XG4gICAgY29uc3QgZW50aXR5UmVnRXhwID0gLyYjKFthLXowLTldKyk7P3wmKFthLXowLTldKyk7L2dpO1xuICAgIGNvbnN0IGFzY2lpTWFwID0ge1xuICAgICAgMTI4OiAnXFx1MjBBQycsXG4gICAgICAxMzA6ICdcXHUyMDFBJyxcbiAgICAgIDEzMTogJ1xcdTAxOTInLFxuICAgICAgMTMyOiAnXFx1MjAxRScsXG4gICAgICAxMzM6ICdcXHUyMDI2JyxcbiAgICAgIDEzNDogJ1xcdTIwMjAnLFxuICAgICAgMTM1OiAnXFx1MjAyMScsXG4gICAgICAxMzY6ICdcXHUwMmM2JyxcbiAgICAgIDEzNzogJ1xcdTIwMzAnLFxuICAgICAgMTM4OiAnXFx1MDE2MCcsXG4gICAgICAxMzk6ICdcXHUyMDM5JyxcbiAgICAgIDE0MDogJ1xcdTAxNTInLFxuICAgICAgMTQyOiAnXFx1MDE3ZCcsXG4gICAgICAxNDU6ICdcXHUyMDE4JyxcbiAgICAgIDE0NjogJ1xcdTIwMTknLFxuICAgICAgMTQ3OiAnXFx1MjAxQycsXG4gICAgICAxNDg6ICdcXHUyMDFEJyxcbiAgICAgIDE0OTogJ1xcdTIwMjInLFxuICAgICAgMTUwOiAnXFx1MjAxMycsXG4gICAgICAxNTE6ICdcXHUyMDE0JyxcbiAgICAgIDE1MjogJ1xcdTAyREMnLFxuICAgICAgMTUzOiAnXFx1MjEyMicsXG4gICAgICAxNTQ6ICdcXHUwMTYxJyxcbiAgICAgIDE1NTogJ1xcdTIwM0EnLFxuICAgICAgMTU2OiAnXFx1MDE1MycsXG4gICAgICAxNTg6ICdcXHUwMTdlJyxcbiAgICAgIDE1OTogJ1xcdTAxNzgnXG4gICAgfTtcbiAgICBjb25zdCBiYXNlRW50aXRpZXMgPSB7XG4gICAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICAgICdcXCcnOiAnJiMzOTsnLFxuICAgICAgJzwnOiAnJmx0OycsXG4gICAgICAnPic6ICcmZ3Q7JyxcbiAgICAgICcmJzogJyZhbXA7JyxcbiAgICAgICdgJzogJyYjOTY7J1xuICAgIH07XG4gICAgY29uc3QgcmV2ZXJzZUVudGl0aWVzID0ge1xuICAgICAgJyZsdDsnOiAnPCcsXG4gICAgICAnJmd0Oyc6ICc+JyxcbiAgICAgICcmYW1wOyc6ICcmJyxcbiAgICAgICcmcXVvdDsnOiAnXCInLFxuICAgICAgJyZhcG9zOyc6IGAnYFxuICAgIH07XG4gICAgY29uc3QgbmF0aXZlRGVjb2RlID0gdGV4dCA9PiB7XG4gICAgICBjb25zdCBlbG0gPSBTdWdhckVsZW1lbnQuZnJvbVRhZygnZGl2JykuZG9tO1xuICAgICAgZWxtLmlubmVySFRNTCA9IHRleHQ7XG4gICAgICByZXR1cm4gZWxtLnRleHRDb250ZW50IHx8IGVsbS5pbm5lclRleHQgfHwgdGV4dDtcbiAgICB9O1xuICAgIGNvbnN0IGJ1aWxkRW50aXRpZXNMb29rdXAgPSAoaXRlbXMsIHJhZGl4KSA9PiB7XG4gICAgICBsZXQgaSwgY2hyLCBlbnRpdHk7XG4gICAgICBjb25zdCBsb29rdXAgPSB7fTtcbiAgICAgIGlmIChpdGVtcykge1xuICAgICAgICBpdGVtcyA9IGl0ZW1zLnNwbGl0KCcsJyk7XG4gICAgICAgIHJhZGl4ID0gcmFkaXggfHwgMTA7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgIGNociA9IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoaXRlbXNbaV0sIHJhZGl4KSk7XG4gICAgICAgICAgaWYgKCFiYXNlRW50aXRpZXNbY2hyXSkge1xuICAgICAgICAgICAgZW50aXR5ID0gJyYnICsgaXRlbXNbaSArIDFdICsgJzsnO1xuICAgICAgICAgICAgbG9va3VwW2Nocl0gPSBlbnRpdHk7XG4gICAgICAgICAgICBsb29rdXBbZW50aXR5XSA9IGNocjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvb2t1cDtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG5hbWVkRW50aXRpZXMgPSBidWlsZEVudGl0aWVzTG9va3VwKCc1MCxuYnNwLDUxLGlleGNsLDUyLGNlbnQsNTMscG91bmQsNTQsY3VycmVuLDU1LHllbiw1NixicnZiYXIsNTcsc2VjdCw1OCx1bWwsNTksY29weSwnICsgJzVhLG9yZGYsNWIsbGFxdW8sNWMsbm90LDVkLHNoeSw1ZSxyZWcsNWYsbWFjciw1ZyxkZWcsNWgscGx1c21uLDVpLHN1cDIsNWosc3VwMyw1ayxhY3V0ZSwnICsgJzVsLG1pY3JvLDVtLHBhcmEsNW4sbWlkZG90LDVvLGNlZGlsLDVwLHN1cDEsNXEsb3JkbSw1cixyYXF1byw1cyxmcmFjMTQsNXQsZnJhYzEyLDV1LGZyYWMzNCwnICsgJzV2LGlxdWVzdCw2MCxBZ3JhdmUsNjEsQWFjdXRlLDYyLEFjaXJjLDYzLEF0aWxkZSw2NCxBdW1sLDY1LEFyaW5nLDY2LEFFbGlnLDY3LENjZWRpbCwnICsgJzY4LEVncmF2ZSw2OSxFYWN1dGUsNmEsRWNpcmMsNmIsRXVtbCw2YyxJZ3JhdmUsNmQsSWFjdXRlLDZlLEljaXJjLDZmLEl1bWwsNmcsRVRILDZoLE50aWxkZSwnICsgJzZpLE9ncmF2ZSw2aixPYWN1dGUsNmssT2NpcmMsNmwsT3RpbGRlLDZtLE91bWwsNm4sdGltZXMsNm8sT3NsYXNoLDZwLFVncmF2ZSw2cSxVYWN1dGUsJyArICc2cixVY2lyYyw2cyxVdW1sLDZ0LFlhY3V0ZSw2dSxUSE9STiw2dixzemxpZyw3MCxhZ3JhdmUsNzEsYWFjdXRlLDcyLGFjaXJjLDczLGF0aWxkZSw3NCxhdW1sLCcgKyAnNzUsYXJpbmcsNzYsYWVsaWcsNzcsY2NlZGlsLDc4LGVncmF2ZSw3OSxlYWN1dGUsN2EsZWNpcmMsN2IsZXVtbCw3YyxpZ3JhdmUsN2QsaWFjdXRlLDdlLGljaXJjLCcgKyAnN2YsaXVtbCw3ZyxldGgsN2gsbnRpbGRlLDdpLG9ncmF2ZSw3aixvYWN1dGUsN2ssb2NpcmMsN2wsb3RpbGRlLDdtLG91bWwsN24sZGl2aWRlLDdvLG9zbGFzaCwnICsgJzdwLHVncmF2ZSw3cSx1YWN1dGUsN3IsdWNpcmMsN3MsdXVtbCw3dCx5YWN1dGUsN3UsdGhvcm4sN3YseXVtbCxjaSxmbm9mLHNoLEFscGhhLHNpLEJldGEsJyArICdzaixHYW1tYSxzayxEZWx0YSxzbCxFcHNpbG9uLHNtLFpldGEsc24sRXRhLHNvLFRoZXRhLHNwLElvdGEsc3EsS2FwcGEsc3IsTGFtYmRhLHNzLE11LCcgKyAnc3QsTnUsc3UsWGksc3YsT21pY3Jvbix0MCxQaSx0MSxSaG8sdDMsU2lnbWEsdDQsVGF1LHQ1LFVwc2lsb24sdDYsUGhpLHQ3LENoaSx0OCxQc2ksJyArICd0OSxPbWVnYSx0aCxhbHBoYSx0aSxiZXRhLHRqLGdhbW1hLHRrLGRlbHRhLHRsLGVwc2lsb24sdG0semV0YSx0bixldGEsdG8sdGhldGEsdHAsaW90YSwnICsgJ3RxLGthcHBhLHRyLGxhbWJkYSx0cyxtdSx0dCxudSx0dSx4aSx0dixvbWljcm9uLHUwLHBpLHUxLHJobyx1MixzaWdtYWYsdTMsc2lnbWEsdTQsdGF1LCcgKyAndTUsdXBzaWxvbix1NixwaGksdTcsY2hpLHU4LHBzaSx1OSxvbWVnYSx1aCx0aGV0YXN5bSx1aSx1cHNpaCx1bSxwaXYsODEyLGJ1bGwsODE2LGhlbGxpcCwnICsgJzgxaSxwcmltZSw4MWosUHJpbWUsODF1LG9saW5lLDgyNCxmcmFzbCw4OG8sd2VpZXJwLDg4aCxpbWFnZSw4OHMscmVhbCw4OTIsdHJhZGUsODlsLGFsZWZzeW0sJyArICc4Y2csbGFyciw4Y2gsdWFyciw4Y2kscmFyciw4Y2osZGFyciw4Y2ssaGFyciw4ZGwsY3JhcnIsOGVnLGxBcnIsOGVoLHVBcnIsOGVpLHJBcnIsOGVqLGRBcnIsJyArICc4ZWssaEFyciw4ZzAsZm9yYWxsLDhnMixwYXJ0LDhnMyxleGlzdCw4ZzUsZW1wdHksOGc3LG5hYmxhLDhnOCxpc2luLDhnOSxub3Rpbiw4Z2IsbmksOGdmLHByb2QsJyArICc4Z2gsc3VtLDhnaSxtaW51cyw4Z24sbG93YXN0LDhncSxyYWRpYyw4Z3QscHJvcCw4Z3UsaW5maW4sOGgwLGFuZyw4aDcsYW5kLDhoOCxvciw4aDksY2FwLDhoYSxjdXAsJyArICc4aGIsaW50LDhoayx0aGVyZTQsOGhzLHNpbSw4aTUsY29uZyw4aTgsYXN5bXAsOGowLG5lLDhqMSxlcXVpdiw4ajQsbGUsOGo1LGdlLDhrMixzdWIsOGszLHN1cCw4azQsJyArICduc3ViLDhrNixzdWJlLDhrNyxzdXBlLDhrbCxvcGx1cyw4a24sb3RpbWVzLDhsNSxwZXJwLDhtNSxzZG90LDhvOCxsY2VpbCw4bzkscmNlaWwsOG9hLGxmbG9vciw4b2IsJyArICdyZmxvb3IsOHA5LGxhbmcsOHBhLHJhbmcsOWVhLGxveiw5ajAsc3BhZGVzLDlqMyxjbHVicyw5ajUsaGVhcnRzLDlqNixkaWFtcyxhaSxPRWxpZyxhaixvZWxpZyxiMCwnICsgJ1NjYXJvbixiMSxzY2Fyb24sYm8sWXVtbCxtNixjaXJjLG1zLHRpbGRlLDgwMixlbnNwLDgwMyxlbXNwLDgwOSx0aGluc3AsODBjLHp3bmosODBkLHp3aiw4MGUsbHJtLCcgKyAnODBmLHJsbSw4MGosbmRhc2gsODBrLG1kYXNoLDgwbyxsc3F1byw4MHAscnNxdW8sODBxLHNicXVvLDgwcyxsZHF1byw4MHQscmRxdW8sODB1LGJkcXVvLDgxMCxkYWdnZXIsJyArICc4MTEsRGFnZ2VyLDgxZyxwZXJtaWwsODFwLGxzYXF1byw4MXEscnNhcXVvLDg1YyxldXJvJywgMzIpO1xuICAgIGNvbnN0IGVuY29kZVJhdyA9ICh0ZXh0LCBhdHRyKSA9PiB0ZXh0LnJlcGxhY2UoYXR0ciA/IGF0dHJzQ2hhcnNSZWdFeHAgOiB0ZXh0Q2hhcnNSZWdFeHAsIGNociA9PiB7XG4gICAgICByZXR1cm4gYmFzZUVudGl0aWVzW2Nocl0gfHwgY2hyO1xuICAgIH0pO1xuICAgIGNvbnN0IGVuY29kZUFsbFJhdyA9IHRleHQgPT4gKCcnICsgdGV4dCkucmVwbGFjZShyYXdDaGFyc1JlZ0V4cCwgY2hyID0+IHtcbiAgICAgIHJldHVybiBiYXNlRW50aXRpZXNbY2hyXSB8fCBjaHI7XG4gICAgfSk7XG4gICAgY29uc3QgZW5jb2RlTnVtZXJpYyA9ICh0ZXh0LCBhdHRyKSA9PiB0ZXh0LnJlcGxhY2UoYXR0ciA/IGF0dHJzQ2hhcnNSZWdFeHAgOiB0ZXh0Q2hhcnNSZWdFeHAsIGNociA9PiB7XG4gICAgICBpZiAoY2hyLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgcmV0dXJuICcmIycgKyAoKGNoci5jaGFyQ29kZUF0KDApIC0gNTUyOTYpICogMTAyNCArIChjaHIuY2hhckNvZGVBdCgxKSAtIDU2MzIwKSArIDY1NTM2KSArICc7JztcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlRW50aXRpZXNbY2hyXSB8fCAnJiMnICsgY2hyLmNoYXJDb2RlQXQoMCkgKyAnOyc7XG4gICAgfSk7XG4gICAgY29uc3QgZW5jb2RlTmFtZWQgPSAodGV4dCwgYXR0ciwgZW50aXRpZXMpID0+IHtcbiAgICAgIGVudGl0aWVzID0gZW50aXRpZXMgfHwgbmFtZWRFbnRpdGllcztcbiAgICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoYXR0ciA/IGF0dHJzQ2hhcnNSZWdFeHAgOiB0ZXh0Q2hhcnNSZWdFeHAsIGNociA9PiB7XG4gICAgICAgIHJldHVybiBiYXNlRW50aXRpZXNbY2hyXSB8fCBlbnRpdGllc1tjaHJdIHx8IGNocjtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgZ2V0RW5jb2RlRnVuYyA9IChuYW1lLCBlbnRpdGllcykgPT4ge1xuICAgICAgY29uc3QgZW50aXRpZXNNYXAgPSBidWlsZEVudGl0aWVzTG9va3VwKGVudGl0aWVzKSB8fCBuYW1lZEVudGl0aWVzO1xuICAgICAgY29uc3QgZW5jb2RlTmFtZWRBbmROdW1lcmljID0gKHRleHQsIGF0dHIpID0+IHRleHQucmVwbGFjZShhdHRyID8gYXR0cnNDaGFyc1JlZ0V4cCA6IHRleHRDaGFyc1JlZ0V4cCwgY2hyID0+IHtcbiAgICAgICAgaWYgKGJhc2VFbnRpdGllc1tjaHJdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gYmFzZUVudGl0aWVzW2Nocl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVudGl0aWVzTWFwW2Nocl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBlbnRpdGllc01hcFtjaHJdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaHIubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHJldHVybiAnJiMnICsgKChjaHIuY2hhckNvZGVBdCgwKSAtIDU1Mjk2KSAqIDEwMjQgKyAoY2hyLmNoYXJDb2RlQXQoMSkgLSA1NjMyMCkgKyA2NTUzNikgKyAnOyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcmIycgKyBjaHIuY2hhckNvZGVBdCgwKSArICc7JztcbiAgICAgIH0pO1xuICAgICAgY29uc3QgZW5jb2RlQ3VzdG9tTmFtZWQgPSAodGV4dCwgYXR0cikgPT4ge1xuICAgICAgICByZXR1cm4gZW5jb2RlTmFtZWQodGV4dCwgYXR0ciwgZW50aXRpZXNNYXApO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IG5hbWVNYXAgPSBtYWtlTWFwJDMobmFtZS5yZXBsYWNlKC9cXCsvZywgJywnKSk7XG4gICAgICBpZiAobmFtZU1hcC5uYW1lZCAmJiBuYW1lTWFwLm51bWVyaWMpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZU5hbWVkQW5kTnVtZXJpYztcbiAgICAgIH1cbiAgICAgIGlmIChuYW1lTWFwLm5hbWVkKSB7XG4gICAgICAgIGlmIChlbnRpdGllcykge1xuICAgICAgICAgIHJldHVybiBlbmNvZGVDdXN0b21OYW1lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW5jb2RlTmFtZWQ7XG4gICAgICB9XG4gICAgICBpZiAobmFtZU1hcC5udW1lcmljKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVOdW1lcmljO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVuY29kZVJhdztcbiAgICB9O1xuICAgIGNvbnN0IGRlY29kZSA9IHRleHQgPT4gdGV4dC5yZXBsYWNlKGVudGl0eVJlZ0V4cCwgKGFsbCwgbnVtZXJpYykgPT4ge1xuICAgICAgaWYgKG51bWVyaWMpIHtcbiAgICAgICAgaWYgKG51bWVyaWMuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgPT09ICd4Jykge1xuICAgICAgICAgIG51bWVyaWMgPSBwYXJzZUludChudW1lcmljLnN1YnN0cigxKSwgMTYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG51bWVyaWMgPSBwYXJzZUludChudW1lcmljLCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG51bWVyaWMgPiA2NTUzNSkge1xuICAgICAgICAgIG51bWVyaWMgLT0gNjU1MzY7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTYgKyAobnVtZXJpYyA+PiAxMCksIDU2MzIwICsgKG51bWVyaWMgJiAxMDIzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzY2lpTWFwW251bWVyaWNdIHx8IFN0cmluZy5mcm9tQ2hhckNvZGUobnVtZXJpYyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV2ZXJzZUVudGl0aWVzW2FsbF0gfHwgbmFtZWRFbnRpdGllc1thbGxdIHx8IG5hdGl2ZURlY29kZShhbGwpO1xuICAgIH0pO1xuICAgIGNvbnN0IEVudGl0aWVzID0ge1xuICAgICAgZW5jb2RlUmF3LFxuICAgICAgZW5jb2RlQWxsUmF3LFxuICAgICAgZW5jb2RlTnVtZXJpYyxcbiAgICAgIGVuY29kZU5hbWVkLFxuICAgICAgZ2V0RW5jb2RlRnVuYyxcbiAgICAgIGRlY29kZVxuICAgIH07XG5cbiAgICBjb25zdCBtYXBDYWNoZSA9IHt9LCBkdW1teU9iaiA9IHt9O1xuICAgIGNvbnN0IG1ha2VNYXAkMiA9IFRvb2xzLm1ha2VNYXAsIGVhY2gkZCA9IFRvb2xzLmVhY2gsIGV4dGVuZCQyID0gVG9vbHMuZXh0ZW5kLCBleHBsb2RlJDIgPSBUb29scy5leHBsb2RlLCBpbkFycmF5ID0gVG9vbHMuaW5BcnJheTtcbiAgICBjb25zdCBzcGxpdCQxID0gKGl0ZW1zLCBkZWxpbSkgPT4ge1xuICAgICAgaXRlbXMgPSBUb29scy50cmltKGl0ZW1zKTtcbiAgICAgIHJldHVybiBpdGVtcyA/IGl0ZW1zLnNwbGl0KGRlbGltIHx8ICcgJykgOiBbXTtcbiAgICB9O1xuICAgIGNvbnN0IGNyZWF0ZU1hcCA9IChkZWZhdWx0VmFsdWUsIGV4dGVuZFdpdGgpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gbWFrZU1hcCQyKGRlZmF1bHRWYWx1ZSwgJyAnLCBtYWtlTWFwJDIoZGVmYXVsdFZhbHVlLnRvVXBwZXJDYXNlKCksICcgJykpO1xuICAgICAgcmV0dXJuIGV4dGVuZCQyKHZhbHVlLCBleHRlbmRXaXRoKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldFRleHRSb290QmxvY2tFbGVtZW50cyA9IHNjaGVtYSA9PiBjcmVhdGVNYXAoJ3RkIHRoIGxpIGR0IGRkIGZpZ2NhcHRpb24gY2FwdGlvbiBkZXRhaWxzIHN1bW1hcnknLCBzY2hlbWEuZ2V0VGV4dEJsb2NrRWxlbWVudHMoKSk7XG4gICAgY29uc3QgY29tcGlsZVNjaGVtYSA9IHR5cGUgPT4ge1xuICAgICAgY29uc3Qgc2NoZW1hID0ge307XG4gICAgICBsZXQgZ2xvYmFsQXR0cmlidXRlcywgYmxvY2tDb250ZW50O1xuICAgICAgbGV0IHBocmFzaW5nQ29udGVudCwgZmxvd0NvbnRlbnQsIGh0bWw0QmxvY2tDb250ZW50LCBodG1sNFBocmFzaW5nQ29udGVudDtcbiAgICAgIGNvbnN0IGFkZCA9IChuYW1lLCBhdHRyaWJ1dGVzID0gJycsIGNoaWxkcmVuID0gJycpID0+IHtcbiAgICAgICAgY29uc3QgY2hpbGROYW1lcyA9IHNwbGl0JDEoY2hpbGRyZW4pO1xuICAgICAgICBjb25zdCBuYW1lcyA9IHNwbGl0JDEobmFtZSk7XG4gICAgICAgIGxldCBuaSA9IG5hbWVzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKG5pLS0pIHtcbiAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVzT3JkZXIgPSBzcGxpdCQxKFtcbiAgICAgICAgICAgIGdsb2JhbEF0dHJpYnV0ZXMsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzXG4gICAgICAgICAgXS5qb2luKCcgJykpO1xuICAgICAgICAgIHNjaGVtYVtuYW1lc1tuaV1dID0ge1xuICAgICAgICAgICAgYXR0cmlidXRlczogbWFwVG9PYmplY3QoYXR0cmlidXRlc09yZGVyLCAoKSA9PiAoe30pKSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXNPcmRlcixcbiAgICAgICAgICAgIGNoaWxkcmVuOiBtYXBUb09iamVjdChjaGlsZE5hbWVzLCBjb25zdGFudChkdW1teU9iaikpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGFkZEF0dHJzID0gKG5hbWUsIGF0dHJpYnV0ZXMpID0+IHtcbiAgICAgICAgY29uc3QgbmFtZXMgPSBzcGxpdCQxKG5hbWUpO1xuICAgICAgICBjb25zdCBhdHRycyA9IHNwbGl0JDEoYXR0cmlidXRlcyk7XG4gICAgICAgIGxldCBuaSA9IG5hbWVzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKG5pLS0pIHtcbiAgICAgICAgICBjb25zdCBzY2hlbWFJdGVtID0gc2NoZW1hW25hbWVzW25pXV07XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBhdHRycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHNjaGVtYUl0ZW0uYXR0cmlidXRlc1thdHRyc1tpXV0gPSB7fTtcbiAgICAgICAgICAgIHNjaGVtYUl0ZW0uYXR0cmlidXRlc09yZGVyLnB1c2goYXR0cnNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmIChtYXBDYWNoZVt0eXBlXSkge1xuICAgICAgICByZXR1cm4gbWFwQ2FjaGVbdHlwZV07XG4gICAgICB9XG4gICAgICBnbG9iYWxBdHRyaWJ1dGVzID0gJ2lkIGFjY2Vzc2tleSBjbGFzcyBkaXIgbGFuZyBzdHlsZSB0YWJpbmRleCB0aXRsZSByb2xlJztcbiAgICAgIGJsb2NrQ29udGVudCA9ICdhZGRyZXNzIGJsb2NrcXVvdGUgZGl2IGRsIGZpZWxkc2V0IGZvcm0gaDEgaDIgaDMgaDQgaDUgaDYgaHIgbWVudSBvbCBwIHByZSB0YWJsZSB1bCc7XG4gICAgICBwaHJhc2luZ0NvbnRlbnQgPSAnYSBhYmJyIGIgYmRvIGJyIGJ1dHRvbiBjaXRlIGNvZGUgZGVsIGRmbiBlbSBlbWJlZCBpIGlmcmFtZSBpbWcgaW5wdXQgaW5zIGtiZCAnICsgJ2xhYmVsIG1hcCBub3NjcmlwdCBvYmplY3QgcSBzIHNhbXAgc2NyaXB0IHNlbGVjdCBzbWFsbCBzcGFuIHN0cm9uZyBzdWIgc3VwICcgKyAndGV4dGFyZWEgdSB2YXIgI3RleHQgI2NvbW1lbnQnO1xuICAgICAgaWYgKHR5cGUgIT09ICdodG1sNCcpIHtcbiAgICAgICAgZ2xvYmFsQXR0cmlidXRlcyArPSAnIGNvbnRlbnRlZGl0YWJsZSBjb250ZXh0bWVudSBkcmFnZ2FibGUgZHJvcHpvbmUgJyArICdoaWRkZW4gc3BlbGxjaGVjayB0cmFuc2xhdGUnO1xuICAgICAgICBibG9ja0NvbnRlbnQgKz0gJyBhcnRpY2xlIGFzaWRlIGRldGFpbHMgZGlhbG9nIGZpZ3VyZSBtYWluIGhlYWRlciBmb290ZXIgaGdyb3VwIHNlY3Rpb24gbmF2JztcbiAgICAgICAgcGhyYXNpbmdDb250ZW50ICs9ICcgYXVkaW8gY2FudmFzIGNvbW1hbmQgZGF0YWxpc3QgbWFyayBtZXRlciBvdXRwdXQgcGljdHVyZSAnICsgJ3Byb2dyZXNzIHRpbWUgd2JyIHZpZGVvIHJ1YnkgYmRpIGtleWdlbic7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSAhPT0gJ2h0bWw1LXN0cmljdCcpIHtcbiAgICAgICAgZ2xvYmFsQXR0cmlidXRlcyArPSAnIHhtbDpsYW5nJztcbiAgICAgICAgaHRtbDRQaHJhc2luZ0NvbnRlbnQgPSAnYWNyb255bSBhcHBsZXQgYmFzZWZvbnQgYmlnIGZvbnQgc3RyaWtlIHR0JztcbiAgICAgICAgcGhyYXNpbmdDb250ZW50ID0gW1xuICAgICAgICAgIHBocmFzaW5nQ29udGVudCxcbiAgICAgICAgICBodG1sNFBocmFzaW5nQ29udGVudFxuICAgICAgICBdLmpvaW4oJyAnKTtcbiAgICAgICAgZWFjaCRkKHNwbGl0JDEoaHRtbDRQaHJhc2luZ0NvbnRlbnQpLCBuYW1lID0+IHtcbiAgICAgICAgICBhZGQobmFtZSwgJycsIHBocmFzaW5nQ29udGVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICBodG1sNEJsb2NrQ29udGVudCA9ICdjZW50ZXIgZGlyIGlzaW5kZXggbm9mcmFtZXMnO1xuICAgICAgICBibG9ja0NvbnRlbnQgPSBbXG4gICAgICAgICAgYmxvY2tDb250ZW50LFxuICAgICAgICAgIGh0bWw0QmxvY2tDb250ZW50XG4gICAgICAgIF0uam9pbignICcpO1xuICAgICAgICBmbG93Q29udGVudCA9IFtcbiAgICAgICAgICBibG9ja0NvbnRlbnQsXG4gICAgICAgICAgcGhyYXNpbmdDb250ZW50XG4gICAgICAgIF0uam9pbignICcpO1xuICAgICAgICBlYWNoJGQoc3BsaXQkMShodG1sNEJsb2NrQ29udGVudCksIG5hbWUgPT4ge1xuICAgICAgICAgIGFkZChuYW1lLCAnJywgZmxvd0NvbnRlbnQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGZsb3dDb250ZW50ID0gZmxvd0NvbnRlbnQgfHwgW1xuICAgICAgICBibG9ja0NvbnRlbnQsXG4gICAgICAgIHBocmFzaW5nQ29udGVudFxuICAgICAgXS5qb2luKCcgJyk7XG4gICAgICBhZGQoJ2h0bWwnLCAnbWFuaWZlc3QnLCAnaGVhZCBib2R5Jyk7XG4gICAgICBhZGQoJ2hlYWQnLCAnJywgJ2Jhc2UgY29tbWFuZCBsaW5rIG1ldGEgbm9zY3JpcHQgc2NyaXB0IHN0eWxlIHRpdGxlJyk7XG4gICAgICBhZGQoJ3RpdGxlIGhyIG5vc2NyaXB0IGJyJyk7XG4gICAgICBhZGQoJ2Jhc2UnLCAnaHJlZiB0YXJnZXQnKTtcbiAgICAgIGFkZCgnbGluaycsICdocmVmIHJlbCBtZWRpYSBocmVmbGFuZyB0eXBlIHNpemVzIGhyZWZsYW5nJyk7XG4gICAgICBhZGQoJ21ldGEnLCAnbmFtZSBodHRwLWVxdWl2IGNvbnRlbnQgY2hhcnNldCcpO1xuICAgICAgYWRkKCdzdHlsZScsICdtZWRpYSB0eXBlIHNjb3BlZCcpO1xuICAgICAgYWRkKCdzY3JpcHQnLCAnc3JjIGFzeW5jIGRlZmVyIHR5cGUgY2hhcnNldCcpO1xuICAgICAgYWRkKCdib2R5JywgJ29uYWZ0ZXJwcmludCBvbmJlZm9yZXByaW50IG9uYmVmb3JldW5sb2FkIG9uYmx1ciBvbmVycm9yIG9uZm9jdXMgJyArICdvbmhhc2hjaGFuZ2Ugb25sb2FkIG9ubWVzc2FnZSBvbm9mZmxpbmUgb25vbmxpbmUgb25wYWdlaGlkZSBvbnBhZ2VzaG93ICcgKyAnb25wb3BzdGF0ZSBvbnJlc2l6ZSBvbnNjcm9sbCBvbnN0b3JhZ2Ugb251bmxvYWQnLCBmbG93Q29udGVudCk7XG4gICAgICBhZGQoJ2FkZHJlc3MgZHQgZGQgZGl2IGNhcHRpb24nLCAnJywgZmxvd0NvbnRlbnQpO1xuICAgICAgYWRkKCdoMSBoMiBoMyBoNCBoNSBoNiBwcmUgcCBhYmJyIGNvZGUgdmFyIHNhbXAga2JkIHN1YiBzdXAgaSBiIHUgYmRvIHNwYW4gbGVnZW5kIGVtIHN0cm9uZyBzbWFsbCBzIGNpdGUgZGZuJywgJycsIHBocmFzaW5nQ29udGVudCk7XG4gICAgICBhZGQoJ2Jsb2NrcXVvdGUnLCAnY2l0ZScsIGZsb3dDb250ZW50KTtcbiAgICAgIGFkZCgnb2wnLCAncmV2ZXJzZWQgc3RhcnQgdHlwZScsICdsaScpO1xuICAgICAgYWRkKCd1bCcsICcnLCAnbGknKTtcbiAgICAgIGFkZCgnbGknLCAndmFsdWUnLCBmbG93Q29udGVudCk7XG4gICAgICBhZGQoJ2RsJywgJycsICdkdCBkZCcpO1xuICAgICAgYWRkKCdhJywgJ2hyZWYgdGFyZ2V0IHJlbCBtZWRpYSBocmVmbGFuZyB0eXBlJywgcGhyYXNpbmdDb250ZW50KTtcbiAgICAgIGFkZCgncScsICdjaXRlJywgcGhyYXNpbmdDb250ZW50KTtcbiAgICAgIGFkZCgnaW5zIGRlbCcsICdjaXRlIGRhdGV0aW1lJywgZmxvd0NvbnRlbnQpO1xuICAgICAgYWRkKCdpbWcnLCAnc3JjIHNpemVzIHNyY3NldCBhbHQgdXNlbWFwIGlzbWFwIHdpZHRoIGhlaWdodCcpO1xuICAgICAgYWRkKCdpZnJhbWUnLCAnc3JjIG5hbWUgd2lkdGggaGVpZ2h0JywgZmxvd0NvbnRlbnQpO1xuICAgICAgYWRkKCdlbWJlZCcsICdzcmMgdHlwZSB3aWR0aCBoZWlnaHQnKTtcbiAgICAgIGFkZCgnb2JqZWN0JywgJ2RhdGEgdHlwZSB0eXBlbXVzdG1hdGNoIG5hbWUgdXNlbWFwIGZvcm0gd2lkdGggaGVpZ2h0JywgW1xuICAgICAgICBmbG93Q29udGVudCxcbiAgICAgICAgJ3BhcmFtJ1xuICAgICAgXS5qb2luKCcgJykpO1xuICAgICAgYWRkKCdwYXJhbScsICduYW1lIHZhbHVlJyk7XG4gICAgICBhZGQoJ21hcCcsICduYW1lJywgW1xuICAgICAgICBmbG93Q29udGVudCxcbiAgICAgICAgJ2FyZWEnXG4gICAgICBdLmpvaW4oJyAnKSk7XG4gICAgICBhZGQoJ2FyZWEnLCAnYWx0IGNvb3JkcyBzaGFwZSBocmVmIHRhcmdldCByZWwgbWVkaWEgaHJlZmxhbmcgdHlwZScpO1xuICAgICAgYWRkKCd0YWJsZScsICdib3JkZXInLCAnY2FwdGlvbiBjb2xncm91cCB0aGVhZCB0Zm9vdCB0Ym9keSB0cicgKyAodHlwZSA9PT0gJ2h0bWw0JyA/ICcgY29sJyA6ICcnKSk7XG4gICAgICBhZGQoJ2NvbGdyb3VwJywgJ3NwYW4nLCAnY29sJyk7XG4gICAgICBhZGQoJ2NvbCcsICdzcGFuJyk7XG4gICAgICBhZGQoJ3Rib2R5IHRoZWFkIHRmb290JywgJycsICd0cicpO1xuICAgICAgYWRkKCd0cicsICcnLCAndGQgdGgnKTtcbiAgICAgIGFkZCgndGQnLCAnY29sc3BhbiByb3dzcGFuIGhlYWRlcnMnLCBmbG93Q29udGVudCk7XG4gICAgICBhZGQoJ3RoJywgJ2NvbHNwYW4gcm93c3BhbiBoZWFkZXJzIHNjb3BlIGFiYnInLCBmbG93Q29udGVudCk7XG4gICAgICBhZGQoJ2Zvcm0nLCAnYWNjZXB0LWNoYXJzZXQgYWN0aW9uIGF1dG9jb21wbGV0ZSBlbmN0eXBlIG1ldGhvZCBuYW1lIG5vdmFsaWRhdGUgdGFyZ2V0JywgZmxvd0NvbnRlbnQpO1xuICAgICAgYWRkKCdmaWVsZHNldCcsICdkaXNhYmxlZCBmb3JtIG5hbWUnLCBbXG4gICAgICAgIGZsb3dDb250ZW50LFxuICAgICAgICAnbGVnZW5kJ1xuICAgICAgXS5qb2luKCcgJykpO1xuICAgICAgYWRkKCdsYWJlbCcsICdmb3JtIGZvcicsIHBocmFzaW5nQ29udGVudCk7XG4gICAgICBhZGQoJ2lucHV0JywgJ2FjY2VwdCBhbHQgYXV0b2NvbXBsZXRlIGNoZWNrZWQgZGlybmFtZSBkaXNhYmxlZCBmb3JtIGZvcm1hY3Rpb24gZm9ybWVuY3R5cGUgZm9ybW1ldGhvZCBmb3Jtbm92YWxpZGF0ZSAnICsgJ2Zvcm10YXJnZXQgaGVpZ2h0IGxpc3QgbWF4IG1heGxlbmd0aCBtaW4gbXVsdGlwbGUgbmFtZSBwYXR0ZXJuIHJlYWRvbmx5IHJlcXVpcmVkIHNpemUgc3JjIHN0ZXAgdHlwZSB2YWx1ZSB3aWR0aCcpO1xuICAgICAgYWRkKCdidXR0b24nLCAnZGlzYWJsZWQgZm9ybSBmb3JtYWN0aW9uIGZvcm1lbmN0eXBlIGZvcm1tZXRob2QgZm9ybW5vdmFsaWRhdGUgZm9ybXRhcmdldCBuYW1lIHR5cGUgdmFsdWUnLCB0eXBlID09PSAnaHRtbDQnID8gZmxvd0NvbnRlbnQgOiBwaHJhc2luZ0NvbnRlbnQpO1xuICAgICAgYWRkKCdzZWxlY3QnLCAnZGlzYWJsZWQgZm9ybSBtdWx0aXBsZSBuYW1lIHJlcXVpcmVkIHNpemUnLCAnb3B0aW9uIG9wdGdyb3VwJyk7XG4gICAgICBhZGQoJ29wdGdyb3VwJywgJ2Rpc2FibGVkIGxhYmVsJywgJ29wdGlvbicpO1xuICAgICAgYWRkKCdvcHRpb24nLCAnZGlzYWJsZWQgbGFiZWwgc2VsZWN0ZWQgdmFsdWUnKTtcbiAgICAgIGFkZCgndGV4dGFyZWEnLCAnY29scyBkaXJuYW1lIGRpc2FibGVkIGZvcm0gbWF4bGVuZ3RoIG5hbWUgcmVhZG9ubHkgcmVxdWlyZWQgcm93cyB3cmFwJyk7XG4gICAgICBhZGQoJ21lbnUnLCAndHlwZSBsYWJlbCcsIFtcbiAgICAgICAgZmxvd0NvbnRlbnQsXG4gICAgICAgICdsaSdcbiAgICAgIF0uam9pbignICcpKTtcbiAgICAgIGFkZCgnbm9zY3JpcHQnLCAnJywgZmxvd0NvbnRlbnQpO1xuICAgICAgaWYgKHR5cGUgIT09ICdodG1sNCcpIHtcbiAgICAgICAgYWRkKCd3YnInKTtcbiAgICAgICAgYWRkKCdydWJ5JywgJycsIFtcbiAgICAgICAgICBwaHJhc2luZ0NvbnRlbnQsXG4gICAgICAgICAgJ3J0IHJwJ1xuICAgICAgICBdLmpvaW4oJyAnKSk7XG4gICAgICAgIGFkZCgnZmlnY2FwdGlvbicsICcnLCBmbG93Q29udGVudCk7XG4gICAgICAgIGFkZCgnbWFyayBydCBycCBzdW1tYXJ5IGJkaScsICcnLCBwaHJhc2luZ0NvbnRlbnQpO1xuICAgICAgICBhZGQoJ2NhbnZhcycsICd3aWR0aCBoZWlnaHQnLCBmbG93Q29udGVudCk7XG4gICAgICAgIGFkZCgndmlkZW8nLCAnc3JjIGNyb3Nzb3JpZ2luIHBvc3RlciBwcmVsb2FkIGF1dG9wbGF5IG1lZGlhZ3JvdXAgbG9vcCAnICsgJ211dGVkIGNvbnRyb2xzIHdpZHRoIGhlaWdodCBidWZmZXJlZCcsIFtcbiAgICAgICAgICBmbG93Q29udGVudCxcbiAgICAgICAgICAndHJhY2sgc291cmNlJ1xuICAgICAgICBdLmpvaW4oJyAnKSk7XG4gICAgICAgIGFkZCgnYXVkaW8nLCAnc3JjIGNyb3Nzb3JpZ2luIHByZWxvYWQgYXV0b3BsYXkgbWVkaWFncm91cCBsb29wIG11dGVkIGNvbnRyb2xzICcgKyAnYnVmZmVyZWQgdm9sdW1lJywgW1xuICAgICAgICAgIGZsb3dDb250ZW50LFxuICAgICAgICAgICd0cmFjayBzb3VyY2UnXG4gICAgICAgIF0uam9pbignICcpKTtcbiAgICAgICAgYWRkKCdwaWN0dXJlJywgJycsICdpbWcgc291cmNlJyk7XG4gICAgICAgIGFkZCgnc291cmNlJywgJ3NyYyBzcmNzZXQgdHlwZSBtZWRpYSBzaXplcycpO1xuICAgICAgICBhZGQoJ3RyYWNrJywgJ2tpbmQgc3JjIHNyY2xhbmcgbGFiZWwgZGVmYXVsdCcpO1xuICAgICAgICBhZGQoJ2RhdGFsaXN0JywgJycsIFtcbiAgICAgICAgICBwaHJhc2luZ0NvbnRlbnQsXG4gICAgICAgICAgJ29wdGlvbidcbiAgICAgICAgXS5qb2luKCcgJykpO1xuICAgICAgICBhZGQoJ2FydGljbGUgc2VjdGlvbiBuYXYgYXNpZGUgbWFpbiBoZWFkZXIgZm9vdGVyJywgJycsIGZsb3dDb250ZW50KTtcbiAgICAgICAgYWRkKCdoZ3JvdXAnLCAnJywgJ2gxIGgyIGgzIGg0IGg1IGg2Jyk7XG4gICAgICAgIGFkZCgnZmlndXJlJywgJycsIFtcbiAgICAgICAgICBmbG93Q29udGVudCxcbiAgICAgICAgICAnZmlnY2FwdGlvbidcbiAgICAgICAgXS5qb2luKCcgJykpO1xuICAgICAgICBhZGQoJ3RpbWUnLCAnZGF0ZXRpbWUnLCBwaHJhc2luZ0NvbnRlbnQpO1xuICAgICAgICBhZGQoJ2RpYWxvZycsICdvcGVuJywgZmxvd0NvbnRlbnQpO1xuICAgICAgICBhZGQoJ2NvbW1hbmQnLCAndHlwZSBsYWJlbCBpY29uIGRpc2FibGVkIGNoZWNrZWQgcmFkaW9ncm91cCBjb21tYW5kJyk7XG4gICAgICAgIGFkZCgnb3V0cHV0JywgJ2ZvciBmb3JtIG5hbWUnLCBwaHJhc2luZ0NvbnRlbnQpO1xuICAgICAgICBhZGQoJ3Byb2dyZXNzJywgJ3ZhbHVlIG1heCcsIHBocmFzaW5nQ29udGVudCk7XG4gICAgICAgIGFkZCgnbWV0ZXInLCAndmFsdWUgbWluIG1heCBsb3cgaGlnaCBvcHRpbXVtJywgcGhyYXNpbmdDb250ZW50KTtcbiAgICAgICAgYWRkKCdkZXRhaWxzJywgJ29wZW4nLCBbXG4gICAgICAgICAgZmxvd0NvbnRlbnQsXG4gICAgICAgICAgJ3N1bW1hcnknXG4gICAgICAgIF0uam9pbignICcpKTtcbiAgICAgICAgYWRkKCdrZXlnZW4nLCAnYXV0b2ZvY3VzIGNoYWxsZW5nZSBkaXNhYmxlZCBmb3JtIGtleXR5cGUgbmFtZScpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgIT09ICdodG1sNS1zdHJpY3QnKSB7XG4gICAgICAgIGFkZEF0dHJzKCdzY3JpcHQnLCAnbGFuZ3VhZ2UgeG1sOnNwYWNlJyk7XG4gICAgICAgIGFkZEF0dHJzKCdzdHlsZScsICd4bWw6c3BhY2UnKTtcbiAgICAgICAgYWRkQXR0cnMoJ29iamVjdCcsICdkZWNsYXJlIGNsYXNzaWQgY29kZSBjb2RlYmFzZSBjb2RldHlwZSBhcmNoaXZlIHN0YW5kYnkgYWxpZ24gYm9yZGVyIGhzcGFjZSB2c3BhY2UnKTtcbiAgICAgICAgYWRkQXR0cnMoJ2VtYmVkJywgJ2FsaWduIG5hbWUgaHNwYWNlIHZzcGFjZScpO1xuICAgICAgICBhZGRBdHRycygncGFyYW0nLCAndmFsdWV0eXBlIHR5cGUnKTtcbiAgICAgICAgYWRkQXR0cnMoJ2EnLCAnY2hhcnNldCBuYW1lIHJldiBzaGFwZSBjb29yZHMnKTtcbiAgICAgICAgYWRkQXR0cnMoJ2JyJywgJ2NsZWFyJyk7XG4gICAgICAgIGFkZEF0dHJzKCdhcHBsZXQnLCAnY29kZWJhc2UgYXJjaGl2ZSBjb2RlIG9iamVjdCBhbHQgbmFtZSB3aWR0aCBoZWlnaHQgYWxpZ24gaHNwYWNlIHZzcGFjZScpO1xuICAgICAgICBhZGRBdHRycygnaW1nJywgJ25hbWUgbG9uZ2Rlc2MgYWxpZ24gYm9yZGVyIGhzcGFjZSB2c3BhY2UnKTtcbiAgICAgICAgYWRkQXR0cnMoJ2lmcmFtZScsICdsb25nZGVzYyBmcmFtZWJvcmRlciBtYXJnaW53aWR0aCBtYXJnaW5oZWlnaHQgc2Nyb2xsaW5nIGFsaWduJyk7XG4gICAgICAgIGFkZEF0dHJzKCdmb250IGJhc2Vmb250JywgJ3NpemUgY29sb3IgZmFjZScpO1xuICAgICAgICBhZGRBdHRycygnaW5wdXQnLCAndXNlbWFwIGFsaWduJyk7XG4gICAgICAgIGFkZEF0dHJzKCdzZWxlY3QnKTtcbiAgICAgICAgYWRkQXR0cnMoJ3RleHRhcmVhJyk7XG4gICAgICAgIGFkZEF0dHJzKCdoMSBoMiBoMyBoNCBoNSBoNiBkaXYgcCBsZWdlbmQgY2FwdGlvbicsICdhbGlnbicpO1xuICAgICAgICBhZGRBdHRycygndWwnLCAndHlwZSBjb21wYWN0Jyk7XG4gICAgICAgIGFkZEF0dHJzKCdsaScsICd0eXBlJyk7XG4gICAgICAgIGFkZEF0dHJzKCdvbCBkbCBtZW51IGRpcicsICdjb21wYWN0Jyk7XG4gICAgICAgIGFkZEF0dHJzKCdwcmUnLCAnd2lkdGggeG1sOnNwYWNlJyk7XG4gICAgICAgIGFkZEF0dHJzKCdocicsICdhbGlnbiBub3NoYWRlIHNpemUgd2lkdGgnKTtcbiAgICAgICAgYWRkQXR0cnMoJ2lzaW5kZXgnLCAncHJvbXB0Jyk7XG4gICAgICAgIGFkZEF0dHJzKCd0YWJsZScsICdzdW1tYXJ5IHdpZHRoIGZyYW1lIHJ1bGVzIGNlbGxzcGFjaW5nIGNlbGxwYWRkaW5nIGFsaWduIGJnY29sb3InKTtcbiAgICAgICAgYWRkQXR0cnMoJ2NvbCcsICd3aWR0aCBhbGlnbiBjaGFyIGNoYXJvZmYgdmFsaWduJyk7XG4gICAgICAgIGFkZEF0dHJzKCdjb2xncm91cCcsICd3aWR0aCBhbGlnbiBjaGFyIGNoYXJvZmYgdmFsaWduJyk7XG4gICAgICAgIGFkZEF0dHJzKCd0aGVhZCcsICdhbGlnbiBjaGFyIGNoYXJvZmYgdmFsaWduJyk7XG4gICAgICAgIGFkZEF0dHJzKCd0cicsICdhbGlnbiBjaGFyIGNoYXJvZmYgdmFsaWduIGJnY29sb3InKTtcbiAgICAgICAgYWRkQXR0cnMoJ3RoJywgJ2F4aXMgYWxpZ24gY2hhciBjaGFyb2ZmIHZhbGlnbiBub3dyYXAgYmdjb2xvciB3aWR0aCBoZWlnaHQnKTtcbiAgICAgICAgYWRkQXR0cnMoJ2Zvcm0nLCAnYWNjZXB0Jyk7XG4gICAgICAgIGFkZEF0dHJzKCd0ZCcsICdhYmJyIGF4aXMgc2NvcGUgYWxpZ24gY2hhciBjaGFyb2ZmIHZhbGlnbiBub3dyYXAgYmdjb2xvciB3aWR0aCBoZWlnaHQnKTtcbiAgICAgICAgYWRkQXR0cnMoJ3Rmb290JywgJ2FsaWduIGNoYXIgY2hhcm9mZiB2YWxpZ24nKTtcbiAgICAgICAgYWRkQXR0cnMoJ3Rib2R5JywgJ2FsaWduIGNoYXIgY2hhcm9mZiB2YWxpZ24nKTtcbiAgICAgICAgYWRkQXR0cnMoJ2FyZWEnLCAnbm9ocmVmJyk7XG4gICAgICAgIGFkZEF0dHJzKCdib2R5JywgJ2JhY2tncm91bmQgYmdjb2xvciB0ZXh0IGxpbmsgdmxpbmsgYWxpbmsnKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlICE9PSAnaHRtbDQnKSB7XG4gICAgICAgIGFkZEF0dHJzKCdpbnB1dCBidXR0b24gc2VsZWN0IHRleHRhcmVhJywgJ2F1dG9mb2N1cycpO1xuICAgICAgICBhZGRBdHRycygnaW5wdXQgdGV4dGFyZWEnLCAncGxhY2Vob2xkZXInKTtcbiAgICAgICAgYWRkQXR0cnMoJ2EnLCAnZG93bmxvYWQnKTtcbiAgICAgICAgYWRkQXR0cnMoJ2xpbmsgc2NyaXB0IGltZycsICdjcm9zc29yaWdpbicpO1xuICAgICAgICBhZGRBdHRycygnaW1nJywgJ2xvYWRpbmcnKTtcbiAgICAgICAgYWRkQXR0cnMoJ2lmcmFtZScsICdzYW5kYm94IHNlYW1sZXNzIGFsbG93ZnVsbHNjcmVlbiBsb2FkaW5nJyk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSAhPT0gJ2h0bWw0Jykge1xuICAgICAgICBlYWNoJGcoW1xuICAgICAgICAgIHNjaGVtYS52aWRlbyxcbiAgICAgICAgICBzY2hlbWEuYXVkaW9cbiAgICAgICAgXSwgaXRlbSA9PiB7XG4gICAgICAgICAgZGVsZXRlIGl0ZW0uY2hpbGRyZW4uYXVkaW87XG4gICAgICAgICAgZGVsZXRlIGl0ZW0uY2hpbGRyZW4udmlkZW87XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZWFjaCRkKHNwbGl0JDEoJ2EgZm9ybSBtZXRlciBwcm9ncmVzcyBkZm4nKSwgbmFtZSA9PiB7XG4gICAgICAgIGlmIChzY2hlbWFbbmFtZV0pIHtcbiAgICAgICAgICBkZWxldGUgc2NoZW1hW25hbWVdLmNoaWxkcmVuW25hbWVdO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGRlbGV0ZSBzY2hlbWEuY2FwdGlvbi5jaGlsZHJlbi50YWJsZTtcbiAgICAgIGRlbGV0ZSBzY2hlbWEuc2NyaXB0O1xuICAgICAgbWFwQ2FjaGVbdHlwZV0gPSBzY2hlbWE7XG4gICAgICByZXR1cm4gc2NoZW1hO1xuICAgIH07XG4gICAgY29uc3QgY29tcGlsZUVsZW1lbnRNYXAgPSAodmFsdWUsIG1vZGUpID0+IHtcbiAgICAgIGxldCBzdHlsZXM7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgc3R5bGVzID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdmFsdWUgPSB7ICcqJzogdmFsdWUgfTtcbiAgICAgICAgfVxuICAgICAgICBlYWNoJGQodmFsdWUsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgc3R5bGVzW2tleV0gPSBzdHlsZXNba2V5LnRvVXBwZXJDYXNlKCldID0gbW9kZSA9PT0gJ21hcCcgPyBtYWtlTWFwJDIodmFsdWUsIC9bLCBdLykgOiBleHBsb2RlJDIodmFsdWUsIC9bLCBdLyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0eWxlcztcbiAgICB9O1xuICAgIGNvbnN0IFNjaGVtYSA9IHNldHRpbmdzID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IGVsZW1lbnRzID0ge307XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IHt9O1xuICAgICAgbGV0IHBhdHRlcm5FbGVtZW50cyA9IFtdO1xuICAgICAgY29uc3QgY3VzdG9tRWxlbWVudHNNYXAgPSB7fSwgc3BlY2lhbEVsZW1lbnRzID0ge307XG4gICAgICBjb25zdCBjcmVhdGVMb29rdXBUYWJsZSA9IChvcHRpb24sIGRlZmF1bHRWYWx1ZSwgZXh0ZW5kV2l0aCkgPT4ge1xuICAgICAgICBsZXQgdmFsdWUgPSBzZXR0aW5nc1tvcHRpb25dO1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgdmFsdWUgPSBtYXBDYWNoZVtvcHRpb25dO1xuICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHZhbHVlID0gY3JlYXRlTWFwKGRlZmF1bHRWYWx1ZSwgZXh0ZW5kV2l0aCk7XG4gICAgICAgICAgICBtYXBDYWNoZVtvcHRpb25dID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gbWFrZU1hcCQyKHZhbHVlLCAvWywgXS8sIG1ha2VNYXAkMih2YWx1ZS50b1VwcGVyQ2FzZSgpLCAvWywgXS8pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9O1xuICAgICAgc2V0dGluZ3MgPSBzZXR0aW5ncyB8fCB7fTtcbiAgICAgIGNvbnN0IHNjaGVtYVR5cGUgPSAoX2EgPSBzZXR0aW5ncy5zY2hlbWEpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICdodG1sNSc7XG4gICAgICBjb25zdCBzY2hlbWFJdGVtcyA9IGNvbXBpbGVTY2hlbWEoc2NoZW1hVHlwZSk7XG4gICAgICBpZiAoc2V0dGluZ3MudmVyaWZ5X2h0bWwgPT09IGZhbHNlKSB7XG4gICAgICAgIHNldHRpbmdzLnZhbGlkX2VsZW1lbnRzID0gJypbKl0nO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsaWRTdHlsZXMgPSBjb21waWxlRWxlbWVudE1hcChzZXR0aW5ncy52YWxpZF9zdHlsZXMpO1xuICAgICAgY29uc3QgaW52YWxpZFN0eWxlcyA9IGNvbXBpbGVFbGVtZW50TWFwKHNldHRpbmdzLmludmFsaWRfc3R5bGVzLCAnbWFwJyk7XG4gICAgICBjb25zdCB2YWxpZENsYXNzZXMgPSBjb21waWxlRWxlbWVudE1hcChzZXR0aW5ncy52YWxpZF9jbGFzc2VzLCAnbWFwJyk7XG4gICAgICBjb25zdCB3aGl0ZXNwYWNlRWxlbWVudHNNYXAgPSBjcmVhdGVMb29rdXBUYWJsZSgnd2hpdGVzcGFjZV9lbGVtZW50cycsICdwcmUgc2NyaXB0IG5vc2NyaXB0IHN0eWxlIHRleHRhcmVhIHZpZGVvIGF1ZGlvIGlmcmFtZSBvYmplY3QgY29kZScpO1xuICAgICAgY29uc3Qgc2VsZkNsb3NpbmdFbGVtZW50c01hcCA9IGNyZWF0ZUxvb2t1cFRhYmxlKCdzZWxmX2Nsb3NpbmdfZWxlbWVudHMnLCAnY29sZ3JvdXAgZGQgZHQgbGkgb3B0aW9uIHAgdGQgdGZvb3QgdGggdGhlYWQgdHInKTtcbiAgICAgIGNvbnN0IHZvaWRFbGVtZW50c01hcCA9IGNyZWF0ZUxvb2t1cFRhYmxlKCd2b2lkX2VsZW1lbnRzJywgJ2FyZWEgYmFzZSBiYXNlZm9udCBiciBjb2wgZnJhbWUgaHIgaW1nIGlucHV0IGlzaW5kZXggbGluayAnICsgJ21ldGEgcGFyYW0gZW1iZWQgc291cmNlIHdiciB0cmFjaycpO1xuICAgICAgY29uc3QgYm9vbEF0dHJNYXAgPSBjcmVhdGVMb29rdXBUYWJsZSgnYm9vbGVhbl9hdHRyaWJ1dGVzJywgJ2NoZWNrZWQgY29tcGFjdCBkZWNsYXJlIGRlZmVyIGRpc2FibGVkIGlzbWFwIG11bHRpcGxlIG5vaHJlZiBub3Jlc2l6ZSAnICsgJ25vc2hhZGUgbm93cmFwIHJlYWRvbmx5IHNlbGVjdGVkIGF1dG9wbGF5IGxvb3AgY29udHJvbHMgYWxsb3dmdWxsc2NyZWVuJyk7XG4gICAgICBjb25zdCBub25FbXB0eU9yTW92ZUNhcmV0QmVmb3JlT25FbnRlciA9ICd0ZCB0aCBpZnJhbWUgdmlkZW8gYXVkaW8gb2JqZWN0IHNjcmlwdCBjb2RlJztcbiAgICAgIGNvbnN0IG5vbkVtcHR5RWxlbWVudHNNYXAgPSBjcmVhdGVMb29rdXBUYWJsZSgnbm9uX2VtcHR5X2VsZW1lbnRzJywgbm9uRW1wdHlPck1vdmVDYXJldEJlZm9yZU9uRW50ZXIgKyAnIHByZScsIHZvaWRFbGVtZW50c01hcCk7XG4gICAgICBjb25zdCBtb3ZlQ2FyZXRCZWZvcmVPbkVudGVyRWxlbWVudHNNYXAgPSBjcmVhdGVMb29rdXBUYWJsZSgnbW92ZV9jYXJldF9iZWZvcmVfb25fZW50ZXJfZWxlbWVudHMnLCBub25FbXB0eU9yTW92ZUNhcmV0QmVmb3JlT25FbnRlciArICcgdGFibGUnLCB2b2lkRWxlbWVudHNNYXApO1xuICAgICAgY29uc3QgdGV4dEJsb2NrRWxlbWVudHNNYXAgPSBjcmVhdGVMb29rdXBUYWJsZSgndGV4dF9ibG9ja19lbGVtZW50cycsICdoMSBoMiBoMyBoNCBoNSBoNiBwIGRpdiBhZGRyZXNzIHByZSBmb3JtICcgKyAnYmxvY2txdW90ZSBjZW50ZXIgZGlyIGZpZWxkc2V0IGhlYWRlciBmb290ZXIgYXJ0aWNsZSBzZWN0aW9uIGhncm91cCBhc2lkZSBtYWluIG5hdiBmaWd1cmUnKTtcbiAgICAgIGNvbnN0IGJsb2NrRWxlbWVudHNNYXAgPSBjcmVhdGVMb29rdXBUYWJsZSgnYmxvY2tfZWxlbWVudHMnLCAnaHIgdGFibGUgdGJvZHkgdGhlYWQgdGZvb3QgJyArICd0aCB0ciB0ZCBsaSBvbCB1bCBjYXB0aW9uIGRsIGR0IGRkIG5vc2NyaXB0IG1lbnUgaXNpbmRleCBvcHRpb24gJyArICdkYXRhbGlzdCBzZWxlY3Qgb3B0Z3JvdXAgZmlnY2FwdGlvbiBkZXRhaWxzIHN1bW1hcnknLCB0ZXh0QmxvY2tFbGVtZW50c01hcCk7XG4gICAgICBjb25zdCB0ZXh0SW5saW5lRWxlbWVudHNNYXAgPSBjcmVhdGVMb29rdXBUYWJsZSgndGV4dF9pbmxpbmVfZWxlbWVudHMnLCAnc3BhbiBzdHJvbmcgYiBlbSBpIGZvbnQgcyBzdHJpa2UgdSB2YXIgY2l0ZSAnICsgJ2RmbiBjb2RlIG1hcmsgcSBzdXAgc3ViIHNhbXAnKTtcbiAgICAgIGVhY2gkZCgnc2NyaXB0IG5vc2NyaXB0IGlmcmFtZSBub2ZyYW1lcyBub2VtYmVkIHRpdGxlIHN0eWxlIHRleHRhcmVhIHhtcCBwbGFpbnRleHQnLnNwbGl0KCcgJyksIG5hbWUgPT4ge1xuICAgICAgICBzcGVjaWFsRWxlbWVudHNbbmFtZV0gPSBuZXcgUmVnRXhwKCc8LycgKyBuYW1lICsgJ1tePl0qPicsICdnaScpO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBwYXR0ZXJuVG9SZWdFeHAgPSBzdHIgPT4gbmV3IFJlZ0V4cCgnXicgKyBzdHIucmVwbGFjZSgvKFs/KypdKS9nLCAnLiQxJykgKyAnJCcpO1xuICAgICAgY29uc3QgYWRkVmFsaWRFbGVtZW50cyA9IHZhbGlkRWxlbWVudHMgPT4ge1xuICAgICAgICBsZXQgZWksIGVsLCBhaSwgYWwsIG1hdGNoZXMsIGVsZW1lbnQsIGF0dHIsIGF0dHJEYXRhLCBlbGVtZW50TmFtZSwgYXR0ck5hbWUsIGF0dHJUeXBlLCBhdHRyaWJ1dGVzLCBhdHRyaWJ1dGVzT3JkZXIsIHByZWZpeCwgb3V0cHV0TmFtZSwgZ2xvYmFsQXR0cmlidXRlcywgZ2xvYmFsQXR0cmlidXRlc09yZGVyLCB2YWx1ZTtcbiAgICAgICAgY29uc3QgZWxlbWVudFJ1bGVSZWdFeHAgPSAvXihbIytcXC1dKT8oW15cXFshXFwvXSspKD86XFwvKFteXFxbIV0rKSk/KD86KCE/KVxcWyhbXlxcXV0rKV0pPyQvLCBhdHRyUnVsZVJlZ0V4cCA9IC9eKFshXFwtXSk/KFxcdytbXFxcXDpdOlxcdyt8W149fjxdKyk/KD86KFs9fjxdKSguKikpPyQvLCBoYXNQYXR0ZXJuc1JlZ0V4cCA9IC9bKj8rXS87XG4gICAgICAgIGlmICh2YWxpZEVsZW1lbnRzKSB7XG4gICAgICAgICAgY29uc3QgdmFsaWRFbGVtZW50c0FyciA9IHNwbGl0JDEodmFsaWRFbGVtZW50cywgJywnKTtcbiAgICAgICAgICBpZiAoZWxlbWVudHNbJ0AnXSkge1xuICAgICAgICAgICAgZ2xvYmFsQXR0cmlidXRlcyA9IGVsZW1lbnRzWydAJ10uYXR0cmlidXRlcztcbiAgICAgICAgICAgIGdsb2JhbEF0dHJpYnV0ZXNPcmRlciA9IGVsZW1lbnRzWydAJ10uYXR0cmlidXRlc09yZGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGVpID0gMCwgZWwgPSB2YWxpZEVsZW1lbnRzQXJyLmxlbmd0aDsgZWkgPCBlbDsgZWkrKykge1xuICAgICAgICAgICAgbWF0Y2hlcyA9IGVsZW1lbnRSdWxlUmVnRXhwLmV4ZWModmFsaWRFbGVtZW50c0FycltlaV0pO1xuICAgICAgICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgcHJlZml4ID0gbWF0Y2hlc1sxXTtcbiAgICAgICAgICAgICAgZWxlbWVudE5hbWUgPSBtYXRjaGVzWzJdO1xuICAgICAgICAgICAgICBvdXRwdXROYW1lID0gbWF0Y2hlc1szXTtcbiAgICAgICAgICAgICAgYXR0ckRhdGEgPSBtYXRjaGVzWzVdO1xuICAgICAgICAgICAgICBhdHRyaWJ1dGVzID0ge307XG4gICAgICAgICAgICAgIGF0dHJpYnV0ZXNPcmRlciA9IFtdO1xuICAgICAgICAgICAgICBlbGVtZW50ID0ge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlc09yZGVyXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGlmIChwcmVmaXggPT09ICcjJykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQucGFkZEVtcHR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocHJlZml4ID09PSAnLScpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZUVtcHR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobWF0Y2hlc1s0XSA9PT0gJyEnKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVFbXB0eUF0dHJzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZ2xvYmFsQXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgIGVhY2gkZihnbG9iYWxBdHRyaWJ1dGVzLCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlc09yZGVyLnB1c2guYXBwbHkoYXR0cmlidXRlc09yZGVyLCBnbG9iYWxBdHRyaWJ1dGVzT3JkZXIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChhdHRyRGF0YSkge1xuICAgICAgICAgICAgICAgIGF0dHJEYXRhID0gc3BsaXQkMShhdHRyRGF0YSwgJ3wnKTtcbiAgICAgICAgICAgICAgICBmb3IgKGFpID0gMCwgYWwgPSBhdHRyRGF0YS5sZW5ndGg7IGFpIDwgYWw7IGFpKyspIHtcbiAgICAgICAgICAgICAgICAgIG1hdGNoZXMgPSBhdHRyUnVsZVJlZ0V4cC5leGVjKGF0dHJEYXRhW2FpXSk7XG4gICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICAgICAgICAgICAgICBhdHRyID0ge307XG4gICAgICAgICAgICAgICAgICAgIGF0dHJUeXBlID0gbWF0Y2hlc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgYXR0ck5hbWUgPSBtYXRjaGVzWzJdLnJlcGxhY2UoL1tcXFxcOl06L2csICc6Jyk7XG4gICAgICAgICAgICAgICAgICAgIHByZWZpeCA9IG1hdGNoZXNbM107XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbWF0Y2hlc1s0XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHJUeXBlID09PSAnIScpIHtcbiAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmF0dHJpYnV0ZXNSZXF1aXJlZCA9IGVsZW1lbnQuYXR0cmlidXRlc1JlcXVpcmVkIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuYXR0cmlidXRlc1JlcXVpcmVkLnB1c2goYXR0ck5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgIGF0dHIucmVxdWlyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChhdHRyVHlwZSA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGF0dHJpYnV0ZXNbYXR0ck5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNPcmRlci5zcGxpY2UoaW5BcnJheShhdHRyaWJ1dGVzT3JkZXIsIGF0dHJOYW1lKSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZWZpeCkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmVmaXggPT09ICc9Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5hdHRyaWJ1dGVzRGVmYXVsdCA9IGVsZW1lbnQuYXR0cmlidXRlc0RlZmF1bHQgfHwgW107XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmF0dHJpYnV0ZXNEZWZhdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBhdHRyTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0ci5kZWZhdWx0VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHByZWZpeCA9PT0gJ34nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmF0dHJpYnV0ZXNGb3JjZWQgPSBlbGVtZW50LmF0dHJpYnV0ZXNGb3JjZWQgfHwgW107XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmF0dHJpYnV0ZXNGb3JjZWQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGF0dHJOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyLmZvcmNlZFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmVmaXggPT09ICc8Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0ci52YWxpZFZhbHVlcyA9IG1ha2VNYXAkMih2YWx1ZSwgJz8nKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc1BhdHRlcm5zUmVnRXhwLnRlc3QoYXR0ck5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5hdHRyaWJ1dGVQYXR0ZXJucyA9IGVsZW1lbnQuYXR0cmlidXRlUGF0dGVybnMgfHwgW107XG4gICAgICAgICAgICAgICAgICAgICAgYXR0ci5wYXR0ZXJuID0gcGF0dGVyblRvUmVnRXhwKGF0dHJOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmF0dHJpYnV0ZVBhdHRlcm5zLnB1c2goYXR0cik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCFhdHRyaWJ1dGVzW2F0dHJOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlc09yZGVyLnB1c2goYXR0ck5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzW2F0dHJOYW1lXSA9IGF0dHI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFnbG9iYWxBdHRyaWJ1dGVzICYmIGVsZW1lbnROYW1lID09PSAnQCcpIHtcbiAgICAgICAgICAgICAgICBnbG9iYWxBdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbiAgICAgICAgICAgICAgICBnbG9iYWxBdHRyaWJ1dGVzT3JkZXIgPSBhdHRyaWJ1dGVzT3JkZXI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG91dHB1dE5hbWUpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50Lm91dHB1dE5hbWUgPSBlbGVtZW50TmFtZTtcbiAgICAgICAgICAgICAgICBlbGVtZW50c1tvdXRwdXROYW1lXSA9IGVsZW1lbnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGhhc1BhdHRlcm5zUmVnRXhwLnRlc3QoZWxlbWVudE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5wYXR0ZXJuID0gcGF0dGVyblRvUmVnRXhwKGVsZW1lbnROYW1lKTtcbiAgICAgICAgICAgICAgICBwYXR0ZXJuRWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50c1tlbGVtZW50TmFtZV0gPSBlbGVtZW50O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3Qgc2V0VmFsaWRFbGVtZW50cyA9IHZhbGlkRWxlbWVudHMgPT4ge1xuICAgICAgICBwYXR0ZXJuRWxlbWVudHMgPSBbXTtcbiAgICAgICAgZWFjaCRnKGtleXMoZWxlbWVudHMpLCBuYW1lID0+IHtcbiAgICAgICAgICBkZWxldGUgZWxlbWVudHNbbmFtZV07XG4gICAgICAgIH0pO1xuICAgICAgICBhZGRWYWxpZEVsZW1lbnRzKHZhbGlkRWxlbWVudHMpO1xuICAgICAgICBlYWNoJGQoc2NoZW1hSXRlbXMsIChlbGVtZW50LCBuYW1lKSA9PiB7XG4gICAgICAgICAgY2hpbGRyZW5bbmFtZV0gPSBlbGVtZW50LmNoaWxkcmVuO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBjb25zdCBhZGRDdXN0b21FbGVtZW50cyA9IGN1c3RvbUVsZW1lbnRzID0+IHtcbiAgICAgICAgY29uc3QgY3VzdG9tRWxlbWVudFJlZ0V4cCA9IC9eKH4pPyguKykkLztcbiAgICAgICAgaWYgKGN1c3RvbUVsZW1lbnRzKSB7XG4gICAgICAgICAgbWFwQ2FjaGUudGV4dF9ibG9ja19lbGVtZW50cyA9IG1hcENhY2hlLmJsb2NrX2VsZW1lbnRzID0gbnVsbDtcbiAgICAgICAgICBlYWNoJGQoc3BsaXQkMShjdXN0b21FbGVtZW50cywgJywnKSwgcnVsZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGVzID0gY3VzdG9tRWxlbWVudFJlZ0V4cC5leGVjKHJ1bGUpLCBpbmxpbmUgPSBtYXRjaGVzWzFdID09PSAnficsIGNsb25lTmFtZSA9IGlubGluZSA/ICdzcGFuJyA6ICdkaXYnLCBuYW1lID0gbWF0Y2hlc1syXTtcbiAgICAgICAgICAgIGNoaWxkcmVuW25hbWVdID0gY2hpbGRyZW5bY2xvbmVOYW1lXTtcbiAgICAgICAgICAgIGN1c3RvbUVsZW1lbnRzTWFwW25hbWVdID0gY2xvbmVOYW1lO1xuICAgICAgICAgICAgaWYgKCFpbmxpbmUpIHtcbiAgICAgICAgICAgICAgYmxvY2tFbGVtZW50c01hcFtuYW1lLnRvVXBwZXJDYXNlKCldID0ge307XG4gICAgICAgICAgICAgIGJsb2NrRWxlbWVudHNNYXBbbmFtZV0gPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZWxlbWVudHNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgbGV0IGN1c3RvbVJ1bGUgPSBlbGVtZW50c1tjbG9uZU5hbWVdO1xuICAgICAgICAgICAgICBjdXN0b21SdWxlID0gZXh0ZW5kJDIoe30sIGN1c3RvbVJ1bGUpO1xuICAgICAgICAgICAgICBkZWxldGUgY3VzdG9tUnVsZS5yZW1vdmVFbXB0eUF0dHJzO1xuICAgICAgICAgICAgICBkZWxldGUgY3VzdG9tUnVsZS5yZW1vdmVFbXB0eTtcbiAgICAgICAgICAgICAgZWxlbWVudHNbbmFtZV0gPSBjdXN0b21SdWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWFjaCRkKGNoaWxkcmVuLCAoZWxlbWVudCwgZWxtTmFtZSkgPT4ge1xuICAgICAgICAgICAgICBpZiAoZWxlbWVudFtjbG9uZU5hbWVdKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW5bZWxtTmFtZV0gPSBlbGVtZW50ID0gZXh0ZW5kJDIoe30sIGNoaWxkcmVuW2VsbU5hbWVdKTtcbiAgICAgICAgICAgICAgICBlbGVtZW50W25hbWVdID0gZWxlbWVudFtjbG9uZU5hbWVdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGFkZFZhbGlkQ2hpbGRyZW4gPSB2YWxpZENoaWxkcmVuID0+IHtcbiAgICAgICAgY29uc3QgY2hpbGRSdWxlUmVnRXhwID0gL14oWytcXC1dPykoW0EtWmEtejAtOV9cXC0uXFx1MDBiN1xcdTAwYzAtXFx1MDBkNlxcdTAwZDgtXFx1MDBmNlxcdTAwZjgtXFx1MDM3ZFxcdTAzN2YtXFx1MWZmZlxcdTIwMGMtXFx1MjAwZFxcdTIwM2YtXFx1MjA0MFxcdTIwNzAtXFx1MjE4ZlxcdTJjMDAtXFx1MmZlZlxcdTMwMDEtXFx1ZDdmZlxcdWY5MDAtXFx1ZmRjZlxcdWZkZjAtXFx1ZmZmZF0rKVxcWyhbXlxcXV0rKV0kLztcbiAgICAgICAgbWFwQ2FjaGVbc2NoZW1hVHlwZV0gPSBudWxsO1xuICAgICAgICBpZiAodmFsaWRDaGlsZHJlbikge1xuICAgICAgICAgIGVhY2gkZChzcGxpdCQxKHZhbGlkQ2hpbGRyZW4sICcsJyksIHJ1bGUgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2hlcyA9IGNoaWxkUnVsZVJlZ0V4cC5leGVjKHJ1bGUpO1xuICAgICAgICAgICAgbGV0IHBhcmVudCwgcHJlZml4O1xuICAgICAgICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgcHJlZml4ID0gbWF0Y2hlc1sxXTtcbiAgICAgICAgICAgICAgaWYgKHByZWZpeCkge1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IGNoaWxkcmVuW21hdGNoZXNbMl1dO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IGNoaWxkcmVuW21hdGNoZXNbMl1dID0geyAnI2NvbW1lbnQnOiB7fSB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHBhcmVudCA9IGNoaWxkcmVuW21hdGNoZXNbMl1dO1xuICAgICAgICAgICAgICBlYWNoJGQoc3BsaXQkMShtYXRjaGVzWzNdLCAnfCcpLCBjaGlsZCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHByZWZpeCA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgICBkZWxldGUgcGFyZW50W2NoaWxkXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcGFyZW50W2NoaWxkXSA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBnZXRFbGVtZW50UnVsZSA9IG5hbWUgPT4ge1xuICAgICAgICBsZXQgZWxlbWVudCA9IGVsZW1lbnRzW25hbWVdLCBpO1xuICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIGkgPSBwYXR0ZXJuRWxlbWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgZWxlbWVudCA9IHBhdHRlcm5FbGVtZW50c1tpXTtcbiAgICAgICAgICBpZiAoZWxlbWVudC5wYXR0ZXJuLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmICghc2V0dGluZ3MudmFsaWRfZWxlbWVudHMpIHtcbiAgICAgICAgZWFjaCRkKHNjaGVtYUl0ZW1zLCAoZWxlbWVudCwgbmFtZSkgPT4ge1xuICAgICAgICAgIGVsZW1lbnRzW25hbWVdID0ge1xuICAgICAgICAgICAgYXR0cmlidXRlczogZWxlbWVudC5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgYXR0cmlidXRlc09yZGVyOiBlbGVtZW50LmF0dHJpYnV0ZXNPcmRlclxuICAgICAgICAgIH07XG4gICAgICAgICAgY2hpbGRyZW5bbmFtZV0gPSBlbGVtZW50LmNoaWxkcmVuO1xuICAgICAgICB9KTtcbiAgICAgICAgZWFjaCRkKHNwbGl0JDEoJ3N0cm9uZy9iIGVtL2knKSwgaXRlbSA9PiB7XG4gICAgICAgICAgY29uc3QgaXRlbXMgPSBzcGxpdCQxKGl0ZW0sICcvJyk7XG4gICAgICAgICAgZWxlbWVudHNbaXRlbXNbMV1dLm91dHB1dE5hbWUgPSBpdGVtc1swXTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVhY2gkZCh0ZXh0SW5saW5lRWxlbWVudHNNYXAsIChfdmFsLCBuYW1lKSA9PiB7XG4gICAgICAgICAgaWYgKGVsZW1lbnRzW25hbWVdKSB7XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MucGFkZF9lbXB0eV9ibG9ja19pbmxpbmVfY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgZWxlbWVudHNbbmFtZV0ucGFkZEluRW1wdHlCbG9jayA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbGVtZW50c1tuYW1lXS5yZW1vdmVFbXB0eSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZWFjaCRkKHNwbGl0JDEoJ29sIHVsIGJsb2NrcXVvdGUgYSB0YWJsZSB0Ym9keScpLCBuYW1lID0+IHtcbiAgICAgICAgICBpZiAoZWxlbWVudHNbbmFtZV0pIHtcbiAgICAgICAgICAgIGVsZW1lbnRzW25hbWVdLnJlbW92ZUVtcHR5ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBlYWNoJGQoc3BsaXQkMSgncCBoMSBoMiBoMyBoNCBoNSBoNiB0aCB0ZCBwcmUgZGl2IGFkZHJlc3MgY2FwdGlvbiBsaScpLCBuYW1lID0+IHtcbiAgICAgICAgICBlbGVtZW50c1tuYW1lXS5wYWRkRW1wdHkgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgZWFjaCRkKHNwbGl0JDEoJ3NwYW4nKSwgbmFtZSA9PiB7XG4gICAgICAgICAgZWxlbWVudHNbbmFtZV0ucmVtb3ZlRW1wdHlBdHRycyA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0VmFsaWRFbGVtZW50cyhzZXR0aW5ncy52YWxpZF9lbGVtZW50cyk7XG4gICAgICB9XG4gICAgICBhZGRDdXN0b21FbGVtZW50cyhzZXR0aW5ncy5jdXN0b21fZWxlbWVudHMpO1xuICAgICAgYWRkVmFsaWRDaGlsZHJlbihzZXR0aW5ncy52YWxpZF9jaGlsZHJlbik7XG4gICAgICBhZGRWYWxpZEVsZW1lbnRzKHNldHRpbmdzLmV4dGVuZGVkX3ZhbGlkX2VsZW1lbnRzKTtcbiAgICAgIGFkZFZhbGlkQ2hpbGRyZW4oJytvbFt1bHxvbF0sK3VsW3VsfG9sXScpO1xuICAgICAgZWFjaCRkKHtcbiAgICAgICAgZGQ6ICdkbCcsXG4gICAgICAgIGR0OiAnZGwnLFxuICAgICAgICBsaTogJ3VsIG9sJyxcbiAgICAgICAgdGQ6ICd0cicsXG4gICAgICAgIHRoOiAndHInLFxuICAgICAgICB0cjogJ3Rib2R5IHRoZWFkIHRmb290JyxcbiAgICAgICAgdGJvZHk6ICd0YWJsZScsXG4gICAgICAgIHRoZWFkOiAndGFibGUnLFxuICAgICAgICB0Zm9vdDogJ3RhYmxlJyxcbiAgICAgICAgbGVnZW5kOiAnZmllbGRzZXQnLFxuICAgICAgICBhcmVhOiAnbWFwJyxcbiAgICAgICAgcGFyYW06ICd2aWRlbyBhdWRpbyBvYmplY3QnXG4gICAgICB9LCAocGFyZW50cywgaXRlbSkgPT4ge1xuICAgICAgICBpZiAoZWxlbWVudHNbaXRlbV0pIHtcbiAgICAgICAgICBlbGVtZW50c1tpdGVtXS5wYXJlbnRzUmVxdWlyZWQgPSBzcGxpdCQxKHBhcmVudHMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChzZXR0aW5ncy5pbnZhbGlkX2VsZW1lbnRzKSB7XG4gICAgICAgIGVhY2gkZChleHBsb2RlJDIoc2V0dGluZ3MuaW52YWxpZF9lbGVtZW50cyksIGl0ZW0gPT4ge1xuICAgICAgICAgIGlmIChlbGVtZW50c1tpdGVtXSkge1xuICAgICAgICAgICAgZGVsZXRlIGVsZW1lbnRzW2l0ZW1dO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoIWdldEVsZW1lbnRSdWxlKCdzcGFuJykpIHtcbiAgICAgICAgYWRkVmFsaWRFbGVtZW50cygnc3BhblshZGF0YS1tY2UtdHlwZXwqXScpO1xuICAgICAgfVxuICAgICAgY29uc3QgZ2V0VmFsaWRTdHlsZXMgPSBjb25zdGFudCh2YWxpZFN0eWxlcyk7XG4gICAgICBjb25zdCBnZXRJbnZhbGlkU3R5bGVzID0gY29uc3RhbnQoaW52YWxpZFN0eWxlcyk7XG4gICAgICBjb25zdCBnZXRWYWxpZENsYXNzZXMgPSBjb25zdGFudCh2YWxpZENsYXNzZXMpO1xuICAgICAgY29uc3QgZ2V0Qm9vbEF0dHJzID0gY29uc3RhbnQoYm9vbEF0dHJNYXApO1xuICAgICAgY29uc3QgZ2V0QmxvY2tFbGVtZW50cyA9IGNvbnN0YW50KGJsb2NrRWxlbWVudHNNYXApO1xuICAgICAgY29uc3QgZ2V0VGV4dEJsb2NrRWxlbWVudHMgPSBjb25zdGFudCh0ZXh0QmxvY2tFbGVtZW50c01hcCk7XG4gICAgICBjb25zdCBnZXRUZXh0SW5saW5lRWxlbWVudHMgPSBjb25zdGFudCh0ZXh0SW5saW5lRWxlbWVudHNNYXApO1xuICAgICAgY29uc3QgZ2V0Vm9pZEVsZW1lbnRzID0gY29uc3RhbnQoT2JqZWN0LnNlYWwodm9pZEVsZW1lbnRzTWFwKSk7XG4gICAgICBjb25zdCBnZXRTZWxmQ2xvc2luZ0VsZW1lbnRzID0gY29uc3RhbnQoc2VsZkNsb3NpbmdFbGVtZW50c01hcCk7XG4gICAgICBjb25zdCBnZXROb25FbXB0eUVsZW1lbnRzID0gY29uc3RhbnQobm9uRW1wdHlFbGVtZW50c01hcCk7XG4gICAgICBjb25zdCBnZXRNb3ZlQ2FyZXRCZWZvcmVPbkVudGVyRWxlbWVudHMgPSBjb25zdGFudChtb3ZlQ2FyZXRCZWZvcmVPbkVudGVyRWxlbWVudHNNYXApO1xuICAgICAgY29uc3QgZ2V0V2hpdGVzcGFjZUVsZW1lbnRzID0gY29uc3RhbnQod2hpdGVzcGFjZUVsZW1lbnRzTWFwKTtcbiAgICAgIGNvbnN0IGdldFNwZWNpYWxFbGVtZW50cyA9IGNvbnN0YW50KE9iamVjdC5zZWFsKHNwZWNpYWxFbGVtZW50cykpO1xuICAgICAgY29uc3QgaXNWYWxpZENoaWxkID0gKG5hbWUsIGNoaWxkKSA9PiB7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IGNoaWxkcmVuW25hbWUudG9Mb3dlckNhc2UoKV07XG4gICAgICAgIHJldHVybiAhIShwYXJlbnQgJiYgcGFyZW50W2NoaWxkLnRvTG93ZXJDYXNlKCldKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBpc1ZhbGlkID0gKG5hbWUsIGF0dHIpID0+IHtcbiAgICAgICAgbGV0IGF0dHJQYXR0ZXJucywgaTtcbiAgICAgICAgY29uc3QgcnVsZSA9IGdldEVsZW1lbnRSdWxlKG5hbWUpO1xuICAgICAgICBpZiAocnVsZSkge1xuICAgICAgICAgIGlmIChhdHRyKSB7XG4gICAgICAgICAgICBpZiAocnVsZS5hdHRyaWJ1dGVzW2F0dHJdKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXR0clBhdHRlcm5zID0gcnVsZS5hdHRyaWJ1dGVQYXR0ZXJucztcbiAgICAgICAgICAgIGlmIChhdHRyUGF0dGVybnMpIHtcbiAgICAgICAgICAgICAgaSA9IGF0dHJQYXR0ZXJucy5sZW5ndGg7XG4gICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoYXR0clBhdHRlcm5zW2ldLnBhdHRlcm4udGVzdChhdHRyKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuICAgICAgY29uc3QgZ2V0Q3VzdG9tRWxlbWVudHMgPSBjb25zdGFudChjdXN0b21FbGVtZW50c01hcCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBzY2hlbWFUeXBlLFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgZWxlbWVudHMsXG4gICAgICAgIGdldFZhbGlkU3R5bGVzLFxuICAgICAgICBnZXRWYWxpZENsYXNzZXMsXG4gICAgICAgIGdldEJsb2NrRWxlbWVudHMsXG4gICAgICAgIGdldEludmFsaWRTdHlsZXMsXG4gICAgICAgIGdldFZvaWRFbGVtZW50cyxcbiAgICAgICAgZ2V0VGV4dEJsb2NrRWxlbWVudHMsXG4gICAgICAgIGdldFRleHRJbmxpbmVFbGVtZW50cyxcbiAgICAgICAgZ2V0Qm9vbEF0dHJzLFxuICAgICAgICBnZXRFbGVtZW50UnVsZSxcbiAgICAgICAgZ2V0U2VsZkNsb3NpbmdFbGVtZW50cyxcbiAgICAgICAgZ2V0Tm9uRW1wdHlFbGVtZW50cyxcbiAgICAgICAgZ2V0TW92ZUNhcmV0QmVmb3JlT25FbnRlckVsZW1lbnRzLFxuICAgICAgICBnZXRXaGl0ZXNwYWNlRWxlbWVudHMsXG4gICAgICAgIGdldFNwZWNpYWxFbGVtZW50cyxcbiAgICAgICAgaXNWYWxpZENoaWxkLFxuICAgICAgICBpc1ZhbGlkLFxuICAgICAgICBnZXRDdXN0b21FbGVtZW50cyxcbiAgICAgICAgYWRkVmFsaWRFbGVtZW50cyxcbiAgICAgICAgc2V0VmFsaWRFbGVtZW50cyxcbiAgICAgICAgYWRkQ3VzdG9tRWxlbWVudHMsXG4gICAgICAgIGFkZFZhbGlkQ2hpbGRyZW5cbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IFN0eWxlcyA9IChzZXR0aW5ncywgc2NoZW1hKSA9PiB7XG4gICAgICBjb25zdCB1cmxPclN0clJlZ0V4cCA9IC8oPzp1cmwoPzooPzpcXChcXHMqXFxcIihbXlxcXCJdKylcXFwiXFxzKlxcKSl8KD86XFwoXFxzKlxcJyhbXlxcJ10rKVxcJ1xccypcXCkpfCg/OlxcKFxccyooW14pXFxzXSspXFxzKlxcKSkpKXwoPzpcXCcoW15cXCddKylcXCcpfCg/OlxcXCIoW15cXFwiXSspXFxcIikvZ2k7XG4gICAgICBjb25zdCBzdHlsZVJlZ0V4cCA9IC9cXHMqKFteOl0rKTpcXHMqKFteO10rKTs/L2c7XG4gICAgICBjb25zdCB0cmltUmlnaHRSZWdFeHAgPSAvXFxzKyQvO1xuICAgICAgbGV0IGk7XG4gICAgICBjb25zdCBlbmNvZGluZ0xvb2t1cCA9IHt9O1xuICAgICAgbGV0IHZhbGlkU3R5bGVzO1xuICAgICAgbGV0IGludmFsaWRTdHlsZXM7XG4gICAgICBjb25zdCBpbnZpc2libGVDaGFyID0gemVyb1dpZHRoO1xuICAgICAgc2V0dGluZ3MgPSBzZXR0aW5ncyB8fCB7fTtcbiAgICAgIGlmIChzY2hlbWEpIHtcbiAgICAgICAgdmFsaWRTdHlsZXMgPSBzY2hlbWEuZ2V0VmFsaWRTdHlsZXMoKTtcbiAgICAgICAgaW52YWxpZFN0eWxlcyA9IHNjaGVtYS5nZXRJbnZhbGlkU3R5bGVzKCk7XG4gICAgICB9XG4gICAgICBjb25zdCBlbmNvZGluZ0l0ZW1zID0gKGBcXFxcXCIgXFxcXCcgXFxcXDsgXFxcXDogOyA6IGAgKyBpbnZpc2libGVDaGFyKS5zcGxpdCgnICcpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGVuY29kaW5nSXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZW5jb2RpbmdMb29rdXBbZW5jb2RpbmdJdGVtc1tpXV0gPSBpbnZpc2libGVDaGFyICsgaTtcbiAgICAgICAgZW5jb2RpbmdMb29rdXBbaW52aXNpYmxlQ2hhciArIGldID0gZW5jb2RpbmdJdGVtc1tpXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNlbGYgPSB7XG4gICAgICAgIHBhcnNlOiBjc3MgPT4ge1xuICAgICAgICAgIGNvbnN0IHN0eWxlcyA9IHt9O1xuICAgICAgICAgIGxldCBtYXRjaGVzLCBuYW1lLCB2YWx1ZSwgaXNFbmNvZGVkO1xuICAgICAgICAgIGNvbnN0IHVybENvbnZlcnRlciA9IHNldHRpbmdzLnVybF9jb252ZXJ0ZXI7XG4gICAgICAgICAgY29uc3QgdXJsQ29udmVydGVyU2NvcGUgPSBzZXR0aW5ncy51cmxfY29udmVydGVyX3Njb3BlIHx8IHNlbGY7XG4gICAgICAgICAgY29uc3QgY29tcHJlc3MgPSAocHJlZml4LCBzdWZmaXgsIG5vSm9pbikgPT4ge1xuICAgICAgICAgICAgY29uc3QgdG9wID0gc3R5bGVzW3ByZWZpeCArICctdG9wJyArIHN1ZmZpeF07XG4gICAgICAgICAgICBpZiAoIXRvcCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByaWdodCA9IHN0eWxlc1twcmVmaXggKyAnLXJpZ2h0JyArIHN1ZmZpeF07XG4gICAgICAgICAgICBpZiAoIXJpZ2h0KSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJvdHRvbSA9IHN0eWxlc1twcmVmaXggKyAnLWJvdHRvbScgKyBzdWZmaXhdO1xuICAgICAgICAgICAgaWYgKCFib3R0b20pIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGVmdCA9IHN0eWxlc1twcmVmaXggKyAnLWxlZnQnICsgc3VmZml4XTtcbiAgICAgICAgICAgIGlmICghbGVmdCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBib3ggPSBbXG4gICAgICAgICAgICAgIHRvcCxcbiAgICAgICAgICAgICAgcmlnaHQsXG4gICAgICAgICAgICAgIGJvdHRvbSxcbiAgICAgICAgICAgICAgbGVmdFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGkgPSBib3gubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgaWYgKGJveFtpXSAhPT0gYm94W2kgKyAxXSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA+IC0xICYmIG5vSm9pbikge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHlsZXNbcHJlZml4ICsgc3VmZml4XSA9IGkgPT09IC0xID8gYm94WzBdIDogYm94LmpvaW4oJyAnKTtcbiAgICAgICAgICAgIGRlbGV0ZSBzdHlsZXNbcHJlZml4ICsgJy10b3AnICsgc3VmZml4XTtcbiAgICAgICAgICAgIGRlbGV0ZSBzdHlsZXNbcHJlZml4ICsgJy1yaWdodCcgKyBzdWZmaXhdO1xuICAgICAgICAgICAgZGVsZXRlIHN0eWxlc1twcmVmaXggKyAnLWJvdHRvbScgKyBzdWZmaXhdO1xuICAgICAgICAgICAgZGVsZXRlIHN0eWxlc1twcmVmaXggKyAnLWxlZnQnICsgc3VmZml4XTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnN0IGNhbkNvbXByZXNzID0ga2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHN0eWxlc1trZXldLCBpO1xuICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICBpID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICBpZiAodmFsdWVbaV0gIT09IHZhbHVlWzBdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHlsZXNba2V5XSA9IHZhbHVlWzBdO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBjb25zdCBjb21wcmVzczIgPSAodGFyZ2V0LCBhLCBiLCBjKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWNhbkNvbXByZXNzKGEpKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY2FuQ29tcHJlc3MoYikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjYW5Db21wcmVzcyhjKSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHlsZXNbdGFyZ2V0XSA9IHN0eWxlc1thXSArICcgJyArIHN0eWxlc1tiXSArICcgJyArIHN0eWxlc1tjXTtcbiAgICAgICAgICAgIGRlbGV0ZSBzdHlsZXNbYV07XG4gICAgICAgICAgICBkZWxldGUgc3R5bGVzW2JdO1xuICAgICAgICAgICAgZGVsZXRlIHN0eWxlc1tjXTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnN0IGVuY29kZSA9IHN0ciA9PiB7XG4gICAgICAgICAgICBpc0VuY29kZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGVuY29kaW5nTG9va3VwW3N0cl07XG4gICAgICAgICAgfTtcbiAgICAgICAgICBjb25zdCBkZWNvZGUgPSAoc3RyLCBrZWVwU2xhc2hlcykgPT4ge1xuICAgICAgICAgICAgaWYgKGlzRW5jb2RlZCkge1xuICAgICAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgvXFx1RkVGRlswLTldL2csIHN0ciA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuY29kaW5nTG9va3VwW3N0cl07XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFrZWVwU2xhc2hlcykge1xuICAgICAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgvXFxcXChbXFwnXFxcIjs6XSkvZywgJyQxJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICAgIH07XG4gICAgICAgICAgY29uc3QgZGVjb2RlU2luZ2xlSGV4U2VxdWVuY2UgPSBlc2NTZXEgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoZXNjU2VxLnNsaWNlKDEpLCAxNikpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgY29uc3QgZGVjb2RlSGV4U2VxdWVuY2VzID0gdmFsdWUgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoL1xcXFxbMC05YS1mXSsvZ2ksIGRlY29kZVNpbmdsZUhleFNlcXVlbmNlKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnN0IHByb2Nlc3NVcmwgPSAobWF0Y2gsIHVybCwgdXJsMiwgdXJsMywgc3RyLCBzdHIyKSA9PiB7XG4gICAgICAgICAgICBzdHIgPSBzdHIgfHwgc3RyMjtcbiAgICAgICAgICAgIGlmIChzdHIpIHtcbiAgICAgICAgICAgICAgc3RyID0gZGVjb2RlKHN0cik7XG4gICAgICAgICAgICAgIHJldHVybiBgJ2AgKyBzdHIucmVwbGFjZSgvXFwnL2csIGBcXFxcJ2ApICsgYCdgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXJsID0gZGVjb2RlKHVybCB8fCB1cmwyIHx8IHVybDMpO1xuICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5hbGxvd19zY3JpcHRfdXJscykge1xuICAgICAgICAgICAgICBjb25zdCBzY3JpcHRVcmwgPSB1cmwucmVwbGFjZSgvW1xcc1xcclxcbl0rL2csICcnKTtcbiAgICAgICAgICAgICAgaWYgKC8oamF2YXx2YilzY3JpcHQ6L2kudGVzdChzY3JpcHRVcmwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghc2V0dGluZ3MuYWxsb3dfc3ZnX2RhdGFfdXJscyAmJiAvXmRhdGE6aW1hZ2VcXC9zdmcvaS50ZXN0KHNjcmlwdFVybCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1cmxDb252ZXJ0ZXIpIHtcbiAgICAgICAgICAgICAgdXJsID0gdXJsQ29udmVydGVyLmNhbGwodXJsQ29udmVydGVyU2NvcGUsIHVybCwgJ3N0eWxlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYHVybCgnYCArIHVybC5yZXBsYWNlKC9cXCcvZywgYFxcXFwnYCkgKyBgJylgO1xuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKGNzcykge1xuICAgICAgICAgICAgY3NzID0gY3NzLnJlcGxhY2UoL1tcXHUwMDAwLVxcdTAwMUZdL2csICcnKTtcbiAgICAgICAgICAgIGNzcyA9IGNzcy5yZXBsYWNlKC9cXFxcW1xcXCJcXCc7OlxcdUZFRkZdL2csIGVuY29kZSkucmVwbGFjZSgvXFxcIlteXFxcIl0rXFxcInxcXCdbXlxcJ10rXFwnL2csIHN0ciA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvWzs6XS9nLCBlbmNvZGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB3aGlsZSAobWF0Y2hlcyA9IHN0eWxlUmVnRXhwLmV4ZWMoY3NzKSkge1xuICAgICAgICAgICAgICBzdHlsZVJlZ0V4cC5sYXN0SW5kZXggPSBtYXRjaGVzLmluZGV4ICsgbWF0Y2hlc1swXS5sZW5ndGg7XG4gICAgICAgICAgICAgIG5hbWUgPSBtYXRjaGVzWzFdLnJlcGxhY2UodHJpbVJpZ2h0UmVnRXhwLCAnJykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgdmFsdWUgPSBtYXRjaGVzWzJdLnJlcGxhY2UodHJpbVJpZ2h0UmVnRXhwLCAnJyk7XG4gICAgICAgICAgICAgIGlmIChuYW1lICYmIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IGRlY29kZUhleFNlcXVlbmNlcyhuYW1lKTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGRlY29kZUhleFNlcXVlbmNlcyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUuaW5kZXhPZihpbnZpc2libGVDaGFyKSAhPT0gLTEgfHwgbmFtZS5pbmRleE9mKCdcIicpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghc2V0dGluZ3MuYWxsb3dfc2NyaXB0X3VybHMgJiYgKG5hbWUgPT09ICdiZWhhdmlvcicgfHwgL2V4cHJlc3Npb25cXHMqXFwofFxcL1xcKnxcXCpcXC8vLnRlc3QodmFsdWUpKSkge1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuYW1lID09PSAnZm9udC13ZWlnaHQnICYmIHZhbHVlID09PSAnNzAwJykge1xuICAgICAgICAgICAgICAgICAgdmFsdWUgPSAnYm9sZCc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuYW1lID09PSAnY29sb3InIHx8IG5hbWUgPT09ICdiYWNrZ3JvdW5kLWNvbG9yJykge1xuICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UodXJsT3JTdHJSZWdFeHAsIHByb2Nlc3NVcmwpO1xuICAgICAgICAgICAgICAgIHN0eWxlc1tuYW1lXSA9IGlzRW5jb2RlZCA/IGRlY29kZSh2YWx1ZSwgdHJ1ZSkgOiB2YWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29tcHJlc3MoJ2JvcmRlcicsICcnLCB0cnVlKTtcbiAgICAgICAgICAgIGNvbXByZXNzKCdib3JkZXInLCAnLXdpZHRoJyk7XG4gICAgICAgICAgICBjb21wcmVzcygnYm9yZGVyJywgJy1jb2xvcicpO1xuICAgICAgICAgICAgY29tcHJlc3MoJ2JvcmRlcicsICctc3R5bGUnKTtcbiAgICAgICAgICAgIGNvbXByZXNzKCdwYWRkaW5nJywgJycpO1xuICAgICAgICAgICAgY29tcHJlc3MoJ21hcmdpbicsICcnKTtcbiAgICAgICAgICAgIGNvbXByZXNzMignYm9yZGVyJywgJ2JvcmRlci13aWR0aCcsICdib3JkZXItc3R5bGUnLCAnYm9yZGVyLWNvbG9yJyk7XG4gICAgICAgICAgICBpZiAoc3R5bGVzLmJvcmRlciA9PT0gJ21lZGl1bSBub25lJykge1xuICAgICAgICAgICAgICBkZWxldGUgc3R5bGVzLmJvcmRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdHlsZXNbJ2JvcmRlci1pbWFnZSddID09PSAnbm9uZScpIHtcbiAgICAgICAgICAgICAgZGVsZXRlIHN0eWxlc1snYm9yZGVyLWltYWdlJ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzdHlsZXM7XG4gICAgICAgIH0sXG4gICAgICAgIHNlcmlhbGl6ZTogKHN0eWxlcywgZWxlbWVudE5hbWUpID0+IHtcbiAgICAgICAgICBsZXQgY3NzID0gJyc7XG4gICAgICAgICAgY29uc3Qgc2VyaWFsaXplU3R5bGVzID0gbmFtZSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWU7XG4gICAgICAgICAgICBjb25zdCBzdHlsZUxpc3QgPSB2YWxpZFN0eWxlc1tuYW1lXTtcbiAgICAgICAgICAgIGlmIChzdHlsZUxpc3QpIHtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBzdHlsZUxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IHN0eWxlTGlzdFtpXTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHN0eWxlc1tuYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIGNzcyArPSAoY3NzLmxlbmd0aCA+IDAgPyAnICcgOiAnJykgKyBuYW1lICsgJzogJyArIHZhbHVlICsgJzsnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgY29uc3QgaXNWYWxpZCA9IChuYW1lLCBlbGVtZW50TmFtZSkgPT4ge1xuICAgICAgICAgICAgbGV0IHN0eWxlTWFwID0gaW52YWxpZFN0eWxlc1snKiddO1xuICAgICAgICAgICAgaWYgKHN0eWxlTWFwICYmIHN0eWxlTWFwW25hbWVdKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0eWxlTWFwID0gaW52YWxpZFN0eWxlc1tlbGVtZW50TmFtZV07XG4gICAgICAgICAgICByZXR1cm4gIShzdHlsZU1hcCAmJiBzdHlsZU1hcFtuYW1lXSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAoZWxlbWVudE5hbWUgJiYgdmFsaWRTdHlsZXMpIHtcbiAgICAgICAgICAgIHNlcmlhbGl6ZVN0eWxlcygnKicpO1xuICAgICAgICAgICAgc2VyaWFsaXplU3R5bGVzKGVsZW1lbnROYW1lKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWFjaCRmKHN0eWxlcywgKHZhbHVlLCBuYW1lKSA9PiB7XG4gICAgICAgICAgICAgIGlmICh2YWx1ZSAmJiAoIWludmFsaWRTdHlsZXMgfHwgaXNWYWxpZChuYW1lLCBlbGVtZW50TmFtZSkpKSB7XG4gICAgICAgICAgICAgICAgY3NzICs9IChjc3MubGVuZ3RoID4gMCA/ICcgJyA6ICcnKSArIG5hbWUgKyAnOiAnICsgdmFsdWUgKyAnOyc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY3NzO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcblxuICAgIGNvbnN0IGRlcHJlY2F0ZWQgPSB7XG4gICAgICBrZXlMb2NhdGlvbjogdHJ1ZSxcbiAgICAgIGxheWVyWDogdHJ1ZSxcbiAgICAgIGxheWVyWTogdHJ1ZSxcbiAgICAgIHJldHVyblZhbHVlOiB0cnVlLFxuICAgICAgd2Via2l0TW92ZW1lbnRYOiB0cnVlLFxuICAgICAgd2Via2l0TW92ZW1lbnRZOiB0cnVlLFxuICAgICAga2V5SWRlbnRpZmllcjogdHJ1ZSxcbiAgICAgIG1velByZXNzdXJlOiB0cnVlXG4gICAgfTtcbiAgICBjb25zdCBpc05hdGl2ZUV2ZW50ID0gZXZlbnQgPT4gZXZlbnQgaW5zdGFuY2VvZiBFdmVudCB8fCBpc0Z1bmN0aW9uKGV2ZW50LmluaXRFdmVudCk7XG4gICAgY29uc3QgaGFzSXNEZWZhdWx0UHJldmVudGVkID0gZXZlbnQgPT4gZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkID09PSBhbHdheXMgfHwgZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkID09PSBuZXZlcjtcbiAgICBjb25zdCBuZWVkc05vcm1hbGl6aW5nID0gZXZlbnQgPT4gaXNOdWxsYWJsZShldmVudC5wcmV2ZW50RGVmYXVsdCkgfHwgaXNOYXRpdmVFdmVudChldmVudCk7XG4gICAgY29uc3QgY2xvbmUkMyA9IChvcmlnaW5hbEV2ZW50LCBkYXRhKSA9PiB7XG4gICAgICBjb25zdCBldmVudCA9IGRhdGEgIT09IG51bGwgJiYgZGF0YSAhPT0gdm9pZCAwID8gZGF0YSA6IHt9O1xuICAgICAgZm9yIChjb25zdCBuYW1lIGluIG9yaWdpbmFsRXZlbnQpIHtcbiAgICAgICAgaWYgKCFoYXMkMihkZXByZWNhdGVkLCBuYW1lKSkge1xuICAgICAgICAgIGV2ZW50W25hbWVdID0gb3JpZ2luYWxFdmVudFtuYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzTm9uTnVsbGFibGUoZXZlbnQuY29tcG9zZWRQYXRoKSkge1xuICAgICAgICBldmVudC5jb21wb3NlZFBhdGggPSAoKSA9PiBvcmlnaW5hbEV2ZW50LmNvbXBvc2VkUGF0aCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH07XG4gICAgY29uc3Qgbm9ybWFsaXplJDMgPSAodHlwZSwgb3JpZ2luYWxFdmVudCwgZmFsbGJhY2tUYXJnZXQsIGRhdGEpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IGV2ZW50ID0gY2xvbmUkMyhvcmlnaW5hbEV2ZW50LCBkYXRhKTtcbiAgICAgIGV2ZW50LnR5cGUgPSB0eXBlO1xuICAgICAgaWYgKGlzTnVsbGFibGUoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgICBldmVudC50YXJnZXQgPSAoX2EgPSBldmVudC5zcmNFbGVtZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxsYmFja1RhcmdldDtcbiAgICAgIH1cbiAgICAgIGlmIChuZWVkc05vcm1hbGl6aW5nKG9yaWdpbmFsRXZlbnQpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0ID0gKCkgPT4ge1xuICAgICAgICAgIGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuICAgICAgICAgIGV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCA9IGFsd2F5cztcbiAgICAgICAgICBpZiAoaXNGdW5jdGlvbihvcmlnaW5hbEV2ZW50LnByZXZlbnREZWZhdWx0KSkge1xuICAgICAgICAgICAgb3JpZ2luYWxFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uID0gKCkgPT4ge1xuICAgICAgICAgIGV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgICAgICAgZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBhbHdheXM7XG4gICAgICAgICAgaWYgKGlzRnVuY3Rpb24ob3JpZ2luYWxFdmVudC5zdG9wUHJvcGFnYXRpb24pKSB7XG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uID0gKCkgPT4ge1xuICAgICAgICAgIGV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gYWx3YXlzO1xuICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoIWhhc0lzRGVmYXVsdFByZXZlbnRlZChldmVudCkpIHtcbiAgICAgICAgICBldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBldmVudC5kZWZhdWx0UHJldmVudGVkID09PSB0cnVlID8gYWx3YXlzIDogbmV2ZXI7XG4gICAgICAgICAgZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBldmVudC5jYW5jZWxCdWJibGUgPT09IHRydWUgPyBhbHdheXMgOiBuZXZlcjtcbiAgICAgICAgICBldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IG5ldmVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZXZlbnQ7XG4gICAgfTtcblxuICAgIGNvbnN0IGV2ZW50RXhwYW5kb1ByZWZpeCA9ICdtY2UtZGF0YS0nO1xuICAgIGNvbnN0IG1vdXNlRXZlbnRSZSA9IC9eKD86bW91c2V8Y29udGV4dG1lbnUpfGNsaWNrLztcbiAgICBjb25zdCBhZGRFdmVudCA9ICh0YXJnZXQsIG5hbWUsIGNhbGxiYWNrLCBjYXB0dXJlKSA9PiB7XG4gICAgICBpZiAodGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgY2FsbGJhY2ssIGNhcHR1cmUgfHwgZmFsc2UpO1xuICAgICAgfSBlbHNlIGlmICh0YXJnZXQuYXR0YWNoRXZlbnQpIHtcbiAgICAgICAgdGFyZ2V0LmF0dGFjaEV2ZW50KCdvbicgKyBuYW1lLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCByZW1vdmVFdmVudCA9ICh0YXJnZXQsIG5hbWUsIGNhbGxiYWNrLCBjYXB0dXJlKSA9PiB7XG4gICAgICBpZiAodGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgY2FsbGJhY2ssIGNhcHR1cmUgfHwgZmFsc2UpO1xuICAgICAgfSBlbHNlIGlmICh0YXJnZXQuZGV0YWNoRXZlbnQpIHtcbiAgICAgICAgdGFyZ2V0LmRldGFjaEV2ZW50KCdvbicgKyBuYW1lLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBpc01vdXNlRXZlbnQgPSBldmVudCA9PiBpc05vbk51bGxhYmxlKGV2ZW50KSAmJiBtb3VzZUV2ZW50UmUudGVzdChldmVudC50eXBlKTtcbiAgICBjb25zdCBmaXggPSAob3JpZ2luYWxFdmVudCwgZGF0YSkgPT4ge1xuICAgICAgY29uc3QgZXZlbnQgPSBub3JtYWxpemUkMyhvcmlnaW5hbEV2ZW50LnR5cGUsIG9yaWdpbmFsRXZlbnQsIGRvY3VtZW50LCBkYXRhKTtcbiAgICAgIGlmIChpc01vdXNlRXZlbnQob3JpZ2luYWxFdmVudCkgJiYgaXNVbmRlZmluZWQob3JpZ2luYWxFdmVudC5wYWdlWCkgJiYgIWlzVW5kZWZpbmVkKG9yaWdpbmFsRXZlbnQuY2xpZW50WCkpIHtcbiAgICAgICAgY29uc3QgZXZlbnREb2MgPSBldmVudC50YXJnZXQub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudDtcbiAgICAgICAgY29uc3QgZG9jID0gZXZlbnREb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICBjb25zdCBib2R5ID0gZXZlbnREb2MuYm9keTtcbiAgICAgICAgY29uc3QgbW91c2VFdmVudCA9IGV2ZW50O1xuICAgICAgICBtb3VzZUV2ZW50LnBhZ2VYID0gb3JpZ2luYWxFdmVudC5jbGllbnRYICsgKGRvYyAmJiBkb2Muc2Nyb2xsTGVmdCB8fCBib2R5ICYmIGJvZHkuc2Nyb2xsTGVmdCB8fCAwKSAtIChkb2MgJiYgZG9jLmNsaWVudExlZnQgfHwgYm9keSAmJiBib2R5LmNsaWVudExlZnQgfHwgMCk7XG4gICAgICAgIG1vdXNlRXZlbnQucGFnZVkgPSBvcmlnaW5hbEV2ZW50LmNsaWVudFkgKyAoZG9jICYmIGRvYy5zY3JvbGxUb3AgfHwgYm9keSAmJiBib2R5LnNjcm9sbFRvcCB8fCAwKSAtIChkb2MgJiYgZG9jLmNsaWVudFRvcCB8fCBib2R5ICYmIGJvZHkuY2xpZW50VG9wIHx8IDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH07XG4gICAgY29uc3QgYmluZE9uUmVhZHkgPSAod2luLCBjYWxsYmFjaywgZXZlbnRVdGlscykgPT4ge1xuICAgICAgY29uc3QgZG9jID0gd2luLmRvY3VtZW50LCBldmVudCA9IHsgdHlwZTogJ3JlYWR5JyB9O1xuICAgICAgaWYgKGV2ZW50VXRpbHMuZG9tTG9hZGVkKSB7XG4gICAgICAgIGNhbGxiYWNrKGV2ZW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgaXNEb2NSZWFkeSA9ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIGRvYy5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnIHx8IGRvYy5yZWFkeVN0YXRlID09PSAnaW50ZXJhY3RpdmUnICYmIGRvYy5ib2R5O1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlYWR5SGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgcmVtb3ZlRXZlbnQod2luLCAnRE9NQ29udGVudExvYWRlZCcsIHJlYWR5SGFuZGxlcik7XG4gICAgICAgIHJlbW92ZUV2ZW50KHdpbiwgJ2xvYWQnLCByZWFkeUhhbmRsZXIpO1xuICAgICAgICBpZiAoIWV2ZW50VXRpbHMuZG9tTG9hZGVkKSB7XG4gICAgICAgICAgZXZlbnRVdGlscy5kb21Mb2FkZWQgPSB0cnVlO1xuICAgICAgICAgIGNhbGxiYWNrKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICB3aW4gPSBudWxsO1xuICAgICAgfTtcbiAgICAgIGlmIChpc0RvY1JlYWR5KCkpIHtcbiAgICAgICAgcmVhZHlIYW5kbGVyKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZGRFdmVudCh3aW4sICdET01Db250ZW50TG9hZGVkJywgcmVhZHlIYW5kbGVyKTtcbiAgICAgIH1cbiAgICAgIGlmICghZXZlbnRVdGlscy5kb21Mb2FkZWQpIHtcbiAgICAgICAgYWRkRXZlbnQod2luLCAnbG9hZCcsIHJlYWR5SGFuZGxlcik7XG4gICAgICB9XG4gICAgfTtcbiAgICBjbGFzcyBFdmVudFV0aWxzIHtcbiAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmRvbUxvYWRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmV2ZW50cyA9IHt9O1xuICAgICAgICB0aGlzLmNvdW50ID0gMTtcbiAgICAgICAgdGhpcy5leHBhbmRvID0gZXZlbnRFeHBhbmRvUHJlZml4ICsgKCtuZXcgRGF0ZSgpKS50b1N0cmluZygzMik7XG4gICAgICAgIHRoaXMuaGFzTW91c2VFbnRlckxlYXZlID0gJ29ubW91c2VlbnRlcicgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICB0aGlzLmhhc0ZvY3VzSW4gPSAnb25mb2N1c2luJyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHRoaXMuY291bnQgPSAxO1xuICAgICAgfVxuICAgICAgYmluZCh0YXJnZXQsIG5hbWVzLCBjYWxsYmFjaywgc2NvcGUpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGxldCBpZCwgY2FsbGJhY2tMaXN0LCBpLCBuYW1lLCBmYWtlTmFtZSwgbmF0aXZlSGFuZGxlciwgY2FwdHVyZTtcbiAgICAgICAgY29uc3Qgd2luID0gd2luZG93O1xuICAgICAgICBjb25zdCBkZWZhdWx0TmF0aXZlSGFuZGxlciA9IGV2dCA9PiB7XG4gICAgICAgICAgc2VsZi5leGVjdXRlSGFuZGxlcnMoZml4KGV2dCB8fCB3aW4uZXZlbnQpLCBpZCk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICghdGFyZ2V0IHx8IHRhcmdldC5ub2RlVHlwZSA9PT0gMyB8fCB0YXJnZXQubm9kZVR5cGUgPT09IDgpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0YXJnZXRbc2VsZi5leHBhbmRvXSkge1xuICAgICAgICAgIGlkID0gc2VsZi5jb3VudCsrO1xuICAgICAgICAgIHRhcmdldFtzZWxmLmV4cGFuZG9dID0gaWQ7XG4gICAgICAgICAgc2VsZi5ldmVudHNbaWRdID0ge307XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWQgPSB0YXJnZXRbc2VsZi5leHBhbmRvXTtcbiAgICAgICAgfVxuICAgICAgICBzY29wZSA9IHNjb3BlIHx8IHRhcmdldDtcbiAgICAgICAgY29uc3QgbmFtZXNMaXN0ID0gbmFtZXMuc3BsaXQoJyAnKTtcbiAgICAgICAgaSA9IG5hbWVzTGlzdC5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICBuYW1lID0gbmFtZXNMaXN0W2ldO1xuICAgICAgICAgIG5hdGl2ZUhhbmRsZXIgPSBkZWZhdWx0TmF0aXZlSGFuZGxlcjtcbiAgICAgICAgICBmYWtlTmFtZSA9IGNhcHR1cmUgPSBmYWxzZTtcbiAgICAgICAgICBpZiAobmFtZSA9PT0gJ0RPTUNvbnRlbnRMb2FkZWQnKSB7XG4gICAgICAgICAgICBuYW1lID0gJ3JlYWR5JztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNlbGYuZG9tTG9hZGVkICYmIG5hbWUgPT09ICdyZWFkeScgJiYgdGFyZ2V0LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoc2NvcGUsIGZpeCh7IHR5cGU6IG5hbWUgfSkpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghc2VsZi5oYXNNb3VzZUVudGVyTGVhdmUpIHtcbiAgICAgICAgICAgIGZha2VOYW1lID0gc2VsZi5tb3VzZUVudGVyTGVhdmVbbmFtZV07XG4gICAgICAgICAgICBpZiAoZmFrZU5hbWUpIHtcbiAgICAgICAgICAgICAgbmF0aXZlSGFuZGxlciA9IGV2dCA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IGV2dC5jdXJyZW50VGFyZ2V0O1xuICAgICAgICAgICAgICAgIGxldCByZWxhdGVkID0gZXZ0LnJlbGF0ZWRUYXJnZXQ7XG4gICAgICAgICAgICAgICAgaWYgKHJlbGF0ZWQgJiYgY3VycmVudC5jb250YWlucykge1xuICAgICAgICAgICAgICAgICAgcmVsYXRlZCA9IGN1cnJlbnQuY29udGFpbnMocmVsYXRlZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHdoaWxlIChyZWxhdGVkICYmIHJlbGF0ZWQgIT09IGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVsYXRlZCA9IHJlbGF0ZWQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFyZWxhdGVkKSB7XG4gICAgICAgICAgICAgICAgICBldnQgPSBmaXgoZXZ0IHx8IHdpbi5ldmVudCk7XG4gICAgICAgICAgICAgICAgICBldnQudHlwZSA9IGV2dC50eXBlID09PSAnbW91c2VvdXQnID8gJ21vdXNlbGVhdmUnIDogJ21vdXNlZW50ZXInO1xuICAgICAgICAgICAgICAgICAgZXZ0LnRhcmdldCA9IGN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICBzZWxmLmV4ZWN1dGVIYW5kbGVycyhldnQsIGlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghc2VsZi5oYXNGb2N1c0luICYmIChuYW1lID09PSAnZm9jdXNpbicgfHwgbmFtZSA9PT0gJ2ZvY3Vzb3V0JykpIHtcbiAgICAgICAgICAgIGNhcHR1cmUgPSB0cnVlO1xuICAgICAgICAgICAgZmFrZU5hbWUgPSBuYW1lID09PSAnZm9jdXNpbicgPyAnZm9jdXMnIDogJ2JsdXInO1xuICAgICAgICAgICAgbmF0aXZlSGFuZGxlciA9IGV2dCA9PiB7XG4gICAgICAgICAgICAgIGV2dCA9IGZpeChldnQgfHwgd2luLmV2ZW50KTtcbiAgICAgICAgICAgICAgZXZ0LnR5cGUgPSBldnQudHlwZSA9PT0gJ2ZvY3VzJyA/ICdmb2N1c2luJyA6ICdmb2N1c291dCc7XG4gICAgICAgICAgICAgIHNlbGYuZXhlY3V0ZUhhbmRsZXJzKGV2dCwgaWQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FsbGJhY2tMaXN0ID0gc2VsZi5ldmVudHNbaWRdW25hbWVdO1xuICAgICAgICAgIGlmICghY2FsbGJhY2tMaXN0KSB7XG4gICAgICAgICAgICBzZWxmLmV2ZW50c1tpZF1bbmFtZV0gPSBjYWxsYmFja0xpc3QgPSBbe1xuICAgICAgICAgICAgICAgIGZ1bmM6IGNhbGxiYWNrLFxuICAgICAgICAgICAgICAgIHNjb3BlXG4gICAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgY2FsbGJhY2tMaXN0LmZha2VOYW1lID0gZmFrZU5hbWU7XG4gICAgICAgICAgICBjYWxsYmFja0xpc3QuY2FwdHVyZSA9IGNhcHR1cmU7XG4gICAgICAgICAgICBjYWxsYmFja0xpc3QubmF0aXZlSGFuZGxlciA9IG5hdGl2ZUhhbmRsZXI7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ3JlYWR5Jykge1xuICAgICAgICAgICAgICBiaW5kT25SZWFkeSh0YXJnZXQsIG5hdGl2ZUhhbmRsZXIsIHNlbGYpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYWRkRXZlbnQodGFyZ2V0LCBmYWtlTmFtZSB8fCBuYW1lLCBuYXRpdmVIYW5kbGVyLCBjYXB0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdyZWFkeScgJiYgc2VsZi5kb21Mb2FkZWQpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2soZml4KHsgdHlwZTogbmFtZSB9KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjYWxsYmFja0xpc3QucHVzaCh7XG4gICAgICAgICAgICAgICAgZnVuYzogY2FsbGJhY2ssXG4gICAgICAgICAgICAgICAgc2NvcGVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRhcmdldCA9IGNhbGxiYWNrTGlzdCA9IG51bGw7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaztcbiAgICAgIH1cbiAgICAgIHVuYmluZCh0YXJnZXQsIG5hbWVzLCBjYWxsYmFjaykge1xuICAgICAgICBsZXQgY2FsbGJhY2tMaXN0LCBpLCBjaSwgbmFtZSwgZXZlbnRNYXA7XG4gICAgICAgIGlmICghdGFyZ2V0IHx8IHRhcmdldC5ub2RlVHlwZSA9PT0gMyB8fCB0YXJnZXQubm9kZVR5cGUgPT09IDgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpZCA9IHRhcmdldFt0aGlzLmV4cGFuZG9dO1xuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICBldmVudE1hcCA9IHRoaXMuZXZlbnRzW2lkXTtcbiAgICAgICAgICBpZiAobmFtZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWVzTGlzdCA9IG5hbWVzLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICBpID0gbmFtZXNMaXN0Lmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgbmFtZSA9IG5hbWVzTGlzdFtpXTtcbiAgICAgICAgICAgICAgY2FsbGJhY2tMaXN0ID0gZXZlbnRNYXBbbmFtZV07XG4gICAgICAgICAgICAgIGlmIChjYWxsYmFja0xpc3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgIGNpID0gY2FsbGJhY2tMaXN0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgIHdoaWxlIChjaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFja0xpc3RbY2ldLmZ1bmMgPT09IGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmF0aXZlSGFuZGxlciA9IGNhbGxiYWNrTGlzdC5uYXRpdmVIYW5kbGVyO1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZha2VOYW1lID0gY2FsbGJhY2tMaXN0LmZha2VOYW1lLCBjYXB0dXJlID0gY2FsbGJhY2tMaXN0LmNhcHR1cmU7XG4gICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tMaXN0ID0gY2FsbGJhY2tMaXN0LnNsaWNlKDAsIGNpKS5jb25jYXQoY2FsbGJhY2tMaXN0LnNsaWNlKGNpICsgMSkpO1xuICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrTGlzdC5uYXRpdmVIYW5kbGVyID0gbmF0aXZlSGFuZGxlcjtcbiAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja0xpc3QuZmFrZU5hbWUgPSBmYWtlTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja0xpc3QuY2FwdHVyZSA9IGNhcHR1cmU7XG4gICAgICAgICAgICAgICAgICAgICAgZXZlbnRNYXBbbmFtZV0gPSBjYWxsYmFja0xpc3Q7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFjYWxsYmFjayB8fCBjYWxsYmFja0xpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICBkZWxldGUgZXZlbnRNYXBbbmFtZV07XG4gICAgICAgICAgICAgICAgICByZW1vdmVFdmVudCh0YXJnZXQsIGNhbGxiYWNrTGlzdC5mYWtlTmFtZSB8fCBuYW1lLCBjYWxsYmFja0xpc3QubmF0aXZlSGFuZGxlciwgY2FsbGJhY2tMaXN0LmNhcHR1cmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlYWNoJGYoZXZlbnRNYXAsIChjYWxsYmFja0xpc3QsIG5hbWUpID0+IHtcbiAgICAgICAgICAgICAgcmVtb3ZlRXZlbnQodGFyZ2V0LCBjYWxsYmFja0xpc3QuZmFrZU5hbWUgfHwgbmFtZSwgY2FsbGJhY2tMaXN0Lm5hdGl2ZUhhbmRsZXIsIGNhbGxiYWNrTGlzdC5jYXB0dXJlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXZlbnRNYXAgPSB7fTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChuYW1lIGluIGV2ZW50TWFwKSB7XG4gICAgICAgICAgICBpZiAoaGFzJDIoZXZlbnRNYXAsIG5hbWUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBkZWxldGUgdGhpcy5ldmVudHNbaWRdO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkZWxldGUgdGFyZ2V0W3RoaXMuZXhwYW5kb107XG4gICAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgIHRhcmdldFt0aGlzLmV4cGFuZG9dID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBmaXJlKHRhcmdldCwgbmFtZSwgYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNwYXRjaCh0YXJnZXQsIG5hbWUsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgZGlzcGF0Y2godGFyZ2V0LCBuYW1lLCBhcmdzKSB7XG4gICAgICAgIGxldCBpZDtcbiAgICAgICAgaWYgKCF0YXJnZXQgfHwgdGFyZ2V0Lm5vZGVUeXBlID09PSAzIHx8IHRhcmdldC5ub2RlVHlwZSA9PT0gOCkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gZml4KHtcbiAgICAgICAgICB0eXBlOiBuYW1lLFxuICAgICAgICAgIHRhcmdldFxuICAgICAgICB9LCBhcmdzKTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIGlkID0gdGFyZ2V0W3RoaXMuZXhwYW5kb107XG4gICAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICB0aGlzLmV4ZWN1dGVIYW5kbGVycyhldmVudCwgaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZSB8fCB0YXJnZXQub3duZXJEb2N1bWVudCB8fCB0YXJnZXQuZGVmYXVsdFZpZXcgfHwgdGFyZ2V0LnBhcmVudFdpbmRvdztcbiAgICAgICAgfSB3aGlsZSAodGFyZ2V0ICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBjbGVhbih0YXJnZXQpIHtcbiAgICAgICAgbGV0IGksIGNoaWxkcmVuO1xuICAgICAgICBpZiAoIXRhcmdldCB8fCB0YXJnZXQubm9kZVR5cGUgPT09IDMgfHwgdGFyZ2V0Lm5vZGVUeXBlID09PSA4KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhcmdldFt0aGlzLmV4cGFuZG9dKSB7XG4gICAgICAgICAgdGhpcy51bmJpbmQodGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRhcmdldC5nZXRFbGVtZW50c0J5VGFnTmFtZSkge1xuICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5kb2N1bWVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFyZ2V0ICYmIHRhcmdldC5nZXRFbGVtZW50c0J5VGFnTmFtZSkge1xuICAgICAgICAgIHRoaXMudW5iaW5kKHRhcmdldCk7XG4gICAgICAgICAgY2hpbGRyZW4gPSB0YXJnZXQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJyonKTtcbiAgICAgICAgICBpID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIHRhcmdldCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKHRhcmdldFt0aGlzLmV4cGFuZG9dKSB7XG4gICAgICAgICAgICAgIHRoaXMudW5iaW5kKHRhcmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5ldmVudHMgPSB7fTtcbiAgICAgIH1cbiAgICAgIGNhbmNlbChlKSB7XG4gICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgZXhlY3V0ZUhhbmRsZXJzKGV2dCwgaWQpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5ldmVudHNbaWRdO1xuICAgICAgICBjb25zdCBjYWxsYmFja0xpc3QgPSBjb250YWluZXIgJiYgY29udGFpbmVyW2V2dC50eXBlXTtcbiAgICAgICAgaWYgKGNhbGxiYWNrTGlzdCkge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gY2FsbGJhY2tMaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBjYWxsYmFja0xpc3RbaV07XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2sgJiYgY2FsbGJhY2suZnVuYy5jYWxsKGNhbGxiYWNrLnNjb3BlLCBldnQpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChldnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIEV2ZW50VXRpbHMuRXZlbnQgPSBuZXcgRXZlbnRVdGlscygpO1xuXG4gICAgY29uc3QgZWFjaCRjID0gVG9vbHMuZWFjaDtcbiAgICBjb25zdCBncmVwID0gVG9vbHMuZ3JlcDtcbiAgICBjb25zdCBpbnRlcm5hbFN0eWxlTmFtZSA9ICdkYXRhLW1jZS1zdHlsZSc7XG4gICAgY29uc3QgbGVnYWN5U2V0QXR0cmlidXRlID0gKGVsbSwgbmFtZSwgdmFsdWUpID0+IHtcbiAgICAgIGlmIChpc051bGxhYmxlKHZhbHVlKSB8fCB2YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgcmVtb3ZlJGEoZWxtLCBuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldCQyKGVsbSwgbmFtZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgc2V0dXBBdHRySG9va3MgPSAoc3R5bGVzLCBzZXR0aW5ncywgZ2V0Q29udGV4dCkgPT4ge1xuICAgICAgY29uc3Qga2VlcFZhbHVlcyA9IHNldHRpbmdzLmtlZXBfdmFsdWVzO1xuICAgICAgY29uc3Qga2VlcFVybEhvb2sgPSB7XG4gICAgICAgIHNldDogKGVsbSwgdmFsdWUsIG5hbWUpID0+IHtcbiAgICAgICAgICBjb25zdCBzdWdhckVsbSA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVsbSk7XG4gICAgICAgICAgaWYgKGlzRnVuY3Rpb24oc2V0dGluZ3MudXJsX2NvbnZlcnRlcikgJiYgaXNOb25OdWxsYWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gc2V0dGluZ3MudXJsX2NvbnZlcnRlci5jYWxsKHNldHRpbmdzLnVybF9jb252ZXJ0ZXJfc2NvcGUgfHwgZ2V0Q29udGV4dCgpLCB2YWx1ZSwgbmFtZSwgZWxtWzBdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgaW50ZXJuYWxOYW1lID0gJ2RhdGEtbWNlLScgKyBuYW1lO1xuICAgICAgICAgIGxlZ2FjeVNldEF0dHJpYnV0ZShzdWdhckVsbSwgaW50ZXJuYWxOYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgbGVnYWN5U2V0QXR0cmlidXRlKHN1Z2FyRWxtLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldDogKGVsbSwgbmFtZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHN1Z2FyRWxtID0gU3VnYXJFbGVtZW50LmZyb21Eb20oZWxtKTtcbiAgICAgICAgICByZXR1cm4gZ2V0JDkoc3VnYXJFbG0sICdkYXRhLW1jZS0nICsgbmFtZSkgfHwgZ2V0JDkoc3VnYXJFbG0sIG5hbWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgYXR0ckhvb2tzID0ge1xuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIHNldDogKGVsbSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN1Z2FyRWxtID0gU3VnYXJFbGVtZW50LmZyb21Eb20oZWxtKTtcbiAgICAgICAgICAgIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgc2V0QWxsKHN1Z2FyRWxtLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrZWVwVmFsdWVzKSB7XG4gICAgICAgICAgICAgIGxlZ2FjeVNldEF0dHJpYnV0ZShzdWdhckVsbSwgaW50ZXJuYWxTdHlsZU5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlbW92ZSRhKHN1Z2FyRWxtLCAnc3R5bGUnKTtcbiAgICAgICAgICAgIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgc2V0QWxsKHN1Z2FyRWxtLCBzdHlsZXMucGFyc2UodmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldDogZWxtID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN1Z2FyRWxtID0gU3VnYXJFbGVtZW50LmZyb21Eb20oZWxtKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZ2V0JDkoc3VnYXJFbG0sIGludGVybmFsU3R5bGVOYW1lKSB8fCBnZXQkOShzdWdhckVsbSwgJ3N0eWxlJyk7XG4gICAgICAgICAgICByZXR1cm4gc3R5bGVzLnNlcmlhbGl6ZShzdHlsZXMucGFyc2UodmFsdWUpLCBuYW1lKHN1Z2FyRWxtKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKGtlZXBWYWx1ZXMpIHtcbiAgICAgICAgYXR0ckhvb2tzLmhyZWYgPSBhdHRySG9va3Muc3JjID0ga2VlcFVybEhvb2s7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXR0ckhvb2tzO1xuICAgIH07XG4gICAgY29uc3QgdXBkYXRlSW50ZXJuYWxTdHlsZUF0dHIgPSAoc3R5bGVzLCBlbG0pID0+IHtcbiAgICAgIGNvbnN0IHJhd1ZhbHVlID0gZ2V0JDkoZWxtLCAnc3R5bGUnKTtcbiAgICAgIGNvbnN0IHZhbHVlID0gc3R5bGVzLnNlcmlhbGl6ZShzdHlsZXMucGFyc2UocmF3VmFsdWUpLCBuYW1lKGVsbSkpO1xuICAgICAgbGVnYWN5U2V0QXR0cmlidXRlKGVsbSwgaW50ZXJuYWxTdHlsZU5hbWUsIHZhbHVlKTtcbiAgICB9O1xuICAgIGNvbnN0IGZpbmROb2RlSW5kZXggPSAobm9kZSwgbm9ybWFsaXplZCkgPT4ge1xuICAgICAgbGV0IGlkeCA9IDAsIGxhc3ROb2RlVHlwZSwgbm9kZVR5cGU7XG4gICAgICBpZiAobm9kZSkge1xuICAgICAgICBmb3IgKGxhc3ROb2RlVHlwZSA9IG5vZGUubm9kZVR5cGUsIG5vZGUgPSBub2RlLnByZXZpb3VzU2libGluZzsgbm9kZTsgbm9kZSA9IG5vZGUucHJldmlvdXNTaWJsaW5nKSB7XG4gICAgICAgICAgbm9kZVR5cGUgPSBub2RlLm5vZGVUeXBlO1xuICAgICAgICAgIGlmIChub3JtYWxpemVkICYmIG5vZGVUeXBlID09PSAzKSB7XG4gICAgICAgICAgICBpZiAobm9kZVR5cGUgPT09IGxhc3ROb2RlVHlwZSB8fCAhbm9kZS5ub2RlVmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZHgrKztcbiAgICAgICAgICBsYXN0Tm9kZVR5cGUgPSBub2RlVHlwZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGlkeDtcbiAgICB9O1xuICAgIGNvbnN0IG51bWVyaWNhbENzc01hcCA9IFRvb2xzLm1ha2VNYXAoJ2ZpbGwtb3BhY2l0eSBmb250LXdlaWdodCBsaW5lLWhlaWdodCBvcGFjaXR5IG9ycGhhbnMgd2lkb3dzIHotaW5kZXggem9vbScsICcgJyk7XG4gICAgY29uc3QgY2FtZWxDYXNlVG9IeXBoZW5zID0gbmFtZSA9PiBuYW1lLnJlcGxhY2UoL1tBLVpdL2csIHYgPT4gJy0nICsgdi50b0xvd2VyQ2FzZSgpKTtcbiAgICBjb25zdCBET01VdGlscyA9IChkb2MsIHNldHRpbmdzID0ge30pID0+IHtcbiAgICAgIGNvbnN0IGFkZGVkU3R5bGVzID0ge307XG4gICAgICBjb25zdCB3aW4gPSB3aW5kb3c7XG4gICAgICBjb25zdCBmaWxlcyA9IHt9O1xuICAgICAgbGV0IGNvdW50ZXIgPSAwO1xuICAgICAgY29uc3Qgc3RkTW9kZSA9IHRydWU7XG4gICAgICBjb25zdCBib3hNb2RlbCA9IHRydWU7XG4gICAgICBjb25zdCBzdHlsZVNoZWV0TG9hZGVyID0gaW5zdGFuY2UuZm9yRWxlbWVudChTdWdhckVsZW1lbnQuZnJvbURvbShkb2MpLCB7XG4gICAgICAgIGNvbnRlbnRDc3NDb3JzOiBzZXR0aW5ncy5jb250ZW50Q3NzQ29ycyxcbiAgICAgICAgcmVmZXJyZXJQb2xpY3k6IHNldHRpbmdzLnJlZmVycmVyUG9saWN5XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGJvdW5kRXZlbnRzID0gW107XG4gICAgICBjb25zdCBzY2hlbWEgPSBzZXR0aW5ncy5zY2hlbWEgPyBzZXR0aW5ncy5zY2hlbWEgOiBTY2hlbWEoe30pO1xuICAgICAgY29uc3Qgc3R5bGVzID0gU3R5bGVzKHtcbiAgICAgICAgdXJsX2NvbnZlcnRlcjogc2V0dGluZ3MudXJsX2NvbnZlcnRlcixcbiAgICAgICAgdXJsX2NvbnZlcnRlcl9zY29wZTogc2V0dGluZ3MudXJsX2NvbnZlcnRlcl9zY29wZVxuICAgICAgfSwgc2V0dGluZ3Muc2NoZW1hKTtcbiAgICAgIGNvbnN0IGV2ZW50cyA9IHNldHRpbmdzLm93bkV2ZW50cyA/IG5ldyBFdmVudFV0aWxzKCkgOiBFdmVudFV0aWxzLkV2ZW50O1xuICAgICAgY29uc3QgYmxvY2tFbGVtZW50c01hcCA9IHNjaGVtYS5nZXRCbG9ja0VsZW1lbnRzKCk7XG4gICAgICBjb25zdCBpc0Jsb2NrID0gbm9kZSA9PiB7XG4gICAgICAgIGlmIChpc1N0cmluZyhub2RlKSkge1xuICAgICAgICAgIHJldHVybiBoYXMkMihibG9ja0VsZW1lbnRzTWFwLCBub2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gaXNFbGVtZW50JDYobm9kZSkgJiYgaGFzJDIoYmxvY2tFbGVtZW50c01hcCwgbm9kZS5ub2RlTmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBnZXQgPSBlbG0gPT4gZWxtICYmIGRvYyAmJiBpc1N0cmluZyhlbG0pID8gZG9jLmdldEVsZW1lbnRCeUlkKGVsbSkgOiBlbG07XG4gICAgICBjb25zdCBfZ2V0ID0gZWxtID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBnZXQoZWxtKTtcbiAgICAgICAgcmV0dXJuIGlzTm9uTnVsbGFibGUodmFsdWUpID8gU3VnYXJFbGVtZW50LmZyb21Eb20odmFsdWUpIDogbnVsbDtcbiAgICAgIH07XG4gICAgICBjb25zdCBnZXRBdHRyaWIgPSAoZWxtLCBuYW1lLCBkZWZhdWx0VmFsKSA9PiB7XG4gICAgICAgIGxldCB2YWx1ZTtcbiAgICAgICAgY29uc3QgJGVsbSA9IF9nZXQoZWxtKTtcbiAgICAgICAgaWYgKGlzTm9uTnVsbGFibGUoJGVsbSkgJiYgaXNFbGVtZW50JDcoJGVsbSkpIHtcbiAgICAgICAgICBjb25zdCBob29rID0gYXR0ckhvb2tzW25hbWVdO1xuICAgICAgICAgIGlmIChob29rICYmIGhvb2suZ2V0KSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGhvb2suZ2V0KCRlbG0uZG9tLCBuYW1lKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBnZXQkOSgkZWxtLCBuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzTm9uTnVsbGFibGUodmFsdWUpID8gdmFsdWUgOiBkZWZhdWx0VmFsICE9PSBudWxsICYmIGRlZmF1bHRWYWwgIT09IHZvaWQgMCA/IGRlZmF1bHRWYWwgOiAnJztcbiAgICAgIH07XG4gICAgICBjb25zdCBnZXRBdHRyaWJzID0gZWxtID0+IHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGdldChlbG0pO1xuICAgICAgICByZXR1cm4gaXNOdWxsYWJsZShub2RlKSA/IFtdIDogbm9kZS5hdHRyaWJ1dGVzO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHNldEF0dHJpYiA9IChlbG0sIG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICAgIHJ1bihlbG0sIGUgPT4ge1xuICAgICAgICAgIGlmIChpc0VsZW1lbnQkNihlKSkge1xuICAgICAgICAgICAgY29uc3QgJGVsbSA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKGUpO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbFZhbHVlID0gZ2V0JDkoJGVsbSwgbmFtZSk7XG4gICAgICAgICAgICBjb25zdCBob29rID0gYXR0ckhvb2tzW25hbWVdO1xuICAgICAgICAgICAgaWYgKGhvb2sgJiYgaG9vay5zZXQpIHtcbiAgICAgICAgICAgICAgaG9vay5zZXQoJGVsbS5kb20sIHZhbHVlLCBuYW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGxlZ2FjeVNldEF0dHJpYnV0ZSgkZWxtLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3JpZ2luYWxWYWx1ZSAhPT0gdmFsdWUgJiYgc2V0dGluZ3Mub25TZXRBdHRyaWIpIHtcbiAgICAgICAgICAgICAgc2V0dGluZ3Mub25TZXRBdHRyaWIoe1xuICAgICAgICAgICAgICAgIGF0dHJFbG06ICRlbG0sXG4gICAgICAgICAgICAgICAgYXR0ck5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgYXR0clZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGNsb25lID0gKG5vZGUsIGRlZXApID0+IHtcbiAgICAgICAgcmV0dXJuIG5vZGUuY2xvbmVOb2RlKGRlZXApO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGdldFJvb3QgPSAoKSA9PiBzZXR0aW5ncy5yb290X2VsZW1lbnQgfHwgZG9jLmJvZHk7XG4gICAgICBjb25zdCBnZXRWaWV3UG9ydCA9IGFyZ1dpbiA9PiB7XG4gICAgICAgIGNvbnN0IHZwID0gZ2V0Qm91bmRzKGFyZ1dpbik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogdnAueCxcbiAgICAgICAgICB5OiB2cC55LFxuICAgICAgICAgIHc6IHZwLndpZHRoLFxuICAgICAgICAgIGg6IHZwLmhlaWdodFxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGdldFBvcyQxID0gKGVsbSwgcm9vdEVsbSkgPT4gZ2V0UG9zKGRvYy5ib2R5LCBnZXQoZWxtKSwgcm9vdEVsbSk7XG4gICAgICBjb25zdCBzZXRTdHlsZSA9IChlbG0sIG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IGNvbnZlcnRTdHlsZVRvU3RyaW5nID0gKGNzc1ZhbHVlLCBjc3NOYW1lKSA9PiB7XG4gICAgICAgICAgaWYgKGlzU3RyaW5nKGNzc1ZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNzc1ZhbHVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNOdW1iZXIoY3NzVmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gaGFzJDIobnVtZXJpY2FsQ3NzTWFwLCBjc3NOYW1lKSA/IGNzc1ZhbHVlICsgJycgOiBjc3NWYWx1ZSArICdweCc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBtYXAkMihjc3NWYWx1ZSwgY29udmVydFN0eWxlVG9TdHJpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYXBwbHlTdHlsZSA9ICgkZWxtLCBjc3NOYW1lLCBjc3NWYWx1ZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWROYW1lID0gY2FtZWxDYXNlVG9IeXBoZW5zKGNzc05hbWUpO1xuICAgICAgICAgIGlmIChpc051bGxhYmxlKGNzc1ZhbHVlKSB8fCBjc3NWYWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgIHJlbW92ZSQ2KCRlbG0sIG5vcm1hbGl6ZWROYW1lKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0JDEoJGVsbSwgbm9ybWFsaXplZE5hbWUsIGNvbnZlcnRTdHlsZVRvU3RyaW5nKGNzc1ZhbHVlLCBub3JtYWxpemVkTmFtZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcnVuKGVsbSwgZSA9PiB7XG4gICAgICAgICAgY29uc3QgJGVsbSA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKGUpO1xuICAgICAgICAgIGlmIChpc1N0cmluZyhuYW1lKSkge1xuICAgICAgICAgICAgYXBwbHlTdHlsZSgkZWxtLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVhY2gkZihuYW1lLCAodiwgbikgPT4ge1xuICAgICAgICAgICAgICBhcHBseVN0eWxlKCRlbG0sIG4sIHYpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzZXR0aW5ncy51cGRhdGVfc3R5bGVzKSB7XG4gICAgICAgICAgICB1cGRhdGVJbnRlcm5hbFN0eWxlQXR0cihzdHlsZXMsICRlbG0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3Qgc2V0U3R5bGVzID0gKGVsbSwgc3R5bGVzQXJnKSA9PiB7XG4gICAgICAgIHNldFN0eWxlKGVsbSwgc3R5bGVzQXJnKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBnZXRTdHlsZSA9IChlbG0sIG5hbWUsIGNvbXB1dGVkKSA9PiB7XG4gICAgICAgIGNvbnN0ICRlbG0gPSBnZXQoZWxtKTtcbiAgICAgICAgaWYgKGlzTnVsbGFibGUoJGVsbSkgfHwgIWlzRWxlbWVudCQ2KCRlbG0pKSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcHV0ZWQpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0JDcoU3VnYXJFbGVtZW50LmZyb21Eb20oJGVsbSksIGNhbWVsQ2FzZVRvSHlwaGVucyhuYW1lKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvLShcXEQpL2csIChhLCBiKSA9PiBiLnRvVXBwZXJDYXNlKCkpO1xuICAgICAgICAgIGlmIChuYW1lID09PSAnZmxvYXQnKSB7XG4gICAgICAgICAgICBuYW1lID0gJ2Nzc0Zsb2F0JztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuICRlbG0uc3R5bGUgPyAkZWxtLnN0eWxlW25hbWVdIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgZ2V0U2l6ZSA9IGVsbSA9PiB7XG4gICAgICAgIGxldCB3LCBoO1xuICAgICAgICBjb25zdCAkZWxtID0gZ2V0KGVsbSk7XG4gICAgICAgIHcgPSBnZXRTdHlsZSgkZWxtLCAnd2lkdGgnKTtcbiAgICAgICAgaCA9IGdldFN0eWxlKCRlbG0sICdoZWlnaHQnKTtcbiAgICAgICAgaWYgKHcuaW5kZXhPZigncHgnKSA9PT0gLTEpIHtcbiAgICAgICAgICB3ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaC5pbmRleE9mKCdweCcpID09PSAtMSkge1xuICAgICAgICAgIGggPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdzogcGFyc2VJbnQodywgMTApIHx8ICRlbG0ub2Zmc2V0V2lkdGggfHwgJGVsbS5jbGllbnRXaWR0aCxcbiAgICAgICAgICBoOiBwYXJzZUludChoLCAxMCkgfHwgJGVsbS5vZmZzZXRIZWlnaHQgfHwgJGVsbS5jbGllbnRIZWlnaHRcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICBjb25zdCBnZXRSZWN0ID0gZWxtID0+IHtcbiAgICAgICAgY29uc3QgJGVsbSA9IGdldChlbG0pO1xuICAgICAgICBjb25zdCBwb3MgPSBnZXRQb3MkMSgkZWxtKTtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IGdldFNpemUoJGVsbSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogcG9zLngsXG4gICAgICAgICAgeTogcG9zLnksXG4gICAgICAgICAgdzogc2l6ZS53LFxuICAgICAgICAgIGg6IHNpemUuaFxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGlzID0gKGVsbSwgc2VsZWN0b3IpID0+IHtcbiAgICAgICAgaWYgKCFlbG0pIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZWxtcyA9IGlzQXJyYXkkMShlbG0pID8gZWxtIDogW2VsbV07XG4gICAgICAgIHJldHVybiBleGlzdHMoZWxtcywgZSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGlzJDEoU3VnYXJFbGVtZW50LmZyb21Eb20oZSksIHNlbGVjdG9yKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgZ2V0UGFyZW50cyA9IChlbG0sIHNlbGVjdG9yLCByb290LCBjb2xsZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBsZXQgc2VsZWN0b3JWYWw7XG4gICAgICAgIGxldCBub2RlID0gZ2V0KGVsbSk7XG4gICAgICAgIGNvbGxlY3QgPSBjb2xsZWN0ID09PSB1bmRlZmluZWQ7XG4gICAgICAgIHJvb3QgPSByb290IHx8IChnZXRSb290KCkubm9kZU5hbWUgIT09ICdCT0RZJyA/IGdldFJvb3QoKS5wYXJlbnROb2RlIDogbnVsbCk7XG4gICAgICAgIGlmIChpc1N0cmluZyhzZWxlY3RvcikpIHtcbiAgICAgICAgICBzZWxlY3RvclZhbCA9IHNlbGVjdG9yO1xuICAgICAgICAgIGlmIChzZWxlY3RvciA9PT0gJyonKSB7XG4gICAgICAgICAgICBzZWxlY3RvciA9IGlzRWxlbWVudCQ2O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxlY3RvciA9IG5vZGUgPT4gaXMobm9kZSwgc2VsZWN0b3JWYWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICAgIGlmIChub2RlID09PSByb290IHx8IGlzTnVsbGFibGUobm9kZS5ub2RlVHlwZSkgfHwgaXNEb2N1bWVudCQxKG5vZGUpIHx8IGlzRG9jdW1lbnRGcmFnbWVudChub2RlKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghc2VsZWN0b3IgfHwgc2VsZWN0b3Iobm9kZSkpIHtcbiAgICAgICAgICAgIGlmIChjb2xsZWN0KSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFtub2RlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29sbGVjdCA/IHJlc3VsdCA6IG51bGw7XG4gICAgICB9O1xuICAgICAgY29uc3QgZ2V0UGFyZW50ID0gKG5vZGUsIHNlbGVjdG9yLCByb290KSA9PiB7XG4gICAgICAgIGNvbnN0IHBhcmVudHMgPSBnZXRQYXJlbnRzKG5vZGUsIHNlbGVjdG9yLCByb290LCBmYWxzZSk7XG4gICAgICAgIHJldHVybiBwYXJlbnRzICYmIHBhcmVudHMubGVuZ3RoID4gMCA/IHBhcmVudHNbMF0gOiBudWxsO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IF9maW5kU2liID0gKG5vZGUsIHNlbGVjdG9yLCBuYW1lKSA9PiB7XG4gICAgICAgIGxldCBmdW5jID0gc2VsZWN0b3I7XG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgaWYgKGlzU3RyaW5nKHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgZnVuYyA9IG5vZGUgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gaXMobm9kZSwgc2VsZWN0b3IpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChub2RlID0gbm9kZVtuYW1lXTsgbm9kZTsgbm9kZSA9IG5vZGVbbmFtZV0pIHtcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGZ1bmMpICYmIGZ1bmMobm9kZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGdldE5leHQgPSAobm9kZSwgc2VsZWN0b3IpID0+IF9maW5kU2liKG5vZGUsIHNlbGVjdG9yLCAnbmV4dFNpYmxpbmcnKTtcbiAgICAgIGNvbnN0IGdldFByZXYgPSAobm9kZSwgc2VsZWN0b3IpID0+IF9maW5kU2liKG5vZGUsIHNlbGVjdG9yLCAncHJldmlvdXNTaWJsaW5nJyk7XG4gICAgICBjb25zdCBzZWxlY3QgPSAoc2VsZWN0b3IsIHNjb3BlKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGVsbSA9IChfYiA9IChfYSA9IGdldChzY29wZSkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHNldHRpbmdzLnJvb3RfZWxlbWVudCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZG9jO1xuICAgICAgICByZXR1cm4gZnJvbShlbG0ucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHJ1biA9IGZ1bmN0aW9uIChlbG0sIGZ1bmMsIHNjb3BlKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBzY29wZSAhPT0gbnVsbCAmJiBzY29wZSAhPT0gdm9pZCAwID8gc2NvcGUgOiB0aGlzO1xuICAgICAgICBjb25zdCBub2RlID0gaXNTdHJpbmcoZWxtKSA/IGdldChlbG0pIDogZWxtO1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXJyYXkkMShub2RlKSAmJiAobm9kZS5sZW5ndGggfHwgbm9kZS5sZW5ndGggPT09IDApKSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgICAgZWFjaCRjKG5vZGUsIChlbG0sIGkpID0+IHtcbiAgICAgICAgICAgIGlmIChlbG0pIHtcbiAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZnVuYy5jYWxsKGNvbnRleHQsIGlzU3RyaW5nKGVsbSkgPyBnZXQoZWxtKSA6IGVsbSwgaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCBub2RlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHNldEF0dHJpYnMgPSAoZWxtLCBhdHRycykgPT4ge1xuICAgICAgICBydW4oZWxtLCAkZWxtID0+IHtcbiAgICAgICAgICBlYWNoJGYoYXR0cnMsICh2YWx1ZSwgbmFtZSkgPT4ge1xuICAgICAgICAgICAgc2V0QXR0cmliKCRlbG0sIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3Qgc2V0SFRNTCA9IChlbG0sIGh0bWwpID0+IHtcbiAgICAgICAgcnVuKGVsbSwgZSA9PiB7XG4gICAgICAgICAgY29uc3QgJGVsbSA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKGUpO1xuICAgICAgICAgIHNldCgkZWxtLCBodG1sKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgYWRkID0gKHBhcmVudEVsbSwgbmFtZSwgYXR0cnMsIGh0bWwsIGNyZWF0ZSkgPT4gcnVuKHBhcmVudEVsbSwgcGFyZW50RWxtID0+IHtcbiAgICAgICAgY29uc3QgbmV3RWxtID0gaXNTdHJpbmcobmFtZSkgPyBkb2MuY3JlYXRlRWxlbWVudChuYW1lKSA6IG5hbWU7XG4gICAgICAgIGlmIChpc05vbk51bGxhYmxlKGF0dHJzKSkge1xuICAgICAgICAgIHNldEF0dHJpYnMobmV3RWxtLCBhdHRycyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGh0bWwpIHtcbiAgICAgICAgICBpZiAoIWlzU3RyaW5nKGh0bWwpICYmIGh0bWwubm9kZVR5cGUpIHtcbiAgICAgICAgICAgIG5ld0VsbS5hcHBlbmRDaGlsZChodG1sKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKGh0bWwpKSB7XG4gICAgICAgICAgICBzZXRIVE1MKG5ld0VsbSwgaHRtbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhY3JlYXRlID8gcGFyZW50RWxtLmFwcGVuZENoaWxkKG5ld0VsbSkgOiBuZXdFbG07XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGNyZWF0ZSA9IChuYW1lLCBhdHRycywgaHRtbCkgPT4gYWRkKGRvYy5jcmVhdGVFbGVtZW50KG5hbWUpLCBuYW1lLCBhdHRycywgaHRtbCwgdHJ1ZSk7XG4gICAgICBjb25zdCBkZWNvZGUgPSBFbnRpdGllcy5kZWNvZGU7XG4gICAgICBjb25zdCBlbmNvZGUgPSBFbnRpdGllcy5lbmNvZGVBbGxSYXc7XG4gICAgICBjb25zdCBjcmVhdGVIVE1MID0gKG5hbWUsIGF0dHJzLCBodG1sID0gJycpID0+IHtcbiAgICAgICAgbGV0IG91dEh0bWwgPSAnJywga2V5O1xuICAgICAgICBvdXRIdG1sICs9ICc8JyArIG5hbWU7XG4gICAgICAgIGZvciAoa2V5IGluIGF0dHJzKSB7XG4gICAgICAgICAgaWYgKGhhc05vbk51bGxhYmxlS2V5KGF0dHJzLCBrZXkpKSB7XG4gICAgICAgICAgICBvdXRIdG1sICs9ICcgJyArIGtleSArICc9XCInICsgZW5jb2RlKGF0dHJzW2tleV0pICsgJ1wiJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRW1wdHkkMyhodG1sKSAmJiBoYXMkMihzY2hlbWEuZ2V0Vm9pZEVsZW1lbnRzKCksIG5hbWUpKSB7XG4gICAgICAgICAgcmV0dXJuIG91dEh0bWwgKyAnIC8+JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gb3V0SHRtbCArICc+JyArIGh0bWwgKyAnPC8nICsgbmFtZSArICc+JztcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGNyZWF0ZUZyYWdtZW50ID0gaHRtbCA9PiB7XG4gICAgICAgIGxldCBub2RlO1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSBkb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGNvbnN0IGZyYWcgPSBkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICBmcmFnLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG4gICAgICAgIGlmIChodG1sKSB7XG4gICAgICAgICAgY29udGFpbmVyLmlubmVySFRNTCA9IGh0bWw7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKG5vZGUgPSBjb250YWluZXIuZmlyc3RDaGlsZCkge1xuICAgICAgICAgIGZyYWcuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZnJhZy5yZW1vdmVDaGlsZChjb250YWluZXIpO1xuICAgICAgICByZXR1cm4gZnJhZztcbiAgICAgIH07XG4gICAgICBjb25zdCByZW1vdmUgPSAobm9kZSwga2VlcENoaWxkcmVuKSA9PiB7XG4gICAgICAgIHJldHVybiBydW4obm9kZSwgbiA9PiB7XG4gICAgICAgICAgY29uc3QgJG5vZGUgPSBTdWdhckVsZW1lbnQuZnJvbURvbShuKTtcbiAgICAgICAgICBpZiAoa2VlcENoaWxkcmVuKSB7XG4gICAgICAgICAgICBlYWNoJGcoY2hpbGRyZW4oJG5vZGUpLCBjaGlsZCA9PiB7XG4gICAgICAgICAgICAgIGlmIChpc1RleHQkOShjaGlsZCkgJiYgY2hpbGQuZG9tLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJlbW92ZSQ1KGNoaWxkKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBiZWZvcmUkMygkbm9kZSwgY2hpbGQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVtb3ZlJDUoJG5vZGUpO1xuICAgICAgICAgIHJldHVybiAkbm9kZS5kb207XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlbW92ZUFsbEF0dHJpYnMgPSBlID0+IHJ1bihlLCBlID0+IHtcbiAgICAgICAgY29uc3QgYXR0cnMgPSBlLmF0dHJpYnV0ZXM7XG4gICAgICAgIGZvciAobGV0IGkgPSBhdHRycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGUucmVtb3ZlQXR0cmlidXRlTm9kZShhdHRycy5pdGVtKGkpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb25zdCBwYXJzZVN0eWxlID0gY3NzVGV4dCA9PiBzdHlsZXMucGFyc2UoY3NzVGV4dCk7XG4gICAgICBjb25zdCBzZXJpYWxpemVTdHlsZSA9IChzdHlsZXNBcmcsIG5hbWUpID0+IHN0eWxlcy5zZXJpYWxpemUoc3R5bGVzQXJnLCBuYW1lKTtcbiAgICAgIGNvbnN0IGFkZFN0eWxlID0gY3NzVGV4dCA9PiB7XG4gICAgICAgIGxldCBoZWFkLCBzdHlsZUVsbTtcbiAgICAgICAgaWYgKHNlbGYgIT09IERPTVV0aWxzLkRPTSAmJiBkb2MgPT09IGRvY3VtZW50KSB7XG4gICAgICAgICAgaWYgKGFkZGVkU3R5bGVzW2Nzc1RleHRdKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGFkZGVkU3R5bGVzW2Nzc1RleHRdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBzdHlsZUVsbSA9IGRvYy5nZXRFbGVtZW50QnlJZCgnbWNlRGVmYXVsdFN0eWxlcycpO1xuICAgICAgICBpZiAoIXN0eWxlRWxtKSB7XG4gICAgICAgICAgc3R5bGVFbG0gPSBkb2MuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgICBzdHlsZUVsbS5pZCA9ICdtY2VEZWZhdWx0U3R5bGVzJztcbiAgICAgICAgICBzdHlsZUVsbS50eXBlID0gJ3RleHQvY3NzJztcbiAgICAgICAgICBoZWFkID0gZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG4gICAgICAgICAgaWYgKGhlYWQuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgaGVhZC5pbnNlcnRCZWZvcmUoc3R5bGVFbG0sIGhlYWQuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbG0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3R5bGVFbG0uc3R5bGVTaGVldCkge1xuICAgICAgICAgIHN0eWxlRWxtLnN0eWxlU2hlZXQuY3NzVGV4dCArPSBjc3NUZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0eWxlRWxtLmFwcGVuZENoaWxkKGRvYy5jcmVhdGVUZXh0Tm9kZShjc3NUZXh0KSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBsb2FkQ1NTID0gdXJscyA9PiB7XG4gICAgICAgIGlmICghdXJscykge1xuICAgICAgICAgIHVybHMgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBlYWNoJGcodXJscy5zcGxpdCgnLCcpLCB1cmwgPT4ge1xuICAgICAgICAgIGZpbGVzW3VybF0gPSB0cnVlO1xuICAgICAgICAgIHN0eWxlU2hlZXRMb2FkZXIubG9hZCh1cmwpLmNhdGNoKG5vb3ApO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBjb25zdCB0b2dnbGVDbGFzcyA9IChlbG0sIGNscywgc3RhdGUpID0+IHtcbiAgICAgICAgcnVuKGVsbSwgZSA9PiB7XG4gICAgICAgICAgaWYgKGlzRWxlbWVudCQ2KGUpKSB7XG4gICAgICAgICAgICBjb25zdCAkZWxtID0gU3VnYXJFbGVtZW50LmZyb21Eb20oZSk7XG4gICAgICAgICAgICBjb25zdCBjbGFzc2VzID0gY2xzLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICBlYWNoJGcoY2xhc3NlcywgYyA9PiB7XG4gICAgICAgICAgICAgIGlmIChpc05vbk51bGxhYmxlKHN0YXRlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZuID0gc3RhdGUgPyBhZGQkMiA6IHJlbW92ZSQ3O1xuICAgICAgICAgICAgICAgIGZuKCRlbG0sIGMpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRvZ2dsZSQxKCRlbG0sIGMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGFkZENsYXNzID0gKGVsbSwgY2xzKSA9PiB7XG4gICAgICAgIHRvZ2dsZUNsYXNzKGVsbSwgY2xzLCB0cnVlKTtcbiAgICAgIH07XG4gICAgICBjb25zdCByZW1vdmVDbGFzcyA9IChlbG0sIGNscykgPT4ge1xuICAgICAgICB0b2dnbGVDbGFzcyhlbG0sIGNscywgZmFsc2UpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGhhc0NsYXNzID0gKGVsbSwgY2xzKSA9PiB7XG4gICAgICAgIGNvbnN0ICRlbG0gPSBfZ2V0KGVsbSk7XG4gICAgICAgIGNvbnN0IGNsYXNzZXMgPSBjbHMuc3BsaXQoJyAnKTtcbiAgICAgICAgcmV0dXJuIGZvcmFsbChjbGFzc2VzLCBjID0+IGhhcygkZWxtLCBjKSk7XG4gICAgICB9O1xuICAgICAgY29uc3Qgc2hvdyA9IGVsbSA9PiB7XG4gICAgICAgIHJ1bihlbG0sIGUgPT4gcmVtb3ZlJDYoU3VnYXJFbGVtZW50LmZyb21Eb20oZSksICdkaXNwbGF5JykpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGhpZGUgPSBlbG0gPT4ge1xuICAgICAgICBydW4oZWxtLCBlID0+IHNldCQxKFN1Z2FyRWxlbWVudC5mcm9tRG9tKGUpLCAnZGlzcGxheScsICdub25lJykpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGlzSGlkZGVuID0gZWxtID0+IHtcbiAgICAgICAgY29uc3QgJGVsbSA9IF9nZXQoZWxtKTtcbiAgICAgICAgcmV0dXJuIGlzJDIoZ2V0UmF3JDEoJGVsbSwgJ2Rpc3BsYXknKSwgJ25vbmUnKTtcbiAgICAgIH07XG4gICAgICBjb25zdCB1bmlxdWVJZCA9IHByZWZpeCA9PiAoIXByZWZpeCA/ICdtY2VfJyA6IHByZWZpeCkgKyBjb3VudGVyKys7XG4gICAgICBjb25zdCBnZXRPdXRlckhUTUwgPSBlbG0gPT4ge1xuICAgICAgICBjb25zdCAkZWxtID0gX2dldChlbG0pO1xuICAgICAgICByZXR1cm4gaXNFbGVtZW50JDYoJGVsbS5kb20pID8gJGVsbS5kb20ub3V0ZXJIVE1MIDogZ2V0T3V0ZXIoJGVsbSk7XG4gICAgICB9O1xuICAgICAgY29uc3Qgc2V0T3V0ZXJIVE1MID0gKGVsbSwgaHRtbCkgPT4ge1xuICAgICAgICBydW4oZWxtLCAkZWxtID0+IHtcbiAgICAgICAgICBpZiAoaXNFbGVtZW50JDYoJGVsbSkpIHtcbiAgICAgICAgICAgICRlbG0ub3V0ZXJIVE1MID0gaHRtbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGluc2VydEFmdGVyID0gKG5vZGUsIHJlZmVyZW5jZSkgPT4ge1xuICAgICAgICBjb25zdCByZWZlcmVuY2VOb2RlID0gZ2V0KHJlZmVyZW5jZSk7XG4gICAgICAgIHJldHVybiBydW4obm9kZSwgbm9kZSA9PiB7XG4gICAgICAgICAgY29uc3QgcGFyZW50ID0gcmVmZXJlbmNlTm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgIGNvbnN0IG5leHRTaWJsaW5nID0gcmVmZXJlbmNlTm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICBpZiAobmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUobm9kZSwgbmV4dFNpYmxpbmcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBjb25zdCByZXBsYWNlID0gKG5ld0VsbSwgb2xkRWxtLCBrZWVwQ2hpbGRyZW4pID0+IHJ1bihvbGRFbG0sIG9sZEVsbSA9PiB7XG4gICAgICAgIGlmIChpc0FycmF5JDEob2xkRWxtKSkge1xuICAgICAgICAgIG5ld0VsbSA9IG5ld0VsbS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtlZXBDaGlsZHJlbikge1xuICAgICAgICAgIGVhY2gkYyhncmVwKG9sZEVsbS5jaGlsZE5vZGVzKSwgbm9kZSA9PiB7XG4gICAgICAgICAgICBuZXdFbG0uYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9sZEVsbS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChuZXdFbG0sIG9sZEVsbSk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHJlbmFtZSA9IChlbG0sIG5hbWUpID0+IHtcbiAgICAgICAgbGV0IG5ld0VsbTtcbiAgICAgICAgaWYgKGVsbS5ub2RlTmFtZSAhPT0gbmFtZS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICAgICAgbmV3RWxtID0gY3JlYXRlKG5hbWUpO1xuICAgICAgICAgIGVhY2gkYyhnZXRBdHRyaWJzKGVsbSksIGF0dHJOb2RlID0+IHtcbiAgICAgICAgICAgIHNldEF0dHJpYihuZXdFbG0sIGF0dHJOb2RlLm5vZGVOYW1lLCBnZXRBdHRyaWIoZWxtLCBhdHRyTm9kZS5ub2RlTmFtZSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJlcGxhY2UobmV3RWxtLCBlbG0sIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdFbG0gfHwgZWxtO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGZpbmRDb21tb25BbmNlc3RvciA9IChhLCBiKSA9PiB7XG4gICAgICAgIGxldCBwcyA9IGEsIHBlO1xuICAgICAgICB3aGlsZSAocHMpIHtcbiAgICAgICAgICBwZSA9IGI7XG4gICAgICAgICAgd2hpbGUgKHBlICYmIHBzICE9PSBwZSkge1xuICAgICAgICAgICAgcGUgPSBwZS5wYXJlbnROb2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHMgPT09IHBlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgcHMgPSBwcy5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcHMgJiYgYS5vd25lckRvY3VtZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGEub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBzO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGlzTm9uRW1wdHlFbGVtZW50ID0gbm9kZSA9PiB7XG4gICAgICAgIGlmIChpc0VsZW1lbnQkNihub2RlKSkge1xuICAgICAgICAgIGNvbnN0IGlzTmFtZWRBbmNob3IgPSBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdhJyAmJiAhZ2V0QXR0cmliKG5vZGUsICdocmVmJykgJiYgZ2V0QXR0cmliKG5vZGUsICdpZCcpO1xuICAgICAgICAgIGlmIChnZXRBdHRyaWIobm9kZSwgJ25hbWUnKSB8fCBnZXRBdHRyaWIobm9kZSwgJ2RhdGEtbWNlLWJvb2ttYXJrJykgfHwgaXNOYW1lZEFuY2hvcikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG4gICAgICBjb25zdCBpc0VtcHR5ID0gKG5vZGUsIGVsZW1lbnRzKSA9PiB7XG4gICAgICAgIGxldCB0eXBlLCBuYW1lLCBickNvdW50ID0gMDtcbiAgICAgICAgaWYgKGlzTm9uRW1wdHlFbGVtZW50KG5vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgY29uc3Qgd2Fsa2VyID0gbmV3IERvbVRyZWVXYWxrZXIobm9kZSwgbm9kZS5wYXJlbnROb2RlKTtcbiAgICAgICAgICBjb25zdCB3aGl0ZXNwYWNlID0gc2NoZW1hID8gc2NoZW1hLmdldFdoaXRlc3BhY2VFbGVtZW50cygpIDoge307XG4gICAgICAgICAgZWxlbWVudHMgPSBlbGVtZW50cyB8fCAoc2NoZW1hID8gc2NoZW1hLmdldE5vbkVtcHR5RWxlbWVudHMoKSA6IG51bGwpO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIHR5cGUgPSBub2RlLm5vZGVUeXBlO1xuICAgICAgICAgICAgaWYgKGlzRWxlbWVudCQ2KG5vZGUpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGJvZ3VzVmFsID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtbWNlLWJvZ3VzJyk7XG4gICAgICAgICAgICAgIGlmIChib2d1c1ZhbCkge1xuICAgICAgICAgICAgICAgIG5vZGUgPSB3YWxrZXIubmV4dChib2d1c1ZhbCA9PT0gJ2FsbCcpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG5hbWUgPSBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgIGlmIChlbGVtZW50cyAmJiBlbGVtZW50c1tuYW1lXSkge1xuICAgICAgICAgICAgICAgIGlmIChuYW1lID09PSAnYnInKSB7XG4gICAgICAgICAgICAgICAgICBickNvdW50Kys7XG4gICAgICAgICAgICAgICAgICBub2RlID0gd2Fsa2VyLm5leHQoKTtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGlzTm9uRW1wdHlFbGVtZW50KG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gOCkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gMyAmJiAhaXNXaGl0ZXNwYWNlVGV4dChub2RlLm5vZGVWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGUgPT09IDMgJiYgbm9kZS5wYXJlbnROb2RlICYmIHdoaXRlc3BhY2Vbbm9kZS5wYXJlbnROb2RlLm5vZGVOYW1lXSAmJiBpc1doaXRlc3BhY2VUZXh0KG5vZGUubm9kZVZhbHVlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gd2Fsa2VyLm5leHQoKTtcbiAgICAgICAgICB9IHdoaWxlIChub2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnJDb3VudCA8PSAxO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGNyZWF0ZVJuZyA9ICgpID0+IGRvYy5jcmVhdGVSYW5nZSgpO1xuICAgICAgY29uc3Qgc3BsaXQgPSAocGFyZW50RWxtLCBzcGxpdEVsbSwgcmVwbGFjZW1lbnRFbG0pID0+IHtcbiAgICAgICAgbGV0IHJhbmdlID0gY3JlYXRlUm5nKCk7XG4gICAgICAgIGxldCBiZWZvcmVGcmFnbWVudDtcbiAgICAgICAgbGV0IGFmdGVyRnJhZ21lbnQ7XG4gICAgICAgIGxldCBwYXJlbnROb2RlO1xuICAgICAgICBpZiAocGFyZW50RWxtICYmIHNwbGl0RWxtKSB7XG4gICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQocGFyZW50RWxtLnBhcmVudE5vZGUsIGZpbmROb2RlSW5kZXgocGFyZW50RWxtKSk7XG4gICAgICAgICAgcmFuZ2Uuc2V0RW5kKHNwbGl0RWxtLnBhcmVudE5vZGUsIGZpbmROb2RlSW5kZXgoc3BsaXRFbG0pKTtcbiAgICAgICAgICBiZWZvcmVGcmFnbWVudCA9IHJhbmdlLmV4dHJhY3RDb250ZW50cygpO1xuICAgICAgICAgIHJhbmdlID0gY3JlYXRlUm5nKCk7XG4gICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQoc3BsaXRFbG0ucGFyZW50Tm9kZSwgZmluZE5vZGVJbmRleChzcGxpdEVsbSkgKyAxKTtcbiAgICAgICAgICByYW5nZS5zZXRFbmQocGFyZW50RWxtLnBhcmVudE5vZGUsIGZpbmROb2RlSW5kZXgocGFyZW50RWxtKSArIDEpO1xuICAgICAgICAgIGFmdGVyRnJhZ21lbnQgPSByYW5nZS5leHRyYWN0Q29udGVudHMoKTtcbiAgICAgICAgICBwYXJlbnROb2RlID0gcGFyZW50RWxtLnBhcmVudE5vZGU7XG4gICAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodHJpbU5vZGUoc2VsZiwgYmVmb3JlRnJhZ21lbnQpLCBwYXJlbnRFbG0pO1xuICAgICAgICAgIGlmIChyZXBsYWNlbWVudEVsbSkge1xuICAgICAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUocmVwbGFjZW1lbnRFbG0sIHBhcmVudEVsbSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHNwbGl0RWxtLCBwYXJlbnRFbG0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZSh0cmltTm9kZShzZWxmLCBhZnRlckZyYWdtZW50KSwgcGFyZW50RWxtKTtcbiAgICAgICAgICByZW1vdmUocGFyZW50RWxtKTtcbiAgICAgICAgICByZXR1cm4gcmVwbGFjZW1lbnRFbG0gfHwgc3BsaXRFbG07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBiaW5kID0gKHRhcmdldCwgbmFtZSwgZnVuYywgc2NvcGUpID0+IHtcbiAgICAgICAgaWYgKGlzQXJyYXkkMSh0YXJnZXQpKSB7XG4gICAgICAgICAgbGV0IGkgPSB0YXJnZXQubGVuZ3RoO1xuICAgICAgICAgIGNvbnN0IHJ2ID0gW107XG4gICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgcnZbaV0gPSBiaW5kKHRhcmdldFtpXSwgbmFtZSwgZnVuYywgc2NvcGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcnY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHNldHRpbmdzLmNvbGxlY3QgJiYgKHRhcmdldCA9PT0gZG9jIHx8IHRhcmdldCA9PT0gd2luKSkge1xuICAgICAgICAgICAgYm91bmRFdmVudHMucHVzaChbXG4gICAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgZnVuYyxcbiAgICAgICAgICAgICAgc2NvcGVcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZXZlbnRzLmJpbmQodGFyZ2V0LCBuYW1lLCBmdW5jLCBzY29wZSB8fCBzZWxmKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHVuYmluZCA9ICh0YXJnZXQsIG5hbWUsIGZ1bmMpID0+IHtcbiAgICAgICAgaWYgKGlzQXJyYXkkMSh0YXJnZXQpKSB7XG4gICAgICAgICAgbGV0IGkgPSB0YXJnZXQubGVuZ3RoO1xuICAgICAgICAgIGNvbnN0IHJ2ID0gW107XG4gICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgcnZbaV0gPSB1bmJpbmQodGFyZ2V0W2ldLCBuYW1lLCBmdW5jKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChib3VuZEV2ZW50cy5sZW5ndGggPiAwICYmICh0YXJnZXQgPT09IGRvYyB8fCB0YXJnZXQgPT09IHdpbikpIHtcbiAgICAgICAgICAgIGxldCBpID0gYm91bmRFdmVudHMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICBjb25zdCBpdGVtID0gYm91bmRFdmVudHNbaV07XG4gICAgICAgICAgICAgIGlmICh0YXJnZXQgPT09IGl0ZW1bMF0gJiYgKCFuYW1lIHx8IG5hbWUgPT09IGl0ZW1bMV0pICYmICghZnVuYyB8fCBmdW5jID09PSBpdGVtWzJdKSkge1xuICAgICAgICAgICAgICAgIGV2ZW50cy51bmJpbmQoaXRlbVswXSwgaXRlbVsxXSwgaXRlbVsyXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGV2ZW50cy51bmJpbmQodGFyZ2V0LCBuYW1lLCBmdW5jKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGRpc3BhdGNoID0gKHRhcmdldCwgbmFtZSwgZXZ0KSA9PiBldmVudHMuZGlzcGF0Y2godGFyZ2V0LCBuYW1lLCBldnQpO1xuICAgICAgY29uc3QgZmlyZSA9ICh0YXJnZXQsIG5hbWUsIGV2dCkgPT4gZXZlbnRzLmRpc3BhdGNoKHRhcmdldCwgbmFtZSwgZXZ0KTtcbiAgICAgIGNvbnN0IGdldENvbnRlbnRFZGl0YWJsZSA9IG5vZGUgPT4ge1xuICAgICAgICBpZiAobm9kZSAmJiBpc0VsZW1lbnQkNihub2RlKSkge1xuICAgICAgICAgIGNvbnN0IGNvbnRlbnRFZGl0YWJsZSA9IG5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLW1jZS1jb250ZW50ZWRpdGFibGUnKTtcbiAgICAgICAgICBpZiAoY29udGVudEVkaXRhYmxlICYmIGNvbnRlbnRFZGl0YWJsZSAhPT0gJ2luaGVyaXQnKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGVudEVkaXRhYmxlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbm9kZS5jb250ZW50RWRpdGFibGUgIT09ICdpbmhlcml0JyA/IG5vZGUuY29udGVudEVkaXRhYmxlIDogbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGdldENvbnRlbnRFZGl0YWJsZVBhcmVudCA9IG5vZGUgPT4ge1xuICAgICAgICBjb25zdCByb290ID0gZ2V0Um9vdCgpO1xuICAgICAgICBsZXQgc3RhdGUgPSBudWxsO1xuICAgICAgICBmb3IgKDsgbm9kZSAmJiBub2RlICE9PSByb290OyBub2RlID0gbm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgc3RhdGUgPSBnZXRDb250ZW50RWRpdGFibGUobm9kZSk7XG4gICAgICAgICAgaWYgKHN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGRlc3Ryb3kgPSAoKSA9PiB7XG4gICAgICAgIGlmIChib3VuZEV2ZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgbGV0IGkgPSBib3VuZEV2ZW50cy5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IGJvdW5kRXZlbnRzW2ldO1xuICAgICAgICAgICAgZXZlbnRzLnVuYmluZChpdGVtWzBdLCBpdGVtWzFdLCBpdGVtWzJdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWFjaCRmKGZpbGVzLCAoXywgdXJsKSA9PiB7XG4gICAgICAgICAgc3R5bGVTaGVldExvYWRlci51bmxvYWQodXJsKTtcbiAgICAgICAgICBkZWxldGUgZmlsZXNbdXJsXTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgaXNDaGlsZE9mID0gKG5vZGUsIHBhcmVudCkgPT4ge1xuICAgICAgICByZXR1cm4gbm9kZSA9PT0gcGFyZW50IHx8IHBhcmVudC5jb250YWlucyhub2RlKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBkdW1wUm5nID0gciA9PiAnc3RhcnRDb250YWluZXI6ICcgKyByLnN0YXJ0Q29udGFpbmVyLm5vZGVOYW1lICsgJywgc3RhcnRPZmZzZXQ6ICcgKyByLnN0YXJ0T2Zmc2V0ICsgJywgZW5kQ29udGFpbmVyOiAnICsgci5lbmRDb250YWluZXIubm9kZU5hbWUgKyAnLCBlbmRPZmZzZXQ6ICcgKyByLmVuZE9mZnNldDtcbiAgICAgIGNvbnN0IHNlbGYgPSB7XG4gICAgICAgIGRvYyxcbiAgICAgICAgc2V0dGluZ3MsXG4gICAgICAgIHdpbixcbiAgICAgICAgZmlsZXMsXG4gICAgICAgIHN0ZE1vZGUsXG4gICAgICAgIGJveE1vZGVsLFxuICAgICAgICBzdHlsZVNoZWV0TG9hZGVyLFxuICAgICAgICBib3VuZEV2ZW50cyxcbiAgICAgICAgc3R5bGVzLFxuICAgICAgICBzY2hlbWEsXG4gICAgICAgIGV2ZW50cyxcbiAgICAgICAgaXNCbG9jayxcbiAgICAgICAgcm9vdDogbnVsbCxcbiAgICAgICAgY2xvbmUsXG4gICAgICAgIGdldFJvb3QsXG4gICAgICAgIGdldFZpZXdQb3J0LFxuICAgICAgICBnZXRSZWN0LFxuICAgICAgICBnZXRTaXplLFxuICAgICAgICBnZXRQYXJlbnQsXG4gICAgICAgIGdldFBhcmVudHMsXG4gICAgICAgIGdldCxcbiAgICAgICAgZ2V0TmV4dCxcbiAgICAgICAgZ2V0UHJldixcbiAgICAgICAgc2VsZWN0LFxuICAgICAgICBpcyxcbiAgICAgICAgYWRkLFxuICAgICAgICBjcmVhdGUsXG4gICAgICAgIGNyZWF0ZUhUTUwsXG4gICAgICAgIGNyZWF0ZUZyYWdtZW50LFxuICAgICAgICByZW1vdmUsXG4gICAgICAgIHNldFN0eWxlLFxuICAgICAgICBnZXRTdHlsZSxcbiAgICAgICAgc2V0U3R5bGVzLFxuICAgICAgICByZW1vdmVBbGxBdHRyaWJzLFxuICAgICAgICBzZXRBdHRyaWIsXG4gICAgICAgIHNldEF0dHJpYnMsXG4gICAgICAgIGdldEF0dHJpYixcbiAgICAgICAgZ2V0UG9zOiBnZXRQb3MkMSxcbiAgICAgICAgcGFyc2VTdHlsZSxcbiAgICAgICAgc2VyaWFsaXplU3R5bGUsXG4gICAgICAgIGFkZFN0eWxlLFxuICAgICAgICBsb2FkQ1NTLFxuICAgICAgICBhZGRDbGFzcyxcbiAgICAgICAgcmVtb3ZlQ2xhc3MsXG4gICAgICAgIGhhc0NsYXNzLFxuICAgICAgICB0b2dnbGVDbGFzcyxcbiAgICAgICAgc2hvdyxcbiAgICAgICAgaGlkZSxcbiAgICAgICAgaXNIaWRkZW4sXG4gICAgICAgIHVuaXF1ZUlkLFxuICAgICAgICBzZXRIVE1MLFxuICAgICAgICBnZXRPdXRlckhUTUwsXG4gICAgICAgIHNldE91dGVySFRNTCxcbiAgICAgICAgZGVjb2RlLFxuICAgICAgICBlbmNvZGUsXG4gICAgICAgIGluc2VydEFmdGVyLFxuICAgICAgICByZXBsYWNlLFxuICAgICAgICByZW5hbWUsXG4gICAgICAgIGZpbmRDb21tb25BbmNlc3RvcixcbiAgICAgICAgcnVuLFxuICAgICAgICBnZXRBdHRyaWJzLFxuICAgICAgICBpc0VtcHR5LFxuICAgICAgICBjcmVhdGVSbmcsXG4gICAgICAgIG5vZGVJbmRleDogZmluZE5vZGVJbmRleCxcbiAgICAgICAgc3BsaXQsXG4gICAgICAgIGJpbmQ6IGJpbmQsXG4gICAgICAgIHVuYmluZDogdW5iaW5kLFxuICAgICAgICBmaXJlLFxuICAgICAgICBkaXNwYXRjaCxcbiAgICAgICAgZ2V0Q29udGVudEVkaXRhYmxlLFxuICAgICAgICBnZXRDb250ZW50RWRpdGFibGVQYXJlbnQsXG4gICAgICAgIGRlc3Ryb3ksXG4gICAgICAgIGlzQ2hpbGRPZixcbiAgICAgICAgZHVtcFJuZ1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGF0dHJIb29rcyA9IHNldHVwQXR0ckhvb2tzKHN0eWxlcywgc2V0dGluZ3MsIGNvbnN0YW50KHNlbGYpKTtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG4gICAgRE9NVXRpbHMuRE9NID0gRE9NVXRpbHMoZG9jdW1lbnQpO1xuICAgIERPTVV0aWxzLm5vZGVJbmRleCA9IGZpbmROb2RlSW5kZXg7XG5cbiAgICBjb25zdCBET00kYiA9IERPTVV0aWxzLkRPTTtcbiAgICBjb25zdCBRVUVVRUQgPSAwO1xuICAgIGNvbnN0IExPQURJTkcgPSAxO1xuICAgIGNvbnN0IExPQURFRCA9IDI7XG4gICAgY29uc3QgRkFJTEVEID0gMztcbiAgICBjbGFzcyBTY3JpcHRMb2FkZXIge1xuICAgICAgY29uc3RydWN0b3Ioc2V0dGluZ3MgPSB7fSkge1xuICAgICAgICB0aGlzLnN0YXRlcyA9IHt9O1xuICAgICAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgICAgIHRoaXMuc2NyaXB0TG9hZGVkQ2FsbGJhY2tzID0ge307XG4gICAgICAgIHRoaXMucXVldWVMb2FkZWRDYWxsYmFja3MgPSBbXTtcbiAgICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICAgIH1cbiAgICAgIF9zZXRSZWZlcnJlclBvbGljeShyZWZlcnJlclBvbGljeSkge1xuICAgICAgICB0aGlzLnNldHRpbmdzLnJlZmVycmVyUG9saWN5ID0gcmVmZXJyZXJQb2xpY3k7XG4gICAgICB9XG4gICAgICBsb2FkU2NyaXB0KHVybCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGRvbSA9IERPTSRiO1xuICAgICAgICAgIGxldCBlbG07XG4gICAgICAgICAgY29uc3QgY2xlYW51cCA9ICgpID0+IHtcbiAgICAgICAgICAgIGRvbS5yZW1vdmUoaWQpO1xuICAgICAgICAgICAgaWYgKGVsbSkge1xuICAgICAgICAgICAgICBlbG0ub25lcnJvciA9IGVsbS5vbmxvYWQgPSBlbG0gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgY29uc3QgZG9uZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnN0IGVycm9yID0gKCkgPT4ge1xuICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgcmVqZWN0KCdGYWlsZWQgdG8gbG9hZCBzY3JpcHQ6ICcgKyB1cmwpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgY29uc3QgaWQgPSBkb20udW5pcXVlSWQoKTtcbiAgICAgICAgICBlbG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgICBlbG0uaWQgPSBpZDtcbiAgICAgICAgICBlbG0udHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnO1xuICAgICAgICAgIGVsbS5zcmMgPSBUb29scy5fYWRkQ2FjaGVTdWZmaXgodXJsKTtcbiAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5yZWZlcnJlclBvbGljeSkge1xuICAgICAgICAgICAgZG9tLnNldEF0dHJpYihlbG0sICdyZWZlcnJlcnBvbGljeScsIHRoaXMuc2V0dGluZ3MucmVmZXJyZXJQb2xpY3kpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbG0ub25sb2FkID0gZG9uZTtcbiAgICAgICAgICBlbG0ub25lcnJvciA9IGVycm9yO1xuICAgICAgICAgIChkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdIHx8IGRvY3VtZW50LmJvZHkpLmFwcGVuZENoaWxkKGVsbSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaXNEb25lKHVybCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZXNbdXJsXSA9PT0gTE9BREVEO1xuICAgICAgfVxuICAgICAgbWFya0RvbmUodXJsKSB7XG4gICAgICAgIHRoaXMuc3RhdGVzW3VybF0gPSBMT0FERUQ7XG4gICAgICB9XG4gICAgICBhZGQodXJsKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBzZWxmLnF1ZXVlLnB1c2godXJsKTtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBzZWxmLnN0YXRlc1t1cmxdO1xuICAgICAgICBpZiAoc3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHNlbGYuc3RhdGVzW3VybF0gPSBRVUVVRUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICBpZiAoIXNlbGYuc2NyaXB0TG9hZGVkQ2FsbGJhY2tzW3VybF0pIHtcbiAgICAgICAgICAgIHNlbGYuc2NyaXB0TG9hZGVkQ2FsbGJhY2tzW3VybF0gPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZi5zY3JpcHRMb2FkZWRDYWxsYmFja3NbdXJsXS5wdXNoKHtcbiAgICAgICAgICAgIHJlc29sdmUsXG4gICAgICAgICAgICByZWplY3RcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBsb2FkKHVybCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGQodXJsKTtcbiAgICAgIH1cbiAgICAgIHJlbW92ZSh1cmwpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuc3RhdGVzW3VybF07XG4gICAgICAgIGRlbGV0ZSB0aGlzLnNjcmlwdExvYWRlZENhbGxiYWNrc1t1cmxdO1xuICAgICAgfVxuICAgICAgbG9hZFF1ZXVlKCkge1xuICAgICAgICBjb25zdCBxdWV1ZSA9IHRoaXMucXVldWU7XG4gICAgICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZFNjcmlwdHMocXVldWUpO1xuICAgICAgfVxuICAgICAgbG9hZFNjcmlwdHMoc2NyaXB0cykge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgY29uc3QgZXhlY0NhbGxiYWNrcyA9IChuYW1lLCB1cmwpID0+IHtcbiAgICAgICAgICBnZXQkYShzZWxmLnNjcmlwdExvYWRlZENhbGxiYWNrcywgdXJsKS5lYWNoKGNhbGxiYWNrcyA9PiB7XG4gICAgICAgICAgICBlYWNoJGcoY2FsbGJhY2tzLCBjYWxsYmFjayA9PiBjYWxsYmFja1tuYW1lXSh1cmwpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBkZWxldGUgc2VsZi5zY3JpcHRMb2FkZWRDYWxsYmFja3NbdXJsXTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcHJvY2Vzc1Jlc3VsdHMgPSByZXN1bHRzID0+IHtcbiAgICAgICAgICBjb25zdCBmYWlsdXJlcyA9IGZpbHRlciQ2KHJlc3VsdHMsIHJlc3VsdCA9PiByZXN1bHQuc3RhdHVzID09PSAncmVqZWN0ZWQnKTtcbiAgICAgICAgICBpZiAoZmFpbHVyZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGJpbmQkMyhmYWlsdXJlcywgKHtyZWFzb259KSA9PiBpc0FycmF5JDEocmVhc29uKSA/IHJlYXNvbiA6IFtyZWFzb25dKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGxvYWQgPSB1cmxzID0+IFByb21pc2UuYWxsU2V0dGxlZChtYXAkMyh1cmxzLCB1cmwgPT4ge1xuICAgICAgICAgIGlmIChzZWxmLnN0YXRlc1t1cmxdID09PSBMT0FERUQpIHtcbiAgICAgICAgICAgIGV4ZWNDYWxsYmFja3MoJ3Jlc29sdmUnLCB1cmwpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc2VsZi5zdGF0ZXNbdXJsXSA9PT0gRkFJTEVEKSB7XG4gICAgICAgICAgICBleGVjQ2FsbGJhY2tzKCdyZWplY3QnLCB1cmwpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHVybCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYuc3RhdGVzW3VybF0gPSBMT0FESU5HO1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYubG9hZFNjcmlwdCh1cmwpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICBzZWxmLnN0YXRlc1t1cmxdID0gTE9BREVEO1xuICAgICAgICAgICAgICBleGVjQ2FsbGJhY2tzKCdyZXNvbHZlJywgdXJsKTtcbiAgICAgICAgICAgICAgY29uc3QgcXVldWUgPSBzZWxmLnF1ZXVlO1xuICAgICAgICAgICAgICBpZiAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHNlbGYucXVldWUgPSBbXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9hZChxdWV1ZSkudGhlbihwcm9jZXNzUmVzdWx0cyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sICgpID0+IHtcbiAgICAgICAgICAgICAgc2VsZi5zdGF0ZXNbdXJsXSA9IEZBSUxFRDtcbiAgICAgICAgICAgICAgZXhlY0NhbGxiYWNrcygncmVqZWN0JywgdXJsKTtcbiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHVybCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgY29uc3QgcHJvY2Vzc1F1ZXVlID0gdXJscyA9PiB7XG4gICAgICAgICAgc2VsZi5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gbG9hZCh1cmxzKS50aGVuKHJlc3VsdHMgPT4ge1xuICAgICAgICAgICAgc2VsZi5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBuZXh0UXVldWVkSXRlbSA9IHNlbGYucXVldWVMb2FkZWRDYWxsYmFja3Muc2hpZnQoKTtcbiAgICAgICAgICAgIE9wdGlvbmFsLmZyb20obmV4dFF1ZXVlZEl0ZW0pLmVhY2goY2FsbCk7XG4gICAgICAgICAgICByZXR1cm4gcHJvY2Vzc1Jlc3VsdHMocmVzdWx0cyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHVuaXF1ZVNjcmlwdHMgPSBzdHJpbmdBcnJheShzY3JpcHRzKTtcbiAgICAgICAgaWYgKHNlbGYubG9hZGluZykge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBzZWxmLnF1ZXVlTG9hZGVkQ2FsbGJhY2tzLnB1c2goKCkgPT4gcHJvY2Vzc1F1ZXVlKHVuaXF1ZVNjcmlwdHMpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHByb2Nlc3NRdWV1ZSh1bmlxdWVTY3JpcHRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBTY3JpcHRMb2FkZXIuU2NyaXB0TG9hZGVyID0gbmV3IFNjcmlwdExvYWRlcigpO1xuXG4gICAgY29uc3QgQ2VsbCA9IGluaXRpYWwgPT4ge1xuICAgICAgbGV0IHZhbHVlID0gaW5pdGlhbDtcbiAgICAgIGNvbnN0IGdldCA9ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHNldCA9IHYgPT4ge1xuICAgICAgICB2YWx1ZSA9IHY7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0LFxuICAgICAgICBzZXRcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IGlzUmF3ID0gc3RyID0+IGlzT2JqZWN0KHN0cikgJiYgaGFzJDIoc3RyLCAncmF3Jyk7XG4gICAgY29uc3QgaXNUb2tlbmlzZWQgPSBzdHIgPT4gaXNBcnJheSQxKHN0cikgJiYgc3RyLmxlbmd0aCA+IDE7XG4gICAgY29uc3QgZGF0YSA9IHt9O1xuICAgIGNvbnN0IGN1cnJlbnRDb2RlID0gQ2VsbCgnZW4nKTtcbiAgICBjb25zdCBnZXRMYW5ndWFnZURhdGEgPSAoKSA9PiBnZXQkYShkYXRhLCBjdXJyZW50Q29kZS5nZXQoKSk7XG4gICAgY29uc3QgZ2V0RGF0YSQxID0gKCkgPT4gbWFwJDIoZGF0YSwgdmFsdWUgPT4gKHsgLi4udmFsdWUgfSkpO1xuICAgIGNvbnN0IHNldENvZGUgPSBuZXdDb2RlID0+IHtcbiAgICAgIGlmIChuZXdDb2RlKSB7XG4gICAgICAgIGN1cnJlbnRDb2RlLnNldChuZXdDb2RlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGdldENvZGUgPSAoKSA9PiBjdXJyZW50Q29kZS5nZXQoKTtcbiAgICBjb25zdCBhZGQkMSA9IChjb2RlLCBpdGVtcykgPT4ge1xuICAgICAgbGV0IGxhbmdEYXRhID0gZGF0YVtjb2RlXTtcbiAgICAgIGlmICghbGFuZ0RhdGEpIHtcbiAgICAgICAgZGF0YVtjb2RlXSA9IGxhbmdEYXRhID0ge307XG4gICAgICB9XG4gICAgICBlYWNoJGYoaXRlbXMsICh0cmFuc2xhdGlvbiwgbmFtZSkgPT4ge1xuICAgICAgICBsYW5nRGF0YVtuYW1lLnRvTG93ZXJDYXNlKCldID0gdHJhbnNsYXRpb247XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHRyYW5zbGF0ZSA9IHRleHQgPT4ge1xuICAgICAgY29uc3QgbGFuZ0RhdGEgPSBnZXRMYW5ndWFnZURhdGEoKS5nZXRPcih7fSk7XG4gICAgICBjb25zdCB0b1N0cmluZyA9IG9iaiA9PiB7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKG9iaikpIHtcbiAgICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICFpc0VtcHR5KG9iaikgPyAnJyArIG9iaiA6ICcnO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGlzRW1wdHkgPSB0ZXh0ID0+IHRleHQgPT09ICcnIHx8IHRleHQgPT09IG51bGwgfHwgdGV4dCA9PT0gdW5kZWZpbmVkO1xuICAgICAgY29uc3QgZ2V0TGFuZ0RhdGEgPSB0ZXh0ID0+IHtcbiAgICAgICAgY29uc3QgdGV4dHN0ciA9IHRvU3RyaW5nKHRleHQpO1xuICAgICAgICByZXR1cm4gZ2V0JGEobGFuZ0RhdGEsIHRleHRzdHIudG9Mb3dlckNhc2UoKSkubWFwKHRvU3RyaW5nKS5nZXRPcih0ZXh0c3RyKTtcbiAgICAgIH07XG4gICAgICBjb25zdCByZW1vdmVDb250ZXh0ID0gc3RyID0+IHN0ci5yZXBsYWNlKC97Y29udGV4dDpcXHcrfSQvLCAnJyk7XG4gICAgICBpZiAoaXNFbXB0eSh0ZXh0KSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgICBpZiAoaXNSYXcodGV4dCkpIHtcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nKHRleHQucmF3KTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1Rva2VuaXNlZCh0ZXh0KSkge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSB0ZXh0LnNsaWNlKDEpO1xuICAgICAgICBjb25zdCBzdWJzdGl0dWVkID0gZ2V0TGFuZ0RhdGEodGV4dFswXSkucmVwbGFjZSgvXFx7KFswLTldKylcXH0vZywgKCQxLCAkMikgPT4gaGFzJDIodmFsdWVzLCAkMikgPyB0b1N0cmluZyh2YWx1ZXNbJDJdKSA6ICQxKTtcbiAgICAgICAgcmV0dXJuIHJlbW92ZUNvbnRleHQoc3Vic3RpdHVlZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVtb3ZlQ29udGV4dChnZXRMYW5nRGF0YSh0ZXh0KSk7XG4gICAgfTtcbiAgICBjb25zdCBpc1J0bCQxID0gKCkgPT4gZ2V0TGFuZ3VhZ2VEYXRhKCkuYmluZChpdGVtcyA9PiBnZXQkYShpdGVtcywgJ19kaXInKSkuZXhpc3RzKGRpciA9PiBkaXIgPT09ICdydGwnKTtcbiAgICBjb25zdCBoYXNDb2RlID0gY29kZSA9PiBoYXMkMihkYXRhLCBjb2RlKTtcbiAgICBjb25zdCBJMThuID0ge1xuICAgICAgZ2V0RGF0YTogZ2V0RGF0YSQxLFxuICAgICAgc2V0Q29kZSxcbiAgICAgIGdldENvZGUsXG4gICAgICBhZGQ6IGFkZCQxLFxuICAgICAgdHJhbnNsYXRlLFxuICAgICAgaXNSdGw6IGlzUnRsJDEsXG4gICAgICBoYXNDb2RlXG4gICAgfTtcblxuICAgIGNvbnN0IEFkZE9uTWFuYWdlciA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgICBjb25zdCB1cmxzID0ge307XG4gICAgICBjb25zdCBsb29rdXAgPSB7fTtcbiAgICAgIGNvbnN0IF9saXN0ZW5lcnMgPSBbXTtcbiAgICAgIGNvbnN0IHJ1bkxpc3RlbmVycyA9IChuYW1lLCBzdGF0ZSkgPT4ge1xuICAgICAgICBjb25zdCBtYXRjaGVkTGlzdGVuZXJzID0gZmlsdGVyJDYoX2xpc3RlbmVycywgbGlzdGVuZXIgPT4gbGlzdGVuZXIubmFtZSA9PT0gbmFtZSAmJiBsaXN0ZW5lci5zdGF0ZSA9PT0gc3RhdGUpO1xuICAgICAgICBlYWNoJGcobWF0Y2hlZExpc3RlbmVycywgbGlzdGVuZXIgPT4gbGlzdGVuZXIucmVzb2x2ZSgpKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBpc0xvYWRlZCA9IG5hbWUgPT4gaGFzJDIodXJscywgbmFtZSk7XG4gICAgICBjb25zdCBpc0FkZGVkID0gbmFtZSA9PiBoYXMkMihsb29rdXAsIG5hbWUpO1xuICAgICAgY29uc3QgZ2V0ID0gbmFtZSA9PiB7XG4gICAgICAgIGlmIChsb29rdXBbbmFtZV0pIHtcbiAgICAgICAgICByZXR1cm4gbG9va3VwW25hbWVdLmluc3RhbmNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9O1xuICAgICAgY29uc3QgbG9hZExhbmd1YWdlUGFjayA9IChuYW1lLCBsYW5ndWFnZXMpID0+IHtcbiAgICAgICAgY29uc3QgbGFuZ3VhZ2UgPSBJMThuLmdldENvZGUoKTtcbiAgICAgICAgY29uc3Qgd3JhcHBlZExhbmd1YWdlcyA9ICcsJyArIChsYW5ndWFnZXMgfHwgJycpICsgJywnO1xuICAgICAgICBpZiAoIWxhbmd1YWdlIHx8IGxhbmd1YWdlcyAmJiB3cmFwcGVkTGFuZ3VhZ2VzLmluZGV4T2YoJywnICsgbGFuZ3VhZ2UgKyAnLCcpID09PSAtMSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBTY3JpcHRMb2FkZXIuU2NyaXB0TG9hZGVyLmFkZCh1cmxzW25hbWVdICsgJy9sYW5ncy8nICsgbGFuZ3VhZ2UgKyAnLmpzJyk7XG4gICAgICB9O1xuICAgICAgY29uc3QgcmVxdWlyZUxhbmdQYWNrID0gKG5hbWUsIGxhbmd1YWdlcykgPT4ge1xuICAgICAgICBpZiAoQWRkT25NYW5hZ2VyLmxhbmd1YWdlTG9hZCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBpZiAoaXNMb2FkZWQobmFtZSkpIHtcbiAgICAgICAgICAgIGxvYWRMYW5ndWFnZVBhY2sobmFtZSwgbGFuZ3VhZ2VzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2FpdEZvcihuYW1lLCAnbG9hZGVkJykudGhlbigoKSA9PiBsb2FkTGFuZ3VhZ2VQYWNrKG5hbWUsIGxhbmd1YWdlcykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGFkZCA9IChpZCwgYWRkT24pID0+IHtcbiAgICAgICAgaXRlbXMucHVzaChhZGRPbik7XG4gICAgICAgIGxvb2t1cFtpZF0gPSB7IGluc3RhbmNlOiBhZGRPbiB9O1xuICAgICAgICBydW5MaXN0ZW5lcnMoaWQsICdhZGRlZCcpO1xuICAgICAgICByZXR1cm4gYWRkT247XG4gICAgICB9O1xuICAgICAgY29uc3QgcmVtb3ZlID0gbmFtZSA9PiB7XG4gICAgICAgIGRlbGV0ZSB1cmxzW25hbWVdO1xuICAgICAgICBkZWxldGUgbG9va3VwW25hbWVdO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGNyZWF0ZVVybCA9IChiYXNlVXJsLCBkZXApID0+IHtcbiAgICAgICAgaWYgKGlzU3RyaW5nKGRlcCkpIHtcbiAgICAgICAgICByZXR1cm4gaXNTdHJpbmcoYmFzZVVybCkgPyB7XG4gICAgICAgICAgICBwcmVmaXg6ICcnLFxuICAgICAgICAgICAgcmVzb3VyY2U6IGRlcCxcbiAgICAgICAgICAgIHN1ZmZpeDogJydcbiAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgcHJlZml4OiBiYXNlVXJsLnByZWZpeCxcbiAgICAgICAgICAgIHJlc291cmNlOiBkZXAsXG4gICAgICAgICAgICBzdWZmaXg6IGJhc2VVcmwuc3VmZml4XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZGVwO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgbG9hZCA9IChuYW1lLCBhZGRPblVybCkgPT4ge1xuICAgICAgICBpZiAodXJsc1tuYW1lXSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdXJsU3RyaW5nID0gaXNTdHJpbmcoYWRkT25VcmwpID8gYWRkT25VcmwgOiBhZGRPblVybC5wcmVmaXggKyBhZGRPblVybC5yZXNvdXJjZSArIGFkZE9uVXJsLnN1ZmZpeDtcbiAgICAgICAgaWYgKHVybFN0cmluZy5pbmRleE9mKCcvJykgIT09IDAgJiYgdXJsU3RyaW5nLmluZGV4T2YoJzovLycpID09PSAtMSkge1xuICAgICAgICAgIHVybFN0cmluZyA9IEFkZE9uTWFuYWdlci5iYXNlVVJMICsgJy8nICsgdXJsU3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIHVybHNbbmFtZV0gPSB1cmxTdHJpbmcuc3Vic3RyaW5nKDAsIHVybFN0cmluZy5sYXN0SW5kZXhPZignLycpKTtcbiAgICAgICAgY29uc3QgZG9uZSA9ICgpID0+IHtcbiAgICAgICAgICBydW5MaXN0ZW5lcnMobmFtZSwgJ2xvYWRlZCcpO1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGxvb2t1cFtuYW1lXSkge1xuICAgICAgICAgIHJldHVybiBkb25lKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFNjcmlwdExvYWRlci5TY3JpcHRMb2FkZXIuYWRkKHVybFN0cmluZykudGhlbihkb25lKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHdhaXRGb3IgPSAobmFtZSwgc3RhdGUgPSAnYWRkZWQnKSA9PiB7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gJ2FkZGVkJyAmJiBpc0FkZGVkKG5hbWUpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSAnbG9hZGVkJyAmJiBpc0xvYWRlZChuYW1lKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICBfbGlzdGVuZXJzLnB1c2goe1xuICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgICAgcmVzb2x2ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpdGVtcyxcbiAgICAgICAgdXJscyxcbiAgICAgICAgbG9va3VwLFxuICAgICAgICBnZXQsXG4gICAgICAgIHJlcXVpcmVMYW5nUGFjayxcbiAgICAgICAgYWRkLFxuICAgICAgICByZW1vdmUsXG4gICAgICAgIGNyZWF0ZVVybCxcbiAgICAgICAgbG9hZCxcbiAgICAgICAgd2FpdEZvclxuICAgICAgfTtcbiAgICB9O1xuICAgIEFkZE9uTWFuYWdlci5sYW5ndWFnZUxvYWQgPSB0cnVlO1xuICAgIEFkZE9uTWFuYWdlci5iYXNlVVJMID0gJyc7XG4gICAgQWRkT25NYW5hZ2VyLlBsdWdpbk1hbmFnZXIgPSBBZGRPbk1hbmFnZXIoKTtcbiAgICBBZGRPbk1hbmFnZXIuVGhlbWVNYW5hZ2VyID0gQWRkT25NYW5hZ2VyKCk7XG4gICAgQWRkT25NYW5hZ2VyLk1vZGVsTWFuYWdlciA9IEFkZE9uTWFuYWdlcigpO1xuXG4gICAgY29uc3Qgc2luZ2xldG9uID0gZG9SZXZva2UgPT4ge1xuICAgICAgY29uc3Qgc3ViamVjdCA9IENlbGwoT3B0aW9uYWwubm9uZSgpKTtcbiAgICAgIGNvbnN0IHJldm9rZSA9ICgpID0+IHN1YmplY3QuZ2V0KCkuZWFjaChkb1Jldm9rZSk7XG4gICAgICBjb25zdCBjbGVhciA9ICgpID0+IHtcbiAgICAgICAgcmV2b2tlKCk7XG4gICAgICAgIHN1YmplY3Quc2V0KE9wdGlvbmFsLm5vbmUoKSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgaXNTZXQgPSAoKSA9PiBzdWJqZWN0LmdldCgpLmlzU29tZSgpO1xuICAgICAgY29uc3QgZ2V0ID0gKCkgPT4gc3ViamVjdC5nZXQoKTtcbiAgICAgIGNvbnN0IHNldCA9IHMgPT4ge1xuICAgICAgICByZXZva2UoKTtcbiAgICAgICAgc3ViamVjdC5zZXQoT3B0aW9uYWwuc29tZShzKSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2xlYXIsXG4gICAgICAgIGlzU2V0LFxuICAgICAgICBnZXQsXG4gICAgICAgIHNldFxuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IHZhbHVlJDIgPSAoKSA9PiB7XG4gICAgICBjb25zdCBzdWJqZWN0ID0gc2luZ2xldG9uKG5vb3ApO1xuICAgICAgY29uc3Qgb24gPSBmID0+IHN1YmplY3QuZ2V0KCkuZWFjaChmKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnN1YmplY3QsXG4gICAgICAgIG9uXG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCBmaXJzdCQxID0gKGZuLCByYXRlKSA9PiB7XG4gICAgICBsZXQgdGltZXIgPSBudWxsO1xuICAgICAgY29uc3QgY2FuY2VsID0gKCkgPT4ge1xuICAgICAgICBpZiAoIWlzTnVsbCh0aW1lcikpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHRocm90dGxlID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgaWYgKGlzTnVsbCh0aW1lcikpIHtcbiAgICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgfSwgcmF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjYW5jZWwsXG4gICAgICAgIHRocm90dGxlXG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgbGFzdCQxID0gKGZuLCByYXRlKSA9PiB7XG4gICAgICBsZXQgdGltZXIgPSBudWxsO1xuICAgICAgY29uc3QgY2FuY2VsID0gKCkgPT4ge1xuICAgICAgICBpZiAoIWlzTnVsbCh0aW1lcikpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHRocm90dGxlID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgIHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICB9LCByYXRlKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjYW5jZWwsXG4gICAgICAgIHRocm90dGxlXG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCBkZXNjZW5kYW50cyQxID0gKHNjb3BlLCBwcmVkaWNhdGUpID0+IHtcbiAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgIGVhY2gkZyhjaGlsZHJlbihzY29wZSksIHggPT4ge1xuICAgICAgICBpZiAocHJlZGljYXRlKHgpKSB7XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChbeF0pO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoZGVzY2VuZGFudHMkMSh4LCBwcmVkaWNhdGUpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgY29uc3QgZGVzY2VuZGFudHMgPSAoc2NvcGUsIHNlbGVjdG9yKSA9PiBhbGwoc2VsZWN0b3IsIHNjb3BlKTtcblxuICAgIGNvbnN0IGFubm90YXRpb24gPSBjb25zdGFudCgnbWNlLWFubm90YXRpb24nKTtcbiAgICBjb25zdCBkYXRhQW5ub3RhdGlvbiA9IGNvbnN0YW50KCdkYXRhLW1jZS1hbm5vdGF0aW9uJyk7XG4gICAgY29uc3QgZGF0YUFubm90YXRpb25JZCA9IGNvbnN0YW50KCdkYXRhLW1jZS1hbm5vdGF0aW9uLXVpZCcpO1xuICAgIGNvbnN0IGRhdGFBbm5vdGF0aW9uQWN0aXZlID0gY29uc3RhbnQoJ2RhdGEtbWNlLWFubm90YXRpb24tYWN0aXZlJyk7XG5cbiAgICBjb25zdCBpZGVudGlmeSA9IChlZGl0b3IsIGFubm90YXRpb25OYW1lKSA9PiB7XG4gICAgICBjb25zdCBybmcgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpO1xuICAgICAgY29uc3Qgc3RhcnQgPSBTdWdhckVsZW1lbnQuZnJvbURvbShybmcuc3RhcnRDb250YWluZXIpO1xuICAgICAgY29uc3Qgcm9vdCA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVkaXRvci5nZXRCb2R5KCkpO1xuICAgICAgY29uc3Qgc2VsZWN0b3IgPSBhbm5vdGF0aW9uTmFtZS5mb2xkKCgpID0+ICcuJyArIGFubm90YXRpb24oKSwgYW4gPT4gYFskeyBkYXRhQW5ub3RhdGlvbigpIH09XCIkeyBhbiB9XCJdYCk7XG4gICAgICBjb25zdCBuZXdTdGFydCA9IGNoaWxkJDEoc3RhcnQsIHJuZy5zdGFydE9mZnNldCkuZ2V0T3Ioc3RhcnQpO1xuICAgICAgY29uc3QgY2xvc2VzdCA9IGNsb3Nlc3QkMyhuZXdTdGFydCwgc2VsZWN0b3IsIG4gPT4gZXEobiwgcm9vdCkpO1xuICAgICAgY29uc3QgZ2V0QXR0ciA9IChjLCBwcm9wZXJ0eSkgPT4ge1xuICAgICAgICBpZiAoaGFzJDEoYywgcHJvcGVydHkpKSB7XG4gICAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoZ2V0JDkoYywgcHJvcGVydHkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGNsb3Nlc3QuYmluZChjID0+IGdldEF0dHIoYywgYCR7IGRhdGFBbm5vdGF0aW9uSWQoKSB9YCkuYmluZCh1aWQgPT4gZ2V0QXR0cihjLCBgJHsgZGF0YUFubm90YXRpb24oKSB9YCkubWFwKG5hbWUgPT4ge1xuICAgICAgICBjb25zdCBlbGVtZW50cyA9IGZpbmRNYXJrZXJzKGVkaXRvciwgdWlkKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB1aWQsXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBlbGVtZW50c1xuICAgICAgICB9O1xuICAgICAgfSkpKTtcbiAgICB9O1xuICAgIGNvbnN0IGlzQW5ub3RhdGlvbiA9IGVsZW0gPT4gaXNFbGVtZW50JDcoZWxlbSkgJiYgaGFzKGVsZW0sIGFubm90YXRpb24oKSk7XG4gICAgY29uc3QgZmluZE1hcmtlcnMgPSAoZWRpdG9yLCB1aWQpID0+IHtcbiAgICAgIGNvbnN0IGJvZHkgPSBTdWdhckVsZW1lbnQuZnJvbURvbShlZGl0b3IuZ2V0Qm9keSgpKTtcbiAgICAgIHJldHVybiBkZXNjZW5kYW50cyhib2R5LCBgWyR7IGRhdGFBbm5vdGF0aW9uSWQoKSB9PVwiJHsgdWlkIH1cIl1gKTtcbiAgICB9O1xuICAgIGNvbnN0IGZpbmRBbGwgPSAoZWRpdG9yLCBuYW1lKSA9PiB7XG4gICAgICBjb25zdCBib2R5ID0gU3VnYXJFbGVtZW50LmZyb21Eb20oZWRpdG9yLmdldEJvZHkoKSk7XG4gICAgICBjb25zdCBtYXJrZXJzID0gZGVzY2VuZGFudHMoYm9keSwgYFskeyBkYXRhQW5ub3RhdGlvbigpIH09XCIkeyBuYW1lIH1cIl1gKTtcbiAgICAgIGNvbnN0IGRpcmVjdG9yeSA9IHt9O1xuICAgICAgZWFjaCRnKG1hcmtlcnMsIG0gPT4ge1xuICAgICAgICBjb25zdCB1aWQgPSBnZXQkOShtLCBkYXRhQW5ub3RhdGlvbklkKCkpO1xuICAgICAgICBjb25zdCBub2Rlc0FscmVhZHkgPSBnZXQkYShkaXJlY3RvcnksIHVpZCkuZ2V0T3IoW10pO1xuICAgICAgICBkaXJlY3RvcnlbdWlkXSA9IG5vZGVzQWxyZWFkeS5jb25jYXQoW21dKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGRpcmVjdG9yeTtcbiAgICB9O1xuXG4gICAgY29uc3Qgc2V0dXAkeCA9IChlZGl0b3IsIHJlZ2lzdHJ5KSA9PiB7XG4gICAgICBjb25zdCBjaGFuZ2VDYWxsYmFja3MgPSBDZWxsKHt9KTtcbiAgICAgIGNvbnN0IGluaXREYXRhID0gKCkgPT4gKHtcbiAgICAgICAgbGlzdGVuZXJzOiBbXSxcbiAgICAgICAgcHJldmlvdXM6IHZhbHVlJDIoKVxuICAgICAgfSk7XG4gICAgICBjb25zdCB3aXRoQ2FsbGJhY2tzID0gKG5hbWUsIGYpID0+IHtcbiAgICAgICAgdXBkYXRlQ2FsbGJhY2tzKG5hbWUsIGRhdGEgPT4ge1xuICAgICAgICAgIGYoZGF0YSk7XG4gICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHVwZGF0ZUNhbGxiYWNrcyA9IChuYW1lLCBmKSA9PiB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrTWFwID0gY2hhbmdlQ2FsbGJhY2tzLmdldCgpO1xuICAgICAgICBjb25zdCBkYXRhID0gZ2V0JGEoY2FsbGJhY2tNYXAsIG5hbWUpLmdldE9yVGh1bmsoaW5pdERhdGEpO1xuICAgICAgICBjb25zdCBvdXRwdXREYXRhID0gZihkYXRhKTtcbiAgICAgICAgY2FsbGJhY2tNYXBbbmFtZV0gPSBvdXRwdXREYXRhO1xuICAgICAgICBjaGFuZ2VDYWxsYmFja3Muc2V0KGNhbGxiYWNrTWFwKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBmaXJlQ2FsbGJhY2tzID0gKG5hbWUsIHVpZCwgZWxlbWVudHMpID0+IHtcbiAgICAgICAgd2l0aENhbGxiYWNrcyhuYW1lLCBkYXRhID0+IHtcbiAgICAgICAgICBlYWNoJGcoZGF0YS5saXN0ZW5lcnMsIGYgPT4gZih0cnVlLCBuYW1lLCB7XG4gICAgICAgICAgICB1aWQsXG4gICAgICAgICAgICBub2RlczogbWFwJDMoZWxlbWVudHMsIGVsZW0gPT4gZWxlbS5kb20pXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBjb25zdCBmaXJlTm9Bbm5vdGF0aW9uID0gbmFtZSA9PiB7XG4gICAgICAgIHdpdGhDYWxsYmFja3MobmFtZSwgZGF0YSA9PiB7XG4gICAgICAgICAgZWFjaCRnKGRhdGEubGlzdGVuZXJzLCBmID0+IGYoZmFsc2UsIG5hbWUpKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgdG9nZ2xlQWN0aXZlQXR0ciA9ICh1aWQsIHN0YXRlKSA9PiB7XG4gICAgICAgIGVhY2gkZyhmaW5kTWFya2VycyhlZGl0b3IsIHVpZCksIHNwYW4gPT4ge1xuICAgICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgICAgc2V0JDIoc3BhbiwgZGF0YUFubm90YXRpb25BY3RpdmUoKSwgJ3RydWUnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVtb3ZlJGEoc3BhbiwgZGF0YUFubm90YXRpb25BY3RpdmUoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBjb25zdCBvbk5vZGVDaGFuZ2UgPSBsYXN0JDEoKCkgPT4ge1xuICAgICAgICBjb25zdCBhbm5vdGF0aW9ucyA9IHNvcnQocmVnaXN0cnkuZ2V0TmFtZXMoKSk7XG4gICAgICAgIGVhY2gkZyhhbm5vdGF0aW9ucywgbmFtZSA9PiB7XG4gICAgICAgICAgdXBkYXRlQ2FsbGJhY2tzKG5hbWUsIGRhdGEgPT4ge1xuICAgICAgICAgICAgY29uc3QgcHJldiA9IGRhdGEucHJldmlvdXMuZ2V0KCk7XG4gICAgICAgICAgICBpZGVudGlmeShlZGl0b3IsIE9wdGlvbmFsLnNvbWUobmFtZSkpLmZvbGQoKCkgPT4ge1xuICAgICAgICAgICAgICBwcmV2LmVhY2godWlkID0+IHtcbiAgICAgICAgICAgICAgICBmaXJlTm9Bbm5vdGF0aW9uKG5hbWUpO1xuICAgICAgICAgICAgICAgIGRhdGEucHJldmlvdXMuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICB0b2dnbGVBY3RpdmVBdHRyKHVpZCwgZmFsc2UpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sICh7dWlkLCBuYW1lLCBlbGVtZW50c30pID0+IHtcbiAgICAgICAgICAgICAgaWYgKCFpcyQyKHByZXYsIHVpZCkpIHtcbiAgICAgICAgICAgICAgICBwcmV2LmVhY2godWlkID0+IHRvZ2dsZUFjdGl2ZUF0dHIodWlkLCBmYWxzZSkpO1xuICAgICAgICAgICAgICAgIGZpcmVDYWxsYmFja3MobmFtZSwgdWlkLCBlbGVtZW50cyk7XG4gICAgICAgICAgICAgICAgZGF0YS5wcmV2aW91cy5zZXQodWlkKTtcbiAgICAgICAgICAgICAgICB0b2dnbGVBY3RpdmVBdHRyKHVpZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgcHJldmlvdXM6IGRhdGEucHJldmlvdXMsXG4gICAgICAgICAgICAgIGxpc3RlbmVyczogZGF0YS5saXN0ZW5lcnNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSwgMzApO1xuICAgICAgZWRpdG9yLm9uKCdyZW1vdmUnLCAoKSA9PiB7XG4gICAgICAgIG9uTm9kZUNoYW5nZS5jYW5jZWwoKTtcbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLm9uKCdOb2RlQ2hhbmdlJywgKCkgPT4ge1xuICAgICAgICBvbk5vZGVDaGFuZ2UudGhyb3R0bGUoKTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgYWRkTGlzdGVuZXIgPSAobmFtZSwgZikgPT4ge1xuICAgICAgICB1cGRhdGVDYWxsYmFja3MobmFtZSwgZGF0YSA9PiAoe1xuICAgICAgICAgIHByZXZpb3VzOiBkYXRhLnByZXZpb3VzLFxuICAgICAgICAgIGxpc3RlbmVyczogZGF0YS5saXN0ZW5lcnMuY29uY2F0KFtmXSlcbiAgICAgICAgfSkpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiB7IGFkZExpc3RlbmVyIH07XG4gICAgfTtcblxuICAgIGNvbnN0IHNldHVwJHcgPSAoZWRpdG9yLCByZWdpc3RyeSkgPT4ge1xuICAgICAgY29uc3QgaWRlbnRpZnlQYXJzZXJOb2RlID0gc3BhbiA9PiBPcHRpb25hbC5mcm9tKHNwYW4uYXR0cihkYXRhQW5ub3RhdGlvbigpKSkuYmluZChyZWdpc3RyeS5sb29rdXApO1xuICAgICAgZWRpdG9yLnNlcmlhbGl6ZXIuYWRkVGVtcEF0dHIoZGF0YUFubm90YXRpb25BY3RpdmUoKSk7XG4gICAgICBlZGl0b3Iuc2VyaWFsaXplci5hZGROb2RlRmlsdGVyKCdzcGFuJywgc3BhbnMgPT4ge1xuICAgICAgICBlYWNoJGcoc3BhbnMsIHNwYW4gPT4ge1xuICAgICAgICAgIGlkZW50aWZ5UGFyc2VyTm9kZShzcGFuKS5lYWNoKHNldHRpbmdzID0+IHtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5wZXJzaXN0ZW50ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICBzcGFuLnVud3JhcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCBjcmVhdGUkYiA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGFubm90YXRpb25zID0ge307XG4gICAgICBjb25zdCByZWdpc3RlciA9IChuYW1lLCBzZXR0aW5ncykgPT4ge1xuICAgICAgICBhbm5vdGF0aW9uc1tuYW1lXSA9IHtcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHNldHRpbmdzXG4gICAgICAgIH07XG4gICAgICB9O1xuICAgICAgY29uc3QgbG9va3VwID0gbmFtZSA9PiBnZXQkYShhbm5vdGF0aW9ucywgbmFtZSkubWFwKGEgPT4gYS5zZXR0aW5ncyk7XG4gICAgICBjb25zdCBnZXROYW1lcyA9ICgpID0+IGtleXMoYW5ub3RhdGlvbnMpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVnaXN0ZXIsXG4gICAgICAgIGxvb2t1cCxcbiAgICAgICAgZ2V0TmFtZXNcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGxldCB1bmlxdWUgPSAwO1xuICAgIGNvbnN0IGdlbmVyYXRlJDEgPSBwcmVmaXggPT4ge1xuICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICBjb25zdCB0aW1lID0gZGF0ZS5nZXRUaW1lKCk7XG4gICAgICBjb25zdCByYW5kb20gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwMDAwKTtcbiAgICAgIHVuaXF1ZSsrO1xuICAgICAgcmV0dXJuIHByZWZpeCArICdfJyArIHJhbmRvbSArIHVuaXF1ZSArIFN0cmluZyh0aW1lKTtcbiAgICB9O1xuXG4gICAgY29uc3QgYWRkID0gKGVsZW1lbnQsIGNsYXNzZXMpID0+IHtcbiAgICAgIGVhY2gkZyhjbGFzc2VzLCB4ID0+IHtcbiAgICAgICAgYWRkJDIoZWxlbWVudCwgeCk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3QgY2xvbmUkMiA9IChvcmlnaW5hbCwgaXNEZWVwKSA9PiBTdWdhckVsZW1lbnQuZnJvbURvbShvcmlnaW5hbC5kb20uY2xvbmVOb2RlKGlzRGVlcCkpO1xuICAgIGNvbnN0IHNoYWxsb3ckMSA9IG9yaWdpbmFsID0+IGNsb25lJDIob3JpZ2luYWwsIGZhbHNlKTtcbiAgICBjb25zdCBkZWVwJDEgPSBvcmlnaW5hbCA9PiBjbG9uZSQyKG9yaWdpbmFsLCB0cnVlKTtcbiAgICBjb25zdCBzaGFsbG93QXMgPSAob3JpZ2luYWwsIHRhZykgPT4ge1xuICAgICAgY29uc3QgbnUgPSBTdWdhckVsZW1lbnQuZnJvbVRhZyh0YWcpO1xuICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGNsb25lJDQob3JpZ2luYWwpO1xuICAgICAgc2V0QWxsJDEobnUsIGF0dHJpYnV0ZXMpO1xuICAgICAgcmV0dXJuIG51O1xuICAgIH07XG4gICAgY29uc3QgbXV0YXRlID0gKG9yaWdpbmFsLCB0YWcpID0+IHtcbiAgICAgIGNvbnN0IG51ID0gc2hhbGxvd0FzKG9yaWdpbmFsLCB0YWcpO1xuICAgICAgYWZ0ZXIkNChvcmlnaW5hbCwgbnUpO1xuICAgICAgY29uc3QgY2hpbGRyZW4kMSA9IGNoaWxkcmVuKG9yaWdpbmFsKTtcbiAgICAgIGFwcGVuZChudSwgY2hpbGRyZW4kMSk7XG4gICAgICByZW1vdmUkNShvcmlnaW5hbCk7XG4gICAgICByZXR1cm4gbnU7XG4gICAgfTtcblxuICAgIGNvbnN0IFRleHRXYWxrZXIgPSAoc3RhcnROb2RlLCByb290Tm9kZSwgaXNCb3VuZGFyeSA9IG5ldmVyKSA9PiB7XG4gICAgICBjb25zdCB3YWxrZXIgPSBuZXcgRG9tVHJlZVdhbGtlcihzdGFydE5vZGUsIHJvb3ROb2RlKTtcbiAgICAgIGNvbnN0IHdhbGsgPSBkaXJlY3Rpb24gPT4ge1xuICAgICAgICBsZXQgbmV4dDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIG5leHQgPSB3YWxrZXJbZGlyZWN0aW9uXSgpO1xuICAgICAgICB9IHdoaWxlIChuZXh0ICYmICFpc1RleHQkOChuZXh0KSAmJiAhaXNCb3VuZGFyeShuZXh0KSk7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5mcm9tKG5leHQpLmZpbHRlcihpc1RleHQkOCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY3VycmVudDogKCkgPT4gT3B0aW9uYWwuZnJvbSh3YWxrZXIuY3VycmVudCgpKS5maWx0ZXIoaXNUZXh0JDgpLFxuICAgICAgICBuZXh0OiAoKSA9PiB3YWxrKCduZXh0JyksXG4gICAgICAgIHByZXY6ICgpID0+IHdhbGsoJ3ByZXYnKSxcbiAgICAgICAgcHJldjI6ICgpID0+IHdhbGsoJ3ByZXYyJylcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IFRleHRTZWVrZXIgPSAoZG9tLCBpc0JvdW5kYXJ5KSA9PiB7XG4gICAgICBjb25zdCBpc0Jsb2NrQm91bmRhcnkgPSBpc0JvdW5kYXJ5ID8gaXNCb3VuZGFyeSA6IG5vZGUgPT4gZG9tLmlzQmxvY2sobm9kZSkgfHwgaXNCciQ1KG5vZGUpIHx8IGlzQ29udGVudEVkaXRhYmxlRmFsc2UkYShub2RlKTtcbiAgICAgIGNvbnN0IHdhbGsgPSAobm9kZSwgb2Zmc2V0LCB3YWxrZXIsIHByb2Nlc3MpID0+IHtcbiAgICAgICAgaWYgKGlzVGV4dCQ4KG5vZGUpKSB7XG4gICAgICAgICAgY29uc3QgbmV3T2Zmc2V0ID0gcHJvY2Vzcyhub2RlLCBvZmZzZXQsIG5vZGUuZGF0YSk7XG4gICAgICAgICAgaWYgKG5ld09mZnNldCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKHtcbiAgICAgICAgICAgICAgY29udGFpbmVyOiBub2RlLFxuICAgICAgICAgICAgICBvZmZzZXQ6IG5ld09mZnNldFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3YWxrZXIoKS5iaW5kKG5leHQgPT4gd2FsayhuZXh0LmNvbnRhaW5lciwgbmV4dC5vZmZzZXQsIHdhbGtlciwgcHJvY2VzcykpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGJhY2t3YXJkcyA9IChub2RlLCBvZmZzZXQsIHByb2Nlc3MsIHJvb3QpID0+IHtcbiAgICAgICAgY29uc3Qgd2Fsa2VyID0gVGV4dFdhbGtlcihub2RlLCByb290LCBpc0Jsb2NrQm91bmRhcnkpO1xuICAgICAgICByZXR1cm4gd2Fsayhub2RlLCBvZmZzZXQsICgpID0+IHdhbGtlci5wcmV2KCkubWFwKHByZXYgPT4gKHtcbiAgICAgICAgICBjb250YWluZXI6IHByZXYsXG4gICAgICAgICAgb2Zmc2V0OiBwcmV2Lmxlbmd0aFxuICAgICAgICB9KSksIHByb2Nlc3MpLmdldE9yTnVsbCgpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGZvcndhcmRzID0gKG5vZGUsIG9mZnNldCwgcHJvY2Vzcywgcm9vdCkgPT4ge1xuICAgICAgICBjb25zdCB3YWxrZXIgPSBUZXh0V2Fsa2VyKG5vZGUsIHJvb3QsIGlzQmxvY2tCb3VuZGFyeSk7XG4gICAgICAgIHJldHVybiB3YWxrKG5vZGUsIG9mZnNldCwgKCkgPT4gd2Fsa2VyLm5leHQoKS5tYXAobmV4dCA9PiAoe1xuICAgICAgICAgIGNvbnRhaW5lcjogbmV4dCxcbiAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgfSkpLCBwcm9jZXNzKS5nZXRPck51bGwoKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBiYWNrd2FyZHMsXG4gICAgICAgIGZvcndhcmRzXG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCByb3VuZCQxID0gTWF0aC5yb3VuZDtcbiAgICBjb25zdCBjbG9uZSQxID0gcmVjdCA9PiB7XG4gICAgICBpZiAoIXJlY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICBib3R0b206IDAsXG4gICAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgaGVpZ2h0OiAwXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiByb3VuZCQxKHJlY3QubGVmdCksXG4gICAgICAgIHRvcDogcm91bmQkMShyZWN0LnRvcCksXG4gICAgICAgIGJvdHRvbTogcm91bmQkMShyZWN0LmJvdHRvbSksXG4gICAgICAgIHJpZ2h0OiByb3VuZCQxKHJlY3QucmlnaHQpLFxuICAgICAgICB3aWR0aDogcm91bmQkMShyZWN0LndpZHRoKSxcbiAgICAgICAgaGVpZ2h0OiByb3VuZCQxKHJlY3QuaGVpZ2h0KVxuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IGNvbGxhcHNlID0gKHJlY3QsIHRvU3RhcnQpID0+IHtcbiAgICAgIHJlY3QgPSBjbG9uZSQxKHJlY3QpO1xuICAgICAgaWYgKHRvU3RhcnQpIHtcbiAgICAgICAgcmVjdC5yaWdodCA9IHJlY3QubGVmdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlY3QubGVmdCA9IHJlY3QubGVmdCArIHJlY3Qud2lkdGg7XG4gICAgICAgIHJlY3QucmlnaHQgPSByZWN0LmxlZnQ7XG4gICAgICB9XG4gICAgICByZWN0LndpZHRoID0gMDtcbiAgICAgIHJldHVybiByZWN0O1xuICAgIH07XG4gICAgY29uc3QgaXNFcXVhbCA9IChyZWN0MSwgcmVjdDIpID0+IHJlY3QxLmxlZnQgPT09IHJlY3QyLmxlZnQgJiYgcmVjdDEudG9wID09PSByZWN0Mi50b3AgJiYgcmVjdDEuYm90dG9tID09PSByZWN0Mi5ib3R0b20gJiYgcmVjdDEucmlnaHQgPT09IHJlY3QyLnJpZ2h0O1xuICAgIGNvbnN0IGlzVmFsaWRPdmVyZmxvdyA9IChvdmVyZmxvd1ksIHJlY3QxLCByZWN0MikgPT4gb3ZlcmZsb3dZID49IDAgJiYgb3ZlcmZsb3dZIDw9IE1hdGgubWluKHJlY3QxLmhlaWdodCwgcmVjdDIuaGVpZ2h0KSAvIDI7XG4gICAgY29uc3QgaXNBYm92ZSQxID0gKHJlY3QxLCByZWN0MikgPT4ge1xuICAgICAgY29uc3QgaGFsZkhlaWdodCA9IE1hdGgubWluKHJlY3QyLmhlaWdodCAvIDIsIHJlY3QxLmhlaWdodCAvIDIpO1xuICAgICAgaWYgKHJlY3QxLmJvdHRvbSAtIGhhbGZIZWlnaHQgPCByZWN0Mi50b3ApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAocmVjdDEudG9wID4gcmVjdDIuYm90dG9tKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc1ZhbGlkT3ZlcmZsb3cocmVjdDIudG9wIC0gcmVjdDEuYm90dG9tLCByZWN0MSwgcmVjdDIpO1xuICAgIH07XG4gICAgY29uc3QgaXNCZWxvdyQxID0gKHJlY3QxLCByZWN0MikgPT4ge1xuICAgICAgaWYgKHJlY3QxLnRvcCA+IHJlY3QyLmJvdHRvbSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWN0MS5ib3R0b20gPCByZWN0Mi50b3ApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzVmFsaWRPdmVyZmxvdyhyZWN0Mi5ib3R0b20gLSByZWN0MS50b3AsIHJlY3QxLCByZWN0Mik7XG4gICAgfTtcbiAgICBjb25zdCBjb250YWluc1hZID0gKHJlY3QsIGNsaWVudFgsIGNsaWVudFkpID0+IGNsaWVudFggPj0gcmVjdC5sZWZ0ICYmIGNsaWVudFggPD0gcmVjdC5yaWdodCAmJiBjbGllbnRZID49IHJlY3QudG9wICYmIGNsaWVudFkgPD0gcmVjdC5ib3R0b207XG4gICAgY29uc3QgYm91bmRpbmdDbGllbnRSZWN0RnJvbVJlY3RzID0gcmVjdHMgPT4ge1xuICAgICAgcmV0dXJuIGZvbGRsKHJlY3RzLCAoYWNjLCByZWN0KSA9PiB7XG4gICAgICAgIHJldHVybiBhY2MuZm9sZCgoKSA9PiBPcHRpb25hbC5zb21lKHJlY3QpLCBwcmV2UmVjdCA9PiB7XG4gICAgICAgICAgY29uc3QgbGVmdCA9IE1hdGgubWluKHJlY3QubGVmdCwgcHJldlJlY3QubGVmdCk7XG4gICAgICAgICAgY29uc3QgdG9wID0gTWF0aC5taW4ocmVjdC50b3AsIHByZXZSZWN0LnRvcCk7XG4gICAgICAgICAgY29uc3QgcmlnaHQgPSBNYXRoLm1heChyZWN0LnJpZ2h0LCBwcmV2UmVjdC5yaWdodCk7XG4gICAgICAgICAgY29uc3QgYm90dG9tID0gTWF0aC5tYXgocmVjdC5ib3R0b20sIHByZXZSZWN0LmJvdHRvbSk7XG4gICAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoe1xuICAgICAgICAgICAgdG9wLFxuICAgICAgICAgICAgcmlnaHQsXG4gICAgICAgICAgICBib3R0b20sXG4gICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgd2lkdGg6IHJpZ2h0IC0gbGVmdCxcbiAgICAgICAgICAgIGhlaWdodDogYm90dG9tIC0gdG9wXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSwgT3B0aW9uYWwubm9uZSgpKTtcbiAgICB9O1xuICAgIGNvbnN0IGRpc3RhbmNlVG9SZWN0RWRnZUZyb21YWSA9IChyZWN0LCB4LCB5KSA9PiB7XG4gICAgICBjb25zdCBjeCA9IE1hdGgubWF4KE1hdGgubWluKHgsIHJlY3QubGVmdCArIHJlY3Qud2lkdGgpLCByZWN0LmxlZnQpO1xuICAgICAgY29uc3QgY3kgPSBNYXRoLm1heChNYXRoLm1pbih5LCByZWN0LnRvcCArIHJlY3QuaGVpZ2h0KSwgcmVjdC50b3ApO1xuICAgICAgcmV0dXJuIE1hdGguc3FydCgoeCAtIGN4KSAqICh4IC0gY3gpICsgKHkgLSBjeSkgKiAoeSAtIGN5KSk7XG4gICAgfTtcbiAgICBjb25zdCBvdmVybGFwWSA9IChyMSwgcjIpID0+IE1hdGgubWF4KDAsIE1hdGgubWluKHIxLmJvdHRvbSwgcjIuYm90dG9tKSAtIE1hdGgubWF4KHIxLnRvcCwgcjIudG9wKSk7XG5cbiAgICBjb25zdCBjbGFtcCQyID0gKHZhbHVlLCBtaW4sIG1heCkgPT4gTWF0aC5taW4oTWF0aC5tYXgodmFsdWUsIG1pbiksIG1heCk7XG5cbiAgICBjb25zdCBnZXRTZWxlY3RlZE5vZGUgPSByYW5nZSA9PiB7XG4gICAgICBjb25zdCBzdGFydENvbnRhaW5lciA9IHJhbmdlLnN0YXJ0Q29udGFpbmVyLCBzdGFydE9mZnNldCA9IHJhbmdlLnN0YXJ0T2Zmc2V0O1xuICAgICAgaWYgKHN0YXJ0Q29udGFpbmVyLmhhc0NoaWxkTm9kZXMoKSAmJiByYW5nZS5lbmRPZmZzZXQgPT09IHN0YXJ0T2Zmc2V0ICsgMSkge1xuICAgICAgICByZXR1cm4gc3RhcnRDb250YWluZXIuY2hpbGROb2Rlc1tzdGFydE9mZnNldF07XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIGNvbnN0IGdldE5vZGUkMSA9IChjb250YWluZXIsIG9mZnNldCkgPT4ge1xuICAgICAgaWYgKGlzRWxlbWVudCQ2KGNvbnRhaW5lcikgJiYgY29udGFpbmVyLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICBjb25zdCBjaGlsZE5vZGVzID0gY29udGFpbmVyLmNoaWxkTm9kZXM7XG4gICAgICAgIGNvbnN0IHNhZmVPZmZzZXQgPSBjbGFtcCQyKG9mZnNldCwgMCwgY2hpbGROb2Rlcy5sZW5ndGggLSAxKTtcbiAgICAgICAgcmV0dXJuIGNoaWxkTm9kZXNbc2FmZU9mZnNldF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZ2V0Tm9kZVVuc2FmZSA9IChjb250YWluZXIsIG9mZnNldCkgPT4ge1xuICAgICAgaWYgKG9mZnNldCA8IDAgJiYgaXNFbGVtZW50JDYoY29udGFpbmVyKSAmJiBjb250YWluZXIuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZ2V0Tm9kZSQxKGNvbnRhaW5lciwgb2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgZXh0ZW5kaW5nQ2hhcnMgPSBuZXcgUmVnRXhwKCdbXFx1MDMwMC1cXHUwMzZmXFx1MDQ4My1cXHUwNDg3XFx1MDQ4OC1cXHUwNDg5XFx1MDU5MS1cXHUwNWJkXFx1MDViZlxcdTA1YzEtXFx1MDVjMlxcdTA1YzQtXFx1MDVjNVxcdTA1YzdcXHUwNjEwLVxcdTA2MWEnICsgJ1xcdTA2NGItXFx1MDY1ZlxcdTA2NzBcXHUwNmQ2LVxcdTA2ZGNcXHUwNmRmLVxcdTA2ZTRcXHUwNmU3LVxcdTA2ZThcXHUwNmVhLVxcdTA2ZWRcXHUwNzExXFx1MDczMC1cXHUwNzRhXFx1MDdhNi1cXHUwN2IwJyArICdcXHUwN2ViLVxcdTA3ZjNcXHUwODE2LVxcdTA4MTlcXHUwODFiLVxcdTA4MjNcXHUwODI1LVxcdTA4MjdcXHUwODI5LVxcdTA4MmRcXHUwODU5LVxcdTA4NWJcXHUwOGUzLVxcdTA5MDJcXHUwOTNhXFx1MDkzYycgKyAnXFx1MDk0MS1cXHUwOTQ4XFx1MDk0ZFxcdTA5NTEtXFx1MDk1N1xcdTA5NjItXFx1MDk2M1xcdTA5ODFcXHUwOWJjXFx1MDliZVxcdTA5YzEtXFx1MDljNFxcdTA5Y2RcXHUwOWQ3XFx1MDllMi1cXHUwOWUzJyArICdcXHUwYTAxLVxcdTBhMDJcXHUwYTNjXFx1MGE0MS1cXHUwYTQyXFx1MGE0Ny1cXHUwYTQ4XFx1MGE0Yi1cXHUwYTRkXFx1MGE1MVxcdTBhNzAtXFx1MGE3MVxcdTBhNzVcXHUwYTgxLVxcdTBhODJcXHUwYWJjJyArICdcXHUwYWMxLVxcdTBhYzVcXHUwYWM3LVxcdTBhYzhcXHUwYWNkXFx1MGFlMi1cXHUwYWUzXFx1MGIwMVxcdTBiM2NcXHUwYjNlXFx1MGIzZlxcdTBiNDEtXFx1MGI0NFxcdTBiNGRcXHUwYjU2XFx1MGI1NycgKyAnXFx1MGI2Mi1cXHUwYjYzXFx1MGI4MlxcdTBiYmVcXHUwYmMwXFx1MGJjZFxcdTBiZDdcXHUwYzAwXFx1MGMzZS1cXHUwYzQwXFx1MGM0Ni1cXHUwYzQ4XFx1MGM0YS1cXHUwYzRkXFx1MGM1NS1cXHUwYzU2JyArICdcXHUwYzYyLVxcdTBjNjNcXHUwYzgxXFx1MGNiY1xcdTBjYmZcXHUwY2MyXFx1MGNjNlxcdTBjY2MtXFx1MGNjZFxcdTBjZDUtXFx1MGNkNlxcdTBjZTItXFx1MGNlM1xcdTBkMDFcXHUwZDNlXFx1MGQ0MS1cXHUwZDQ0JyArICdcXHUwZDRkXFx1MGQ1N1xcdTBkNjItXFx1MGQ2M1xcdTBkY2FcXHUwZGNmXFx1MGRkMi1cXHUwZGQ0XFx1MGRkNlxcdTBkZGZcXHUwZTMxXFx1MGUzNC1cXHUwZTNhXFx1MGU0Ny1cXHUwZTRlXFx1MGViMVxcdTBlYjQtXFx1MGViOScgKyAnXFx1MGViYi1cXHUwZWJjXFx1MGVjOC1cXHUwZWNkXFx1MGYxOC1cXHUwZjE5XFx1MGYzNVxcdTBmMzdcXHUwZjM5XFx1MGY3MS1cXHUwZjdlXFx1MGY4MC1cXHUwZjg0XFx1MGY4Ni1cXHUwZjg3XFx1MGY4ZC1cXHUwZjk3JyArICdcXHUwZjk5LVxcdTBmYmNcXHUwZmM2XFx1MTAyZC1cXHUxMDMwXFx1MTAzMi1cXHUxMDM3XFx1MTAzOS1cXHUxMDNhXFx1MTAzZC1cXHUxMDNlXFx1MTA1OC1cXHUxMDU5XFx1MTA1ZS1cXHUxMDYwXFx1MTA3MS1cXHUxMDc0JyArICdcXHUxMDgyXFx1MTA4NS1cXHUxMDg2XFx1MTA4ZFxcdTEwOWRcXHUxMzVkLVxcdTEzNWZcXHUxNzEyLVxcdTE3MTRcXHUxNzMyLVxcdTE3MzRcXHUxNzUyLVxcdTE3NTNcXHUxNzcyLVxcdTE3NzNcXHUxN2I0LVxcdTE3YjUnICsgJ1xcdTE3YjctXFx1MTdiZFxcdTE3YzZcXHUxN2M5LVxcdTE3ZDNcXHUxN2RkXFx1MTgwYi1cXHUxODBkXFx1MThhOVxcdTE5MjAtXFx1MTkyMlxcdTE5MjctXFx1MTkyOFxcdTE5MzJcXHUxOTM5LVxcdTE5M2JcXHUxYTE3LVxcdTFhMTgnICsgJ1xcdTFhMWJcXHUxYTU2XFx1MWE1OC1cXHUxYTVlXFx1MWE2MFxcdTFhNjJcXHUxYTY1LVxcdTFhNmNcXHUxYTczLVxcdTFhN2NcXHUxYTdmXFx1MWFiMC1cXHUxYWJkXFx1MUFCRVxcdTFiMDAtXFx1MWIwM1xcdTFiMzQnICsgJ1xcdTFiMzYtXFx1MWIzYVxcdTFiM2NcXHUxYjQyXFx1MWI2Yi1cXHUxYjczXFx1MWI4MC1cXHUxYjgxXFx1MWJhMi1cXHUxYmE1XFx1MWJhOC1cXHUxYmE5XFx1MWJhYi1cXHUxYmFkXFx1MWJlNlxcdTFiZTgtXFx1MWJlOScgKyAnXFx1MWJlZFxcdTFiZWYtXFx1MWJmMVxcdTFjMmMtXFx1MWMzM1xcdTFjMzYtXFx1MWMzN1xcdTFjZDAtXFx1MWNkMlxcdTFjZDQtXFx1MWNlMFxcdTFjZTItXFx1MWNlOFxcdTFjZWRcXHUxY2Y0XFx1MWNmOC1cXHUxY2Y5JyArICdcXHUxZGMwLVxcdTFkZjVcXHUxZGZjLVxcdTFkZmZcXHUyMDBjLVxcdTIwMGRcXHUyMGQwLVxcdTIwZGNcXHUyMERELVxcdTIwRTBcXHUyMGUxXFx1MjBFMi1cXHUyMEU0XFx1MjBlNS1cXHUyMGYwXFx1MmNlZi1cXHUyY2YxJyArICdcXHUyZDdmXFx1MmRlMC1cXHUyZGZmXFx1MzAyYS1cXHUzMDJkXFx1MzAyZS1cXHUzMDJmXFx1MzA5OS1cXHUzMDlhXFx1YTY2ZlxcdUE2NzAtXFx1QTY3MlxcdWE2NzQtXFx1YTY3ZFxcdWE2OWUtXFx1YTY5ZlxcdWE2ZjAtXFx1YTZmMScgKyAnXFx1YTgwMlxcdWE4MDZcXHVhODBiXFx1YTgyNS1cXHVhODI2XFx1YThjNFxcdWE4ZTAtXFx1YThmMVxcdWE5MjYtXFx1YTkyZFxcdWE5NDctXFx1YTk1MVxcdWE5ODAtXFx1YTk4MlxcdWE5YjNcXHVhOWI2LVxcdWE5YjlcXHVhOWJjJyArICdcXHVhOWU1XFx1YWEyOS1cXHVhYTJlXFx1YWEzMS1cXHVhYTMyXFx1YWEzNS1cXHVhYTM2XFx1YWE0M1xcdWFhNGNcXHVhYTdjXFx1YWFiMFxcdWFhYjItXFx1YWFiNFxcdWFhYjctXFx1YWFiOFxcdWFhYmUtXFx1YWFiZlxcdWFhYzEnICsgJ1xcdWFhZWMtXFx1YWFlZFxcdWFhZjZcXHVhYmU1XFx1YWJlOFxcdWFiZWRcXHVmYjFlXFx1ZmUwMC1cXHVmZTBmXFx1ZmUyMC1cXHVmZTJmXFx1ZmY5ZS1cXHVmZjlmXScpO1xuICAgIGNvbnN0IGlzRXh0ZW5kaW5nQ2hhciA9IGNoID0+IHR5cGVvZiBjaCA9PT0gJ3N0cmluZycgJiYgY2guY2hhckNvZGVBdCgwKSA+PSA3NjggJiYgZXh0ZW5kaW5nQ2hhcnMudGVzdChjaCk7XG5cbiAgICBjb25zdCBvciA9ICguLi5hcmdzKSA9PiB7XG4gICAgICByZXR1cm4geCA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChhcmdzW2ldKHgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IGFuZCA9ICguLi5hcmdzKSA9PiB7XG4gICAgICByZXR1cm4geCA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICghYXJnc1tpXSh4KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IGlzRWxlbWVudCQ0ID0gaXNFbGVtZW50JDY7XG4gICAgY29uc3QgaXNDYXJldENhbmRpZGF0ZSQyID0gaXNDYXJldENhbmRpZGF0ZSQzO1xuICAgIGNvbnN0IGlzQmxvY2skMSA9IG1hdGNoU3R5bGVWYWx1ZXMoJ2Rpc3BsYXknLCAnYmxvY2sgdGFibGUnKTtcbiAgICBjb25zdCBpc0Zsb2F0ZWQgPSBtYXRjaFN0eWxlVmFsdWVzKCdmbG9hdCcsICdsZWZ0IHJpZ2h0Jyk7XG4gICAgY29uc3QgaXNWYWxpZEVsZW1lbnRDYXJldENhbmRpZGF0ZSA9IGFuZChpc0VsZW1lbnQkNCwgaXNDYXJldENhbmRpZGF0ZSQyLCBub3QoaXNGbG9hdGVkKSk7XG4gICAgY29uc3QgaXNOb3RQcmUgPSBub3QobWF0Y2hTdHlsZVZhbHVlcygnd2hpdGUtc3BhY2UnLCAncHJlIHByZS1saW5lIHByZS13cmFwJykpO1xuICAgIGNvbnN0IGlzVGV4dCQ1ID0gaXNUZXh0JDg7XG4gICAgY29uc3QgaXNCciQyID0gaXNCciQ1O1xuICAgIGNvbnN0IG5vZGVJbmRleCQxID0gRE9NVXRpbHMubm9kZUluZGV4O1xuICAgIGNvbnN0IHJlc29sdmVJbmRleCQxID0gZ2V0Tm9kZVVuc2FmZTtcbiAgICBjb25zdCBjcmVhdGVSYW5nZSQxID0gZG9jID0+ICdjcmVhdGVSYW5nZScgaW4gZG9jID8gZG9jLmNyZWF0ZVJhbmdlKCkgOiBET01VdGlscy5ET00uY3JlYXRlUm5nKCk7XG4gICAgY29uc3QgaXNXaGl0ZVNwYWNlJDEgPSBjaHIgPT4gY2hyICYmIC9bXFxyXFxuXFx0IF0vLnRlc3QoY2hyKTtcbiAgICBjb25zdCBpc1JhbmdlID0gcm5nID0+ICEhcm5nLnNldFN0YXJ0ICYmICEhcm5nLnNldEVuZDtcbiAgICBjb25zdCBpc0hpZGRlbldoaXRlU3BhY2VSYW5nZSA9IHJhbmdlID0+IHtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHJhbmdlLnN0YXJ0Q29udGFpbmVyO1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gcmFuZ2Uuc3RhcnRPZmZzZXQ7XG4gICAgICBpZiAoaXNXaGl0ZVNwYWNlJDEocmFuZ2UudG9TdHJpbmcoKSkgJiYgaXNOb3RQcmUoY29udGFpbmVyLnBhcmVudE5vZGUpICYmIGlzVGV4dCQ4KGNvbnRhaW5lcikpIHtcbiAgICAgICAgY29uc3QgdGV4dCA9IGNvbnRhaW5lci5kYXRhO1xuICAgICAgICBpZiAoaXNXaGl0ZVNwYWNlJDEodGV4dFtvZmZzZXQgLSAxXSkgfHwgaXNXaGl0ZVNwYWNlJDEodGV4dFtvZmZzZXQgKyAxXSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgY29uc3QgZ2V0QnJDbGllbnRSZWN0ID0gYnJOb2RlID0+IHtcbiAgICAgIGNvbnN0IGRvYyA9IGJyTm9kZS5vd25lckRvY3VtZW50O1xuICAgICAgY29uc3Qgcm5nID0gY3JlYXRlUmFuZ2UkMShkb2MpO1xuICAgICAgY29uc3QgbmJzcCQxID0gZG9jLmNyZWF0ZVRleHROb2RlKG5ic3ApO1xuICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IGJyTm9kZS5wYXJlbnROb2RlO1xuICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmJzcCQxLCBick5vZGUpO1xuICAgICAgcm5nLnNldFN0YXJ0KG5ic3AkMSwgMCk7XG4gICAgICBybmcuc2V0RW5kKG5ic3AkMSwgMSk7XG4gICAgICBjb25zdCBjbGllbnRSZWN0ID0gY2xvbmUkMShybmcuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpO1xuICAgICAgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChuYnNwJDEpO1xuICAgICAgcmV0dXJuIGNsaWVudFJlY3Q7XG4gICAgfTtcbiAgICBjb25zdCBnZXRCb3VuZGluZ0NsaWVudFJlY3RXZWJLaXRUZXh0ID0gcm5nID0+IHtcbiAgICAgIGNvbnN0IHNjID0gcm5nLnN0YXJ0Q29udGFpbmVyO1xuICAgICAgY29uc3QgZWMgPSBybmcuZW5kQ29udGFpbmVyO1xuICAgICAgY29uc3Qgc28gPSBybmcuc3RhcnRPZmZzZXQ7XG4gICAgICBjb25zdCBlbyA9IHJuZy5lbmRPZmZzZXQ7XG4gICAgICBpZiAoc2MgPT09IGVjICYmIGlzVGV4dCQ4KGVjKSAmJiBzbyA9PT0gMCAmJiBlbyA9PT0gMSkge1xuICAgICAgICBjb25zdCBuZXdSbmcgPSBybmcuY2xvbmVSYW5nZSgpO1xuICAgICAgICBuZXdSbmcuc2V0RW5kQWZ0ZXIoZWMpO1xuICAgICAgICByZXR1cm4gZ2V0Qm91bmRpbmdDbGllbnRSZWN0JDEobmV3Um5nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaXNaZXJvUmVjdCA9IHIgPT4gci5sZWZ0ID09PSAwICYmIHIucmlnaHQgPT09IDAgJiYgci50b3AgPT09IDAgJiYgci5ib3R0b20gPT09IDA7XG4gICAgY29uc3QgZ2V0Qm91bmRpbmdDbGllbnRSZWN0JDEgPSBpdGVtID0+IHtcbiAgICAgIGxldCBjbGllbnRSZWN0O1xuICAgICAgY29uc3QgY2xpZW50UmVjdHMgPSBpdGVtLmdldENsaWVudFJlY3RzKCk7XG4gICAgICBpZiAoY2xpZW50UmVjdHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjbGllbnRSZWN0ID0gY2xvbmUkMShjbGllbnRSZWN0c1swXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbGllbnRSZWN0ID0gY2xvbmUkMShpdGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNSYW5nZShpdGVtKSAmJiBpc0JyJDIoaXRlbSkgJiYgaXNaZXJvUmVjdChjbGllbnRSZWN0KSkge1xuICAgICAgICByZXR1cm4gZ2V0QnJDbGllbnRSZWN0KGl0ZW0pO1xuICAgICAgfVxuICAgICAgaWYgKGlzWmVyb1JlY3QoY2xpZW50UmVjdCkgJiYgaXNSYW5nZShpdGVtKSkge1xuICAgICAgICByZXR1cm4gZ2V0Qm91bmRpbmdDbGllbnRSZWN0V2ViS2l0VGV4dChpdGVtKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjbGllbnRSZWN0O1xuICAgIH07XG4gICAgY29uc3QgY29sbGFwc2VBbmRJbmZsYXRlV2lkdGggPSAoY2xpZW50UmVjdCwgdG9TdGFydCkgPT4ge1xuICAgICAgY29uc3QgbmV3Q2xpZW50UmVjdCA9IGNvbGxhcHNlKGNsaWVudFJlY3QsIHRvU3RhcnQpO1xuICAgICAgbmV3Q2xpZW50UmVjdC53aWR0aCA9IDE7XG4gICAgICBuZXdDbGllbnRSZWN0LnJpZ2h0ID0gbmV3Q2xpZW50UmVjdC5sZWZ0ICsgMTtcbiAgICAgIHJldHVybiBuZXdDbGllbnRSZWN0O1xuICAgIH07XG4gICAgY29uc3QgZ2V0Q2FyZXRQb3NpdGlvbkNsaWVudFJlY3RzID0gY2FyZXRQb3NpdGlvbiA9PiB7XG4gICAgICBjb25zdCBjbGllbnRSZWN0cyA9IFtdO1xuICAgICAgY29uc3QgYWRkVW5pcXVlQW5kVmFsaWRSZWN0ID0gY2xpZW50UmVjdCA9PiB7XG4gICAgICAgIGlmIChjbGllbnRSZWN0LmhlaWdodCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2xpZW50UmVjdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGlmIChpc0VxdWFsKGNsaWVudFJlY3QsIGNsaWVudFJlY3RzW2NsaWVudFJlY3RzLmxlbmd0aCAtIDFdKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjbGllbnRSZWN0cy5wdXNoKGNsaWVudFJlY3QpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGFkZENoYXJhY3Rlck9mZnNldCA9IChjb250YWluZXIsIG9mZnNldCkgPT4ge1xuICAgICAgICBjb25zdCByYW5nZSA9IGNyZWF0ZVJhbmdlJDEoY29udGFpbmVyLm93bmVyRG9jdW1lbnQpO1xuICAgICAgICBpZiAob2Zmc2V0IDwgY29udGFpbmVyLmRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKGlzRXh0ZW5kaW5nQ2hhcihjb250YWluZXIuZGF0YVtvZmZzZXRdKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNsaWVudFJlY3RzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNFeHRlbmRpbmdDaGFyKGNvbnRhaW5lci5kYXRhW29mZnNldCAtIDFdKSkge1xuICAgICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQoY29udGFpbmVyLCBvZmZzZXQpO1xuICAgICAgICAgICAgcmFuZ2Uuc2V0RW5kKGNvbnRhaW5lciwgb2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICBpZiAoIWlzSGlkZGVuV2hpdGVTcGFjZVJhbmdlKHJhbmdlKSkge1xuICAgICAgICAgICAgICBhZGRVbmlxdWVBbmRWYWxpZFJlY3QoY29sbGFwc2VBbmRJbmZsYXRlV2lkdGgoZ2V0Qm91bmRpbmdDbGllbnRSZWN0JDEocmFuZ2UpLCBmYWxzZSkpO1xuICAgICAgICAgICAgICByZXR1cm4gY2xpZW50UmVjdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvZmZzZXQgPiAwKSB7XG4gICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQoY29udGFpbmVyLCBvZmZzZXQgLSAxKTtcbiAgICAgICAgICByYW5nZS5zZXRFbmQoY29udGFpbmVyLCBvZmZzZXQpO1xuICAgICAgICAgIGlmICghaXNIaWRkZW5XaGl0ZVNwYWNlUmFuZ2UocmFuZ2UpKSB7XG4gICAgICAgICAgICBhZGRVbmlxdWVBbmRWYWxpZFJlY3QoY29sbGFwc2VBbmRJbmZsYXRlV2lkdGgoZ2V0Qm91bmRpbmdDbGllbnRSZWN0JDEocmFuZ2UpLCBmYWxzZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob2Zmc2V0IDwgY29udGFpbmVyLmRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQoY29udGFpbmVyLCBvZmZzZXQpO1xuICAgICAgICAgIHJhbmdlLnNldEVuZChjb250YWluZXIsIG9mZnNldCArIDEpO1xuICAgICAgICAgIGlmICghaXNIaWRkZW5XaGl0ZVNwYWNlUmFuZ2UocmFuZ2UpKSB7XG4gICAgICAgICAgICBhZGRVbmlxdWVBbmRWYWxpZFJlY3QoY29sbGFwc2VBbmRJbmZsYXRlV2lkdGgoZ2V0Qm91bmRpbmdDbGllbnRSZWN0JDEocmFuZ2UpLCB0cnVlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgY29udGFpbmVyID0gY2FyZXRQb3NpdGlvbi5jb250YWluZXIoKTtcbiAgICAgIGNvbnN0IG9mZnNldCA9IGNhcmV0UG9zaXRpb24ub2Zmc2V0KCk7XG4gICAgICBpZiAoaXNUZXh0JDUoY29udGFpbmVyKSkge1xuICAgICAgICBhZGRDaGFyYWN0ZXJPZmZzZXQoY29udGFpbmVyLCBvZmZzZXQpO1xuICAgICAgICByZXR1cm4gY2xpZW50UmVjdHM7XG4gICAgICB9XG4gICAgICBpZiAoaXNFbGVtZW50JDQoY29udGFpbmVyKSkge1xuICAgICAgICBpZiAoY2FyZXRQb3NpdGlvbi5pc0F0RW5kKCkpIHtcbiAgICAgICAgICBjb25zdCBub2RlID0gcmVzb2x2ZUluZGV4JDEoY29udGFpbmVyLCBvZmZzZXQpO1xuICAgICAgICAgIGlmIChpc1RleHQkNShub2RlKSkge1xuICAgICAgICAgICAgYWRkQ2hhcmFjdGVyT2Zmc2V0KG5vZGUsIG5vZGUuZGF0YS5sZW5ndGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnRDYXJldENhbmRpZGF0ZShub2RlKSAmJiAhaXNCciQyKG5vZGUpKSB7XG4gICAgICAgICAgICBhZGRVbmlxdWVBbmRWYWxpZFJlY3QoY29sbGFwc2VBbmRJbmZsYXRlV2lkdGgoZ2V0Qm91bmRpbmdDbGllbnRSZWN0JDEobm9kZSksIGZhbHNlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IG5vZGUgPSByZXNvbHZlSW5kZXgkMShjb250YWluZXIsIG9mZnNldCk7XG4gICAgICAgICAgaWYgKGlzVGV4dCQ1KG5vZGUpKSB7XG4gICAgICAgICAgICBhZGRDaGFyYWN0ZXJPZmZzZXQobm9kZSwgMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudENhcmV0Q2FuZGlkYXRlKG5vZGUpICYmIGNhcmV0UG9zaXRpb24uaXNBdEVuZCgpKSB7XG4gICAgICAgICAgICBhZGRVbmlxdWVBbmRWYWxpZFJlY3QoY29sbGFwc2VBbmRJbmZsYXRlV2lkdGgoZ2V0Qm91bmRpbmdDbGllbnRSZWN0JDEobm9kZSksIGZhbHNlKSk7XG4gICAgICAgICAgICByZXR1cm4gY2xpZW50UmVjdHM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGJlZm9yZU5vZGUgPSByZXNvbHZlSW5kZXgkMShjYXJldFBvc2l0aW9uLmNvbnRhaW5lcigpLCBjYXJldFBvc2l0aW9uLm9mZnNldCgpIC0gMSk7XG4gICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50Q2FyZXRDYW5kaWRhdGUoYmVmb3JlTm9kZSkgJiYgIWlzQnIkMihiZWZvcmVOb2RlKSkge1xuICAgICAgICAgICAgaWYgKGlzQmxvY2skMShiZWZvcmVOb2RlKSB8fCBpc0Jsb2NrJDEobm9kZSkgfHwgIWlzVmFsaWRFbGVtZW50Q2FyZXRDYW5kaWRhdGUobm9kZSkpIHtcbiAgICAgICAgICAgICAgYWRkVW5pcXVlQW5kVmFsaWRSZWN0KGNvbGxhcHNlQW5kSW5mbGF0ZVdpZHRoKGdldEJvdW5kaW5nQ2xpZW50UmVjdCQxKGJlZm9yZU5vZGUpLCBmYWxzZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnRDYXJldENhbmRpZGF0ZShub2RlKSkge1xuICAgICAgICAgICAgYWRkVW5pcXVlQW5kVmFsaWRSZWN0KGNvbGxhcHNlQW5kSW5mbGF0ZVdpZHRoKGdldEJvdW5kaW5nQ2xpZW50UmVjdCQxKG5vZGUpLCB0cnVlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY2xpZW50UmVjdHM7XG4gICAgfTtcbiAgICBjb25zdCBDYXJldFBvc2l0aW9uID0gKGNvbnRhaW5lciwgb2Zmc2V0LCBjbGllbnRSZWN0cykgPT4ge1xuICAgICAgY29uc3QgaXNBdFN0YXJ0ID0gKCkgPT4ge1xuICAgICAgICBpZiAoaXNUZXh0JDUoY29udGFpbmVyKSkge1xuICAgICAgICAgIHJldHVybiBvZmZzZXQgPT09IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9mZnNldCA9PT0gMDtcbiAgICAgIH07XG4gICAgICBjb25zdCBpc0F0RW5kID0gKCkgPT4ge1xuICAgICAgICBpZiAoaXNUZXh0JDUoY29udGFpbmVyKSkge1xuICAgICAgICAgIHJldHVybiBvZmZzZXQgPj0gY29udGFpbmVyLmRhdGEubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvZmZzZXQgPj0gY29udGFpbmVyLmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHRvUmFuZ2UgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gY3JlYXRlUmFuZ2UkMShjb250YWluZXIub3duZXJEb2N1bWVudCk7XG4gICAgICAgIHJhbmdlLnNldFN0YXJ0KGNvbnRhaW5lciwgb2Zmc2V0KTtcbiAgICAgICAgcmFuZ2Uuc2V0RW5kKGNvbnRhaW5lciwgb2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGdldENsaWVudFJlY3RzID0gKCkgPT4ge1xuICAgICAgICBpZiAoIWNsaWVudFJlY3RzKSB7XG4gICAgICAgICAgY2xpZW50UmVjdHMgPSBnZXRDYXJldFBvc2l0aW9uQ2xpZW50UmVjdHMoQ2FyZXRQb3NpdGlvbihjb250YWluZXIsIG9mZnNldCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbGllbnRSZWN0cztcbiAgICAgIH07XG4gICAgICBjb25zdCBpc1Zpc2libGUgPSAoKSA9PiBnZXRDbGllbnRSZWN0cygpLmxlbmd0aCA+IDA7XG4gICAgICBjb25zdCBpc0VxdWFsID0gY2FyZXRQb3NpdGlvbiA9PiBjYXJldFBvc2l0aW9uICYmIGNvbnRhaW5lciA9PT0gY2FyZXRQb3NpdGlvbi5jb250YWluZXIoKSAmJiBvZmZzZXQgPT09IGNhcmV0UG9zaXRpb24ub2Zmc2V0KCk7XG4gICAgICBjb25zdCBnZXROb2RlID0gYmVmb3JlID0+IHJlc29sdmVJbmRleCQxKGNvbnRhaW5lciwgYmVmb3JlID8gb2Zmc2V0IC0gMSA6IG9mZnNldCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb250YWluZXI6IGNvbnN0YW50KGNvbnRhaW5lciksXG4gICAgICAgIG9mZnNldDogY29uc3RhbnQob2Zmc2V0KSxcbiAgICAgICAgdG9SYW5nZSxcbiAgICAgICAgZ2V0Q2xpZW50UmVjdHMsXG4gICAgICAgIGlzVmlzaWJsZSxcbiAgICAgICAgaXNBdFN0YXJ0LFxuICAgICAgICBpc0F0RW5kLFxuICAgICAgICBpc0VxdWFsLFxuICAgICAgICBnZXROb2RlXG4gICAgICB9O1xuICAgIH07XG4gICAgQ2FyZXRQb3NpdGlvbi5mcm9tUmFuZ2VTdGFydCA9IHJhbmdlID0+IENhcmV0UG9zaXRpb24ocmFuZ2Uuc3RhcnRDb250YWluZXIsIHJhbmdlLnN0YXJ0T2Zmc2V0KTtcbiAgICBDYXJldFBvc2l0aW9uLmZyb21SYW5nZUVuZCA9IHJhbmdlID0+IENhcmV0UG9zaXRpb24ocmFuZ2UuZW5kQ29udGFpbmVyLCByYW5nZS5lbmRPZmZzZXQpO1xuICAgIENhcmV0UG9zaXRpb24uYWZ0ZXIgPSBub2RlID0+IENhcmV0UG9zaXRpb24obm9kZS5wYXJlbnROb2RlLCBub2RlSW5kZXgkMShub2RlKSArIDEpO1xuICAgIENhcmV0UG9zaXRpb24uYmVmb3JlID0gbm9kZSA9PiBDYXJldFBvc2l0aW9uKG5vZGUucGFyZW50Tm9kZSwgbm9kZUluZGV4JDEobm9kZSkpO1xuICAgIENhcmV0UG9zaXRpb24uaXNBYm92ZSA9IChwb3MxLCBwb3MyKSA9PiBsaWZ0MihoZWFkKHBvczIuZ2V0Q2xpZW50UmVjdHMoKSksIGxhc3QkMyhwb3MxLmdldENsaWVudFJlY3RzKCkpLCBpc0Fib3ZlJDEpLmdldE9yKGZhbHNlKTtcbiAgICBDYXJldFBvc2l0aW9uLmlzQmVsb3cgPSAocG9zMSwgcG9zMikgPT4gbGlmdDIobGFzdCQzKHBvczIuZ2V0Q2xpZW50UmVjdHMoKSksIGhlYWQocG9zMS5nZXRDbGllbnRSZWN0cygpKSwgaXNCZWxvdyQxKS5nZXRPcihmYWxzZSk7XG4gICAgQ2FyZXRQb3NpdGlvbi5pc0F0U3RhcnQgPSBwb3MgPT4gcG9zID8gcG9zLmlzQXRTdGFydCgpIDogZmFsc2U7XG4gICAgQ2FyZXRQb3NpdGlvbi5pc0F0RW5kID0gcG9zID0+IHBvcyA/IHBvcy5pc0F0RW5kKCkgOiBmYWxzZTtcbiAgICBDYXJldFBvc2l0aW9uLmlzVGV4dFBvc2l0aW9uID0gcG9zID0+IHBvcyA/IGlzVGV4dCQ4KHBvcy5jb250YWluZXIoKSkgOiBmYWxzZTtcbiAgICBDYXJldFBvc2l0aW9uLmlzRWxlbWVudFBvc2l0aW9uID0gcG9zID0+IENhcmV0UG9zaXRpb24uaXNUZXh0UG9zaXRpb24ocG9zKSA9PT0gZmFsc2U7XG5cbiAgICBjb25zdCB0cmltRW1wdHlUZXh0Tm9kZSQxID0gKGRvbSwgbm9kZSkgPT4ge1xuICAgICAgaWYgKGlzVGV4dCQ4KG5vZGUpICYmIG5vZGUuZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZG9tLnJlbW92ZShub2RlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGluc2VydE5vZGUgPSAoZG9tLCBybmcsIG5vZGUpID0+IHtcbiAgICAgIHJuZy5pbnNlcnROb2RlKG5vZGUpO1xuICAgICAgdHJpbUVtcHR5VGV4dE5vZGUkMShkb20sIG5vZGUucHJldmlvdXNTaWJsaW5nKTtcbiAgICAgIHRyaW1FbXB0eVRleHROb2RlJDEoZG9tLCBub2RlLm5leHRTaWJsaW5nKTtcbiAgICB9O1xuICAgIGNvbnN0IGluc2VydEZyYWdtZW50ID0gKGRvbSwgcm5nLCBmcmFnKSA9PiB7XG4gICAgICBjb25zdCBmaXJzdENoaWxkID0gT3B0aW9uYWwuZnJvbShmcmFnLmZpcnN0Q2hpbGQpO1xuICAgICAgY29uc3QgbGFzdENoaWxkID0gT3B0aW9uYWwuZnJvbShmcmFnLmxhc3RDaGlsZCk7XG4gICAgICBybmcuaW5zZXJ0Tm9kZShmcmFnKTtcbiAgICAgIGZpcnN0Q2hpbGQuZWFjaChjaGlsZCA9PiB0cmltRW1wdHlUZXh0Tm9kZSQxKGRvbSwgY2hpbGQucHJldmlvdXNTaWJsaW5nKSk7XG4gICAgICBsYXN0Q2hpbGQuZWFjaChjaGlsZCA9PiB0cmltRW1wdHlUZXh0Tm9kZSQxKGRvbSwgY2hpbGQubmV4dFNpYmxpbmcpKTtcbiAgICB9O1xuICAgIGNvbnN0IHJhbmdlSW5zZXJ0Tm9kZSA9IChkb20sIHJuZywgbm9kZSkgPT4ge1xuICAgICAgaWYgKGlzRG9jdW1lbnRGcmFnbWVudChub2RlKSkge1xuICAgICAgICBpbnNlcnRGcmFnbWVudChkb20sIHJuZywgbm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnNlcnROb2RlKGRvbSwgcm5nLCBub2RlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgaXNUZXh0JDQgPSBpc1RleHQkODtcbiAgICBjb25zdCBpc0JvZ3VzID0gaXNCb2d1cyQyO1xuICAgIGNvbnN0IG5vZGVJbmRleCA9IERPTVV0aWxzLm5vZGVJbmRleDtcbiAgICBjb25zdCBub3JtYWxpemVkUGFyZW50ID0gbm9kZSA9PiB7XG4gICAgICBjb25zdCBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgaWYgKGlzQm9ndXMocGFyZW50Tm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRQYXJlbnQocGFyZW50Tm9kZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyZW50Tm9kZTtcbiAgICB9O1xuICAgIGNvbnN0IGdldENoaWxkTm9kZXMgPSBub2RlID0+IHtcbiAgICAgIGlmICghbm9kZSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVkdWNlKG5vZGUuY2hpbGROb2RlcywgKHJlc3VsdCwgbm9kZSkgPT4ge1xuICAgICAgICBpZiAoaXNCb2d1cyhub2RlKSAmJiBub2RlLm5vZGVOYW1lICE9PSAnQlInKSB7XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChnZXRDaGlsZE5vZGVzKG5vZGUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSwgW10pO1xuICAgIH07XG4gICAgY29uc3Qgbm9ybWFsaXplZFRleHRPZmZzZXQgPSAobm9kZSwgb2Zmc2V0KSA9PiB7XG4gICAgICB3aGlsZSAobm9kZSA9IG5vZGUucHJldmlvdXNTaWJsaW5nKSB7XG4gICAgICAgIGlmICghaXNUZXh0JDQobm9kZSkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBvZmZzZXQgKz0gbm9kZS5kYXRhLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfTtcbiAgICBjb25zdCBlcXVhbCA9IGEgPT4gYiA9PiBhID09PSBiO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWROb2RlSW5kZXggPSBub2RlID0+IHtcbiAgICAgIGxldCBub2RlcywgaW5kZXg7XG4gICAgICBub2RlcyA9IGdldENoaWxkTm9kZXMobm9ybWFsaXplZFBhcmVudChub2RlKSk7XG4gICAgICBpbmRleCA9IGZpbmRJbmRleCQxKG5vZGVzLCBlcXVhbChub2RlKSwgbm9kZSk7XG4gICAgICBub2RlcyA9IG5vZGVzLnNsaWNlKDAsIGluZGV4ICsgMSk7XG4gICAgICBjb25zdCBudW1UZXh0RnJhZ21lbnRzID0gcmVkdWNlKG5vZGVzLCAocmVzdWx0LCBub2RlLCBpKSA9PiB7XG4gICAgICAgIGlmIChpc1RleHQkNChub2RlKSAmJiBpc1RleHQkNChub2Rlc1tpIC0gMV0pKSB7XG4gICAgICAgICAgcmVzdWx0Kys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0sIDApO1xuICAgICAgbm9kZXMgPSBmaWx0ZXIkNChub2RlcywgbWF0Y2hOb2RlTmFtZXMoW25vZGUubm9kZU5hbWVdKSk7XG4gICAgICBpbmRleCA9IGZpbmRJbmRleCQxKG5vZGVzLCBlcXVhbChub2RlKSwgbm9kZSk7XG4gICAgICByZXR1cm4gaW5kZXggLSBudW1UZXh0RnJhZ21lbnRzO1xuICAgIH07XG4gICAgY29uc3QgY3JlYXRlUGF0aEl0ZW0gPSBub2RlID0+IHtcbiAgICAgIGxldCBuYW1lO1xuICAgICAgaWYgKGlzVGV4dCQ0KG5vZGUpKSB7XG4gICAgICAgIG5hbWUgPSAndGV4dCgpJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5hbWUgPSBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmFtZSArICdbJyArIG5vcm1hbGl6ZWROb2RlSW5kZXgobm9kZSkgKyAnXSc7XG4gICAgfTtcbiAgICBjb25zdCBwYXJlbnRzVW50aWwkMSA9IChyb290LCBub2RlLCBwcmVkaWNhdGUpID0+IHtcbiAgICAgIGNvbnN0IHBhcmVudHMgPSBbXTtcbiAgICAgIGZvciAobm9kZSA9IG5vZGUucGFyZW50Tm9kZTsgbm9kZSAhPT0gcm9vdDsgbm9kZSA9IG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICBpZiAocHJlZGljYXRlICYmIHByZWRpY2F0ZShub2RlKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudHMucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJlbnRzO1xuICAgIH07XG4gICAgY29uc3QgY3JlYXRlJGEgPSAocm9vdCwgY2FyZXRQb3NpdGlvbikgPT4ge1xuICAgICAgbGV0IGNvbnRhaW5lciwgb2Zmc2V0LCBwYXRoID0gW10sIG91dHB1dE9mZnNldCwgY2hpbGROb2RlcywgcGFyZW50cztcbiAgICAgIGNvbnRhaW5lciA9IGNhcmV0UG9zaXRpb24uY29udGFpbmVyKCk7XG4gICAgICBvZmZzZXQgPSBjYXJldFBvc2l0aW9uLm9mZnNldCgpO1xuICAgICAgaWYgKGlzVGV4dCQ0KGNvbnRhaW5lcikpIHtcbiAgICAgICAgb3V0cHV0T2Zmc2V0ID0gbm9ybWFsaXplZFRleHRPZmZzZXQoY29udGFpbmVyLCBvZmZzZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hpbGROb2RlcyA9IGNvbnRhaW5lci5jaGlsZE5vZGVzO1xuICAgICAgICBpZiAob2Zmc2V0ID49IGNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgb3V0cHV0T2Zmc2V0ID0gJ2FmdGVyJztcbiAgICAgICAgICBvZmZzZXQgPSBjaGlsZE5vZGVzLmxlbmd0aCAtIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0cHV0T2Zmc2V0ID0gJ2JlZm9yZSc7XG4gICAgICAgIH1cbiAgICAgICAgY29udGFpbmVyID0gY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgICAgfVxuICAgICAgcGF0aC5wdXNoKGNyZWF0ZVBhdGhJdGVtKGNvbnRhaW5lcikpO1xuICAgICAgcGFyZW50cyA9IHBhcmVudHNVbnRpbCQxKHJvb3QsIGNvbnRhaW5lcik7XG4gICAgICBwYXJlbnRzID0gZmlsdGVyJDQocGFyZW50cywgbm90KGlzQm9ndXMkMikpO1xuICAgICAgcGF0aCA9IHBhdGguY29uY2F0KG1hcCQxKHBhcmVudHMsIG5vZGUgPT4ge1xuICAgICAgICByZXR1cm4gY3JlYXRlUGF0aEl0ZW0obm9kZSk7XG4gICAgICB9KSk7XG4gICAgICByZXR1cm4gcGF0aC5yZXZlcnNlKCkuam9pbignLycpICsgJywnICsgb3V0cHV0T2Zmc2V0O1xuICAgIH07XG4gICAgY29uc3QgcmVzb2x2ZVBhdGhJdGVtID0gKG5vZGUsIG5hbWUsIGluZGV4KSA9PiB7XG4gICAgICBsZXQgbm9kZXMgPSBnZXRDaGlsZE5vZGVzKG5vZGUpO1xuICAgICAgbm9kZXMgPSBmaWx0ZXIkNChub2RlcywgKG5vZGUsIGluZGV4KSA9PiB7XG4gICAgICAgIHJldHVybiAhaXNUZXh0JDQobm9kZSkgfHwgIWlzVGV4dCQ0KG5vZGVzW2luZGV4IC0gMV0pO1xuICAgICAgfSk7XG4gICAgICBub2RlcyA9IGZpbHRlciQ0KG5vZGVzLCBtYXRjaE5vZGVOYW1lcyhbbmFtZV0pKTtcbiAgICAgIHJldHVybiBub2Rlc1tpbmRleF07XG4gICAgfTtcbiAgICBjb25zdCBmaW5kVGV4dFBvc2l0aW9uID0gKGNvbnRhaW5lciwgb2Zmc2V0KSA9PiB7XG4gICAgICBsZXQgbm9kZSA9IGNvbnRhaW5lciwgdGFyZ2V0T2Zmc2V0ID0gMCwgZGF0YUxlbjtcbiAgICAgIHdoaWxlIChpc1RleHQkNChub2RlKSkge1xuICAgICAgICBkYXRhTGVuID0gbm9kZS5kYXRhLmxlbmd0aDtcbiAgICAgICAgaWYgKG9mZnNldCA+PSB0YXJnZXRPZmZzZXQgJiYgb2Zmc2V0IDw9IHRhcmdldE9mZnNldCArIGRhdGFMZW4pIHtcbiAgICAgICAgICBjb250YWluZXIgPSBub2RlO1xuICAgICAgICAgIG9mZnNldCA9IG9mZnNldCAtIHRhcmdldE9mZnNldDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVGV4dCQ0KG5vZGUubmV4dFNpYmxpbmcpKSB7XG4gICAgICAgICAgY29udGFpbmVyID0gbm9kZTtcbiAgICAgICAgICBvZmZzZXQgPSBkYXRhTGVuO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldE9mZnNldCArPSBkYXRhTGVuO1xuICAgICAgICBub2RlID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgIH1cbiAgICAgIGlmIChpc1RleHQkNChjb250YWluZXIpICYmIG9mZnNldCA+IGNvbnRhaW5lci5kYXRhLmxlbmd0aCkge1xuICAgICAgICBvZmZzZXQgPSBjb250YWluZXIuZGF0YS5sZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gQ2FyZXRQb3NpdGlvbihjb250YWluZXIsIG9mZnNldCk7XG4gICAgfTtcbiAgICBjb25zdCByZXNvbHZlJDEgPSAocm9vdCwgcGF0aCkgPT4ge1xuICAgICAgbGV0IG9mZnNldDtcbiAgICAgIGlmICghcGF0aCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhcnRzID0gcGF0aC5zcGxpdCgnLCcpO1xuICAgICAgY29uc3QgcGF0aHMgPSBwYXJ0c1swXS5zcGxpdCgnLycpO1xuICAgICAgb2Zmc2V0ID0gcGFydHMubGVuZ3RoID4gMSA/IHBhcnRzWzFdIDogJ2JlZm9yZSc7XG4gICAgICBjb25zdCBjb250YWluZXIgPSByZWR1Y2UocGF0aHMsIChyZXN1bHQsIHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gLyhbXFx3XFwtXFwoXFwpXSspXFxbKFswLTldKylcXF0vLmV4ZWModmFsdWUpO1xuICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoWzFdID09PSAndGV4dCgpJykge1xuICAgICAgICAgIG1hdGNoWzFdID0gJyN0ZXh0JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzb2x2ZVBhdGhJdGVtKHJlc3VsdCwgbWF0Y2hbMV0sIHBhcnNlSW50KG1hdGNoWzJdLCAxMCkpO1xuICAgICAgfSwgcm9vdCk7XG4gICAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICghaXNUZXh0JDQoY29udGFpbmVyKSkge1xuICAgICAgICBpZiAob2Zmc2V0ID09PSAnYWZ0ZXInKSB7XG4gICAgICAgICAgb2Zmc2V0ID0gbm9kZUluZGV4KGNvbnRhaW5lcikgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9mZnNldCA9IG5vZGVJbmRleChjb250YWluZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBDYXJldFBvc2l0aW9uKGNvbnRhaW5lci5wYXJlbnROb2RlLCBvZmZzZXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZpbmRUZXh0UG9zaXRpb24oY29udGFpbmVyLCBwYXJzZUludChvZmZzZXQsIDEwKSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGlzQ29udGVudEVkaXRhYmxlRmFsc2UkOCA9IGlzQ29udGVudEVkaXRhYmxlRmFsc2UkYTtcbiAgICBjb25zdCBnZXROb3JtYWxpemVkVGV4dE9mZnNldCA9ICh0cmltLCBjb250YWluZXIsIG9mZnNldCkgPT4ge1xuICAgICAgbGV0IG5vZGUsIHRyaW1tZWRPZmZzZXQ7XG4gICAgICB0cmltbWVkT2Zmc2V0ID0gdHJpbShjb250YWluZXIuZGF0YS5zbGljZSgwLCBvZmZzZXQpKS5sZW5ndGg7XG4gICAgICBmb3IgKG5vZGUgPSBjb250YWluZXIucHJldmlvdXNTaWJsaW5nOyBub2RlICYmIGlzVGV4dCQ4KG5vZGUpOyBub2RlID0gbm9kZS5wcmV2aW91c1NpYmxpbmcpIHtcbiAgICAgICAgdHJpbW1lZE9mZnNldCArPSB0cmltKG5vZGUuZGF0YSkubGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRyaW1tZWRPZmZzZXQ7XG4gICAgfTtcbiAgICBjb25zdCBnZXRQb2ludCA9IChkb20sIHRyaW0sIG5vcm1hbGl6ZWQsIHJuZywgc3RhcnQpID0+IHtcbiAgICAgIGxldCBjb250YWluZXIgPSBybmdbc3RhcnQgPyAnc3RhcnRDb250YWluZXInIDogJ2VuZENvbnRhaW5lciddO1xuICAgICAgbGV0IG9mZnNldCA9IHJuZ1tzdGFydCA/ICdzdGFydE9mZnNldCcgOiAnZW5kT2Zmc2V0J107XG4gICAgICBjb25zdCBwb2ludCA9IFtdO1xuICAgICAgbGV0IGNoaWxkTm9kZXMsIGFmdGVyID0gMDtcbiAgICAgIGNvbnN0IHJvb3QgPSBkb20uZ2V0Um9vdCgpO1xuICAgICAgaWYgKGlzVGV4dCQ4KGNvbnRhaW5lcikpIHtcbiAgICAgICAgcG9pbnQucHVzaChub3JtYWxpemVkID8gZ2V0Tm9ybWFsaXplZFRleHRPZmZzZXQodHJpbSwgY29udGFpbmVyLCBvZmZzZXQpIDogb2Zmc2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoaWxkTm9kZXMgPSBjb250YWluZXIuY2hpbGROb2RlcztcbiAgICAgICAgaWYgKG9mZnNldCA+PSBjaGlsZE5vZGVzLmxlbmd0aCAmJiBjaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgIGFmdGVyID0gMTtcbiAgICAgICAgICBvZmZzZXQgPSBNYXRoLm1heCgwLCBjaGlsZE5vZGVzLmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIHBvaW50LnB1c2goZG9tLm5vZGVJbmRleChjaGlsZE5vZGVzW29mZnNldF0sIG5vcm1hbGl6ZWQpICsgYWZ0ZXIpO1xuICAgICAgfVxuICAgICAgZm9yICg7IGNvbnRhaW5lciAmJiBjb250YWluZXIgIT09IHJvb3Q7IGNvbnRhaW5lciA9IGNvbnRhaW5lci5wYXJlbnROb2RlKSB7XG4gICAgICAgIHBvaW50LnB1c2goZG9tLm5vZGVJbmRleChjb250YWluZXIsIG5vcm1hbGl6ZWQpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwb2ludDtcbiAgICB9O1xuICAgIGNvbnN0IGdldExvY2F0aW9uID0gKHRyaW0sIHNlbGVjdGlvbiwgbm9ybWFsaXplZCwgcm5nKSA9PiB7XG4gICAgICBjb25zdCBkb20gPSBzZWxlY3Rpb24uZG9tLCBib29rbWFyayA9IHt9O1xuICAgICAgYm9va21hcmsuc3RhcnQgPSBnZXRQb2ludChkb20sIHRyaW0sIG5vcm1hbGl6ZWQsIHJuZywgdHJ1ZSk7XG4gICAgICBpZiAoIXNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpKSB7XG4gICAgICAgIGJvb2ttYXJrLmVuZCA9IGdldFBvaW50KGRvbSwgdHJpbSwgbm9ybWFsaXplZCwgcm5nLCBmYWxzZSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNSYW5nZUluQ2FyZXRDb250YWluZXJCbG9jayhybmcpKSB7XG4gICAgICAgIGJvb2ttYXJrLmlzRmFrZUNhcmV0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBib29rbWFyaztcbiAgICB9O1xuICAgIGNvbnN0IGZpbmRJbmRleCA9IChkb20sIG5hbWUsIGVsZW1lbnQpID0+IHtcbiAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICBUb29scy5lYWNoKGRvbS5zZWxlY3QobmFtZSksIG5vZGUgPT4ge1xuICAgICAgICBpZiAobm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtbWNlLWJvZ3VzJykgPT09ICdhbGwnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlID09PSBlbGVtZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvdW50Kys7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjb3VudDtcbiAgICB9O1xuICAgIGNvbnN0IG1vdmVFbmRQb2ludCQxID0gKHJuZywgc3RhcnQpID0+IHtcbiAgICAgIGxldCBjb250YWluZXIsIG9mZnNldCwgY2hpbGROb2RlcztcbiAgICAgIGNvbnN0IHByZWZpeCA9IHN0YXJ0ID8gJ3N0YXJ0JyA6ICdlbmQnO1xuICAgICAgY29udGFpbmVyID0gcm5nW3ByZWZpeCArICdDb250YWluZXInXTtcbiAgICAgIG9mZnNldCA9IHJuZ1twcmVmaXggKyAnT2Zmc2V0J107XG4gICAgICBpZiAoaXNFbGVtZW50JDYoY29udGFpbmVyKSAmJiBjb250YWluZXIubm9kZU5hbWUgPT09ICdUUicpIHtcbiAgICAgICAgY2hpbGROb2RlcyA9IGNvbnRhaW5lci5jaGlsZE5vZGVzO1xuICAgICAgICBjb250YWluZXIgPSBjaGlsZE5vZGVzW01hdGgubWluKHN0YXJ0ID8gb2Zmc2V0IDogb2Zmc2V0IC0gMSwgY2hpbGROb2Rlcy5sZW5ndGggLSAxKV07XG4gICAgICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgICAgICBvZmZzZXQgPSBzdGFydCA/IDAgOiBjb250YWluZXIuY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgICAgICAgcm5nWydzZXQnICsgKHN0YXJ0ID8gJ1N0YXJ0JyA6ICdFbmQnKV0oY29udGFpbmVyLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBub3JtYWxpemVUYWJsZUNlbGxTZWxlY3Rpb24gPSBybmcgPT4ge1xuICAgICAgbW92ZUVuZFBvaW50JDEocm5nLCB0cnVlKTtcbiAgICAgIG1vdmVFbmRQb2ludCQxKHJuZywgZmFsc2UpO1xuICAgICAgcmV0dXJuIHJuZztcbiAgICB9O1xuICAgIGNvbnN0IGZpbmRTaWJsaW5nID0gKG5vZGUsIG9mZnNldCkgPT4ge1xuICAgICAgbGV0IHNpYmxpbmc7XG4gICAgICBpZiAoaXNFbGVtZW50JDYobm9kZSkpIHtcbiAgICAgICAgbm9kZSA9IGdldE5vZGUkMShub2RlLCBvZmZzZXQpO1xuICAgICAgICBpZiAoaXNDb250ZW50RWRpdGFibGVGYWxzZSQ4KG5vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0NhcmV0Q29udGFpbmVyJDIobm9kZSkpIHtcbiAgICAgICAgaWYgKGlzVGV4dCQ4KG5vZGUpICYmIGlzQ2FyZXRDb250YWluZXJCbG9jayQxKG5vZGUpKSB7XG4gICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBzaWJsaW5nID0gbm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgIGlmIChpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJDgoc2libGluZykpIHtcbiAgICAgICAgICByZXR1cm4gc2libGluZztcbiAgICAgICAgfVxuICAgICAgICBzaWJsaW5nID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgaWYgKGlzQ29udGVudEVkaXRhYmxlRmFsc2UkOChzaWJsaW5nKSkge1xuICAgICAgICAgIHJldHVybiBzaWJsaW5nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBmaW5kQWRqYWNlbnRDb250ZW50RWRpdGFibGVGYWxzZUVsbSA9IHJuZyA9PiB7XG4gICAgICByZXR1cm4gZmluZFNpYmxpbmcocm5nLnN0YXJ0Q29udGFpbmVyLCBybmcuc3RhcnRPZmZzZXQpIHx8IGZpbmRTaWJsaW5nKHJuZy5lbmRDb250YWluZXIsIHJuZy5lbmRPZmZzZXQpO1xuICAgIH07XG4gICAgY29uc3QgZ2V0T2Zmc2V0Qm9va21hcmsgPSAodHJpbSwgbm9ybWFsaXplZCwgc2VsZWN0aW9uKSA9PiB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gc2VsZWN0aW9uLmdldE5vZGUoKTtcbiAgICAgIGxldCBuYW1lID0gZWxlbWVudCA/IGVsZW1lbnQubm9kZU5hbWUgOiBudWxsO1xuICAgICAgY29uc3Qgcm5nID0gc2VsZWN0aW9uLmdldFJuZygpO1xuICAgICAgaWYgKGlzQ29udGVudEVkaXRhYmxlRmFsc2UkOChlbGVtZW50KSB8fCBuYW1lID09PSAnSU1HJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgaW5kZXg6IGZpbmRJbmRleChzZWxlY3Rpb24uZG9tLCBuYW1lLCBlbGVtZW50KVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3Qgc2libGluZyA9IGZpbmRBZGphY2VudENvbnRlbnRFZGl0YWJsZUZhbHNlRWxtKHJuZyk7XG4gICAgICBpZiAoc2libGluZykge1xuICAgICAgICBuYW1lID0gc2libGluZy50YWdOYW1lO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgaW5kZXg6IGZpbmRJbmRleChzZWxlY3Rpb24uZG9tLCBuYW1lLCBzaWJsaW5nKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldExvY2F0aW9uKHRyaW0sIHNlbGVjdGlvbiwgbm9ybWFsaXplZCwgcm5nKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldENhcmV0Qm9va21hcmsgPSBzZWxlY3Rpb24gPT4ge1xuICAgICAgY29uc3Qgcm5nID0gc2VsZWN0aW9uLmdldFJuZygpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IGNyZWF0ZSRhKHNlbGVjdGlvbi5kb20uZ2V0Um9vdCgpLCBDYXJldFBvc2l0aW9uLmZyb21SYW5nZVN0YXJ0KHJuZykpLFxuICAgICAgICBlbmQ6IGNyZWF0ZSRhKHNlbGVjdGlvbi5kb20uZ2V0Um9vdCgpLCBDYXJldFBvc2l0aW9uLmZyb21SYW5nZUVuZChybmcpKVxuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IGdldFJhbmdlQm9va21hcmsgPSBzZWxlY3Rpb24gPT4ge1xuICAgICAgcmV0dXJuIHsgcm5nOiBzZWxlY3Rpb24uZ2V0Um5nKCkgfTtcbiAgICB9O1xuICAgIGNvbnN0IGNyZWF0ZUJvb2ttYXJrU3BhbiA9IChkb20sIGlkLCBmaWxsZWQpID0+IHtcbiAgICAgIGNvbnN0IGFyZ3MgPSB7XG4gICAgICAgICdkYXRhLW1jZS10eXBlJzogJ2Jvb2ttYXJrJyxcbiAgICAgICAgaWQsXG4gICAgICAgICdzdHlsZSc6ICdvdmVyZmxvdzpoaWRkZW47bGluZS1oZWlnaHQ6MHB4J1xuICAgICAgfTtcbiAgICAgIHJldHVybiBmaWxsZWQgPyBkb20uY3JlYXRlKCdzcGFuJywgYXJncywgJyYjeEZFRkY7JykgOiBkb20uY3JlYXRlKCdzcGFuJywgYXJncyk7XG4gICAgfTtcbiAgICBjb25zdCBnZXRQZXJzaXN0ZW50Qm9va21hcmsgPSAoc2VsZWN0aW9uLCBmaWxsZWQpID0+IHtcbiAgICAgIGNvbnN0IGRvbSA9IHNlbGVjdGlvbi5kb207XG4gICAgICBsZXQgcm5nID0gc2VsZWN0aW9uLmdldFJuZygpO1xuICAgICAgY29uc3QgaWQgPSBkb20udW5pcXVlSWQoKTtcbiAgICAgIGNvbnN0IGNvbGxhcHNlZCA9IHNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpO1xuICAgICAgY29uc3QgZWxlbWVudCA9IHNlbGVjdGlvbi5nZXROb2RlKCk7XG4gICAgICBjb25zdCBuYW1lID0gZWxlbWVudC5ub2RlTmFtZTtcbiAgICAgIGlmIChuYW1lID09PSAnSU1HJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgaW5kZXg6IGZpbmRJbmRleChkb20sIG5hbWUsIGVsZW1lbnQpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCBybmcyID0gbm9ybWFsaXplVGFibGVDZWxsU2VsZWN0aW9uKHJuZy5jbG9uZVJhbmdlKCkpO1xuICAgICAgaWYgKCFjb2xsYXBzZWQpIHtcbiAgICAgICAgcm5nMi5jb2xsYXBzZShmYWxzZSk7XG4gICAgICAgIGNvbnN0IGVuZEJvb2ttYXJrTm9kZSA9IGNyZWF0ZUJvb2ttYXJrU3Bhbihkb20sIGlkICsgJ19lbmQnLCBmaWxsZWQpO1xuICAgICAgICByYW5nZUluc2VydE5vZGUoZG9tLCBybmcyLCBlbmRCb29rbWFya05vZGUpO1xuICAgICAgfVxuICAgICAgcm5nID0gbm9ybWFsaXplVGFibGVDZWxsU2VsZWN0aW9uKHJuZyk7XG4gICAgICBybmcuY29sbGFwc2UodHJ1ZSk7XG4gICAgICBjb25zdCBzdGFydEJvb2ttYXJrTm9kZSA9IGNyZWF0ZUJvb2ttYXJrU3Bhbihkb20sIGlkICsgJ19zdGFydCcsIGZpbGxlZCk7XG4gICAgICByYW5nZUluc2VydE5vZGUoZG9tLCBybmcsIHN0YXJ0Qm9va21hcmtOb2RlKTtcbiAgICAgIHNlbGVjdGlvbi5tb3ZlVG9Cb29rbWFyayh7XG4gICAgICAgIGlkLFxuICAgICAgICBrZWVwOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7IGlkIH07XG4gICAgfTtcbiAgICBjb25zdCBnZXRCb29rbWFyayQyID0gKHNlbGVjdGlvbiwgdHlwZSwgbm9ybWFsaXplZCkgPT4ge1xuICAgICAgaWYgKHR5cGUgPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIGdldE9mZnNldEJvb2ttYXJrKHRyaW0kMSwgbm9ybWFsaXplZCwgc2VsZWN0aW9uKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gMykge1xuICAgICAgICByZXR1cm4gZ2V0Q2FyZXRCb29rbWFyayhzZWxlY3Rpb24pO1xuICAgICAgfSBlbHNlIGlmICh0eXBlKSB7XG4gICAgICAgIHJldHVybiBnZXRSYW5nZUJvb2ttYXJrKHNlbGVjdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZ2V0UGVyc2lzdGVudEJvb2ttYXJrKHNlbGVjdGlvbiwgZmFsc2UpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZ2V0VW5kb0Jvb2ttYXJrID0gY3VycnkoZ2V0T2Zmc2V0Qm9va21hcmssIGlkZW50aXR5LCB0cnVlKTtcblxuICAgIGNvbnN0IHZhbHVlJDEgPSB2YWx1ZSA9PiB7XG4gICAgICBjb25zdCBhcHBseUhlbHBlciA9IGZuID0+IGZuKHZhbHVlKTtcbiAgICAgIGNvbnN0IGNvbnN0SGVscGVyID0gY29uc3RhbnQodmFsdWUpO1xuICAgICAgY29uc3Qgb3V0cHV0SGVscGVyID0gKCkgPT4gb3V0cHV0O1xuICAgICAgY29uc3Qgb3V0cHV0ID0ge1xuICAgICAgICB0YWc6IHRydWUsXG4gICAgICAgIGlubmVyOiB2YWx1ZSxcbiAgICAgICAgZm9sZDogKF9vbkVycm9yLCBvblZhbHVlKSA9PiBvblZhbHVlKHZhbHVlKSxcbiAgICAgICAgaXNWYWx1ZTogYWx3YXlzLFxuICAgICAgICBpc0Vycm9yOiBuZXZlcixcbiAgICAgICAgbWFwOiBtYXBwZXIgPT4gUmVzdWx0LnZhbHVlKG1hcHBlcih2YWx1ZSkpLFxuICAgICAgICBtYXBFcnJvcjogb3V0cHV0SGVscGVyLFxuICAgICAgICBiaW5kOiBhcHBseUhlbHBlcixcbiAgICAgICAgZXhpc3RzOiBhcHBseUhlbHBlcixcbiAgICAgICAgZm9yYWxsOiBhcHBseUhlbHBlcixcbiAgICAgICAgZ2V0T3I6IGNvbnN0SGVscGVyLFxuICAgICAgICBvcjogb3V0cHV0SGVscGVyLFxuICAgICAgICBnZXRPclRodW5rOiBjb25zdEhlbHBlcixcbiAgICAgICAgb3JUaHVuazogb3V0cHV0SGVscGVyLFxuICAgICAgICBnZXRPckRpZTogY29uc3RIZWxwZXIsXG4gICAgICAgIGVhY2g6IGZuID0+IHtcbiAgICAgICAgICBmbih2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHRvT3B0aW9uYWw6ICgpID0+IE9wdGlvbmFsLnNvbWUodmFsdWUpXG4gICAgICB9O1xuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xuICAgIGNvbnN0IGVycm9yID0gZXJyb3IgPT4ge1xuICAgICAgY29uc3Qgb3V0cHV0SGVscGVyID0gKCkgPT4gb3V0cHV0O1xuICAgICAgY29uc3Qgb3V0cHV0ID0ge1xuICAgICAgICB0YWc6IGZhbHNlLFxuICAgICAgICBpbm5lcjogZXJyb3IsXG4gICAgICAgIGZvbGQ6IChvbkVycm9yLCBfb25WYWx1ZSkgPT4gb25FcnJvcihlcnJvciksXG4gICAgICAgIGlzVmFsdWU6IG5ldmVyLFxuICAgICAgICBpc0Vycm9yOiBhbHdheXMsXG4gICAgICAgIG1hcDogb3V0cHV0SGVscGVyLFxuICAgICAgICBtYXBFcnJvcjogbWFwcGVyID0+IFJlc3VsdC5lcnJvcihtYXBwZXIoZXJyb3IpKSxcbiAgICAgICAgYmluZDogb3V0cHV0SGVscGVyLFxuICAgICAgICBleGlzdHM6IG5ldmVyLFxuICAgICAgICBmb3JhbGw6IGFsd2F5cyxcbiAgICAgICAgZ2V0T3I6IGlkZW50aXR5LFxuICAgICAgICBvcjogaWRlbnRpdHksXG4gICAgICAgIGdldE9yVGh1bms6IGFwcGx5JDEsXG4gICAgICAgIG9yVGh1bms6IGFwcGx5JDEsXG4gICAgICAgIGdldE9yRGllOiBkaWUoU3RyaW5nKGVycm9yKSksXG4gICAgICAgIGVhY2g6IG5vb3AsXG4gICAgICAgIHRvT3B0aW9uYWw6IE9wdGlvbmFsLm5vbmVcbiAgICAgIH07XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG4gICAgY29uc3QgZnJvbU9wdGlvbiA9IChvcHRpb25hbCwgZXJyKSA9PiBvcHRpb25hbC5mb2xkKCgpID0+IGVycm9yKGVyciksIHZhbHVlJDEpO1xuICAgIGNvbnN0IFJlc3VsdCA9IHtcbiAgICAgIHZhbHVlOiB2YWx1ZSQxLFxuICAgICAgZXJyb3IsXG4gICAgICBmcm9tT3B0aW9uXG4gICAgfTtcblxuICAgIGNvbnN0IGdlbmVyYXRlID0gY2FzZXMgPT4ge1xuICAgICAgaWYgKCFpc0FycmF5JDEoY2FzZXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2FzZXMgbXVzdCBiZSBhbiBhcnJheScpO1xuICAgICAgfVxuICAgICAgaWYgKGNhc2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RoZXJlIG11c3QgYmUgYXQgbGVhc3Qgb25lIGNhc2UnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbnN0cnVjdG9ycyA9IFtdO1xuICAgICAgY29uc3QgYWR0ID0ge307XG4gICAgICBlYWNoJGcoY2FzZXMsIChhY2FzZSwgY291bnQpID0+IHtcbiAgICAgICAgY29uc3Qga2V5cyQxID0ga2V5cyhhY2FzZSk7XG4gICAgICAgIGlmIChrZXlzJDEubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvbmUgYW5kIG9ubHkgb25lIG5hbWUgcGVyIGNhc2UnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrZXkgPSBrZXlzJDFbMF07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gYWNhc2Vba2V5XTtcbiAgICAgICAgaWYgKGFkdFtrZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2R1cGxpY2F0ZSBrZXkgZGV0ZWN0ZWQ6JyArIGtleSk7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnY2F0YScpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBoYXZlIGEgY2FzZSBuYW1lZCBjYXRhIChzb3JyeSknKTtcbiAgICAgICAgfSBlbHNlIGlmICghaXNBcnJheSQxKHZhbHVlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2FzZSBhcmd1bWVudHMgbXVzdCBiZSBhbiBhcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0cnVjdG9ycy5wdXNoKGtleSk7XG4gICAgICAgIGFkdFtrZXldID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICBjb25zdCBhcmdMZW5ndGggPSBhcmdzLmxlbmd0aDtcbiAgICAgICAgICBpZiAoYXJnTGVuZ3RoICE9PSB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBjYXNlICcgKyBrZXkgKyAnLiBFeHBlY3RlZCAnICsgdmFsdWUubGVuZ3RoICsgJyAoJyArIHZhbHVlICsgJyksIGdvdCAnICsgYXJnTGVuZ3RoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgbWF0Y2ggPSBicmFuY2hlcyA9PiB7XG4gICAgICAgICAgICBjb25zdCBicmFuY2hLZXlzID0ga2V5cyhicmFuY2hlcyk7XG4gICAgICAgICAgICBpZiAoY29uc3RydWN0b3JzLmxlbmd0aCAhPT0gYnJhbmNoS2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXcm9uZyBudW1iZXIgb2YgYXJndW1lbnRzIHRvIG1hdGNoLiBFeHBlY3RlZDogJyArIGNvbnN0cnVjdG9ycy5qb2luKCcsJykgKyAnXFxuQWN0dWFsOiAnICsgYnJhbmNoS2V5cy5qb2luKCcsJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYWxsUmVxZCA9IGZvcmFsbChjb25zdHJ1Y3RvcnMsIHJlcUtleSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiBjb250YWlucyQyKGJyYW5jaEtleXMsIHJlcUtleSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghYWxsUmVxZCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhbGwgYnJhbmNoZXMgd2VyZSBzcGVjaWZpZWQgd2hlbiB1c2luZyBtYXRjaC4gU3BlY2lmaWVkOiAnICsgYnJhbmNoS2V5cy5qb2luKCcsICcpICsgJ1xcblJlcXVpcmVkOiAnICsgY29uc3RydWN0b3JzLmpvaW4oJywgJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJyYW5jaGVzW2tleV0uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZm9sZDogKC4uLmZvbGRBcmdzKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChmb2xkQXJncy5sZW5ndGggIT09IGNhc2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBmb2xkLiBFeHBlY3RlZCAnICsgY2FzZXMubGVuZ3RoICsgJywgZ290ICcgKyBmb2xkQXJncy5sZW5ndGgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGZvbGRBcmdzW2NvdW50XTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICAgIGxvZzogbGFiZWwgPT4ge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhsYWJlbCwge1xuICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9ycyxcbiAgICAgICAgICAgICAgICBjb25zdHJ1Y3Rvcjoga2V5LFxuICAgICAgICAgICAgICAgIHBhcmFtczogYXJnc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWR0O1xuICAgIH07XG4gICAgY29uc3QgQWR0ID0geyBnZW5lcmF0ZSB9O1xuXG4gICAgQWR0LmdlbmVyYXRlKFtcbiAgICAgIHtcbiAgICAgICAgYm90aEVycm9yczogW1xuICAgICAgICAgICdlcnJvcjEnLFxuICAgICAgICAgICdlcnJvcjInXG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGZpcnN0RXJyb3I6IFtcbiAgICAgICAgICAnZXJyb3IxJyxcbiAgICAgICAgICAndmFsdWUyJ1xuICAgICAgICBdXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzZWNvbmRFcnJvcjogW1xuICAgICAgICAgICd2YWx1ZTEnLFxuICAgICAgICAgICdlcnJvcjInXG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGJvdGhWYWx1ZXM6IFtcbiAgICAgICAgICAndmFsdWUxJyxcbiAgICAgICAgICAndmFsdWUyJ1xuICAgICAgICBdXG4gICAgICB9XG4gICAgXSk7XG4gICAgY29uc3QgcGFydGl0aW9uJDEgPSByZXN1bHRzID0+IHtcbiAgICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgICBlYWNoJGcocmVzdWx0cywgcmVzdWx0ID0+IHtcbiAgICAgICAgcmVzdWx0LmZvbGQoZXJyID0+IHtcbiAgICAgICAgICBlcnJvcnMucHVzaChlcnIpO1xuICAgICAgICB9LCB2YWx1ZSA9PiB7XG4gICAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXJyb3JzLFxuICAgICAgICB2YWx1ZXNcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IGlzSW5saW5lUGF0dGVybiA9IHBhdHRlcm4gPT4gcGF0dGVybi50eXBlID09PSAnaW5saW5lLWNvbW1hbmQnIHx8IHBhdHRlcm4udHlwZSA9PT0gJ2lubGluZS1mb3JtYXQnO1xuICAgIGNvbnN0IGlzQmxvY2tQYXR0ZXJuID0gcGF0dGVybiA9PiBwYXR0ZXJuLnR5cGUgPT09ICdibG9jay1jb21tYW5kJyB8fCBwYXR0ZXJuLnR5cGUgPT09ICdibG9jay1mb3JtYXQnO1xuICAgIGNvbnN0IHNvcnRQYXR0ZXJucyA9IHBhdHRlcm5zID0+IHNvcnQocGF0dGVybnMsIChhLCBiKSA9PiB7XG4gICAgICBpZiAoYS5zdGFydC5sZW5ndGggPT09IGIuc3RhcnQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGEuc3RhcnQubGVuZ3RoID4gYi5zdGFydC5sZW5ndGggPyAtMSA6IDE7XG4gICAgfSk7XG4gICAgY29uc3Qgbm9ybWFsaXplUGF0dGVybiA9IHBhdHRlcm4gPT4ge1xuICAgICAgY29uc3QgZXJyID0gbWVzc2FnZSA9PiBSZXN1bHQuZXJyb3Ioe1xuICAgICAgICBtZXNzYWdlLFxuICAgICAgICBwYXR0ZXJuXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGZvcm1hdE9yQ21kID0gKG5hbWUsIG9uRm9ybWF0LCBvbkNvbW1hbmQpID0+IHtcbiAgICAgICAgaWYgKHBhdHRlcm4uZm9ybWF0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBsZXQgZm9ybWF0cztcbiAgICAgICAgICBpZiAoaXNBcnJheSQxKHBhdHRlcm4uZm9ybWF0KSkge1xuICAgICAgICAgICAgaWYgKCFmb3JhbGwocGF0dGVybi5mb3JtYXQsIGlzU3RyaW5nKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZXJyKG5hbWUgKyAnIHBhdHRlcm4gaGFzIG5vbi1zdHJpbmcgaXRlbXMgaW4gdGhlIGBmb3JtYXRgIGFycmF5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3JtYXRzID0gcGF0dGVybi5mb3JtYXQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc1N0cmluZyhwYXR0ZXJuLmZvcm1hdCkpIHtcbiAgICAgICAgICAgIGZvcm1hdHMgPSBbcGF0dGVybi5mb3JtYXRdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyKG5hbWUgKyAnIHBhdHRlcm4gaGFzIG5vbi1zdHJpbmcgYGZvcm1hdGAgcGFyYW1ldGVyJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBSZXN1bHQudmFsdWUob25Gb3JtYXQoZm9ybWF0cykpO1xuICAgICAgICB9IGVsc2UgaWYgKHBhdHRlcm4uY21kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoIWlzU3RyaW5nKHBhdHRlcm4uY21kKSkge1xuICAgICAgICAgICAgcmV0dXJuIGVycihuYW1lICsgJyBwYXR0ZXJuIGhhcyBub24tc3RyaW5nIGBjbWRgIHBhcmFtZXRlcicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gUmVzdWx0LnZhbHVlKG9uQ29tbWFuZChwYXR0ZXJuLmNtZCwgcGF0dGVybi52YWx1ZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBlcnIobmFtZSArICcgcGF0dGVybiBpcyBtaXNzaW5nIGJvdGggYGZvcm1hdGAgYW5kIGBjbWRgIHBhcmFtZXRlcnMnKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmICghaXNPYmplY3QocGF0dGVybikpIHtcbiAgICAgICAgcmV0dXJuIGVycignUmF3IHBhdHRlcm4gaXMgbm90IGFuIG9iamVjdCcpO1xuICAgICAgfVxuICAgICAgaWYgKCFpc1N0cmluZyhwYXR0ZXJuLnN0YXJ0KSkge1xuICAgICAgICByZXR1cm4gZXJyKCdSYXcgcGF0dGVybiBpcyBtaXNzaW5nIGBzdGFydGAgcGFyYW1ldGVyJyk7XG4gICAgICB9XG4gICAgICBpZiAocGF0dGVybi5lbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIWlzU3RyaW5nKHBhdHRlcm4uZW5kKSkge1xuICAgICAgICAgIHJldHVybiBlcnIoJ0lubGluZSBwYXR0ZXJuIGhhcyBub24tc3RyaW5nIGBlbmRgIHBhcmFtZXRlcicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXR0ZXJuLnN0YXJ0Lmxlbmd0aCA9PT0gMCAmJiBwYXR0ZXJuLmVuZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gZXJyKCdJbmxpbmUgcGF0dGVybiBoYXMgZW1wdHkgYHN0YXJ0YCBhbmQgYGVuZGAgcGFyYW1ldGVycycpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGFydCA9IHBhdHRlcm4uc3RhcnQ7XG4gICAgICAgIGxldCBlbmQgPSBwYXR0ZXJuLmVuZDtcbiAgICAgICAgaWYgKGVuZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBlbmQgPSBzdGFydDtcbiAgICAgICAgICBzdGFydCA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYXRPckNtZCgnSW5saW5lJywgZm9ybWF0ID0+ICh7XG4gICAgICAgICAgdHlwZTogJ2lubGluZS1mb3JtYXQnLFxuICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgIGVuZCxcbiAgICAgICAgICBmb3JtYXRcbiAgICAgICAgfSksIChjbWQsIHZhbHVlKSA9PiAoe1xuICAgICAgICAgIHR5cGU6ICdpbmxpbmUtY29tbWFuZCcsXG4gICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgZW5kLFxuICAgICAgICAgIGNtZCxcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICB9KSk7XG4gICAgICB9IGVsc2UgaWYgKHBhdHRlcm4ucmVwbGFjZW1lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIWlzU3RyaW5nKHBhdHRlcm4ucmVwbGFjZW1lbnQpKSB7XG4gICAgICAgICAgcmV0dXJuIGVycignUmVwbGFjZW1lbnQgcGF0dGVybiBoYXMgbm9uLXN0cmluZyBgcmVwbGFjZW1lbnRgIHBhcmFtZXRlcicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXR0ZXJuLnN0YXJ0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBlcnIoJ1JlcGxhY2VtZW50IHBhdHRlcm4gaGFzIGVtcHR5IGBzdGFydGAgcGFyYW1ldGVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFJlc3VsdC52YWx1ZSh7XG4gICAgICAgICAgdHlwZTogJ2lubGluZS1jb21tYW5kJyxcbiAgICAgICAgICBzdGFydDogJycsXG4gICAgICAgICAgZW5kOiBwYXR0ZXJuLnN0YXJ0LFxuICAgICAgICAgIGNtZDogJ21jZUluc2VydENvbnRlbnQnLFxuICAgICAgICAgIHZhbHVlOiBwYXR0ZXJuLnJlcGxhY2VtZW50XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHBhdHRlcm4uc3RhcnQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGVycignQmxvY2sgcGF0dGVybiBoYXMgZW1wdHkgYHN0YXJ0YCBwYXJhbWV0ZXInKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0T3JDbWQoJ0Jsb2NrJywgZm9ybWF0cyA9PiAoe1xuICAgICAgICAgIHR5cGU6ICdibG9jay1mb3JtYXQnLFxuICAgICAgICAgIHN0YXJ0OiBwYXR0ZXJuLnN0YXJ0LFxuICAgICAgICAgIGZvcm1hdDogZm9ybWF0c1swXVxuICAgICAgICB9KSwgKGNvbW1hbmQsIGNvbW1hbmRWYWx1ZSkgPT4gKHtcbiAgICAgICAgICB0eXBlOiAnYmxvY2stY29tbWFuZCcsXG4gICAgICAgICAgc3RhcnQ6IHBhdHRlcm4uc3RhcnQsXG4gICAgICAgICAgY21kOiBjb21tYW5kLFxuICAgICAgICAgIHZhbHVlOiBjb21tYW5kVmFsdWVcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZ2V0QmxvY2tQYXR0ZXJucyA9IHBhdHRlcm5zID0+IHNvcnRQYXR0ZXJucyhmaWx0ZXIkNihwYXR0ZXJucywgaXNCbG9ja1BhdHRlcm4pKTtcbiAgICBjb25zdCBnZXRJbmxpbmVQYXR0ZXJucyA9IHBhdHRlcm5zID0+IGZpbHRlciQ2KHBhdHRlcm5zLCBpc0lubGluZVBhdHRlcm4pO1xuICAgIGNvbnN0IGNyZWF0ZVBhdHRlcm5TZXQgPSBwYXR0ZXJucyA9PiAoe1xuICAgICAgaW5saW5lUGF0dGVybnM6IGdldElubGluZVBhdHRlcm5zKHBhdHRlcm5zKSxcbiAgICAgIGJsb2NrUGF0dGVybnM6IGdldEJsb2NrUGF0dGVybnMocGF0dGVybnMpXG4gICAgfSk7XG4gICAgY29uc3QgZnJvbVJhd1BhdHRlcm5zID0gcGF0dGVybnMgPT4ge1xuICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IHBhcnRpdGlvbiQxKG1hcCQzKHBhdHRlcm5zLCBub3JtYWxpemVQYXR0ZXJuKSk7XG4gICAgICBlYWNoJGcobm9ybWFsaXplZC5lcnJvcnMsIGVyciA9PiBjb25zb2xlLmVycm9yKGVyci5tZXNzYWdlLCBlcnIucGF0dGVybikpO1xuICAgICAgcmV0dXJuIG5vcm1hbGl6ZWQudmFsdWVzO1xuICAgIH07XG5cbiAgICBjb25zdCBkZXZpY2VEZXRlY3Rpb24kMSA9IGRldGVjdCQyKCkuZGV2aWNlVHlwZTtcbiAgICBjb25zdCBpc1RvdWNoID0gZGV2aWNlRGV0ZWN0aW9uJDEuaXNUb3VjaCgpO1xuICAgIGNvbnN0IERPTSRhID0gRE9NVXRpbHMuRE9NO1xuICAgIGNvbnN0IGdldEhhc2ggPSB2YWx1ZSA9PiB7XG4gICAgICBjb25zdCBpdGVtcyA9IHZhbHVlLmluZGV4T2YoJz0nKSA+IDAgPyB2YWx1ZS5zcGxpdCgvWzssXSg/IVtePTssXSooPzpbOyxdfCQpKS8pIDogdmFsdWUuc3BsaXQoJywnKTtcbiAgICAgIHJldHVybiBmb2xkbChpdGVtcywgKG91dHB1dCwgaXRlbSkgPT4ge1xuICAgICAgICBjb25zdCBhcnIgPSBpdGVtLnNwbGl0KCc9Jyk7XG4gICAgICAgIGNvbnN0IGtleSA9IGFyclswXTtcbiAgICAgICAgY29uc3QgdmFsID0gYXJyLmxlbmd0aCA+IDEgPyBhcnJbMV0gOiBrZXk7XG4gICAgICAgIG91dHB1dFt0cmltJDMoa2V5KV0gPSB0cmltJDModmFsKTtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgIH0sIHt9KTtcbiAgICB9O1xuICAgIGNvbnN0IGlzUmVnRXhwID0geCA9PiBpcyQ0KHgsIFJlZ0V4cCk7XG4gICAgY29uc3Qgb3B0aW9uID0gbmFtZSA9PiBlZGl0b3IgPT4gZWRpdG9yLm9wdGlvbnMuZ2V0KG5hbWUpO1xuICAgIGNvbnN0IHN0cmluZ09yT2JqZWN0UHJvY2Vzc29yID0gdmFsdWUgPT4gaXNTdHJpbmcodmFsdWUpIHx8IGlzT2JqZWN0KHZhbHVlKTtcbiAgICBjb25zdCBib2R5T3B0aW9uUHJvY2Vzc29yID0gKGVkaXRvciwgZGVmYXVsdFZhbHVlID0gJycpID0+IHZhbHVlID0+IHtcbiAgICAgIGNvbnN0IHZhbGlkID0gaXNTdHJpbmcodmFsdWUpO1xuICAgICAgaWYgKHZhbGlkKSB7XG4gICAgICAgIGlmICh2YWx1ZS5pbmRleE9mKCc9JykgIT09IC0xKSB7XG4gICAgICAgICAgY29uc3QgYm9keU9iaiA9IGdldEhhc2godmFsdWUpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogZ2V0JGEoYm9keU9iaiwgZWRpdG9yLmlkKS5nZXRPcihkZWZhdWx0VmFsdWUpLFxuICAgICAgICAgICAgdmFsaWRcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIHZhbGlkXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWxpZDogZmFsc2UsXG4gICAgICAgICAgbWVzc2FnZTogJ011c3QgYmUgYSBzdHJpbmcuJ1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcmVnaXN0ZXIkNyA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCByZWdpc3Rlck9wdGlvbiA9IGVkaXRvci5vcHRpb25zLnJlZ2lzdGVyO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2lkJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdzdHJpbmcnLFxuICAgICAgICBkZWZhdWx0OiBlZGl0b3IuaWRcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ3NlbGVjdG9yJywgeyBwcm9jZXNzb3I6ICdzdHJpbmcnIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ3RhcmdldCcsIHsgcHJvY2Vzc29yOiAnb2JqZWN0JyB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdzdWZmaXgnLCB7IHByb2Nlc3NvcjogJ3N0cmluZycgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignY2FjaGVfc3VmZml4JywgeyBwcm9jZXNzb3I6ICdzdHJpbmcnIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2Jhc2VfdXJsJywgeyBwcm9jZXNzb3I6ICdzdHJpbmcnIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ3JlZmVycmVyX3BvbGljeScsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnc3RyaW5nJyxcbiAgICAgICAgZGVmYXVsdDogJydcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2xhbmd1YWdlX2xvYWQnLCB7IHByb2Nlc3NvcjogJ2Jvb2xlYW4nIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2lubGluZScsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnYm9vbGVhbicsXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdpZnJhbWVfYXR0cnMnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ29iamVjdCcsXG4gICAgICAgIGRlZmF1bHQ6IHt9XG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdkb2N0eXBlJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdzdHJpbmcnLFxuICAgICAgICBkZWZhdWx0OiAnPCFET0NUWVBFIGh0bWw+J1xuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignZG9jdW1lbnRfYmFzZV91cmwnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ3N0cmluZycsXG4gICAgICAgIGRlZmF1bHQ6IGVkaXRvci5kb2N1bWVudEJhc2VVcmxcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2JvZHlfaWQnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogYm9keU9wdGlvblByb2Nlc3NvcihlZGl0b3IsICd0aW55bWNlJyksXG4gICAgICAgIGRlZmF1bHQ6ICd0aW55bWNlJ1xuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignYm9keV9jbGFzcycsIHtcbiAgICAgICAgcHJvY2Vzc29yOiBib2R5T3B0aW9uUHJvY2Vzc29yKGVkaXRvciksXG4gICAgICAgIGRlZmF1bHQ6ICcnXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdjb250ZW50X3NlY3VyaXR5X3BvbGljeScsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnc3RyaW5nJyxcbiAgICAgICAgZGVmYXVsdDogJydcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2JyX2luX3ByZScsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnYm9vbGVhbicsXG4gICAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2ZvcmNlZF9yb290X2Jsb2NrJywge1xuICAgICAgICBwcm9jZXNzb3I6IHZhbHVlID0+IHtcbiAgICAgICAgICBjb25zdCB2YWxpZCA9IGlzU3RyaW5nKHZhbHVlKSAmJiBpc05vdEVtcHR5KHZhbHVlKTtcbiAgICAgICAgICBpZiAodmFsaWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICB2YWxpZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdmFsaWQ6IGZhbHNlLFxuICAgICAgICAgICAgICBtZXNzYWdlOiAnTXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcuJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRlZmF1bHQ6ICdwJ1xuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignZm9yY2VkX3Jvb3RfYmxvY2tfYXR0cnMnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ29iamVjdCcsXG4gICAgICAgIGRlZmF1bHQ6IHt9XG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdicl9uZXdsaW5lX3NlbGVjdG9yJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdzdHJpbmcnLFxuICAgICAgICBkZWZhdWx0OiAnLm1jZS10b2MgaDIsZmlnY2FwdGlvbixjYXB0aW9uJ1xuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignbm9fbmV3bGluZV9zZWxlY3RvcicsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnc3RyaW5nJyxcbiAgICAgICAgZGVmYXVsdDogJydcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2tlZXBfc3R5bGVzJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignZW5kX2NvbnRhaW5lcl9vbl9lbXB0eV9ibG9jaycsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnYm9vbGVhbicsXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdmb250X3NpemVfc3R5bGVfdmFsdWVzJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdzdHJpbmcnLFxuICAgICAgICBkZWZhdWx0OiAneHgtc21hbGwseC1zbWFsbCxzbWFsbCxtZWRpdW0sbGFyZ2UseC1sYXJnZSx4eC1sYXJnZSdcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2ZvbnRfc2l6ZV9sZWdhY3lfdmFsdWVzJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdzdHJpbmcnLFxuICAgICAgICBkZWZhdWx0OiAneHgtc21hbGwsc21hbGwsbWVkaXVtLGxhcmdlLHgtbGFyZ2UseHgtbGFyZ2UsMzAwJSdcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2ZvbnRfc2l6ZV9jbGFzc2VzJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdzdHJpbmcnLFxuICAgICAgICBkZWZhdWx0OiAnJ1xuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignYXV0b21hdGljX3VwbG9hZHMnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ2Jvb2xlYW4nLFxuICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdpbWFnZXNfcmV1c2VfZmlsZW5hbWUnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ2Jvb2xlYW4nLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignaW1hZ2VzX3JlcGxhY2VfYmxvYl91cmlzJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignaWNvbnMnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ3N0cmluZycsXG4gICAgICAgIGRlZmF1bHQ6ICcnXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdpY29uc191cmwnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ3N0cmluZycsXG4gICAgICAgIGRlZmF1bHQ6ICcnXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdpbWFnZXNfdXBsb2FkX3VybCcsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnc3RyaW5nJyxcbiAgICAgICAgZGVmYXVsdDogJydcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2ltYWdlc191cGxvYWRfYmFzZV9wYXRoJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdzdHJpbmcnLFxuICAgICAgICBkZWZhdWx0OiAnJ1xuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignaW1hZ2VzX3VwbG9hZF9iYXNlX3BhdGgnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ3N0cmluZycsXG4gICAgICAgIGRlZmF1bHQ6ICcnXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdpbWFnZXNfdXBsb2FkX2NyZWRlbnRpYWxzJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2ltYWdlc191cGxvYWRfaGFuZGxlcicsIHsgcHJvY2Vzc29yOiAnZnVuY3Rpb24nIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2xhbmd1YWdlJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdzdHJpbmcnLFxuICAgICAgICBkZWZhdWx0OiAnZW4nXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdsYW5ndWFnZV91cmwnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ3N0cmluZycsXG4gICAgICAgIGRlZmF1bHQ6ICcnXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdlbnRpdHlfZW5jb2RpbmcnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ3N0cmluZycsXG4gICAgICAgIGRlZmF1bHQ6ICduYW1lZCdcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2luZGVudCcsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnYm9vbGVhbicsXG4gICAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2luZGVudF9iZWZvcmUnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ3N0cmluZycsXG4gICAgICAgIGRlZmF1bHQ6ICdwLGgxLGgyLGgzLGg0LGg1LGg2LGJsb2NrcXVvdGUsZGl2LHRpdGxlLHN0eWxlLHByZSxzY3JpcHQsdGQsdGgsdWwsb2wsbGksZGwsZHQsZGQsYXJlYSx0YWJsZSx0aGVhZCwnICsgJ3Rmb290LHRib2R5LHRyLHNlY3Rpb24sc3VtbWFyeSxhcnRpY2xlLGhncm91cCxhc2lkZSxmaWd1cmUsZmlnY2FwdGlvbixvcHRpb24sb3B0Z3JvdXAsZGF0YWxpc3QnXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdpbmRlbnRfYWZ0ZXInLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ3N0cmluZycsXG4gICAgICAgIGRlZmF1bHQ6ICdwLGgxLGgyLGgzLGg0LGg1LGg2LGJsb2NrcXVvdGUsZGl2LHRpdGxlLHN0eWxlLHByZSxzY3JpcHQsdGQsdGgsdWwsb2wsbGksZGwsZHQsZGQsYXJlYSx0YWJsZSx0aGVhZCwnICsgJ3Rmb290LHRib2R5LHRyLHNlY3Rpb24sc3VtbWFyeSxhcnRpY2xlLGhncm91cCxhc2lkZSxmaWd1cmUsZmlnY2FwdGlvbixvcHRpb24sb3B0Z3JvdXAsZGF0YWxpc3QnXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdpbmRlbnRfdXNlX21hcmdpbicsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnYm9vbGVhbicsXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdpbmRlbnRhdGlvbicsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnc3RyaW5nJyxcbiAgICAgICAgZGVmYXVsdDogJzQwcHgnXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdjb250ZW50X2NzcycsIHtcbiAgICAgICAgcHJvY2Vzc29yOiB2YWx1ZSA9PiB7XG4gICAgICAgICAgY29uc3QgdmFsaWQgPSB2YWx1ZSA9PT0gZmFsc2UgfHwgaXNTdHJpbmcodmFsdWUpIHx8IGlzQXJyYXlPZih2YWx1ZSwgaXNTdHJpbmcpO1xuICAgICAgICAgIGlmICh2YWxpZCkge1xuICAgICAgICAgICAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBtYXAkMyh2YWx1ZS5zcGxpdCgnLCcpLCB0cmltJDMpLFxuICAgICAgICAgICAgICAgIHZhbGlkXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkkMSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICB2YWxpZFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogW10sXG4gICAgICAgICAgICAgICAgdmFsaWRcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgdmFsaWRcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdmFsaWQ6IGZhbHNlLFxuICAgICAgICAgICAgICBtZXNzYWdlOiAnTXVzdCBiZSBmYWxzZSwgYSBzdHJpbmcgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncy4nXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZGVmYXVsdDogaXNJbmxpbmUoZWRpdG9yKSA/IFtdIDogWydkZWZhdWx0J11cbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2NvbnRlbnRfc3R5bGUnLCB7IHByb2Nlc3NvcjogJ3N0cmluZycgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignY29udGVudF9jc3NfY29ycycsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnYm9vbGVhbicsXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdmb250X2NzcycsIHtcbiAgICAgICAgcHJvY2Vzc29yOiB2YWx1ZSA9PiB7XG4gICAgICAgICAgY29uc3QgdmFsaWQgPSBpc1N0cmluZyh2YWx1ZSkgfHwgaXNBcnJheU9mKHZhbHVlLCBpc1N0cmluZyk7XG4gICAgICAgICAgaWYgKHZhbGlkKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IGlzQXJyYXkkMSh2YWx1ZSkgPyB2YWx1ZSA6IG1hcCQzKHZhbHVlLnNwbGl0KCcsJyksIHRyaW0kMyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB2YWx1ZTogbmV3VmFsdWUsXG4gICAgICAgICAgICAgIHZhbGlkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB2YWxpZDogZmFsc2UsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6ICdNdXN0IGJlIGEgc3RyaW5nIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MuJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRlZmF1bHQ6IFtdXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdpbmxpbmVfYm91bmRhcmllcycsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnYm9vbGVhbicsXG4gICAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2lubGluZV9ib3VuZGFyaWVzX3NlbGVjdG9yJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdzdHJpbmcnLFxuICAgICAgICBkZWZhdWx0OiAnYVtocmVmXSxjb2RlLC5tY2UtYW5ub3RhdGlvbidcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ29iamVjdF9yZXNpemluZycsIHtcbiAgICAgICAgcHJvY2Vzc29yOiB2YWx1ZSA9PiB7XG4gICAgICAgICAgY29uc3QgdmFsaWQgPSBpc0Jvb2xlYW4odmFsdWUpIHx8IGlzU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICBpZiAodmFsaWQpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UgfHwgZGV2aWNlRGV0ZWN0aW9uJDEuaXNpUGhvbmUoKSB8fCBkZXZpY2VEZXRlY3Rpb24kMS5pc2lQYWQoKSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiAnJyxcbiAgICAgICAgICAgICAgICB2YWxpZFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUgPT09IHRydWUgPyAndGFibGUsaW1nLGZpZ3VyZS5pbWFnZSxkaXYsdmlkZW8saWZyYW1lJyA6IHZhbHVlLFxuICAgICAgICAgICAgICAgIHZhbGlkXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHZhbGlkOiBmYWxzZSxcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ011c3QgYmUgYm9vbGVhbiBvciBhIHN0cmluZydcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkZWZhdWx0OiAhaXNUb3VjaFxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbigncmVzaXplX2ltZ19wcm9wb3J0aW9uYWwnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ2Jvb2xlYW4nLFxuICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdldmVudF9yb290JywgeyBwcm9jZXNzb3I6ICdvYmplY3QnIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ3NlcnZpY2VfbWVzc2FnZScsIHsgcHJvY2Vzc29yOiAnc3RyaW5nJyB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCd0aGVtZScsIHtcbiAgICAgICAgcHJvY2Vzc29yOiB2YWx1ZSA9PiB2YWx1ZSA9PT0gZmFsc2UgfHwgaXNTdHJpbmcodmFsdWUpIHx8IGlzRnVuY3Rpb24odmFsdWUpLFxuICAgICAgICBkZWZhdWx0OiAnc2lsdmVyJ1xuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbigndGhlbWVfdXJsJywgeyBwcm9jZXNzb3I6ICdzdHJpbmcnIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2Zvcm1hdHMnLCB7IHByb2Nlc3NvcjogJ29iamVjdCcgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignZm9ybWF0X2VtcHR5X2xpbmVzJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ3ByZXZpZXdfc3R5bGVzJywge1xuICAgICAgICBwcm9jZXNzb3I6IHZhbHVlID0+IHtcbiAgICAgICAgICBjb25zdCB2YWxpZCA9IHZhbHVlID09PSBmYWxzZSB8fCBpc1N0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgaWYgKHZhbGlkKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUgPT09IGZhbHNlID8gJycgOiB2YWx1ZSxcbiAgICAgICAgICAgICAgdmFsaWRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHZhbGlkOiBmYWxzZSxcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ011c3QgYmUgZmFsc2Ugb3IgYSBzdHJpbmcnXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZGVmYXVsdDogJ2ZvbnQtZmFtaWx5IGZvbnQtc2l6ZSBmb250LXdlaWdodCBmb250LXN0eWxlIHRleHQtZGVjb3JhdGlvbiB0ZXh0LXRyYW5zZm9ybSBjb2xvciBiYWNrZ3JvdW5kLWNvbG9yIGJvcmRlciBib3JkZXItcmFkaXVzIG91dGxpbmUgdGV4dC1zaGFkb3cnXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdjdXN0b21fdWlfc2VsZWN0b3InLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ3N0cmluZycsXG4gICAgICAgIGRlZmF1bHQ6ICcnXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdoaWRkZW5faW5wdXQnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ2Jvb2xlYW4nLFxuICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdzdWJtaXRfcGF0Y2gnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ2Jvb2xlYW4nLFxuICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdlbmNvZGluZycsIHsgcHJvY2Vzc29yOiAnc3RyaW5nJyB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdhZGRfZm9ybV9zdWJtaXRfdHJpZ2dlcicsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnYm9vbGVhbicsXG4gICAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2FkZF91bmxvYWRfdHJpZ2dlcicsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnYm9vbGVhbicsXG4gICAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2N1c3RvbV91bmRvX3JlZG9fbGV2ZWxzJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdudW1iZXInLFxuICAgICAgICBkZWZhdWx0OiAwXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdkaXNhYmxlX25vZGVjaGFuZ2UnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ2Jvb2xlYW4nLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbigncmVhZG9ubHknLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ2Jvb2xlYW4nLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbigncGx1Z2lucycsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnc3RyaW5nW10nLFxuICAgICAgICBkZWZhdWx0OiBbXVxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignZXh0ZXJuYWxfcGx1Z2lucycsIHsgcHJvY2Vzc29yOiAnb2JqZWN0JyB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdmb3JjZWRfcGx1Z2lucycsIHsgcHJvY2Vzc29yOiAnc3RyaW5nW10nIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ21vZGVsJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdzdHJpbmcnLFxuICAgICAgICBkZWZhdWx0OiBlZGl0b3IuaGFzUGx1Z2luKCdydGMnKSA/ICdwbHVnaW4nIDogJ2RvbSdcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ21vZGVsX3VybCcsIHsgcHJvY2Vzc29yOiAnc3RyaW5nJyB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdibG9ja191bnN1cHBvcnRlZF9kcm9wJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbigndmlzdWFsJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbigndmlzdWFsX3RhYmxlX2NsYXNzJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdzdHJpbmcnLFxuICAgICAgICBkZWZhdWx0OiAnbWNlLWl0ZW0tdGFibGUnXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCd2aXN1YWxfYW5jaG9yX2NsYXNzJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdzdHJpbmcnLFxuICAgICAgICBkZWZhdWx0OiAnbWNlLWl0ZW0tYW5jaG9yJ1xuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignaWZyYW1lX2FyaWFfdGV4dCcsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnc3RyaW5nJyxcbiAgICAgICAgZGVmYXVsdDogJ1JpY2ggVGV4dCBBcmVhLiBQcmVzcyBBTFQtMCBmb3IgaGVscC4nXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdzZXR1cCcsIHsgcHJvY2Vzc29yOiAnZnVuY3Rpb24nIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2luaXRfaW5zdGFuY2VfY2FsbGJhY2snLCB7IHByb2Nlc3NvcjogJ2Z1bmN0aW9uJyB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCd1cmxfY29udmVydGVyJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdmdW5jdGlvbicsXG4gICAgICAgIGRlZmF1bHQ6IGVkaXRvci5jb252ZXJ0VVJMXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCd1cmxfY29udmVydGVyX3Njb3BlJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdvYmplY3QnLFxuICAgICAgICBkZWZhdWx0OiBlZGl0b3JcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ3VybGNvbnZlcnRlcl9jYWxsYmFjaycsIHsgcHJvY2Vzc29yOiAnZnVuY3Rpb24nIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2FsbG93X2NvbmRpdGlvbmFsX2NvbW1lbnRzJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2FsbG93X2h0bWxfZGF0YV91cmxzJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2FsbG93X3N2Z19kYXRhX3VybHMnLCB7IHByb2Nlc3NvcjogJ2Jvb2xlYW4nIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2FsbG93X2h0bWxfaW5fbmFtZWRfYW5jaG9yJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2FsbG93X3NjcmlwdF91cmxzJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2FsbG93X3Vuc2FmZV9saW5rX3RhcmdldCcsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnYm9vbGVhbicsXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdjb252ZXJ0X2ZvbnRzX3RvX3NwYW5zJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICAgICAgZGVwcmVjYXRlZDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignZml4X2xpc3RfZWxlbWVudHMnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ2Jvb2xlYW4nLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbigncHJlc2VydmVfY2RhdGEnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ2Jvb2xlYW4nLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbigncmVtb3ZlX3RyYWlsaW5nX2JycycsIHsgcHJvY2Vzc29yOiAnYm9vbGVhbicgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignaW5saW5lX3N0eWxlcycsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnYm9vbGVhbicsXG4gICAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgICAgIGRlcHJlY2F0ZWQ6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2VsZW1lbnRfZm9ybWF0Jywge1xuICAgICAgICBwcm9jZXNzb3I6ICdzdHJpbmcnLFxuICAgICAgICBkZWZhdWx0OiAnaHRtbCdcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2VudGl0aWVzJywgeyBwcm9jZXNzb3I6ICdzdHJpbmcnIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ3NjaGVtYScsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnc3RyaW5nJyxcbiAgICAgICAgZGVmYXVsdDogJ2h0bWw1J1xuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignY29udmVydF91cmxzJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbigncmVsYXRpdmVfdXJscycsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnYm9vbGVhbicsXG4gICAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ3JlbW92ZV9zY3JpcHRfaG9zdCcsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnYm9vbGVhbicsXG4gICAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2N1c3RvbV9lbGVtZW50cycsIHsgcHJvY2Vzc29yOiAnc3RyaW5nJyB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdleHRlbmRlZF92YWxpZF9lbGVtZW50cycsIHsgcHJvY2Vzc29yOiAnc3RyaW5nJyB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdpbnZhbGlkX2VsZW1lbnRzJywgeyBwcm9jZXNzb3I6ICdzdHJpbmcnIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2ludmFsaWRfc3R5bGVzJywgeyBwcm9jZXNzb3I6IHN0cmluZ09yT2JqZWN0UHJvY2Vzc29yIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ3ZhbGlkX2NoaWxkcmVuJywgeyBwcm9jZXNzb3I6ICdzdHJpbmcnIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ3ZhbGlkX2NsYXNzZXMnLCB7IHByb2Nlc3Nvcjogc3RyaW5nT3JPYmplY3RQcm9jZXNzb3IgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbigndmFsaWRfZWxlbWVudHMnLCB7IHByb2Nlc3NvcjogJ3N0cmluZycgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbigndmFsaWRfc3R5bGVzJywgeyBwcm9jZXNzb3I6IHN0cmluZ09yT2JqZWN0UHJvY2Vzc29yIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ3ZlcmlmeV9odG1sJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignYXV0b19mb2N1cycsIHsgcHJvY2Vzc29yOiB2YWx1ZSA9PiBpc1N0cmluZyh2YWx1ZSkgfHwgdmFsdWUgPT09IHRydWUgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignYnJvd3Nlcl9zcGVsbGNoZWNrJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ3Byb3RlY3QnLCB7IHByb2Nlc3NvcjogJ2FycmF5JyB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdpbWFnZXNfZmlsZV90eXBlcycsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnc3RyaW5nJyxcbiAgICAgICAgZGVmYXVsdDogJ2pwZWcsanBnLGpwZSxqZmksamlmLGpmaWYscG5nLGdpZixibXAsd2VicCdcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2RlcHJlY2F0aW9uX3dhcm5pbmdzJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignYTExeV9hZHZhbmNlZF9vcHRpb25zJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2FwaV9rZXknLCB7IHByb2Nlc3NvcjogJ3N0cmluZycgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbigncGFzdGVfYmxvY2tfZHJvcCcsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnYm9vbGVhbicsXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdwYXN0ZV9kYXRhX2ltYWdlcycsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnYm9vbGVhbicsXG4gICAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ3Bhc3RlX3ByZXByb2Nlc3MnLCB7IHByb2Nlc3NvcjogJ2Z1bmN0aW9uJyB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdwYXN0ZV9wb3N0cHJvY2VzcycsIHsgcHJvY2Vzc29yOiAnZnVuY3Rpb24nIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ3Bhc3RlX3dlYmtpdF9zdHlsZXMnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ3N0cmluZycsXG4gICAgICAgIGRlZmF1bHQ6ICdub25lJ1xuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbigncGFzdGVfcmVtb3ZlX3N0eWxlc19pZl93ZWJraXQnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ2Jvb2xlYW4nLFxuICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdwYXN0ZV9tZXJnZV9mb3JtYXRzJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignc21hcnRfcGFzdGUnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ2Jvb2xlYW4nLFxuICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdwYXN0ZV9hc190ZXh0Jywge1xuICAgICAgICBwcm9jZXNzb3I6ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ3Bhc3RlX3RhYl9zcGFjZXMnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ251bWJlcicsXG4gICAgICAgIGRlZmF1bHQ6IDRcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ3RleHRfcGF0dGVybnMnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogdmFsdWUgPT4ge1xuICAgICAgICAgIGlmIChpc0FycmF5T2YodmFsdWUsIGlzT2JqZWN0KSB8fCB2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdHRlcm5zID0gdmFsdWUgPT09IGZhbHNlID8gW10gOiB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHZhbHVlOiBmcm9tUmF3UGF0dGVybnMocGF0dGVybnMpLFxuICAgICAgICAgICAgICB2YWxpZDogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdmFsaWQ6IGZhbHNlLFxuICAgICAgICAgICAgICBtZXNzYWdlOiAnTXVzdCBiZSBhbiBhcnJheSBvZiBvYmplY3RzIG9yIGZhbHNlLidcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkZWZhdWx0OiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgc3RhcnQ6ICcqJyxcbiAgICAgICAgICAgIGVuZDogJyonLFxuICAgICAgICAgICAgZm9ybWF0OiAnaXRhbGljJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgc3RhcnQ6ICcqKicsXG4gICAgICAgICAgICBlbmQ6ICcqKicsXG4gICAgICAgICAgICBmb3JtYXQ6ICdib2xkJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgc3RhcnQ6ICcjJyxcbiAgICAgICAgICAgIGZvcm1hdDogJ2gxJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgc3RhcnQ6ICcjIycsXG4gICAgICAgICAgICBmb3JtYXQ6ICdoMidcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHN0YXJ0OiAnIyMjJyxcbiAgICAgICAgICAgIGZvcm1hdDogJ2gzJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgc3RhcnQ6ICcjIyMjJyxcbiAgICAgICAgICAgIGZvcm1hdDogJ2g0J1xuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgc3RhcnQ6ICcjIyMjIycsXG4gICAgICAgICAgICBmb3JtYXQ6ICdoNSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHN0YXJ0OiAnIyMjIyMjJyxcbiAgICAgICAgICAgIGZvcm1hdDogJ2g2J1xuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgc3RhcnQ6ICcxLiAnLFxuICAgICAgICAgICAgY21kOiAnSW5zZXJ0T3JkZXJlZExpc3QnXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzdGFydDogJyogJyxcbiAgICAgICAgICAgIGNtZDogJ0luc2VydFVub3JkZXJlZExpc3QnXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzdGFydDogJy0gJyxcbiAgICAgICAgICAgIGNtZDogJ0luc2VydFVub3JkZXJlZExpc3QnXG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdub25lZGl0YWJsZV9jbGFzcycsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnc3RyaW5nJyxcbiAgICAgICAgZGVmYXVsdDogJ21jZU5vbkVkaXRhYmxlJ1xuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignZWRpdGFibGVfY2xhc3MnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ3N0cmluZycsXG4gICAgICAgIGRlZmF1bHQ6ICdtY2VFZGl0YWJsZSdcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ25vbmVkaXRhYmxlX3JlZ2V4cCcsIHtcbiAgICAgICAgcHJvY2Vzc29yOiB2YWx1ZSA9PiB7XG4gICAgICAgICAgaWYgKGlzQXJyYXlPZih2YWx1ZSwgaXNSZWdFeHApKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgdmFsaWQ6IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHZhbHVlOiBbdmFsdWVdLFxuICAgICAgICAgICAgICB2YWxpZDogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdmFsaWQ6IGZhbHNlLFxuICAgICAgICAgICAgICBtZXNzYWdlOiAnTXVzdCBiZSBhIFJlZ0V4cCBvciBhbiBhcnJheSBvZiBSZWdFeHAuJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRlZmF1bHQ6IFtdXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCd0YWJsZV90YWJfbmF2aWdhdGlvbicsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnYm9vbGVhbicsXG4gICAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLm9uKCdTY3JpcHRzTG9hZGVkJywgKCkgPT4ge1xuICAgICAgICByZWdpc3Rlck9wdGlvbignZGlyZWN0aW9uYWxpdHknLCB7XG4gICAgICAgICAgcHJvY2Vzc29yOiAnc3RyaW5nJyxcbiAgICAgICAgICBkZWZhdWx0OiBJMThuLmlzUnRsKCkgPyAncnRsJyA6IHVuZGVmaW5lZFxuICAgICAgICB9KTtcbiAgICAgICAgcmVnaXN0ZXJPcHRpb24oJ3BsYWNlaG9sZGVyJywge1xuICAgICAgICAgIHByb2Nlc3NvcjogJ3N0cmluZycsXG4gICAgICAgICAgZGVmYXVsdDogRE9NJGEuZ2V0QXR0cmliKGVkaXRvci5nZXRFbGVtZW50KCksICdwbGFjZWhvbGRlcicpXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBnZXRJZnJhbWVBdHRycyA9IG9wdGlvbignaWZyYW1lX2F0dHJzJyk7XG4gICAgY29uc3QgZ2V0RG9jVHlwZSA9IG9wdGlvbignZG9jdHlwZScpO1xuICAgIGNvbnN0IGdldERvY3VtZW50QmFzZVVybCA9IG9wdGlvbignZG9jdW1lbnRfYmFzZV91cmwnKTtcbiAgICBjb25zdCBnZXRCb2R5SWQgPSBvcHRpb24oJ2JvZHlfaWQnKTtcbiAgICBjb25zdCBnZXRCb2R5Q2xhc3MgPSBvcHRpb24oJ2JvZHlfY2xhc3MnKTtcbiAgICBjb25zdCBnZXRDb250ZW50U2VjdXJpdHlQb2xpY3kgPSBvcHRpb24oJ2NvbnRlbnRfc2VjdXJpdHlfcG9saWN5Jyk7XG4gICAgY29uc3Qgc2hvdWxkUHV0QnJJblByZSQxID0gb3B0aW9uKCdicl9pbl9wcmUnKTtcbiAgICBjb25zdCBnZXRGb3JjZWRSb290QmxvY2sgPSBvcHRpb24oJ2ZvcmNlZF9yb290X2Jsb2NrJyk7XG4gICAgY29uc3QgZ2V0Rm9yY2VkUm9vdEJsb2NrQXR0cnMgPSBvcHRpb24oJ2ZvcmNlZF9yb290X2Jsb2NrX2F0dHJzJyk7XG4gICAgY29uc3QgZ2V0QnJOZXdMaW5lU2VsZWN0b3IgPSBvcHRpb24oJ2JyX25ld2xpbmVfc2VsZWN0b3InKTtcbiAgICBjb25zdCBnZXROb05ld0xpbmVTZWxlY3RvciA9IG9wdGlvbignbm9fbmV3bGluZV9zZWxlY3RvcicpO1xuICAgIGNvbnN0IHNob3VsZEtlZXBTdHlsZXMgPSBvcHRpb24oJ2tlZXBfc3R5bGVzJyk7XG4gICAgY29uc3Qgc2hvdWxkRW5kQ29udGFpbmVyT25FbXB0eUJsb2NrID0gb3B0aW9uKCdlbmRfY29udGFpbmVyX29uX2VtcHR5X2Jsb2NrJyk7XG4gICAgY29uc3QgaXNBdXRvbWF0aWNVcGxvYWRzRW5hYmxlZCA9IG9wdGlvbignYXV0b21hdGljX3VwbG9hZHMnKTtcbiAgICBjb25zdCBzaG91bGRSZXVzZUZpbGVOYW1lID0gb3B0aW9uKCdpbWFnZXNfcmV1c2VfZmlsZW5hbWUnKTtcbiAgICBjb25zdCBzaG91bGRSZXBsYWNlQmxvYlVyaXMgPSBvcHRpb24oJ2ltYWdlc19yZXBsYWNlX2Jsb2JfdXJpcycpO1xuICAgIGNvbnN0IGdldEljb25QYWNrTmFtZSA9IG9wdGlvbignaWNvbnMnKTtcbiAgICBjb25zdCBnZXRJY29uc1VybCA9IG9wdGlvbignaWNvbnNfdXJsJyk7XG4gICAgY29uc3QgZ2V0SW1hZ2VVcGxvYWRVcmwgPSBvcHRpb24oJ2ltYWdlc191cGxvYWRfdXJsJyk7XG4gICAgY29uc3QgZ2V0SW1hZ2VVcGxvYWRCYXNlUGF0aCA9IG9wdGlvbignaW1hZ2VzX3VwbG9hZF9iYXNlX3BhdGgnKTtcbiAgICBjb25zdCBnZXRJbWFnZXNVcGxvYWRDcmVkZW50aWFscyA9IG9wdGlvbignaW1hZ2VzX3VwbG9hZF9jcmVkZW50aWFscycpO1xuICAgIGNvbnN0IGdldEltYWdlc1VwbG9hZEhhbmRsZXIgPSBvcHRpb24oJ2ltYWdlc191cGxvYWRfaGFuZGxlcicpO1xuICAgIGNvbnN0IHNob3VsZFVzZUNvbnRlbnRDc3NDb3JzID0gb3B0aW9uKCdjb250ZW50X2Nzc19jb3JzJyk7XG4gICAgY29uc3QgZ2V0UmVmZXJyZXJQb2xpY3kgPSBvcHRpb24oJ3JlZmVycmVyX3BvbGljeScpO1xuICAgIGNvbnN0IGdldExhbmd1YWdlQ29kZSA9IG9wdGlvbignbGFuZ3VhZ2UnKTtcbiAgICBjb25zdCBnZXRMYW5ndWFnZVVybCA9IG9wdGlvbignbGFuZ3VhZ2VfdXJsJyk7XG4gICAgY29uc3Qgc2hvdWxkSW5kZW50VXNlTWFyZ2luID0gb3B0aW9uKCdpbmRlbnRfdXNlX21hcmdpbicpO1xuICAgIGNvbnN0IGdldEluZGVudGF0aW9uID0gb3B0aW9uKCdpbmRlbnRhdGlvbicpO1xuICAgIGNvbnN0IGdldENvbnRlbnRDc3MgPSBvcHRpb24oJ2NvbnRlbnRfY3NzJyk7XG4gICAgY29uc3QgZ2V0Q29udGVudFN0eWxlID0gb3B0aW9uKCdjb250ZW50X3N0eWxlJyk7XG4gICAgY29uc3QgZ2V0Rm9udENzcyA9IG9wdGlvbignZm9udF9jc3MnKTtcbiAgICBjb25zdCBnZXREaXJlY3Rpb25hbGl0eSA9IG9wdGlvbignZGlyZWN0aW9uYWxpdHknKTtcbiAgICBjb25zdCBnZXRJbmxpbmVCb3VuZGFyeVNlbGVjdG9yID0gb3B0aW9uKCdpbmxpbmVfYm91bmRhcmllc19zZWxlY3RvcicpO1xuICAgIGNvbnN0IGdldE9iamVjdFJlc2l6aW5nID0gb3B0aW9uKCdvYmplY3RfcmVzaXppbmcnKTtcbiAgICBjb25zdCBnZXRSZXNpemVJbWdQcm9wb3J0aW9uYWwgPSBvcHRpb24oJ3Jlc2l6ZV9pbWdfcHJvcG9ydGlvbmFsJyk7XG4gICAgY29uc3QgZ2V0UGxhY2Vob2xkZXIgPSBvcHRpb24oJ3BsYWNlaG9sZGVyJyk7XG4gICAgY29uc3QgZ2V0RXZlbnRSb290ID0gb3B0aW9uKCdldmVudF9yb290Jyk7XG4gICAgY29uc3QgZ2V0U2VydmljZU1lc3NhZ2UgPSBvcHRpb24oJ3NlcnZpY2VfbWVzc2FnZScpO1xuICAgIGNvbnN0IGdldFRoZW1lID0gb3B0aW9uKCd0aGVtZScpO1xuICAgIGNvbnN0IGdldFRoZW1lVXJsID0gb3B0aW9uKCd0aGVtZV91cmwnKTtcbiAgICBjb25zdCBnZXRNb2RlbCA9IG9wdGlvbignbW9kZWwnKTtcbiAgICBjb25zdCBnZXRNb2RlbFVybCA9IG9wdGlvbignbW9kZWxfdXJsJyk7XG4gICAgY29uc3QgaXNJbmxpbmVCb3VuZGFyaWVzRW5hYmxlZCA9IG9wdGlvbignaW5saW5lX2JvdW5kYXJpZXMnKTtcbiAgICBjb25zdCBnZXRGb3JtYXRzID0gb3B0aW9uKCdmb3JtYXRzJyk7XG4gICAgY29uc3QgZ2V0UHJldmlld1N0eWxlcyA9IG9wdGlvbigncHJldmlld19zdHlsZXMnKTtcbiAgICBjb25zdCBjYW5Gb3JtYXRFbXB0eUxpbmVzID0gb3B0aW9uKCdmb3JtYXRfZW1wdHlfbGluZXMnKTtcbiAgICBjb25zdCBnZXRDdXN0b21VaVNlbGVjdG9yID0gb3B0aW9uKCdjdXN0b21fdWlfc2VsZWN0b3InKTtcbiAgICBjb25zdCBpc0lubGluZSA9IG9wdGlvbignaW5saW5lJyk7XG4gICAgY29uc3QgaGFzSGlkZGVuSW5wdXQgPSBvcHRpb24oJ2hpZGRlbl9pbnB1dCcpO1xuICAgIGNvbnN0IHNob3VsZFBhdGNoU3VibWl0ID0gb3B0aW9uKCdzdWJtaXRfcGF0Y2gnKTtcbiAgICBjb25zdCBzaG91bGRBZGRGb3JtU3VibWl0VHJpZ2dlciA9IG9wdGlvbignYWRkX2Zvcm1fc3VibWl0X3RyaWdnZXInKTtcbiAgICBjb25zdCBzaG91bGRBZGRVbmxvYWRUcmlnZ2VyID0gb3B0aW9uKCdhZGRfdW5sb2FkX3RyaWdnZXInKTtcbiAgICBjb25zdCBnZXRDdXN0b21VbmRvUmVkb0xldmVscyA9IG9wdGlvbignY3VzdG9tX3VuZG9fcmVkb19sZXZlbHMnKTtcbiAgICBjb25zdCBzaG91bGREaXNhYmxlTm9kZUNoYW5nZSA9IG9wdGlvbignZGlzYWJsZV9ub2RlY2hhbmdlJyk7XG4gICAgY29uc3QgaXNSZWFkT25seSQxID0gb3B0aW9uKCdyZWFkb25seScpO1xuICAgIGNvbnN0IGhhc0NvbnRlbnRDc3NDb3JzID0gb3B0aW9uKCdjb250ZW50X2Nzc19jb3JzJyk7XG4gICAgY29uc3QgZ2V0UGx1Z2lucyA9IG9wdGlvbigncGx1Z2lucycpO1xuICAgIGNvbnN0IGdldEV4dGVybmFsUGx1Z2lucyQxID0gb3B0aW9uKCdleHRlcm5hbF9wbHVnaW5zJyk7XG4gICAgY29uc3Qgc2hvdWxkQmxvY2tVbnN1cHBvcnRlZERyb3AgPSBvcHRpb24oJ2Jsb2NrX3Vuc3VwcG9ydGVkX2Ryb3AnKTtcbiAgICBjb25zdCBpc1Zpc3VhbEFpZHNFbmFibGVkID0gb3B0aW9uKCd2aXN1YWwnKTtcbiAgICBjb25zdCBnZXRWaXN1YWxBaWRzVGFibGVDbGFzcyA9IG9wdGlvbigndmlzdWFsX3RhYmxlX2NsYXNzJyk7XG4gICAgY29uc3QgZ2V0VmlzdWFsQWlkc0FuY2hvckNsYXNzID0gb3B0aW9uKCd2aXN1YWxfYW5jaG9yX2NsYXNzJyk7XG4gICAgY29uc3QgZ2V0SWZyYW1lQXJpYVRleHQgPSBvcHRpb24oJ2lmcmFtZV9hcmlhX3RleHQnKTtcbiAgICBjb25zdCBnZXRTZXR1cENhbGxiYWNrID0gb3B0aW9uKCdzZXR1cCcpO1xuICAgIGNvbnN0IGdldEluaXRJbnN0YW5jZUNhbGxiYWNrID0gb3B0aW9uKCdpbml0X2luc3RhbmNlX2NhbGxiYWNrJyk7XG4gICAgY29uc3QgZ2V0VXJsQ29udmVydGVyQ2FsbGJhY2sgPSBvcHRpb24oJ3VybGNvbnZlcnRlcl9jYWxsYmFjaycpO1xuICAgIGNvbnN0IGdldEF1dG9Gb2N1cyA9IG9wdGlvbignYXV0b19mb2N1cycpO1xuICAgIGNvbnN0IHNob3VsZEJyb3dzZXJTcGVsbGNoZWNrID0gb3B0aW9uKCdicm93c2VyX3NwZWxsY2hlY2snKTtcbiAgICBjb25zdCBnZXRQcm90ZWN0ID0gb3B0aW9uKCdwcm90ZWN0Jyk7XG4gICAgY29uc3Qgc2hvdWxkUGFzdGVCbG9ja0Ryb3AgPSBvcHRpb24oJ3Bhc3RlX2Jsb2NrX2Ryb3AnKTtcbiAgICBjb25zdCBzaG91bGRQYXN0ZURhdGFJbWFnZXMgPSBvcHRpb24oJ3Bhc3RlX2RhdGFfaW1hZ2VzJyk7XG4gICAgY29uc3QgZ2V0UGFzdGVQcmVQcm9jZXNzID0gb3B0aW9uKCdwYXN0ZV9wcmVwcm9jZXNzJyk7XG4gICAgY29uc3QgZ2V0UGFzdGVQb3N0UHJvY2VzcyA9IG9wdGlvbigncGFzdGVfcG9zdHByb2Nlc3MnKTtcbiAgICBjb25zdCBnZXRQYXN0ZVdlYmtpdFN0eWxlcyA9IG9wdGlvbigncGFzdGVfd2Via2l0X3N0eWxlcycpO1xuICAgIGNvbnN0IHNob3VsZFBhc3RlUmVtb3ZlV2ViS2l0U3R5bGVzID0gb3B0aW9uKCdwYXN0ZV9yZW1vdmVfc3R5bGVzX2lmX3dlYmtpdCcpO1xuICAgIGNvbnN0IHNob3VsZFBhc3RlTWVyZ2VGb3JtYXRzID0gb3B0aW9uKCdwYXN0ZV9tZXJnZV9mb3JtYXRzJyk7XG4gICAgY29uc3QgaXNTbWFydFBhc3RlRW5hYmxlZCA9IG9wdGlvbignc21hcnRfcGFzdGUnKTtcbiAgICBjb25zdCBpc1Bhc3RlQXNUZXh0RW5hYmxlZCA9IG9wdGlvbigncGFzdGVfYXNfdGV4dCcpO1xuICAgIGNvbnN0IGdldFBhc3RlVGFiU3BhY2VzID0gb3B0aW9uKCdwYXN0ZV90YWJfc3BhY2VzJyk7XG4gICAgY29uc3Qgc2hvdWxkQWxsb3dIdG1sRGF0YVVybHMgPSBvcHRpb24oJ2FsbG93X2h0bWxfZGF0YV91cmxzJyk7XG4gICAgY29uc3QgZ2V0VGV4dFBhdHRlcm5zID0gb3B0aW9uKCd0ZXh0X3BhdHRlcm5zJyk7XG4gICAgY29uc3QgZ2V0Tm9uRWRpdGFibGVDbGFzcyA9IG9wdGlvbignbm9uZWRpdGFibGVfY2xhc3MnKTtcbiAgICBjb25zdCBnZXRFZGl0YWJsZUNsYXNzID0gb3B0aW9uKCdlZGl0YWJsZV9jbGFzcycpO1xuICAgIGNvbnN0IGdldE5vbkVkaXRhYmxlUmVnRXhwcyA9IG9wdGlvbignbm9uZWRpdGFibGVfcmVnZXhwJyk7XG4gICAgY29uc3QgZ2V0Rm9udFN0eWxlVmFsdWVzID0gZWRpdG9yID0+IFRvb2xzLmV4cGxvZGUoZWRpdG9yLm9wdGlvbnMuZ2V0KCdmb250X3NpemVfc3R5bGVfdmFsdWVzJykpO1xuICAgIGNvbnN0IGdldEZvbnRTaXplQ2xhc3NlcyA9IGVkaXRvciA9PiBUb29scy5leHBsb2RlKGVkaXRvci5vcHRpb25zLmdldCgnZm9udF9zaXplX2NsYXNzZXMnKSk7XG4gICAgY29uc3QgaXNFbmNvZGluZ1htbCA9IGVkaXRvciA9PiBlZGl0b3Iub3B0aW9ucy5nZXQoJ2VuY29kaW5nJykgPT09ICd4bWwnO1xuICAgIGNvbnN0IGdldEFsbG93ZWRJbWFnZUZpbGVUeXBlcyA9IGVkaXRvciA9PiBUb29scy5leHBsb2RlKGVkaXRvci5vcHRpb25zLmdldCgnaW1hZ2VzX2ZpbGVfdHlwZXMnKSk7XG4gICAgY29uc3QgaGFzVGFibGVUYWJOYXZpZ2F0aW9uID0gb3B0aW9uKCd0YWJsZV90YWJfbmF2aWdhdGlvbicpO1xuXG4gICAgY29uc3QgaXNFbGVtZW50JDMgPSBpc0VsZW1lbnQkNjtcbiAgICBjb25zdCBpc1RleHQkMyA9IGlzVGV4dCQ4O1xuICAgIGNvbnN0IHJlbW92ZU5vZGUkMSA9IG5vZGUgPT4ge1xuICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgIGlmIChwYXJlbnROb2RlKSB7XG4gICAgICAgIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCB0cmltQ291bnQgPSB0ZXh0ID0+IHtcbiAgICAgIGNvbnN0IHRyaW1tZWRUZXh0ID0gdHJpbSQxKHRleHQpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY291bnQ6IHRleHQubGVuZ3RoIC0gdHJpbW1lZFRleHQubGVuZ3RoLFxuICAgICAgICB0ZXh0OiB0cmltbWVkVGV4dFxuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IGRlbGV0ZVp3c3BDaGFycyA9IGNhcmV0Q29udGFpbmVyID0+IHtcbiAgICAgIGxldCBpZHg7XG4gICAgICB3aGlsZSAoKGlkeCA9IGNhcmV0Q29udGFpbmVyLmRhdGEubGFzdEluZGV4T2YoWldTUCQxKSkgIT09IC0xKSB7XG4gICAgICAgIGNhcmV0Q29udGFpbmVyLmRlbGV0ZURhdGEoaWR4LCAxKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlbW92ZVVuY2hhbmdlZCA9IChjYXJldENvbnRhaW5lciwgcG9zKSA9PiB7XG4gICAgICByZW1vdmUkNChjYXJldENvbnRhaW5lcik7XG4gICAgICByZXR1cm4gcG9zO1xuICAgIH07XG4gICAgY29uc3QgcmVtb3ZlVGV4dEFuZFJlcG9zaXRpb24gPSAoY2FyZXRDb250YWluZXIsIHBvcykgPT4ge1xuICAgICAgY29uc3QgYmVmb3JlID0gdHJpbUNvdW50KGNhcmV0Q29udGFpbmVyLmRhdGEuc3Vic3RyKDAsIHBvcy5vZmZzZXQoKSkpO1xuICAgICAgY29uc3QgYWZ0ZXIgPSB0cmltQ291bnQoY2FyZXRDb250YWluZXIuZGF0YS5zdWJzdHIocG9zLm9mZnNldCgpKSk7XG4gICAgICBjb25zdCB0ZXh0ID0gYmVmb3JlLnRleHQgKyBhZnRlci50ZXh0O1xuICAgICAgaWYgKHRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICBkZWxldGVad3NwQ2hhcnMoY2FyZXRDb250YWluZXIpO1xuICAgICAgICByZXR1cm4gQ2FyZXRQb3NpdGlvbihjYXJldENvbnRhaW5lciwgcG9zLm9mZnNldCgpIC0gYmVmb3JlLmNvdW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCByZW1vdmVFbGVtZW50QW5kUmVwb3NpdGlvbiA9IChjYXJldENvbnRhaW5lciwgcG9zKSA9PiB7XG4gICAgICBjb25zdCBwYXJlbnROb2RlID0gcG9zLmNvbnRhaW5lcigpO1xuICAgICAgY29uc3QgbmV3UG9zaXRpb24gPSBpbmRleE9mJDEoZnJvbShwYXJlbnROb2RlLmNoaWxkTm9kZXMpLCBjYXJldENvbnRhaW5lcikubWFwKGluZGV4ID0+IHtcbiAgICAgICAgcmV0dXJuIGluZGV4IDwgcG9zLm9mZnNldCgpID8gQ2FyZXRQb3NpdGlvbihwYXJlbnROb2RlLCBwb3Mub2Zmc2V0KCkgLSAxKSA6IHBvcztcbiAgICAgIH0pLmdldE9yKHBvcyk7XG4gICAgICByZW1vdmUkNChjYXJldENvbnRhaW5lcik7XG4gICAgICByZXR1cm4gbmV3UG9zaXRpb247XG4gICAgfTtcbiAgICBjb25zdCByZW1vdmVUZXh0Q2FyZXRDb250YWluZXIgPSAoY2FyZXRDb250YWluZXIsIHBvcykgPT4gaXNUZXh0JDMoY2FyZXRDb250YWluZXIpICYmIHBvcy5jb250YWluZXIoKSA9PT0gY2FyZXRDb250YWluZXIgPyByZW1vdmVUZXh0QW5kUmVwb3NpdGlvbihjYXJldENvbnRhaW5lciwgcG9zKSA6IHJlbW92ZVVuY2hhbmdlZChjYXJldENvbnRhaW5lciwgcG9zKTtcbiAgICBjb25zdCByZW1vdmVFbGVtZW50Q2FyZXRDb250YWluZXIgPSAoY2FyZXRDb250YWluZXIsIHBvcykgPT4gcG9zLmNvbnRhaW5lcigpID09PSBjYXJldENvbnRhaW5lci5wYXJlbnROb2RlID8gcmVtb3ZlRWxlbWVudEFuZFJlcG9zaXRpb24oY2FyZXRDb250YWluZXIsIHBvcykgOiByZW1vdmVVbmNoYW5nZWQoY2FyZXRDb250YWluZXIsIHBvcyk7XG4gICAgY29uc3QgcmVtb3ZlQW5kUmVwb3NpdGlvbiA9IChjb250YWluZXIsIHBvcykgPT4gQ2FyZXRQb3NpdGlvbi5pc1RleHRQb3NpdGlvbihwb3MpID8gcmVtb3ZlVGV4dENhcmV0Q29udGFpbmVyKGNvbnRhaW5lciwgcG9zKSA6IHJlbW92ZUVsZW1lbnRDYXJldENvbnRhaW5lcihjb250YWluZXIsIHBvcyk7XG4gICAgY29uc3QgcmVtb3ZlJDQgPSBjYXJldENvbnRhaW5lck5vZGUgPT4ge1xuICAgICAgaWYgKGlzRWxlbWVudCQzKGNhcmV0Q29udGFpbmVyTm9kZSkgJiYgaXNDYXJldENvbnRhaW5lciQyKGNhcmV0Q29udGFpbmVyTm9kZSkpIHtcbiAgICAgICAgaWYgKGhhc0NvbnRlbnQoY2FyZXRDb250YWluZXJOb2RlKSkge1xuICAgICAgICAgIGNhcmV0Q29udGFpbmVyTm9kZS5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtbWNlLWNhcmV0Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtb3ZlTm9kZSQxKGNhcmV0Q29udGFpbmVyTm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc1RleHQkMyhjYXJldENvbnRhaW5lck5vZGUpKSB7XG4gICAgICAgIGRlbGV0ZVp3c3BDaGFycyhjYXJldENvbnRhaW5lck5vZGUpO1xuICAgICAgICBpZiAoY2FyZXRDb250YWluZXJOb2RlLmRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmVtb3ZlTm9kZSQxKGNhcmV0Q29udGFpbmVyTm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgaXNDb250ZW50RWRpdGFibGVGYWxzZSQ3ID0gaXNDb250ZW50RWRpdGFibGVGYWxzZSRhO1xuICAgIGNvbnN0IGlzTWVkaWEkMSA9IGlzTWVkaWEkMjtcbiAgICBjb25zdCBpc1RhYmxlQ2VsbCQzID0gaXNUYWJsZUNlbGwkNTtcbiAgICBjb25zdCBpbmxpbmVGYWtlQ2FyZXRTZWxlY3RvciA9ICcqW2NvbnRlbnRFZGl0YWJsZT1mYWxzZV0sdmlkZW8sYXVkaW8sZW1iZWQsb2JqZWN0JztcbiAgICBjb25zdCBnZXRBYnNvbHV0ZUNsaWVudFJlY3QgPSAocm9vdCwgZWxlbWVudCwgYmVmb3JlKSA9PiB7XG4gICAgICBjb25zdCBjbGllbnRSZWN0ID0gY29sbGFwc2UoZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgYmVmb3JlKTtcbiAgICAgIGxldCBzY3JvbGxYO1xuICAgICAgbGV0IHNjcm9sbFk7XG4gICAgICBpZiAocm9vdC50YWdOYW1lID09PSAnQk9EWScpIHtcbiAgICAgICAgY29uc3QgZG9jRWxtID0gcm9vdC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgc2Nyb2xsWCA9IHJvb3Quc2Nyb2xsTGVmdCB8fCBkb2NFbG0uc2Nyb2xsTGVmdDtcbiAgICAgICAgc2Nyb2xsWSA9IHJvb3Quc2Nyb2xsVG9wIHx8IGRvY0VsbS5zY3JvbGxUb3A7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCByb290UmVjdCA9IHJvb3QuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHNjcm9sbFggPSByb290LnNjcm9sbExlZnQgLSByb290UmVjdC5sZWZ0O1xuICAgICAgICBzY3JvbGxZID0gcm9vdC5zY3JvbGxUb3AgLSByb290UmVjdC50b3A7XG4gICAgICB9XG4gICAgICBjbGllbnRSZWN0LmxlZnQgKz0gc2Nyb2xsWDtcbiAgICAgIGNsaWVudFJlY3QucmlnaHQgKz0gc2Nyb2xsWDtcbiAgICAgIGNsaWVudFJlY3QudG9wICs9IHNjcm9sbFk7XG4gICAgICBjbGllbnRSZWN0LmJvdHRvbSArPSBzY3JvbGxZO1xuICAgICAgY2xpZW50UmVjdC53aWR0aCA9IDE7XG4gICAgICBsZXQgbWFyZ2luID0gZWxlbWVudC5vZmZzZXRXaWR0aCAtIGVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgICBpZiAobWFyZ2luID4gMCkge1xuICAgICAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgICAgbWFyZ2luICo9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGNsaWVudFJlY3QubGVmdCArPSBtYXJnaW47XG4gICAgICAgIGNsaWVudFJlY3QucmlnaHQgKz0gbWFyZ2luO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNsaWVudFJlY3Q7XG4gICAgfTtcbiAgICBjb25zdCB0cmltSW5saW5lQ2FyZXRDb250YWluZXJzID0gcm9vdCA9PiB7XG4gICAgICBjb25zdCBmYWtlQ2FyZXRUYXJnZXROb2RlcyA9IGRlc2NlbmRhbnRzKFN1Z2FyRWxlbWVudC5mcm9tRG9tKHJvb3QpLCBpbmxpbmVGYWtlQ2FyZXRTZWxlY3Rvcik7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZha2VDYXJldFRhcmdldE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBmYWtlQ2FyZXRUYXJnZXROb2Rlc1tpXS5kb207XG4gICAgICAgIGxldCBzaWJsaW5nID0gbm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgIGlmIChlbmRzV2l0aENhcmV0Q29udGFpbmVyJDEoc2libGluZykpIHtcbiAgICAgICAgICBjb25zdCBkYXRhID0gc2libGluZy5kYXRhO1xuICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgc2libGluZy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNpYmxpbmcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaWJsaW5nLmRlbGV0ZURhdGEoZGF0YS5sZW5ndGggLSAxLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2libGluZyA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgIGlmIChzdGFydHNXaXRoQ2FyZXRDb250YWluZXIkMShzaWJsaW5nKSkge1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSBzaWJsaW5nLmRhdGE7XG4gICAgICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBzaWJsaW5nLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2libGluZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNpYmxpbmcuZGVsZXRlRGF0YSgwLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IEZha2VDYXJldCA9IChlZGl0b3IsIHJvb3QsIGlzQmxvY2ssIGhhc0ZvY3VzKSA9PiB7XG4gICAgICBjb25zdCBsYXN0VmlzdWFsQ2FyZXQgPSB2YWx1ZSQyKCk7XG4gICAgICBsZXQgY3Vyc29ySW50ZXJ2YWw7XG4gICAgICBsZXQgY2FyZXRDb250YWluZXJOb2RlO1xuICAgICAgY29uc3QgY2FyZXRCbG9jayA9IGdldEZvcmNlZFJvb3RCbG9jayhlZGl0b3IpO1xuICAgICAgY29uc3QgZG9tID0gZWRpdG9yLmRvbTtcbiAgICAgIGNvbnN0IHNob3cgPSAoYmVmb3JlLCBlbGVtZW50KSA9PiB7XG4gICAgICAgIGxldCBybmc7XG4gICAgICAgIGhpZGUoKTtcbiAgICAgICAgaWYgKGlzVGFibGVDZWxsJDMoZWxlbWVudCkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNCbG9jayhlbGVtZW50KSkge1xuICAgICAgICAgIGNhcmV0Q29udGFpbmVyTm9kZSA9IGluc2VydEJsb2NrKGNhcmV0QmxvY2ssIGVsZW1lbnQsIGJlZm9yZSk7XG4gICAgICAgICAgY29uc3QgY2xpZW50UmVjdCA9IGdldEFic29sdXRlQ2xpZW50UmVjdChyb290LCBlbGVtZW50LCBiZWZvcmUpO1xuICAgICAgICAgIGRvbS5zZXRTdHlsZShjYXJldENvbnRhaW5lck5vZGUsICd0b3AnLCBjbGllbnRSZWN0LnRvcCk7XG4gICAgICAgICAgY29uc3QgY2FyZXQgPSBkb20uY3JlYXRlKCdkaXYnLCB7XG4gICAgICAgICAgICAnY2xhc3MnOiAnbWNlLXZpc3VhbC1jYXJldCcsXG4gICAgICAgICAgICAnZGF0YS1tY2UtYm9ndXMnOiAnYWxsJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGRvbS5zZXRTdHlsZXMoY2FyZXQsIHsgLi4uY2xpZW50UmVjdCB9KTtcbiAgICAgICAgICBkb20uYWRkKHJvb3QsIGNhcmV0KTtcbiAgICAgICAgICBsYXN0VmlzdWFsQ2FyZXQuc2V0KHtcbiAgICAgICAgICAgIGNhcmV0LFxuICAgICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICAgIGJlZm9yZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChiZWZvcmUpIHtcbiAgICAgICAgICAgIGRvbS5hZGRDbGFzcyhjYXJldCwgJ21jZS12aXN1YWwtY2FyZXQtYmVmb3JlJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YXJ0QmxpbmsoKTtcbiAgICAgICAgICBybmcgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICBybmcuc2V0U3RhcnQoY2FyZXRDb250YWluZXJOb2RlLCAwKTtcbiAgICAgICAgICBybmcuc2V0RW5kKGNhcmV0Q29udGFpbmVyTm9kZSwgMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FyZXRDb250YWluZXJOb2RlID0gaW5zZXJ0SW5saW5lJDEoZWxlbWVudCwgYmVmb3JlKTtcbiAgICAgICAgICBybmcgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICBpZiAoaXNJbmxpbmVGYWtlQ2FyZXRUYXJnZXQoY2FyZXRDb250YWluZXJOb2RlLm5leHRTaWJsaW5nKSkge1xuICAgICAgICAgICAgcm5nLnNldFN0YXJ0KGNhcmV0Q29udGFpbmVyTm9kZSwgMCk7XG4gICAgICAgICAgICBybmcuc2V0RW5kKGNhcmV0Q29udGFpbmVyTm9kZSwgMCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJuZy5zZXRTdGFydChjYXJldENvbnRhaW5lck5vZGUsIDEpO1xuICAgICAgICAgICAgcm5nLnNldEVuZChjYXJldENvbnRhaW5lck5vZGUsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcm5nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBybmc7XG4gICAgICB9O1xuICAgICAgY29uc3QgaGlkZSA9ICgpID0+IHtcbiAgICAgICAgdHJpbUlubGluZUNhcmV0Q29udGFpbmVycyhyb290KTtcbiAgICAgICAgaWYgKGNhcmV0Q29udGFpbmVyTm9kZSkge1xuICAgICAgICAgIHJlbW92ZSQ0KGNhcmV0Q29udGFpbmVyTm9kZSk7XG4gICAgICAgICAgY2FyZXRDb250YWluZXJOb2RlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsYXN0VmlzdWFsQ2FyZXQub24oY2FyZXRTdGF0ZSA9PiB7XG4gICAgICAgICAgZG9tLnJlbW92ZShjYXJldFN0YXRlLmNhcmV0KTtcbiAgICAgICAgICBsYXN0VmlzdWFsQ2FyZXQuY2xlYXIoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjdXJzb3JJbnRlcnZhbCkge1xuICAgICAgICAgIGNsZWFySW50ZXJ2YWwoY3Vyc29ySW50ZXJ2YWwpO1xuICAgICAgICAgIGN1cnNvckludGVydmFsID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3Qgc3RhcnRCbGluayA9ICgpID0+IHtcbiAgICAgICAgY3Vyc29ySW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgbGFzdFZpc3VhbENhcmV0Lm9uKGNhcmV0U3RhdGUgPT4ge1xuICAgICAgICAgICAgaWYgKGhhc0ZvY3VzKCkpIHtcbiAgICAgICAgICAgICAgZG9tLnRvZ2dsZUNsYXNzKGNhcmV0U3RhdGUuY2FyZXQsICdtY2UtdmlzdWFsLWNhcmV0LWhpZGRlbicpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZG9tLmFkZENsYXNzKGNhcmV0U3RhdGUuY2FyZXQsICdtY2UtdmlzdWFsLWNhcmV0LWhpZGRlbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCA1MDApO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlcG9zaXRpb24gPSAoKSA9PiB7XG4gICAgICAgIGxhc3RWaXN1YWxDYXJldC5vbihjYXJldFN0YXRlID0+IHtcbiAgICAgICAgICBjb25zdCBjbGllbnRSZWN0ID0gZ2V0QWJzb2x1dGVDbGllbnRSZWN0KHJvb3QsIGNhcmV0U3RhdGUuZWxlbWVudCwgY2FyZXRTdGF0ZS5iZWZvcmUpO1xuICAgICAgICAgIGRvbS5zZXRTdHlsZXMoY2FyZXRTdGF0ZS5jYXJldCwgeyAuLi5jbGllbnRSZWN0IH0pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBjb25zdCBkZXN0cm95ID0gKCkgPT4gY2xlYXJJbnRlcnZhbChjdXJzb3JJbnRlcnZhbCk7XG4gICAgICBjb25zdCBnZXRDc3MgPSAoKSA9PiAnLm1jZS12aXN1YWwtY2FyZXQgeycgKyAncG9zaXRpb246IGFic29sdXRlOycgKyAnYmFja2dyb3VuZC1jb2xvcjogYmxhY2s7JyArICdiYWNrZ3JvdW5kLWNvbG9yOiBjdXJyZW50Y29sb3I7JyArICd9JyArICcubWNlLXZpc3VhbC1jYXJldC1oaWRkZW4geycgKyAnZGlzcGxheTogbm9uZTsnICsgJ30nICsgJypbZGF0YS1tY2UtY2FyZXRdIHsnICsgJ3Bvc2l0aW9uOiBhYnNvbHV0ZTsnICsgJ2xlZnQ6IC0xMDAwcHg7JyArICdyaWdodDogYXV0bzsnICsgJ3RvcDogMDsnICsgJ21hcmdpbjogMDsnICsgJ3BhZGRpbmc6IDA7JyArICd9JztcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNob3csXG4gICAgICAgIGhpZGUsXG4gICAgICAgIGdldENzcyxcbiAgICAgICAgcmVwb3NpdGlvbixcbiAgICAgICAgZGVzdHJveVxuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IGlzRmFrZUNhcmV0VGFibGVCcm93c2VyID0gKCkgPT4gRW52LmJyb3dzZXIuaXNGaXJlZm94KCk7XG4gICAgY29uc3QgaXNJbmxpbmVGYWtlQ2FyZXRUYXJnZXQgPSBub2RlID0+IGlzQ29udGVudEVkaXRhYmxlRmFsc2UkNyhub2RlKSB8fCBpc01lZGlhJDEobm9kZSk7XG4gICAgY29uc3QgaXNGYWtlQ2FyZXRUYXJnZXQgPSBub2RlID0+IGlzSW5saW5lRmFrZUNhcmV0VGFyZ2V0KG5vZGUpIHx8IGlzVGFibGUkMyhub2RlKSAmJiBpc0Zha2VDYXJldFRhYmxlQnJvd3NlcigpO1xuXG4gICAgY29uc3QgaXNDb250ZW50RWRpdGFibGVUcnVlJDIgPSBpc0NvbnRlbnRFZGl0YWJsZVRydWUkNDtcbiAgICBjb25zdCBpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJDYgPSBpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJGE7XG4gICAgY29uc3QgaXNNZWRpYSA9IGlzTWVkaWEkMjtcbiAgICBjb25zdCBpc0Jsb2NrTGlrZSA9IG1hdGNoU3R5bGVWYWx1ZXMoJ2Rpc3BsYXknLCAnYmxvY2sgdGFibGUgdGFibGUtY2VsbCB0YWJsZS1jYXB0aW9uIGxpc3QtaXRlbScpO1xuICAgIGNvbnN0IGlzQ2FyZXRDb250YWluZXIgPSBpc0NhcmV0Q29udGFpbmVyJDI7XG4gICAgY29uc3QgaXNDYXJldENvbnRhaW5lckJsb2NrID0gaXNDYXJldENvbnRhaW5lckJsb2NrJDE7XG4gICAgY29uc3QgaXNFbGVtZW50JDIgPSBpc0VsZW1lbnQkNjtcbiAgICBjb25zdCBpc0NhcmV0Q2FuZGlkYXRlJDEgPSBpc0NhcmV0Q2FuZGlkYXRlJDM7XG4gICAgY29uc3QgaXNGb3J3YXJkcyA9IGRpcmVjdGlvbiA9PiBkaXJlY3Rpb24gPiAwO1xuICAgIGNvbnN0IGlzQmFja3dhcmRzID0gZGlyZWN0aW9uID0+IGRpcmVjdGlvbiA8IDA7XG4gICAgY29uc3Qgc2tpcENhcmV0Q29udGFpbmVycyA9ICh3YWxrLCBzaGFsbG93KSA9PiB7XG4gICAgICBsZXQgbm9kZTtcbiAgICAgIHdoaWxlIChub2RlID0gd2FsayhzaGFsbG93KSkge1xuICAgICAgICBpZiAoIWlzQ2FyZXRDb250YWluZXJCbG9jayhub2RlKSkge1xuICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIGNvbnN0IGZpbmROb2RlID0gKG5vZGUsIGRpcmVjdGlvbiwgcHJlZGljYXRlRm4sIHJvb3ROb2RlLCBzaGFsbG93KSA9PiB7XG4gICAgICBjb25zdCB3YWxrZXIgPSBuZXcgRG9tVHJlZVdhbGtlcihub2RlLCByb290Tm9kZSk7XG4gICAgICBjb25zdCBpc0NlZk9yQ2FyZXRDb250YWluZXIgPSBpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJDYobm9kZSkgfHwgaXNDYXJldENvbnRhaW5lckJsb2NrKG5vZGUpO1xuICAgICAgaWYgKGlzQmFja3dhcmRzKGRpcmVjdGlvbikpIHtcbiAgICAgICAgaWYgKGlzQ2VmT3JDYXJldENvbnRhaW5lcikge1xuICAgICAgICAgIG5vZGUgPSBza2lwQ2FyZXRDb250YWluZXJzKHdhbGtlci5wcmV2LmJpbmQod2Fsa2VyKSwgdHJ1ZSk7XG4gICAgICAgICAgaWYgKHByZWRpY2F0ZUZuKG5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKG5vZGUgPSBza2lwQ2FyZXRDb250YWluZXJzKHdhbGtlci5wcmV2LmJpbmQod2Fsa2VyKSwgc2hhbGxvdykpIHtcbiAgICAgICAgICBpZiAocHJlZGljYXRlRm4obm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzRm9yd2FyZHMoZGlyZWN0aW9uKSkge1xuICAgICAgICBpZiAoaXNDZWZPckNhcmV0Q29udGFpbmVyKSB7XG4gICAgICAgICAgbm9kZSA9IHNraXBDYXJldENvbnRhaW5lcnMod2Fsa2VyLm5leHQuYmluZCh3YWxrZXIpLCB0cnVlKTtcbiAgICAgICAgICBpZiAocHJlZGljYXRlRm4obm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAobm9kZSA9IHNraXBDYXJldENvbnRhaW5lcnMod2Fsa2VyLm5leHQuYmluZCh3YWxrZXIpLCBzaGFsbG93KSkge1xuICAgICAgICAgIGlmIChwcmVkaWNhdGVGbihub2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIGNvbnN0IGdldEVkaXRpbmdIb3N0ID0gKG5vZGUsIHJvb3ROb2RlKSA9PiB7XG4gICAgICBjb25zdCBpc0NFVHJ1ZSA9IG5vZGUgPT4gaXNDb250ZW50RWRpdGFibGVUcnVlJDIobm9kZS5kb20pO1xuICAgICAgY29uc3QgaXNSb290ID0gbm9kZSA9PiBub2RlLmRvbSA9PT0gcm9vdE5vZGU7XG4gICAgICByZXR1cm4gYW5jZXN0b3IkMyhTdWdhckVsZW1lbnQuZnJvbURvbShub2RlKSwgaXNDRVRydWUsIGlzUm9vdCkubWFwKGVsbSA9PiBlbG0uZG9tKS5nZXRPcihyb290Tm9kZSk7XG4gICAgfTtcbiAgICBjb25zdCBnZXRQYXJlbnRCbG9jayQzID0gKG5vZGUsIHJvb3ROb2RlKSA9PiB7XG4gICAgICB3aGlsZSAobm9kZSAmJiBub2RlICE9PSByb290Tm9kZSkge1xuICAgICAgICBpZiAoaXNCbG9ja0xpa2Uobm9kZSkpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBjb25zdCBpc0luU2FtZUJsb2NrID0gKGNhcmV0UG9zaXRpb24xLCBjYXJldFBvc2l0aW9uMiwgcm9vdE5vZGUpID0+IGdldFBhcmVudEJsb2NrJDMoY2FyZXRQb3NpdGlvbjEuY29udGFpbmVyKCksIHJvb3ROb2RlKSA9PT0gZ2V0UGFyZW50QmxvY2skMyhjYXJldFBvc2l0aW9uMi5jb250YWluZXIoKSwgcm9vdE5vZGUpO1xuICAgIGNvbnN0IGdldENoaWxkTm9kZUF0UmVsYXRpdmVPZmZzZXQgPSAocmVsYXRpdmVPZmZzZXQsIGNhcmV0UG9zaXRpb24pID0+IHtcbiAgICAgIGlmICghY2FyZXRQb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGNhcmV0UG9zaXRpb24uY29udGFpbmVyKCk7XG4gICAgICBjb25zdCBvZmZzZXQgPSBjYXJldFBvc2l0aW9uLm9mZnNldCgpO1xuICAgICAgaWYgKCFpc0VsZW1lbnQkMihjb250YWluZXIpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbnRhaW5lci5jaGlsZE5vZGVzW29mZnNldCArIHJlbGF0aXZlT2Zmc2V0XTtcbiAgICB9O1xuICAgIGNvbnN0IGJlZm9yZUFmdGVyID0gKGJlZm9yZSwgbm9kZSkgPT4ge1xuICAgICAgY29uc3QgcmFuZ2UgPSBub2RlLm93bmVyRG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgIGlmIChiZWZvcmUpIHtcbiAgICAgICAgcmFuZ2Uuc2V0U3RhcnRCZWZvcmUobm9kZSk7XG4gICAgICAgIHJhbmdlLnNldEVuZEJlZm9yZShub2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJhbmdlLnNldFN0YXJ0QWZ0ZXIobm9kZSk7XG4gICAgICAgIHJhbmdlLnNldEVuZEFmdGVyKG5vZGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH07XG4gICAgY29uc3QgaXNOb2Rlc0luU2FtZUJsb2NrID0gKHJvb3QsIG5vZGUxLCBub2RlMikgPT4gZ2V0UGFyZW50QmxvY2skMyhub2RlMSwgcm9vdCkgPT09IGdldFBhcmVudEJsb2NrJDMobm9kZTIsIHJvb3QpO1xuICAgIGNvbnN0IGxlYW4gPSAobGVmdCwgcm9vdCwgbm9kZSkgPT4ge1xuICAgICAgY29uc3Qgc2libGluZ05hbWUgPSBsZWZ0ID8gJ3ByZXZpb3VzU2libGluZycgOiAnbmV4dFNpYmxpbmcnO1xuICAgICAgd2hpbGUgKG5vZGUgJiYgbm9kZSAhPT0gcm9vdCkge1xuICAgICAgICBsZXQgc2libGluZyA9IG5vZGVbc2libGluZ05hbWVdO1xuICAgICAgICBpZiAoaXNDYXJldENvbnRhaW5lcihzaWJsaW5nKSkge1xuICAgICAgICAgIHNpYmxpbmcgPSBzaWJsaW5nW3NpYmxpbmdOYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDb250ZW50RWRpdGFibGVGYWxzZSQ2KHNpYmxpbmcpIHx8IGlzTWVkaWEoc2libGluZykpIHtcbiAgICAgICAgICBpZiAoaXNOb2Rlc0luU2FtZUJsb2NrKHJvb3QsIHNpYmxpbmcsIG5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gc2libGluZztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQ2FyZXRDYW5kaWRhdGUkMShzaWJsaW5nKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIGNvbnN0IGJlZm9yZSQyID0gY3VycnkoYmVmb3JlQWZ0ZXIsIHRydWUpO1xuICAgIGNvbnN0IGFmdGVyJDIgPSBjdXJyeShiZWZvcmVBZnRlciwgZmFsc2UpO1xuICAgIGNvbnN0IG5vcm1hbGl6ZVJhbmdlID0gKGRpcmVjdGlvbiwgcm9vdCwgcmFuZ2UpID0+IHtcbiAgICAgIGxldCBub2RlO1xuICAgICAgY29uc3QgbGVhbkxlZnQgPSBjdXJyeShsZWFuLCB0cnVlLCByb290KTtcbiAgICAgIGNvbnN0IGxlYW5SaWdodCA9IGN1cnJ5KGxlYW4sIGZhbHNlLCByb290KTtcbiAgICAgIGxldCBjb250YWluZXIgPSByYW5nZS5zdGFydENvbnRhaW5lcjtcbiAgICAgIGNvbnN0IG9mZnNldCA9IHJhbmdlLnN0YXJ0T2Zmc2V0O1xuICAgICAgaWYgKGlzQ2FyZXRDb250YWluZXJCbG9jayQxKGNvbnRhaW5lcikpIHtcbiAgICAgICAgaWYgKCFpc0VsZW1lbnQkMihjb250YWluZXIpKSB7XG4gICAgICAgICAgY29udGFpbmVyID0gY29udGFpbmVyLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbG9jYXRpb24gPSBjb250YWluZXIuZ2V0QXR0cmlidXRlKCdkYXRhLW1jZS1jYXJldCcpO1xuICAgICAgICBpZiAobG9jYXRpb24gPT09ICdiZWZvcmUnKSB7XG4gICAgICAgICAgbm9kZSA9IGNvbnRhaW5lci5uZXh0U2libGluZztcbiAgICAgICAgICBpZiAoaXNGYWtlQ2FyZXRUYXJnZXQobm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBiZWZvcmUkMihub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvY2F0aW9uID09PSAnYWZ0ZXInKSB7XG4gICAgICAgICAgbm9kZSA9IGNvbnRhaW5lci5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgaWYgKGlzRmFrZUNhcmV0VGFyZ2V0KG5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gYWZ0ZXIkMihub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghcmFuZ2UuY29sbGFwc2VkKSB7XG4gICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1RleHQkOChjb250YWluZXIpKSB7XG4gICAgICAgIGlmIChpc0NhcmV0Q29udGFpbmVyKGNvbnRhaW5lcikpIHtcbiAgICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAxKSB7XG4gICAgICAgICAgICBub2RlID0gbGVhblJpZ2h0KGNvbnRhaW5lcik7XG4gICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICByZXR1cm4gYmVmb3JlJDIobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gbGVhbkxlZnQoY29udGFpbmVyKTtcbiAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhZnRlciQyKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAtMSkge1xuICAgICAgICAgICAgbm9kZSA9IGxlYW5MZWZ0KGNvbnRhaW5lcik7XG4gICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICByZXR1cm4gYWZ0ZXIkMihub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUgPSBsZWFuUmlnaHQoY29udGFpbmVyKTtcbiAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBiZWZvcmUkMihub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmRzV2l0aENhcmV0Q29udGFpbmVyJDEoY29udGFpbmVyKSAmJiBvZmZzZXQgPj0gY29udGFpbmVyLmRhdGEubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT09IDEpIHtcbiAgICAgICAgICAgIG5vZGUgPSBsZWFuUmlnaHQoY29udGFpbmVyKTtcbiAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBiZWZvcmUkMihub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydHNXaXRoQ2FyZXRDb250YWluZXIkMShjb250YWluZXIpICYmIG9mZnNldCA8PSAxKSB7XG4gICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gLTEpIHtcbiAgICAgICAgICAgIG5vZGUgPSBsZWFuTGVmdChjb250YWluZXIpO1xuICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGFmdGVyJDIobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2Zmc2V0ID09PSBjb250YWluZXIuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICBub2RlID0gbGVhblJpZ2h0KGNvbnRhaW5lcik7XG4gICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBiZWZvcmUkMihub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvZmZzZXQgPT09IDApIHtcbiAgICAgICAgICBub2RlID0gbGVhbkxlZnQoY29udGFpbmVyKTtcbiAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIGFmdGVyJDIobm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH07XG4gICAgY29uc3QgZ2V0UmVsYXRpdmVDZWZFbG0gPSAoZm9yd2FyZCwgY2FyZXRQb3NpdGlvbikgPT4gT3B0aW9uYWwuZnJvbShnZXRDaGlsZE5vZGVBdFJlbGF0aXZlT2Zmc2V0KGZvcndhcmQgPyAwIDogLTEsIGNhcmV0UG9zaXRpb24pKS5maWx0ZXIoaXNDb250ZW50RWRpdGFibGVGYWxzZSQ2KTtcbiAgICBjb25zdCBnZXROb3JtYWxpemVkUmFuZ2VFbmRQb2ludCA9IChkaXJlY3Rpb24sIHJvb3QsIHJhbmdlKSA9PiB7XG4gICAgICBjb25zdCBub3JtYWxpemVkUmFuZ2UgPSBub3JtYWxpemVSYW5nZShkaXJlY3Rpb24sIHJvb3QsIHJhbmdlKTtcbiAgICAgIGlmIChkaXJlY3Rpb24gPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBDYXJldFBvc2l0aW9uLmZyb21SYW5nZVN0YXJ0KG5vcm1hbGl6ZWRSYW5nZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gQ2FyZXRQb3NpdGlvbi5mcm9tUmFuZ2VFbmQobm9ybWFsaXplZFJhbmdlKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldEVsZW1lbnRGcm9tUG9zaXRpb24gPSBwb3MgPT4gT3B0aW9uYWwuZnJvbShwb3MuZ2V0Tm9kZSgpKS5tYXAoU3VnYXJFbGVtZW50LmZyb21Eb20pO1xuICAgIGNvbnN0IGdldEVsZW1lbnRGcm9tUHJldlBvc2l0aW9uID0gcG9zID0+IE9wdGlvbmFsLmZyb20ocG9zLmdldE5vZGUodHJ1ZSkpLm1hcChTdWdhckVsZW1lbnQuZnJvbURvbSk7XG4gICAgY29uc3QgZ2V0VmlzdWFsQ2FyZXRQb3NpdGlvbiA9ICh3YWxrRm4sIGNhcmV0UG9zaXRpb24pID0+IHtcbiAgICAgIHdoaWxlIChjYXJldFBvc2l0aW9uID0gd2Fsa0ZuKGNhcmV0UG9zaXRpb24pKSB7XG4gICAgICAgIGlmIChjYXJldFBvc2l0aW9uLmlzVmlzaWJsZSgpKSB7XG4gICAgICAgICAgcmV0dXJuIGNhcmV0UG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjYXJldFBvc2l0aW9uO1xuICAgIH07XG4gICAgY29uc3QgaXNNb3ZlSW5zaWRlU2FtZUJsb2NrID0gKGZyb20sIHRvKSA9PiB7XG4gICAgICBjb25zdCBpblNhbWVCbG9jayA9IGlzSW5TYW1lQmxvY2soZnJvbSwgdG8pO1xuICAgICAgaWYgKCFpblNhbWVCbG9jayAmJiBpc0JyJDUoZnJvbS5nZXROb2RlKCkpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGluU2FtZUJsb2NrO1xuICAgIH07XG5cbiAgICB2YXIgSERpcmVjdGlvbjtcbiAgICAoZnVuY3Rpb24gKEhEaXJlY3Rpb24pIHtcbiAgICAgIEhEaXJlY3Rpb25bSERpcmVjdGlvblsnQmFja3dhcmRzJ10gPSAtMV0gPSAnQmFja3dhcmRzJztcbiAgICAgIEhEaXJlY3Rpb25bSERpcmVjdGlvblsnRm9yd2FyZHMnXSA9IDFdID0gJ0ZvcndhcmRzJztcbiAgICB9KEhEaXJlY3Rpb24gfHwgKEhEaXJlY3Rpb24gPSB7fSkpKTtcbiAgICBjb25zdCBpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJDUgPSBpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJGE7XG4gICAgY29uc3QgaXNUZXh0JDIgPSBpc1RleHQkODtcbiAgICBjb25zdCBpc0VsZW1lbnQkMSA9IGlzRWxlbWVudCQ2O1xuICAgIGNvbnN0IGlzQnIkMSA9IGlzQnIkNTtcbiAgICBjb25zdCBpc0NhcmV0Q2FuZGlkYXRlID0gaXNDYXJldENhbmRpZGF0ZSQzO1xuICAgIGNvbnN0IGlzQXRvbWljID0gaXNBdG9taWMkMTtcbiAgICBjb25zdCBpc0VkaXRhYmxlQ2FyZXRDYW5kaWRhdGUgPSBpc0VkaXRhYmxlQ2FyZXRDYW5kaWRhdGUkMTtcbiAgICBjb25zdCBnZXRQYXJlbnRzJDMgPSAobm9kZSwgcm9vdCkgPT4ge1xuICAgICAgY29uc3QgcGFyZW50cyA9IFtdO1xuICAgICAgd2hpbGUgKG5vZGUgJiYgbm9kZSAhPT0gcm9vdCkge1xuICAgICAgICBwYXJlbnRzLnB1c2gobm9kZSk7XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyZW50cztcbiAgICB9O1xuICAgIGNvbnN0IG5vZGVBdEluZGV4ID0gKGNvbnRhaW5lciwgb2Zmc2V0KSA9PiB7XG4gICAgICBpZiAoY29udGFpbmVyLmhhc0NoaWxkTm9kZXMoKSAmJiBvZmZzZXQgPCBjb250YWluZXIuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lci5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIGNvbnN0IGdldENhcmV0Q2FuZGlkYXRlUG9zaXRpb24gPSAoZGlyZWN0aW9uLCBub2RlKSA9PiB7XG4gICAgICBpZiAoaXNGb3J3YXJkcyhkaXJlY3Rpb24pKSB7XG4gICAgICAgIGlmIChpc0NhcmV0Q2FuZGlkYXRlKG5vZGUucHJldmlvdXNTaWJsaW5nKSAmJiAhaXNUZXh0JDIobm9kZS5wcmV2aW91c1NpYmxpbmcpKSB7XG4gICAgICAgICAgcmV0dXJuIENhcmV0UG9zaXRpb24uYmVmb3JlKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1RleHQkMihub2RlKSkge1xuICAgICAgICAgIHJldHVybiBDYXJldFBvc2l0aW9uKG5vZGUsIDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNCYWNrd2FyZHMoZGlyZWN0aW9uKSkge1xuICAgICAgICBpZiAoaXNDYXJldENhbmRpZGF0ZShub2RlLm5leHRTaWJsaW5nKSAmJiAhaXNUZXh0JDIobm9kZS5uZXh0U2libGluZykpIHtcbiAgICAgICAgICByZXR1cm4gQ2FyZXRQb3NpdGlvbi5hZnRlcihub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNUZXh0JDIobm9kZSkpIHtcbiAgICAgICAgICByZXR1cm4gQ2FyZXRQb3NpdGlvbihub2RlLCBub2RlLmRhdGEubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzQmFja3dhcmRzKGRpcmVjdGlvbikpIHtcbiAgICAgICAgaWYgKGlzQnIkMShub2RlKSkge1xuICAgICAgICAgIHJldHVybiBDYXJldFBvc2l0aW9uLmJlZm9yZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ2FyZXRQb3NpdGlvbi5hZnRlcihub2RlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBDYXJldFBvc2l0aW9uLmJlZm9yZShub2RlKTtcbiAgICB9O1xuICAgIGNvbnN0IG1vdmVGb3J3YXJkRnJvbUJyID0gKHJvb3QsIG5leHROb2RlKSA9PiB7XG4gICAgICBjb25zdCBuZXh0U2libGluZyA9IG5leHROb2RlLm5leHRTaWJsaW5nO1xuICAgICAgaWYgKG5leHRTaWJsaW5nICYmIGlzQ2FyZXRDYW5kaWRhdGUobmV4dFNpYmxpbmcpKSB7XG4gICAgICAgIGlmIChpc1RleHQkMihuZXh0U2libGluZykpIHtcbiAgICAgICAgICByZXR1cm4gQ2FyZXRQb3NpdGlvbihuZXh0U2libGluZywgMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIENhcmV0UG9zaXRpb24uYmVmb3JlKG5leHRTaWJsaW5nKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZpbmRDYXJldFBvc2l0aW9uJDEoSERpcmVjdGlvbi5Gb3J3YXJkcywgQ2FyZXRQb3NpdGlvbi5hZnRlcihuZXh0Tm9kZSksIHJvb3QpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZmluZENhcmV0UG9zaXRpb24kMSA9IChkaXJlY3Rpb24sIHN0YXJ0UG9zLCByb290KSA9PiB7XG4gICAgICBsZXQgbm9kZTtcbiAgICAgIGxldCBuZXh0Tm9kZTtcbiAgICAgIGxldCBpbm5lck5vZGU7XG4gICAgICBsZXQgY2FyZXRQb3NpdGlvbjtcbiAgICAgIGlmICghaXNFbGVtZW50JDEocm9vdCkgfHwgIXN0YXJ0UG9zKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0UG9zLmlzRXF1YWwoQ2FyZXRQb3NpdGlvbi5hZnRlcihyb290KSkgJiYgcm9vdC5sYXN0Q2hpbGQpIHtcbiAgICAgICAgY2FyZXRQb3NpdGlvbiA9IENhcmV0UG9zaXRpb24uYWZ0ZXIocm9vdC5sYXN0Q2hpbGQpO1xuICAgICAgICBpZiAoaXNCYWNrd2FyZHMoZGlyZWN0aW9uKSAmJiBpc0NhcmV0Q2FuZGlkYXRlKHJvb3QubGFzdENoaWxkKSAmJiBpc0VsZW1lbnQkMShyb290Lmxhc3RDaGlsZCkpIHtcbiAgICAgICAgICByZXR1cm4gaXNCciQxKHJvb3QubGFzdENoaWxkKSA/IENhcmV0UG9zaXRpb24uYmVmb3JlKHJvb3QubGFzdENoaWxkKSA6IGNhcmV0UG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhcmV0UG9zaXRpb24gPSBzdGFydFBvcztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGNhcmV0UG9zaXRpb24uY29udGFpbmVyKCk7XG4gICAgICBsZXQgb2Zmc2V0ID0gY2FyZXRQb3NpdGlvbi5vZmZzZXQoKTtcbiAgICAgIGlmIChpc1RleHQkMihjb250YWluZXIpKSB7XG4gICAgICAgIGlmIChpc0JhY2t3YXJkcyhkaXJlY3Rpb24pICYmIG9mZnNldCA+IDApIHtcbiAgICAgICAgICByZXR1cm4gQ2FyZXRQb3NpdGlvbihjb250YWluZXIsIC0tb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNGb3J3YXJkcyhkaXJlY3Rpb24pICYmIG9mZnNldCA8IGNvbnRhaW5lci5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gQ2FyZXRQb3NpdGlvbihjb250YWluZXIsICsrb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gY29udGFpbmVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzQmFja3dhcmRzKGRpcmVjdGlvbikgJiYgb2Zmc2V0ID4gMCkge1xuICAgICAgICAgIG5leHROb2RlID0gbm9kZUF0SW5kZXgoY29udGFpbmVyLCBvZmZzZXQgLSAxKTtcbiAgICAgICAgICBpZiAoaXNDYXJldENhbmRpZGF0ZShuZXh0Tm9kZSkpIHtcbiAgICAgICAgICAgIGlmICghaXNBdG9taWMobmV4dE5vZGUpKSB7XG4gICAgICAgICAgICAgIGlubmVyTm9kZSA9IGZpbmROb2RlKG5leHROb2RlLCBkaXJlY3Rpb24sIGlzRWRpdGFibGVDYXJldENhbmRpZGF0ZSwgbmV4dE5vZGUpO1xuICAgICAgICAgICAgICBpZiAoaW5uZXJOb2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzVGV4dCQyKGlubmVyTm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBDYXJldFBvc2l0aW9uKGlubmVyTm9kZSwgaW5uZXJOb2RlLmRhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIENhcmV0UG9zaXRpb24uYWZ0ZXIoaW5uZXJOb2RlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzVGV4dCQyKG5leHROb2RlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gQ2FyZXRQb3NpdGlvbihuZXh0Tm9kZSwgbmV4dE5vZGUuZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIENhcmV0UG9zaXRpb24uYmVmb3JlKG5leHROb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRm9yd2FyZHMoZGlyZWN0aW9uKSAmJiBvZmZzZXQgPCBjb250YWluZXIuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICBuZXh0Tm9kZSA9IG5vZGVBdEluZGV4KGNvbnRhaW5lciwgb2Zmc2V0KTtcbiAgICAgICAgICBpZiAoaXNDYXJldENhbmRpZGF0ZShuZXh0Tm9kZSkpIHtcbiAgICAgICAgICAgIGlmIChpc0JyJDEobmV4dE5vZGUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBtb3ZlRm9yd2FyZEZyb21Ccihyb290LCBuZXh0Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzQXRvbWljKG5leHROb2RlKSkge1xuICAgICAgICAgICAgICBpbm5lck5vZGUgPSBmaW5kTm9kZShuZXh0Tm9kZSwgZGlyZWN0aW9uLCBpc0VkaXRhYmxlQ2FyZXRDYW5kaWRhdGUsIG5leHROb2RlKTtcbiAgICAgICAgICAgICAgaWYgKGlubmVyTm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChpc1RleHQkMihpbm5lck5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gQ2FyZXRQb3NpdGlvbihpbm5lck5vZGUsIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gQ2FyZXRQb3NpdGlvbi5iZWZvcmUoaW5uZXJOb2RlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzVGV4dCQyKG5leHROb2RlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gQ2FyZXRQb3NpdGlvbihuZXh0Tm9kZSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQ2FyZXRQb3NpdGlvbi5hZnRlcihuZXh0Tm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBuZXh0Tm9kZSA/IG5leHROb2RlIDogY2FyZXRQb3NpdGlvbi5nZXROb2RlKCk7XG4gICAgICB9XG4gICAgICBpZiAoaXNGb3J3YXJkcyhkaXJlY3Rpb24pICYmIGNhcmV0UG9zaXRpb24uaXNBdEVuZCgpIHx8IGlzQmFja3dhcmRzKGRpcmVjdGlvbikgJiYgY2FyZXRQb3NpdGlvbi5pc0F0U3RhcnQoKSkge1xuICAgICAgICBub2RlID0gZmluZE5vZGUobm9kZSwgZGlyZWN0aW9uLCBhbHdheXMsIHJvb3QsIHRydWUpO1xuICAgICAgICBpZiAoaXNFZGl0YWJsZUNhcmV0Q2FuZGlkYXRlKG5vZGUsIHJvb3QpKSB7XG4gICAgICAgICAgcmV0dXJuIGdldENhcmV0Q2FuZGlkYXRlUG9zaXRpb24oZGlyZWN0aW9uLCBub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbmV4dE5vZGUgPSBmaW5kTm9kZShub2RlLCBkaXJlY3Rpb24sIGlzRWRpdGFibGVDYXJldENhbmRpZGF0ZSwgcm9vdCk7XG4gICAgICBjb25zdCByb290Q29udGVudEVkaXRhYmxlRmFsc2VFbG0gPSBsYXN0JDIoZmlsdGVyJDYoZ2V0UGFyZW50cyQzKGNvbnRhaW5lciwgcm9vdCksIGlzQ29udGVudEVkaXRhYmxlRmFsc2UkNSkpO1xuICAgICAgaWYgKHJvb3RDb250ZW50RWRpdGFibGVGYWxzZUVsbSAmJiAoIW5leHROb2RlIHx8ICFyb290Q29udGVudEVkaXRhYmxlRmFsc2VFbG0uY29udGFpbnMobmV4dE5vZGUpKSkge1xuICAgICAgICBpZiAoaXNGb3J3YXJkcyhkaXJlY3Rpb24pKSB7XG4gICAgICAgICAgY2FyZXRQb3NpdGlvbiA9IENhcmV0UG9zaXRpb24uYWZ0ZXIocm9vdENvbnRlbnRFZGl0YWJsZUZhbHNlRWxtKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYXJldFBvc2l0aW9uID0gQ2FyZXRQb3NpdGlvbi5iZWZvcmUocm9vdENvbnRlbnRFZGl0YWJsZUZhbHNlRWxtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FyZXRQb3NpdGlvbjtcbiAgICAgIH1cbiAgICAgIGlmIChuZXh0Tm9kZSkge1xuICAgICAgICByZXR1cm4gZ2V0Q2FyZXRDYW5kaWRhdGVQb3NpdGlvbihkaXJlY3Rpb24sIG5leHROb2RlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgY29uc3QgQ2FyZXRXYWxrZXIgPSByb290ID0+ICh7XG4gICAgICBuZXh0OiBjYXJldFBvc2l0aW9uID0+IHtcbiAgICAgICAgcmV0dXJuIGZpbmRDYXJldFBvc2l0aW9uJDEoSERpcmVjdGlvbi5Gb3J3YXJkcywgY2FyZXRQb3NpdGlvbiwgcm9vdCk7XG4gICAgICB9LFxuICAgICAgcHJldjogY2FyZXRQb3NpdGlvbiA9PiB7XG4gICAgICAgIHJldHVybiBmaW5kQ2FyZXRQb3NpdGlvbiQxKEhEaXJlY3Rpb24uQmFja3dhcmRzLCBjYXJldFBvc2l0aW9uLCByb290KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IHdhbGtUb1Bvc2l0aW9uSW4gPSAoZm9yd2FyZCwgcm9vdCwgc3RhcnQpID0+IHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZm9yd2FyZCA/IENhcmV0UG9zaXRpb24uYmVmb3JlKHN0YXJ0KSA6IENhcmV0UG9zaXRpb24uYWZ0ZXIoc3RhcnQpO1xuICAgICAgcmV0dXJuIGZyb21Qb3NpdGlvbihmb3J3YXJkLCByb290LCBwb3NpdGlvbik7XG4gICAgfTtcbiAgICBjb25zdCBhZnRlckVsZW1lbnQgPSBub2RlID0+IGlzQnIkNShub2RlKSA/IENhcmV0UG9zaXRpb24uYmVmb3JlKG5vZGUpIDogQ2FyZXRQb3NpdGlvbi5hZnRlcihub2RlKTtcbiAgICBjb25zdCBpc0JlZm9yZU9yU3RhcnQgPSBwb3NpdGlvbiA9PiB7XG4gICAgICBpZiAoQ2FyZXRQb3NpdGlvbi5pc1RleHRQb3NpdGlvbihwb3NpdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIHBvc2l0aW9uLm9mZnNldCgpID09PSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGlzQ2FyZXRDYW5kaWRhdGUkMyhwb3NpdGlvbi5nZXROb2RlKCkpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaXNBZnRlck9yRW5kID0gcG9zaXRpb24gPT4ge1xuICAgICAgaWYgKENhcmV0UG9zaXRpb24uaXNUZXh0UG9zaXRpb24ocG9zaXRpb24pKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHBvc2l0aW9uLmNvbnRhaW5lcigpO1xuICAgICAgICByZXR1cm4gcG9zaXRpb24ub2Zmc2V0KCkgPT09IGNvbnRhaW5lci5kYXRhLmxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBpc0NhcmV0Q2FuZGlkYXRlJDMocG9zaXRpb24uZ2V0Tm9kZSh0cnVlKSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBpc0JlZm9yZUFmdGVyU2FtZUVsZW1lbnQgPSAoZnJvbSwgdG8pID0+ICFDYXJldFBvc2l0aW9uLmlzVGV4dFBvc2l0aW9uKGZyb20pICYmICFDYXJldFBvc2l0aW9uLmlzVGV4dFBvc2l0aW9uKHRvKSAmJiBmcm9tLmdldE5vZGUoKSA9PT0gdG8uZ2V0Tm9kZSh0cnVlKTtcbiAgICBjb25zdCBpc0F0QnIgPSBwb3NpdGlvbiA9PiAhQ2FyZXRQb3NpdGlvbi5pc1RleHRQb3NpdGlvbihwb3NpdGlvbikgJiYgaXNCciQ1KHBvc2l0aW9uLmdldE5vZGUoKSk7XG4gICAgY29uc3Qgc2hvdWxkU2tpcFBvc2l0aW9uID0gKGZvcndhcmQsIGZyb20sIHRvKSA9PiB7XG4gICAgICBpZiAoZm9yd2FyZCkge1xuICAgICAgICByZXR1cm4gIWlzQmVmb3JlQWZ0ZXJTYW1lRWxlbWVudChmcm9tLCB0bykgJiYgIWlzQXRCcihmcm9tKSAmJiBpc0FmdGVyT3JFbmQoZnJvbSkgJiYgaXNCZWZvcmVPclN0YXJ0KHRvKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAhaXNCZWZvcmVBZnRlclNhbWVFbGVtZW50KHRvLCBmcm9tKSAmJiBpc0JlZm9yZU9yU3RhcnQoZnJvbSkgJiYgaXNBZnRlck9yRW5kKHRvKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGZyb21Qb3NpdGlvbiA9IChmb3J3YXJkLCByb290LCBwb3MpID0+IHtcbiAgICAgIGNvbnN0IHdhbGtlciA9IENhcmV0V2Fsa2VyKHJvb3QpO1xuICAgICAgcmV0dXJuIE9wdGlvbmFsLmZyb20oZm9yd2FyZCA/IHdhbGtlci5uZXh0KHBvcykgOiB3YWxrZXIucHJldihwb3MpKTtcbiAgICB9O1xuICAgIGNvbnN0IG5hdmlnYXRlID0gKGZvcndhcmQsIHJvb3QsIGZyb20pID0+IGZyb21Qb3NpdGlvbihmb3J3YXJkLCByb290LCBmcm9tKS5iaW5kKHRvID0+IHtcbiAgICAgIGlmIChpc0luU2FtZUJsb2NrKGZyb20sIHRvLCByb290KSAmJiBzaG91bGRTa2lwUG9zaXRpb24oZm9yd2FyZCwgZnJvbSwgdG8pKSB7XG4gICAgICAgIHJldHVybiBmcm9tUG9zaXRpb24oZm9yd2FyZCwgcm9vdCwgdG8pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUodG8pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IG5hdmlnYXRlSWdub3JlID0gKGZvcndhcmQsIHJvb3QsIGZyb20sIGlnbm9yZUZpbHRlcikgPT4gbmF2aWdhdGUoZm9yd2FyZCwgcm9vdCwgZnJvbSkuYmluZChwb3MgPT4gaWdub3JlRmlsdGVyKHBvcykgPyBuYXZpZ2F0ZUlnbm9yZShmb3J3YXJkLCByb290LCBwb3MsIGlnbm9yZUZpbHRlcikgOiBPcHRpb25hbC5zb21lKHBvcykpO1xuICAgIGNvbnN0IHBvc2l0aW9uSW4gPSAoZm9yd2FyZCwgZWxlbWVudCkgPT4ge1xuICAgICAgY29uc3Qgc3RhcnROb2RlID0gZm9yd2FyZCA/IGVsZW1lbnQuZmlyc3RDaGlsZCA6IGVsZW1lbnQubGFzdENoaWxkO1xuICAgICAgaWYgKGlzVGV4dCQ4KHN0YXJ0Tm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoQ2FyZXRQb3NpdGlvbihzdGFydE5vZGUsIGZvcndhcmQgPyAwIDogc3RhcnROb2RlLmRhdGEubGVuZ3RoKSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXJ0Tm9kZSkge1xuICAgICAgICBpZiAoaXNDYXJldENhbmRpZGF0ZSQzKHN0YXJ0Tm9kZSkpIHtcbiAgICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZShmb3J3YXJkID8gQ2FyZXRQb3NpdGlvbi5iZWZvcmUoc3RhcnROb2RlKSA6IGFmdGVyRWxlbWVudChzdGFydE5vZGUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gd2Fsa1RvUG9zaXRpb25Jbihmb3J3YXJkLCBlbGVtZW50LCBzdGFydE5vZGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgbmV4dFBvc2l0aW9uID0gY3VycnkoZnJvbVBvc2l0aW9uLCB0cnVlKTtcbiAgICBjb25zdCBwcmV2UG9zaXRpb24gPSBjdXJyeShmcm9tUG9zaXRpb24sIGZhbHNlKTtcbiAgICBjb25zdCBmaXJzdFBvc2l0aW9uSW4gPSBjdXJyeShwb3NpdGlvbkluLCB0cnVlKTtcbiAgICBjb25zdCBsYXN0UG9zaXRpb25JbiA9IGN1cnJ5KHBvc2l0aW9uSW4sIGZhbHNlKTtcblxuICAgIGNvbnN0IENBUkVUX0lEJDEgPSAnX21jZV9jYXJldCc7XG4gICAgY29uc3QgaXNDYXJldE5vZGUgPSBub2RlID0+IGlzRWxlbWVudCQ2KG5vZGUpICYmIG5vZGUuaWQgPT09IENBUkVUX0lEJDE7XG4gICAgY29uc3QgZ2V0UGFyZW50Q2FyZXRDb250YWluZXIgPSAoYm9keSwgbm9kZSkgPT4ge1xuICAgICAgd2hpbGUgKG5vZGUgJiYgbm9kZSAhPT0gYm9keSkge1xuICAgICAgICBpZiAobm9kZS5pZCA9PT0gQ0FSRVRfSUQkMSkge1xuICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgY29uc3QgaXNTdHJpbmdQYXRoQm9va21hcmsgPSBib29rbWFyayA9PiBpc1N0cmluZyhib29rbWFyay5zdGFydCk7XG4gICAgY29uc3QgaXNSYW5nZUJvb2ttYXJrID0gYm9va21hcmsgPT4gaGFzJDIoYm9va21hcmssICdybmcnKTtcbiAgICBjb25zdCBpc0lkQm9va21hcmsgPSBib29rbWFyayA9PiBoYXMkMihib29rbWFyaywgJ2lkJyk7XG4gICAgY29uc3QgaXNJbmRleEJvb2ttYXJrID0gYm9va21hcmsgPT4gaGFzJDIoYm9va21hcmssICduYW1lJyk7XG4gICAgY29uc3QgaXNQYXRoQm9va21hcmsgPSBib29rbWFyayA9PiBUb29scy5pc0FycmF5KGJvb2ttYXJrLnN0YXJ0KTtcblxuICAgIGNvbnN0IGFkZEJvZ3VzID0gKGRvbSwgbm9kZSkgPT4ge1xuICAgICAgaWYgKGlzRWxlbWVudCQ2KG5vZGUpICYmIGRvbS5pc0Jsb2NrKG5vZGUpICYmICFub2RlLmlubmVySFRNTCkge1xuICAgICAgICBub2RlLmlubmVySFRNTCA9ICc8YnIgZGF0YS1tY2UtYm9ndXM9XCIxXCIgLz4nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcbiAgICBjb25zdCByZXNvbHZlQ2FyZXRQb3NpdGlvbkJvb2ttYXJrID0gKGRvbSwgYm9va21hcmspID0+IHtcbiAgICAgIGxldCBwb3M7XG4gICAgICBjb25zdCBybmcgPSBkb20uY3JlYXRlUm5nKCk7XG4gICAgICBwb3MgPSByZXNvbHZlJDEoZG9tLmdldFJvb3QoKSwgYm9va21hcmsuc3RhcnQpO1xuICAgICAgcm5nLnNldFN0YXJ0KHBvcy5jb250YWluZXIoKSwgcG9zLm9mZnNldCgpKTtcbiAgICAgIHBvcyA9IHJlc29sdmUkMShkb20uZ2V0Um9vdCgpLCBib29rbWFyay5lbmQpO1xuICAgICAgcm5nLnNldEVuZChwb3MuY29udGFpbmVyKCksIHBvcy5vZmZzZXQoKSk7XG4gICAgICByZXR1cm4gcm5nO1xuICAgIH07XG4gICAgY29uc3QgaW5zZXJ0WndzcCA9IChub2RlLCBybmcpID0+IHtcbiAgICAgIGNvbnN0IHRleHROb2RlID0gbm9kZS5vd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFpXU1AkMSk7XG4gICAgICBub2RlLmFwcGVuZENoaWxkKHRleHROb2RlKTtcbiAgICAgIHJuZy5zZXRTdGFydCh0ZXh0Tm9kZSwgMCk7XG4gICAgICBybmcuc2V0RW5kKHRleHROb2RlLCAwKTtcbiAgICB9O1xuICAgIGNvbnN0IGlzRW1wdHkkMSA9IG5vZGUgPT4gbm9kZS5oYXNDaGlsZE5vZGVzKCkgPT09IGZhbHNlO1xuICAgIGNvbnN0IHRyeUZpbmRSYW5nZVBvc2l0aW9uID0gKG5vZGUsIHJuZykgPT4gbGFzdFBvc2l0aW9uSW4obm9kZSkuZm9sZChuZXZlciwgcG9zID0+IHtcbiAgICAgIHJuZy5zZXRTdGFydChwb3MuY29udGFpbmVyKCksIHBvcy5vZmZzZXQoKSk7XG4gICAgICBybmcuc2V0RW5kKHBvcy5jb250YWluZXIoKSwgcG9zLm9mZnNldCgpKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICAgIGNvbnN0IHBhZEVtcHR5Q2FyZXRDb250YWluZXIgPSAocm9vdCwgbm9kZSwgcm5nKSA9PiB7XG4gICAgICBpZiAoaXNFbXB0eSQxKG5vZGUpICYmIGdldFBhcmVudENhcmV0Q29udGFpbmVyKHJvb3QsIG5vZGUpKSB7XG4gICAgICAgIGluc2VydFp3c3Aobm9kZSwgcm5nKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBzZXRFbmRQb2ludCA9IChkb20sIHN0YXJ0LCBib29rbWFyaywgcm5nKSA9PiB7XG4gICAgICBjb25zdCBwb2ludCA9IGJvb2ttYXJrW3N0YXJ0ID8gJ3N0YXJ0JyA6ICdlbmQnXTtcbiAgICAgIGxldCBpLCBub2RlLCBvZmZzZXQsIGNoaWxkcmVuO1xuICAgICAgY29uc3Qgcm9vdCA9IGRvbS5nZXRSb290KCk7XG4gICAgICBpZiAocG9pbnQpIHtcbiAgICAgICAgb2Zmc2V0ID0gcG9pbnRbMF07XG4gICAgICAgIGZvciAobm9kZSA9IHJvb3QsIGkgPSBwb2ludC5sZW5ndGggLSAxOyBpID49IDE7IGktLSkge1xuICAgICAgICAgIGNoaWxkcmVuID0gbm9kZS5jaGlsZE5vZGVzO1xuICAgICAgICAgIGlmIChwYWRFbXB0eUNhcmV0Q29udGFpbmVyKHJvb3QsIG5vZGUsIHJuZykpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocG9pbnRbaV0gPiBjaGlsZHJlbi5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBpZiAocGFkRW1wdHlDYXJldENvbnRhaW5lcihyb290LCBub2RlLCBybmcpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRyeUZpbmRSYW5nZVBvc2l0aW9uKG5vZGUsIHJuZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUgPSBjaGlsZHJlbltwb2ludFtpXV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDMpIHtcbiAgICAgICAgICBvZmZzZXQgPSBNYXRoLm1pbihwb2ludFswXSwgbm9kZS5ub2RlVmFsdWUubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgIG9mZnNldCA9IE1hdGgubWluKHBvaW50WzBdLCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgICBybmcuc2V0U3RhcnQobm9kZSwgb2Zmc2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBybmcuc2V0RW5kKG5vZGUsIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgY29uc3QgaXNWYWxpZFRleHROb2RlID0gbm9kZSA9PiBpc1RleHQkOChub2RlKSAmJiBub2RlLmRhdGEubGVuZ3RoID4gMDtcbiAgICBjb25zdCByZXN0b3JlRW5kUG9pbnQgPSAoZG9tLCBzdWZmaXgsIGJvb2ttYXJrKSA9PiB7XG4gICAgICBsZXQgbWFya2VyID0gZG9tLmdldChib29rbWFyay5pZCArICdfJyArIHN1ZmZpeCksIG5vZGUsIGlkeCwgbmV4dCwgcHJldjtcbiAgICAgIGNvbnN0IGtlZXAgPSBib29rbWFyay5rZWVwO1xuICAgICAgbGV0IGNvbnRhaW5lciwgb2Zmc2V0O1xuICAgICAgaWYgKG1hcmtlcikge1xuICAgICAgICBub2RlID0gbWFya2VyLnBhcmVudE5vZGU7XG4gICAgICAgIGlmIChzdWZmaXggPT09ICdzdGFydCcpIHtcbiAgICAgICAgICBpZiAoIWtlZXApIHtcbiAgICAgICAgICAgIGlkeCA9IGRvbS5ub2RlSW5kZXgobWFya2VyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG1hcmtlci5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICAgICAgbm9kZSA9IG1hcmtlci5maXJzdENoaWxkO1xuICAgICAgICAgICAgICBpZHggPSAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc1ZhbGlkVGV4dE5vZGUobWFya2VyLm5leHRTaWJsaW5nKSkge1xuICAgICAgICAgICAgICBub2RlID0gbWFya2VyLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICBpZHggPSAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc1ZhbGlkVGV4dE5vZGUobWFya2VyLnByZXZpb3VzU2libGluZykpIHtcbiAgICAgICAgICAgICAgbm9kZSA9IG1hcmtlci5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICAgIGlkeCA9IG1hcmtlci5wcmV2aW91c1NpYmxpbmcuZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBub2RlID0gbWFya2VyLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgIGlkeCA9IGRvbS5ub2RlSW5kZXgobWFya2VyKSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRhaW5lciA9IG5vZGU7XG4gICAgICAgICAgb2Zmc2V0ID0gaWR4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICgha2VlcCkge1xuICAgICAgICAgICAgaWR4ID0gZG9tLm5vZGVJbmRleChtYXJrZXIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAobWFya2VyLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgICAgICBub2RlID0gbWFya2VyLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgIGlkeCA9IDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzVmFsaWRUZXh0Tm9kZShtYXJrZXIucHJldmlvdXNTaWJsaW5nKSkge1xuICAgICAgICAgICAgICBub2RlID0gbWFya2VyLnByZXZpb3VzU2libGluZztcbiAgICAgICAgICAgICAgaWR4ID0gbWFya2VyLnByZXZpb3VzU2libGluZy5kYXRhLmxlbmd0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5vZGUgPSBtYXJrZXIucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgaWR4ID0gZG9tLm5vZGVJbmRleChtYXJrZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250YWluZXIgPSBub2RlO1xuICAgICAgICAgIG9mZnNldCA9IGlkeDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWtlZXApIHtcbiAgICAgICAgICBwcmV2ID0gbWFya2VyLnByZXZpb3VzU2libGluZztcbiAgICAgICAgICBuZXh0ID0gbWFya2VyLm5leHRTaWJsaW5nO1xuICAgICAgICAgIFRvb2xzLmVhY2goVG9vbHMuZ3JlcChtYXJrZXIuY2hpbGROb2RlcyksIG5vZGUgPT4ge1xuICAgICAgICAgICAgaWYgKGlzVGV4dCQ4KG5vZGUpKSB7XG4gICAgICAgICAgICAgIG5vZGUubm9kZVZhbHVlID0gbm9kZS5ub2RlVmFsdWUucmVwbGFjZSgvXFx1RkVGRi9nLCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgd2hpbGUgKG1hcmtlciA9IGRvbS5nZXQoYm9va21hcmsuaWQgKyAnXycgKyBzdWZmaXgpKSB7XG4gICAgICAgICAgICBkb20ucmVtb3ZlKG1hcmtlciwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcmV2ICYmIG5leHQgJiYgcHJldi5ub2RlVHlwZSA9PT0gbmV4dC5ub2RlVHlwZSAmJiBpc1RleHQkOChwcmV2KSAmJiAhRW52LmJyb3dzZXIuaXNPcGVyYSgpKSB7XG4gICAgICAgICAgICBpZHggPSBwcmV2Lm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICBwcmV2LmFwcGVuZERhdGEobmV4dC5ub2RlVmFsdWUpO1xuICAgICAgICAgICAgZG9tLnJlbW92ZShuZXh0KTtcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IHByZXY7XG4gICAgICAgICAgICBvZmZzZXQgPSBpZHg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKENhcmV0UG9zaXRpb24oY29udGFpbmVyLCBvZmZzZXQpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCByZXNvbHZlUGF0aHMgPSAoZG9tLCBib29rbWFyaykgPT4ge1xuICAgICAgY29uc3Qgcm5nID0gZG9tLmNyZWF0ZVJuZygpO1xuICAgICAgaWYgKHNldEVuZFBvaW50KGRvbSwgdHJ1ZSwgYm9va21hcmssIHJuZykgJiYgc2V0RW5kUG9pbnQoZG9tLCBmYWxzZSwgYm9va21hcmssIHJuZykpIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUocm5nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCByZXNvbHZlSWQgPSAoZG9tLCBib29rbWFyaykgPT4ge1xuICAgICAgY29uc3Qgc3RhcnRQb3MgPSByZXN0b3JlRW5kUG9pbnQoZG9tLCAnc3RhcnQnLCBib29rbWFyayk7XG4gICAgICBjb25zdCBlbmRQb3MgPSByZXN0b3JlRW5kUG9pbnQoZG9tLCAnZW5kJywgYm9va21hcmspO1xuICAgICAgcmV0dXJuIGxpZnQyKHN0YXJ0UG9zLCBlbmRQb3Mub3Ioc3RhcnRQb3MpLCAoc3BvcywgZXBvcykgPT4ge1xuICAgICAgICBjb25zdCBybmcgPSBkb20uY3JlYXRlUm5nKCk7XG4gICAgICAgIHJuZy5zZXRTdGFydChhZGRCb2d1cyhkb20sIHNwb3MuY29udGFpbmVyKCkpLCBzcG9zLm9mZnNldCgpKTtcbiAgICAgICAgcm5nLnNldEVuZChhZGRCb2d1cyhkb20sIGVwb3MuY29udGFpbmVyKCkpLCBlcG9zLm9mZnNldCgpKTtcbiAgICAgICAgcmV0dXJuIHJuZztcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgcmVzb2x2ZUluZGV4ID0gKGRvbSwgYm9va21hcmspID0+IE9wdGlvbmFsLmZyb20oZG9tLnNlbGVjdChib29rbWFyay5uYW1lKVtib29rbWFyay5pbmRleF0pLm1hcChlbG0gPT4ge1xuICAgICAgY29uc3Qgcm5nID0gZG9tLmNyZWF0ZVJuZygpO1xuICAgICAgcm5nLnNlbGVjdE5vZGUoZWxtKTtcbiAgICAgIHJldHVybiBybmc7XG4gICAgfSk7XG4gICAgY29uc3QgcmVzb2x2ZSA9IChzZWxlY3Rpb24sIGJvb2ttYXJrKSA9PiB7XG4gICAgICBjb25zdCBkb20gPSBzZWxlY3Rpb24uZG9tO1xuICAgICAgaWYgKGJvb2ttYXJrKSB7XG4gICAgICAgIGlmIChpc1BhdGhCb29rbWFyayhib29rbWFyaykpIHtcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZVBhdGhzKGRvbSwgYm9va21hcmspO1xuICAgICAgICB9IGVsc2UgaWYgKGlzU3RyaW5nUGF0aEJvb2ttYXJrKGJvb2ttYXJrKSkge1xuICAgICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKHJlc29sdmVDYXJldFBvc2l0aW9uQm9va21hcmsoZG9tLCBib29rbWFyaykpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzSWRCb29rbWFyayhib29rbWFyaykpIHtcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZUlkKGRvbSwgYm9va21hcmspO1xuICAgICAgICB9IGVsc2UgaWYgKGlzSW5kZXhCb29rbWFyayhib29rbWFyaykpIHtcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZUluZGV4KGRvbSwgYm9va21hcmspO1xuICAgICAgICB9IGVsc2UgaWYgKGlzUmFuZ2VCb29rbWFyayhib29rbWFyaykpIHtcbiAgICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZShib29rbWFyay5ybmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgIH07XG5cbiAgICBjb25zdCBnZXRCb29rbWFyayQxID0gKHNlbGVjdGlvbiwgdHlwZSwgbm9ybWFsaXplZCkgPT4ge1xuICAgICAgcmV0dXJuIGdldEJvb2ttYXJrJDIoc2VsZWN0aW9uLCB0eXBlLCBub3JtYWxpemVkKTtcbiAgICB9O1xuICAgIGNvbnN0IG1vdmVUb0Jvb2ttYXJrID0gKHNlbGVjdGlvbiwgYm9va21hcmspID0+IHtcbiAgICAgIHJlc29sdmUoc2VsZWN0aW9uLCBib29rbWFyaykuZWFjaChybmcgPT4ge1xuICAgICAgICBzZWxlY3Rpb24uc2V0Um5nKHJuZyk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGlzQm9va21hcmtOb2RlJDEgPSBub2RlID0+IHtcbiAgICAgIHJldHVybiBpc0VsZW1lbnQkNihub2RlKSAmJiBub2RlLnRhZ05hbWUgPT09ICdTUEFOJyAmJiBub2RlLmdldEF0dHJpYnV0ZSgnZGF0YS1tY2UtdHlwZScpID09PSAnYm9va21hcmsnO1xuICAgIH07XG5cbiAgICBjb25zdCBpcyA9IGV4cGVjdGVkID0+IGFjdHVhbCA9PiBleHBlY3RlZCA9PT0gYWN0dWFsO1xuICAgIGNvbnN0IGlzTmJzcCA9IGlzKG5ic3ApO1xuICAgIGNvbnN0IGlzV2hpdGVTcGFjZSA9IGNociA9PiBjaHIgIT09ICcnICYmICcgXFxmXFxuXFxyXFx0XFx4MEInLmluZGV4T2YoY2hyKSAhPT0gLTE7XG4gICAgY29uc3QgaXNDb250ZW50ID0gY2hyID0+ICFpc1doaXRlU3BhY2UoY2hyKSAmJiAhaXNOYnNwKGNocikgJiYgIWlzWndzcCQxKGNocik7XG5cbiAgICBjb25zdCBoZXhDb2xvdXIgPSB2YWx1ZSA9PiAoeyB2YWx1ZSB9KTtcbiAgICBjb25zdCB0b0hleCA9IGNvbXBvbmVudCA9PiB7XG4gICAgICBjb25zdCBoZXggPSBjb21wb25lbnQudG9TdHJpbmcoMTYpO1xuICAgICAgcmV0dXJuIChoZXgubGVuZ3RoID09PSAxID8gJzAnICsgaGV4IDogaGV4KS50b1VwcGVyQ2FzZSgpO1xuICAgIH07XG4gICAgY29uc3QgZnJvbVJnYmEgPSByZ2JhQ29sb3VyID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdG9IZXgocmdiYUNvbG91ci5yZWQpICsgdG9IZXgocmdiYUNvbG91ci5ncmVlbikgKyB0b0hleChyZ2JhQ29sb3VyLmJsdWUpO1xuICAgICAgcmV0dXJuIGhleENvbG91cih2YWx1ZSk7XG4gICAgfTtcblxuICAgIGNvbnN0IHJnYlJlZ2V4ID0gL15cXHMqcmdiXFxzKlxcKFxccyooXFxkKylcXHMqLFxccyooXFxkKylcXHMqLFxccyooXFxkKylcXHMqXFwpXFxzKiQvaTtcbiAgICBjb25zdCByZ2JhUmVnZXggPSAvXlxccypyZ2JhXFxzKlxcKFxccyooXFxkKylcXHMqLFxccyooXFxkKylcXHMqLFxccyooXFxkKylcXHMqLFxccyooXFxkPyg/OlxcLlxcZCspPylcXHMqXFwpXFxzKiQvaTtcbiAgICBjb25zdCByZ2JhQ29sb3VyID0gKHJlZCwgZ3JlZW4sIGJsdWUsIGFscGhhKSA9PiAoe1xuICAgICAgcmVkLFxuICAgICAgZ3JlZW4sXG4gICAgICBibHVlLFxuICAgICAgYWxwaGFcbiAgICB9KTtcbiAgICBjb25zdCBmcm9tU3RyaW5nVmFsdWVzID0gKHJlZCwgZ3JlZW4sIGJsdWUsIGFscGhhKSA9PiB7XG4gICAgICBjb25zdCByID0gcGFyc2VJbnQocmVkLCAxMCk7XG4gICAgICBjb25zdCBnID0gcGFyc2VJbnQoZ3JlZW4sIDEwKTtcbiAgICAgIGNvbnN0IGIgPSBwYXJzZUludChibHVlLCAxMCk7XG4gICAgICBjb25zdCBhID0gcGFyc2VGbG9hdChhbHBoYSk7XG4gICAgICByZXR1cm4gcmdiYUNvbG91cihyLCBnLCBiLCBhKTtcbiAgICB9O1xuICAgIGNvbnN0IGZyb21TdHJpbmcgPSByZ2JhU3RyaW5nID0+IHtcbiAgICAgIGlmIChyZ2JhU3RyaW5nID09PSAndHJhbnNwYXJlbnQnKSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKHJnYmFDb2xvdXIoMCwgMCwgMCwgMCkpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmdiTWF0Y2ggPSByZ2JSZWdleC5leGVjKHJnYmFTdHJpbmcpO1xuICAgICAgaWYgKHJnYk1hdGNoICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKGZyb21TdHJpbmdWYWx1ZXMocmdiTWF0Y2hbMV0sIHJnYk1hdGNoWzJdLCByZ2JNYXRjaFszXSwgJzEnKSk7XG4gICAgICB9XG4gICAgICBjb25zdCByZ2JhTWF0Y2ggPSByZ2JhUmVnZXguZXhlYyhyZ2JhU3RyaW5nKTtcbiAgICAgIGlmIChyZ2JhTWF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoZnJvbVN0cmluZ1ZhbHVlcyhyZ2JhTWF0Y2hbMV0sIHJnYmFNYXRjaFsyXSwgcmdiYU1hdGNoWzNdLCByZ2JhTWF0Y2hbNF0pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgfTtcblxuICAgIGNvbnN0IHJnYmFUb0hleFN0cmluZyA9IGNvbG9yID0+IGZyb21TdHJpbmcoY29sb3IpLm1hcChmcm9tUmdiYSkubWFwKGggPT4gJyMnICsgaC52YWx1ZSkuZ2V0T3IoY29sb3IpO1xuXG4gICAgY29uc3QgaXNOb2RlID0gbm9kZSA9PiAhIW5vZGUubm9kZVR5cGU7XG4gICAgY29uc3QgaXNJbmxpbmVCbG9jayA9IG5vZGUgPT4ge1xuICAgICAgcmV0dXJuIG5vZGUgJiYgL14oSU1HKSQvLnRlc3Qobm9kZS5ub2RlTmFtZSk7XG4gICAgfTtcbiAgICBjb25zdCBtb3ZlU3RhcnQgPSAoZG9tLCBzZWxlY3Rpb24sIHJuZykgPT4ge1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gcm5nLnN0YXJ0T2Zmc2V0O1xuICAgICAgbGV0IGNvbnRhaW5lciA9IHJuZy5zdGFydENvbnRhaW5lcjtcbiAgICAgIGlmIChjb250YWluZXIgPT09IHJuZy5lbmRDb250YWluZXIpIHtcbiAgICAgICAgaWYgKGlzSW5saW5lQmxvY2soY29udGFpbmVyLmNoaWxkTm9kZXNbb2Zmc2V0XSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0VsZW1lbnQkNihjb250YWluZXIpKSB7XG4gICAgICAgIGNvbnN0IG5vZGVzID0gY29udGFpbmVyLmNoaWxkTm9kZXM7XG4gICAgICAgIGxldCB3YWxrZXI7XG4gICAgICAgIGlmIChvZmZzZXQgPCBub2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICBjb250YWluZXIgPSBub2Rlc1tvZmZzZXRdO1xuICAgICAgICAgIHdhbGtlciA9IG5ldyBEb21UcmVlV2Fsa2VyKGNvbnRhaW5lciwgZG9tLmdldFBhcmVudChjb250YWluZXIsIGRvbS5pc0Jsb2NrKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGFpbmVyID0gbm9kZXNbbm9kZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgd2Fsa2VyID0gbmV3IERvbVRyZWVXYWxrZXIoY29udGFpbmVyLCBkb20uZ2V0UGFyZW50KGNvbnRhaW5lciwgZG9tLmlzQmxvY2spKTtcbiAgICAgICAgICB3YWxrZXIubmV4dCh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBub2RlID0gd2Fsa2VyLmN1cnJlbnQoKTsgbm9kZTsgbm9kZSA9IHdhbGtlci5uZXh0KCkpIHtcbiAgICAgICAgICBpZiAoaXNUZXh0JDgobm9kZSkgJiYgIWlzV2hpdGVTcGFjZU5vZGUkMShub2RlKSkge1xuICAgICAgICAgICAgcm5nLnNldFN0YXJ0KG5vZGUsIDApO1xuICAgICAgICAgICAgc2VsZWN0aW9uLnNldFJuZyhybmcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZ2V0Tm9uV2hpdGVTcGFjZVNpYmxpbmcgPSAobm9kZSwgbmV4dCwgaW5jKSA9PiB7XG4gICAgICBpZiAobm9kZSkge1xuICAgICAgICBjb25zdCBuZXh0TmFtZSA9IG5leHQgPyAnbmV4dFNpYmxpbmcnIDogJ3ByZXZpb3VzU2libGluZyc7XG4gICAgICAgIGZvciAobm9kZSA9IGluYyA/IG5vZGUgOiBub2RlW25leHROYW1lXTsgbm9kZTsgbm9kZSA9IG5vZGVbbmV4dE5hbWVdKSB7XG4gICAgICAgICAgaWYgKGlzRWxlbWVudCQ2KG5vZGUpIHx8ICFpc1doaXRlU3BhY2VOb2RlJDEobm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaXNUZXh0QmxvY2skMSA9IChlZGl0b3IsIG5hbWUpID0+IHtcbiAgICAgIGlmIChpc05vZGUobmFtZSkpIHtcbiAgICAgICAgbmFtZSA9IG5hbWUubm9kZU5hbWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gISFlZGl0b3Iuc2NoZW1hLmdldFRleHRCbG9ja0VsZW1lbnRzKClbbmFtZS50b0xvd2VyQ2FzZSgpXTtcbiAgICB9O1xuICAgIGNvbnN0IGlzVmFsaWQgPSAoZWQsIHBhcmVudCwgY2hpbGQpID0+IHtcbiAgICAgIHJldHVybiBlZC5zY2hlbWEuaXNWYWxpZENoaWxkKHBhcmVudCwgY2hpbGQpO1xuICAgIH07XG4gICAgY29uc3QgaXNXaGl0ZVNwYWNlTm9kZSQxID0gKG5vZGUsIGFsbG93U3BhY2VzID0gZmFsc2UpID0+IHtcbiAgICAgIGlmIChpc05vbk51bGxhYmxlKG5vZGUpICYmIGlzVGV4dCQ4KG5vZGUpKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhbGxvd1NwYWNlcyA/IG5vZGUuZGF0YS5yZXBsYWNlKC8gL2csICdcXHhBMCcpIDogbm9kZS5kYXRhO1xuICAgICAgICByZXR1cm4gaXNXaGl0ZXNwYWNlVGV4dChkYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGlzRW1wdHlUZXh0Tm9kZSQxID0gbm9kZSA9PiB7XG4gICAgICByZXR1cm4gaXNOb25OdWxsYWJsZShub2RlKSAmJiBpc1RleHQkOChub2RlKSAmJiBub2RlLmxlbmd0aCA9PT0gMDtcbiAgICB9O1xuICAgIGNvbnN0IHJlcGxhY2VWYXJzID0gKHZhbHVlLCB2YXJzKSA9PiB7XG4gICAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSh2YXJzKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNOb25OdWxsYWJsZSh2YXJzKSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoLyUoXFx3KykvZywgKHN0ciwgbmFtZSkgPT4ge1xuICAgICAgICAgIHJldHVybiB2YXJzW25hbWVdIHx8IHN0cjtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBjb25zdCBpc0VxJDUgPSAoc3RyMSwgc3RyMikgPT4ge1xuICAgICAgc3RyMSA9IHN0cjEgfHwgJyc7XG4gICAgICBzdHIyID0gc3RyMiB8fCAnJztcbiAgICAgIHN0cjEgPSAnJyArIChzdHIxLm5vZGVOYW1lIHx8IHN0cjEpO1xuICAgICAgc3RyMiA9ICcnICsgKHN0cjIubm9kZU5hbWUgfHwgc3RyMik7XG4gICAgICByZXR1cm4gc3RyMS50b0xvd2VyQ2FzZSgpID09PSBzdHIyLnRvTG93ZXJDYXNlKCk7XG4gICAgfTtcbiAgICBjb25zdCBub3JtYWxpemVTdHlsZVZhbHVlID0gKHZhbHVlLCBuYW1lKSA9PiB7XG4gICAgICBpZiAobmFtZSA9PT0gJ2NvbG9yJyB8fCBuYW1lID09PSAnYmFja2dyb3VuZENvbG9yJykge1xuICAgICAgICB2YWx1ZSA9IHJnYmFUb0hleFN0cmluZyh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAobmFtZSA9PT0gJ2ZvbnRXZWlnaHQnICYmIHZhbHVlID09PSA3MDApIHtcbiAgICAgICAgdmFsdWUgPSAnYm9sZCc7XG4gICAgICB9XG4gICAgICBpZiAobmFtZSA9PT0gJ2ZvbnRGYW1pbHknKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvW1xcJ1xcXCJdL2csICcnKS5yZXBsYWNlKC8sXFxzKy9nLCAnLCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuICcnICsgdmFsdWU7XG4gICAgfTtcbiAgICBjb25zdCBnZXRTdHlsZSA9IChkb20sIG5vZGUsIG5hbWUpID0+IHtcbiAgICAgIHJldHVybiBub3JtYWxpemVTdHlsZVZhbHVlKGRvbS5nZXRTdHlsZShub2RlLCBuYW1lKSwgbmFtZSk7XG4gICAgfTtcbiAgICBjb25zdCBnZXRUZXh0RGVjb3JhdGlvbiA9IChkb20sIG5vZGUpID0+IHtcbiAgICAgIGxldCBkZWNvcmF0aW9uO1xuICAgICAgZG9tLmdldFBhcmVudChub2RlLCBuID0+IHtcbiAgICAgICAgZGVjb3JhdGlvbiA9IGRvbS5nZXRTdHlsZShuLCAndGV4dC1kZWNvcmF0aW9uJyk7XG4gICAgICAgIHJldHVybiBkZWNvcmF0aW9uICYmIGRlY29yYXRpb24gIT09ICdub25lJztcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGRlY29yYXRpb247XG4gICAgfTtcbiAgICBjb25zdCBnZXRQYXJlbnRzJDIgPSAoZG9tLCBub2RlLCBzZWxlY3RvcikgPT4ge1xuICAgICAgcmV0dXJuIGRvbS5nZXRQYXJlbnRzKG5vZGUsIHNlbGVjdG9yLCBkb20uZ2V0Um9vdCgpKTtcbiAgICB9O1xuICAgIGNvbnN0IGlzVmFyaWFibGVGb3JtYXROYW1lID0gKGVkaXRvciwgZm9ybWF0TmFtZSkgPT4ge1xuICAgICAgY29uc3QgaGFzVmFyaWFibGVWYWx1ZXMgPSBmb3JtYXQgPT4ge1xuICAgICAgICBjb25zdCBpc1ZhcmlhYmxlVmFsdWUgPSB2YWwgPT4gdmFsLmxlbmd0aCA+IDEgJiYgdmFsLmNoYXJBdCgwKSA9PT0gJyUnO1xuICAgICAgICByZXR1cm4gZXhpc3RzKFtcbiAgICAgICAgICAnc3R5bGVzJyxcbiAgICAgICAgICAnYXR0cmlidXRlcydcbiAgICAgICAgXSwga2V5ID0+IGdldCRhKGZvcm1hdCwga2V5KS5leGlzdHMoZmllbGQgPT4ge1xuICAgICAgICAgIGNvbnN0IGZpZWxkVmFsdWVzID0gaXNBcnJheSQxKGZpZWxkKSA/IGZpZWxkIDogdmFsdWVzKGZpZWxkKTtcbiAgICAgICAgICByZXR1cm4gZXhpc3RzKGZpZWxkVmFsdWVzLCBpc1ZhcmlhYmxlVmFsdWUpO1xuICAgICAgICB9KSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGV4aXN0cyhlZGl0b3IuZm9ybWF0dGVyLmdldChmb3JtYXROYW1lKSwgaGFzVmFyaWFibGVWYWx1ZXMpO1xuICAgIH07XG4gICAgY29uc3QgYXJlU2ltaWxhckZvcm1hdHMgPSAoZWRpdG9yLCBmb3JtYXROYW1lLCBvdGhlckZvcm1hdE5hbWUpID0+IHtcbiAgICAgIGNvbnN0IHZhbGlkS2V5cyA9IFtcbiAgICAgICAgJ2lubGluZScsXG4gICAgICAgICdibG9jaycsXG4gICAgICAgICdzZWxlY3RvcicsXG4gICAgICAgICdhdHRyaWJ1dGVzJyxcbiAgICAgICAgJ3N0eWxlcycsXG4gICAgICAgICdjbGFzc2VzJ1xuICAgICAgXTtcbiAgICAgIGNvbnN0IGZpbHRlck9iaiA9IGZvcm1hdCA9PiBmaWx0ZXIkNShmb3JtYXQsIChfLCBrZXkpID0+IGV4aXN0cyh2YWxpZEtleXMsIHZhbGlkS2V5ID0+IHZhbGlkS2V5ID09PSBrZXkpKTtcbiAgICAgIHJldHVybiBleGlzdHMoZWRpdG9yLmZvcm1hdHRlci5nZXQoZm9ybWF0TmFtZSksIGZtdDEgPT4ge1xuICAgICAgICBjb25zdCBmaWx0ZXJlZEZtdDEgPSBmaWx0ZXJPYmooZm10MSk7XG4gICAgICAgIHJldHVybiBleGlzdHMoZWRpdG9yLmZvcm1hdHRlci5nZXQob3RoZXJGb3JtYXROYW1lKSwgZm10MiA9PiB7XG4gICAgICAgICAgY29uc3QgZmlsdGVyZWRGbXQyID0gZmlsdGVyT2JqKGZtdDIpO1xuICAgICAgICAgIHJldHVybiBlcXVhbCQxKGZpbHRlcmVkRm10MSwgZmlsdGVyZWRGbXQyKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGlzQmxvY2tGb3JtYXQgPSBmb3JtYXQgPT4gaGFzTm9uTnVsbGFibGVLZXkoZm9ybWF0LCAnYmxvY2snKTtcbiAgICBjb25zdCBpc1NlbGVjdG9yRm9ybWF0ID0gZm9ybWF0ID0+IGhhc05vbk51bGxhYmxlS2V5KGZvcm1hdCwgJ3NlbGVjdG9yJyk7XG4gICAgY29uc3QgaXNJbmxpbmVGb3JtYXQgPSBmb3JtYXQgPT4gaGFzTm9uTnVsbGFibGVLZXkoZm9ybWF0LCAnaW5saW5lJyk7XG4gICAgY29uc3QgaXNNaXhlZEZvcm1hdCA9IGZvcm1hdCA9PiBpc1NlbGVjdG9yRm9ybWF0KGZvcm1hdCkgJiYgaXNJbmxpbmVGb3JtYXQoZm9ybWF0KSAmJiBpcyQyKGdldCRhKGZvcm1hdCwgJ21peGVkJyksIHRydWUpO1xuICAgIGNvbnN0IHNob3VsZEV4cGFuZFRvU2VsZWN0b3IgPSBmb3JtYXQgPT4gaXNTZWxlY3RvckZvcm1hdChmb3JtYXQpICYmIGZvcm1hdC5leHBhbmQgIT09IGZhbHNlICYmICFpc0lubGluZUZvcm1hdChmb3JtYXQpO1xuXG4gICAgY29uc3QgaXNCb29rbWFya05vZGUgPSBpc0Jvb2ttYXJrTm9kZSQxO1xuICAgIGNvbnN0IGdldFBhcmVudHMkMSA9IGdldFBhcmVudHMkMjtcbiAgICBjb25zdCBpc1doaXRlU3BhY2VOb2RlID0gaXNXaGl0ZVNwYWNlTm9kZSQxO1xuICAgIGNvbnN0IGlzVGV4dEJsb2NrID0gaXNUZXh0QmxvY2skMTtcbiAgICBjb25zdCBpc0JvZ3VzQnIgPSBub2RlID0+IHtcbiAgICAgIHJldHVybiBpc0JyJDUobm9kZSkgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtbWNlLWJvZ3VzJykgJiYgIW5vZGUubmV4dFNpYmxpbmc7XG4gICAgfTtcbiAgICBjb25zdCBmaW5kUGFyZW50Q29udGVudEVkaXRhYmxlID0gKGRvbSwgbm9kZSkgPT4ge1xuICAgICAgbGV0IHBhcmVudCA9IG5vZGU7XG4gICAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgIGlmIChpc0VsZW1lbnQkNihwYXJlbnQpICYmIGRvbS5nZXRDb250ZW50RWRpdGFibGUocGFyZW50KSkge1xuICAgICAgICAgIHJldHVybiBkb20uZ2V0Q29udGVudEVkaXRhYmxlKHBhcmVudCkgPT09ICdmYWxzZScgPyBwYXJlbnQgOiBub2RlO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcbiAgICBjb25zdCB3YWxrVGV4dCA9IChzdGFydCwgbm9kZSwgb2Zmc2V0LCBwcmVkaWNhdGUpID0+IHtcbiAgICAgIGNvbnN0IHN0ciA9IG5vZGUuZGF0YTtcbiAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IHN0YXJ0ID8gaSA+PSAwIDogaSA8IHN0ci5sZW5ndGg7IHN0YXJ0ID8gaS0tIDogaSsrKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUoc3RyLmNoYXJBdChpKSkpIHtcbiAgICAgICAgICByZXR1cm4gc3RhcnQgPyBpICsgMSA6IGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuICAgIGNvbnN0IGZpbmRTcGFjZSA9IChzdGFydCwgbm9kZSwgb2Zmc2V0KSA9PiB3YWxrVGV4dChzdGFydCwgbm9kZSwgb2Zmc2V0LCBjID0+IGlzTmJzcChjKSB8fCBpc1doaXRlU3BhY2UoYykpO1xuICAgIGNvbnN0IGZpbmRDb250ZW50ID0gKHN0YXJ0LCBub2RlLCBvZmZzZXQpID0+IHdhbGtUZXh0KHN0YXJ0LCBub2RlLCBvZmZzZXQsIGlzQ29udGVudCk7XG4gICAgY29uc3QgZmluZFdvcmRFbmRQb2ludCA9IChkb20sIGJvZHksIGNvbnRhaW5lciwgb2Zmc2V0LCBzdGFydCwgaW5jbHVkZVRyYWlsaW5nU3BhY2VzKSA9PiB7XG4gICAgICBsZXQgbGFzdFRleHROb2RlO1xuICAgICAgY29uc3Qgcm9vdE5vZGUgPSBkb20uZ2V0UGFyZW50KGNvbnRhaW5lciwgZG9tLmlzQmxvY2spIHx8IGJvZHk7XG4gICAgICBjb25zdCB3YWxrID0gKGNvbnRhaW5lciwgb2Zmc2V0LCBwcmVkKSA9PiB7XG4gICAgICAgIGNvbnN0IHRleHRTZWVrZXIgPSBUZXh0U2Vla2VyKGRvbSk7XG4gICAgICAgIGNvbnN0IHdhbGtlciA9IHN0YXJ0ID8gdGV4dFNlZWtlci5iYWNrd2FyZHMgOiB0ZXh0U2Vla2VyLmZvcndhcmRzO1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwuZnJvbSh3YWxrZXIoY29udGFpbmVyLCBvZmZzZXQsICh0ZXh0LCB0ZXh0T2Zmc2V0KSA9PiB7XG4gICAgICAgICAgaWYgKGlzQm9va21hcmtOb2RlKHRleHQucGFyZW50Tm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGFzdFRleHROb2RlID0gdGV4dDtcbiAgICAgICAgICAgIHJldHVybiBwcmVkKHN0YXJ0LCB0ZXh0LCB0ZXh0T2Zmc2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHJvb3ROb2RlKSk7XG4gICAgICB9O1xuICAgICAgY29uc3Qgc3BhY2VSZXN1bHQgPSB3YWxrKGNvbnRhaW5lciwgb2Zmc2V0LCBmaW5kU3BhY2UpO1xuICAgICAgcmV0dXJuIHNwYWNlUmVzdWx0LmJpbmQocmVzdWx0ID0+IGluY2x1ZGVUcmFpbGluZ1NwYWNlcyA/IHdhbGsocmVzdWx0LmNvbnRhaW5lciwgcmVzdWx0Lm9mZnNldCArIChzdGFydCA/IC0xIDogMCksIGZpbmRDb250ZW50KSA6IE9wdGlvbmFsLnNvbWUocmVzdWx0KSkub3JUaHVuaygoKSA9PiBsYXN0VGV4dE5vZGUgPyBPcHRpb25hbC5zb21lKHtcbiAgICAgICAgY29udGFpbmVyOiBsYXN0VGV4dE5vZGUsXG4gICAgICAgIG9mZnNldDogc3RhcnQgPyAwIDogbGFzdFRleHROb2RlLmxlbmd0aFxuICAgICAgfSkgOiBPcHRpb25hbC5ub25lKCkpO1xuICAgIH07XG4gICAgY29uc3QgZmluZFNlbGVjdG9yRW5kUG9pbnQgPSAoZG9tLCBmb3JtYXRMaXN0LCBybmcsIGNvbnRhaW5lciwgc2libGluZ05hbWUpID0+IHtcbiAgICAgIGlmIChpc1RleHQkOChjb250YWluZXIpICYmIGlzRW1wdHkkMyhjb250YWluZXIuZGF0YSkgJiYgY29udGFpbmVyW3NpYmxpbmdOYW1lXSkge1xuICAgICAgICBjb250YWluZXIgPSBjb250YWluZXJbc2libGluZ05hbWVdO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFyZW50cyA9IGdldFBhcmVudHMkMShkb20sIGNvbnRhaW5lcik7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBmb3JtYXRMaXN0Lmxlbmd0aDsgeSsrKSB7XG4gICAgICAgICAgY29uc3QgY3VyRm9ybWF0ID0gZm9ybWF0TGlzdFt5XTtcbiAgICAgICAgICBpZiAoaXNOb25OdWxsYWJsZShjdXJGb3JtYXQuY29sbGFwc2VkKSAmJiBjdXJGb3JtYXQuY29sbGFwc2VkICE9PSBybmcuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzU2VsZWN0b3JGb3JtYXQoY3VyRm9ybWF0KSAmJiBkb20uaXMocGFyZW50c1tpXSwgY3VyRm9ybWF0LnNlbGVjdG9yKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmVudHNbaV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgIH07XG4gICAgY29uc3QgZmluZEJsb2NrRW5kUG9pbnQgPSAoZWRpdG9yLCBmb3JtYXRMaXN0LCBjb250YWluZXIsIHNpYmxpbmdOYW1lKSA9PiB7XG4gICAgICBsZXQgbm9kZSA9IGNvbnRhaW5lcjtcbiAgICAgIGNvbnN0IGRvbSA9IGVkaXRvci5kb207XG4gICAgICBjb25zdCByb290ID0gZG9tLmdldFJvb3QoKTtcbiAgICAgIGNvbnN0IGZvcm1hdCA9IGZvcm1hdExpc3RbMF07XG4gICAgICBpZiAoaXNCbG9ja0Zvcm1hdChmb3JtYXQpKSB7XG4gICAgICAgIG5vZGUgPSBmb3JtYXQud3JhcHBlciA/IG51bGwgOiBkb20uZ2V0UGFyZW50KGNvbnRhaW5lciwgZm9ybWF0LmJsb2NrLCByb290KTtcbiAgICAgIH1cbiAgICAgIGlmICghbm9kZSkge1xuICAgICAgICBjb25zdCBzY29wZVJvb3QgPSBkb20uZ2V0UGFyZW50KGNvbnRhaW5lciwgJ0xJLFRELFRIJyk7XG4gICAgICAgIG5vZGUgPSBkb20uZ2V0UGFyZW50KGlzVGV4dCQ4KGNvbnRhaW5lcikgPyBjb250YWluZXIucGFyZW50Tm9kZSA6IGNvbnRhaW5lciwgbm9kZSA9PiBub2RlICE9PSByb290ICYmIGlzVGV4dEJsb2NrKGVkaXRvciwgbm9kZSksIHNjb3BlUm9vdCk7XG4gICAgICB9XG4gICAgICBpZiAobm9kZSAmJiBpc0Jsb2NrRm9ybWF0KGZvcm1hdCkgJiYgZm9ybWF0LndyYXBwZXIpIHtcbiAgICAgICAgbm9kZSA9IGdldFBhcmVudHMkMShkb20sIG5vZGUsICd1bCxvbCcpLnJldmVyc2UoKVswXSB8fCBub2RlO1xuICAgICAgfVxuICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgIG5vZGUgPSBjb250YWluZXI7XG4gICAgICAgIHdoaWxlIChub2RlW3NpYmxpbmdOYW1lXSAmJiAhZG9tLmlzQmxvY2sobm9kZVtzaWJsaW5nTmFtZV0pKSB7XG4gICAgICAgICAgbm9kZSA9IG5vZGVbc2libGluZ05hbWVdO1xuICAgICAgICAgIGlmIChpc0VxJDUobm9kZSwgJ2JyJykpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGUgfHwgY29udGFpbmVyO1xuICAgIH07XG4gICAgY29uc3QgaXNBdEJsb2NrQm91bmRhcnkkMSA9IChkb20sIHJvb3QsIGNvbnRhaW5lciwgc2libGluZ05hbWUpID0+IHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IGNvbnRhaW5lci5wYXJlbnROb2RlO1xuICAgICAgaWYgKGlzTm9uTnVsbGFibGUoY29udGFpbmVyW3NpYmxpbmdOYW1lXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChwYXJlbnQgPT09IHJvb3QgfHwgaXNOdWxsYWJsZShwYXJlbnQpIHx8IGRvbS5pc0Jsb2NrKHBhcmVudCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaXNBdEJsb2NrQm91bmRhcnkkMShkb20sIHJvb3QsIHBhcmVudCwgc2libGluZ05hbWUpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZmluZFBhcmVudENvbnRhaW5lciA9IChkb20sIGZvcm1hdExpc3QsIGNvbnRhaW5lciwgb2Zmc2V0LCBzdGFydCkgPT4ge1xuICAgICAgbGV0IHBhcmVudCA9IGNvbnRhaW5lcjtcbiAgICAgIGNvbnN0IHNpYmxpbmdOYW1lID0gc3RhcnQgPyAncHJldmlvdXNTaWJsaW5nJyA6ICduZXh0U2libGluZyc7XG4gICAgICBjb25zdCByb290ID0gZG9tLmdldFJvb3QoKTtcbiAgICAgIGlmIChpc1RleHQkOChjb250YWluZXIpICYmICFpc1doaXRlU3BhY2VOb2RlKGNvbnRhaW5lcikpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID8gb2Zmc2V0ID4gMCA6IG9mZnNldCA8IGNvbnRhaW5lci5kYXRhLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGlmICghZm9ybWF0TGlzdFswXS5ibG9ja19leHBhbmQgJiYgZG9tLmlzQmxvY2socGFyZW50KSkge1xuICAgICAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgc2libGluZyA9IHBhcmVudFtzaWJsaW5nTmFtZV07IHNpYmxpbmc7IHNpYmxpbmcgPSBzaWJsaW5nW3NpYmxpbmdOYW1lXSkge1xuICAgICAgICAgIGNvbnN0IGFsbG93U3BhY2VzID0gaXNUZXh0JDgoc2libGluZykgJiYgIWlzQXRCbG9ja0JvdW5kYXJ5JDEoZG9tLCByb290LCBzaWJsaW5nLCBzaWJsaW5nTmFtZSk7XG4gICAgICAgICAgaWYgKCFpc0Jvb2ttYXJrTm9kZShzaWJsaW5nKSAmJiAhaXNCb2d1c0JyKHNpYmxpbmcpICYmICFpc1doaXRlU3BhY2VOb2RlKHNpYmxpbmcsIGFsbG93U3BhY2VzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmVudCA9PT0gcm9vdCB8fCBwYXJlbnQucGFyZW50Tm9kZSA9PT0gcm9vdCkge1xuICAgICAgICAgIGNvbnRhaW5lciA9IHBhcmVudDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgfTtcbiAgICBjb25zdCBpc1NlbGZPclBhcmVudEJvb2ttYXJrID0gY29udGFpbmVyID0+IGlzQm9va21hcmtOb2RlKGNvbnRhaW5lci5wYXJlbnROb2RlKSB8fCBpc0Jvb2ttYXJrTm9kZShjb250YWluZXIpO1xuICAgIGNvbnN0IGV4cGFuZFJuZyA9IChlZGl0b3IsIHJuZywgZm9ybWF0TGlzdCwgaW5jbHVkZVRyYWlsaW5nU3BhY2UgPSBmYWxzZSkgPT4ge1xuICAgICAgbGV0IHtzdGFydENvbnRhaW5lciwgc3RhcnRPZmZzZXQsIGVuZENvbnRhaW5lciwgZW5kT2Zmc2V0fSA9IHJuZztcbiAgICAgIGNvbnN0IGRvbSA9IGVkaXRvci5kb207XG4gICAgICBjb25zdCBmb3JtYXQgPSBmb3JtYXRMaXN0WzBdO1xuICAgICAgaWYgKGlzRWxlbWVudCQ2KHN0YXJ0Q29udGFpbmVyKSAmJiBzdGFydENvbnRhaW5lci5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgc3RhcnRDb250YWluZXIgPSBnZXROb2RlJDEoc3RhcnRDb250YWluZXIsIHN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgaWYgKGlzVGV4dCQ4KHN0YXJ0Q29udGFpbmVyKSkge1xuICAgICAgICAgIHN0YXJ0T2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzRWxlbWVudCQ2KGVuZENvbnRhaW5lcikgJiYgZW5kQ29udGFpbmVyLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICBlbmRDb250YWluZXIgPSBnZXROb2RlJDEoZW5kQ29udGFpbmVyLCBybmcuY29sbGFwc2VkID8gZW5kT2Zmc2V0IDogZW5kT2Zmc2V0IC0gMSk7XG4gICAgICAgIGlmIChpc1RleHQkOChlbmRDb250YWluZXIpKSB7XG4gICAgICAgICAgZW5kT2Zmc2V0ID0gZW5kQ29udGFpbmVyLm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0YXJ0Q29udGFpbmVyID0gZmluZFBhcmVudENvbnRlbnRFZGl0YWJsZShkb20sIHN0YXJ0Q29udGFpbmVyKTtcbiAgICAgIGVuZENvbnRhaW5lciA9IGZpbmRQYXJlbnRDb250ZW50RWRpdGFibGUoZG9tLCBlbmRDb250YWluZXIpO1xuICAgICAgaWYgKGlzU2VsZk9yUGFyZW50Qm9va21hcmsoc3RhcnRDb250YWluZXIpKSB7XG4gICAgICAgIHN0YXJ0Q29udGFpbmVyID0gaXNCb29rbWFya05vZGUoc3RhcnRDb250YWluZXIpID8gc3RhcnRDb250YWluZXIgOiBzdGFydENvbnRhaW5lci5wYXJlbnROb2RlO1xuICAgICAgICBpZiAocm5nLmNvbGxhcHNlZCkge1xuICAgICAgICAgIHN0YXJ0Q29udGFpbmVyID0gc3RhcnRDb250YWluZXIucHJldmlvdXNTaWJsaW5nIHx8IHN0YXJ0Q29udGFpbmVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXJ0Q29udGFpbmVyID0gc3RhcnRDb250YWluZXIubmV4dFNpYmxpbmcgfHwgc3RhcnRDb250YWluZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVGV4dCQ4KHN0YXJ0Q29udGFpbmVyKSkge1xuICAgICAgICAgIHN0YXJ0T2Zmc2V0ID0gcm5nLmNvbGxhcHNlZCA/IHN0YXJ0Q29udGFpbmVyLmxlbmd0aCA6IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc1NlbGZPclBhcmVudEJvb2ttYXJrKGVuZENvbnRhaW5lcikpIHtcbiAgICAgICAgZW5kQ29udGFpbmVyID0gaXNCb29rbWFya05vZGUoZW5kQ29udGFpbmVyKSA/IGVuZENvbnRhaW5lciA6IGVuZENvbnRhaW5lci5wYXJlbnROb2RlO1xuICAgICAgICBpZiAocm5nLmNvbGxhcHNlZCkge1xuICAgICAgICAgIGVuZENvbnRhaW5lciA9IGVuZENvbnRhaW5lci5uZXh0U2libGluZyB8fCBlbmRDb250YWluZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW5kQ29udGFpbmVyID0gZW5kQ29udGFpbmVyLnByZXZpb3VzU2libGluZyB8fCBlbmRDb250YWluZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVGV4dCQ4KGVuZENvbnRhaW5lcikpIHtcbiAgICAgICAgICBlbmRPZmZzZXQgPSBybmcuY29sbGFwc2VkID8gMCA6IGVuZENvbnRhaW5lci5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChybmcuY29sbGFwc2VkKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0UG9pbnQgPSBmaW5kV29yZEVuZFBvaW50KGRvbSwgZWRpdG9yLmdldEJvZHkoKSwgc3RhcnRDb250YWluZXIsIHN0YXJ0T2Zmc2V0LCB0cnVlLCBpbmNsdWRlVHJhaWxpbmdTcGFjZSk7XG4gICAgICAgIHN0YXJ0UG9pbnQuZWFjaCgoe2NvbnRhaW5lciwgb2Zmc2V0fSkgPT4ge1xuICAgICAgICAgIHN0YXJ0Q29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICAgIHN0YXJ0T2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZW5kUG9pbnQgPSBmaW5kV29yZEVuZFBvaW50KGRvbSwgZWRpdG9yLmdldEJvZHkoKSwgZW5kQ29udGFpbmVyLCBlbmRPZmZzZXQsIGZhbHNlLCBpbmNsdWRlVHJhaWxpbmdTcGFjZSk7XG4gICAgICAgIGVuZFBvaW50LmVhY2goKHtjb250YWluZXIsIG9mZnNldH0pID0+IHtcbiAgICAgICAgICBlbmRDb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgICAgZW5kT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0lubGluZUZvcm1hdChmb3JtYXQpIHx8IGZvcm1hdC5ibG9ja19leHBhbmQpIHtcbiAgICAgICAgaWYgKCFpc0lubGluZUZvcm1hdChmb3JtYXQpIHx8ICghaXNUZXh0JDgoc3RhcnRDb250YWluZXIpIHx8IHN0YXJ0T2Zmc2V0ID09PSAwKSkge1xuICAgICAgICAgIHN0YXJ0Q29udGFpbmVyID0gZmluZFBhcmVudENvbnRhaW5lcihkb20sIGZvcm1hdExpc3QsIHN0YXJ0Q29udGFpbmVyLCBzdGFydE9mZnNldCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0lubGluZUZvcm1hdChmb3JtYXQpIHx8ICghaXNUZXh0JDgoZW5kQ29udGFpbmVyKSB8fCBlbmRPZmZzZXQgPT09IGVuZENvbnRhaW5lci5ub2RlVmFsdWUubGVuZ3RoKSkge1xuICAgICAgICAgIGVuZENvbnRhaW5lciA9IGZpbmRQYXJlbnRDb250YWluZXIoZG9tLCBmb3JtYXRMaXN0LCBlbmRDb250YWluZXIsIGVuZE9mZnNldCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkRXhwYW5kVG9TZWxlY3Rvcihmb3JtYXQpKSB7XG4gICAgICAgIHN0YXJ0Q29udGFpbmVyID0gZmluZFNlbGVjdG9yRW5kUG9pbnQoZG9tLCBmb3JtYXRMaXN0LCBybmcsIHN0YXJ0Q29udGFpbmVyLCAncHJldmlvdXNTaWJsaW5nJyk7XG4gICAgICAgIGVuZENvbnRhaW5lciA9IGZpbmRTZWxlY3RvckVuZFBvaW50KGRvbSwgZm9ybWF0TGlzdCwgcm5nLCBlbmRDb250YWluZXIsICduZXh0U2libGluZycpO1xuICAgICAgfVxuICAgICAgaWYgKGlzQmxvY2tGb3JtYXQoZm9ybWF0KSB8fCBpc1NlbGVjdG9yRm9ybWF0KGZvcm1hdCkpIHtcbiAgICAgICAgc3RhcnRDb250YWluZXIgPSBmaW5kQmxvY2tFbmRQb2ludChlZGl0b3IsIGZvcm1hdExpc3QsIHN0YXJ0Q29udGFpbmVyLCAncHJldmlvdXNTaWJsaW5nJyk7XG4gICAgICAgIGVuZENvbnRhaW5lciA9IGZpbmRCbG9ja0VuZFBvaW50KGVkaXRvciwgZm9ybWF0TGlzdCwgZW5kQ29udGFpbmVyLCAnbmV4dFNpYmxpbmcnKTtcbiAgICAgICAgaWYgKGlzQmxvY2tGb3JtYXQoZm9ybWF0KSkge1xuICAgICAgICAgIGlmICghZG9tLmlzQmxvY2soc3RhcnRDb250YWluZXIpKSB7XG4gICAgICAgICAgICBzdGFydENvbnRhaW5lciA9IGZpbmRQYXJlbnRDb250YWluZXIoZG9tLCBmb3JtYXRMaXN0LCBzdGFydENvbnRhaW5lciwgc3RhcnRPZmZzZXQsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWRvbS5pc0Jsb2NrKGVuZENvbnRhaW5lcikpIHtcbiAgICAgICAgICAgIGVuZENvbnRhaW5lciA9IGZpbmRQYXJlbnRDb250YWluZXIoZG9tLCBmb3JtYXRMaXN0LCBlbmRDb250YWluZXIsIGVuZE9mZnNldCwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzRWxlbWVudCQ2KHN0YXJ0Q29udGFpbmVyKSkge1xuICAgICAgICBzdGFydE9mZnNldCA9IGRvbS5ub2RlSW5kZXgoc3RhcnRDb250YWluZXIpO1xuICAgICAgICBzdGFydENvbnRhaW5lciA9IHN0YXJ0Q29udGFpbmVyLnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgICBpZiAoaXNFbGVtZW50JDYoZW5kQ29udGFpbmVyKSkge1xuICAgICAgICBlbmRPZmZzZXQgPSBkb20ubm9kZUluZGV4KGVuZENvbnRhaW5lcikgKyAxO1xuICAgICAgICBlbmRDb250YWluZXIgPSBlbmRDb250YWluZXIucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0Q29udGFpbmVyLFxuICAgICAgICBzdGFydE9mZnNldCxcbiAgICAgICAgZW5kQ29udGFpbmVyLFxuICAgICAgICBlbmRPZmZzZXRcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IHdhbGskMyA9IChkb20sIHJuZywgY2FsbGJhY2spID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gcm5nLnN0YXJ0T2Zmc2V0O1xuICAgICAgY29uc3Qgc3RhcnRDb250YWluZXIgPSBnZXROb2RlJDEocm5nLnN0YXJ0Q29udGFpbmVyLCBzdGFydE9mZnNldCk7XG4gICAgICBjb25zdCBlbmRPZmZzZXQgPSBybmcuZW5kT2Zmc2V0O1xuICAgICAgY29uc3QgZW5kQ29udGFpbmVyID0gZ2V0Tm9kZSQxKHJuZy5lbmRDb250YWluZXIsIGVuZE9mZnNldCAtIDEpO1xuICAgICAgY29uc3QgZXhjbHVkZSA9IG5vZGVzID0+IHtcbiAgICAgICAgY29uc3QgZmlyc3ROb2RlID0gbm9kZXNbMF07XG4gICAgICAgIGlmIChpc1RleHQkOChmaXJzdE5vZGUpICYmIGZpcnN0Tm9kZSA9PT0gc3RhcnRDb250YWluZXIgJiYgc3RhcnRPZmZzZXQgPj0gZmlyc3ROb2RlLmRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgbm9kZXMuc3BsaWNlKDAsIDEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxhc3ROb2RlID0gbm9kZXNbbm9kZXMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChlbmRPZmZzZXQgPT09IDAgJiYgbm9kZXMubGVuZ3RoID4gMCAmJiBsYXN0Tm9kZSA9PT0gZW5kQ29udGFpbmVyICYmIGlzVGV4dCQ4KGxhc3ROb2RlKSkge1xuICAgICAgICAgIG5vZGVzLnNwbGljZShub2Rlcy5sZW5ndGggLSAxLCAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgICB9O1xuICAgICAgY29uc3QgY29sbGVjdFNpYmxpbmdzID0gKG5vZGUsIG5hbWUsIGVuZE5vZGUpID0+IHtcbiAgICAgICAgY29uc3Qgc2libGluZ3MgPSBbXTtcbiAgICAgICAgZm9yICg7IG5vZGUgJiYgbm9kZSAhPT0gZW5kTm9kZTsgbm9kZSA9IG5vZGVbbmFtZV0pIHtcbiAgICAgICAgICBzaWJsaW5ncy5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaWJsaW5ncztcbiAgICAgIH07XG4gICAgICBjb25zdCBmaW5kRW5kUG9pbnQgPSAobm9kZSwgcm9vdCkgPT4gZG9tLmdldFBhcmVudChub2RlLCBub2RlID0+IG5vZGUucGFyZW50Tm9kZSA9PT0gcm9vdCwgcm9vdCk7XG4gICAgICBjb25zdCB3YWxrQm91bmRhcnkgPSAoc3RhcnROb2RlLCBlbmROb2RlLCBuZXh0KSA9PiB7XG4gICAgICAgIGNvbnN0IHNpYmxpbmdOYW1lID0gbmV4dCA/ICduZXh0U2libGluZycgOiAncHJldmlvdXNTaWJsaW5nJztcbiAgICAgICAgZm9yIChsZXQgbm9kZSA9IHN0YXJ0Tm9kZSwgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlOyBub2RlICYmIG5vZGUgIT09IGVuZE5vZGU7IG5vZGUgPSBwYXJlbnQpIHtcbiAgICAgICAgICBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgY29uc3Qgc2libGluZ3MgPSBjb2xsZWN0U2libGluZ3Mobm9kZSA9PT0gc3RhcnROb2RlID8gbm9kZSA6IG5vZGVbc2libGluZ05hbWVdLCBzaWJsaW5nTmFtZSk7XG4gICAgICAgICAgaWYgKHNpYmxpbmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCFuZXh0KSB7XG4gICAgICAgICAgICAgIHNpYmxpbmdzLnJldmVyc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrKGV4Y2x1ZGUoc2libGluZ3MpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAoc3RhcnRDb250YWluZXIgPT09IGVuZENvbnRhaW5lcikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXhjbHVkZShbc3RhcnRDb250YWluZXJdKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBhbmNlc3RvciA9IGRvbS5maW5kQ29tbW9uQW5jZXN0b3Ioc3RhcnRDb250YWluZXIsIGVuZENvbnRhaW5lcik7XG4gICAgICBpZiAoZG9tLmlzQ2hpbGRPZihzdGFydENvbnRhaW5lciwgZW5kQ29udGFpbmVyKSkge1xuICAgICAgICByZXR1cm4gd2Fsa0JvdW5kYXJ5KHN0YXJ0Q29udGFpbmVyLCBhbmNlc3RvciwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoZG9tLmlzQ2hpbGRPZihlbmRDb250YWluZXIsIHN0YXJ0Q29udGFpbmVyKSkge1xuICAgICAgICByZXR1cm4gd2Fsa0JvdW5kYXJ5KGVuZENvbnRhaW5lciwgYW5jZXN0b3IpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhcnRQb2ludCA9IGZpbmRFbmRQb2ludChzdGFydENvbnRhaW5lciwgYW5jZXN0b3IpIHx8IHN0YXJ0Q29udGFpbmVyO1xuICAgICAgY29uc3QgZW5kUG9pbnQgPSBmaW5kRW5kUG9pbnQoZW5kQ29udGFpbmVyLCBhbmNlc3RvcikgfHwgZW5kQ29udGFpbmVyO1xuICAgICAgd2Fsa0JvdW5kYXJ5KHN0YXJ0Q29udGFpbmVyLCBzdGFydFBvaW50LCB0cnVlKTtcbiAgICAgIGNvbnN0IHNpYmxpbmdzID0gY29sbGVjdFNpYmxpbmdzKHN0YXJ0UG9pbnQgPT09IHN0YXJ0Q29udGFpbmVyID8gc3RhcnRQb2ludCA6IHN0YXJ0UG9pbnQubmV4dFNpYmxpbmcsICduZXh0U2libGluZycsIGVuZFBvaW50ID09PSBlbmRDb250YWluZXIgPyBlbmRQb2ludC5uZXh0U2libGluZyA6IGVuZFBvaW50KTtcbiAgICAgIGlmIChzaWJsaW5ncy5sZW5ndGgpIHtcbiAgICAgICAgY2FsbGJhY2soZXhjbHVkZShzaWJsaW5ncykpO1xuICAgICAgfVxuICAgICAgd2Fsa0JvdW5kYXJ5KGVuZENvbnRhaW5lciwgZW5kUG9pbnQpO1xuICAgIH07XG5cbiAgICBjb25zdCBnZXRSYW5nZXMkMSA9IHNlbGVjdGlvbiA9PiB7XG4gICAgICBjb25zdCByYW5nZXMgPSBbXTtcbiAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWxlY3Rpb24ucmFuZ2VDb3VudDsgaSsrKSB7XG4gICAgICAgICAgcmFuZ2VzLnB1c2goc2VsZWN0aW9uLmdldFJhbmdlQXQoaSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmFuZ2VzO1xuICAgIH07XG4gICAgY29uc3QgZ2V0U2VsZWN0ZWROb2RlcyA9IHJhbmdlcyA9PiB7XG4gICAgICByZXR1cm4gYmluZCQzKHJhbmdlcywgcmFuZ2UgPT4ge1xuICAgICAgICBjb25zdCBub2RlID0gZ2V0U2VsZWN0ZWROb2RlKHJhbmdlKTtcbiAgICAgICAgcmV0dXJuIG5vZGUgPyBbU3VnYXJFbGVtZW50LmZyb21Eb20obm9kZSldIDogW107XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGhhc011bHRpcGxlUmFuZ2VzID0gc2VsZWN0aW9uID0+IHtcbiAgICAgIHJldHVybiBnZXRSYW5nZXMkMShzZWxlY3Rpb24pLmxlbmd0aCA+IDE7XG4gICAgfTtcblxuICAgIGNvbnN0IGdldENlbGxzRnJvbVJhbmdlcyA9IHJhbmdlcyA9PiBmaWx0ZXIkNihnZXRTZWxlY3RlZE5vZGVzKHJhbmdlcyksIGlzVGFibGVDZWxsJDQpO1xuICAgIGNvbnN0IGdldENlbGxzRnJvbUVsZW1lbnQgPSBlbG0gPT4gZGVzY2VuZGFudHMoZWxtLCAndGRbZGF0YS1tY2Utc2VsZWN0ZWRdLHRoW2RhdGEtbWNlLXNlbGVjdGVkXScpO1xuICAgIGNvbnN0IGdldENlbGxzRnJvbUVsZW1lbnRPclJhbmdlcyA9IChyYW5nZXMsIGVsZW1lbnQpID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGVkQ2VsbHMgPSBnZXRDZWxsc0Zyb21FbGVtZW50KGVsZW1lbnQpO1xuICAgICAgcmV0dXJuIHNlbGVjdGVkQ2VsbHMubGVuZ3RoID4gMCA/IHNlbGVjdGVkQ2VsbHMgOiBnZXRDZWxsc0Zyb21SYW5nZXMocmFuZ2VzKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldENlbGxzRnJvbUVkaXRvciA9IGVkaXRvciA9PiBnZXRDZWxsc0Zyb21FbGVtZW50T3JSYW5nZXMoZ2V0UmFuZ2VzJDEoZWRpdG9yLnNlbGVjdGlvbi5nZXRTZWwoKSksIFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVkaXRvci5nZXRCb2R5KCkpKTtcbiAgICBjb25zdCBnZXRDbG9zZXN0VGFibGUgPSAoY2VsbCwgaXNSb290KSA9PiBhbmNlc3RvciQyKGNlbGwsICd0YWJsZScsIGlzUm9vdCk7XG5cbiAgICBjb25zdCBnZXRTdGFydE5vZGUgPSBybmcgPT4ge1xuICAgICAgY29uc3Qgc2MgPSBybmcuc3RhcnRDb250YWluZXIsIHNvID0gcm5nLnN0YXJ0T2Zmc2V0O1xuICAgICAgaWYgKGlzVGV4dCQ4KHNjKSkge1xuICAgICAgICByZXR1cm4gc28gPT09IDAgPyBPcHRpb25hbC5zb21lKFN1Z2FyRWxlbWVudC5mcm9tRG9tKHNjKSkgOiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwuZnJvbShzYy5jaGlsZE5vZGVzW3NvXSkubWFwKFN1Z2FyRWxlbWVudC5mcm9tRG9tKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGdldEVuZE5vZGUgPSBybmcgPT4ge1xuICAgICAgY29uc3QgZWMgPSBybmcuZW5kQ29udGFpbmVyLCBlbyA9IHJuZy5lbmRPZmZzZXQ7XG4gICAgICBpZiAoaXNUZXh0JDgoZWMpKSB7XG4gICAgICAgIHJldHVybiBlbyA9PT0gZWMuZGF0YS5sZW5ndGggPyBPcHRpb25hbC5zb21lKFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVjKSkgOiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwuZnJvbShlYy5jaGlsZE5vZGVzW2VvIC0gMV0pLm1hcChTdWdhckVsZW1lbnQuZnJvbURvbSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBnZXRGaXJzdENoaWxkcmVuID0gbm9kZSA9PiB7XG4gICAgICByZXR1cm4gZmlyc3RDaGlsZChub2RlKS5mb2xkKGNvbnN0YW50KFtub2RlXSksIGNoaWxkID0+IHtcbiAgICAgICAgcmV0dXJuIFtub2RlXS5jb25jYXQoZ2V0Rmlyc3RDaGlsZHJlbihjaGlsZCkpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBnZXRMYXN0Q2hpbGRyZW4kMSA9IG5vZGUgPT4ge1xuICAgICAgcmV0dXJuIGxhc3RDaGlsZChub2RlKS5mb2xkKGNvbnN0YW50KFtub2RlXSksIGNoaWxkID0+IHtcbiAgICAgICAgaWYgKG5hbWUoY2hpbGQpID09PSAnYnInKSB7XG4gICAgICAgICAgcmV0dXJuIHByZXZTaWJsaW5nKGNoaWxkKS5tYXAoc2libGluZyA9PiB7XG4gICAgICAgICAgICByZXR1cm4gW25vZGVdLmNvbmNhdChnZXRMYXN0Q2hpbGRyZW4kMShzaWJsaW5nKSk7XG4gICAgICAgICAgfSkuZ2V0T3IoW10pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBbbm9kZV0uY29uY2F0KGdldExhc3RDaGlsZHJlbiQxKGNoaWxkKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgaGFzQWxsQ29udGVudHNTZWxlY3RlZCA9IChlbG0sIHJuZykgPT4ge1xuICAgICAgcmV0dXJuIGxpZnQyKGdldFN0YXJ0Tm9kZShybmcpLCBnZXRFbmROb2RlKHJuZyksIChzdGFydE5vZGUsIGVuZE5vZGUpID0+IHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBmaW5kJDIoZ2V0Rmlyc3RDaGlsZHJlbihlbG0pLCBjdXJyeShlcSwgc3RhcnROb2RlKSk7XG4gICAgICAgIGNvbnN0IGVuZCA9IGZpbmQkMihnZXRMYXN0Q2hpbGRyZW4kMShlbG0pLCBjdXJyeShlcSwgZW5kTm9kZSkpO1xuICAgICAgICByZXR1cm4gc3RhcnQuaXNTb21lKCkgJiYgZW5kLmlzU29tZSgpO1xuICAgICAgfSkuZ2V0T3IoZmFsc2UpO1xuICAgIH07XG4gICAgY29uc3QgbW92ZUVuZFBvaW50ID0gKGRvbSwgcm5nLCBub2RlLCBzdGFydCkgPT4ge1xuICAgICAgY29uc3Qgcm9vdCA9IG5vZGUsIHdhbGtlciA9IG5ldyBEb21UcmVlV2Fsa2VyKG5vZGUsIHJvb3QpO1xuICAgICAgY29uc3QgbW92ZUNhcmV0QmVmb3JlT25FbnRlckVsZW1lbnRzTWFwID0gZmlsdGVyJDUoZG9tLnNjaGVtYS5nZXRNb3ZlQ2FyZXRCZWZvcmVPbkVudGVyRWxlbWVudHMoKSwgKF8sIG5hbWUpID0+ICFjb250YWlucyQyKFtcbiAgICAgICAgJ3RkJyxcbiAgICAgICAgJ3RoJyxcbiAgICAgICAgJ3RhYmxlJ1xuICAgICAgXSwgbmFtZS50b0xvd2VyQ2FzZSgpKSk7XG4gICAgICBkbyB7XG4gICAgICAgIGlmIChpc1RleHQkOChub2RlKSAmJiBUb29scy50cmltKG5vZGUubm9kZVZhbHVlKS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgICAgIHJuZy5zZXRTdGFydChub2RlLCAwKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcm5nLnNldEVuZChub2RlLCBub2RlLm5vZGVWYWx1ZS5sZW5ndGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vdmVDYXJldEJlZm9yZU9uRW50ZXJFbGVtZW50c01hcFtub2RlLm5vZGVOYW1lXSkge1xuICAgICAgICAgIGlmIChzdGFydCkge1xuICAgICAgICAgICAgcm5nLnNldFN0YXJ0QmVmb3JlKG5vZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlTmFtZSA9PT0gJ0JSJykge1xuICAgICAgICAgICAgICBybmcuc2V0RW5kQmVmb3JlKG5vZGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcm5nLnNldEVuZEFmdGVyKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKG5vZGUgPSBzdGFydCA/IHdhbGtlci5uZXh0KCkgOiB3YWxrZXIucHJldigpKTtcbiAgICAgIGlmIChyb290Lm5vZGVOYW1lID09PSAnQk9EWScpIHtcbiAgICAgICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgICAgcm5nLnNldFN0YXJ0KHJvb3QsIDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJuZy5zZXRFbmQocm9vdCwgcm9vdC5jaGlsZE5vZGVzLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGhhc0FueVJhbmdlcyA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBzZWwgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldFNlbCgpO1xuICAgICAgcmV0dXJuIHNlbCAmJiBzZWwucmFuZ2VDb3VudCA+IDA7XG4gICAgfTtcbiAgICBjb25zdCBydW5PblJhbmdlcyA9IChlZGl0b3IsIGV4ZWN1dG9yKSA9PiB7XG4gICAgICBjb25zdCBmYWtlU2VsZWN0aW9uTm9kZXMgPSBnZXRDZWxsc0Zyb21FZGl0b3IoZWRpdG9yKTtcbiAgICAgIGlmIChmYWtlU2VsZWN0aW9uTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBlYWNoJGcoZmFrZVNlbGVjdGlvbk5vZGVzLCBlbGVtID0+IHtcbiAgICAgICAgICBjb25zdCBub2RlID0gZWxlbS5kb207XG4gICAgICAgICAgY29uc3QgZmFrZU5vZGVSbmcgPSBlZGl0b3IuZG9tLmNyZWF0ZVJuZygpO1xuICAgICAgICAgIGZha2VOb2RlUm5nLnNldFN0YXJ0QmVmb3JlKG5vZGUpO1xuICAgICAgICAgIGZha2VOb2RlUm5nLnNldEVuZEFmdGVyKG5vZGUpO1xuICAgICAgICAgIGV4ZWN1dG9yKGZha2VOb2RlUm5nLCB0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleGVjdXRvcihlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBwcmVzZXJ2ZSA9IChzZWxlY3Rpb24sIGZpbGxCb29rbWFyaywgZXhlY3V0b3IpID0+IHtcbiAgICAgIGNvbnN0IGJvb2ttYXJrID0gZ2V0UGVyc2lzdGVudEJvb2ttYXJrKHNlbGVjdGlvbiwgZmlsbEJvb2ttYXJrKTtcbiAgICAgIGV4ZWN1dG9yKGJvb2ttYXJrKTtcbiAgICAgIHNlbGVjdGlvbi5tb3ZlVG9Cb29rbWFyayhib29rbWFyayk7XG4gICAgfTtcblxuICAgIGNvbnN0IE5vZGVWYWx1ZSA9IChpcywgbmFtZSkgPT4ge1xuICAgICAgY29uc3QgZ2V0ID0gZWxlbWVudCA9PiB7XG4gICAgICAgIGlmICghaXMoZWxlbWVudCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBvbmx5IGdldCAnICsgbmFtZSArICcgdmFsdWUgb2YgYSAnICsgbmFtZSArICcgbm9kZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRPcHRpb24oZWxlbWVudCkuZ2V0T3IoJycpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGdldE9wdGlvbiA9IGVsZW1lbnQgPT4gaXMoZWxlbWVudCkgPyBPcHRpb25hbC5mcm9tKGVsZW1lbnQuZG9tLm5vZGVWYWx1ZSkgOiBPcHRpb25hbC5ub25lKCk7XG4gICAgICBjb25zdCBzZXQgPSAoZWxlbWVudCwgdmFsdWUpID0+IHtcbiAgICAgICAgaWYgKCFpcyhlbGVtZW50KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG9ubHkgc2V0IHJhdyAnICsgbmFtZSArICcgdmFsdWUgb2YgYSAnICsgbmFtZSArICcgbm9kZScpO1xuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnQuZG9tLm5vZGVWYWx1ZSA9IHZhbHVlO1xuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGdldCxcbiAgICAgICAgZ2V0T3B0aW9uLFxuICAgICAgICBzZXRcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IGFwaSQxID0gTm9kZVZhbHVlKGlzVGV4dCQ5LCAndGV4dCcpO1xuICAgIGNvbnN0IGdldCQzID0gZWxlbWVudCA9PiBhcGkkMS5nZXQoZWxlbWVudCk7XG4gICAgY29uc3QgZ2V0T3B0aW9uID0gZWxlbWVudCA9PiBhcGkkMS5nZXRPcHRpb24oZWxlbWVudCk7XG5cbiAgICBjb25zdCBpc1plcm9XaWR0aCA9IGVsZW0gPT4gaXNUZXh0JDkoZWxlbSkgJiYgZ2V0JDMoZWxlbSkgPT09IFpXU1AkMTtcbiAgICBjb25zdCBjb250ZXh0ID0gKGVkaXRvciwgZWxlbSwgd3JhcE5hbWUsIG5vZGVOYW1lKSA9PiBwYXJlbnQoZWxlbSkuZm9sZCgoKSA9PiAnc2tpcHBpbmcnLCBwYXJlbnQgPT4ge1xuICAgICAgaWYgKG5vZGVOYW1lID09PSAnYnInIHx8IGlzWmVyb1dpZHRoKGVsZW0pKSB7XG4gICAgICAgIHJldHVybiAndmFsaWQnO1xuICAgICAgfSBlbHNlIGlmIChpc0Fubm90YXRpb24oZWxlbSkpIHtcbiAgICAgICAgcmV0dXJuICdleGlzdGluZyc7XG4gICAgICB9IGVsc2UgaWYgKGlzQ2FyZXROb2RlKGVsZW0uZG9tKSkge1xuICAgICAgICByZXR1cm4gJ2NhcmV0JztcbiAgICAgIH0gZWxzZSBpZiAoIWlzVmFsaWQoZWRpdG9yLCB3cmFwTmFtZSwgbm9kZU5hbWUpIHx8ICFpc1ZhbGlkKGVkaXRvciwgbmFtZShwYXJlbnQpLCB3cmFwTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuICdpbnZhbGlkLWNoaWxkJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAndmFsaWQnO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgYXBwbHlXb3JkR3JhYiA9IChlZGl0b3IsIHJuZykgPT4ge1xuICAgICAgY29uc3QgciA9IGV4cGFuZFJuZyhlZGl0b3IsIHJuZywgW3sgaW5saW5lOiAnc3BhbicgfV0pO1xuICAgICAgcm5nLnNldFN0YXJ0KHIuc3RhcnRDb250YWluZXIsIHIuc3RhcnRPZmZzZXQpO1xuICAgICAgcm5nLnNldEVuZChyLmVuZENvbnRhaW5lciwgci5lbmRPZmZzZXQpO1xuICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZXRSbmcocm5nKTtcbiAgICB9O1xuICAgIGNvbnN0IG1ha2VBbm5vdGF0aW9uID0gKGVEb2MsIHt1aWQgPSBnZW5lcmF0ZSQxKCdtY2UtYW5ub3RhdGlvbicpLCAuLi5kYXRhfSwgYW5ub3RhdGlvbk5hbWUsIGRlY29yYXRlKSA9PiB7XG4gICAgICBjb25zdCBtYXN0ZXIgPSBTdWdhckVsZW1lbnQuZnJvbVRhZygnc3BhbicsIGVEb2MpO1xuICAgICAgYWRkJDIobWFzdGVyLCBhbm5vdGF0aW9uKCkpO1xuICAgICAgc2V0JDIobWFzdGVyLCBgJHsgZGF0YUFubm90YXRpb25JZCgpIH1gLCB1aWQpO1xuICAgICAgc2V0JDIobWFzdGVyLCBgJHsgZGF0YUFubm90YXRpb24oKSB9YCwgYW5ub3RhdGlvbk5hbWUpO1xuICAgICAgY29uc3Qge2F0dHJpYnV0ZXMgPSB7fSwgY2xhc3NlcyA9IFtdfSA9IGRlY29yYXRlKHVpZCwgZGF0YSk7XG4gICAgICBzZXRBbGwkMShtYXN0ZXIsIGF0dHJpYnV0ZXMpO1xuICAgICAgYWRkKG1hc3RlciwgY2xhc3Nlcyk7XG4gICAgICByZXR1cm4gbWFzdGVyO1xuICAgIH07XG4gICAgY29uc3QgYW5ub3RhdGUgPSAoZWRpdG9yLCBybmcsIGFubm90YXRpb25OYW1lLCBkZWNvcmF0ZSwgZGF0YSkgPT4ge1xuICAgICAgY29uc3QgbmV3V3JhcHBlcnMgPSBbXTtcbiAgICAgIGNvbnN0IG1hc3RlciA9IG1ha2VBbm5vdGF0aW9uKGVkaXRvci5nZXREb2MoKSwgZGF0YSwgYW5ub3RhdGlvbk5hbWUsIGRlY29yYXRlKTtcbiAgICAgIGNvbnN0IHdyYXBwZXIgPSB2YWx1ZSQyKCk7XG4gICAgICBjb25zdCBmaW5pc2hXcmFwcGVyID0gKCkgPT4ge1xuICAgICAgICB3cmFwcGVyLmNsZWFyKCk7XG4gICAgICB9O1xuICAgICAgY29uc3QgZ2V0T3JPcGVuV3JhcHBlciA9ICgpID0+IHdyYXBwZXIuZ2V0KCkuZ2V0T3JUaHVuaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IG51ID0gc2hhbGxvdyQxKG1hc3Rlcik7XG4gICAgICAgIG5ld1dyYXBwZXJzLnB1c2gobnUpO1xuICAgICAgICB3cmFwcGVyLnNldChudSk7XG4gICAgICAgIHJldHVybiBudTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcHJvY2Vzc0VsZW1lbnRzID0gZWxlbXMgPT4ge1xuICAgICAgICBlYWNoJGcoZWxlbXMsIHByb2Nlc3NFbGVtZW50KTtcbiAgICAgIH07XG4gICAgICBjb25zdCBwcm9jZXNzRWxlbWVudCA9IGVsZW0gPT4ge1xuICAgICAgICBjb25zdCBjdHggPSBjb250ZXh0KGVkaXRvciwgZWxlbSwgJ3NwYW4nLCBuYW1lKGVsZW0pKTtcbiAgICAgICAgc3dpdGNoIChjdHgpIHtcbiAgICAgICAgY2FzZSAnaW52YWxpZC1jaGlsZCc6IHtcbiAgICAgICAgICAgIGZpbmlzaFdyYXBwZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuJDEgPSBjaGlsZHJlbihlbGVtKTtcbiAgICAgICAgICAgIHByb2Nlc3NFbGVtZW50cyhjaGlsZHJlbiQxKTtcbiAgICAgICAgICAgIGZpbmlzaFdyYXBwZXIoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAndmFsaWQnOiB7XG4gICAgICAgICAgICBjb25zdCB3ID0gZ2V0T3JPcGVuV3JhcHBlcigpO1xuICAgICAgICAgICAgd3JhcCQyKGVsZW0sIHcpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgcHJvY2Vzc05vZGVzID0gbm9kZXMgPT4ge1xuICAgICAgICBjb25zdCBlbGVtcyA9IG1hcCQzKG5vZGVzLCBTdWdhckVsZW1lbnQuZnJvbURvbSk7XG4gICAgICAgIHByb2Nlc3NFbGVtZW50cyhlbGVtcyk7XG4gICAgICB9O1xuICAgICAgd2FsayQzKGVkaXRvci5kb20sIHJuZywgbm9kZXMgPT4ge1xuICAgICAgICBmaW5pc2hXcmFwcGVyKCk7XG4gICAgICAgIHByb2Nlc3NOb2Rlcyhub2Rlcyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXdXcmFwcGVycztcbiAgICB9O1xuICAgIGNvbnN0IGFubm90YXRlV2l0aEJvb2ttYXJrID0gKGVkaXRvciwgbmFtZSwgc2V0dGluZ3MsIGRhdGEpID0+IHtcbiAgICAgIGVkaXRvci51bmRvTWFuYWdlci50cmFuc2FjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb247XG4gICAgICAgIGNvbnN0IGluaXRpYWxSbmcgPSBzZWxlY3Rpb24uZ2V0Um5nKCk7XG4gICAgICAgIGNvbnN0IGhhc0Zha2VTZWxlY3Rpb24gPSBnZXRDZWxsc0Zyb21FZGl0b3IoZWRpdG9yKS5sZW5ndGggPiAwO1xuICAgICAgICBpZiAoaW5pdGlhbFJuZy5jb2xsYXBzZWQgJiYgIWhhc0Zha2VTZWxlY3Rpb24pIHtcbiAgICAgICAgICBhcHBseVdvcmRHcmFiKGVkaXRvciwgaW5pdGlhbFJuZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGVjdGlvbi5nZXRSbmcoKS5jb2xsYXBzZWQgJiYgIWhhc0Zha2VTZWxlY3Rpb24pIHtcbiAgICAgICAgICBjb25zdCB3cmFwcGVyID0gbWFrZUFubm90YXRpb24oZWRpdG9yLmdldERvYygpLCBkYXRhLCBuYW1lLCBzZXR0aW5ncy5kZWNvcmF0ZSk7XG4gICAgICAgICAgc2V0KHdyYXBwZXIsIG5ic3ApO1xuICAgICAgICAgIHNlbGVjdGlvbi5nZXRSbmcoKS5pbnNlcnROb2RlKHdyYXBwZXIuZG9tKTtcbiAgICAgICAgICBzZWxlY3Rpb24uc2VsZWN0KHdyYXBwZXIuZG9tKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmVzZXJ2ZShzZWxlY3Rpb24sIGZhbHNlLCAoKSA9PiB7XG4gICAgICAgICAgICBydW5PblJhbmdlcyhlZGl0b3IsIHNlbGVjdGlvblJuZyA9PiB7XG4gICAgICAgICAgICAgIGFubm90YXRlKGVkaXRvciwgc2VsZWN0aW9uUm5nLCBuYW1lLCBzZXR0aW5ncy5kZWNvcmF0ZSwgZGF0YSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IEFubm90YXRvciA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCByZWdpc3RyeSA9IGNyZWF0ZSRiKCk7XG4gICAgICBzZXR1cCR3KGVkaXRvciwgcmVnaXN0cnkpO1xuICAgICAgY29uc3QgY2hhbmdlcyA9IHNldHVwJHgoZWRpdG9yLCByZWdpc3RyeSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZWdpc3RlcjogKG5hbWUsIHNldHRpbmdzKSA9PiB7XG4gICAgICAgICAgcmVnaXN0cnkucmVnaXN0ZXIobmFtZSwgc2V0dGluZ3MpO1xuICAgICAgICB9LFxuICAgICAgICBhbm5vdGF0ZTogKG5hbWUsIGRhdGEpID0+IHtcbiAgICAgICAgICByZWdpc3RyeS5sb29rdXAobmFtZSkuZWFjaChzZXR0aW5ncyA9PiB7XG4gICAgICAgICAgICBhbm5vdGF0ZVdpdGhCb29rbWFyayhlZGl0b3IsIG5hbWUsIHNldHRpbmdzLCBkYXRhKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgYW5ub3RhdGlvbkNoYW5nZWQ6IChuYW1lLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICAgIGNoYW5nZXMuYWRkTGlzdGVuZXIobmFtZSwgY2FsbGJhY2spO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmU6IG5hbWUgPT4ge1xuICAgICAgICAgIGNvbnN0IGJvb2ttYXJrID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRCb29rbWFyaygpO1xuICAgICAgICAgIGlkZW50aWZ5KGVkaXRvciwgT3B0aW9uYWwuc29tZShuYW1lKSkuZWFjaCgoe2VsZW1lbnRzfSkgPT4ge1xuICAgICAgICAgICAgZWFjaCRnKGVsZW1lbnRzLCB1bndyYXApO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24ubW92ZVRvQm9va21hcmsoYm9va21hcmspO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmVBbGw6IG5hbWUgPT4ge1xuICAgICAgICAgIGNvbnN0IGJvb2ttYXJrID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRCb29rbWFyaygpO1xuICAgICAgICAgIGVhY2gkZihmaW5kQWxsKGVkaXRvciwgbmFtZSksIChzcGFucywgXykgPT4gZWFjaCRnKHNwYW5zLCB1bndyYXApKTtcbiAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLm1vdmVUb0Jvb2ttYXJrKGJvb2ttYXJrKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0QWxsOiBuYW1lID0+IHtcbiAgICAgICAgICBjb25zdCBkaXJlY3RvcnkgPSBmaW5kQWxsKGVkaXRvciwgbmFtZSk7XG4gICAgICAgICAgcmV0dXJuIG1hcCQyKGRpcmVjdG9yeSwgZWxlbXMgPT4gbWFwJDMoZWxlbXMsIGVsZW0gPT4gZWxlbS5kb20pKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgY29uc3QgQm9va21hcmtNYW5hZ2VyID0gc2VsZWN0aW9uID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGdldEJvb2ttYXJrOiBjdXJyeShnZXRCb29rbWFyayQxLCBzZWxlY3Rpb24pLFxuICAgICAgICBtb3ZlVG9Cb29rbWFyazogY3VycnkobW92ZVRvQm9va21hcmssIHNlbGVjdGlvbilcbiAgICAgIH07XG4gICAgfTtcbiAgICBCb29rbWFya01hbmFnZXIuaXNCb29rbWFya05vZGUgPSBpc0Jvb2ttYXJrTm9kZSQxO1xuXG4gICAgY29uc3QgaXNYWVdpdGhpblJhbmdlID0gKGNsaWVudFgsIGNsaWVudFksIHJhbmdlKSA9PiB7XG4gICAgICBpZiAocmFuZ2UuY29sbGFwc2VkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBleGlzdHMocmFuZ2UuZ2V0Q2xpZW50UmVjdHMoKSwgcmVjdCA9PiBjb250YWluc1hZKHJlY3QsIGNsaWVudFgsIGNsaWVudFkpKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgZmlyZVByZVByb2Nlc3MgPSAoZWRpdG9yLCBhcmdzKSA9PiBlZGl0b3IuZGlzcGF0Y2goJ1ByZVByb2Nlc3MnLCBhcmdzKTtcbiAgICBjb25zdCBmaXJlUG9zdFByb2Nlc3MgPSAoZWRpdG9yLCBhcmdzKSA9PiBlZGl0b3IuZGlzcGF0Y2goJ1Bvc3RQcm9jZXNzJywgYXJncyk7XG4gICAgY29uc3QgZmlyZVJlbW92ZSA9IGVkaXRvciA9PiBlZGl0b3IuZGlzcGF0Y2goJ3JlbW92ZScpO1xuICAgIGNvbnN0IGZpcmVEZXRhY2ggPSBlZGl0b3IgPT4gZWRpdG9yLmRpc3BhdGNoKCdkZXRhY2gnKTtcbiAgICBjb25zdCBmaXJlU3dpdGNoTW9kZSA9IChlZGl0b3IsIG1vZGUpID0+IGVkaXRvci5kaXNwYXRjaCgnU3dpdGNoTW9kZScsIHsgbW9kZSB9KTtcbiAgICBjb25zdCBmaXJlT2JqZWN0UmVzaXplU3RhcnQgPSAoZWRpdG9yLCB0YXJnZXQsIHdpZHRoLCBoZWlnaHQsIG9yaWdpbikgPT4ge1xuICAgICAgZWRpdG9yLmRpc3BhdGNoKCdPYmplY3RSZXNpemVTdGFydCcsIHtcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICBvcmlnaW5cbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgZmlyZU9iamVjdFJlc2l6ZWQgPSAoZWRpdG9yLCB0YXJnZXQsIHdpZHRoLCBoZWlnaHQsIG9yaWdpbikgPT4ge1xuICAgICAgZWRpdG9yLmRpc3BhdGNoKCdPYmplY3RSZXNpemVkJywge1xuICAgICAgICB0YXJnZXQsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIG9yaWdpblxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBmaXJlUHJlSW5pdCA9IGVkaXRvciA9PiBlZGl0b3IuZGlzcGF0Y2goJ1ByZUluaXQnKTtcbiAgICBjb25zdCBmaXJlUG9zdFJlbmRlciA9IGVkaXRvciA9PiBlZGl0b3IuZGlzcGF0Y2goJ1Bvc3RSZW5kZXInKTtcbiAgICBjb25zdCBmaXJlSW5pdCA9IGVkaXRvciA9PiBlZGl0b3IuZGlzcGF0Y2goJ0luaXQnKTtcbiAgICBjb25zdCBmaXJlUGxhY2Vob2xkZXJUb2dnbGUgPSAoZWRpdG9yLCBzdGF0ZSkgPT4gZWRpdG9yLmRpc3BhdGNoKCdQbGFjZWhvbGRlclRvZ2dsZScsIHsgc3RhdGUgfSk7XG4gICAgY29uc3QgZmlyZUVycm9yID0gKGVkaXRvciwgZXJyb3JUeXBlLCBlcnJvcikgPT4gZWRpdG9yLmRpc3BhdGNoKGVycm9yVHlwZSwgZXJyb3IpO1xuICAgIGNvbnN0IGZpcmVGb3JtYXRBcHBseSA9IChlZGl0b3IsIGZvcm1hdCwgbm9kZSwgdmFycykgPT4gZWRpdG9yLmRpc3BhdGNoKCdGb3JtYXRBcHBseScsIHtcbiAgICAgIGZvcm1hdCxcbiAgICAgIG5vZGUsXG4gICAgICB2YXJzXG4gICAgfSk7XG4gICAgY29uc3QgZmlyZUZvcm1hdFJlbW92ZSA9IChlZGl0b3IsIGZvcm1hdCwgbm9kZSwgdmFycykgPT4gZWRpdG9yLmRpc3BhdGNoKCdGb3JtYXRSZW1vdmUnLCB7XG4gICAgICBmb3JtYXQsXG4gICAgICBub2RlLFxuICAgICAgdmFyc1xuICAgIH0pO1xuICAgIGNvbnN0IGZpcmVCZWZvcmVTZXRDb250ZW50ID0gKGVkaXRvciwgYXJncykgPT4gZWRpdG9yLmRpc3BhdGNoKCdCZWZvcmVTZXRDb250ZW50JywgYXJncyk7XG4gICAgY29uc3QgZmlyZVNldENvbnRlbnQgPSAoZWRpdG9yLCBhcmdzKSA9PiBlZGl0b3IuZGlzcGF0Y2goJ1NldENvbnRlbnQnLCBhcmdzKTtcbiAgICBjb25zdCBmaXJlQmVmb3JlR2V0Q29udGVudCA9IChlZGl0b3IsIGFyZ3MpID0+IGVkaXRvci5kaXNwYXRjaCgnQmVmb3JlR2V0Q29udGVudCcsIGFyZ3MpO1xuICAgIGNvbnN0IGZpcmVHZXRDb250ZW50ID0gKGVkaXRvciwgYXJncykgPT4gZWRpdG9yLmRpc3BhdGNoKCdHZXRDb250ZW50JywgYXJncyk7XG4gICAgY29uc3QgZmlyZUF1dG9jb21wbGV0ZXJTdGFydCA9IChlZGl0b3IsIGFyZ3MpID0+IGVkaXRvci5kaXNwYXRjaCgnQXV0b2NvbXBsZXRlclN0YXJ0JywgYXJncyk7XG4gICAgY29uc3QgZmlyZUF1dG9jb21wbGV0ZXJVcGRhdGUgPSAoZWRpdG9yLCBhcmdzKSA9PiBlZGl0b3IuZGlzcGF0Y2goJ0F1dG9jb21wbGV0ZXJVcGRhdGUnLCBhcmdzKTtcbiAgICBjb25zdCBmaXJlQXV0b2NvbXBsZXRlckVuZCA9IGVkaXRvciA9PiBlZGl0b3IuZGlzcGF0Y2goJ0F1dG9jb21wbGV0ZXJFbmQnKTtcbiAgICBjb25zdCBmaXJlUGFzdGVQcmVQcm9jZXNzID0gKGVkaXRvciwgaHRtbCwgaW50ZXJuYWwpID0+IGVkaXRvci5kaXNwYXRjaCgnUGFzdGVQcmVQcm9jZXNzJywge1xuICAgICAgY29udGVudDogaHRtbCxcbiAgICAgIGludGVybmFsXG4gICAgfSk7XG4gICAgY29uc3QgZmlyZVBhc3RlUG9zdFByb2Nlc3MgPSAoZWRpdG9yLCBub2RlLCBpbnRlcm5hbCkgPT4gZWRpdG9yLmRpc3BhdGNoKCdQYXN0ZVBvc3RQcm9jZXNzJywge1xuICAgICAgbm9kZSxcbiAgICAgIGludGVybmFsXG4gICAgfSk7XG4gICAgY29uc3QgZmlyZVBhc3RlUGxhaW5UZXh0VG9nZ2xlID0gKGVkaXRvciwgc3RhdGUpID0+IGVkaXRvci5kaXNwYXRjaCgnUGFzdGVQbGFpblRleHRUb2dnbGUnLCB7IHN0YXRlIH0pO1xuXG4gICAgY29uc3QgVksgPSB7XG4gICAgICBCQUNLU1BBQ0U6IDgsXG4gICAgICBERUxFVEU6IDQ2LFxuICAgICAgRE9XTjogNDAsXG4gICAgICBFTlRFUjogMTMsXG4gICAgICBFU0M6IDI3LFxuICAgICAgTEVGVDogMzcsXG4gICAgICBSSUdIVDogMzksXG4gICAgICBTUEFDRUJBUjogMzIsXG4gICAgICBUQUI6IDksXG4gICAgICBVUDogMzgsXG4gICAgICBQQUdFX1VQOiAzMyxcbiAgICAgIFBBR0VfRE9XTjogMzQsXG4gICAgICBFTkQ6IDM1LFxuICAgICAgSE9NRTogMzYsXG4gICAgICBtb2RpZmllclByZXNzZWQ6IGUgPT4ge1xuICAgICAgICByZXR1cm4gZS5zaGlmdEtleSB8fCBlLmN0cmxLZXkgfHwgZS5hbHRLZXkgfHwgVksubWV0YUtleVByZXNzZWQoZSk7XG4gICAgICB9LFxuICAgICAgbWV0YUtleVByZXNzZWQ6IGUgPT4ge1xuICAgICAgICByZXR1cm4gRW52Lm9zLmlzTWFjT1MoKSB8fCBFbnYub3MuaXNpT1MoKSA/IGUubWV0YUtleSA6IGUuY3RybEtleSAmJiAhZS5hbHRLZXk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IENvbnRyb2xTZWxlY3Rpb24gPSAoc2VsZWN0aW9uLCBlZGl0b3IpID0+IHtcbiAgICAgIGNvbnN0IGVsZW1lbnRTZWxlY3Rpb25BdHRyID0gJ2RhdGEtbWNlLXNlbGVjdGVkJztcbiAgICAgIGNvbnN0IGRvbSA9IGVkaXRvci5kb20sIGVhY2ggPSBUb29scy5lYWNoO1xuICAgICAgbGV0IHNlbGVjdGVkRWxtLCBzZWxlY3RlZEVsbUdob3N0LCByZXNpemVIZWxwZXIsIHNlbGVjdGVkSGFuZGxlLCByZXNpemVCYWNrZHJvcDtcbiAgICAgIGxldCBzdGFydFgsIHN0YXJ0WSwgc2VsZWN0ZWRFbG1YLCBzZWxlY3RlZEVsbVksIHN0YXJ0Vywgc3RhcnRILCByYXRpbywgcmVzaXplU3RhcnRlZDtcbiAgICAgIGxldCB3aWR0aCwgaGVpZ2h0O1xuICAgICAgY29uc3QgZWRpdGFibGVEb2MgPSBlZGl0b3IuZ2V0RG9jKCksIHJvb3REb2N1bWVudCA9IGRvY3VtZW50O1xuICAgICAgY29uc3QgYWJzID0gTWF0aC5hYnMsIHJvdW5kID0gTWF0aC5yb3VuZCwgcm9vdEVsZW1lbnQgPSBlZGl0b3IuZ2V0Qm9keSgpO1xuICAgICAgbGV0IHN0YXJ0U2Nyb2xsV2lkdGgsIHN0YXJ0U2Nyb2xsSGVpZ2h0O1xuICAgICAgY29uc3QgcmVzaXplSGFuZGxlcyA9IHtcbiAgICAgICAgbnc6IFtcbiAgICAgICAgICAwLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgLTEsXG4gICAgICAgICAgLTFcbiAgICAgICAgXSxcbiAgICAgICAgbmU6IFtcbiAgICAgICAgICAxLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgMSxcbiAgICAgICAgICAtMVxuICAgICAgICBdLFxuICAgICAgICBzZTogW1xuICAgICAgICAgIDEsXG4gICAgICAgICAgMSxcbiAgICAgICAgICAxLFxuICAgICAgICAgIDFcbiAgICAgICAgXSxcbiAgICAgICAgc3c6IFtcbiAgICAgICAgICAwLFxuICAgICAgICAgIDEsXG4gICAgICAgICAgLTEsXG4gICAgICAgICAgMVxuICAgICAgICBdXG4gICAgICB9O1xuICAgICAgY29uc3QgaXNJbWFnZSA9IGVsbSA9PiBpc05vbk51bGxhYmxlKGVsbSkgJiYgKGlzSW1nKGVsbSkgfHwgZWRpdG9yLmRvbS5pcyhlbG0sICdmaWd1cmUuaW1hZ2UnKSk7XG4gICAgICBjb25zdCBpc01lZGlhID0gZWxtID0+IGlzTWVkaWEkMihlbG0pIHx8IGRvbS5oYXNDbGFzcyhlbG0sICdtY2UtcHJldmlldy1vYmplY3QnKTtcbiAgICAgIGNvbnN0IGlzRXZlbnRPbkltYWdlT3V0c2lkZVJhbmdlID0gKGV2dCwgcmFuZ2UpID0+IHtcbiAgICAgICAgaWYgKGV2dC50eXBlID09PSAnbG9uZ3ByZXNzJyB8fCBldnQudHlwZS5pbmRleE9mKCd0b3VjaCcpID09PSAwKSB7XG4gICAgICAgICAgY29uc3QgdG91Y2ggPSBldnQudG91Y2hlc1swXTtcbiAgICAgICAgICByZXR1cm4gaXNJbWFnZShldnQudGFyZ2V0KSAmJiAhaXNYWVdpdGhpblJhbmdlKHRvdWNoLmNsaWVudFgsIHRvdWNoLmNsaWVudFksIHJhbmdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gaXNJbWFnZShldnQudGFyZ2V0KSAmJiAhaXNYWVdpdGhpblJhbmdlKGV2dC5jbGllbnRYLCBldnQuY2xpZW50WSwgcmFuZ2UpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgY29udGV4dE1lbnVTZWxlY3RJbWFnZSA9IGV2dCA9PiB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGV2dC50YXJnZXQ7XG4gICAgICAgIGlmIChpc0V2ZW50T25JbWFnZU91dHNpZGVSYW5nZShldnQsIGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCkpICYmICFldnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNlbGVjdCh0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgZ2V0UmVzaXplVGFyZ2V0cyA9IGVsbSA9PiB7XG4gICAgICAgIGlmIChkb20uaXMoZWxtLCAnZmlndXJlLmltYWdlJykpIHtcbiAgICAgICAgICByZXR1cm4gW2VsbS5xdWVyeVNlbGVjdG9yKCdpbWcnKV07XG4gICAgICAgIH0gZWxzZSBpZiAoZG9tLmhhc0NsYXNzKGVsbSwgJ21jZS1wcmV2aWV3LW9iamVjdCcpICYmIGlzTm9uTnVsbGFibGUoZWxtLmZpcnN0RWxlbWVudENoaWxkKSkge1xuICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBlbG0sXG4gICAgICAgICAgICBlbG0uZmlyc3RFbGVtZW50Q2hpbGRcbiAgICAgICAgICBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBbZWxtXTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGlzUmVzaXphYmxlID0gZWxtID0+IHtcbiAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBnZXRPYmplY3RSZXNpemluZyhlZGl0b3IpO1xuICAgICAgICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbG0uZ2V0QXR0cmlidXRlKCdkYXRhLW1jZS1yZXNpemUnKSA9PT0gJ2ZhbHNlJykge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWxtID09PSBlZGl0b3IuZ2V0Qm9keSgpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkb20uaGFzQ2xhc3MoZWxtLCAnbWNlLXByZXZpZXctb2JqZWN0JykpIHtcbiAgICAgICAgICByZXR1cm4gaXMkMShTdWdhckVsZW1lbnQuZnJvbURvbShlbG0uZmlyc3RFbGVtZW50Q2hpbGQpLCBzZWxlY3Rvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGlzJDEoU3VnYXJFbGVtZW50LmZyb21Eb20oZWxtKSwgc2VsZWN0b3IpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgY3JlYXRlR2hvc3RFbGVtZW50ID0gZWxtID0+IHtcbiAgICAgICAgaWYgKGlzTWVkaWEoZWxtKSkge1xuICAgICAgICAgIHJldHVybiBkb20uY3JlYXRlKCdpbWcnLCB7IHNyYzogRW52LnRyYW5zcGFyZW50U3JjIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBlbG0uY2xvbmVOb2RlKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3Qgc2V0U2l6ZVByb3AgPSAoZWxlbWVudCwgbmFtZSwgdmFsdWUpID0+IHtcbiAgICAgICAgaWYgKGlzTm9uTnVsbGFibGUodmFsdWUpKSB7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0cyA9IGdldFJlc2l6ZVRhcmdldHMoZWxlbWVudCk7XG4gICAgICAgICAgZWFjaCRnKHRhcmdldHMsIHRhcmdldCA9PiB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0LnN0eWxlW25hbWVdIHx8ICFlZGl0b3Iuc2NoZW1hLmlzVmFsaWQodGFyZ2V0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksIG5hbWUpKSB7XG4gICAgICAgICAgICAgIGRvbS5zZXRTdHlsZSh0YXJnZXQsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRvbS5zZXRBdHRyaWIodGFyZ2V0LCBuYW1lLCAnJyArIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHNldEdob3N0RWxtU2l6ZSA9IChnaG9zdEVsbSwgd2lkdGgsIGhlaWdodCkgPT4ge1xuICAgICAgICBzZXRTaXplUHJvcChnaG9zdEVsbSwgJ3dpZHRoJywgd2lkdGgpO1xuICAgICAgICBzZXRTaXplUHJvcChnaG9zdEVsbSwgJ2hlaWdodCcsIGhlaWdodCk7XG4gICAgICB9O1xuICAgICAgY29uc3QgcmVzaXplR2hvc3RFbGVtZW50ID0gZSA9PiB7XG4gICAgICAgIGxldCBkZWx0YVgsIGRlbHRhWSwgcHJvcG9ydGlvbmFsO1xuICAgICAgICBsZXQgcmVzaXplSGVscGVyWCwgcmVzaXplSGVscGVyWTtcbiAgICAgICAgZGVsdGFYID0gZS5zY3JlZW5YIC0gc3RhcnRYO1xuICAgICAgICBkZWx0YVkgPSBlLnNjcmVlblkgLSBzdGFydFk7XG4gICAgICAgIHdpZHRoID0gZGVsdGFYICogc2VsZWN0ZWRIYW5kbGVbMl0gKyBzdGFydFc7XG4gICAgICAgIGhlaWdodCA9IGRlbHRhWSAqIHNlbGVjdGVkSGFuZGxlWzNdICsgc3RhcnRIO1xuICAgICAgICB3aWR0aCA9IHdpZHRoIDwgNSA/IDUgOiB3aWR0aDtcbiAgICAgICAgaGVpZ2h0ID0gaGVpZ2h0IDwgNSA/IDUgOiBoZWlnaHQ7XG4gICAgICAgIGlmICgoaXNJbWFnZShzZWxlY3RlZEVsbSkgfHwgaXNNZWRpYShzZWxlY3RlZEVsbSkpICYmIGdldFJlc2l6ZUltZ1Byb3BvcnRpb25hbChlZGl0b3IpICE9PSBmYWxzZSkge1xuICAgICAgICAgIHByb3BvcnRpb25hbCA9ICFWSy5tb2RpZmllclByZXNzZWQoZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvcG9ydGlvbmFsID0gVksubW9kaWZpZXJQcmVzc2VkKGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wb3J0aW9uYWwpIHtcbiAgICAgICAgICBpZiAoYWJzKGRlbHRhWCkgPiBhYnMoZGVsdGFZKSkge1xuICAgICAgICAgICAgaGVpZ2h0ID0gcm91bmQod2lkdGggKiByYXRpbyk7XG4gICAgICAgICAgICB3aWR0aCA9IHJvdW5kKGhlaWdodCAvIHJhdGlvKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2lkdGggPSByb3VuZChoZWlnaHQgLyByYXRpbyk7XG4gICAgICAgICAgICBoZWlnaHQgPSByb3VuZCh3aWR0aCAqIHJhdGlvKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2V0R2hvc3RFbG1TaXplKHNlbGVjdGVkRWxtR2hvc3QsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICByZXNpemVIZWxwZXJYID0gc2VsZWN0ZWRIYW5kbGUuc3RhcnRQb3MueCArIGRlbHRhWDtcbiAgICAgICAgcmVzaXplSGVscGVyWSA9IHNlbGVjdGVkSGFuZGxlLnN0YXJ0UG9zLnkgKyBkZWx0YVk7XG4gICAgICAgIHJlc2l6ZUhlbHBlclggPSByZXNpemVIZWxwZXJYID4gMCA/IHJlc2l6ZUhlbHBlclggOiAwO1xuICAgICAgICByZXNpemVIZWxwZXJZID0gcmVzaXplSGVscGVyWSA+IDAgPyByZXNpemVIZWxwZXJZIDogMDtcbiAgICAgICAgZG9tLnNldFN0eWxlcyhyZXNpemVIZWxwZXIsIHtcbiAgICAgICAgICBsZWZ0OiByZXNpemVIZWxwZXJYLFxuICAgICAgICAgIHRvcDogcmVzaXplSGVscGVyWSxcbiAgICAgICAgICBkaXNwbGF5OiAnYmxvY2snXG4gICAgICAgIH0pO1xuICAgICAgICByZXNpemVIZWxwZXIuaW5uZXJIVE1MID0gd2lkdGggKyAnICZ0aW1lczsgJyArIGhlaWdodDtcbiAgICAgICAgaWYgKHNlbGVjdGVkSGFuZGxlWzJdIDwgMCAmJiBzZWxlY3RlZEVsbUdob3N0LmNsaWVudFdpZHRoIDw9IHdpZHRoKSB7XG4gICAgICAgICAgZG9tLnNldFN0eWxlKHNlbGVjdGVkRWxtR2hvc3QsICdsZWZ0Jywgc2VsZWN0ZWRFbG1YICsgKHN0YXJ0VyAtIHdpZHRoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGVjdGVkSGFuZGxlWzNdIDwgMCAmJiBzZWxlY3RlZEVsbUdob3N0LmNsaWVudEhlaWdodCA8PSBoZWlnaHQpIHtcbiAgICAgICAgICBkb20uc2V0U3R5bGUoc2VsZWN0ZWRFbG1HaG9zdCwgJ3RvcCcsIHNlbGVjdGVkRWxtWSArIChzdGFydEggLSBoZWlnaHQpKTtcbiAgICAgICAgfVxuICAgICAgICBkZWx0YVggPSByb290RWxlbWVudC5zY3JvbGxXaWR0aCAtIHN0YXJ0U2Nyb2xsV2lkdGg7XG4gICAgICAgIGRlbHRhWSA9IHJvb3RFbGVtZW50LnNjcm9sbEhlaWdodCAtIHN0YXJ0U2Nyb2xsSGVpZ2h0O1xuICAgICAgICBpZiAoZGVsdGFYICsgZGVsdGFZICE9PSAwKSB7XG4gICAgICAgICAgZG9tLnNldFN0eWxlcyhyZXNpemVIZWxwZXIsIHtcbiAgICAgICAgICAgIGxlZnQ6IHJlc2l6ZUhlbHBlclggLSBkZWx0YVgsXG4gICAgICAgICAgICB0b3A6IHJlc2l6ZUhlbHBlclkgLSBkZWx0YVlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc2l6ZVN0YXJ0ZWQpIHtcbiAgICAgICAgICBmaXJlT2JqZWN0UmVzaXplU3RhcnQoZWRpdG9yLCBzZWxlY3RlZEVsbSwgc3RhcnRXLCBzdGFydEgsICdjb3JuZXItJyArIHNlbGVjdGVkSGFuZGxlLm5hbWUpO1xuICAgICAgICAgIHJlc2l6ZVN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgZW5kR2hvc3RSZXNpemUgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHdhc1Jlc2l6ZVN0YXJ0ZWQgPSByZXNpemVTdGFydGVkO1xuICAgICAgICByZXNpemVTdGFydGVkID0gZmFsc2U7XG4gICAgICAgIGlmICh3YXNSZXNpemVTdGFydGVkKSB7XG4gICAgICAgICAgc2V0U2l6ZVByb3Aoc2VsZWN0ZWRFbG0sICd3aWR0aCcsIHdpZHRoKTtcbiAgICAgICAgICBzZXRTaXplUHJvcChzZWxlY3RlZEVsbSwgJ2hlaWdodCcsIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgZG9tLnVuYmluZChlZGl0YWJsZURvYywgJ21vdXNlbW92ZScsIHJlc2l6ZUdob3N0RWxlbWVudCk7XG4gICAgICAgIGRvbS51bmJpbmQoZWRpdGFibGVEb2MsICdtb3VzZXVwJywgZW5kR2hvc3RSZXNpemUpO1xuICAgICAgICBpZiAocm9vdERvY3VtZW50ICE9PSBlZGl0YWJsZURvYykge1xuICAgICAgICAgIGRvbS51bmJpbmQocm9vdERvY3VtZW50LCAnbW91c2Vtb3ZlJywgcmVzaXplR2hvc3RFbGVtZW50KTtcbiAgICAgICAgICBkb20udW5iaW5kKHJvb3REb2N1bWVudCwgJ21vdXNldXAnLCBlbmRHaG9zdFJlc2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZG9tLnJlbW92ZShzZWxlY3RlZEVsbUdob3N0KTtcbiAgICAgICAgZG9tLnJlbW92ZShyZXNpemVIZWxwZXIpO1xuICAgICAgICBkb20ucmVtb3ZlKHJlc2l6ZUJhY2tkcm9wKTtcbiAgICAgICAgc2hvd1Jlc2l6ZVJlY3Qoc2VsZWN0ZWRFbG0pO1xuICAgICAgICBpZiAod2FzUmVzaXplU3RhcnRlZCkge1xuICAgICAgICAgIGZpcmVPYmplY3RSZXNpemVkKGVkaXRvciwgc2VsZWN0ZWRFbG0sIHdpZHRoLCBoZWlnaHQsICdjb3JuZXItJyArIHNlbGVjdGVkSGFuZGxlLm5hbWUpO1xuICAgICAgICAgIGRvbS5zZXRBdHRyaWIoc2VsZWN0ZWRFbG0sICdzdHlsZScsIGRvbS5nZXRBdHRyaWIoc2VsZWN0ZWRFbG0sICdzdHlsZScpKTtcbiAgICAgICAgfVxuICAgICAgICBlZGl0b3Iubm9kZUNoYW5nZWQoKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBzaG93UmVzaXplUmVjdCA9IHRhcmdldEVsbSA9PiB7XG4gICAgICAgIHVuYmluZFJlc2l6ZUhhbmRsZUV2ZW50cygpO1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IGRvbS5nZXRQb3ModGFyZ2V0RWxtLCByb290RWxlbWVudCk7XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkRWxtWCA9IHBvc2l0aW9uLng7XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkRWxtWSA9IHBvc2l0aW9uLnk7XG4gICAgICAgIGNvbnN0IHJlY3QgPSB0YXJnZXRFbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnN0IHRhcmdldFdpZHRoID0gcmVjdC53aWR0aCB8fCByZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0O1xuICAgICAgICBjb25zdCB0YXJnZXRIZWlnaHQgPSByZWN0LmhlaWdodCB8fCByZWN0LmJvdHRvbSAtIHJlY3QudG9wO1xuICAgICAgICBpZiAoc2VsZWN0ZWRFbG0gIT09IHRhcmdldEVsbSkge1xuICAgICAgICAgIGhpZGVSZXNpemVSZWN0KCk7XG4gICAgICAgICAgc2VsZWN0ZWRFbG0gPSB0YXJnZXRFbG07XG4gICAgICAgICAgd2lkdGggPSBoZWlnaHQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGUgPSBlZGl0b3IuZGlzcGF0Y2goJ09iamVjdFNlbGVjdGVkJywgeyB0YXJnZXQ6IHRhcmdldEVsbSB9KTtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRWYWx1ZSA9IGRvbS5nZXRBdHRyaWIoc2VsZWN0ZWRFbG0sIGVsZW1lbnRTZWxlY3Rpb25BdHRyLCAnMScpO1xuICAgICAgICBpZiAoaXNSZXNpemFibGUodGFyZ2V0RWxtKSAmJiAhZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICAgIGVhY2gocmVzaXplSGFuZGxlcywgKGhhbmRsZSwgbmFtZSkgPT4ge1xuICAgICAgICAgICAgbGV0IGhhbmRsZUVsbTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0RHJhZyA9IGUgPT4ge1xuICAgICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBnZXRSZXNpemVUYXJnZXRzKHNlbGVjdGVkRWxtKVswXTtcbiAgICAgICAgICAgICAgc3RhcnRYID0gZS5zY3JlZW5YO1xuICAgICAgICAgICAgICBzdGFydFkgPSBlLnNjcmVlblk7XG4gICAgICAgICAgICAgIHN0YXJ0VyA9IHRhcmdldC5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgICAgc3RhcnRIID0gdGFyZ2V0LmNsaWVudEhlaWdodDtcbiAgICAgICAgICAgICAgcmF0aW8gPSBzdGFydEggLyBzdGFydFc7XG4gICAgICAgICAgICAgIHNlbGVjdGVkSGFuZGxlID0gaGFuZGxlO1xuICAgICAgICAgICAgICBzZWxlY3RlZEhhbmRsZS5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgICAgc2VsZWN0ZWRIYW5kbGUuc3RhcnRQb3MgPSB7XG4gICAgICAgICAgICAgICAgeDogdGFyZ2V0V2lkdGggKiBoYW5kbGVbMF0gKyBzZWxlY3RlZEVsbVgsXG4gICAgICAgICAgICAgICAgeTogdGFyZ2V0SGVpZ2h0ICogaGFuZGxlWzFdICsgc2VsZWN0ZWRFbG1ZXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHN0YXJ0U2Nyb2xsV2lkdGggPSByb290RWxlbWVudC5zY3JvbGxXaWR0aDtcbiAgICAgICAgICAgICAgc3RhcnRTY3JvbGxIZWlnaHQgPSByb290RWxlbWVudC5zY3JvbGxIZWlnaHQ7XG4gICAgICAgICAgICAgIHJlc2l6ZUJhY2tkcm9wID0gZG9tLmFkZChyb290RWxlbWVudCwgJ2RpdicsIHtcbiAgICAgICAgICAgICAgICAnY2xhc3MnOiAnbWNlLXJlc2l6ZS1iYWNrZHJvcCcsXG4gICAgICAgICAgICAgICAgJ2RhdGEtbWNlLWJvZ3VzJzogJ2FsbCdcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGRvbS5zZXRTdHlsZXMocmVzaXplQmFja2Ryb3AsIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICAgICAgICAgICAgICBsZWZ0OiAnMCcsXG4gICAgICAgICAgICAgICAgdG9wOiAnMCcsXG4gICAgICAgICAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6ICcxMDAlJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgc2VsZWN0ZWRFbG1HaG9zdCA9IGNyZWF0ZUdob3N0RWxlbWVudChzZWxlY3RlZEVsbSk7XG4gICAgICAgICAgICAgIGRvbS5hZGRDbGFzcyhzZWxlY3RlZEVsbUdob3N0LCAnbWNlLWNsb25lZHJlc2l6YWJsZScpO1xuICAgICAgICAgICAgICBkb20uc2V0QXR0cmliKHNlbGVjdGVkRWxtR2hvc3QsICdkYXRhLW1jZS1ib2d1cycsICdhbGwnKTtcbiAgICAgICAgICAgICAgc2VsZWN0ZWRFbG1HaG9zdC5jb250ZW50RWRpdGFibGUgPSAnZmFsc2UnO1xuICAgICAgICAgICAgICBkb20uc2V0U3R5bGVzKHNlbGVjdGVkRWxtR2hvc3QsIHtcbiAgICAgICAgICAgICAgICBsZWZ0OiBzZWxlY3RlZEVsbVgsXG4gICAgICAgICAgICAgICAgdG9wOiBzZWxlY3RlZEVsbVksXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAwXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBzZXRHaG9zdEVsbVNpemUoc2VsZWN0ZWRFbG1HaG9zdCwgdGFyZ2V0V2lkdGgsIHRhcmdldEhlaWdodCk7XG4gICAgICAgICAgICAgIHNlbGVjdGVkRWxtR2hvc3QucmVtb3ZlQXR0cmlidXRlKGVsZW1lbnRTZWxlY3Rpb25BdHRyKTtcbiAgICAgICAgICAgICAgcm9vdEVsZW1lbnQuYXBwZW5kQ2hpbGQoc2VsZWN0ZWRFbG1HaG9zdCk7XG4gICAgICAgICAgICAgIGRvbS5iaW5kKGVkaXRhYmxlRG9jLCAnbW91c2Vtb3ZlJywgcmVzaXplR2hvc3RFbGVtZW50KTtcbiAgICAgICAgICAgICAgZG9tLmJpbmQoZWRpdGFibGVEb2MsICdtb3VzZXVwJywgZW5kR2hvc3RSZXNpemUpO1xuICAgICAgICAgICAgICBpZiAocm9vdERvY3VtZW50ICE9PSBlZGl0YWJsZURvYykge1xuICAgICAgICAgICAgICAgIGRvbS5iaW5kKHJvb3REb2N1bWVudCwgJ21vdXNlbW92ZScsIHJlc2l6ZUdob3N0RWxlbWVudCk7XG4gICAgICAgICAgICAgICAgZG9tLmJpbmQocm9vdERvY3VtZW50LCAnbW91c2V1cCcsIGVuZEdob3N0UmVzaXplKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXNpemVIZWxwZXIgPSBkb20uYWRkKHJvb3RFbGVtZW50LCAnZGl2Jywge1xuICAgICAgICAgICAgICAgICdjbGFzcyc6ICdtY2UtcmVzaXplLWhlbHBlcicsXG4gICAgICAgICAgICAgICAgJ2RhdGEtbWNlLWJvZ3VzJzogJ2FsbCdcbiAgICAgICAgICAgICAgfSwgc3RhcnRXICsgJyAmdGltZXM7ICcgKyBzdGFydEgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGhhbmRsZUVsbSA9IGRvbS5nZXQoJ21jZVJlc2l6ZUhhbmRsZScgKyBuYW1lKTtcbiAgICAgICAgICAgIGlmIChoYW5kbGVFbG0pIHtcbiAgICAgICAgICAgICAgZG9tLnJlbW92ZShoYW5kbGVFbG0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFuZGxlRWxtID0gZG9tLmFkZChyb290RWxlbWVudCwgJ2RpdicsIHtcbiAgICAgICAgICAgICAgJ2lkJzogJ21jZVJlc2l6ZUhhbmRsZScgKyBuYW1lLFxuICAgICAgICAgICAgICAnZGF0YS1tY2UtYm9ndXMnOiAnYWxsJyxcbiAgICAgICAgICAgICAgJ2NsYXNzJzogJ21jZS1yZXNpemVoYW5kbGUnLFxuICAgICAgICAgICAgICAndW5zZWxlY3RhYmxlJzogdHJ1ZSxcbiAgICAgICAgICAgICAgJ3N0eWxlJzogJ2N1cnNvcjonICsgbmFtZSArICctcmVzaXplOyBtYXJnaW46MDsgcGFkZGluZzowJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkb20uYmluZChoYW5kbGVFbG0sICdtb3VzZWRvd24nLCBlID0+IHtcbiAgICAgICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICBzdGFydERyYWcoZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGhhbmRsZS5lbG0gPSBoYW5kbGVFbG07XG4gICAgICAgICAgICBkb20uc2V0U3R5bGVzKGhhbmRsZUVsbSwge1xuICAgICAgICAgICAgICBsZWZ0OiB0YXJnZXRXaWR0aCAqIGhhbmRsZVswXSArIHNlbGVjdGVkRWxtWCAtIGhhbmRsZUVsbS5vZmZzZXRXaWR0aCAvIDIsXG4gICAgICAgICAgICAgIHRvcDogdGFyZ2V0SGVpZ2h0ICogaGFuZGxlWzFdICsgc2VsZWN0ZWRFbG1ZIC0gaGFuZGxlRWxtLm9mZnNldEhlaWdodCAvIDJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhpZGVSZXNpemVSZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkb20uZ2V0QXR0cmliKHNlbGVjdGVkRWxtLCBlbGVtZW50U2VsZWN0aW9uQXR0cikpIHtcbiAgICAgICAgICBzZWxlY3RlZEVsbS5zZXRBdHRyaWJ1dGUoZWxlbWVudFNlbGVjdGlvbkF0dHIsIHNlbGVjdGVkVmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgaGlkZVJlc2l6ZVJlY3QgPSAoKSA9PiB7XG4gICAgICAgIHVuYmluZFJlc2l6ZUhhbmRsZUV2ZW50cygpO1xuICAgICAgICBpZiAoc2VsZWN0ZWRFbG0pIHtcbiAgICAgICAgICBzZWxlY3RlZEVsbS5yZW1vdmVBdHRyaWJ1dGUoZWxlbWVudFNlbGVjdGlvbkF0dHIpO1xuICAgICAgICB9XG4gICAgICAgIGVhY2gkZihyZXNpemVIYW5kbGVzLCAodmFsdWUsIG5hbWUpID0+IHtcbiAgICAgICAgICBjb25zdCBoYW5kbGVFbG0gPSBkb20uZ2V0KCdtY2VSZXNpemVIYW5kbGUnICsgbmFtZSk7XG4gICAgICAgICAgaWYgKGhhbmRsZUVsbSkge1xuICAgICAgICAgICAgZG9tLnVuYmluZChoYW5kbGVFbG0pO1xuICAgICAgICAgICAgZG9tLnJlbW92ZShoYW5kbGVFbG0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgdXBkYXRlUmVzaXplUmVjdCA9IGUgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBzdGFydEVsbSwgY29udHJvbEVsbTtcbiAgICAgICAgY29uc3QgaXNDaGlsZE9yRXF1YWwgPSAobm9kZSwgcGFyZW50KSA9PiB7XG4gICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgaWYgKG5vZGUgPT09IHBhcmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChub2RlID0gbm9kZS5wYXJlbnROb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChyZXNpemVTdGFydGVkIHx8IGVkaXRvci5yZW1vdmVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVhY2goZG9tLnNlbGVjdCgnaW1nW2RhdGEtbWNlLXNlbGVjdGVkXSxocltkYXRhLW1jZS1zZWxlY3RlZF0nKSwgaW1nID0+IHtcbiAgICAgICAgICBpbWcucmVtb3ZlQXR0cmlidXRlKGVsZW1lbnRTZWxlY3Rpb25BdHRyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnRyb2xFbG0gPSBlLnR5cGUgPT09ICdtb3VzZWRvd24nID8gZS50YXJnZXQgOiBzZWxlY3Rpb24uZ2V0Tm9kZSgpO1xuICAgICAgICBjb250cm9sRWxtID0gKF9hID0gY2xvc2VzdCQzKFN1Z2FyRWxlbWVudC5mcm9tRG9tKGNvbnRyb2xFbG0pLCAndGFibGUsaW1nLGZpZ3VyZS5pbWFnZSxocix2aWRlbyxzcGFuLm1jZS1wcmV2aWV3LW9iamVjdCcpLmdldE9yVW5kZWZpbmVkKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kb207XG4gICAgICAgIGlmIChpc0NoaWxkT3JFcXVhbChjb250cm9sRWxtLCByb290RWxlbWVudCkpIHtcbiAgICAgICAgICBkaXNhYmxlR2Vja29SZXNpemUoKTtcbiAgICAgICAgICBzdGFydEVsbSA9IHNlbGVjdGlvbi5nZXRTdGFydCh0cnVlKTtcbiAgICAgICAgICBpZiAoaXNDaGlsZE9yRXF1YWwoc3RhcnRFbG0sIGNvbnRyb2xFbG0pICYmIGlzQ2hpbGRPckVxdWFsKHNlbGVjdGlvbi5nZXRFbmQodHJ1ZSksIGNvbnRyb2xFbG0pKSB7XG4gICAgICAgICAgICBzaG93UmVzaXplUmVjdChjb250cm9sRWxtKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaGlkZVJlc2l6ZVJlY3QoKTtcbiAgICAgIH07XG4gICAgICBjb25zdCB1bmJpbmRSZXNpemVIYW5kbGVFdmVudHMgPSAoKSA9PiB7XG4gICAgICAgIGVhY2gkZihyZXNpemVIYW5kbGVzLCBoYW5kbGUgPT4ge1xuICAgICAgICAgIGlmIChoYW5kbGUuZWxtKSB7XG4gICAgICAgICAgICBkb20udW5iaW5kKGhhbmRsZS5lbG0pO1xuICAgICAgICAgICAgZGVsZXRlIGhhbmRsZS5lbG07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBjb25zdCBkaXNhYmxlR2Vja29SZXNpemUgPSAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZWRpdG9yLmdldERvYygpLmV4ZWNDb21tYW5kKCdlbmFibGVPYmplY3RSZXNpemluZycsIGZhbHNlLCAnZmFsc2UnKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGVkaXRvci5vbignaW5pdCcsICgpID0+IHtcbiAgICAgICAgZGlzYWJsZUdlY2tvUmVzaXplKCk7XG4gICAgICAgIGNvbnN0IHRocm90dGxlZFVwZGF0ZVJlc2l6ZVJlY3QgPSBmaXJzdCQxKGUgPT4ge1xuICAgICAgICAgIGlmICghZWRpdG9yLmNvbXBvc2luZykge1xuICAgICAgICAgICAgdXBkYXRlUmVzaXplUmVjdChlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDApO1xuICAgICAgICBlZGl0b3Iub24oJ25vZGVjaGFuZ2UgUmVzaXplRWRpdG9yIFJlc2l6ZVdpbmRvdyBSZXNpemVDb250ZW50IGRyb3AgRnVsbHNjcmVlblN0YXRlQ2hhbmdlZCcsIHRocm90dGxlZFVwZGF0ZVJlc2l6ZVJlY3QudGhyb3R0bGUpO1xuICAgICAgICBlZGl0b3Iub24oJ2tleXVwIGNvbXBvc2l0aW9uZW5kJywgZSA9PiB7XG4gICAgICAgICAgaWYgKHNlbGVjdGVkRWxtICYmIHNlbGVjdGVkRWxtLm5vZGVOYW1lID09PSAnVEFCTEUnKSB7XG4gICAgICAgICAgICB0aHJvdHRsZWRVcGRhdGVSZXNpemVSZWN0LnRocm90dGxlKGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGVkaXRvci5vbignaGlkZSBibHVyJywgaGlkZVJlc2l6ZVJlY3QpO1xuICAgICAgICBlZGl0b3Iub24oJ2NvbnRleHRtZW51IGxvbmdwcmVzcycsIGNvbnRleHRNZW51U2VsZWN0SW1hZ2UsIHRydWUpO1xuICAgICAgfSk7XG4gICAgICBlZGl0b3Iub24oJ3JlbW92ZScsIHVuYmluZFJlc2l6ZUhhbmRsZUV2ZW50cyk7XG4gICAgICBjb25zdCBkZXN0cm95ID0gKCkgPT4ge1xuICAgICAgICBzZWxlY3RlZEVsbSA9IHNlbGVjdGVkRWxtR2hvc3QgPSByZXNpemVCYWNrZHJvcCA9IG51bGw7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNSZXNpemFibGUsXG4gICAgICAgIHNob3dSZXNpemVSZWN0LFxuICAgICAgICBoaWRlUmVzaXplUmVjdCxcbiAgICAgICAgdXBkYXRlUmVzaXplUmVjdCxcbiAgICAgICAgZGVzdHJveVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgY29uc3Qgc2V0U3RhcnQgPSAocm5nLCBzaXR1KSA9PiB7XG4gICAgICBzaXR1LmZvbGQoZSA9PiB7XG4gICAgICAgIHJuZy5zZXRTdGFydEJlZm9yZShlLmRvbSk7XG4gICAgICB9LCAoZSwgbykgPT4ge1xuICAgICAgICBybmcuc2V0U3RhcnQoZS5kb20sIG8pO1xuICAgICAgfSwgZSA9PiB7XG4gICAgICAgIHJuZy5zZXRTdGFydEFmdGVyKGUuZG9tKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3Qgc2V0RmluaXNoID0gKHJuZywgc2l0dSkgPT4ge1xuICAgICAgc2l0dS5mb2xkKGUgPT4ge1xuICAgICAgICBybmcuc2V0RW5kQmVmb3JlKGUuZG9tKTtcbiAgICAgIH0sIChlLCBvKSA9PiB7XG4gICAgICAgIHJuZy5zZXRFbmQoZS5kb20sIG8pO1xuICAgICAgfSwgZSA9PiB7XG4gICAgICAgIHJuZy5zZXRFbmRBZnRlcihlLmRvbSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHJlbGF0aXZlVG9OYXRpdmUgPSAod2luLCBzdGFydFNpdHUsIGZpbmlzaFNpdHUpID0+IHtcbiAgICAgIGNvbnN0IHJhbmdlID0gd2luLmRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICBzZXRTdGFydChyYW5nZSwgc3RhcnRTaXR1KTtcbiAgICAgIHNldEZpbmlzaChyYW5nZSwgZmluaXNoU2l0dSk7XG4gICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfTtcbiAgICBjb25zdCBleGFjdFRvTmF0aXZlID0gKHdpbiwgc3RhcnQsIHNvZmZzZXQsIGZpbmlzaCwgZm9mZnNldCkgPT4ge1xuICAgICAgY29uc3Qgcm5nID0gd2luLmRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICBybmcuc2V0U3RhcnQoc3RhcnQuZG9tLCBzb2Zmc2V0KTtcbiAgICAgIHJuZy5zZXRFbmQoZmluaXNoLmRvbSwgZm9mZnNldCk7XG4gICAgICByZXR1cm4gcm5nO1xuICAgIH07XG5cbiAgICBjb25zdCBhZHQkMyA9IEFkdC5nZW5lcmF0ZShbXG4gICAgICB7XG4gICAgICAgIGx0cjogW1xuICAgICAgICAgICdzdGFydCcsXG4gICAgICAgICAgJ3NvZmZzZXQnLFxuICAgICAgICAgICdmaW5pc2gnLFxuICAgICAgICAgICdmb2Zmc2V0J1xuICAgICAgICBdXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBydGw6IFtcbiAgICAgICAgICAnc3RhcnQnLFxuICAgICAgICAgICdzb2Zmc2V0JyxcbiAgICAgICAgICAnZmluaXNoJyxcbiAgICAgICAgICAnZm9mZnNldCdcbiAgICAgICAgXVxuICAgICAgfVxuICAgIF0pO1xuICAgIGNvbnN0IGZyb21SYW5nZSA9ICh3aW4sIHR5cGUsIHJhbmdlKSA9PiB0eXBlKFN1Z2FyRWxlbWVudC5mcm9tRG9tKHJhbmdlLnN0YXJ0Q29udGFpbmVyKSwgcmFuZ2Uuc3RhcnRPZmZzZXQsIFN1Z2FyRWxlbWVudC5mcm9tRG9tKHJhbmdlLmVuZENvbnRhaW5lciksIHJhbmdlLmVuZE9mZnNldCk7XG4gICAgY29uc3QgZ2V0UmFuZ2VzID0gKHdpbiwgc2VsZWN0aW9uKSA9PiBzZWxlY3Rpb24ubWF0Y2goe1xuICAgICAgZG9tUmFuZ2U6IHJuZyA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbHRyOiBjb25zdGFudChybmcpLFxuICAgICAgICAgIHJ0bDogT3B0aW9uYWwubm9uZVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHJlbGF0aXZlOiAoc3RhcnRTaXR1LCBmaW5pc2hTaXR1KSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbHRyOiBjYWNoZWQoKCkgPT4gcmVsYXRpdmVUb05hdGl2ZSh3aW4sIHN0YXJ0U2l0dSwgZmluaXNoU2l0dSkpLFxuICAgICAgICAgIHJ0bDogY2FjaGVkKCgpID0+IE9wdGlvbmFsLnNvbWUocmVsYXRpdmVUb05hdGl2ZSh3aW4sIGZpbmlzaFNpdHUsIHN0YXJ0U2l0dSkpKVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGV4YWN0OiAoc3RhcnQsIHNvZmZzZXQsIGZpbmlzaCwgZm9mZnNldCkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGx0cjogY2FjaGVkKCgpID0+IGV4YWN0VG9OYXRpdmUod2luLCBzdGFydCwgc29mZnNldCwgZmluaXNoLCBmb2Zmc2V0KSksXG4gICAgICAgICAgcnRsOiBjYWNoZWQoKCkgPT4gT3B0aW9uYWwuc29tZShleGFjdFRvTmF0aXZlKHdpbiwgZmluaXNoLCBmb2Zmc2V0LCBzdGFydCwgc29mZnNldCkpKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGRvRGlhZ25vc2UgPSAod2luLCByYW5nZXMpID0+IHtcbiAgICAgIGNvbnN0IHJuZyA9IHJhbmdlcy5sdHIoKTtcbiAgICAgIGlmIChybmcuY29sbGFwc2VkKSB7XG4gICAgICAgIGNvbnN0IHJldmVyc2VkID0gcmFuZ2VzLnJ0bCgpLmZpbHRlcihyZXYgPT4gcmV2LmNvbGxhcHNlZCA9PT0gZmFsc2UpO1xuICAgICAgICByZXR1cm4gcmV2ZXJzZWQubWFwKHJldiA9PiBhZHQkMy5ydGwoU3VnYXJFbGVtZW50LmZyb21Eb20ocmV2LmVuZENvbnRhaW5lciksIHJldi5lbmRPZmZzZXQsIFN1Z2FyRWxlbWVudC5mcm9tRG9tKHJldi5zdGFydENvbnRhaW5lciksIHJldi5zdGFydE9mZnNldCkpLmdldE9yVGh1bmsoKCkgPT4gZnJvbVJhbmdlKHdpbiwgYWR0JDMubHRyLCBybmcpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmcm9tUmFuZ2Uod2luLCBhZHQkMy5sdHIsIHJuZyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBkaWFnbm9zZSA9ICh3aW4sIHNlbGVjdGlvbikgPT4ge1xuICAgICAgY29uc3QgcmFuZ2VzID0gZ2V0UmFuZ2VzKHdpbiwgc2VsZWN0aW9uKTtcbiAgICAgIHJldHVybiBkb0RpYWdub3NlKHdpbiwgcmFuZ2VzKTtcbiAgICB9O1xuICAgIGFkdCQzLmx0cjtcbiAgICBhZHQkMy5ydGw7XG5cbiAgICBjb25zdCBjcmVhdGUkOSA9IChzdGFydCwgc29mZnNldCwgZmluaXNoLCBmb2Zmc2V0KSA9PiAoe1xuICAgICAgc3RhcnQsXG4gICAgICBzb2Zmc2V0LFxuICAgICAgZmluaXNoLFxuICAgICAgZm9mZnNldFxuICAgIH0pO1xuICAgIGNvbnN0IFNpbVJhbmdlID0geyBjcmVhdGU6IGNyZWF0ZSQ5IH07XG5cbiAgICBjb25zdCBjYXJldFBvc2l0aW9uRnJvbVBvaW50ID0gKGRvYywgeCwgeSkgPT4ge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIHJldHVybiBPcHRpb25hbC5mcm9tKChfYiA9IChfYSA9IGRvYy5kb20pLmNhcmV0UG9zaXRpb25Gcm9tUG9pbnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCB4LCB5KSkuYmluZChwb3MgPT4ge1xuICAgICAgICBpZiAocG9zLm9mZnNldE5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHIgPSBkb2MuZG9tLmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgIHIuc2V0U3RhcnQocG9zLm9mZnNldE5vZGUsIHBvcy5vZmZzZXQpO1xuICAgICAgICByLmNvbGxhcHNlKCk7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKHIpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBjYXJldFJhbmdlRnJvbVBvaW50ID0gKGRvYywgeCwgeSkgPT4ge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIHJldHVybiBPcHRpb25hbC5mcm9tKChfYiA9IChfYSA9IGRvYy5kb20pLmNhcmV0UmFuZ2VGcm9tUG9pbnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCB4LCB5KSk7XG4gICAgfTtcbiAgICBjb25zdCBhdmFpbGFibGVTZWFyY2ggPSAoKCkgPT4ge1xuICAgICAgaWYgKGRvY3VtZW50LmNhcmV0UG9zaXRpb25Gcm9tUG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIGNhcmV0UG9zaXRpb25Gcm9tUG9pbnQ7XG4gICAgICB9IGVsc2UgaWYgKGRvY3VtZW50LmNhcmV0UmFuZ2VGcm9tUG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIGNhcmV0UmFuZ2VGcm9tUG9pbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZTtcbiAgICAgIH1cbiAgICB9KSgpO1xuICAgIGNvbnN0IGZyb21Qb2ludCQxID0gKHdpbiwgeCwgeSkgPT4ge1xuICAgICAgY29uc3QgZG9jID0gU3VnYXJFbGVtZW50LmZyb21Eb20od2luLmRvY3VtZW50KTtcbiAgICAgIHJldHVybiBhdmFpbGFibGVTZWFyY2goZG9jLCB4LCB5KS5tYXAocm5nID0+IFNpbVJhbmdlLmNyZWF0ZShTdWdhckVsZW1lbnQuZnJvbURvbShybmcuc3RhcnRDb250YWluZXIpLCBybmcuc3RhcnRPZmZzZXQsIFN1Z2FyRWxlbWVudC5mcm9tRG9tKHJuZy5lbmRDb250YWluZXIpLCBybmcuZW5kT2Zmc2V0KSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGFkdCQyID0gQWR0LmdlbmVyYXRlKFtcbiAgICAgIHsgYmVmb3JlOiBbJ2VsZW1lbnQnXSB9LFxuICAgICAge1xuICAgICAgICBvbjogW1xuICAgICAgICAgICdlbGVtZW50JyxcbiAgICAgICAgICAnb2Zmc2V0J1xuICAgICAgICBdXG4gICAgICB9LFxuICAgICAgeyBhZnRlcjogWydlbGVtZW50J10gfVxuICAgIF0pO1xuICAgIGNvbnN0IGNhdGEgPSAoc3ViamVjdCwgb25CZWZvcmUsIG9uT24sIG9uQWZ0ZXIpID0+IHN1YmplY3QuZm9sZChvbkJlZm9yZSwgb25Pbiwgb25BZnRlcik7XG4gICAgY29uc3QgZ2V0U3RhcnQkMiA9IHNpdHUgPT4gc2l0dS5mb2xkKGlkZW50aXR5LCBpZGVudGl0eSwgaWRlbnRpdHkpO1xuICAgIGNvbnN0IGJlZm9yZSQxID0gYWR0JDIuYmVmb3JlO1xuICAgIGNvbnN0IG9uID0gYWR0JDIub247XG4gICAgY29uc3QgYWZ0ZXIkMSA9IGFkdCQyLmFmdGVyO1xuICAgIGNvbnN0IFNpdHUgPSB7XG4gICAgICBiZWZvcmU6IGJlZm9yZSQxLFxuICAgICAgb24sXG4gICAgICBhZnRlcjogYWZ0ZXIkMSxcbiAgICAgIGNhdGEsXG4gICAgICBnZXRTdGFydDogZ2V0U3RhcnQkMlxuICAgIH07XG5cbiAgICBjb25zdCBhZHQkMSA9IEFkdC5nZW5lcmF0ZShbXG4gICAgICB7IGRvbVJhbmdlOiBbJ3JuZyddIH0sXG4gICAgICB7XG4gICAgICAgIHJlbGF0aXZlOiBbXG4gICAgICAgICAgJ3N0YXJ0U2l0dScsXG4gICAgICAgICAgJ2ZpbmlzaFNpdHUnXG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGV4YWN0OiBbXG4gICAgICAgICAgJ3N0YXJ0JyxcbiAgICAgICAgICAnc29mZnNldCcsXG4gICAgICAgICAgJ2ZpbmlzaCcsXG4gICAgICAgICAgJ2ZvZmZzZXQnXG4gICAgICAgIF1cbiAgICAgIH1cbiAgICBdKTtcbiAgICBjb25zdCBleGFjdEZyb21SYW5nZSA9IHNpbVJhbmdlID0+IGFkdCQxLmV4YWN0KHNpbVJhbmdlLnN0YXJ0LCBzaW1SYW5nZS5zb2Zmc2V0LCBzaW1SYW5nZS5maW5pc2gsIHNpbVJhbmdlLmZvZmZzZXQpO1xuICAgIGNvbnN0IGdldFN0YXJ0JDEgPSBzZWxlY3Rpb24gPT4gc2VsZWN0aW9uLm1hdGNoKHtcbiAgICAgIGRvbVJhbmdlOiBybmcgPT4gU3VnYXJFbGVtZW50LmZyb21Eb20ocm5nLnN0YXJ0Q29udGFpbmVyKSxcbiAgICAgIHJlbGF0aXZlOiAoc3RhcnRTaXR1LCBfZmluaXNoU2l0dSkgPT4gU2l0dS5nZXRTdGFydChzdGFydFNpdHUpLFxuICAgICAgZXhhY3Q6IChzdGFydCwgX3NvZmZzZXQsIF9maW5pc2gsIF9mb2Zmc2V0KSA9PiBzdGFydFxuICAgIH0pO1xuICAgIGNvbnN0IGRvbVJhbmdlID0gYWR0JDEuZG9tUmFuZ2U7XG4gICAgY29uc3QgcmVsYXRpdmUgPSBhZHQkMS5yZWxhdGl2ZTtcbiAgICBjb25zdCBleGFjdCA9IGFkdCQxLmV4YWN0O1xuICAgIGNvbnN0IGdldFdpbiA9IHNlbGVjdGlvbiA9PiB7XG4gICAgICBjb25zdCBzdGFydCA9IGdldFN0YXJ0JDEoc2VsZWN0aW9uKTtcbiAgICAgIHJldHVybiBkZWZhdWx0VmlldyhzdGFydCk7XG4gICAgfTtcbiAgICBjb25zdCByYW5nZSA9IFNpbVJhbmdlLmNyZWF0ZTtcbiAgICBjb25zdCBTaW1TZWxlY3Rpb24gPSB7XG4gICAgICBkb21SYW5nZSxcbiAgICAgIHJlbGF0aXZlLFxuICAgICAgZXhhY3QsXG4gICAgICBleGFjdEZyb21SYW5nZSxcbiAgICAgIGdldFdpbixcbiAgICAgIHJhbmdlXG4gICAgfTtcblxuICAgIGNvbnN0IGJlZm9yZVNwZWNpYWwgPSAoZWxlbWVudCwgb2Zmc2V0KSA9PiB7XG4gICAgICBjb25zdCBuYW1lJDEgPSBuYW1lKGVsZW1lbnQpO1xuICAgICAgaWYgKCdpbnB1dCcgPT09IG5hbWUkMSkge1xuICAgICAgICByZXR1cm4gU2l0dS5hZnRlcihlbGVtZW50KTtcbiAgICAgIH0gZWxzZSBpZiAoIWNvbnRhaW5zJDIoW1xuICAgICAgICAgICdicicsXG4gICAgICAgICAgJ2ltZydcbiAgICAgICAgXSwgbmFtZSQxKSkge1xuICAgICAgICByZXR1cm4gU2l0dS5vbihlbGVtZW50LCBvZmZzZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG9mZnNldCA9PT0gMCA/IFNpdHUuYmVmb3JlKGVsZW1lbnQpIDogU2l0dS5hZnRlcihlbGVtZW50KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHByZXByb2Nlc3NSZWxhdGl2ZSA9IChzdGFydFNpdHUsIGZpbmlzaFNpdHUpID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gc3RhcnRTaXR1LmZvbGQoU2l0dS5iZWZvcmUsIGJlZm9yZVNwZWNpYWwsIFNpdHUuYWZ0ZXIpO1xuICAgICAgY29uc3QgZmluaXNoID0gZmluaXNoU2l0dS5mb2xkKFNpdHUuYmVmb3JlLCBiZWZvcmVTcGVjaWFsLCBTaXR1LmFmdGVyKTtcbiAgICAgIHJldHVybiBTaW1TZWxlY3Rpb24ucmVsYXRpdmUoc3RhcnQsIGZpbmlzaCk7XG4gICAgfTtcbiAgICBjb25zdCBwcmVwcm9jZXNzRXhhY3QgPSAoc3RhcnQsIHNvZmZzZXQsIGZpbmlzaCwgZm9mZnNldCkgPT4ge1xuICAgICAgY29uc3Qgc3RhcnRTaXR1ID0gYmVmb3JlU3BlY2lhbChzdGFydCwgc29mZnNldCk7XG4gICAgICBjb25zdCBmaW5pc2hTaXR1ID0gYmVmb3JlU3BlY2lhbChmaW5pc2gsIGZvZmZzZXQpO1xuICAgICAgcmV0dXJuIFNpbVNlbGVjdGlvbi5yZWxhdGl2ZShzdGFydFNpdHUsIGZpbmlzaFNpdHUpO1xuICAgIH07XG4gICAgY29uc3QgcHJlcHJvY2VzcyA9IHNlbGVjdGlvbiA9PiBzZWxlY3Rpb24ubWF0Y2goe1xuICAgICAgZG9tUmFuZ2U6IHJuZyA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gU3VnYXJFbGVtZW50LmZyb21Eb20ocm5nLnN0YXJ0Q29udGFpbmVyKTtcbiAgICAgICAgY29uc3QgZmluaXNoID0gU3VnYXJFbGVtZW50LmZyb21Eb20ocm5nLmVuZENvbnRhaW5lcik7XG4gICAgICAgIHJldHVybiBwcmVwcm9jZXNzRXhhY3Qoc3RhcnQsIHJuZy5zdGFydE9mZnNldCwgZmluaXNoLCBybmcuZW5kT2Zmc2V0KTtcbiAgICAgIH0sXG4gICAgICByZWxhdGl2ZTogcHJlcHJvY2Vzc1JlbGF0aXZlLFxuICAgICAgZXhhY3Q6IHByZXByb2Nlc3NFeGFjdFxuICAgIH0pO1xuXG4gICAgY29uc3QgZnJvbUVsZW1lbnRzID0gKGVsZW1lbnRzLCBzY29wZSkgPT4ge1xuICAgICAgY29uc3QgZG9jID0gc2NvcGUgfHwgZG9jdW1lbnQ7XG4gICAgICBjb25zdCBmcmFnbWVudCA9IGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICBlYWNoJGcoZWxlbWVudHMsIGVsZW1lbnQgPT4ge1xuICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChlbGVtZW50LmRvbSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBTdWdhckVsZW1lbnQuZnJvbURvbShmcmFnbWVudCk7XG4gICAgfTtcblxuICAgIGNvbnN0IHRvTmF0aXZlID0gc2VsZWN0aW9uID0+IHtcbiAgICAgIGNvbnN0IHdpbiA9IFNpbVNlbGVjdGlvbi5nZXRXaW4oc2VsZWN0aW9uKS5kb207XG4gICAgICBjb25zdCBnZXREb21SYW5nZSA9IChzdGFydCwgc29mZnNldCwgZmluaXNoLCBmb2Zmc2V0KSA9PiBleGFjdFRvTmF0aXZlKHdpbiwgc3RhcnQsIHNvZmZzZXQsIGZpbmlzaCwgZm9mZnNldCk7XG4gICAgICBjb25zdCBmaWx0ZXJlZCA9IHByZXByb2Nlc3Moc2VsZWN0aW9uKTtcbiAgICAgIHJldHVybiBkaWFnbm9zZSh3aW4sIGZpbHRlcmVkKS5tYXRjaCh7XG4gICAgICAgIGx0cjogZ2V0RG9tUmFuZ2UsXG4gICAgICAgIHJ0bDogZ2V0RG9tUmFuZ2VcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgZ2V0QXRQb2ludCA9ICh3aW4sIHgsIHkpID0+IGZyb21Qb2ludCQxKHdpbiwgeCwgeSk7XG5cbiAgICBjb25zdCBmcm9tUG9pbnQgPSAoY2xpZW50WCwgY2xpZW50WSwgZG9jKSA9PiBnZXRBdFBvaW50KGRvYy5kZWZhdWx0VmlldywgY2xpZW50WCwgY2xpZW50WSkubWFwKHNpbVJhbmdlID0+IHtcbiAgICAgIGNvbnN0IHJuZyA9IGRvYy5jcmVhdGVSYW5nZSgpO1xuICAgICAgcm5nLnNldFN0YXJ0KHNpbVJhbmdlLnN0YXJ0LmRvbSwgc2ltUmFuZ2Uuc29mZnNldCk7XG4gICAgICBybmcuc2V0RW5kKHNpbVJhbmdlLmZpbmlzaC5kb20sIHNpbVJhbmdlLmZvZmZzZXQpO1xuICAgICAgcmV0dXJuIHJuZztcbiAgICB9KS5nZXRPclVuZGVmaW5lZCgpO1xuXG4gICAgY29uc3QgaXNFcSQ0ID0gKHJuZzEsIHJuZzIpID0+IHtcbiAgICAgIHJldHVybiBybmcxICYmIHJuZzIgJiYgKHJuZzEuc3RhcnRDb250YWluZXIgPT09IHJuZzIuc3RhcnRDb250YWluZXIgJiYgcm5nMS5zdGFydE9mZnNldCA9PT0gcm5nMi5zdGFydE9mZnNldCkgJiYgKHJuZzEuZW5kQ29udGFpbmVyID09PSBybmcyLmVuZENvbnRhaW5lciAmJiBybmcxLmVuZE9mZnNldCA9PT0gcm5nMi5lbmRPZmZzZXQpO1xuICAgIH07XG5cbiAgICBjb25zdCBmaW5kUGFyZW50ID0gKG5vZGUsIHJvb3ROb2RlLCBwcmVkaWNhdGUpID0+IHtcbiAgICAgIHdoaWxlIChub2RlICYmIG5vZGUgIT09IHJvb3ROb2RlKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUobm9kZSkpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBjb25zdCBoYXNQYXJlbnQkMSA9IChub2RlLCByb290Tm9kZSwgcHJlZGljYXRlKSA9PiBmaW5kUGFyZW50KG5vZGUsIHJvb3ROb2RlLCBwcmVkaWNhdGUpICE9PSBudWxsO1xuICAgIGNvbnN0IGhhc1BhcmVudFdpdGhOYW1lID0gKG5vZGUsIHJvb3ROb2RlLCBuYW1lKSA9PiBoYXNQYXJlbnQkMShub2RlLCByb290Tm9kZSwgbm9kZSA9PiB7XG4gICAgICByZXR1cm4gbm9kZS5ub2RlTmFtZSA9PT0gbmFtZTtcbiAgICB9KTtcbiAgICBjb25zdCBpc1RhYmxlID0gbm9kZSA9PiBub2RlICYmIG5vZGUubm9kZU5hbWUgPT09ICdUQUJMRSc7XG4gICAgY29uc3QgaXNUYWJsZUNlbGwkMiA9IG5vZGUgPT4gbm9kZSAmJiAvXihURHxUSHxDQVBUSU9OKSQvLnRlc3Qobm9kZS5ub2RlTmFtZSk7XG4gICAgY29uc3QgaXNDZUZhbHNlQ2FyZXRDb250YWluZXIgPSAobm9kZSwgcm9vdE5vZGUpID0+IGlzQ2FyZXRDb250YWluZXIkMihub2RlKSAmJiBoYXNQYXJlbnQkMShub2RlLCByb290Tm9kZSwgaXNDYXJldE5vZGUpID09PSBmYWxzZTtcbiAgICBjb25zdCBoYXNCckJlZm9yZUFmdGVyID0gKGRvbSwgbm9kZSwgbGVmdCkgPT4ge1xuICAgICAgY29uc3Qgd2Fsa2VyID0gbmV3IERvbVRyZWVXYWxrZXIobm9kZSwgZG9tLmdldFBhcmVudChub2RlLnBhcmVudE5vZGUsIGRvbS5pc0Jsb2NrKSB8fCBkb20uZ2V0Um9vdCgpKTtcbiAgICAgIHdoaWxlIChub2RlID0gd2Fsa2VyW2xlZnQgPyAncHJldicgOiAnbmV4dCddKCkpIHtcbiAgICAgICAgaWYgKGlzQnIkNShub2RlKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBpc1ByZXZOb2RlID0gKG5vZGUsIG5hbWUpID0+IG5vZGUucHJldmlvdXNTaWJsaW5nICYmIG5vZGUucHJldmlvdXNTaWJsaW5nLm5vZGVOYW1lID09PSBuYW1lO1xuICAgIGNvbnN0IGhhc0NvbnRlbnRFZGl0YWJsZUZhbHNlUGFyZW50ID0gKGJvZHksIG5vZGUpID0+IHtcbiAgICAgIHdoaWxlIChub2RlICYmIG5vZGUgIT09IGJvZHkpIHtcbiAgICAgICAgaWYgKGlzQ29udGVudEVkaXRhYmxlRmFsc2UkYShub2RlKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBjb25zdCBmaW5kVGV4dE5vZGVSZWxhdGl2ZSA9IChkb20sIGlzQWZ0ZXJOb2RlLCBjb2xsYXBzZWQsIGxlZnQsIHN0YXJ0Tm9kZSkgPT4ge1xuICAgICAgbGV0IGxhc3RJbmxpbmVFbGVtZW50O1xuICAgICAgY29uc3QgYm9keSA9IGRvbS5nZXRSb290KCk7XG4gICAgICBsZXQgbm9kZTtcbiAgICAgIGNvbnN0IG5vbkVtcHR5RWxlbWVudHNNYXAgPSBkb20uc2NoZW1hLmdldE5vbkVtcHR5RWxlbWVudHMoKTtcbiAgICAgIGNvbnN0IHBhcmVudEJsb2NrQ29udGFpbmVyID0gZG9tLmdldFBhcmVudChzdGFydE5vZGUucGFyZW50Tm9kZSwgZG9tLmlzQmxvY2spIHx8IGJvZHk7XG4gICAgICBpZiAobGVmdCAmJiBpc0JyJDUoc3RhcnROb2RlKSAmJiBpc0FmdGVyTm9kZSAmJiBkb20uaXNFbXB0eShwYXJlbnRCbG9ja0NvbnRhaW5lcikpIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoQ2FyZXRQb3NpdGlvbihzdGFydE5vZGUucGFyZW50Tm9kZSwgZG9tLm5vZGVJbmRleChzdGFydE5vZGUpKSk7XG4gICAgICB9XG4gICAgICBjb25zdCB3YWxrZXIgPSBuZXcgRG9tVHJlZVdhbGtlcihzdGFydE5vZGUsIHBhcmVudEJsb2NrQ29udGFpbmVyKTtcbiAgICAgIHdoaWxlIChub2RlID0gd2Fsa2VyW2xlZnQgPyAncHJldicgOiAnbmV4dCddKCkpIHtcbiAgICAgICAgaWYgKGRvbS5nZXRDb250ZW50RWRpdGFibGVQYXJlbnQobm9kZSkgPT09ICdmYWxzZScgfHwgaXNDZUZhbHNlQ2FyZXRDb250YWluZXIobm9kZSwgYm9keSkpIHtcbiAgICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1RleHQkOChub2RlKSAmJiBub2RlLm5vZGVWYWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgaWYgKGhhc1BhcmVudFdpdGhOYW1lKG5vZGUsIGJvZHksICdBJykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZShDYXJldFBvc2l0aW9uKG5vZGUsIGxlZnQgPyBub2RlLm5vZGVWYWx1ZS5sZW5ndGggOiAwKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRvbS5pc0Jsb2NrKG5vZGUpIHx8IG5vbkVtcHR5RWxlbWVudHNNYXBbbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpXSkge1xuICAgICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdElubGluZUVsZW1lbnQgPSBub2RlO1xuICAgICAgfVxuICAgICAgaWYgKGNvbGxhcHNlZCAmJiBsYXN0SW5saW5lRWxlbWVudCkge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZShDYXJldFBvc2l0aW9uKGxhc3RJbmxpbmVFbGVtZW50LCAwKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgIH07XG4gICAgY29uc3Qgbm9ybWFsaXplRW5kUG9pbnQgPSAoZG9tLCBjb2xsYXBzZWQsIHN0YXJ0LCBybmcpID0+IHtcbiAgICAgIGxldCBjb250YWluZXIsIG9mZnNldDtcbiAgICAgIGNvbnN0IGJvZHkgPSBkb20uZ2V0Um9vdCgpO1xuICAgICAgbGV0IG5vZGU7XG4gICAgICBsZXQgZGlyZWN0aW9uTGVmdCwgbm9ybWFsaXplZCA9IGZhbHNlO1xuICAgICAgY29udGFpbmVyID0gcm5nWyhzdGFydCA/ICdzdGFydCcgOiAnZW5kJykgKyAnQ29udGFpbmVyJ107XG4gICAgICBvZmZzZXQgPSBybmdbKHN0YXJ0ID8gJ3N0YXJ0JyA6ICdlbmQnKSArICdPZmZzZXQnXTtcbiAgICAgIGNvbnN0IGlzQWZ0ZXJOb2RlID0gaXNFbGVtZW50JDYoY29udGFpbmVyKSAmJiBvZmZzZXQgPT09IGNvbnRhaW5lci5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgICAgIGNvbnN0IG5vbkVtcHR5RWxlbWVudHNNYXAgPSBkb20uc2NoZW1hLmdldE5vbkVtcHR5RWxlbWVudHMoKTtcbiAgICAgIGRpcmVjdGlvbkxlZnQgPSBzdGFydDtcbiAgICAgIGlmIChpc0NhcmV0Q29udGFpbmVyJDIoY29udGFpbmVyKSkge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgfVxuICAgICAgaWYgKGlzRWxlbWVudCQ2KGNvbnRhaW5lcikgJiYgb2Zmc2V0ID4gY29udGFpbmVyLmNoaWxkTm9kZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICBkaXJlY3Rpb25MZWZ0ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoaXNEb2N1bWVudCQxKGNvbnRhaW5lcikpIHtcbiAgICAgICAgY29udGFpbmVyID0gYm9keTtcbiAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChjb250YWluZXIgPT09IGJvZHkpIHtcbiAgICAgICAgaWYgKGRpcmVjdGlvbkxlZnQpIHtcbiAgICAgICAgICBub2RlID0gY29udGFpbmVyLmNoaWxkTm9kZXNbb2Zmc2V0ID4gMCA/IG9mZnNldCAtIDEgOiAwXTtcbiAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgaWYgKGlzQ2FyZXRDb250YWluZXIkMihub2RlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vbkVtcHR5RWxlbWVudHNNYXBbbm9kZS5ub2RlTmFtZV0gfHwgaXNUYWJsZShub2RlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGFpbmVyLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgIG9mZnNldCA9IE1hdGgubWluKCFkaXJlY3Rpb25MZWZ0ICYmIG9mZnNldCA+IDAgPyBvZmZzZXQgLSAxIDogb2Zmc2V0LCBjb250YWluZXIuY2hpbGROb2Rlcy5sZW5ndGggLSAxKTtcbiAgICAgICAgICBjb250YWluZXIgPSBjb250YWluZXIuY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgICAgICAgIG9mZnNldCA9IGlzVGV4dCQ4KGNvbnRhaW5lcikgJiYgaXNBZnRlck5vZGUgPyBjb250YWluZXIuZGF0YS5sZW5ndGggOiAwO1xuICAgICAgICAgIGlmICghY29sbGFwc2VkICYmIGNvbnRhaW5lciA9PT0gYm9keS5sYXN0Q2hpbGQgJiYgaXNUYWJsZShjb250YWluZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGFzQ29udGVudEVkaXRhYmxlRmFsc2VQYXJlbnQoYm9keSwgY29udGFpbmVyKSB8fCBpc0NhcmV0Q29udGFpbmVyJDIoY29udGFpbmVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvbnRhaW5lci5oYXNDaGlsZE5vZGVzKCkgJiYgaXNUYWJsZShjb250YWluZXIpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgbm9kZSA9IGNvbnRhaW5lcjtcbiAgICAgICAgICAgIGNvbnN0IHdhbGtlciA9IG5ldyBEb21UcmVlV2Fsa2VyKGNvbnRhaW5lciwgYm9keSk7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIGlmIChpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJGEobm9kZSkgfHwgaXNDYXJldENvbnRhaW5lciQyKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpc1RleHQkOChub2RlKSAmJiBub2RlLm5vZGVWYWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gZGlyZWN0aW9uTGVmdCA/IDAgOiBub2RlLm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyID0gbm9kZTtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobm9uRW1wdHlFbGVtZW50c01hcFtub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCldICYmICFpc1RhYmxlQ2VsbCQyKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gZG9tLm5vZGVJbmRleChub2RlKTtcbiAgICAgICAgICAgICAgICBjb250YWluZXIgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKCFkaXJlY3Rpb25MZWZ0KSB7XG4gICAgICAgICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKG5vZGUgPSBkaXJlY3Rpb25MZWZ0ID8gd2Fsa2VyLm5leHQoKSA6IHdhbGtlci5wcmV2KCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNvbGxhcHNlZCkge1xuICAgICAgICBpZiAoaXNUZXh0JDgoY29udGFpbmVyKSAmJiBvZmZzZXQgPT09IDApIHtcbiAgICAgICAgICBmaW5kVGV4dE5vZGVSZWxhdGl2ZShkb20sIGlzQWZ0ZXJOb2RlLCBjb2xsYXBzZWQsIHRydWUsIGNvbnRhaW5lcikuZWFjaChwb3MgPT4ge1xuICAgICAgICAgICAgY29udGFpbmVyID0gcG9zLmNvbnRhaW5lcigpO1xuICAgICAgICAgICAgb2Zmc2V0ID0gcG9zLm9mZnNldCgpO1xuICAgICAgICAgICAgbm9ybWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRWxlbWVudCQ2KGNvbnRhaW5lcikpIHtcbiAgICAgICAgICBub2RlID0gY29udGFpbmVyLmNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgIG5vZGUgPSBjb250YWluZXIuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5vZGUgJiYgaXNCciQ1KG5vZGUpICYmICFpc1ByZXZOb2RlKG5vZGUsICdBJykgJiYgIWhhc0JyQmVmb3JlQWZ0ZXIoZG9tLCBub2RlLCBmYWxzZSkgJiYgIWhhc0JyQmVmb3JlQWZ0ZXIoZG9tLCBub2RlLCB0cnVlKSkge1xuICAgICAgICAgICAgZmluZFRleHROb2RlUmVsYXRpdmUoZG9tLCBpc0FmdGVyTm9kZSwgY29sbGFwc2VkLCB0cnVlLCBub2RlKS5lYWNoKHBvcyA9PiB7XG4gICAgICAgICAgICAgIGNvbnRhaW5lciA9IHBvcy5jb250YWluZXIoKTtcbiAgICAgICAgICAgICAgb2Zmc2V0ID0gcG9zLm9mZnNldCgpO1xuICAgICAgICAgICAgICBub3JtYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRpcmVjdGlvbkxlZnQgJiYgIWNvbGxhcHNlZCAmJiBpc1RleHQkOChjb250YWluZXIpICYmIG9mZnNldCA9PT0gY29udGFpbmVyLm5vZGVWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgZmluZFRleHROb2RlUmVsYXRpdmUoZG9tLCBpc0FmdGVyTm9kZSwgY29sbGFwc2VkLCBmYWxzZSwgY29udGFpbmVyKS5lYWNoKHBvcyA9PiB7XG4gICAgICAgICAgY29udGFpbmVyID0gcG9zLmNvbnRhaW5lcigpO1xuICAgICAgICAgIG9mZnNldCA9IHBvcy5vZmZzZXQoKTtcbiAgICAgICAgICBub3JtYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9ybWFsaXplZCA/IE9wdGlvbmFsLnNvbWUoQ2FyZXRQb3NpdGlvbihjb250YWluZXIsIG9mZnNldCkpIDogT3B0aW9uYWwubm9uZSgpO1xuICAgIH07XG4gICAgY29uc3Qgbm9ybWFsaXplJDIgPSAoZG9tLCBybmcpID0+IHtcbiAgICAgIGNvbnN0IGNvbGxhcHNlZCA9IHJuZy5jb2xsYXBzZWQsIG5vcm1SbmcgPSBybmcuY2xvbmVSYW5nZSgpO1xuICAgICAgY29uc3Qgc3RhcnRQb3MgPSBDYXJldFBvc2l0aW9uLmZyb21SYW5nZVN0YXJ0KHJuZyk7XG4gICAgICBub3JtYWxpemVFbmRQb2ludChkb20sIGNvbGxhcHNlZCwgdHJ1ZSwgbm9ybVJuZykuZWFjaChwb3MgPT4ge1xuICAgICAgICBpZiAoIWNvbGxhcHNlZCB8fCAhQ2FyZXRQb3NpdGlvbi5pc0Fib3ZlKHN0YXJ0UG9zLCBwb3MpKSB7XG4gICAgICAgICAgbm9ybVJuZy5zZXRTdGFydChwb3MuY29udGFpbmVyKCksIHBvcy5vZmZzZXQoKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKCFjb2xsYXBzZWQpIHtcbiAgICAgICAgbm9ybWFsaXplRW5kUG9pbnQoZG9tLCBjb2xsYXBzZWQsIGZhbHNlLCBub3JtUm5nKS5lYWNoKHBvcyA9PiB7XG4gICAgICAgICAgbm9ybVJuZy5zZXRFbmQocG9zLmNvbnRhaW5lcigpLCBwb3Mub2Zmc2V0KCkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChjb2xsYXBzZWQpIHtcbiAgICAgICAgbm9ybVJuZy5jb2xsYXBzZSh0cnVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0VxJDQocm5nLCBub3JtUm5nKSA/IE9wdGlvbmFsLm5vbmUoKSA6IE9wdGlvbmFsLnNvbWUobm9ybVJuZyk7XG4gICAgfTtcblxuICAgIGNvbnN0IHNwbGl0VGV4dCA9IChub2RlLCBvZmZzZXQpID0+IHtcbiAgICAgIHJldHVybiBub2RlLnNwbGl0VGV4dChvZmZzZXQpO1xuICAgIH07XG4gICAgY29uc3Qgc3BsaXQgPSBybmcgPT4ge1xuICAgICAgbGV0IHN0YXJ0Q29udGFpbmVyID0gcm5nLnN0YXJ0Q29udGFpbmVyLCBzdGFydE9mZnNldCA9IHJuZy5zdGFydE9mZnNldCwgZW5kQ29udGFpbmVyID0gcm5nLmVuZENvbnRhaW5lciwgZW5kT2Zmc2V0ID0gcm5nLmVuZE9mZnNldDtcbiAgICAgIGlmIChzdGFydENvbnRhaW5lciA9PT0gZW5kQ29udGFpbmVyICYmIGlzVGV4dCQ4KHN0YXJ0Q29udGFpbmVyKSkge1xuICAgICAgICBpZiAoc3RhcnRPZmZzZXQgPiAwICYmIHN0YXJ0T2Zmc2V0IDwgc3RhcnRDb250YWluZXIubm9kZVZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgIGVuZENvbnRhaW5lciA9IHNwbGl0VGV4dChzdGFydENvbnRhaW5lciwgc3RhcnRPZmZzZXQpO1xuICAgICAgICAgIHN0YXJ0Q29udGFpbmVyID0gZW5kQ29udGFpbmVyLnByZXZpb3VzU2libGluZztcbiAgICAgICAgICBpZiAoZW5kT2Zmc2V0ID4gc3RhcnRPZmZzZXQpIHtcbiAgICAgICAgICAgIGVuZE9mZnNldCA9IGVuZE9mZnNldCAtIHN0YXJ0T2Zmc2V0O1xuICAgICAgICAgICAgc3RhcnRDb250YWluZXIgPSBlbmRDb250YWluZXIgPSBzcGxpdFRleHQoZW5kQ29udGFpbmVyLCBlbmRPZmZzZXQpLnByZXZpb3VzU2libGluZztcbiAgICAgICAgICAgIGVuZE9mZnNldCA9IGVuZENvbnRhaW5lci5ub2RlVmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgc3RhcnRPZmZzZXQgPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbmRPZmZzZXQgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzVGV4dCQ4KHN0YXJ0Q29udGFpbmVyKSAmJiBzdGFydE9mZnNldCA+IDAgJiYgc3RhcnRPZmZzZXQgPCBzdGFydENvbnRhaW5lci5ub2RlVmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgc3RhcnRDb250YWluZXIgPSBzcGxpdFRleHQoc3RhcnRDb250YWluZXIsIHN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgICBzdGFydE9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVGV4dCQ4KGVuZENvbnRhaW5lcikgJiYgZW5kT2Zmc2V0ID4gMCAmJiBlbmRPZmZzZXQgPCBlbmRDb250YWluZXIubm9kZVZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgIGVuZENvbnRhaW5lciA9IHNwbGl0VGV4dChlbmRDb250YWluZXIsIGVuZE9mZnNldCkucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgIGVuZE9mZnNldCA9IGVuZENvbnRhaW5lci5ub2RlVmFsdWUubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGFydENvbnRhaW5lcixcbiAgICAgICAgc3RhcnRPZmZzZXQsXG4gICAgICAgIGVuZENvbnRhaW5lcixcbiAgICAgICAgZW5kT2Zmc2V0XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCBSYW5nZVV0aWxzID0gZG9tID0+IHtcbiAgICAgIGNvbnN0IHdhbGsgPSAocm5nLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICByZXR1cm4gd2FsayQzKGRvbSwgcm5nLCBjYWxsYmFjayk7XG4gICAgICB9O1xuICAgICAgY29uc3Qgc3BsaXQkMSA9IHNwbGl0O1xuICAgICAgY29uc3Qgbm9ybWFsaXplID0gcm5nID0+IHtcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZSQyKGRvbSwgcm5nKS5mb2xkKG5ldmVyLCBub3JtYWxpemVkUm5nID0+IHtcbiAgICAgICAgICBybmcuc2V0U3RhcnQobm9ybWFsaXplZFJuZy5zdGFydENvbnRhaW5lciwgbm9ybWFsaXplZFJuZy5zdGFydE9mZnNldCk7XG4gICAgICAgICAgcm5nLnNldEVuZChub3JtYWxpemVkUm5nLmVuZENvbnRhaW5lciwgbm9ybWFsaXplZFJuZy5lbmRPZmZzZXQpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3YWxrLFxuICAgICAgICBzcGxpdDogc3BsaXQkMSxcbiAgICAgICAgbm9ybWFsaXplXG4gICAgICB9O1xuICAgIH07XG4gICAgUmFuZ2VVdGlscy5jb21wYXJlUmFuZ2VzID0gaXNFcSQ0O1xuICAgIFJhbmdlVXRpbHMuZ2V0Q2FyZXRSYW5nZUZyb21Qb2ludCA9IGZyb21Qb2ludDtcbiAgICBSYW5nZVV0aWxzLmdldFNlbGVjdGVkTm9kZSA9IGdldFNlbGVjdGVkTm9kZTtcbiAgICBSYW5nZVV0aWxzLmdldE5vZGUgPSBnZXROb2RlJDE7XG5cbiAgICBjb25zdCBEaW1lbnNpb24gPSAobmFtZSwgZ2V0T2Zmc2V0KSA9PiB7XG4gICAgICBjb25zdCBzZXQgPSAoZWxlbWVudCwgaCkgPT4ge1xuICAgICAgICBpZiAoIWlzTnVtYmVyKGgpICYmICFoLm1hdGNoKC9eWzAtOV0rJC8pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG5hbWUgKyAnLnNldCBhY2NlcHRzIG9ubHkgcG9zaXRpdmUgaW50ZWdlciB2YWx1ZXMuIFZhbHVlIHdhcyAnICsgaCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZG9tID0gZWxlbWVudC5kb207XG4gICAgICAgIGlmIChpc1N1cHBvcnRlZCQxKGRvbSkpIHtcbiAgICAgICAgICBkb20uc3R5bGVbbmFtZV0gPSBoICsgJ3B4JztcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGdldCA9IGVsZW1lbnQgPT4ge1xuICAgICAgICBjb25zdCByID0gZ2V0T2Zmc2V0KGVsZW1lbnQpO1xuICAgICAgICBpZiAociA8PSAwIHx8IHIgPT09IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBjc3MgPSBnZXQkNyhlbGVtZW50LCBuYW1lKTtcbiAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChjc3MpIHx8IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgICB9O1xuICAgICAgY29uc3QgZ2V0T3V0ZXIgPSBnZXQ7XG4gICAgICBjb25zdCBhZ2dyZWdhdGUgPSAoZWxlbWVudCwgcHJvcGVydGllcykgPT4gZm9sZGwocHJvcGVydGllcywgKGFjYywgcHJvcGVydHkpID0+IHtcbiAgICAgICAgY29uc3QgdmFsID0gZ2V0JDcoZWxlbWVudCwgcHJvcGVydHkpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbCA9PT0gdW5kZWZpbmVkID8gMCA6IHBhcnNlSW50KHZhbCwgMTApO1xuICAgICAgICByZXR1cm4gaXNOYU4odmFsdWUpID8gYWNjIDogYWNjICsgdmFsdWU7XG4gICAgICB9LCAwKTtcbiAgICAgIGNvbnN0IG1heCA9IChlbGVtZW50LCB2YWx1ZSwgcHJvcGVydGllcykgPT4ge1xuICAgICAgICBjb25zdCBjdW11bGF0aXZlSW5jbHVzaW9ucyA9IGFnZ3JlZ2F0ZShlbGVtZW50LCBwcm9wZXJ0aWVzKTtcbiAgICAgICAgY29uc3QgYWJzb2x1dGVNYXggPSB2YWx1ZSA+IGN1bXVsYXRpdmVJbmNsdXNpb25zID8gdmFsdWUgLSBjdW11bGF0aXZlSW5jbHVzaW9ucyA6IDA7XG4gICAgICAgIHJldHVybiBhYnNvbHV0ZU1heDtcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzZXQsXG4gICAgICAgIGdldCxcbiAgICAgICAgZ2V0T3V0ZXIsXG4gICAgICAgIGFnZ3JlZ2F0ZSxcbiAgICAgICAgbWF4XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCBhcGkgPSBEaW1lbnNpb24oJ2hlaWdodCcsIGVsZW1lbnQgPT4ge1xuICAgICAgY29uc3QgZG9tID0gZWxlbWVudC5kb207XG4gICAgICByZXR1cm4gaW5Cb2R5KGVsZW1lbnQpID8gZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCA6IGRvbS5vZmZzZXRIZWlnaHQ7XG4gICAgfSk7XG4gICAgY29uc3QgZ2V0JDIgPSBlbGVtZW50ID0+IGFwaS5nZXQoZWxlbWVudCk7XG5cbiAgICBjb25zdCBnZXREb2N1bWVudCA9ICgpID0+IFN1Z2FyRWxlbWVudC5mcm9tRG9tKGRvY3VtZW50KTtcblxuICAgIGNvbnN0IHdhbGtVcCA9IChuYXZpZ2F0aW9uLCBkb2MpID0+IHtcbiAgICAgIGNvbnN0IGZyYW1lID0gbmF2aWdhdGlvbi52aWV3KGRvYyk7XG4gICAgICByZXR1cm4gZnJhbWUuZm9sZChjb25zdGFudChbXSksIGYgPT4ge1xuICAgICAgICBjb25zdCBwYXJlbnQgPSBuYXZpZ2F0aW9uLm93bmVyKGYpO1xuICAgICAgICBjb25zdCByZXN0ID0gd2Fsa1VwKG5hdmlnYXRpb24sIHBhcmVudCk7XG4gICAgICAgIHJldHVybiBbZl0uY29uY2F0KHJlc3QpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBwYXRoVG8gPSAoZWxlbWVudCwgbmF2aWdhdGlvbikgPT4ge1xuICAgICAgY29uc3QgZCA9IG5hdmlnYXRpb24ub3duZXIoZWxlbWVudCk7XG4gICAgICByZXR1cm4gd2Fsa1VwKG5hdmlnYXRpb24sIGQpO1xuICAgIH07XG5cbiAgICBjb25zdCB2aWV3ID0gZG9jID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBkb2MuZG9tID09PSBkb2N1bWVudCA/IE9wdGlvbmFsLm5vbmUoKSA6IE9wdGlvbmFsLmZyb20oKF9hID0gZG9jLmRvbS5kZWZhdWx0VmlldykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZyYW1lRWxlbWVudCk7XG4gICAgICByZXR1cm4gZWxlbWVudC5tYXAoU3VnYXJFbGVtZW50LmZyb21Eb20pO1xuICAgIH07XG4gICAgY29uc3Qgb3duZXIgPSBlbGVtZW50ID0+IGRvY3VtZW50T3JPd25lcihlbGVtZW50KTtcblxuICAgIHZhciBOYXZpZ2F0aW9uID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgICAgICBfX3Byb3RvX186IG51bGwsXG4gICAgICAgIHZpZXc6IHZpZXcsXG4gICAgICAgIG93bmVyOiBvd25lclxuICAgIH0pO1xuXG4gICAgY29uc3QgZmluZCA9IGVsZW1lbnQgPT4ge1xuICAgICAgY29uc3QgZG9jID0gZ2V0RG9jdW1lbnQoKTtcbiAgICAgIGNvbnN0IHNjcm9sbCA9IGdldCQ1KGRvYyk7XG4gICAgICBjb25zdCBmcmFtZXMgPSBwYXRoVG8oZWxlbWVudCwgTmF2aWdhdGlvbik7XG4gICAgICBjb25zdCBvZmZzZXQgPSB2aWV3cG9ydChlbGVtZW50KTtcbiAgICAgIGNvbnN0IHIgPSBmb2xkcihmcmFtZXMsIChiLCBhKSA9PiB7XG4gICAgICAgIGNvbnN0IGxvYyA9IHZpZXdwb3J0KGEpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxlZnQ6IGIubGVmdCArIGxvYy5sZWZ0LFxuICAgICAgICAgIHRvcDogYi50b3AgKyBsb2MudG9wXG4gICAgICAgIH07XG4gICAgICB9LCB7XG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIHRvcDogMFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gU3VnYXJQb3NpdGlvbihyLmxlZnQgKyBvZmZzZXQubGVmdCArIHNjcm9sbC5sZWZ0LCByLnRvcCArIG9mZnNldC50b3AgKyBzY3JvbGwudG9wKTtcbiAgICB9O1xuXG4gICAgY29uc3QgZXhjbHVkZUZyb21EZXNjZW5kID0gZWxlbWVudCA9PiBuYW1lKGVsZW1lbnQpID09PSAndGV4dGFyZWEnO1xuICAgIGNvbnN0IGZpcmVTY3JvbGxJbnRvVmlld0V2ZW50ID0gKGVkaXRvciwgZGF0YSkgPT4ge1xuICAgICAgY29uc3Qgc2Nyb2xsRXZlbnQgPSBlZGl0b3IuZGlzcGF0Y2goJ1Njcm9sbEludG9WaWV3JywgZGF0YSk7XG4gICAgICByZXR1cm4gc2Nyb2xsRXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCk7XG4gICAgfTtcbiAgICBjb25zdCBmaXJlQWZ0ZXJTY3JvbGxJbnRvVmlld0V2ZW50ID0gKGVkaXRvciwgZGF0YSkgPT4ge1xuICAgICAgZWRpdG9yLmRpc3BhdGNoKCdBZnRlclNjcm9sbEludG9WaWV3JywgZGF0YSk7XG4gICAgfTtcbiAgICBjb25zdCBkZXNjZW5kID0gKGVsZW1lbnQsIG9mZnNldCkgPT4ge1xuICAgICAgY29uc3QgY2hpbGRyZW4kMSA9IGNoaWxkcmVuKGVsZW1lbnQpO1xuICAgICAgaWYgKGNoaWxkcmVuJDEubGVuZ3RoID09PSAwIHx8IGV4Y2x1ZGVGcm9tRGVzY2VuZChlbGVtZW50KSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgb2Zmc2V0XG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKG9mZnNldCA8IGNoaWxkcmVuJDEubGVuZ3RoICYmICFleGNsdWRlRnJvbURlc2NlbmQoY2hpbGRyZW4kMVtvZmZzZXRdKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGVsZW1lbnQ6IGNoaWxkcmVuJDFbb2Zmc2V0XSxcbiAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGxhc3QgPSBjaGlsZHJlbiQxW2NoaWxkcmVuJDEubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChleGNsdWRlRnJvbURlc2NlbmQobGFzdCkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICAgIG9mZnNldFxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG5hbWUobGFzdCkgPT09ICdpbWcnKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBlbGVtZW50OiBsYXN0LFxuICAgICAgICAgICAgICBvZmZzZXQ6IDFcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIGlmIChpc1RleHQkOShsYXN0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgZWxlbWVudDogbGFzdCxcbiAgICAgICAgICAgICAgb2Zmc2V0OiBnZXQkMyhsYXN0KS5sZW5ndGhcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGVsZW1lbnQ6IGxhc3QsXG4gICAgICAgICAgICAgIG9mZnNldDogY2hpbGRyZW4obGFzdCkubGVuZ3RoXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgbWFya2VySW5mbyA9IChlbGVtZW50LCBjbGVhbnVwRnVuKSA9PiB7XG4gICAgICBjb25zdCBwb3MgPSBhYnNvbHV0ZShlbGVtZW50KTtcbiAgICAgIGNvbnN0IGhlaWdodCA9IGdldCQyKGVsZW1lbnQpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZWxlbWVudCxcbiAgICAgICAgYm90dG9tOiBwb3MudG9wICsgaGVpZ2h0LFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIHBvcyxcbiAgICAgICAgY2xlYW51cDogY2xlYW51cEZ1blxuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IGNyZWF0ZU1hcmtlciQxID0gKGVsZW1lbnQsIG9mZnNldCkgPT4ge1xuICAgICAgY29uc3Qgc3RhcnRQb2ludCA9IGRlc2NlbmQoZWxlbWVudCwgb2Zmc2V0KTtcbiAgICAgIGNvbnN0IHNwYW4gPSBTdWdhckVsZW1lbnQuZnJvbUh0bWwoJzxzcGFuIGRhdGEtbWNlLWJvZ3VzPVwiYWxsXCIgc3R5bGU9XCJkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XCI+JyArIFpXU1AkMSArICc8L3NwYW4+Jyk7XG4gICAgICBiZWZvcmUkMyhzdGFydFBvaW50LmVsZW1lbnQsIHNwYW4pO1xuICAgICAgcmV0dXJuIG1hcmtlckluZm8oc3BhbiwgKCkgPT4gcmVtb3ZlJDUoc3BhbikpO1xuICAgIH07XG4gICAgY29uc3QgZWxlbWVudE1hcmtlciA9IGVsZW1lbnQgPT4gbWFya2VySW5mbyhTdWdhckVsZW1lbnQuZnJvbURvbShlbGVtZW50KSwgbm9vcCk7XG4gICAgY29uc3Qgd2l0aE1hcmtlciA9IChlZGl0b3IsIGYsIHJuZywgYWxpZ25Ub1RvcCkgPT4ge1xuICAgICAgcHJlc2VydmVXaXRoKGVkaXRvciwgKF9zLCBfZSkgPT4gYXBwbHlXaXRoTWFya2VyKGVkaXRvciwgZiwgcm5nLCBhbGlnblRvVG9wKSwgcm5nKTtcbiAgICB9O1xuICAgIGNvbnN0IHdpdGhTY3JvbGxFdmVudHMgPSAoZWRpdG9yLCBkb2MsIGYsIG1hcmtlciwgYWxpZ25Ub1RvcCkgPT4ge1xuICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgZWxtOiBtYXJrZXIuZWxlbWVudC5kb20sXG4gICAgICAgIGFsaWduVG9Ub3BcbiAgICAgIH07XG4gICAgICBpZiAoZmlyZVNjcm9sbEludG9WaWV3RXZlbnQoZWRpdG9yLCBkYXRhKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBzY3JvbGxUb3AgPSBnZXQkNShkb2MpLnRvcDtcbiAgICAgIGYoZG9jLCBzY3JvbGxUb3AsIG1hcmtlciwgYWxpZ25Ub1RvcCk7XG4gICAgICBmaXJlQWZ0ZXJTY3JvbGxJbnRvVmlld0V2ZW50KGVkaXRvciwgZGF0YSk7XG4gICAgfTtcbiAgICBjb25zdCBhcHBseVdpdGhNYXJrZXIgPSAoZWRpdG9yLCBmLCBybmcsIGFsaWduVG9Ub3ApID0+IHtcbiAgICAgIGNvbnN0IGJvZHkgPSBTdWdhckVsZW1lbnQuZnJvbURvbShlZGl0b3IuZ2V0Qm9keSgpKTtcbiAgICAgIGNvbnN0IGRvYyA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVkaXRvci5nZXREb2MoKSk7XG4gICAgICByZWZsb3coYm9keSk7XG4gICAgICBjb25zdCBtYXJrZXIgPSBjcmVhdGVNYXJrZXIkMShTdWdhckVsZW1lbnQuZnJvbURvbShybmcuc3RhcnRDb250YWluZXIpLCBybmcuc3RhcnRPZmZzZXQpO1xuICAgICAgd2l0aFNjcm9sbEV2ZW50cyhlZGl0b3IsIGRvYywgZiwgbWFya2VyLCBhbGlnblRvVG9wKTtcbiAgICAgIG1hcmtlci5jbGVhbnVwKCk7XG4gICAgfTtcbiAgICBjb25zdCB3aXRoRWxlbWVudCA9IChlZGl0b3IsIGVsZW1lbnQsIGYsIGFsaWduVG9Ub3ApID0+IHtcbiAgICAgIGNvbnN0IGRvYyA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVkaXRvci5nZXREb2MoKSk7XG4gICAgICB3aXRoU2Nyb2xsRXZlbnRzKGVkaXRvciwgZG9jLCBmLCBlbGVtZW50TWFya2VyKGVsZW1lbnQpLCBhbGlnblRvVG9wKTtcbiAgICB9O1xuICAgIGNvbnN0IHByZXNlcnZlV2l0aCA9IChlZGl0b3IsIGYsIHJuZykgPT4ge1xuICAgICAgY29uc3Qgc3RhcnRFbGVtZW50ID0gcm5nLnN0YXJ0Q29udGFpbmVyO1xuICAgICAgY29uc3Qgc3RhcnRPZmZzZXQgPSBybmcuc3RhcnRPZmZzZXQ7XG4gICAgICBjb25zdCBlbmRFbGVtZW50ID0gcm5nLmVuZENvbnRhaW5lcjtcbiAgICAgIGNvbnN0IGVuZE9mZnNldCA9IHJuZy5lbmRPZmZzZXQ7XG4gICAgICBmKFN1Z2FyRWxlbWVudC5mcm9tRG9tKHN0YXJ0RWxlbWVudCksIFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVuZEVsZW1lbnQpKTtcbiAgICAgIGNvbnN0IG5ld1JuZyA9IGVkaXRvci5kb20uY3JlYXRlUm5nKCk7XG4gICAgICBuZXdSbmcuc2V0U3RhcnQoc3RhcnRFbGVtZW50LCBzdGFydE9mZnNldCk7XG4gICAgICBuZXdSbmcuc2V0RW5kKGVuZEVsZW1lbnQsIGVuZE9mZnNldCk7XG4gICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNldFJuZyhybmcpO1xuICAgIH07XG4gICAgY29uc3Qgc2Nyb2xsVG9NYXJrZXIgPSAobWFya2VyLCB2aWV3SGVpZ2h0LCBhbGlnblRvVG9wLCBkb2MpID0+IHtcbiAgICAgIGNvbnN0IHBvcyA9IG1hcmtlci5wb3M7XG4gICAgICBpZiAoYWxpZ25Ub1RvcCkge1xuICAgICAgICB0byhwb3MubGVmdCwgcG9zLnRvcCwgZG9jKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHkgPSBwb3MudG9wIC0gdmlld0hlaWdodCArIG1hcmtlci5oZWlnaHQ7XG4gICAgICAgIHRvKHBvcy5sZWZ0LCB5LCBkb2MpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaW50b1dpbmRvd0lmTmVlZGVkID0gKGRvYywgc2Nyb2xsVG9wLCB2aWV3SGVpZ2h0LCBtYXJrZXIsIGFsaWduVG9Ub3ApID0+IHtcbiAgICAgIGNvbnN0IHZpZXdwb3J0Qm90dG9tID0gdmlld0hlaWdodCArIHNjcm9sbFRvcDtcbiAgICAgIGNvbnN0IG1hcmtlclRvcCA9IG1hcmtlci5wb3MudG9wO1xuICAgICAgY29uc3QgbWFya2VyQm90dG9tID0gbWFya2VyLmJvdHRvbTtcbiAgICAgIGNvbnN0IGxhcmdlclRoYW5WaWV3cG9ydCA9IG1hcmtlckJvdHRvbSAtIG1hcmtlclRvcCA+PSB2aWV3SGVpZ2h0O1xuICAgICAgaWYgKG1hcmtlclRvcCA8IHNjcm9sbFRvcCkge1xuICAgICAgICBzY3JvbGxUb01hcmtlcihtYXJrZXIsIHZpZXdIZWlnaHQsIGFsaWduVG9Ub3AgIT09IGZhbHNlLCBkb2MpO1xuICAgICAgfSBlbHNlIGlmIChtYXJrZXJUb3AgPiB2aWV3cG9ydEJvdHRvbSkge1xuICAgICAgICBjb25zdCBhbGlnbiA9IGxhcmdlclRoYW5WaWV3cG9ydCA/IGFsaWduVG9Ub3AgIT09IGZhbHNlIDogYWxpZ25Ub1RvcCA9PT0gdHJ1ZTtcbiAgICAgICAgc2Nyb2xsVG9NYXJrZXIobWFya2VyLCB2aWV3SGVpZ2h0LCBhbGlnbiwgZG9jKTtcbiAgICAgIH0gZWxzZSBpZiAobWFya2VyQm90dG9tID4gdmlld3BvcnRCb3R0b20gJiYgIWxhcmdlclRoYW5WaWV3cG9ydCkge1xuICAgICAgICBzY3JvbGxUb01hcmtlcihtYXJrZXIsIHZpZXdIZWlnaHQsIGFsaWduVG9Ub3AgPT09IHRydWUsIGRvYyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBpbnRvV2luZG93ID0gKGRvYywgc2Nyb2xsVG9wLCBtYXJrZXIsIGFsaWduVG9Ub3ApID0+IHtcbiAgICAgIGNvbnN0IHZpZXdIZWlnaHQgPSBkb2MuZG9tLmRlZmF1bHRWaWV3LmlubmVySGVpZ2h0O1xuICAgICAgaW50b1dpbmRvd0lmTmVlZGVkKGRvYywgc2Nyb2xsVG9wLCB2aWV3SGVpZ2h0LCBtYXJrZXIsIGFsaWduVG9Ub3ApO1xuICAgIH07XG4gICAgY29uc3QgaW50b0ZyYW1lID0gKGRvYywgc2Nyb2xsVG9wLCBtYXJrZXIsIGFsaWduVG9Ub3ApID0+IHtcbiAgICAgIGNvbnN0IGZyYW1lVmlld0hlaWdodCA9IGRvYy5kb20uZGVmYXVsdFZpZXcuaW5uZXJIZWlnaHQ7XG4gICAgICBpbnRvV2luZG93SWZOZWVkZWQoZG9jLCBzY3JvbGxUb3AsIGZyYW1lVmlld0hlaWdodCwgbWFya2VyLCBhbGlnblRvVG9wKTtcbiAgICAgIGNvbnN0IG9wID0gZmluZChtYXJrZXIuZWxlbWVudCk7XG4gICAgICBjb25zdCB2aWV3cG9ydEJvdW5kcyA9IGdldEJvdW5kcyh3aW5kb3cpO1xuICAgICAgaWYgKG9wLnRvcCA8IHZpZXdwb3J0Qm91bmRzLnkpIHtcbiAgICAgICAgaW50b1ZpZXcobWFya2VyLmVsZW1lbnQsIGFsaWduVG9Ub3AgIT09IGZhbHNlKTtcbiAgICAgIH0gZWxzZSBpZiAob3AudG9wID4gdmlld3BvcnRCb3VuZHMuYm90dG9tKSB7XG4gICAgICAgIGludG9WaWV3KG1hcmtlci5lbGVtZW50LCBhbGlnblRvVG9wID09PSB0cnVlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJhbmdlSW50b1dpbmRvdyA9IChlZGl0b3IsIHJuZywgYWxpZ25Ub1RvcCkgPT4gd2l0aE1hcmtlcihlZGl0b3IsIGludG9XaW5kb3csIHJuZywgYWxpZ25Ub1RvcCk7XG4gICAgY29uc3QgZWxlbWVudEludG9XaW5kb3cgPSAoZWRpdG9yLCBlbGVtZW50LCBhbGlnblRvVG9wKSA9PiB3aXRoRWxlbWVudChlZGl0b3IsIGVsZW1lbnQsIGludG9XaW5kb3csIGFsaWduVG9Ub3ApO1xuICAgIGNvbnN0IHJhbmdlSW50b0ZyYW1lID0gKGVkaXRvciwgcm5nLCBhbGlnblRvVG9wKSA9PiB3aXRoTWFya2VyKGVkaXRvciwgaW50b0ZyYW1lLCBybmcsIGFsaWduVG9Ub3ApO1xuICAgIGNvbnN0IGVsZW1lbnRJbnRvRnJhbWUgPSAoZWRpdG9yLCBlbGVtZW50LCBhbGlnblRvVG9wKSA9PiB3aXRoRWxlbWVudChlZGl0b3IsIGVsZW1lbnQsIGludG9GcmFtZSwgYWxpZ25Ub1RvcCk7XG4gICAgY29uc3Qgc2Nyb2xsRWxlbWVudEludG9WaWV3ID0gKGVkaXRvciwgZWxlbWVudCwgYWxpZ25Ub1RvcCkgPT4ge1xuICAgICAgY29uc3Qgc2Nyb2xsZXIgPSBlZGl0b3IuaW5saW5lID8gZWxlbWVudEludG9XaW5kb3cgOiBlbGVtZW50SW50b0ZyYW1lO1xuICAgICAgc2Nyb2xsZXIoZWRpdG9yLCBlbGVtZW50LCBhbGlnblRvVG9wKTtcbiAgICB9O1xuICAgIGNvbnN0IHNjcm9sbFJhbmdlSW50b1ZpZXcgPSAoZWRpdG9yLCBybmcsIGFsaWduVG9Ub3ApID0+IHtcbiAgICAgIGNvbnN0IHNjcm9sbGVyID0gZWRpdG9yLmlubGluZSA/IHJhbmdlSW50b1dpbmRvdyA6IHJhbmdlSW50b0ZyYW1lO1xuICAgICAgc2Nyb2xsZXIoZWRpdG9yLCBybmcsIGFsaWduVG9Ub3ApO1xuICAgIH07XG5cbiAgICBjb25zdCBmb2N1cyQxID0gZWxlbWVudCA9PiBlbGVtZW50LmRvbS5mb2N1cygpO1xuICAgIGNvbnN0IGhhc0ZvY3VzJDEgPSBlbGVtZW50ID0+IHtcbiAgICAgIGNvbnN0IHJvb3QgPSBnZXRSb290Tm9kZShlbGVtZW50KS5kb207XG4gICAgICByZXR1cm4gZWxlbWVudC5kb20gPT09IHJvb3QuYWN0aXZlRWxlbWVudDtcbiAgICB9O1xuICAgIGNvbnN0IGFjdGl2ZSQxID0gKHJvb3QgPSBnZXREb2N1bWVudCgpKSA9PiBPcHRpb25hbC5mcm9tKHJvb3QuZG9tLmFjdGl2ZUVsZW1lbnQpLm1hcChTdWdhckVsZW1lbnQuZnJvbURvbSk7XG4gICAgY29uc3Qgc2VhcmNoID0gZWxlbWVudCA9PiBhY3RpdmUkMShnZXRSb290Tm9kZShlbGVtZW50KSkuZmlsdGVyKGUgPT4gZWxlbWVudC5kb20uY29udGFpbnMoZS5kb20pKTtcblxuICAgIGNvbnN0IGNsYW1wJDEgPSAob2Zmc2V0LCBlbGVtZW50KSA9PiB7XG4gICAgICBjb25zdCBtYXggPSBpc1RleHQkOShlbGVtZW50KSA/IGdldCQzKGVsZW1lbnQpLmxlbmd0aCA6IGNoaWxkcmVuKGVsZW1lbnQpLmxlbmd0aCArIDE7XG4gICAgICBpZiAob2Zmc2V0ID4gbWF4KSB7XG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgICB9IGVsc2UgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH07XG4gICAgY29uc3Qgbm9ybWFsaXplUm5nID0gcm5nID0+IFNpbVNlbGVjdGlvbi5yYW5nZShybmcuc3RhcnQsIGNsYW1wJDEocm5nLnNvZmZzZXQsIHJuZy5zdGFydCksIHJuZy5maW5pc2gsIGNsYW1wJDEocm5nLmZvZmZzZXQsIHJuZy5maW5pc2gpKTtcbiAgICBjb25zdCBpc09yQ29udGFpbnMgPSAocm9vdCwgZWxtKSA9PiAhaXNSZXN0cmljdGVkTm9kZShlbG0uZG9tKSAmJiAoY29udGFpbnMocm9vdCwgZWxtKSB8fCBlcShyb290LCBlbG0pKTtcbiAgICBjb25zdCBpc1JuZ0luUm9vdCA9IHJvb3QgPT4gcm5nID0+IGlzT3JDb250YWlucyhyb290LCBybmcuc3RhcnQpICYmIGlzT3JDb250YWlucyhyb290LCBybmcuZmluaXNoKTtcbiAgICBjb25zdCBzaG91bGRTdG9yZSA9IGVkaXRvciA9PiBlZGl0b3IuaW5saW5lO1xuICAgIGNvbnN0IG5hdGl2ZVJhbmdlVG9TZWxlY3Rpb25SYW5nZSA9IHIgPT4gU2ltU2VsZWN0aW9uLnJhbmdlKFN1Z2FyRWxlbWVudC5mcm9tRG9tKHIuc3RhcnRDb250YWluZXIpLCByLnN0YXJ0T2Zmc2V0LCBTdWdhckVsZW1lbnQuZnJvbURvbShyLmVuZENvbnRhaW5lciksIHIuZW5kT2Zmc2V0KTtcbiAgICBjb25zdCByZWFkUmFuZ2UgPSB3aW4gPT4ge1xuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gd2luLmdldFNlbGVjdGlvbigpO1xuICAgICAgY29uc3Qgcm5nID0gIXNlbGVjdGlvbiB8fCBzZWxlY3Rpb24ucmFuZ2VDb3VudCA9PT0gMCA/IE9wdGlvbmFsLm5vbmUoKSA6IE9wdGlvbmFsLmZyb20oc2VsZWN0aW9uLmdldFJhbmdlQXQoMCkpO1xuICAgICAgcmV0dXJuIHJuZy5tYXAobmF0aXZlUmFuZ2VUb1NlbGVjdGlvblJhbmdlKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldEJvb2ttYXJrID0gcm9vdCA9PiB7XG4gICAgICBjb25zdCB3aW4gPSBkZWZhdWx0Vmlldyhyb290KTtcbiAgICAgIHJldHVybiByZWFkUmFuZ2Uod2luLmRvbSkuZmlsdGVyKGlzUm5nSW5Sb290KHJvb3QpKTtcbiAgICB9O1xuICAgIGNvbnN0IHZhbGlkYXRlID0gKHJvb3QsIGJvb2ttYXJrKSA9PiBPcHRpb25hbC5mcm9tKGJvb2ttYXJrKS5maWx0ZXIoaXNSbmdJblJvb3Qocm9vdCkpLm1hcChub3JtYWxpemVSbmcpO1xuICAgIGNvbnN0IGJvb2ttYXJrVG9OYXRpdmVSbmcgPSBib29rbWFyayA9PiB7XG4gICAgICBjb25zdCBybmcgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcm5nLnNldFN0YXJ0KGJvb2ttYXJrLnN0YXJ0LmRvbSwgYm9va21hcmsuc29mZnNldCk7XG4gICAgICAgIHJuZy5zZXRFbmQoYm9va21hcmsuZmluaXNoLmRvbSwgYm9va21hcmsuZm9mZnNldCk7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKHJuZyk7XG4gICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBzdG9yZSA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBuZXdCb29rbWFyayA9IHNob3VsZFN0b3JlKGVkaXRvcikgPyBnZXRCb29rbWFyayhTdWdhckVsZW1lbnQuZnJvbURvbShlZGl0b3IuZ2V0Qm9keSgpKSkgOiBPcHRpb25hbC5ub25lKCk7XG4gICAgICBlZGl0b3IuYm9va21hcmsgPSBuZXdCb29rbWFyay5pc1NvbWUoKSA/IG5ld0Jvb2ttYXJrIDogZWRpdG9yLmJvb2ttYXJrO1xuICAgIH07XG4gICAgY29uc3QgZ2V0Um5nID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IGJvb2ttYXJrID0gZWRpdG9yLmJvb2ttYXJrID8gZWRpdG9yLmJvb2ttYXJrIDogT3B0aW9uYWwubm9uZSgpO1xuICAgICAgcmV0dXJuIGJvb2ttYXJrLmJpbmQoeCA9PiB2YWxpZGF0ZShTdWdhckVsZW1lbnQuZnJvbURvbShlZGl0b3IuZ2V0Qm9keSgpKSwgeCkpLmJpbmQoYm9va21hcmtUb05hdGl2ZVJuZyk7XG4gICAgfTtcbiAgICBjb25zdCByZXN0b3JlID0gZWRpdG9yID0+IHtcbiAgICAgIGdldFJuZyhlZGl0b3IpLmVhY2gocm5nID0+IGVkaXRvci5zZWxlY3Rpb24uc2V0Um5nKHJuZykpO1xuICAgIH07XG5cbiAgICBjb25zdCBpc0VkaXRvclVJRWxlbWVudCQxID0gZWxtID0+IHtcbiAgICAgIGNvbnN0IGNsYXNzTmFtZSA9IGVsbS5jbGFzc05hbWUudG9TdHJpbmcoKTtcbiAgICAgIHJldHVybiBjbGFzc05hbWUuaW5kZXhPZigndG94LScpICE9PSAtMSB8fCBjbGFzc05hbWUuaW5kZXhPZignbWNlLScpICE9PSAtMTtcbiAgICB9O1xuICAgIGNvbnN0IEZvY3VzTWFuYWdlciA9IHsgaXNFZGl0b3JVSUVsZW1lbnQ6IGlzRWRpdG9yVUlFbGVtZW50JDEgfTtcblxuICAgIGNvbnN0IHdyYXBwZWRTZXRUaW1lb3V0ID0gKGNhbGxiYWNrLCB0aW1lKSA9PiB7XG4gICAgICBpZiAoIWlzTnVtYmVyKHRpbWUpKSB7XG4gICAgICAgIHRpbWUgPSAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNldFRpbWVvdXQoY2FsbGJhY2ssIHRpbWUpO1xuICAgIH07XG4gICAgY29uc3Qgd3JhcHBlZFNldEludGVydmFsID0gKGNhbGxiYWNrLCB0aW1lKSA9PiB7XG4gICAgICBpZiAoIWlzTnVtYmVyKHRpbWUpKSB7XG4gICAgICAgIHRpbWUgPSAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNldEludGVydmFsKGNhbGxiYWNrLCB0aW1lKTtcbiAgICB9O1xuICAgIGNvbnN0IERlbGF5ID0ge1xuICAgICAgc2V0RWRpdG9yVGltZW91dDogKGVkaXRvciwgY2FsbGJhY2ssIHRpbWUpID0+IHtcbiAgICAgICAgcmV0dXJuIHdyYXBwZWRTZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpZiAoIWVkaXRvci5yZW1vdmVkKSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgdGltZSk7XG4gICAgICB9LFxuICAgICAgc2V0RWRpdG9ySW50ZXJ2YWw6IChlZGl0b3IsIGNhbGxiYWNrLCB0aW1lKSA9PiB7XG4gICAgICAgIGNvbnN0IHRpbWVyID0gd3JhcHBlZFNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICBpZiAoIWVkaXRvci5yZW1vdmVkKSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRpbWVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHRpbWUpO1xuICAgICAgICByZXR1cm4gdGltZXI7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGlzTWFudWFsTm9kZUNoYW5nZSA9IGUgPT4ge1xuICAgICAgcmV0dXJuIGUudHlwZSA9PT0gJ25vZGVjaGFuZ2UnICYmIGUuc2VsZWN0aW9uQ2hhbmdlO1xuICAgIH07XG4gICAgY29uc3QgcmVnaXN0ZXJQYWdlTW91c2VVcCA9IChlZGl0b3IsIHRocm90dGxlZFN0b3JlKSA9PiB7XG4gICAgICBjb25zdCBtb3VzZVVwUGFnZSA9ICgpID0+IHtcbiAgICAgICAgdGhyb3R0bGVkU3RvcmUudGhyb3R0bGUoKTtcbiAgICAgIH07XG4gICAgICBET01VdGlscy5ET00uYmluZChkb2N1bWVudCwgJ21vdXNldXAnLCBtb3VzZVVwUGFnZSk7XG4gICAgICBlZGl0b3Iub24oJ3JlbW92ZScsICgpID0+IHtcbiAgICAgICAgRE9NVXRpbHMuRE9NLnVuYmluZChkb2N1bWVudCwgJ21vdXNldXAnLCBtb3VzZVVwUGFnZSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHJlZ2lzdGVyTW91c2VVcCA9IChlZGl0b3IsIHRocm90dGxlZFN0b3JlKSA9PiB7XG4gICAgICBlZGl0b3Iub24oJ21vdXNldXAgdG91Y2hlbmQnLCBfZSA9PiB7XG4gICAgICAgIHRocm90dGxlZFN0b3JlLnRocm90dGxlKCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHJlZ2lzdGVyRWRpdG9yRXZlbnRzID0gKGVkaXRvciwgdGhyb3R0bGVkU3RvcmUpID0+IHtcbiAgICAgIHJlZ2lzdGVyTW91c2VVcChlZGl0b3IsIHRocm90dGxlZFN0b3JlKTtcbiAgICAgIGVkaXRvci5vbigna2V5dXAgTm9kZUNoYW5nZSBBZnRlclNldFNlbGVjdGlvblJhbmdlJywgZSA9PiB7XG4gICAgICAgIGlmICghaXNNYW51YWxOb2RlQ2hhbmdlKGUpKSB7XG4gICAgICAgICAgc3RvcmUoZWRpdG9yKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCByZWdpc3RlciQ2ID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IHRocm90dGxlZFN0b3JlID0gZmlyc3QkMSgoKSA9PiB7XG4gICAgICAgIHN0b3JlKGVkaXRvcik7XG4gICAgICB9LCAwKTtcbiAgICAgIGVkaXRvci5vbignaW5pdCcsICgpID0+IHtcbiAgICAgICAgaWYgKGVkaXRvci5pbmxpbmUpIHtcbiAgICAgICAgICByZWdpc3RlclBhZ2VNb3VzZVVwKGVkaXRvciwgdGhyb3R0bGVkU3RvcmUpO1xuICAgICAgICB9XG4gICAgICAgIHJlZ2lzdGVyRWRpdG9yRXZlbnRzKGVkaXRvciwgdGhyb3R0bGVkU3RvcmUpO1xuICAgICAgfSk7XG4gICAgICBlZGl0b3Iub24oJ3JlbW92ZScsICgpID0+IHtcbiAgICAgICAgdGhyb3R0bGVkU3RvcmUuY2FuY2VsKCk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgbGV0IGRvY3VtZW50Rm9jdXNJbkhhbmRsZXI7XG4gICAgY29uc3QgRE9NJDkgPSBET01VdGlscy5ET007XG4gICAgY29uc3QgaXNFZGl0b3JVSUVsZW1lbnQgPSBlbG0gPT4ge1xuICAgICAgcmV0dXJuIEZvY3VzTWFuYWdlci5pc0VkaXRvclVJRWxlbWVudChlbG0pO1xuICAgIH07XG4gICAgY29uc3QgaXNFZGl0b3JDb250ZW50QXJlYUVsZW1lbnQgPSBlbG0gPT4ge1xuICAgICAgY29uc3QgY2xhc3NMaXN0ID0gZWxtLmNsYXNzTGlzdDtcbiAgICAgIGlmIChjbGFzc0xpc3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gY2xhc3NMaXN0LmNvbnRhaW5zKCd0b3gtZWRpdC1hcmVhJykgfHwgY2xhc3NMaXN0LmNvbnRhaW5zKCd0b3gtZWRpdC1hcmVhX19pZnJhbWUnKSB8fCBjbGFzc0xpc3QuY29udGFpbnMoJ21jZS1jb250ZW50LWJvZHknKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGlzVUlFbGVtZW50ID0gKGVkaXRvciwgZWxtKSA9PiB7XG4gICAgICBjb25zdCBjdXN0b21TZWxlY3RvciA9IGdldEN1c3RvbVVpU2VsZWN0b3IoZWRpdG9yKTtcbiAgICAgIGNvbnN0IHBhcmVudCA9IERPTSQ5LmdldFBhcmVudChlbG0sIGVsbSA9PiB7XG4gICAgICAgIHJldHVybiBpc0VkaXRvclVJRWxlbWVudChlbG0pIHx8IChjdXN0b21TZWxlY3RvciA/IGVkaXRvci5kb20uaXMoZWxtLCBjdXN0b21TZWxlY3RvcikgOiBmYWxzZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwYXJlbnQgIT09IG51bGw7XG4gICAgfTtcbiAgICBjb25zdCBnZXRBY3RpdmVFbGVtZW50ID0gZWRpdG9yID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJvb3QgPSBnZXRSb290Tm9kZShTdWdhckVsZW1lbnQuZnJvbURvbShlZGl0b3IuZ2V0RWxlbWVudCgpKSk7XG4gICAgICAgIHJldHVybiBhY3RpdmUkMShyb290KS5mb2xkKCgpID0+IGRvY3VtZW50LmJvZHksIHggPT4geC5kb20pO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmJvZHk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCByZWdpc3RlckV2ZW50cyQxID0gKGVkaXRvck1hbmFnZXIsIGUpID0+IHtcbiAgICAgIGNvbnN0IGVkaXRvciA9IGUuZWRpdG9yO1xuICAgICAgcmVnaXN0ZXIkNihlZGl0b3IpO1xuICAgICAgZWRpdG9yLm9uKCdmb2N1c2luJywgKCkgPT4ge1xuICAgICAgICBjb25zdCBmb2N1c2VkRWRpdG9yID0gZWRpdG9yTWFuYWdlci5mb2N1c2VkRWRpdG9yO1xuICAgICAgICBpZiAoZm9jdXNlZEVkaXRvciAhPT0gZWRpdG9yKSB7XG4gICAgICAgICAgaWYgKGZvY3VzZWRFZGl0b3IpIHtcbiAgICAgICAgICAgIGZvY3VzZWRFZGl0b3IuZGlzcGF0Y2goJ2JsdXInLCB7IGZvY3VzZWRFZGl0b3I6IGVkaXRvciB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWRpdG9yTWFuYWdlci5zZXRBY3RpdmUoZWRpdG9yKTtcbiAgICAgICAgICBlZGl0b3JNYW5hZ2VyLmZvY3VzZWRFZGl0b3IgPSBlZGl0b3I7XG4gICAgICAgICAgZWRpdG9yLmRpc3BhdGNoKCdmb2N1cycsIHsgYmx1cnJlZEVkaXRvcjogZm9jdXNlZEVkaXRvciB9KTtcbiAgICAgICAgICBlZGl0b3IuZm9jdXModHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLm9uKCdmb2N1c291dCcsICgpID0+IHtcbiAgICAgICAgRGVsYXkuc2V0RWRpdG9yVGltZW91dChlZGl0b3IsICgpID0+IHtcbiAgICAgICAgICBjb25zdCBmb2N1c2VkRWRpdG9yID0gZWRpdG9yTWFuYWdlci5mb2N1c2VkRWRpdG9yO1xuICAgICAgICAgIGlmICghaXNVSUVsZW1lbnQoZWRpdG9yLCBnZXRBY3RpdmVFbGVtZW50KGVkaXRvcikpICYmIGZvY3VzZWRFZGl0b3IgPT09IGVkaXRvcikge1xuICAgICAgICAgICAgZWRpdG9yLmRpc3BhdGNoKCdibHVyJywgeyBmb2N1c2VkRWRpdG9yOiBudWxsIH0pO1xuICAgICAgICAgICAgZWRpdG9yTWFuYWdlci5mb2N1c2VkRWRpdG9yID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBpZiAoIWRvY3VtZW50Rm9jdXNJbkhhbmRsZXIpIHtcbiAgICAgICAgZG9jdW1lbnRGb2N1c0luSGFuZGxlciA9IGUgPT4ge1xuICAgICAgICAgIGNvbnN0IGFjdGl2ZUVkaXRvciA9IGVkaXRvck1hbmFnZXIuYWN0aXZlRWRpdG9yO1xuICAgICAgICAgIGlmIChhY3RpdmVFZGl0b3IpIHtcbiAgICAgICAgICAgIGdldE9yaWdpbmFsRXZlbnRUYXJnZXQoZSkuZWFjaCh0YXJnZXQgPT4ge1xuICAgICAgICAgICAgICBpZiAodGFyZ2V0Lm93bmVyRG9jdW1lbnQgPT09IGRvY3VtZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldCAhPT0gZG9jdW1lbnQuYm9keSAmJiAhaXNVSUVsZW1lbnQoYWN0aXZlRWRpdG9yLCB0YXJnZXQpICYmIGVkaXRvck1hbmFnZXIuZm9jdXNlZEVkaXRvciA9PT0gYWN0aXZlRWRpdG9yKSB7XG4gICAgICAgICAgICAgICAgICBhY3RpdmVFZGl0b3IuZGlzcGF0Y2goJ2JsdXInLCB7IGZvY3VzZWRFZGl0b3I6IG51bGwgfSk7XG4gICAgICAgICAgICAgICAgICBlZGl0b3JNYW5hZ2VyLmZvY3VzZWRFZGl0b3IgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBET00kOS5iaW5kKGRvY3VtZW50LCAnZm9jdXNpbicsIGRvY3VtZW50Rm9jdXNJbkhhbmRsZXIpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgdW5yZWdpc3RlckRvY3VtZW50RXZlbnRzID0gKGVkaXRvck1hbmFnZXIsIGUpID0+IHtcbiAgICAgIGlmIChlZGl0b3JNYW5hZ2VyLmZvY3VzZWRFZGl0b3IgPT09IGUuZWRpdG9yKSB7XG4gICAgICAgIGVkaXRvck1hbmFnZXIuZm9jdXNlZEVkaXRvciA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoIWVkaXRvck1hbmFnZXIuYWN0aXZlRWRpdG9yKSB7XG4gICAgICAgIERPTSQ5LnVuYmluZChkb2N1bWVudCwgJ2ZvY3VzaW4nLCBkb2N1bWVudEZvY3VzSW5IYW5kbGVyKTtcbiAgICAgICAgZG9jdW1lbnRGb2N1c0luSGFuZGxlciA9IG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBzZXR1cCR2ID0gZWRpdG9yTWFuYWdlciA9PiB7XG4gICAgICBlZGl0b3JNYW5hZ2VyLm9uKCdBZGRFZGl0b3InLCBjdXJyeShyZWdpc3RlckV2ZW50cyQxLCBlZGl0b3JNYW5hZ2VyKSk7XG4gICAgICBlZGl0b3JNYW5hZ2VyLm9uKCdSZW1vdmVFZGl0b3InLCBjdXJyeSh1bnJlZ2lzdGVyRG9jdW1lbnRFdmVudHMsIGVkaXRvck1hbmFnZXIpKTtcbiAgICB9O1xuXG4gICAgY29uc3QgZ2V0Q29udGVudEVkaXRhYmxlSG9zdCA9IChlZGl0b3IsIG5vZGUpID0+IGVkaXRvci5kb20uZ2V0UGFyZW50KG5vZGUsIG5vZGUgPT4gZWRpdG9yLmRvbS5nZXRDb250ZW50RWRpdGFibGUobm9kZSkgPT09ICd0cnVlJyk7XG4gICAgY29uc3QgZ2V0Q29sbGFwc2VkTm9kZSA9IHJuZyA9PiBybmcuY29sbGFwc2VkID8gT3B0aW9uYWwuZnJvbShnZXROb2RlJDEocm5nLnN0YXJ0Q29udGFpbmVyLCBybmcuc3RhcnRPZmZzZXQpKS5tYXAoU3VnYXJFbGVtZW50LmZyb21Eb20pIDogT3B0aW9uYWwubm9uZSgpO1xuICAgIGNvbnN0IGdldEZvY3VzSW5FbGVtZW50ID0gKHJvb3QsIHJuZykgPT4gZ2V0Q29sbGFwc2VkTm9kZShybmcpLmJpbmQobm9kZSA9PiB7XG4gICAgICBpZiAoaXNUYWJsZVNlY3Rpb24obm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUobm9kZSk7XG4gICAgICB9IGVsc2UgaWYgKGNvbnRhaW5zKHJvb3QsIG5vZGUpID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZShyb290KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3Qgbm9ybWFsaXplU2VsZWN0aW9uJDEgPSAoZWRpdG9yLCBybmcpID0+IHtcbiAgICAgIGdldEZvY3VzSW5FbGVtZW50KFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVkaXRvci5nZXRCb2R5KCkpLCBybmcpLmJpbmQoZWxtID0+IHtcbiAgICAgICAgcmV0dXJuIGZpcnN0UG9zaXRpb25JbihlbG0uZG9tKTtcbiAgICAgIH0pLmZvbGQoKCkgPT4ge1xuICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLm5vcm1hbGl6ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9LCBjYXJldFBvcyA9PiBlZGl0b3Iuc2VsZWN0aW9uLnNldFJuZyhjYXJldFBvcy50b1JhbmdlKCkpKTtcbiAgICB9O1xuICAgIGNvbnN0IGZvY3VzQm9keSA9IGJvZHkgPT4ge1xuICAgICAgaWYgKGJvZHkuc2V0QWN0aXZlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYm9keS5zZXRBY3RpdmUoKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBib2R5LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJvZHkuZm9jdXMoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGhhc0VsZW1lbnRGb2N1cyA9IGVsbSA9PiBoYXNGb2N1cyQxKGVsbSkgfHwgc2VhcmNoKGVsbSkuaXNTb21lKCk7XG4gICAgY29uc3QgaGFzSWZyYW1lRm9jdXMgPSBlZGl0b3IgPT4gZWRpdG9yLmlmcmFtZUVsZW1lbnQgJiYgaGFzRm9jdXMkMShTdWdhckVsZW1lbnQuZnJvbURvbShlZGl0b3IuaWZyYW1lRWxlbWVudCkpO1xuICAgIGNvbnN0IGhhc0lubGluZUZvY3VzID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IHJhd0JvZHkgPSBlZGl0b3IuZ2V0Qm9keSgpO1xuICAgICAgcmV0dXJuIHJhd0JvZHkgJiYgaGFzRWxlbWVudEZvY3VzKFN1Z2FyRWxlbWVudC5mcm9tRG9tKHJhd0JvZHkpKTtcbiAgICB9O1xuICAgIGNvbnN0IGhhc1VpRm9jdXMgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgZG9zID0gZ2V0Um9vdE5vZGUoU3VnYXJFbGVtZW50LmZyb21Eb20oZWRpdG9yLmdldEVsZW1lbnQoKSkpO1xuICAgICAgcmV0dXJuIGFjdGl2ZSQxKGRvcykuZmlsdGVyKGVsZW0gPT4gIWlzRWRpdG9yQ29udGVudEFyZWFFbGVtZW50KGVsZW0uZG9tKSAmJiBpc1VJRWxlbWVudChlZGl0b3IsIGVsZW0uZG9tKSkuaXNTb21lKCk7XG4gICAgfTtcbiAgICBjb25zdCBoYXNGb2N1cyA9IGVkaXRvciA9PiBlZGl0b3IuaW5saW5lID8gaGFzSW5saW5lRm9jdXMoZWRpdG9yKSA6IGhhc0lmcmFtZUZvY3VzKGVkaXRvcik7XG4gICAgY29uc3QgaGFzRWRpdG9yT3JVaUZvY3VzID0gZWRpdG9yID0+IGhhc0ZvY3VzKGVkaXRvcikgfHwgaGFzVWlGb2N1cyhlZGl0b3IpO1xuICAgIGNvbnN0IGZvY3VzRWRpdG9yID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb247XG4gICAgICBjb25zdCBib2R5ID0gZWRpdG9yLmdldEJvZHkoKTtcbiAgICAgIGxldCBybmcgPSBzZWxlY3Rpb24uZ2V0Um5nKCk7XG4gICAgICBlZGl0b3IucXVpcmtzLnJlZnJlc2hDb250ZW50RWRpdGFibGUoKTtcbiAgICAgIGlmIChlZGl0b3IuYm9va21hcmsgIT09IHVuZGVmaW5lZCAmJiBoYXNGb2N1cyhlZGl0b3IpID09PSBmYWxzZSkge1xuICAgICAgICBnZXRSbmcoZWRpdG9yKS5lYWNoKGJvb2ttYXJrUm5nID0+IHtcbiAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNldFJuZyhib29rbWFya1JuZyk7XG4gICAgICAgICAgcm5nID0gYm9va21hcmtSbmc7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29uc3QgY29udGVudEVkaXRhYmxlSG9zdCA9IGdldENvbnRlbnRFZGl0YWJsZUhvc3QoZWRpdG9yLCBzZWxlY3Rpb24uZ2V0Tm9kZSgpKTtcbiAgICAgIGlmIChlZGl0b3IuZG9tLmlzQ2hpbGRPZihjb250ZW50RWRpdGFibGVIb3N0LCBib2R5KSkge1xuICAgICAgICBmb2N1c0JvZHkoY29udGVudEVkaXRhYmxlSG9zdCk7XG4gICAgICAgIG5vcm1hbGl6ZVNlbGVjdGlvbiQxKGVkaXRvciwgcm5nKTtcbiAgICAgICAgYWN0aXZhdGVFZGl0b3IoZWRpdG9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFlZGl0b3IuaW5saW5lKSB7XG4gICAgICAgIGlmICghRW52LmJyb3dzZXIuaXNPcGVyYSgpKSB7XG4gICAgICAgICAgZm9jdXNCb2R5KGJvZHkpO1xuICAgICAgICB9XG4gICAgICAgIGVkaXRvci5nZXRXaW4oKS5mb2N1cygpO1xuICAgICAgfVxuICAgICAgaWYgKEVudi5icm93c2VyLmlzRmlyZWZveCgpIHx8IGVkaXRvci5pbmxpbmUpIHtcbiAgICAgICAgZm9jdXNCb2R5KGJvZHkpO1xuICAgICAgICBub3JtYWxpemVTZWxlY3Rpb24kMShlZGl0b3IsIHJuZyk7XG4gICAgICB9XG4gICAgICBhY3RpdmF0ZUVkaXRvcihlZGl0b3IpO1xuICAgIH07XG4gICAgY29uc3QgYWN0aXZhdGVFZGl0b3IgPSBlZGl0b3IgPT4gZWRpdG9yLmVkaXRvck1hbmFnZXIuc2V0QWN0aXZlKGVkaXRvcik7XG4gICAgY29uc3QgZm9jdXMgPSAoZWRpdG9yLCBza2lwRm9jdXMpID0+IHtcbiAgICAgIGlmIChlZGl0b3IucmVtb3ZlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoc2tpcEZvY3VzKSB7XG4gICAgICAgIGFjdGl2YXRlRWRpdG9yKGVkaXRvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb2N1c0VkaXRvcihlZGl0b3IpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBnZXRFbmRwb2ludEVsZW1lbnQgPSAocm9vdCwgcm5nLCBzdGFydCwgcmVhbCwgcmVzb2x2ZSkgPT4ge1xuICAgICAgY29uc3QgY29udGFpbmVyID0gc3RhcnQgPyBybmcuc3RhcnRDb250YWluZXIgOiBybmcuZW5kQ29udGFpbmVyO1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gc3RhcnQgPyBybmcuc3RhcnRPZmZzZXQgOiBybmcuZW5kT2Zmc2V0O1xuICAgICAgcmV0dXJuIE9wdGlvbmFsLmZyb20oY29udGFpbmVyKS5tYXAoU3VnYXJFbGVtZW50LmZyb21Eb20pLm1hcChlbG0gPT4gIXJlYWwgfHwgIXJuZy5jb2xsYXBzZWQgPyBjaGlsZCQxKGVsbSwgcmVzb2x2ZShlbG0sIG9mZnNldCkpLmdldE9yKGVsbSkgOiBlbG0pLmJpbmQoZWxtID0+IGlzRWxlbWVudCQ3KGVsbSkgPyBPcHRpb25hbC5zb21lKGVsbSkgOiBwYXJlbnQoZWxtKS5maWx0ZXIoaXNFbGVtZW50JDcpKS5tYXAoZWxtID0+IGVsbS5kb20pLmdldE9yKHJvb3QpO1xuICAgIH07XG4gICAgY29uc3QgZ2V0U3RhcnQgPSAocm9vdCwgcm5nLCByZWFsKSA9PiBnZXRFbmRwb2ludEVsZW1lbnQocm9vdCwgcm5nLCB0cnVlLCByZWFsLCAoZWxtLCBvZmZzZXQpID0+IE1hdGgubWluKGNoaWxkTm9kZXNDb3VudChlbG0pLCBvZmZzZXQpKTtcbiAgICBjb25zdCBnZXRFbmQkMSA9IChyb290LCBybmcsIHJlYWwpID0+IGdldEVuZHBvaW50RWxlbWVudChyb290LCBybmcsIGZhbHNlLCByZWFsLCAoZWxtLCBvZmZzZXQpID0+IG9mZnNldCA+IDAgPyBvZmZzZXQgLSAxIDogb2Zmc2V0KTtcbiAgICBjb25zdCBza2lwRW1wdHlUZXh0Tm9kZXMgPSAobm9kZSwgZm9yd2FyZHMpID0+IHtcbiAgICAgIGNvbnN0IG9yaWcgPSBub2RlO1xuICAgICAgd2hpbGUgKG5vZGUgJiYgaXNUZXh0JDgobm9kZSkgJiYgbm9kZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgbm9kZSA9IGZvcndhcmRzID8gbm9kZS5uZXh0U2libGluZyA6IG5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGUgfHwgb3JpZztcbiAgICB9O1xuICAgIGNvbnN0IGdldE5vZGUgPSAocm9vdCwgcm5nKSA9PiB7XG4gICAgICBsZXQgZWxtLCBzdGFydENvbnRhaW5lciwgZW5kQ29udGFpbmVyO1xuICAgICAgaWYgKCFybmcpIHtcbiAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICB9XG4gICAgICBzdGFydENvbnRhaW5lciA9IHJuZy5zdGFydENvbnRhaW5lcjtcbiAgICAgIGVuZENvbnRhaW5lciA9IHJuZy5lbmRDb250YWluZXI7XG4gICAgICBjb25zdCBzdGFydE9mZnNldCA9IHJuZy5zdGFydE9mZnNldDtcbiAgICAgIGNvbnN0IGVuZE9mZnNldCA9IHJuZy5lbmRPZmZzZXQ7XG4gICAgICBlbG0gPSBybmcuY29tbW9uQW5jZXN0b3JDb250YWluZXI7XG4gICAgICBpZiAoIXJuZy5jb2xsYXBzZWQpIHtcbiAgICAgICAgaWYgKHN0YXJ0Q29udGFpbmVyID09PSBlbmRDb250YWluZXIpIHtcbiAgICAgICAgICBpZiAoZW5kT2Zmc2V0IC0gc3RhcnRPZmZzZXQgPCAyKSB7XG4gICAgICAgICAgICBpZiAoc3RhcnRDb250YWluZXIuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgICAgIGVsbSA9IHN0YXJ0Q29udGFpbmVyLmNoaWxkTm9kZXNbc3RhcnRPZmZzZXRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnRDb250YWluZXIubm9kZVR5cGUgPT09IDMgJiYgZW5kQ29udGFpbmVyLm5vZGVUeXBlID09PSAzKSB7XG4gICAgICAgICAgaWYgKHN0YXJ0Q29udGFpbmVyLmxlbmd0aCA9PT0gc3RhcnRPZmZzZXQpIHtcbiAgICAgICAgICAgIHN0YXJ0Q29udGFpbmVyID0gc2tpcEVtcHR5VGV4dE5vZGVzKHN0YXJ0Q29udGFpbmVyLm5leHRTaWJsaW5nLCB0cnVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhcnRDb250YWluZXIgPSBzdGFydENvbnRhaW5lci5wYXJlbnROb2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZW5kT2Zmc2V0ID09PSAwKSB7XG4gICAgICAgICAgICBlbmRDb250YWluZXIgPSBza2lwRW1wdHlUZXh0Tm9kZXMoZW5kQ29udGFpbmVyLnByZXZpb3VzU2libGluZywgZmFsc2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbmRDb250YWluZXIgPSBlbmRDb250YWluZXIucGFyZW50Tm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXJ0Q29udGFpbmVyICYmIHN0YXJ0Q29udGFpbmVyID09PSBlbmRDb250YWluZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFydENvbnRhaW5lcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChlbG0gJiYgZWxtLm5vZGVUeXBlID09PSAzKSB7XG4gICAgICAgIHJldHVybiBlbG0ucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbG07XG4gICAgfTtcbiAgICBjb25zdCBnZXRTZWxlY3RlZEJsb2NrcyA9IChkb20sIHJuZywgc3RhcnRFbG0sIGVuZEVsbSkgPT4ge1xuICAgICAgbGV0IG5vZGU7XG4gICAgICBjb25zdCBzZWxlY3RlZEJsb2NrcyA9IFtdO1xuICAgICAgY29uc3Qgcm9vdCA9IGRvbS5nZXRSb290KCk7XG4gICAgICBzdGFydEVsbSA9IGRvbS5nZXRQYXJlbnQoc3RhcnRFbG0gfHwgZ2V0U3RhcnQocm9vdCwgcm5nLCBybmcuY29sbGFwc2VkKSwgZG9tLmlzQmxvY2spO1xuICAgICAgZW5kRWxtID0gZG9tLmdldFBhcmVudChlbmRFbG0gfHwgZ2V0RW5kJDEocm9vdCwgcm5nLCBybmcuY29sbGFwc2VkKSwgZG9tLmlzQmxvY2spO1xuICAgICAgaWYgKHN0YXJ0RWxtICYmIHN0YXJ0RWxtICE9PSByb290KSB7XG4gICAgICAgIHNlbGVjdGVkQmxvY2tzLnB1c2goc3RhcnRFbG0pO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0RWxtICYmIGVuZEVsbSAmJiBzdGFydEVsbSAhPT0gZW5kRWxtKSB7XG4gICAgICAgIG5vZGUgPSBzdGFydEVsbTtcbiAgICAgICAgY29uc3Qgd2Fsa2VyID0gbmV3IERvbVRyZWVXYWxrZXIoc3RhcnRFbG0sIHJvb3QpO1xuICAgICAgICB3aGlsZSAoKG5vZGUgPSB3YWxrZXIubmV4dCgpKSAmJiBub2RlICE9PSBlbmRFbG0pIHtcbiAgICAgICAgICBpZiAoZG9tLmlzQmxvY2sobm9kZSkpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkQmxvY2tzLnB1c2gobm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZW5kRWxtICYmIHN0YXJ0RWxtICE9PSBlbmRFbG0gJiYgZW5kRWxtICE9PSByb290KSB7XG4gICAgICAgIHNlbGVjdGVkQmxvY2tzLnB1c2goZW5kRWxtKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxlY3RlZEJsb2NrcztcbiAgICB9O1xuICAgIGNvbnN0IHNlbGVjdCA9IChkb20sIG5vZGUsIGNvbnRlbnQpID0+IE9wdGlvbmFsLmZyb20obm9kZSkubWFwKG5vZGUgPT4ge1xuICAgICAgY29uc3QgaWR4ID0gZG9tLm5vZGVJbmRleChub2RlKTtcbiAgICAgIGNvbnN0IHJuZyA9IGRvbS5jcmVhdGVSbmcoKTtcbiAgICAgIHJuZy5zZXRTdGFydChub2RlLnBhcmVudE5vZGUsIGlkeCk7XG4gICAgICBybmcuc2V0RW5kKG5vZGUucGFyZW50Tm9kZSwgaWR4ICsgMSk7XG4gICAgICBpZiAoY29udGVudCkge1xuICAgICAgICBtb3ZlRW5kUG9pbnQoZG9tLCBybmcsIG5vZGUsIHRydWUpO1xuICAgICAgICBtb3ZlRW5kUG9pbnQoZG9tLCBybmcsIG5vZGUsIGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBybmc7XG4gICAgfSk7XG5cbiAgICBjb25zdCBwcm9jZXNzUmFuZ2VzID0gKGVkaXRvciwgcmFuZ2VzKSA9PiBtYXAkMyhyYW5nZXMsIHJhbmdlID0+IHtcbiAgICAgIGNvbnN0IGV2dCA9IGVkaXRvci5kaXNwYXRjaCgnR2V0U2VsZWN0aW9uUmFuZ2UnLCB7IHJhbmdlIH0pO1xuICAgICAgcmV0dXJuIGV2dC5yYW5nZSAhPT0gcmFuZ2UgPyBldnQucmFuZ2UgOiByYW5nZTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGdldEVuZCA9IGVsZW1lbnQgPT4gbmFtZShlbGVtZW50KSA9PT0gJ2ltZycgPyAxIDogZ2V0T3B0aW9uKGVsZW1lbnQpLmZvbGQoKCkgPT4gY2hpbGRyZW4oZWxlbWVudCkubGVuZ3RoLCB2ID0+IHYubGVuZ3RoKTtcbiAgICBjb25zdCBpc1RleHROb2RlV2l0aEN1cnNvclBvc2l0aW9uID0gZWwgPT4gZ2V0T3B0aW9uKGVsKS5maWx0ZXIodGV4dCA9PiB0ZXh0LnRyaW0oKS5sZW5ndGggIT09IDAgfHwgdGV4dC5pbmRleE9mKG5ic3ApID4gLTEpLmlzU29tZSgpO1xuICAgIGNvbnN0IGVsZW1lbnRzV2l0aEN1cnNvclBvc2l0aW9uID0gW1xuICAgICAgJ2ltZycsXG4gICAgICAnYnInXG4gICAgXTtcbiAgICBjb25zdCBpc0N1cnNvclBvc2l0aW9uID0gZWxlbSA9PiB7XG4gICAgICBjb25zdCBoYXNDdXJzb3JQb3NpdGlvbiA9IGlzVGV4dE5vZGVXaXRoQ3Vyc29yUG9zaXRpb24oZWxlbSk7XG4gICAgICByZXR1cm4gaGFzQ3Vyc29yUG9zaXRpb24gfHwgY29udGFpbnMkMihlbGVtZW50c1dpdGhDdXJzb3JQb3NpdGlvbiwgbmFtZShlbGVtKSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGZpcnN0ID0gZWxlbWVudCA9PiBkZXNjZW5kYW50JDEoZWxlbWVudCwgaXNDdXJzb3JQb3NpdGlvbik7XG4gICAgY29uc3QgbGFzdCA9IGVsZW1lbnQgPT4gZGVzY2VuZGFudFJ0bChlbGVtZW50LCBpc0N1cnNvclBvc2l0aW9uKTtcbiAgICBjb25zdCBkZXNjZW5kYW50UnRsID0gKHNjb3BlLCBwcmVkaWNhdGUpID0+IHtcbiAgICAgIGNvbnN0IGRlc2NlbmQgPSBlbGVtZW50ID0+IHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4kMSA9IGNoaWxkcmVuKGVsZW1lbnQpO1xuICAgICAgICBmb3IgKGxldCBpID0gY2hpbGRyZW4kMS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW4kMVtpXTtcbiAgICAgICAgICBpZiAocHJlZGljYXRlKGNoaWxkKSkge1xuICAgICAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoY2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCByZXMgPSBkZXNjZW5kKGNoaWxkKTtcbiAgICAgICAgICBpZiAocmVzLmlzU29tZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBkZXNjZW5kKHNjb3BlKTtcbiAgICB9O1xuXG4gICAgY29uc3QgYXV0b2NvbXBsZXRlU2VsZWN0b3IgPSAnW2RhdGEtbWNlLWF1dG9jb21wbGV0ZXJdJztcbiAgICBjb25zdCBjcmVhdGUkOCA9IChlZGl0b3IsIHJhbmdlKSA9PiB7XG4gICAgICBpZiAoZmluZEluKFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVkaXRvci5nZXRCb2R5KCkpKS5pc05vbmUoKSkge1xuICAgICAgICBjb25zdCB3cmFwcGVyID0gU3VnYXJFbGVtZW50LmZyb21IdG1sKCc8c3BhbiBkYXRhLW1jZS1hdXRvY29tcGxldGVyPVwiMVwiIGRhdGEtbWNlLWJvZ3VzPVwiMVwiPjwvc3Bhbj4nLCBlZGl0b3IuZ2V0RG9jKCkpO1xuICAgICAgICBhcHBlbmQkMSh3cmFwcGVyLCBTdWdhckVsZW1lbnQuZnJvbURvbShyYW5nZS5leHRyYWN0Q29udGVudHMoKSkpO1xuICAgICAgICByYW5nZS5pbnNlcnROb2RlKHdyYXBwZXIuZG9tKTtcbiAgICAgICAgcGFyZW50KHdyYXBwZXIpLmVhY2goZWxtID0+IGVsbS5kb20ubm9ybWFsaXplKCkpO1xuICAgICAgICBsYXN0KHdyYXBwZXIpLm1hcChsYXN0ID0+IHtcbiAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNldEN1cnNvckxvY2F0aW9uKGxhc3QuZG9tLCBnZXRFbmQobGFzdCkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGRldGVjdCQxID0gZWxtID0+IGNsb3Nlc3QkMyhlbG0sIGF1dG9jb21wbGV0ZVNlbGVjdG9yKTtcbiAgICBjb25zdCBmaW5kSW4gPSBlbG0gPT4gZGVzY2VuZGFudChlbG0sIGF1dG9jb21wbGV0ZVNlbGVjdG9yKTtcbiAgICBjb25zdCByZW1vdmUkMyA9IChlZGl0b3IsIGVsbSkgPT4gZmluZEluKGVsbSkuZWFjaCh3cmFwcGVyID0+IHtcbiAgICAgIGNvbnN0IGJvb2ttYXJrID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRCb29rbWFyaygpO1xuICAgICAgdW53cmFwKHdyYXBwZXIpO1xuICAgICAgZWRpdG9yLnNlbGVjdGlvbi5tb3ZlVG9Cb29rbWFyayhib29rbWFyayk7XG4gICAgfSk7XG5cbiAgICBjb25zdCB0eXBlTG9va3VwID0ge1xuICAgICAgJyN0ZXh0JzogMyxcbiAgICAgICcjY29tbWVudCc6IDgsXG4gICAgICAnI2NkYXRhJzogNCxcbiAgICAgICcjcGknOiA3LFxuICAgICAgJyNkb2N0eXBlJzogMTAsXG4gICAgICAnI2RvY3VtZW50LWZyYWdtZW50JzogMTFcbiAgICB9O1xuICAgIGNvbnN0IHdhbGskMiA9IChub2RlLCByb290LCBwcmV2KSA9PiB7XG4gICAgICBjb25zdCBzdGFydE5hbWUgPSBwcmV2ID8gJ2xhc3RDaGlsZCcgOiAnZmlyc3RDaGlsZCc7XG4gICAgICBjb25zdCBzaWJsaW5nTmFtZSA9IHByZXYgPyAncHJldicgOiAnbmV4dCc7XG4gICAgICBpZiAobm9kZVtzdGFydE5hbWVdKSB7XG4gICAgICAgIHJldHVybiBub2RlW3N0YXJ0TmFtZV07XG4gICAgICB9XG4gICAgICBpZiAobm9kZSAhPT0gcm9vdCkge1xuICAgICAgICBsZXQgc2libGluZyA9IG5vZGVbc2libGluZ05hbWVdO1xuICAgICAgICBpZiAoc2libGluZykge1xuICAgICAgICAgIHJldHVybiBzaWJsaW5nO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHBhcmVudCA9IG5vZGUucGFyZW50OyBwYXJlbnQgJiYgcGFyZW50ICE9PSByb290OyBwYXJlbnQgPSBwYXJlbnQucGFyZW50KSB7XG4gICAgICAgICAgc2libGluZyA9IHBhcmVudFtzaWJsaW5nTmFtZV07XG4gICAgICAgICAgaWYgKHNpYmxpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBzaWJsaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaXNFbXB0eVRleHROb2RlID0gbm9kZSA9PiB7XG4gICAgICBpZiAoIWlzV2hpdGVzcGFjZVRleHQobm9kZS52YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50O1xuICAgICAgaWYgKHBhcmVudE5vZGUgJiYgKHBhcmVudE5vZGUubmFtZSAhPT0gJ3NwYW4nIHx8IHBhcmVudE5vZGUuYXR0cignc3R5bGUnKSkgJiYgL15bIF0rJC8udGVzdChub2RlLnZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIGNvbnN0IGlzTm9uRW1wdHlFbGVtZW50ID0gbm9kZSA9PiB7XG4gICAgICBjb25zdCBpc05hbWVkQW5jaG9yID0gbm9kZS5uYW1lID09PSAnYScgJiYgIW5vZGUuYXR0cignaHJlZicpICYmIG5vZGUuYXR0cignaWQnKTtcbiAgICAgIHJldHVybiBub2RlLmF0dHIoJ25hbWUnKSB8fCBub2RlLmF0dHIoJ2lkJykgJiYgIW5vZGUuZmlyc3RDaGlsZCB8fCBub2RlLmF0dHIoJ2RhdGEtbWNlLWJvb2ttYXJrJykgfHwgaXNOYW1lZEFuY2hvcjtcbiAgICB9O1xuICAgIGNsYXNzIEFzdE5vZGUge1xuICAgICAgY29uc3RydWN0b3IobmFtZSwgdHlwZSkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICBpZiAodHlwZSA9PT0gMSkge1xuICAgICAgICAgIHRoaXMuYXR0cmlidXRlcyA9IFtdO1xuICAgICAgICAgIHRoaXMuYXR0cmlidXRlcy5tYXAgPSB7fTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhdGljIGNyZWF0ZShuYW1lLCBhdHRycykge1xuICAgICAgICBjb25zdCBub2RlID0gbmV3IEFzdE5vZGUobmFtZSwgdHlwZUxvb2t1cFtuYW1lXSB8fCAxKTtcbiAgICAgICAgaWYgKGF0dHJzKSB7XG4gICAgICAgICAgZWFjaCRmKGF0dHJzLCAodmFsdWUsIGF0dHJOYW1lKSA9PiB7XG4gICAgICAgICAgICBub2RlLmF0dHIoYXR0ck5hbWUsIHZhbHVlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cbiAgICAgIHJlcGxhY2Uobm9kZSkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKG5vZGUucGFyZW50KSB7XG4gICAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLmluc2VydChub2RlLCBzZWxmKTtcbiAgICAgICAgc2VsZi5yZW1vdmUoKTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG4gICAgICBhdHRyKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBsZXQgYXR0cnM7XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBpZiAobmFtZSAhPT0gdW5kZWZpbmVkICYmIG5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGVhY2gkZihuYW1lLCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgICBzZWxmLmF0dHIoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0dHJzID0gc2VsZi5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBpZiAobmFtZSBpbiBhdHRycy5tYXApIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgYXR0cnMubWFwW25hbWVdO1xuICAgICAgICAgICAgICAgIGxldCBpID0gYXR0cnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICAgIGlmIChhdHRyc1tpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5hbWUgaW4gYXR0cnMubWFwKSB7XG4gICAgICAgICAgICAgIGxldCBpID0gYXR0cnMubGVuZ3RoO1xuICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHJzW2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgIGF0dHJzW2ldLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGF0dHJzLnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhdHRycy5tYXBbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYXR0cnMubWFwW25hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjbG9uZSgpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGNsb25lID0gbmV3IEFzdE5vZGUoc2VsZi5uYW1lLCBzZWxmLnR5cGUpO1xuICAgICAgICBsZXQgc2VsZkF0dHJzO1xuICAgICAgICBpZiAoc2VsZkF0dHJzID0gc2VsZi5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgY29uc3QgY2xvbmVBdHRycyA9IFtdO1xuICAgICAgICAgIGNsb25lQXR0cnMubWFwID0ge307XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBzZWxmQXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBzZWxmQXR0ciA9IHNlbGZBdHRyc1tpXTtcbiAgICAgICAgICAgIGlmIChzZWxmQXR0ci5uYW1lICE9PSAnaWQnKSB7XG4gICAgICAgICAgICAgIGNsb25lQXR0cnNbY2xvbmVBdHRycy5sZW5ndGhdID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6IHNlbGZBdHRyLm5hbWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHNlbGZBdHRyLnZhbHVlXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGNsb25lQXR0cnMubWFwW3NlbGZBdHRyLm5hbWVdID0gc2VsZkF0dHIudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNsb25lLmF0dHJpYnV0ZXMgPSBjbG9uZUF0dHJzO1xuICAgICAgICB9XG4gICAgICAgIGNsb25lLnZhbHVlID0gc2VsZi52YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgICAgfVxuICAgICAgd3JhcCh3cmFwcGVyKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBzZWxmLnBhcmVudC5pbnNlcnQod3JhcHBlciwgc2VsZik7XG4gICAgICAgIHdyYXBwZXIuYXBwZW5kKHNlbGYpO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cbiAgICAgIHVud3JhcCgpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IG5vZGUgPSBzZWxmLmZpcnN0Q2hpbGQ7IG5vZGU7KSB7XG4gICAgICAgICAgY29uc3QgbmV4dCA9IG5vZGUubmV4dDtcbiAgICAgICAgICBzZWxmLmluc2VydChub2RlLCBzZWxmLCB0cnVlKTtcbiAgICAgICAgICBub2RlID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLnJlbW92ZSgpO1xuICAgICAgfVxuICAgICAgcmVtb3ZlKCkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcywgcGFyZW50ID0gc2VsZi5wYXJlbnQsIG5leHQgPSBzZWxmLm5leHQsIHByZXYgPSBzZWxmLnByZXY7XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICBpZiAocGFyZW50LmZpcnN0Q2hpbGQgPT09IHNlbGYpIHtcbiAgICAgICAgICAgIHBhcmVudC5maXJzdENoaWxkID0gbmV4dDtcbiAgICAgICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgICAgIG5leHQucHJldiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByZXYubmV4dCA9IG5leHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwYXJlbnQubGFzdENoaWxkID09PSBzZWxmKSB7XG4gICAgICAgICAgICBwYXJlbnQubGFzdENoaWxkID0gcHJldjtcbiAgICAgICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgICAgIHByZXYubmV4dCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5leHQucHJldiA9IHByZXY7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGYucGFyZW50ID0gc2VsZi5uZXh0ID0gc2VsZi5wcmV2ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cbiAgICAgIGFwcGVuZChub2RlKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAobm9kZS5wYXJlbnQpIHtcbiAgICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxhc3QgPSBzZWxmLmxhc3RDaGlsZDtcbiAgICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgICBsYXN0Lm5leHQgPSBub2RlO1xuICAgICAgICAgIG5vZGUucHJldiA9IGxhc3Q7XG4gICAgICAgICAgc2VsZi5sYXN0Q2hpbGQgPSBub2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGYubGFzdENoaWxkID0gc2VsZi5maXJzdENoaWxkID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLnBhcmVudCA9IHNlbGY7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuICAgICAgaW5zZXJ0KG5vZGUsIHJlZk5vZGUsIGJlZm9yZSkge1xuICAgICAgICBpZiAobm9kZS5wYXJlbnQpIHtcbiAgICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHJlZk5vZGUucGFyZW50IHx8IHRoaXM7XG4gICAgICAgIGlmIChiZWZvcmUpIHtcbiAgICAgICAgICBpZiAocmVmTm9kZSA9PT0gcGFyZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIHBhcmVudC5maXJzdENoaWxkID0gbm9kZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVmTm9kZS5wcmV2Lm5leHQgPSBub2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlLnByZXYgPSByZWZOb2RlLnByZXY7XG4gICAgICAgICAgbm9kZS5uZXh0ID0gcmVmTm9kZTtcbiAgICAgICAgICByZWZOb2RlLnByZXYgPSBub2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChyZWZOb2RlID09PSBwYXJlbnQubGFzdENoaWxkKSB7XG4gICAgICAgICAgICBwYXJlbnQubGFzdENoaWxkID0gbm9kZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVmTm9kZS5uZXh0LnByZXYgPSBub2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlLm5leHQgPSByZWZOb2RlLm5leHQ7XG4gICAgICAgICAgbm9kZS5wcmV2ID0gcmVmTm9kZTtcbiAgICAgICAgICByZWZOb2RlLm5leHQgPSBub2RlO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUucGFyZW50ID0gcGFyZW50O1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cbiAgICAgIGdldEFsbChuYW1lKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBjb25zdCBjb2xsZWN0aW9uID0gW107XG4gICAgICAgIGZvciAobGV0IG5vZGUgPSBzZWxmLmZpcnN0Q2hpbGQ7IG5vZGU7IG5vZGUgPSB3YWxrJDIobm9kZSwgc2VsZikpIHtcbiAgICAgICAgICBpZiAobm9kZS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgICBjb2xsZWN0aW9uLnB1c2gobm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgICAgfVxuICAgICAgY2hpbGRyZW4oKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBjb25zdCBjb2xsZWN0aW9uID0gW107XG4gICAgICAgIGZvciAobGV0IG5vZGUgPSBzZWxmLmZpcnN0Q2hpbGQ7IG5vZGU7IG5vZGUgPSBub2RlLm5leHQpIHtcbiAgICAgICAgICBjb2xsZWN0aW9uLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgICB9XG4gICAgICBlbXB0eSgpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmIChzZWxmLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICBjb25zdCBub2RlcyA9IFtdO1xuICAgICAgICAgIGZvciAobGV0IG5vZGUgPSBzZWxmLmZpcnN0Q2hpbGQ7IG5vZGU7IG5vZGUgPSB3YWxrJDIobm9kZSwgc2VsZikpIHtcbiAgICAgICAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBpID0gbm9kZXMubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICAgIG5vZGUucGFyZW50ID0gbm9kZS5maXJzdENoaWxkID0gbm9kZS5sYXN0Q2hpbGQgPSBub2RlLm5leHQgPSBub2RlLnByZXYgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZWxmLmZpcnN0Q2hpbGQgPSBzZWxmLmxhc3RDaGlsZCA9IG51bGw7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuICAgICAgaXNFbXB0eShlbGVtZW50cywgd2hpdGVzcGFjZSA9IHt9LCBwcmVkaWNhdGUpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGxldCBub2RlID0gc2VsZi5maXJzdENoaWxkO1xuICAgICAgICBpZiAoaXNOb25FbXB0eUVsZW1lbnQoc2VsZikpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgICAgICAgICAgIGlmIChub2RlLmF0dHIoJ2RhdGEtbWNlLWJvZ3VzJykpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZWxlbWVudHNbbm9kZS5uYW1lXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaXNOb25FbXB0eUVsZW1lbnQobm9kZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09IDgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gMyAmJiAhaXNFbXB0eVRleHROb2RlKG5vZGUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09IDMgJiYgbm9kZS5wYXJlbnQgJiYgd2hpdGVzcGFjZVtub2RlLnBhcmVudC5uYW1lXSAmJiBpc1doaXRlc3BhY2VUZXh0KG5vZGUudmFsdWUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUgJiYgcHJlZGljYXRlKG5vZGUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IHdoaWxlIChub2RlID0gd2FsayQyKG5vZGUsIHNlbGYpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHdhbGsocHJldikge1xuICAgICAgICByZXR1cm4gd2FsayQyKHRoaXMsIG51bGwsIHByZXYpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGlzQ29uZGl0aW9uYWxDb21tZW50ID0gKGh0bWwsIHN0YXJ0SW5kZXgpID0+IC9eXFxzKlxcW2lmIFtcXHdcXFddK1xcXT4uKjwhXFxbZW5kaWZcXF0oLS0hPyk/Pi8udGVzdChodG1sLnN1YnN0cihzdGFydEluZGV4KSk7XG4gICAgY29uc3QgZmluZENvbW1lbnRFbmRJbmRleCA9IChodG1sLCBpc0JvZ3VzLCBzdGFydEluZGV4ID0gMCkgPT4ge1xuICAgICAgY29uc3QgbGNIdG1sID0gaHRtbC50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKGxjSHRtbC5pbmRleE9mKCdbaWYgJywgc3RhcnRJbmRleCkgIT09IC0xICYmIGlzQ29uZGl0aW9uYWxDb21tZW50KGxjSHRtbCwgc3RhcnRJbmRleCkpIHtcbiAgICAgICAgY29uc3QgZW5kSWZJbmRleCA9IGxjSHRtbC5pbmRleE9mKCdbZW5kaWZdJywgc3RhcnRJbmRleCk7XG4gICAgICAgIHJldHVybiBsY0h0bWwuaW5kZXhPZignPicsIGVuZElmSW5kZXgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzQm9ndXMpIHtcbiAgICAgICAgICBjb25zdCBlbmRJbmRleCA9IGxjSHRtbC5pbmRleE9mKCc+Jywgc3RhcnRJbmRleCk7XG4gICAgICAgICAgcmV0dXJuIGVuZEluZGV4ICE9PSAtMSA/IGVuZEluZGV4IDogbGNIdG1sLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBlbmRDb21tZW50UmVnZXhwID0gLy0tIT8+L2c7XG4gICAgICAgICAgZW5kQ29tbWVudFJlZ2V4cC5sYXN0SW5kZXggPSBzdGFydEluZGV4O1xuICAgICAgICAgIGNvbnN0IG1hdGNoID0gZW5kQ29tbWVudFJlZ2V4cC5leGVjKGh0bWwpO1xuICAgICAgICAgIHJldHVybiBtYXRjaCA/IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoIDogbGNIdG1sLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZmluZE1hdGNoaW5nRW5kVGFnSW5kZXggPSAoc2NoZW1hLCBodG1sLCBzdGFydEluZGV4KSA9PiB7XG4gICAgICBjb25zdCBzdGFydFRhZ1JlZ0V4cCA9IC88KFshP1xcL10pPyhbQS1aYS16MC05XFwtXzouXSspL2c7XG4gICAgICBjb25zdCBlbmRUYWdSZWdFeHAgPSAvKD86XFxzKD86W14nXCI+XSsoPzpcIlteXCJdKlwifCdbXiddKicpKSpbXlwiJz5dKig/OlwiW15cIj5dKnwnW14nPl0qKT98XFxzKnxcXC8pPi9nO1xuICAgICAgY29uc3Qgdm9pZEVsZW1lbnRzID0gc2NoZW1hLmdldFZvaWRFbGVtZW50cygpO1xuICAgICAgbGV0IGNvdW50ID0gMSwgaW5kZXggPSBzdGFydEluZGV4O1xuICAgICAgd2hpbGUgKGNvdW50ICE9PSAwKSB7XG4gICAgICAgIHN0YXJ0VGFnUmVnRXhwLmxhc3RJbmRleCA9IGluZGV4O1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGNvbnN0IHN0YXJ0TWF0Y2ggPSBzdGFydFRhZ1JlZ0V4cC5leGVjKGh0bWwpO1xuICAgICAgICAgIGlmIChzdGFydE1hdGNoID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdGFydE1hdGNoWzFdID09PSAnIScpIHtcbiAgICAgICAgICAgIGlmIChzdGFydHNXaXRoKHN0YXJ0TWF0Y2hbMl0sICctLScpKSB7XG4gICAgICAgICAgICAgIGluZGV4ID0gZmluZENvbW1lbnRFbmRJbmRleChodG1sLCBmYWxzZSwgc3RhcnRNYXRjaC5pbmRleCArICchLS0nLmxlbmd0aCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpbmRleCA9IGZpbmRDb21tZW50RW5kSW5kZXgoaHRtbCwgdHJ1ZSwgc3RhcnRNYXRjaC5pbmRleCArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVuZFRhZ1JlZ0V4cC5sYXN0SW5kZXggPSBzdGFydFRhZ1JlZ0V4cC5sYXN0SW5kZXg7XG4gICAgICAgICAgICBjb25zdCBlbmRNYXRjaCA9IGVuZFRhZ1JlZ0V4cC5leGVjKGh0bWwpO1xuICAgICAgICAgICAgaWYgKGlzTnVsbChlbmRNYXRjaCkgfHwgZW5kTWF0Y2guaW5kZXggIT09IHN0YXJ0VGFnUmVnRXhwLmxhc3RJbmRleCkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGFydE1hdGNoWzFdID09PSAnLycpIHtcbiAgICAgICAgICAgICAgY291bnQgLT0gMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWhhcyQyKHZvaWRFbGVtZW50cywgc3RhcnRNYXRjaFsyXSkpIHtcbiAgICAgICAgICAgICAgY291bnQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZGV4ID0gc3RhcnRUYWdSZWdFeHAubGFzdEluZGV4ICsgZW5kTWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfTtcbiAgICBjb25zdCB0cmltSHRtbCQxID0gKHRlbXBBdHRycywgaHRtbCkgPT4ge1xuICAgICAgY29uc3QgdHJpbUNvbnRlbnRSZWdFeHAgPSBuZXcgUmVnRXhwKFsnXFxcXHM/KCcgKyB0ZW1wQXR0cnMuam9pbignfCcpICsgJyk9XCJbXlwiXStcIiddLmpvaW4oJ3wnKSwgJ2dpJyk7XG4gICAgICByZXR1cm4gaHRtbC5yZXBsYWNlKHRyaW1Db250ZW50UmVnRXhwLCAnJyk7XG4gICAgfTtcbiAgICBjb25zdCB0cmltSW50ZXJuYWwgPSAoc2VyaWFsaXplciwgaHRtbCkgPT4ge1xuICAgICAgY29uc3QgYm9ndXNBbGxSZWdFeHAgPSAvPChcXHcrKSBbXj5dKmRhdGEtbWNlLWJvZ3VzPVwiYWxsXCJbXj5dKj4vZztcbiAgICAgIGNvbnN0IHNjaGVtYSA9IHNlcmlhbGl6ZXIuc2NoZW1hO1xuICAgICAgbGV0IGNvbnRlbnQgPSB0cmltSHRtbCQxKHNlcmlhbGl6ZXIuZ2V0VGVtcEF0dHJzKCksIGh0bWwpO1xuICAgICAgY29uc3Qgdm9pZEVsZW1lbnRzID0gc2NoZW1hLmdldFZvaWRFbGVtZW50cygpO1xuICAgICAgbGV0IG1hdGNoZXM7XG4gICAgICB3aGlsZSAobWF0Y2hlcyA9IGJvZ3VzQWxsUmVnRXhwLmV4ZWMoY29udGVudCkpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBib2d1c0FsbFJlZ0V4cC5sYXN0SW5kZXg7XG4gICAgICAgIGNvbnN0IG1hdGNoTGVuZ3RoID0gbWF0Y2hlc1swXS5sZW5ndGg7XG4gICAgICAgIGxldCBlbmRUYWdJbmRleDtcbiAgICAgICAgaWYgKHZvaWRFbGVtZW50c1ttYXRjaGVzWzFdXSkge1xuICAgICAgICAgIGVuZFRhZ0luZGV4ID0gaW5kZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW5kVGFnSW5kZXggPSBmaW5kTWF0Y2hpbmdFbmRUYWdJbmRleChzY2hlbWEsIGNvbnRlbnQsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZW50ID0gY29udGVudC5zdWJzdHJpbmcoMCwgaW5kZXggLSBtYXRjaExlbmd0aCkgKyBjb250ZW50LnN1YnN0cmluZyhlbmRUYWdJbmRleCk7XG4gICAgICAgIGJvZ3VzQWxsUmVnRXhwLmxhc3RJbmRleCA9IGluZGV4IC0gbWF0Y2hMZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJpbSQxKGNvbnRlbnQpO1xuICAgIH07XG4gICAgY29uc3QgdHJpbUV4dGVybmFsID0gdHJpbUludGVybmFsO1xuXG4gICAgY29uc3QgdHJpbUVtcHR5Q29udGVudHMgPSAoZWRpdG9yLCBodG1sKSA9PiB7XG4gICAgICBjb25zdCBibG9ja05hbWUgPSBnZXRGb3JjZWRSb290QmxvY2soZWRpdG9yKTtcbiAgICAgIGNvbnN0IGVtcHR5UmVnRXhwID0gbmV3IFJlZ0V4cChgXig8JHsgYmxvY2tOYW1lIH1bXj5dKj4oJm5ic3A7fCYjMTYwO3xcXFxcc3xcXHUwMGEwfDxiciBcXFxcLz58KTxcXFxcLyR7IGJsb2NrTmFtZSB9PltcXHJcXG5dKnw8YnIgXFxcXC8+W1xcclxcbl0qKSRgKTtcbiAgICAgIHJldHVybiBodG1sLnJlcGxhY2UoZW1wdHlSZWdFeHAsICcnKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldENvbnRlbnRGcm9tQm9keSA9IChlZGl0b3IsIGFyZ3MsIGJvZHkpID0+IHtcbiAgICAgIGxldCBjb250ZW50O1xuICAgICAgaWYgKGFyZ3MuZm9ybWF0ID09PSAncmF3Jykge1xuICAgICAgICBjb250ZW50ID0gVG9vbHMudHJpbSh0cmltRXh0ZXJuYWwoZWRpdG9yLnNlcmlhbGl6ZXIsIGJvZHkuaW5uZXJIVE1MKSk7XG4gICAgICB9IGVsc2UgaWYgKGFyZ3MuZm9ybWF0ID09PSAndGV4dCcpIHtcbiAgICAgICAgY29udGVudCA9IGVkaXRvci5kb20uaXNFbXB0eShib2R5KSA/ICcnIDogdHJpbSQxKGJvZHkuaW5uZXJUZXh0IHx8IGJvZHkudGV4dENvbnRlbnQpO1xuICAgICAgfSBlbHNlIGlmIChhcmdzLmZvcm1hdCA9PT0gJ3RyZWUnKSB7XG4gICAgICAgIGNvbnRlbnQgPSBlZGl0b3Iuc2VyaWFsaXplci5zZXJpYWxpemUoYm9keSwgYXJncyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZW50ID0gdHJpbUVtcHR5Q29udGVudHMoZWRpdG9yLCBlZGl0b3Iuc2VyaWFsaXplci5zZXJpYWxpemUoYm9keSwgYXJncykpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2hvdWxkVHJpbSA9IGFyZ3MuZm9ybWF0ICE9PSAndGV4dCcgJiYgIWlzV3NQcmVzZXJ2ZUVsZW1lbnQoU3VnYXJFbGVtZW50LmZyb21Eb20oYm9keSkpO1xuICAgICAgcmV0dXJuIHNob3VsZFRyaW0gJiYgaXNTdHJpbmcoY29udGVudCkgPyBUb29scy50cmltKGNvbnRlbnQpIDogY29udGVudDtcbiAgICB9O1xuICAgIGNvbnN0IGdldENvbnRlbnRJbnRlcm5hbCA9IChlZGl0b3IsIGFyZ3MpID0+IE9wdGlvbmFsLmZyb20oZWRpdG9yLmdldEJvZHkoKSkuZm9sZChjb25zdGFudChhcmdzLmZvcm1hdCA9PT0gJ3RyZWUnID8gbmV3IEFzdE5vZGUoJ2JvZHknLCAxMSkgOiAnJyksIGJvZHkgPT4gZ2V0Q29udGVudEZyb21Cb2R5KGVkaXRvciwgYXJncywgYm9keSkpO1xuXG4gICAgY29uc3QgZWFjaCRiID0gVG9vbHMuZWFjaDtcbiAgICBjb25zdCBFbGVtZW50VXRpbHMgPSBkb20gPT4ge1xuICAgICAgY29uc3QgY29tcGFyZSA9IChub2RlMSwgbm9kZTIpID0+IHtcbiAgICAgICAgaWYgKG5vZGUxLm5vZGVOYW1lICE9PSBub2RlMi5ub2RlTmFtZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBnZXRBdHRyaWJzID0gbm9kZSA9PiB7XG4gICAgICAgICAgY29uc3QgYXR0cmlicyA9IHt9O1xuICAgICAgICAgIGVhY2gkYihkb20uZ2V0QXR0cmlicyhub2RlKSwgYXR0ciA9PiB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gYXR0ci5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKG5hbWUuaW5kZXhPZignXycpICE9PSAwICYmIG5hbWUgIT09ICdzdHlsZScgJiYgbmFtZS5pbmRleE9mKCdkYXRhLScpICE9PSAwKSB7XG4gICAgICAgICAgICAgIGF0dHJpYnNbbmFtZV0gPSBkb20uZ2V0QXR0cmliKG5vZGUsIG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBhdHRyaWJzO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjb21wYXJlT2JqZWN0cyA9IChvYmoxLCBvYmoyKSA9PiB7XG4gICAgICAgICAgbGV0IHZhbHVlLCBuYW1lO1xuICAgICAgICAgIGZvciAobmFtZSBpbiBvYmoxKSB7XG4gICAgICAgICAgICBpZiAoaGFzJDIob2JqMSwgbmFtZSkpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBvYmoyW25hbWVdO1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAob2JqMVtuYW1lXSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGVsZXRlIG9iajJbbmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAobmFtZSBpbiBvYmoyKSB7XG4gICAgICAgICAgICBpZiAoaGFzJDIob2JqMiwgbmFtZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFjb21wYXJlT2JqZWN0cyhnZXRBdHRyaWJzKG5vZGUxKSwgZ2V0QXR0cmlicyhub2RlMikpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29tcGFyZU9iamVjdHMoZG9tLnBhcnNlU3R5bGUoZG9tLmdldEF0dHJpYihub2RlMSwgJ3N0eWxlJykpLCBkb20ucGFyc2VTdHlsZShkb20uZ2V0QXR0cmliKG5vZGUyLCAnc3R5bGUnKSkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhaXNCb29rbWFya05vZGUkMShub2RlMSkgJiYgIWlzQm9va21hcmtOb2RlJDEobm9kZTIpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiB7IGNvbXBhcmUgfTtcbiAgICB9O1xuXG4gICAgY29uc3QgbWFrZU1hcCQxID0gVG9vbHMubWFrZU1hcDtcbiAgICBjb25zdCBXcml0ZXIgPSBzZXR0aW5ncyA9PiB7XG4gICAgICBjb25zdCBodG1sID0gW107XG4gICAgICBzZXR0aW5ncyA9IHNldHRpbmdzIHx8IHt9O1xuICAgICAgY29uc3QgaW5kZW50ID0gc2V0dGluZ3MuaW5kZW50O1xuICAgICAgY29uc3QgaW5kZW50QmVmb3JlID0gbWFrZU1hcCQxKHNldHRpbmdzLmluZGVudF9iZWZvcmUgfHwgJycpO1xuICAgICAgY29uc3QgaW5kZW50QWZ0ZXIgPSBtYWtlTWFwJDEoc2V0dGluZ3MuaW5kZW50X2FmdGVyIHx8ICcnKTtcbiAgICAgIGNvbnN0IGVuY29kZSA9IEVudGl0aWVzLmdldEVuY29kZUZ1bmMoc2V0dGluZ3MuZW50aXR5X2VuY29kaW5nIHx8ICdyYXcnLCBzZXR0aW5ncy5lbnRpdGllcyk7XG4gICAgICBjb25zdCBodG1sT3V0cHV0ID0gc2V0dGluZ3MuZWxlbWVudF9mb3JtYXQgIT09ICd4aHRtbCc7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGFydDogKG5hbWUsIGF0dHJzLCBlbXB0eSkgPT4ge1xuICAgICAgICAgIGxldCBpLCBsLCBhdHRyLCB2YWx1ZTtcbiAgICAgICAgICBpZiAoaW5kZW50ICYmIGluZGVudEJlZm9yZVtuYW1lXSAmJiBodG1sLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhbHVlID0gaHRtbFtodG1sLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDAgJiYgdmFsdWUgIT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgIGh0bWwucHVzaCgnXFxuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGh0bWwucHVzaCgnPCcsIG5hbWUpO1xuICAgICAgICAgIGlmIChhdHRycykge1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGF0dHJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICBhdHRyID0gYXR0cnNbaV07XG4gICAgICAgICAgICAgIGh0bWwucHVzaCgnICcsIGF0dHIubmFtZSwgJz1cIicsIGVuY29kZShhdHRyLnZhbHVlLCB0cnVlKSwgJ1wiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZW1wdHkgfHwgaHRtbE91dHB1dCkge1xuICAgICAgICAgICAgaHRtbFtodG1sLmxlbmd0aF0gPSAnPic7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGh0bWxbaHRtbC5sZW5ndGhdID0gJyAvPic7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlbXB0eSAmJiBpbmRlbnQgJiYgaW5kZW50QWZ0ZXJbbmFtZV0gJiYgaHRtbC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGh0bWxbaHRtbC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAwICYmIHZhbHVlICE9PSAnXFxuJykge1xuICAgICAgICAgICAgICBodG1sLnB1c2goJ1xcbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW5kOiBuYW1lID0+IHtcbiAgICAgICAgICBsZXQgdmFsdWU7XG4gICAgICAgICAgaHRtbC5wdXNoKCc8LycsIG5hbWUsICc+Jyk7XG4gICAgICAgICAgaWYgKGluZGVudCAmJiBpbmRlbnRBZnRlcltuYW1lXSAmJiBodG1sLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhbHVlID0gaHRtbFtodG1sLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDAgJiYgdmFsdWUgIT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgIGh0bWwucHVzaCgnXFxuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0ZXh0OiAodGV4dCwgcmF3KSA9PiB7XG4gICAgICAgICAgaWYgKHRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaHRtbFtodG1sLmxlbmd0aF0gPSByYXcgPyB0ZXh0IDogZW5jb2RlKHRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY2RhdGE6IHRleHQgPT4ge1xuICAgICAgICAgIGh0bWwucHVzaCgnPCFbQ0RBVEFbJywgdGV4dCwgJ11dPicpO1xuICAgICAgICB9LFxuICAgICAgICBjb21tZW50OiB0ZXh0ID0+IHtcbiAgICAgICAgICBodG1sLnB1c2goJzwhLS0nLCB0ZXh0LCAnLS0+Jyk7XG4gICAgICAgIH0sXG4gICAgICAgIHBpOiAobmFtZSwgdGV4dCkgPT4ge1xuICAgICAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgICAgICBodG1sLnB1c2goJzw/JywgbmFtZSwgJyAnLCBlbmNvZGUodGV4dCksICc/PicpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBodG1sLnB1c2goJzw/JywgbmFtZSwgJz8+Jyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbmRlbnQpIHtcbiAgICAgICAgICAgIGh0bWwucHVzaCgnXFxuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkb2N0eXBlOiB0ZXh0ID0+IHtcbiAgICAgICAgICBodG1sLnB1c2goJzwhRE9DVFlQRScsIHRleHQsICc+JywgaW5kZW50ID8gJ1xcbicgOiAnJyk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlc2V0OiAoKSA9PiB7XG4gICAgICAgICAgaHRtbC5sZW5ndGggPSAwO1xuICAgICAgICB9LFxuICAgICAgICBnZXRDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGh0bWwuam9pbignJykucmVwbGFjZSgvXFxuJC8sICcnKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgY29uc3QgSHRtbFNlcmlhbGl6ZXIgPSAoc2V0dGluZ3MsIHNjaGVtYSA9IFNjaGVtYSgpKSA9PiB7XG4gICAgICBjb25zdCB3cml0ZXIgPSBXcml0ZXIoc2V0dGluZ3MpO1xuICAgICAgc2V0dGluZ3MgPSBzZXR0aW5ncyB8fCB7fTtcbiAgICAgIHNldHRpbmdzLnZhbGlkYXRlID0gJ3ZhbGlkYXRlJyBpbiBzZXR0aW5ncyA/IHNldHRpbmdzLnZhbGlkYXRlIDogdHJ1ZTtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZSA9IG5vZGUgPT4ge1xuICAgICAgICBjb25zdCB2YWxpZGF0ZSA9IHNldHRpbmdzLnZhbGlkYXRlO1xuICAgICAgICBjb25zdCBoYW5kbGVycyA9IHtcbiAgICAgICAgICAzOiBub2RlID0+IHtcbiAgICAgICAgICAgIHdyaXRlci50ZXh0KG5vZGUudmFsdWUsIG5vZGUucmF3KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIDg6IG5vZGUgPT4ge1xuICAgICAgICAgICAgd3JpdGVyLmNvbW1lbnQobm9kZS52YWx1ZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICA3OiBub2RlID0+IHtcbiAgICAgICAgICAgIHdyaXRlci5waShub2RlLm5hbWUsIG5vZGUudmFsdWUpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgMTA6IG5vZGUgPT4ge1xuICAgICAgICAgICAgd3JpdGVyLmRvY3R5cGUobm9kZS52YWx1ZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICA0OiBub2RlID0+IHtcbiAgICAgICAgICAgIHdyaXRlci5jZGF0YShub2RlLnZhbHVlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIDExOiBub2RlID0+IHtcbiAgICAgICAgICAgIGlmIChub2RlID0gbm9kZS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICB3YWxrKG5vZGUpO1xuICAgICAgICAgICAgICB9IHdoaWxlIChub2RlID0gbm9kZS5uZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHdyaXRlci5yZXNldCgpO1xuICAgICAgICBjb25zdCB3YWxrID0gbm9kZSA9PiB7XG4gICAgICAgICAgY29uc3QgaGFuZGxlciA9IGhhbmRsZXJzW25vZGUudHlwZV07XG4gICAgICAgICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gbm9kZS5uYW1lO1xuICAgICAgICAgICAgY29uc3QgaXNFbXB0eSA9IG5hbWUgaW4gc2NoZW1hLmdldFZvaWRFbGVtZW50cygpO1xuICAgICAgICAgICAgbGV0IGF0dHJzID0gbm9kZS5hdHRyaWJ1dGVzO1xuICAgICAgICAgICAgaWYgKHZhbGlkYXRlICYmIGF0dHJzICYmIGF0dHJzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgY29uc3Qgc29ydGVkQXR0cnMgPSBbXTtcbiAgICAgICAgICAgICAgc29ydGVkQXR0cnMubWFwID0ge307XG4gICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRSdWxlID0gc2NoZW1hLmdldEVsZW1lbnRSdWxlKG5vZGUubmFtZSk7XG4gICAgICAgICAgICAgIGlmIChlbGVtZW50UnVsZSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gZWxlbWVudFJ1bGUuYXR0cmlidXRlc09yZGVyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgY29uc3QgYXR0ck5hbWUgPSBlbGVtZW50UnVsZS5hdHRyaWJ1dGVzT3JkZXJbaV07XG4gICAgICAgICAgICAgICAgICBpZiAoYXR0ck5hbWUgaW4gYXR0cnMubWFwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJWYWx1ZSA9IGF0dHJzLm1hcFthdHRyTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIHNvcnRlZEF0dHJzLm1hcFthdHRyTmFtZV0gPSBhdHRyVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHNvcnRlZEF0dHJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGF0dHJOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBhdHRyVmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gYXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBhdHRyTmFtZSA9IGF0dHJzW2ldLm5hbWU7XG4gICAgICAgICAgICAgICAgICBpZiAoIShhdHRyTmFtZSBpbiBzb3J0ZWRBdHRycy5tYXApKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJWYWx1ZSA9IGF0dHJzLm1hcFthdHRyTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIHNvcnRlZEF0dHJzLm1hcFthdHRyTmFtZV0gPSBhdHRyVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHNvcnRlZEF0dHJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGF0dHJOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBhdHRyVmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF0dHJzID0gc29ydGVkQXR0cnM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdyaXRlci5zdGFydChuYW1lLCBhdHRycywgaXNFbXB0eSk7XG4gICAgICAgICAgICBpZiAoIWlzRW1wdHkpIHtcbiAgICAgICAgICAgICAgbGV0IGNoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoKG5hbWUgPT09ICdwcmUnIHx8IG5hbWUgPT09ICd0ZXh0YXJlYScpICYmIGNoaWxkLnR5cGUgPT09IDMgJiYgY2hpbGQudmFsdWVbMF0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICB3cml0ZXIudGV4dCgnXFxuJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgIHdhbGsoY2hpbGQpO1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKGNoaWxkID0gY2hpbGQubmV4dCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgd3JpdGVyLmVuZChuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGFuZGxlcihub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09IDEgJiYgIXNldHRpbmdzLmlubmVyKSB7XG4gICAgICAgICAgd2Fsayhub2RlKTtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IDMpIHtcbiAgICAgICAgICBoYW5kbGVyc1szXShub2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoYW5kbGVyc1sxMV0obm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlci5nZXRDb250ZW50KCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHsgc2VyaWFsaXplIH07XG4gICAgfTtcblxuICAgIGNvbnN0IG5vbkluaGVyaXRhYmxlU3R5bGVzID0gbmV3IFNldCgpO1xuICAgICgoKSA9PiB7XG4gICAgICBjb25zdCBub25Jbmhlcml0YWJsZVN0eWxlc0FyciA9IFtcbiAgICAgICAgJ21hcmdpbicsXG4gICAgICAgICdtYXJnaW4tbGVmdCcsXG4gICAgICAgICdtYXJnaW4tcmlnaHQnLFxuICAgICAgICAnbWFyZ2luLXRvcCcsXG4gICAgICAgICdtYXJnaW4tYm90dG9tJyxcbiAgICAgICAgJ3BhZGRpbmcnLFxuICAgICAgICAncGFkZGluZy1sZWZ0JyxcbiAgICAgICAgJ3BhZGRpbmctcmlnaHQnLFxuICAgICAgICAncGFkZGluZy10b3AnLFxuICAgICAgICAncGFkZGluZy1ib3R0b20nLFxuICAgICAgICAnYm9yZGVyJyxcbiAgICAgICAgJ2JvcmRlci13aWR0aCcsXG4gICAgICAgICdib3JkZXItc3R5bGUnLFxuICAgICAgICAnYm9yZGVyLWNvbG9yJyxcbiAgICAgICAgJ2JhY2tncm91bmQnLFxuICAgICAgICAnYmFja2dyb3VuZC1hdHRhY2htZW50JyxcbiAgICAgICAgJ2JhY2tncm91bmQtY2xpcCcsXG4gICAgICAgICdiYWNrZ3JvdW5kLWNvbG9yJyxcbiAgICAgICAgJ2JhY2tncm91bmQtaW1hZ2UnLFxuICAgICAgICAnYmFja2dyb3VuZC1vcmlnaW4nLFxuICAgICAgICAnYmFja2dyb3VuZC1wb3NpdGlvbicsXG4gICAgICAgICdiYWNrZ3JvdW5kLXJlcGVhdCcsXG4gICAgICAgICdiYWNrZ3JvdW5kLXNpemUnLFxuICAgICAgICAnZmxvYXQnLFxuICAgICAgICAncG9zaXRpb24nLFxuICAgICAgICAnbGVmdCcsXG4gICAgICAgICdyaWdodCcsXG4gICAgICAgICd0b3AnLFxuICAgICAgICAnYm90dG9tJyxcbiAgICAgICAgJ3otaW5kZXgnLFxuICAgICAgICAnZGlzcGxheScsXG4gICAgICAgICd0cmFuc2Zvcm0nLFxuICAgICAgICAnd2lkdGgnLFxuICAgICAgICAnbWF4LXdpZHRoJyxcbiAgICAgICAgJ21pbi13aWR0aCcsXG4gICAgICAgICdoZWlnaHQnLFxuICAgICAgICAnbWF4LWhlaWdodCcsXG4gICAgICAgICdtaW4taGVpZ2h0JyxcbiAgICAgICAgJ292ZXJmbG93JyxcbiAgICAgICAgJ292ZXJmbG93LXgnLFxuICAgICAgICAnb3ZlcmZsb3cteScsXG4gICAgICAgICd0ZXh0LW92ZXJmbG93JyxcbiAgICAgICAgJ3ZlcnRpY2FsLWFsaWduJyxcbiAgICAgICAgJ3RyYW5zaXRpb24nLFxuICAgICAgICAndHJhbnNpdGlvbi1kZWxheScsXG4gICAgICAgICd0cmFuc2l0aW9uLWR1cmF0aW9uJyxcbiAgICAgICAgJ3RyYW5zaXRpb24tcHJvcGVydHknLFxuICAgICAgICAndHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb24nXG4gICAgICBdO1xuICAgICAgZWFjaCRnKG5vbkluaGVyaXRhYmxlU3R5bGVzQXJyLCBzdHlsZSA9PiB7XG4gICAgICAgIG5vbkluaGVyaXRhYmxlU3R5bGVzLmFkZChzdHlsZSk7XG4gICAgICB9KTtcbiAgICB9KSgpO1xuICAgIGNvbnN0IHNob3J0aGFuZFN0eWxlUHJvcHMgPSBbXG4gICAgICAnZm9udCcsXG4gICAgICAndGV4dC1kZWNvcmF0aW9uJyxcbiAgICAgICd0ZXh0LWVtcGhhc2lzJ1xuICAgIF07XG4gICAgY29uc3QgZ2V0U3R5bGVQcm9wcyA9IChkb20sIG5vZGUpID0+IGtleXMoZG9tLnBhcnNlU3R5bGUoZG9tLmdldEF0dHJpYihub2RlLCAnc3R5bGUnKSkpO1xuICAgIGNvbnN0IGlzTm9uSW5oZXJpdGFibGVTdHlsZSA9IHN0eWxlID0+IG5vbkluaGVyaXRhYmxlU3R5bGVzLmhhcyhzdHlsZSk7XG4gICAgY29uc3QgaGFzSW5oZXJpdGFibGVTdHlsZXMgPSAoZG9tLCBub2RlKSA9PiBmb3JhbGwoZ2V0U3R5bGVQcm9wcyhkb20sIG5vZGUpLCBzdHlsZSA9PiAhaXNOb25Jbmhlcml0YWJsZVN0eWxlKHN0eWxlKSk7XG4gICAgY29uc3QgZ2V0TG9uZ2hhbmRTdHlsZVByb3BzID0gc3R5bGVzID0+IGZpbHRlciQ2KHN0eWxlcywgc3R5bGUgPT4gZXhpc3RzKHNob3J0aGFuZFN0eWxlUHJvcHMsIHByb3AgPT4gc3RhcnRzV2l0aChzdHlsZSwgcHJvcCkpKTtcbiAgICBjb25zdCBoYXNTdHlsZUNvbmZsaWN0ID0gKGRvbSwgbm9kZSwgcGFyZW50Tm9kZSkgPT4ge1xuICAgICAgY29uc3Qgbm9kZVN0eWxlUHJvcHMgPSBnZXRTdHlsZVByb3BzKGRvbSwgbm9kZSk7XG4gICAgICBjb25zdCBwYXJlbnROb2RlU3R5bGVQcm9wcyA9IGdldFN0eWxlUHJvcHMoZG9tLCBwYXJlbnROb2RlKTtcbiAgICAgIGNvbnN0IHZhbHVlTWlzbWF0Y2ggPSBwcm9wID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3Qgbm9kZVZhbHVlID0gKF9hID0gZG9tLmdldFN0eWxlKG5vZGUsIHByb3ApKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJztcbiAgICAgICAgY29uc3QgcGFyZW50VmFsdWUgPSAoX2IgPSBkb20uZ2V0U3R5bGUocGFyZW50Tm9kZSwgcHJvcCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnO1xuICAgICAgICByZXR1cm4gaXNOb3RFbXB0eShub2RlVmFsdWUpICYmIGlzTm90RW1wdHkocGFyZW50VmFsdWUpICYmIG5vZGVWYWx1ZSAhPT0gcGFyZW50VmFsdWU7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGV4aXN0cyhub2RlU3R5bGVQcm9wcywgbm9kZVN0eWxlUHJvcCA9PiB7XG4gICAgICAgIGNvbnN0IHByb3BFeGlzdHMgPSBwcm9wcyA9PiBleGlzdHMocHJvcHMsIHByb3AgPT4gcHJvcCA9PT0gbm9kZVN0eWxlUHJvcCk7XG4gICAgICAgIGlmICghcHJvcEV4aXN0cyhwYXJlbnROb2RlU3R5bGVQcm9wcykgJiYgcHJvcEV4aXN0cyhzaG9ydGhhbmRTdHlsZVByb3BzKSkge1xuICAgICAgICAgIGNvbnN0IGxvbmdoYW5kUHJvcHMgPSBnZXRMb25naGFuZFN0eWxlUHJvcHMocGFyZW50Tm9kZVN0eWxlUHJvcHMpO1xuICAgICAgICAgIHJldHVybiBleGlzdHMobG9uZ2hhbmRQcm9wcywgdmFsdWVNaXNtYXRjaCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlTWlzbWF0Y2gobm9kZVN0eWxlUHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCBpc0NoYXIgPSAoZm9yd2FyZCwgcHJlZGljYXRlLCBwb3MpID0+IE9wdGlvbmFsLmZyb20ocG9zLmNvbnRhaW5lcigpKS5maWx0ZXIoaXNUZXh0JDgpLmV4aXN0cyh0ZXh0ID0+IHtcbiAgICAgIGNvbnN0IGRlbHRhID0gZm9yd2FyZCA/IDAgOiAtMTtcbiAgICAgIHJldHVybiBwcmVkaWNhdGUodGV4dC5kYXRhLmNoYXJBdChwb3Mub2Zmc2V0KCkgKyBkZWx0YSkpO1xuICAgIH0pO1xuICAgIGNvbnN0IGlzQmVmb3JlU3BhY2UgPSBjdXJyeShpc0NoYXIsIHRydWUsIGlzV2hpdGVTcGFjZSk7XG4gICAgY29uc3QgaXNBZnRlclNwYWNlID0gY3VycnkoaXNDaGFyLCBmYWxzZSwgaXNXaGl0ZVNwYWNlKTtcbiAgICBjb25zdCBpc0VtcHR5VGV4dCA9IHBvcyA9PiB7XG4gICAgICBjb25zdCBjb250YWluZXIgPSBwb3MuY29udGFpbmVyKCk7XG4gICAgICByZXR1cm4gaXNUZXh0JDgoY29udGFpbmVyKSAmJiAoY29udGFpbmVyLmRhdGEubGVuZ3RoID09PSAwIHx8IGlzWndzcChjb250YWluZXIuZGF0YSkgJiYgQm9va21hcmtNYW5hZ2VyLmlzQm9va21hcmtOb2RlKGNvbnRhaW5lci5wYXJlbnROb2RlKSk7XG4gICAgfTtcbiAgICBjb25zdCBtYXRjaGVzRWxlbWVudFBvc2l0aW9uID0gKGJlZm9yZSwgcHJlZGljYXRlKSA9PiBwb3MgPT4gT3B0aW9uYWwuZnJvbShnZXRDaGlsZE5vZGVBdFJlbGF0aXZlT2Zmc2V0KGJlZm9yZSA/IDAgOiAtMSwgcG9zKSkuZmlsdGVyKHByZWRpY2F0ZSkuaXNTb21lKCk7XG4gICAgY29uc3QgaXNJbWFnZUJsb2NrID0gbm9kZSA9PiBpc0ltZyhub2RlKSAmJiBnZXQkNyhTdWdhckVsZW1lbnQuZnJvbURvbShub2RlKSwgJ2Rpc3BsYXknKSA9PT0gJ2Jsb2NrJztcbiAgICBjb25zdCBpc0NlZk5vZGUgPSBub2RlID0+IGlzQ29udGVudEVkaXRhYmxlRmFsc2UkYShub2RlKSAmJiAhaXNCb2d1c0FsbCQxKG5vZGUpO1xuICAgIGNvbnN0IGlzQmVmb3JlSW1hZ2VCbG9jayA9IG1hdGNoZXNFbGVtZW50UG9zaXRpb24odHJ1ZSwgaXNJbWFnZUJsb2NrKTtcbiAgICBjb25zdCBpc0FmdGVySW1hZ2VCbG9jayA9IG1hdGNoZXNFbGVtZW50UG9zaXRpb24oZmFsc2UsIGlzSW1hZ2VCbG9jayk7XG4gICAgY29uc3QgaXNCZWZvcmVNZWRpYSA9IG1hdGNoZXNFbGVtZW50UG9zaXRpb24odHJ1ZSwgaXNNZWRpYSQyKTtcbiAgICBjb25zdCBpc0FmdGVyTWVkaWEgPSBtYXRjaGVzRWxlbWVudFBvc2l0aW9uKGZhbHNlLCBpc01lZGlhJDIpO1xuICAgIGNvbnN0IGlzQmVmb3JlVGFibGUgPSBtYXRjaGVzRWxlbWVudFBvc2l0aW9uKHRydWUsIGlzVGFibGUkMyk7XG4gICAgY29uc3QgaXNBZnRlclRhYmxlID0gbWF0Y2hlc0VsZW1lbnRQb3NpdGlvbihmYWxzZSwgaXNUYWJsZSQzKTtcbiAgICBjb25zdCBpc0JlZm9yZUNvbnRlbnRFZGl0YWJsZUZhbHNlID0gbWF0Y2hlc0VsZW1lbnRQb3NpdGlvbih0cnVlLCBpc0NlZk5vZGUpO1xuICAgIGNvbnN0IGlzQWZ0ZXJDb250ZW50RWRpdGFibGVGYWxzZSA9IG1hdGNoZXNFbGVtZW50UG9zaXRpb24oZmFsc2UsIGlzQ2VmTm9kZSk7XG5cbiAgICBjb25zdCBnZXRMYXN0Q2hpbGRyZW4gPSBlbG0gPT4ge1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSBbXTtcbiAgICAgIGxldCByYXdOb2RlID0gZWxtLmRvbTtcbiAgICAgIHdoaWxlIChyYXdOb2RlKSB7XG4gICAgICAgIGNoaWxkcmVuLnB1c2goU3VnYXJFbGVtZW50LmZyb21Eb20ocmF3Tm9kZSkpO1xuICAgICAgICByYXdOb2RlID0gcmF3Tm9kZS5sYXN0Q2hpbGQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgfTtcbiAgICBjb25zdCByZW1vdmVUcmFpbGluZ0JyID0gZWxtID0+IHtcbiAgICAgIGNvbnN0IGFsbEJycyA9IGRlc2NlbmRhbnRzKGVsbSwgJ2JyJyk7XG4gICAgICBjb25zdCBicnMgPSBmaWx0ZXIkNihnZXRMYXN0Q2hpbGRyZW4oZWxtKS5zbGljZSgtMSksIGlzQnIkNCk7XG4gICAgICBpZiAoYWxsQnJzLmxlbmd0aCA9PT0gYnJzLmxlbmd0aCkge1xuICAgICAgICBlYWNoJGcoYnJzLCByZW1vdmUkNSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBmaWxsV2l0aFBhZGRpbmdCciA9IGVsbSA9PiB7XG4gICAgICBlbXB0eShlbG0pO1xuICAgICAgYXBwZW5kJDEoZWxtLCBTdWdhckVsZW1lbnQuZnJvbUh0bWwoJzxiciBkYXRhLW1jZS1ib2d1cz1cIjFcIj4nKSk7XG4gICAgfTtcbiAgICBjb25zdCB0cmltQmxvY2tUcmFpbGluZ0JyID0gZWxtID0+IHtcbiAgICAgIGxhc3RDaGlsZChlbG0pLmVhY2gobGFzdENoaWxkID0+IHtcbiAgICAgICAgcHJldlNpYmxpbmcobGFzdENoaWxkKS5lYWNoKGxhc3RDaGlsZFByZXZTaWJsaW5nID0+IHtcbiAgICAgICAgICBpZiAoaXNCbG9jayQyKGVsbSkgJiYgaXNCciQ0KGxhc3RDaGlsZCkgJiYgaXNCbG9jayQyKGxhc3RDaGlsZFByZXZTaWJsaW5nKSkge1xuICAgICAgICAgICAgcmVtb3ZlJDUobGFzdENoaWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGRyb3BMYXN0ID0geHMgPT4geHMuc2xpY2UoMCwgLTEpO1xuICAgIGNvbnN0IHBhcmVudHNVbnRpbCA9IChzdGFydCwgcm9vdCwgcHJlZGljYXRlKSA9PiB7XG4gICAgICBpZiAoY29udGFpbnMocm9vdCwgc3RhcnQpKSB7XG4gICAgICAgIHJldHVybiBkcm9wTGFzdChwYXJlbnRzJDEoc3RhcnQsIGVsbSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHByZWRpY2F0ZShlbG0pIHx8IGVxKGVsbSwgcm9vdCk7XG4gICAgICAgIH0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHBhcmVudHMgPSAoc3RhcnQsIHJvb3QpID0+IHBhcmVudHNVbnRpbChzdGFydCwgcm9vdCwgbmV2ZXIpO1xuICAgIGNvbnN0IHBhcmVudHNBbmRTZWxmID0gKHN0YXJ0LCByb290KSA9PiBbc3RhcnRdLmNvbmNhdChwYXJlbnRzKHN0YXJ0LCByb290KSk7XG5cbiAgICBjb25zdCBuYXZpZ2F0ZUlnbm9yZUVtcHR5VGV4dE5vZGVzID0gKGZvcndhcmQsIHJvb3QsIGZyb20pID0+IG5hdmlnYXRlSWdub3JlKGZvcndhcmQsIHJvb3QsIGZyb20sIGlzRW1wdHlUZXh0KTtcbiAgICBjb25zdCBnZXRDbG9zZXN0QmxvY2skMSA9IChyb290LCBwb3MpID0+IGZpbmQkMihwYXJlbnRzQW5kU2VsZihTdWdhckVsZW1lbnQuZnJvbURvbShwb3MuY29udGFpbmVyKCkpLCByb290KSwgaXNCbG9jayQyKTtcbiAgICBjb25zdCBpc0F0QmVmb3JlQWZ0ZXJCbG9ja0JvdW5kYXJ5ID0gKGZvcndhcmQsIHJvb3QsIHBvcykgPT4gbmF2aWdhdGVJZ25vcmVFbXB0eVRleHROb2Rlcyhmb3J3YXJkLCByb290LmRvbSwgcG9zKS5mb3JhbGwobmV3UG9zID0+IGdldENsb3Nlc3RCbG9jayQxKHJvb3QsIHBvcykuZm9sZCgoKSA9PiBpc0luU2FtZUJsb2NrKG5ld1BvcywgcG9zLCByb290LmRvbSkgPT09IGZhbHNlLCBmcm9tQmxvY2sgPT4gaXNJblNhbWVCbG9jayhuZXdQb3MsIHBvcywgcm9vdC5kb20pID09PSBmYWxzZSAmJiBjb250YWlucyhmcm9tQmxvY2ssIFN1Z2FyRWxlbWVudC5mcm9tRG9tKG5ld1Bvcy5jb250YWluZXIoKSkpKSk7XG4gICAgY29uc3QgaXNBdEJsb2NrQm91bmRhcnkgPSAoZm9yd2FyZCwgcm9vdCwgcG9zKSA9PiBnZXRDbG9zZXN0QmxvY2skMShyb290LCBwb3MpLmZvbGQoKCkgPT4gbmF2aWdhdGVJZ25vcmVFbXB0eVRleHROb2Rlcyhmb3J3YXJkLCByb290LmRvbSwgcG9zKS5mb3JhbGwobmV3UG9zID0+IGlzSW5TYW1lQmxvY2sobmV3UG9zLCBwb3MsIHJvb3QuZG9tKSA9PT0gZmFsc2UpLCBwYXJlbnQgPT4gbmF2aWdhdGVJZ25vcmVFbXB0eVRleHROb2Rlcyhmb3J3YXJkLCBwYXJlbnQuZG9tLCBwb3MpLmlzTm9uZSgpKTtcbiAgICBjb25zdCBpc0F0U3RhcnRPZkJsb2NrID0gY3VycnkoaXNBdEJsb2NrQm91bmRhcnksIGZhbHNlKTtcbiAgICBjb25zdCBpc0F0RW5kT2ZCbG9jayA9IGN1cnJ5KGlzQXRCbG9ja0JvdW5kYXJ5LCB0cnVlKTtcbiAgICBjb25zdCBpc0JlZm9yZUJsb2NrID0gY3VycnkoaXNBdEJlZm9yZUFmdGVyQmxvY2tCb3VuZGFyeSwgZmFsc2UpO1xuICAgIGNvbnN0IGlzQWZ0ZXJCbG9jayA9IGN1cnJ5KGlzQXRCZWZvcmVBZnRlckJsb2NrQm91bmRhcnksIHRydWUpO1xuXG4gICAgY29uc3QgaXNCciA9IHBvcyA9PiBnZXRFbGVtZW50RnJvbVBvc2l0aW9uKHBvcykuZXhpc3RzKGlzQnIkNCk7XG4gICAgY29uc3QgZmluZEJyID0gKGZvcndhcmQsIHJvb3QsIHBvcykgPT4ge1xuICAgICAgY29uc3QgcGFyZW50QmxvY2tzID0gZmlsdGVyJDYocGFyZW50c0FuZFNlbGYoU3VnYXJFbGVtZW50LmZyb21Eb20ocG9zLmNvbnRhaW5lcigpKSwgcm9vdCksIGlzQmxvY2skMik7XG4gICAgICBjb25zdCBzY29wZSA9IGhlYWQocGFyZW50QmxvY2tzKS5nZXRPcihyb290KTtcbiAgICAgIHJldHVybiBmcm9tUG9zaXRpb24oZm9yd2FyZCwgc2NvcGUuZG9tLCBwb3MpLmZpbHRlcihpc0JyKTtcbiAgICB9O1xuICAgIGNvbnN0IGlzQmVmb3JlQnIkMSA9IChyb290LCBwb3MpID0+IGdldEVsZW1lbnRGcm9tUG9zaXRpb24ocG9zKS5leGlzdHMoaXNCciQ0KSB8fCBmaW5kQnIodHJ1ZSwgcm9vdCwgcG9zKS5pc1NvbWUoKTtcbiAgICBjb25zdCBpc0FmdGVyQnIgPSAocm9vdCwgcG9zKSA9PiBnZXRFbGVtZW50RnJvbVByZXZQb3NpdGlvbihwb3MpLmV4aXN0cyhpc0JyJDQpIHx8IGZpbmRCcihmYWxzZSwgcm9vdCwgcG9zKS5pc1NvbWUoKTtcbiAgICBjb25zdCBmaW5kUHJldmlvdXNCciA9IGN1cnJ5KGZpbmRCciwgZmFsc2UpO1xuICAgIGNvbnN0IGZpbmROZXh0QnIgPSBjdXJyeShmaW5kQnIsIHRydWUpO1xuXG4gICAgY29uc3QgaXNJbk1pZGRsZU9mVGV4dCA9IHBvcyA9PiBDYXJldFBvc2l0aW9uLmlzVGV4dFBvc2l0aW9uKHBvcykgJiYgIXBvcy5pc0F0U3RhcnQoKSAmJiAhcG9zLmlzQXRFbmQoKTtcbiAgICBjb25zdCBnZXRDbG9zZXN0QmxvY2sgPSAocm9vdCwgcG9zKSA9PiB7XG4gICAgICBjb25zdCBwYXJlbnRCbG9ja3MgPSBmaWx0ZXIkNihwYXJlbnRzQW5kU2VsZihTdWdhckVsZW1lbnQuZnJvbURvbShwb3MuY29udGFpbmVyKCkpLCByb290KSwgaXNCbG9jayQyKTtcbiAgICAgIHJldHVybiBoZWFkKHBhcmVudEJsb2NrcykuZ2V0T3Iocm9vdCk7XG4gICAgfTtcbiAgICBjb25zdCBoYXNTcGFjZUJlZm9yZSA9IChyb290LCBwb3MpID0+IHtcbiAgICAgIGlmIChpc0luTWlkZGxlT2ZUZXh0KHBvcykpIHtcbiAgICAgICAgcmV0dXJuIGlzQWZ0ZXJTcGFjZShwb3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGlzQWZ0ZXJTcGFjZShwb3MpIHx8IHByZXZQb3NpdGlvbihnZXRDbG9zZXN0QmxvY2socm9vdCwgcG9zKS5kb20sIHBvcykuZXhpc3RzKGlzQWZ0ZXJTcGFjZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBoYXNTcGFjZUFmdGVyID0gKHJvb3QsIHBvcykgPT4ge1xuICAgICAgaWYgKGlzSW5NaWRkbGVPZlRleHQocG9zKSkge1xuICAgICAgICByZXR1cm4gaXNCZWZvcmVTcGFjZShwb3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGlzQmVmb3JlU3BhY2UocG9zKSB8fCBuZXh0UG9zaXRpb24oZ2V0Q2xvc2VzdEJsb2NrKHJvb3QsIHBvcykuZG9tLCBwb3MpLmV4aXN0cyhpc0JlZm9yZVNwYWNlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGlzUHJlVmFsdWUgPSB2YWx1ZSA9PiBjb250YWlucyQyKFtcbiAgICAgICdwcmUnLFxuICAgICAgJ3ByZS13cmFwJ1xuICAgIF0sIHZhbHVlKTtcbiAgICBjb25zdCBpc0luUHJlID0gcG9zID0+IGdldEVsZW1lbnRGcm9tUG9zaXRpb24ocG9zKS5iaW5kKGVsbSA9PiBjbG9zZXN0JDQoZWxtLCBpc0VsZW1lbnQkNykpLmV4aXN0cyhlbG0gPT4gaXNQcmVWYWx1ZShnZXQkNyhlbG0sICd3aGl0ZS1zcGFjZScpKSk7XG4gICAgY29uc3QgaXNBdEJlZ2lubmluZ09mQm9keSA9IChyb290LCBwb3MpID0+IHByZXZQb3NpdGlvbihyb290LmRvbSwgcG9zKS5pc05vbmUoKTtcbiAgICBjb25zdCBpc0F0RW5kT2ZCb2R5ID0gKHJvb3QsIHBvcykgPT4gbmV4dFBvc2l0aW9uKHJvb3QuZG9tLCBwb3MpLmlzTm9uZSgpO1xuICAgIGNvbnN0IGlzQXRMaW5lQm91bmRhcnkgPSAocm9vdCwgcG9zKSA9PiBpc0F0QmVnaW5uaW5nT2ZCb2R5KHJvb3QsIHBvcykgfHwgaXNBdEVuZE9mQm9keShyb290LCBwb3MpIHx8IGlzQXRTdGFydE9mQmxvY2socm9vdCwgcG9zKSB8fCBpc0F0RW5kT2ZCbG9jayhyb290LCBwb3MpIHx8IGlzQWZ0ZXJCcihyb290LCBwb3MpIHx8IGlzQmVmb3JlQnIkMShyb290LCBwb3MpO1xuICAgIGNvbnN0IG5lZWRzVG9IYXZlTmJzcCA9IChyb290LCBwb3MpID0+IHtcbiAgICAgIGlmIChpc0luUHJlKHBvcykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGlzQXRMaW5lQm91bmRhcnkocm9vdCwgcG9zKSB8fCBoYXNTcGFjZUJlZm9yZShyb290LCBwb3MpIHx8IGhhc1NwYWNlQWZ0ZXIocm9vdCwgcG9zKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG5lZWRzVG9CZU5ic3BMZWZ0ID0gKHJvb3QsIHBvcykgPT4ge1xuICAgICAgaWYgKGlzSW5QcmUocG9zKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaXNBdFN0YXJ0T2ZCbG9jayhyb290LCBwb3MpIHx8IGlzQmVmb3JlQmxvY2socm9vdCwgcG9zKSB8fCBpc0FmdGVyQnIocm9vdCwgcG9zKSB8fCBoYXNTcGFjZUJlZm9yZShyb290LCBwb3MpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgbGVhblJpZ2h0ID0gcG9zID0+IHtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHBvcy5jb250YWluZXIoKTtcbiAgICAgIGNvbnN0IG9mZnNldCA9IHBvcy5vZmZzZXQoKTtcbiAgICAgIGlmIChpc1RleHQkOChjb250YWluZXIpICYmIG9mZnNldCA8IGNvbnRhaW5lci5kYXRhLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gQ2FyZXRQb3NpdGlvbihjb250YWluZXIsIG9mZnNldCArIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG5lZWRzVG9CZU5ic3BSaWdodCA9IChyb290LCBwb3MpID0+IHtcbiAgICAgIGlmIChpc0luUHJlKHBvcykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGlzQXRFbmRPZkJsb2NrKHJvb3QsIHBvcykgfHwgaXNBZnRlckJsb2NrKHJvb3QsIHBvcykgfHwgaXNCZWZvcmVCciQxKHJvb3QsIHBvcykgfHwgaGFzU3BhY2VBZnRlcihyb290LCBwb3MpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgbmVlZHNUb0JlTmJzcCA9IChyb290LCBwb3MpID0+IG5lZWRzVG9CZU5ic3BMZWZ0KHJvb3QsIHBvcykgfHwgbmVlZHNUb0JlTmJzcFJpZ2h0KHJvb3QsIGxlYW5SaWdodChwb3MpKTtcbiAgICBjb25zdCBpc05ic3BBdCA9ICh0ZXh0LCBvZmZzZXQpID0+IGlzTmJzcCh0ZXh0LmNoYXJBdChvZmZzZXQpKTtcbiAgICBjb25zdCBoYXNOYnNwID0gcG9zID0+IHtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHBvcy5jb250YWluZXIoKTtcbiAgICAgIHJldHVybiBpc1RleHQkOChjb250YWluZXIpICYmIGNvbnRhaW5zJDEoY29udGFpbmVyLmRhdGEsIG5ic3ApO1xuICAgIH07XG4gICAgY29uc3Qgbm9ybWFsaXplTmJzcE1pZGRsZSA9IHRleHQgPT4ge1xuICAgICAgY29uc3QgY2hhcnMgPSB0ZXh0LnNwbGl0KCcnKTtcbiAgICAgIHJldHVybiBtYXAkMyhjaGFycywgKGNociwgaSkgPT4ge1xuICAgICAgICBpZiAoaXNOYnNwKGNocikgJiYgaSA+IDAgJiYgaSA8IGNoYXJzLmxlbmd0aCAtIDEgJiYgaXNDb250ZW50KGNoYXJzW2kgLSAxXSkgJiYgaXNDb250ZW50KGNoYXJzW2kgKyAxXSkpIHtcbiAgICAgICAgICByZXR1cm4gJyAnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBjaHI7XG4gICAgICAgIH1cbiAgICAgIH0pLmpvaW4oJycpO1xuICAgIH07XG4gICAgY29uc3Qgbm9ybWFsaXplTmJzcEF0U3RhcnQgPSAocm9vdCwgbm9kZSkgPT4ge1xuICAgICAgY29uc3QgdGV4dCA9IG5vZGUuZGF0YTtcbiAgICAgIGNvbnN0IGZpcnN0UG9zID0gQ2FyZXRQb3NpdGlvbihub2RlLCAwKTtcbiAgICAgIGlmIChpc05ic3BBdCh0ZXh0LCAwKSAmJiAhbmVlZHNUb0JlTmJzcChyb290LCBmaXJzdFBvcykpIHtcbiAgICAgICAgbm9kZS5kYXRhID0gJyAnICsgdGV4dC5zbGljZSgxKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBub3JtYWxpemVOYnNwSW5NaWRkbGVPZlRleHROb2RlID0gbm9kZSA9PiB7XG4gICAgICBjb25zdCB0ZXh0ID0gbm9kZS5kYXRhO1xuICAgICAgY29uc3QgbmV3VGV4dCA9IG5vcm1hbGl6ZU5ic3BNaWRkbGUodGV4dCk7XG4gICAgICBpZiAobmV3VGV4dCAhPT0gdGV4dCkge1xuICAgICAgICBub2RlLmRhdGEgPSBuZXdUZXh0O1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG5vcm1hbGl6ZU5ic3BBdEVuZCA9IChyb290LCBub2RlKSA9PiB7XG4gICAgICBjb25zdCB0ZXh0ID0gbm9kZS5kYXRhO1xuICAgICAgY29uc3QgbGFzdFBvcyA9IENhcmV0UG9zaXRpb24obm9kZSwgdGV4dC5sZW5ndGggLSAxKTtcbiAgICAgIGlmIChpc05ic3BBdCh0ZXh0LCB0ZXh0Lmxlbmd0aCAtIDEpICYmICFuZWVkc1RvQmVOYnNwKHJvb3QsIGxhc3RQb3MpKSB7XG4gICAgICAgIG5vZGUuZGF0YSA9IHRleHQuc2xpY2UoMCwgLTEpICsgJyAnO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG5vcm1hbGl6ZU5ic3BzID0gKHJvb3QsIHBvcykgPT4gT3B0aW9uYWwuc29tZShwb3MpLmZpbHRlcihoYXNOYnNwKS5iaW5kKHBvcyA9PiB7XG4gICAgICBjb25zdCBjb250YWluZXIgPSBwb3MuY29udGFpbmVyKCk7XG4gICAgICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplTmJzcEF0U3RhcnQocm9vdCwgY29udGFpbmVyKSB8fCBub3JtYWxpemVOYnNwSW5NaWRkbGVPZlRleHROb2RlKGNvbnRhaW5lcikgfHwgbm9ybWFsaXplTmJzcEF0RW5kKHJvb3QsIGNvbnRhaW5lcik7XG4gICAgICByZXR1cm4gbm9ybWFsaXplZCA/IE9wdGlvbmFsLnNvbWUocG9zKSA6IE9wdGlvbmFsLm5vbmUoKTtcbiAgICB9KTtcbiAgICBjb25zdCBub3JtYWxpemVOYnNwc0luRWRpdG9yID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IHJvb3QgPSBTdWdhckVsZW1lbnQuZnJvbURvbShlZGl0b3IuZ2V0Qm9keSgpKTtcbiAgICAgIGlmIChlZGl0b3Iuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgICAgbm9ybWFsaXplTmJzcHMocm9vdCwgQ2FyZXRQb3NpdGlvbi5mcm9tUmFuZ2VTdGFydChlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpKSkuZWFjaChwb3MgPT4ge1xuICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2V0Um5nKHBvcy50b1JhbmdlKCkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3Qgbm9ybWFsaXplJDEgPSAobm9kZSwgb2Zmc2V0LCBjb3VudCkgPT4ge1xuICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVsbSA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKG5vZGUpO1xuICAgICAgY29uc3Qgcm9vdCA9IGFuY2VzdG9yJDMoZWxtLCBpc0Jsb2NrJDIpLmdldE9yKGVsbSk7XG4gICAgICBjb25zdCB3aGl0ZXNwYWNlID0gbm9kZS5kYXRhLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgY291bnQpO1xuICAgICAgY29uc3QgaXNFbmRPZkNvbnRlbnQgPSBvZmZzZXQgKyBjb3VudCA+PSBub2RlLmRhdGEubGVuZ3RoICYmIG5lZWRzVG9CZU5ic3BSaWdodChyb290LCBDYXJldFBvc2l0aW9uKG5vZGUsIG5vZGUuZGF0YS5sZW5ndGgpKTtcbiAgICAgIGNvbnN0IGlzU3RhcnRPZkNvbnRlbnQgPSBvZmZzZXQgPT09IDAgJiYgbmVlZHNUb0JlTmJzcExlZnQocm9vdCwgQ2FyZXRQb3NpdGlvbihub2RlLCAwKSk7XG4gICAgICBub2RlLnJlcGxhY2VEYXRhKG9mZnNldCwgY291bnQsIG5vcm1hbGl6ZSQ0KHdoaXRlc3BhY2UsIDQsIGlzU3RhcnRPZkNvbnRlbnQsIGlzRW5kT2ZDb250ZW50KSk7XG4gICAgfTtcbiAgICBjb25zdCBub3JtYWxpemVXaGl0ZXNwYWNlQWZ0ZXIgPSAobm9kZSwgb2Zmc2V0KSA9PiB7XG4gICAgICBjb25zdCBjb250ZW50ID0gbm9kZS5kYXRhLnNsaWNlKG9mZnNldCk7XG4gICAgICBjb25zdCB3aGl0ZXNwYWNlQ291bnQgPSBjb250ZW50Lmxlbmd0aCAtIGxUcmltKGNvbnRlbnQpLmxlbmd0aDtcbiAgICAgIG5vcm1hbGl6ZSQxKG5vZGUsIG9mZnNldCwgd2hpdGVzcGFjZUNvdW50KTtcbiAgICB9O1xuICAgIGNvbnN0IG5vcm1hbGl6ZVdoaXRlc3BhY2VCZWZvcmUgPSAobm9kZSwgb2Zmc2V0KSA9PiB7XG4gICAgICBjb25zdCBjb250ZW50ID0gbm9kZS5kYXRhLnNsaWNlKDAsIG9mZnNldCk7XG4gICAgICBjb25zdCB3aGl0ZXNwYWNlQ291bnQgPSBjb250ZW50Lmxlbmd0aCAtIHJUcmltKGNvbnRlbnQpLmxlbmd0aDtcbiAgICAgIG5vcm1hbGl6ZSQxKG5vZGUsIG9mZnNldCAtIHdoaXRlc3BhY2VDb3VudCwgd2hpdGVzcGFjZUNvdW50KTtcbiAgICB9O1xuICAgIGNvbnN0IG1lcmdlVGV4dE5vZGVzID0gKHByZXZOb2RlLCBuZXh0Tm9kZSwgbm9ybWFsaXplV2hpdGVzcGFjZSwgbWVyZ2VUb1ByZXYgPSB0cnVlKSA9PiB7XG4gICAgICBjb25zdCB3aGl0ZXNwYWNlT2Zmc2V0ID0gclRyaW0ocHJldk5vZGUuZGF0YSkubGVuZ3RoO1xuICAgICAgY29uc3QgbmV3Tm9kZSA9IG1lcmdlVG9QcmV2ID8gcHJldk5vZGUgOiBuZXh0Tm9kZTtcbiAgICAgIGNvbnN0IHJlbW92ZU5vZGUgPSBtZXJnZVRvUHJldiA/IG5leHROb2RlIDogcHJldk5vZGU7XG4gICAgICBpZiAobWVyZ2VUb1ByZXYpIHtcbiAgICAgICAgbmV3Tm9kZS5hcHBlbmREYXRhKHJlbW92ZU5vZGUuZGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdOb2RlLmluc2VydERhdGEoMCwgcmVtb3ZlTm9kZS5kYXRhKTtcbiAgICAgIH1cbiAgICAgIHJlbW92ZSQ1KFN1Z2FyRWxlbWVudC5mcm9tRG9tKHJlbW92ZU5vZGUpKTtcbiAgICAgIGlmIChub3JtYWxpemVXaGl0ZXNwYWNlKSB7XG4gICAgICAgIG5vcm1hbGl6ZVdoaXRlc3BhY2VBZnRlcihuZXdOb2RlLCB3aGl0ZXNwYWNlT2Zmc2V0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdOb2RlO1xuICAgIH07XG5cbiAgICBjb25zdCBuZWVkc1JlcG9zaXRpb24gPSAocG9zLCBlbG0pID0+IHtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHBvcy5jb250YWluZXIoKTtcbiAgICAgIGNvbnN0IG9mZnNldCA9IHBvcy5vZmZzZXQoKTtcbiAgICAgIHJldHVybiBDYXJldFBvc2l0aW9uLmlzVGV4dFBvc2l0aW9uKHBvcykgPT09IGZhbHNlICYmIGNvbnRhaW5lciA9PT0gZWxtLnBhcmVudE5vZGUgJiYgb2Zmc2V0ID4gQ2FyZXRQb3NpdGlvbi5iZWZvcmUoZWxtKS5vZmZzZXQoKTtcbiAgICB9O1xuICAgIGNvbnN0IHJlcG9zaXRpb24gPSAoZWxtLCBwb3MpID0+IG5lZWRzUmVwb3NpdGlvbihwb3MsIGVsbSkgPyBDYXJldFBvc2l0aW9uKHBvcy5jb250YWluZXIoKSwgcG9zLm9mZnNldCgpIC0gMSkgOiBwb3M7XG4gICAgY29uc3QgYmVmb3JlT3JTdGFydE9mID0gbm9kZSA9PiBpc1RleHQkOChub2RlKSA/IENhcmV0UG9zaXRpb24obm9kZSwgMCkgOiBDYXJldFBvc2l0aW9uLmJlZm9yZShub2RlKTtcbiAgICBjb25zdCBhZnRlck9yRW5kT2YgPSBub2RlID0+IGlzVGV4dCQ4KG5vZGUpID8gQ2FyZXRQb3NpdGlvbihub2RlLCBub2RlLmRhdGEubGVuZ3RoKSA6IENhcmV0UG9zaXRpb24uYWZ0ZXIobm9kZSk7XG4gICAgY29uc3QgZ2V0UHJldmlvdXNTaWJsaW5nQ2FyZXRQb3NpdGlvbiA9IGVsbSA9PiB7XG4gICAgICBpZiAoaXNDYXJldENhbmRpZGF0ZSQzKGVsbS5wcmV2aW91c1NpYmxpbmcpKSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKGFmdGVyT3JFbmRPZihlbG0ucHJldmlvdXNTaWJsaW5nKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZWxtLnByZXZpb3VzU2libGluZyA/IGxhc3RQb3NpdGlvbkluKGVsbS5wcmV2aW91c1NpYmxpbmcpIDogT3B0aW9uYWwubm9uZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZ2V0TmV4dFNpYmxpbmdDYXJldFBvc2l0aW9uID0gZWxtID0+IHtcbiAgICAgIGlmIChpc0NhcmV0Q2FuZGlkYXRlJDMoZWxtLm5leHRTaWJsaW5nKSkge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZShiZWZvcmVPclN0YXJ0T2YoZWxtLm5leHRTaWJsaW5nKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZWxtLm5leHRTaWJsaW5nID8gZmlyc3RQb3NpdGlvbkluKGVsbS5uZXh0U2libGluZykgOiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBmaW5kQ2FyZXRQb3NpdGlvbkJhY2t3YXJkc0Zyb21FbG0gPSAocm9vdEVsZW1lbnQsIGVsbSkgPT4ge1xuICAgICAgY29uc3Qgc3RhcnRQb3NpdGlvbiA9IENhcmV0UG9zaXRpb24uYmVmb3JlKGVsbS5wcmV2aW91c1NpYmxpbmcgPyBlbG0ucHJldmlvdXNTaWJsaW5nIDogZWxtLnBhcmVudE5vZGUpO1xuICAgICAgcmV0dXJuIHByZXZQb3NpdGlvbihyb290RWxlbWVudCwgc3RhcnRQb3NpdGlvbikuZm9sZCgoKSA9PiBuZXh0UG9zaXRpb24ocm9vdEVsZW1lbnQsIENhcmV0UG9zaXRpb24uYWZ0ZXIoZWxtKSksIE9wdGlvbmFsLnNvbWUpO1xuICAgIH07XG4gICAgY29uc3QgZmluZENhcmV0UG9zaXRpb25Gb3J3YXJkc0Zyb21FbG0gPSAocm9vdEVsZW1lbnQsIGVsbSkgPT4gbmV4dFBvc2l0aW9uKHJvb3RFbGVtZW50LCBDYXJldFBvc2l0aW9uLmFmdGVyKGVsbSkpLmZvbGQoKCkgPT4gcHJldlBvc2l0aW9uKHJvb3RFbGVtZW50LCBDYXJldFBvc2l0aW9uLmJlZm9yZShlbG0pKSwgT3B0aW9uYWwuc29tZSk7XG4gICAgY29uc3QgZmluZENhcmV0UG9zaXRpb25CYWNrd2FyZHMgPSAocm9vdEVsZW1lbnQsIGVsbSkgPT4gZ2V0UHJldmlvdXNTaWJsaW5nQ2FyZXRQb3NpdGlvbihlbG0pLm9yVGh1bmsoKCkgPT4gZ2V0TmV4dFNpYmxpbmdDYXJldFBvc2l0aW9uKGVsbSkpLm9yVGh1bmsoKCkgPT4gZmluZENhcmV0UG9zaXRpb25CYWNrd2FyZHNGcm9tRWxtKHJvb3RFbGVtZW50LCBlbG0pKTtcbiAgICBjb25zdCBmaW5kQ2FyZXRQb3NpdGlvbkZvcndhcmQgPSAocm9vdEVsZW1lbnQsIGVsbSkgPT4gZ2V0TmV4dFNpYmxpbmdDYXJldFBvc2l0aW9uKGVsbSkub3JUaHVuaygoKSA9PiBnZXRQcmV2aW91c1NpYmxpbmdDYXJldFBvc2l0aW9uKGVsbSkpLm9yVGh1bmsoKCkgPT4gZmluZENhcmV0UG9zaXRpb25Gb3J3YXJkc0Zyb21FbG0ocm9vdEVsZW1lbnQsIGVsbSkpO1xuICAgIGNvbnN0IGZpbmRDYXJldFBvc2l0aW9uID0gKGZvcndhcmQsIHJvb3RFbGVtZW50LCBlbG0pID0+IGZvcndhcmQgPyBmaW5kQ2FyZXRQb3NpdGlvbkZvcndhcmQocm9vdEVsZW1lbnQsIGVsbSkgOiBmaW5kQ2FyZXRQb3NpdGlvbkJhY2t3YXJkcyhyb290RWxlbWVudCwgZWxtKTtcbiAgICBjb25zdCBmaW5kQ2FyZXRQb3NPdXRzaWRlRWxtQWZ0ZXJEZWxldGUgPSAoZm9yd2FyZCwgcm9vdEVsZW1lbnQsIGVsbSkgPT4gZmluZENhcmV0UG9zaXRpb24oZm9yd2FyZCwgcm9vdEVsZW1lbnQsIGVsbSkubWFwKGN1cnJ5KHJlcG9zaXRpb24sIGVsbSkpO1xuICAgIGNvbnN0IHNldFNlbGVjdGlvbiQxID0gKGVkaXRvciwgZm9yd2FyZCwgcG9zKSA9PiB7XG4gICAgICBwb3MuZm9sZCgoKSA9PiB7XG4gICAgICAgIGVkaXRvci5mb2N1cygpO1xuICAgICAgfSwgcG9zID0+IHtcbiAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZXRSbmcocG9zLnRvUmFuZ2UoKSwgZm9yd2FyZCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGVxUmF3Tm9kZSA9IHJhd05vZGUgPT4gZWxtID0+IGVsbS5kb20gPT09IHJhd05vZGU7XG4gICAgY29uc3QgaXNCbG9jayA9IChlZGl0b3IsIGVsbSkgPT4gZWxtICYmIGhhcyQyKGVkaXRvci5zY2hlbWEuZ2V0QmxvY2tFbGVtZW50cygpLCBuYW1lKGVsbSkpO1xuICAgIGNvbnN0IHBhZGRFbXB0eUJsb2NrID0gZWxtID0+IHtcbiAgICAgIGlmIChpc0VtcHR5JDIoZWxtKSkge1xuICAgICAgICBjb25zdCBiciA9IFN1Z2FyRWxlbWVudC5mcm9tSHRtbCgnPGJyIGRhdGEtbWNlLWJvZ3VzPVwiMVwiPicpO1xuICAgICAgICBlbXB0eShlbG0pO1xuICAgICAgICBhcHBlbmQkMShlbG0sIGJyKTtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoQ2FyZXRQb3NpdGlvbi5iZWZvcmUoYnIuZG9tKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZGVsZXRlTm9ybWFsaXplZCA9IChlbG0sIGFmdGVyRGVsZXRlUG9zT3B0LCBub3JtYWxpemVXaGl0ZXNwYWNlKSA9PiB7XG4gICAgICBjb25zdCBwcmV2VGV4dE9wdCA9IHByZXZTaWJsaW5nKGVsbSkuZmlsdGVyKGlzVGV4dCQ5KTtcbiAgICAgIGNvbnN0IG5leHRUZXh0T3B0ID0gbmV4dFNpYmxpbmcoZWxtKS5maWx0ZXIoaXNUZXh0JDkpO1xuICAgICAgcmVtb3ZlJDUoZWxtKTtcbiAgICAgIHJldHVybiBsaWZ0MyhwcmV2VGV4dE9wdCwgbmV4dFRleHRPcHQsIGFmdGVyRGVsZXRlUG9zT3B0LCAocHJldiwgbmV4dCwgcG9zKSA9PiB7XG4gICAgICAgIGNvbnN0IHByZXZOb2RlID0gcHJldi5kb20sIG5leHROb2RlID0gbmV4dC5kb207XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHByZXZOb2RlLmRhdGEubGVuZ3RoO1xuICAgICAgICBtZXJnZVRleHROb2RlcyhwcmV2Tm9kZSwgbmV4dE5vZGUsIG5vcm1hbGl6ZVdoaXRlc3BhY2UpO1xuICAgICAgICByZXR1cm4gcG9zLmNvbnRhaW5lcigpID09PSBuZXh0Tm9kZSA/IENhcmV0UG9zaXRpb24ocHJldk5vZGUsIG9mZnNldCkgOiBwb3M7XG4gICAgICB9KS5vclRodW5rKCgpID0+IHtcbiAgICAgICAgaWYgKG5vcm1hbGl6ZVdoaXRlc3BhY2UpIHtcbiAgICAgICAgICBwcmV2VGV4dE9wdC5lYWNoKGVsbSA9PiBub3JtYWxpemVXaGl0ZXNwYWNlQmVmb3JlKGVsbS5kb20sIGVsbS5kb20ubGVuZ3RoKSk7XG4gICAgICAgICAgbmV4dFRleHRPcHQuZWFjaChlbG0gPT4gbm9ybWFsaXplV2hpdGVzcGFjZUFmdGVyKGVsbS5kb20sIDApKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWZ0ZXJEZWxldGVQb3NPcHQ7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGlzSW5saW5lRWxlbWVudCA9IChlZGl0b3IsIGVsZW1lbnQpID0+IGhhcyQyKGVkaXRvci5zY2hlbWEuZ2V0VGV4dElubGluZUVsZW1lbnRzKCksIG5hbWUoZWxlbWVudCkpO1xuICAgIGNvbnN0IGRlbGV0ZUVsZW1lbnQkMiA9IChlZGl0b3IsIGZvcndhcmQsIGVsbSwgbW92ZUNhcmV0ID0gdHJ1ZSkgPT4ge1xuICAgICAgY29uc3QgYWZ0ZXJEZWxldGVQb3MgPSBmaW5kQ2FyZXRQb3NPdXRzaWRlRWxtQWZ0ZXJEZWxldGUoZm9yd2FyZCwgZWRpdG9yLmdldEJvZHkoKSwgZWxtLmRvbSk7XG4gICAgICBjb25zdCBwYXJlbnRCbG9jayA9IGFuY2VzdG9yJDMoZWxtLCBjdXJyeShpc0Jsb2NrLCBlZGl0b3IpLCBlcVJhd05vZGUoZWRpdG9yLmdldEJvZHkoKSkpO1xuICAgICAgY29uc3Qgbm9ybWFsaXplZEFmdGVyRGVsZXRlUG9zID0gZGVsZXRlTm9ybWFsaXplZChlbG0sIGFmdGVyRGVsZXRlUG9zLCBpc0lubGluZUVsZW1lbnQoZWRpdG9yLCBlbG0pKTtcbiAgICAgIGlmIChlZGl0b3IuZG9tLmlzRW1wdHkoZWRpdG9yLmdldEJvZHkoKSkpIHtcbiAgICAgICAgZWRpdG9yLnNldENvbnRlbnQoJycpO1xuICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNldEN1cnNvckxvY2F0aW9uKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJlbnRCbG9jay5iaW5kKHBhZGRFbXB0eUJsb2NrKS5mb2xkKCgpID0+IHtcbiAgICAgICAgICBpZiAobW92ZUNhcmV0KSB7XG4gICAgICAgICAgICBzZXRTZWxlY3Rpb24kMShlZGl0b3IsIGZvcndhcmQsIG5vcm1hbGl6ZWRBZnRlckRlbGV0ZVBvcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBwYWRkUG9zID0+IHtcbiAgICAgICAgICBpZiAobW92ZUNhcmV0KSB7XG4gICAgICAgICAgICBzZXRTZWxlY3Rpb24kMShlZGl0b3IsIGZvcndhcmQsIE9wdGlvbmFsLnNvbWUocGFkZFBvcykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGlzUm9vdEZyb21FbGVtZW50ID0gcm9vdCA9PiBjdXIgPT4gZXEocm9vdCwgY3VyKTtcbiAgICBjb25zdCBnZXRUYWJsZUNlbGxzID0gdGFibGUgPT4gZGVzY2VuZGFudHModGFibGUsICd0ZCx0aCcpO1xuICAgIGNvbnN0IGdldFRhYmxlRGV0YWlsc0Zyb21SYW5nZSA9IChybmcsIGlzUm9vdCkgPT4ge1xuICAgICAgY29uc3QgZ2V0VGFibGUgPSBub2RlID0+IGdldENsb3Nlc3RUYWJsZShTdWdhckVsZW1lbnQuZnJvbURvbShub2RlKSwgaXNSb290KTtcbiAgICAgIGNvbnN0IHN0YXJ0VGFibGUgPSBnZXRUYWJsZShybmcuc3RhcnRDb250YWluZXIpO1xuICAgICAgY29uc3QgZW5kVGFibGUgPSBnZXRUYWJsZShybmcuZW5kQ29udGFpbmVyKTtcbiAgICAgIGNvbnN0IGlzU3RhcnRJblRhYmxlID0gc3RhcnRUYWJsZS5pc1NvbWUoKTtcbiAgICAgIGNvbnN0IGlzRW5kSW5UYWJsZSA9IGVuZFRhYmxlLmlzU29tZSgpO1xuICAgICAgY29uc3QgaXNTYW1lVGFibGUgPSBsaWZ0MihzdGFydFRhYmxlLCBlbmRUYWJsZSwgZXEpLmdldE9yKGZhbHNlKTtcbiAgICAgIGNvbnN0IGlzTXVsdGlUYWJsZSA9ICFpc1NhbWVUYWJsZSAmJiBpc1N0YXJ0SW5UYWJsZSAmJiBpc0VuZEluVGFibGU7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGFydFRhYmxlLFxuICAgICAgICBlbmRUYWJsZSxcbiAgICAgICAgaXNTdGFydEluVGFibGUsXG4gICAgICAgIGlzRW5kSW5UYWJsZSxcbiAgICAgICAgaXNTYW1lVGFibGUsXG4gICAgICAgIGlzTXVsdGlUYWJsZVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgY29uc3QgdGFibGVDZWxsUm5nID0gKHN0YXJ0LCBlbmQpID0+ICh7XG4gICAgICBzdGFydCxcbiAgICAgIGVuZFxuICAgIH0pO1xuICAgIGNvbnN0IHRhYmxlU2VsZWN0aW9uID0gKHJuZywgdGFibGUsIGNlbGxzKSA9PiAoe1xuICAgICAgcm5nLFxuICAgICAgdGFibGUsXG4gICAgICBjZWxsc1xuICAgIH0pO1xuICAgIGNvbnN0IGRlbGV0ZUFjdGlvbiA9IEFkdC5nZW5lcmF0ZShbXG4gICAgICB7XG4gICAgICAgIHNpbmdsZUNlbGxUYWJsZTogW1xuICAgICAgICAgICdybmcnLFxuICAgICAgICAgICdjZWxsJ1xuICAgICAgICBdXG4gICAgICB9LFxuICAgICAgeyBmdWxsVGFibGU6IFsndGFibGUnXSB9LFxuICAgICAge1xuICAgICAgICBwYXJ0aWFsVGFibGU6IFtcbiAgICAgICAgICAnY2VsbHMnLFxuICAgICAgICAgICdvdXRzaWRlRGV0YWlscydcbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbXVsdGlUYWJsZTogW1xuICAgICAgICAgICdzdGFydFRhYmxlQ2VsbHMnLFxuICAgICAgICAgICdlbmRUYWJsZUNlbGxzJyxcbiAgICAgICAgICAnYmV0d2VlblJuZydcbiAgICAgICAgXVxuICAgICAgfVxuICAgIF0pO1xuICAgIGNvbnN0IGdldENsb3Nlc3RDZWxsJDEgPSAoY29udGFpbmVyLCBpc1Jvb3QpID0+IGNsb3Nlc3QkMyhTdWdhckVsZW1lbnQuZnJvbURvbShjb250YWluZXIpLCAndGQsdGgnLCBpc1Jvb3QpO1xuICAgIGNvbnN0IGlzRXhwYW5kZWRDZWxsUm5nID0gY2VsbFJuZyA9PiAhZXEoY2VsbFJuZy5zdGFydCwgY2VsbFJuZy5lbmQpO1xuICAgIGNvbnN0IGdldFRhYmxlRnJvbUNlbGxSbmcgPSAoY2VsbFJuZywgaXNSb290KSA9PiBnZXRDbG9zZXN0VGFibGUoY2VsbFJuZy5zdGFydCwgaXNSb290KS5iaW5kKHN0YXJ0UGFyZW50VGFibGUgPT4gZ2V0Q2xvc2VzdFRhYmxlKGNlbGxSbmcuZW5kLCBpc1Jvb3QpLmJpbmQoZW5kUGFyZW50VGFibGUgPT4gc29tZUlmKGVxKHN0YXJ0UGFyZW50VGFibGUsIGVuZFBhcmVudFRhYmxlKSwgc3RhcnRQYXJlbnRUYWJsZSkpKTtcbiAgICBjb25zdCBpc1NpbmdsZUNlbGxUYWJsZSA9IChjZWxsUm5nLCBpc1Jvb3QpID0+ICFpc0V4cGFuZGVkQ2VsbFJuZyhjZWxsUm5nKSAmJiBnZXRUYWJsZUZyb21DZWxsUm5nKGNlbGxSbmcsIGlzUm9vdCkuZXhpc3RzKHRhYmxlID0+IHtcbiAgICAgIGNvbnN0IHJvd3MgPSB0YWJsZS5kb20ucm93cztcbiAgICAgIHJldHVybiByb3dzLmxlbmd0aCA9PT0gMSAmJiByb3dzWzBdLmNlbGxzLmxlbmd0aCA9PT0gMTtcbiAgICB9KTtcbiAgICBjb25zdCBnZXRDZWxsUm5nID0gKHJuZywgaXNSb290KSA9PiB7XG4gICAgICBjb25zdCBzdGFydENlbGwgPSBnZXRDbG9zZXN0Q2VsbCQxKHJuZy5zdGFydENvbnRhaW5lciwgaXNSb290KTtcbiAgICAgIGNvbnN0IGVuZENlbGwgPSBnZXRDbG9zZXN0Q2VsbCQxKHJuZy5lbmRDb250YWluZXIsIGlzUm9vdCk7XG4gICAgICByZXR1cm4gbGlmdDIoc3RhcnRDZWxsLCBlbmRDZWxsLCB0YWJsZUNlbGxSbmcpO1xuICAgIH07XG4gICAgY29uc3QgZ2V0Q2VsbFJhbmdlRnJvbVN0YXJ0VGFibGUgPSBpc1Jvb3QgPT4gc3RhcnRDZWxsID0+IGdldENsb3Nlc3RUYWJsZShzdGFydENlbGwsIGlzUm9vdCkuYmluZCh0YWJsZSA9PiBsYXN0JDMoZ2V0VGFibGVDZWxscyh0YWJsZSkpLm1hcChlbmRDZWxsID0+IHRhYmxlQ2VsbFJuZyhzdGFydENlbGwsIGVuZENlbGwpKSk7XG4gICAgY29uc3QgZ2V0Q2VsbFJhbmdlRnJvbUVuZFRhYmxlID0gaXNSb290ID0+IGVuZENlbGwgPT4gZ2V0Q2xvc2VzdFRhYmxlKGVuZENlbGwsIGlzUm9vdCkuYmluZCh0YWJsZSA9PiBoZWFkKGdldFRhYmxlQ2VsbHModGFibGUpKS5tYXAoc3RhcnRDZWxsID0+IHRhYmxlQ2VsbFJuZyhzdGFydENlbGwsIGVuZENlbGwpKSk7XG4gICAgY29uc3QgZ2V0VGFibGVTZWxlY3Rpb25Gcm9tQ2VsbFJuZyA9IGlzUm9vdCA9PiBjZWxsUm5nID0+IGdldFRhYmxlRnJvbUNlbGxSbmcoY2VsbFJuZywgaXNSb290KS5tYXAodGFibGUgPT4gdGFibGVTZWxlY3Rpb24oY2VsbFJuZywgdGFibGUsIGdldFRhYmxlQ2VsbHModGFibGUpKSk7XG4gICAgY29uc3QgZ2V0VGFibGVTZWxlY3Rpb25zID0gKGNlbGxSbmcsIHNlbGVjdGlvbkRldGFpbHMsIHJuZywgaXNSb290KSA9PiB7XG4gICAgICBpZiAocm5nLmNvbGxhcHNlZCB8fCAhY2VsbFJuZy5mb3JhbGwoaXNFeHBhbmRlZENlbGxSbmcpKSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9IGVsc2UgaWYgKHNlbGVjdGlvbkRldGFpbHMuaXNTYW1lVGFibGUpIHtcbiAgICAgICAgY29uc3Qgc2FtZVRhYmxlU2VsZWN0aW9uID0gY2VsbFJuZy5iaW5kKGdldFRhYmxlU2VsZWN0aW9uRnJvbUNlbGxSbmcoaXNSb290KSk7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKHtcbiAgICAgICAgICBzdGFydDogc2FtZVRhYmxlU2VsZWN0aW9uLFxuICAgICAgICAgIGVuZDogc2FtZVRhYmxlU2VsZWN0aW9uXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgc3RhcnRDZWxsID0gZ2V0Q2xvc2VzdENlbGwkMShybmcuc3RhcnRDb250YWluZXIsIGlzUm9vdCk7XG4gICAgICAgIGNvbnN0IGVuZENlbGwgPSBnZXRDbG9zZXN0Q2VsbCQxKHJuZy5lbmRDb250YWluZXIsIGlzUm9vdCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGFibGVTZWxlY3Rpb24gPSBzdGFydENlbGwuYmluZChnZXRDZWxsUmFuZ2VGcm9tU3RhcnRUYWJsZShpc1Jvb3QpKS5iaW5kKGdldFRhYmxlU2VsZWN0aW9uRnJvbUNlbGxSbmcoaXNSb290KSk7XG4gICAgICAgIGNvbnN0IGVuZFRhYmxlU2VsZWN0aW9uID0gZW5kQ2VsbC5iaW5kKGdldENlbGxSYW5nZUZyb21FbmRUYWJsZShpc1Jvb3QpKS5iaW5kKGdldFRhYmxlU2VsZWN0aW9uRnJvbUNlbGxSbmcoaXNSb290KSk7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKHtcbiAgICAgICAgICBzdGFydDogc3RhcnRUYWJsZVNlbGVjdGlvbixcbiAgICAgICAgICBlbmQ6IGVuZFRhYmxlU2VsZWN0aW9uXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZ2V0Q2VsbEluZGV4ID0gKGNlbGxzLCBjZWxsKSA9PiBmaW5kSW5kZXgkMihjZWxscywgeCA9PiBlcSh4LCBjZWxsKSk7XG4gICAgY29uc3QgZ2V0U2VsZWN0ZWRDZWxscyA9IHRhYmxlU2VsZWN0aW9uID0+IGxpZnQyKGdldENlbGxJbmRleCh0YWJsZVNlbGVjdGlvbi5jZWxscywgdGFibGVTZWxlY3Rpb24ucm5nLnN0YXJ0KSwgZ2V0Q2VsbEluZGV4KHRhYmxlU2VsZWN0aW9uLmNlbGxzLCB0YWJsZVNlbGVjdGlvbi5ybmcuZW5kKSwgKHN0YXJ0SW5kZXgsIGVuZEluZGV4KSA9PiB0YWJsZVNlbGVjdGlvbi5jZWxscy5zbGljZShzdGFydEluZGV4LCBlbmRJbmRleCArIDEpKTtcbiAgICBjb25zdCBpc1NpbmdsZUNlbGxUYWJsZUNvbnRlbnRTZWxlY3RlZCA9IChvcHRDZWxsUm5nLCBybmcsIGlzUm9vdCkgPT4gb3B0Q2VsbFJuZy5leGlzdHMoY2VsbFJuZyA9PiBpc1NpbmdsZUNlbGxUYWJsZShjZWxsUm5nLCBpc1Jvb3QpICYmIGhhc0FsbENvbnRlbnRzU2VsZWN0ZWQoY2VsbFJuZy5zdGFydCwgcm5nKSk7XG4gICAgY29uc3QgdW5zZWxlY3RDZWxscyA9IChybmcsIHNlbGVjdGlvbkRldGFpbHMpID0+IHtcbiAgICAgIGNvbnN0IHtzdGFydFRhYmxlLCBlbmRUYWJsZX0gPSBzZWxlY3Rpb25EZXRhaWxzO1xuICAgICAgY29uc3Qgb3RoZXJDb250ZW50Um5nID0gcm5nLmNsb25lUmFuZ2UoKTtcbiAgICAgIHN0YXJ0VGFibGUuZWFjaCh0YWJsZSA9PiBvdGhlckNvbnRlbnRSbmcuc2V0U3RhcnRBZnRlcih0YWJsZS5kb20pKTtcbiAgICAgIGVuZFRhYmxlLmVhY2godGFibGUgPT4gb3RoZXJDb250ZW50Um5nLnNldEVuZEJlZm9yZSh0YWJsZS5kb20pKTtcbiAgICAgIHJldHVybiBvdGhlckNvbnRlbnRSbmc7XG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVTaW5nbGVUYWJsZSA9IChjZWxsUm5nLCBzZWxlY3Rpb25EZXRhaWxzLCBybmcsIGlzUm9vdCkgPT4gZ2V0VGFibGVTZWxlY3Rpb25zKGNlbGxSbmcsIHNlbGVjdGlvbkRldGFpbHMsIHJuZywgaXNSb290KS5iaW5kKCh7c3RhcnQsIGVuZH0pID0+IHN0YXJ0Lm9yKGVuZCkpLmJpbmQodGFibGVTZWxlY3Rpb24gPT4ge1xuICAgICAgY29uc3Qge2lzU2FtZVRhYmxlfSA9IHNlbGVjdGlvbkRldGFpbHM7XG4gICAgICBjb25zdCBzZWxlY3RlZENlbGxzID0gZ2V0U2VsZWN0ZWRDZWxscyh0YWJsZVNlbGVjdGlvbikuZ2V0T3IoW10pO1xuICAgICAgaWYgKGlzU2FtZVRhYmxlICYmIHRhYmxlU2VsZWN0aW9uLmNlbGxzLmxlbmd0aCA9PT0gc2VsZWN0ZWRDZWxscy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoZGVsZXRlQWN0aW9uLmZ1bGxUYWJsZSh0YWJsZVNlbGVjdGlvbi50YWJsZSkpO1xuICAgICAgfSBlbHNlIGlmIChzZWxlY3RlZENlbGxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKGlzU2FtZVRhYmxlKSB7XG4gICAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoZGVsZXRlQWN0aW9uLnBhcnRpYWxUYWJsZShzZWxlY3RlZENlbGxzLCBPcHRpb25hbC5ub25lKCkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBvdGhlckNvbnRlbnRSbmcgPSB1bnNlbGVjdENlbGxzKHJuZywgc2VsZWN0aW9uRGV0YWlscyk7XG4gICAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoZGVsZXRlQWN0aW9uLnBhcnRpYWxUYWJsZShzZWxlY3RlZENlbGxzLCBPcHRpb25hbC5zb21lKHtcbiAgICAgICAgICAgIC4uLnNlbGVjdGlvbkRldGFpbHMsXG4gICAgICAgICAgICBybmc6IG90aGVyQ29udGVudFJuZ1xuICAgICAgICAgIH0pKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgaGFuZGxlTXVsdGlUYWJsZSA9IChjZWxsUm5nLCBzZWxlY3Rpb25EZXRhaWxzLCBybmcsIGlzUm9vdCkgPT4gZ2V0VGFibGVTZWxlY3Rpb25zKGNlbGxSbmcsIHNlbGVjdGlvbkRldGFpbHMsIHJuZywgaXNSb290KS5iaW5kKCh7c3RhcnQsIGVuZH0pID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0VGFibGVTZWxlY3RlZENlbGxzID0gc3RhcnQuYmluZChnZXRTZWxlY3RlZENlbGxzKS5nZXRPcihbXSk7XG4gICAgICBjb25zdCBlbmRUYWJsZVNlbGVjdGVkQ2VsbHMgPSBlbmQuYmluZChnZXRTZWxlY3RlZENlbGxzKS5nZXRPcihbXSk7XG4gICAgICBpZiAoc3RhcnRUYWJsZVNlbGVjdGVkQ2VsbHMubGVuZ3RoID4gMCAmJiBlbmRUYWJsZVNlbGVjdGVkQ2VsbHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBvdGhlckNvbnRlbnRSbmcgPSB1bnNlbGVjdENlbGxzKHJuZywgc2VsZWN0aW9uRGV0YWlscyk7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKGRlbGV0ZUFjdGlvbi5tdWx0aVRhYmxlKHN0YXJ0VGFibGVTZWxlY3RlZENlbGxzLCBlbmRUYWJsZVNlbGVjdGVkQ2VsbHMsIG90aGVyQ29udGVudFJuZykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBnZXRBY3Rpb25Gcm9tUmFuZ2UgPSAocm9vdCwgcm5nKSA9PiB7XG4gICAgICBjb25zdCBpc1Jvb3QgPSBpc1Jvb3RGcm9tRWxlbWVudChyb290KTtcbiAgICAgIGNvbnN0IG9wdENlbGxSbmcgPSBnZXRDZWxsUm5nKHJuZywgaXNSb290KTtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbkRldGFpbHMgPSBnZXRUYWJsZURldGFpbHNGcm9tUmFuZ2Uocm5nLCBpc1Jvb3QpO1xuICAgICAgaWYgKGlzU2luZ2xlQ2VsbFRhYmxlQ29udGVudFNlbGVjdGVkKG9wdENlbGxSbmcsIHJuZywgaXNSb290KSkge1xuICAgICAgICByZXR1cm4gb3B0Q2VsbFJuZy5tYXAoY2VsbFJuZyA9PiBkZWxldGVBY3Rpb24uc2luZ2xlQ2VsbFRhYmxlKHJuZywgY2VsbFJuZy5zdGFydCkpO1xuICAgICAgfSBlbHNlIGlmIChzZWxlY3Rpb25EZXRhaWxzLmlzTXVsdGlUYWJsZSkge1xuICAgICAgICByZXR1cm4gaGFuZGxlTXVsdGlUYWJsZShvcHRDZWxsUm5nLCBzZWxlY3Rpb25EZXRhaWxzLCBybmcsIGlzUm9vdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaGFuZGxlU2luZ2xlVGFibGUob3B0Q2VsbFJuZywgc2VsZWN0aW9uRGV0YWlscywgcm5nLCBpc1Jvb3QpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBmcmVlZmFsbFJ0bCA9IHJvb3QgPT4ge1xuICAgICAgY29uc3QgY2hpbGQgPSBpc0NvbW1lbnQkMShyb290KSA/IHByZXZTaWJsaW5nKHJvb3QpIDogbGFzdENoaWxkKHJvb3QpO1xuICAgICAgcmV0dXJuIGNoaWxkLmJpbmQoZnJlZWZhbGxSdGwpLm9yVGh1bmsoKCkgPT4gT3B0aW9uYWwuc29tZShyb290KSk7XG4gICAgfTtcbiAgICBjb25zdCBjbGVhbkNlbGxzID0gY2VsbHMgPT4gZWFjaCRnKGNlbGxzLCBjZWxsID0+IHtcbiAgICAgIHJlbW92ZSRhKGNlbGwsICdjb250ZW50ZWRpdGFibGUnKTtcbiAgICAgIGZpbGxXaXRoUGFkZGluZ0JyKGNlbGwpO1xuICAgIH0pO1xuICAgIGNvbnN0IGdldE91dHNpZGVCbG9jayA9IChlZGl0b3IsIGNvbnRhaW5lcikgPT4gT3B0aW9uYWwuZnJvbShlZGl0b3IuZG9tLmdldFBhcmVudChjb250YWluZXIsIGVkaXRvci5kb20uaXNCbG9jaykpLm1hcChTdWdhckVsZW1lbnQuZnJvbURvbSk7XG4gICAgY29uc3QgaGFuZGxlRW1wdHlCbG9jayA9IChlZGl0b3IsIHN0YXJ0SW5UYWJsZSwgZW1wdHlCbG9jaykgPT4ge1xuICAgICAgZW1wdHlCbG9jay5lYWNoKGJsb2NrID0+IHtcbiAgICAgICAgaWYgKHN0YXJ0SW5UYWJsZSkge1xuICAgICAgICAgIHJlbW92ZSQ1KGJsb2NrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmaWxsV2l0aFBhZGRpbmdCcihibG9jayk7XG4gICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZXRDdXJzb3JMb2NhdGlvbihibG9jay5kb20sIDApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGRlbGV0ZUNvbnRlbnRJbnNpZGVDZWxsID0gKGVkaXRvciwgY2VsbCwgcm5nLCBpc0ZpcnN0Q2VsbEluU2VsZWN0aW9uKSA9PiB7XG4gICAgICBjb25zdCBpbnNpZGVUYWJsZVJuZyA9IHJuZy5jbG9uZVJhbmdlKCk7XG4gICAgICBpZiAoaXNGaXJzdENlbGxJblNlbGVjdGlvbikge1xuICAgICAgICBpbnNpZGVUYWJsZVJuZy5zZXRTdGFydChybmcuc3RhcnRDb250YWluZXIsIHJuZy5zdGFydE9mZnNldCk7XG4gICAgICAgIGluc2lkZVRhYmxlUm5nLnNldEVuZEFmdGVyKGNlbGwuZG9tLmxhc3RDaGlsZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnNpZGVUYWJsZVJuZy5zZXRTdGFydEJlZm9yZShjZWxsLmRvbS5maXJzdENoaWxkKTtcbiAgICAgICAgaW5zaWRlVGFibGVSbmcuc2V0RW5kKHJuZy5lbmRDb250YWluZXIsIHJuZy5lbmRPZmZzZXQpO1xuICAgICAgfVxuICAgICAgZGVsZXRlQ2VsbENvbnRlbnRzKGVkaXRvciwgaW5zaWRlVGFibGVSbmcsIGNlbGwsIGZhbHNlKS5lYWNoKGFjdGlvbiA9PiBhY3Rpb24oKSk7XG4gICAgfTtcbiAgICBjb25zdCBjb2xsYXBzZUFuZFJlc3RvcmVDZWxsU2VsZWN0aW9uID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGVkQ2VsbHMgPSBnZXRDZWxsc0Zyb21FZGl0b3IoZWRpdG9yKTtcbiAgICAgIGNvbnN0IHNlbGVjdGVkTm9kZSA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVkaXRvci5zZWxlY3Rpb24uZ2V0Tm9kZSgpKTtcbiAgICAgIGlmIChpc1RhYmxlQ2VsbCQ1KHNlbGVjdGVkTm9kZS5kb20pICYmIGlzRW1wdHkkMihzZWxlY3RlZE5vZGUpKSB7XG4gICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2V0Q3Vyc29yTG9jYXRpb24oc2VsZWN0ZWROb2RlLmRvbSwgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLmNvbGxhcHNlKHRydWUpO1xuICAgICAgfVxuICAgICAgaWYgKHNlbGVjdGVkQ2VsbHMubGVuZ3RoID4gMSAmJiBleGlzdHMoc2VsZWN0ZWRDZWxscywgY2VsbCA9PiBlcShjZWxsLCBzZWxlY3RlZE5vZGUpKSkge1xuICAgICAgICBzZXQkMihzZWxlY3RlZE5vZGUsICdkYXRhLW1jZS1zZWxlY3RlZCcsICcxJyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBlbXB0eVNpbmdsZVRhYmxlQ2VsbHMgPSAoZWRpdG9yLCBjZWxscywgb3V0c2lkZURldGFpbHMpID0+IE9wdGlvbmFsLnNvbWUoKCkgPT4ge1xuICAgICAgY29uc3QgZWRpdG9yUm5nID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKTtcbiAgICAgIGNvbnN0IGNlbGxzVG9DbGVhbiA9IG91dHNpZGVEZXRhaWxzLmJpbmQoKHtybmcsIGlzU3RhcnRJblRhYmxlfSkgPT4ge1xuICAgICAgICBjb25zdCBvdXRzaWRlQmxvY2sgPSBnZXRPdXRzaWRlQmxvY2soZWRpdG9yLCBpc1N0YXJ0SW5UYWJsZSA/IHJuZy5lbmRDb250YWluZXIgOiBybmcuc3RhcnRDb250YWluZXIpO1xuICAgICAgICBybmcuZGVsZXRlQ29udGVudHMoKTtcbiAgICAgICAgaGFuZGxlRW1wdHlCbG9jayhlZGl0b3IsIGlzU3RhcnRJblRhYmxlLCBvdXRzaWRlQmxvY2suZmlsdGVyKGlzRW1wdHkkMikpO1xuICAgICAgICBjb25zdCBlbmRQb2ludENlbGwgPSBpc1N0YXJ0SW5UYWJsZSA/IGNlbGxzWzBdIDogY2VsbHNbY2VsbHMubGVuZ3RoIC0gMV07XG4gICAgICAgIGRlbGV0ZUNvbnRlbnRJbnNpZGVDZWxsKGVkaXRvciwgZW5kUG9pbnRDZWxsLCBlZGl0b3JSbmcsIGlzU3RhcnRJblRhYmxlKTtcbiAgICAgICAgaWYgKCFpc0VtcHR5JDIoZW5kUG9pbnRDZWxsKSkge1xuICAgICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKGlzU3RhcnRJblRhYmxlID8gY2VsbHMuc2xpY2UoMSkgOiBjZWxscy5zbGljZSgwLCAtMSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICAgIH1cbiAgICAgIH0pLmdldE9yKGNlbGxzKTtcbiAgICAgIGNsZWFuQ2VsbHMoY2VsbHNUb0NsZWFuKTtcbiAgICAgIGNvbGxhcHNlQW5kUmVzdG9yZUNlbGxTZWxlY3Rpb24oZWRpdG9yKTtcbiAgICB9KTtcbiAgICBjb25zdCBlbXB0eU11bHRpVGFibGVDZWxscyA9IChlZGl0b3IsIHN0YXJ0VGFibGVDZWxscywgZW5kVGFibGVDZWxscywgYmV0d2VlblJuZykgPT4gT3B0aW9uYWwuc29tZSgoKSA9PiB7XG4gICAgICBjb25zdCBybmcgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpO1xuICAgICAgY29uc3Qgc3RhcnRDZWxsID0gc3RhcnRUYWJsZUNlbGxzWzBdO1xuICAgICAgY29uc3QgZW5kQ2VsbCA9IGVuZFRhYmxlQ2VsbHNbZW5kVGFibGVDZWxscy5sZW5ndGggLSAxXTtcbiAgICAgIGRlbGV0ZUNvbnRlbnRJbnNpZGVDZWxsKGVkaXRvciwgc3RhcnRDZWxsLCBybmcsIHRydWUpO1xuICAgICAgZGVsZXRlQ29udGVudEluc2lkZUNlbGwoZWRpdG9yLCBlbmRDZWxsLCBybmcsIGZhbHNlKTtcbiAgICAgIGNvbnN0IHN0YXJ0VGFibGVDZWxsc1RvQ2xlYW4gPSBpc0VtcHR5JDIoc3RhcnRDZWxsKSA/IHN0YXJ0VGFibGVDZWxscyA6IHN0YXJ0VGFibGVDZWxscy5zbGljZSgxKTtcbiAgICAgIGNvbnN0IGVuZFRhYmxlQ2VsbHNUb0NsZWFuID0gaXNFbXB0eSQyKGVuZENlbGwpID8gZW5kVGFibGVDZWxscyA6IGVuZFRhYmxlQ2VsbHMuc2xpY2UoMCwgLTEpO1xuICAgICAgY2xlYW5DZWxscyhzdGFydFRhYmxlQ2VsbHNUb0NsZWFuLmNvbmNhdChlbmRUYWJsZUNlbGxzVG9DbGVhbikpO1xuICAgICAgYmV0d2VlblJuZy5kZWxldGVDb250ZW50cygpO1xuICAgICAgY29sbGFwc2VBbmRSZXN0b3JlQ2VsbFNlbGVjdGlvbihlZGl0b3IpO1xuICAgIH0pO1xuICAgIGNvbnN0IGRlbGV0ZUNlbGxDb250ZW50cyA9IChlZGl0b3IsIHJuZywgY2VsbCwgbW92ZVNlbGVjdGlvbiA9IHRydWUpID0+IE9wdGlvbmFsLnNvbWUoKCkgPT4ge1xuICAgICAgcm5nLmRlbGV0ZUNvbnRlbnRzKCk7XG4gICAgICBjb25zdCBsYXN0Tm9kZSA9IGZyZWVmYWxsUnRsKGNlbGwpLmdldE9yKGNlbGwpO1xuICAgICAgY29uc3QgbGFzdEJsb2NrID0gU3VnYXJFbGVtZW50LmZyb21Eb20oZWRpdG9yLmRvbS5nZXRQYXJlbnQobGFzdE5vZGUuZG9tLCBlZGl0b3IuZG9tLmlzQmxvY2spKTtcbiAgICAgIGlmIChpc0VtcHR5JDIobGFzdEJsb2NrKSkge1xuICAgICAgICBmaWxsV2l0aFBhZGRpbmdCcihsYXN0QmxvY2spO1xuICAgICAgICBpZiAobW92ZVNlbGVjdGlvbikge1xuICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2V0Q3Vyc29yTG9jYXRpb24obGFzdEJsb2NrLmRvbSwgMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghZXEoY2VsbCwgbGFzdEJsb2NrKSkge1xuICAgICAgICBjb25zdCBhZGRpdGlvbmFsQ2xlYW51cE5vZGVzID0gaXMkMihwYXJlbnQobGFzdEJsb2NrKSwgY2VsbCkgPyBbXSA6IHNpYmxpbmdzKGxhc3RCbG9jayk7XG4gICAgICAgIGVhY2gkZyhhZGRpdGlvbmFsQ2xlYW51cE5vZGVzLmNvbmNhdChjaGlsZHJlbihjZWxsKSksIG5vZGUgPT4ge1xuICAgICAgICAgIGlmICghZXEobm9kZSwgbGFzdEJsb2NrKSAmJiAhY29udGFpbnMobm9kZSwgbGFzdEJsb2NrKSAmJiBpc0VtcHR5JDIobm9kZSkpIHtcbiAgICAgICAgICAgIHJlbW92ZSQ1KG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgZGVsZXRlVGFibGVFbGVtZW50ID0gKGVkaXRvciwgdGFibGUpID0+IE9wdGlvbmFsLnNvbWUoKCkgPT4gZGVsZXRlRWxlbWVudCQyKGVkaXRvciwgZmFsc2UsIHRhYmxlKSk7XG4gICAgY29uc3QgZGVsZXRlQ2VsbFJhbmdlID0gKGVkaXRvciwgcm9vdEVsbSwgcm5nKSA9PiBnZXRBY3Rpb25Gcm9tUmFuZ2Uocm9vdEVsbSwgcm5nKS5iaW5kKGFjdGlvbiA9PiBhY3Rpb24uZm9sZChjdXJyeShkZWxldGVDZWxsQ29udGVudHMsIGVkaXRvciksIGN1cnJ5KGRlbGV0ZVRhYmxlRWxlbWVudCwgZWRpdG9yKSwgY3VycnkoZW1wdHlTaW5nbGVUYWJsZUNlbGxzLCBlZGl0b3IpLCBjdXJyeShlbXB0eU11bHRpVGFibGVDZWxscywgZWRpdG9yKSkpO1xuICAgIGNvbnN0IGRlbGV0ZUNhcHRpb25SYW5nZSA9IChlZGl0b3IsIGNhcHRpb24pID0+IGVtcHR5RWxlbWVudChlZGl0b3IsIGNhcHRpb24pO1xuICAgIGNvbnN0IGRlbGV0ZVRhYmxlUmFuZ2UgPSAoZWRpdG9yLCByb290RWxtLCBybmcsIHN0YXJ0RWxtKSA9PiBnZXRQYXJlbnRDYXB0aW9uKHJvb3RFbG0sIHN0YXJ0RWxtKS5mb2xkKCgpID0+IGRlbGV0ZUNlbGxSYW5nZShlZGl0b3IsIHJvb3RFbG0sIHJuZyksIGNhcHRpb24gPT4gZGVsZXRlQ2FwdGlvblJhbmdlKGVkaXRvciwgY2FwdGlvbikpO1xuICAgIGNvbnN0IGRlbGV0ZVJhbmdlJDIgPSAoZWRpdG9yLCBzdGFydEVsbSwgc2VsZWN0ZWRDZWxscykgPT4ge1xuICAgICAgY29uc3Qgcm9vdE5vZGUgPSBTdWdhckVsZW1lbnQuZnJvbURvbShlZGl0b3IuZ2V0Qm9keSgpKTtcbiAgICAgIGNvbnN0IHJuZyA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCk7XG4gICAgICByZXR1cm4gc2VsZWN0ZWRDZWxscy5sZW5ndGggIT09IDAgPyBlbXB0eVNpbmdsZVRhYmxlQ2VsbHMoZWRpdG9yLCBzZWxlY3RlZENlbGxzLCBPcHRpb25hbC5ub25lKCkpIDogZGVsZXRlVGFibGVSYW5nZShlZGl0b3IsIHJvb3ROb2RlLCBybmcsIHN0YXJ0RWxtKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldFBhcmVudENlbGwgPSAocm9vdEVsbSwgZWxtKSA9PiBmaW5kJDIocGFyZW50c0FuZFNlbGYoZWxtLCByb290RWxtKSwgaXNUYWJsZUNlbGwkNCk7XG4gICAgY29uc3QgZ2V0UGFyZW50Q2FwdGlvbiA9IChyb290RWxtLCBlbG0pID0+IGZpbmQkMihwYXJlbnRzQW5kU2VsZihlbG0sIHJvb3RFbG0pLCBpc1RhZygnY2FwdGlvbicpKTtcbiAgICBjb25zdCBkZWxldGVCZXR3ZWVuQ2VsbHMgPSAoZWRpdG9yLCByb290RWxtLCBmb3J3YXJkLCBmcm9tQ2VsbCwgZnJvbSkgPT4gbmF2aWdhdGUoZm9yd2FyZCwgZWRpdG9yLmdldEJvZHkoKSwgZnJvbSkuYmluZCh0byA9PiBnZXRQYXJlbnRDZWxsKHJvb3RFbG0sIFN1Z2FyRWxlbWVudC5mcm9tRG9tKHRvLmdldE5vZGUoKSkpLmJpbmQodG9DZWxsID0+IGVxKHRvQ2VsbCwgZnJvbUNlbGwpID8gT3B0aW9uYWwubm9uZSgpIDogT3B0aW9uYWwuc29tZShub29wKSkpO1xuICAgIGNvbnN0IGVtcHR5RWxlbWVudCA9IChlZGl0b3IsIGVsbSkgPT4gT3B0aW9uYWwuc29tZSgoKSA9PiB7XG4gICAgICBmaWxsV2l0aFBhZGRpbmdCcihlbG0pO1xuICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZXRDdXJzb3JMb2NhdGlvbihlbG0uZG9tLCAwKTtcbiAgICB9KTtcbiAgICBjb25zdCBpc0RlbGV0ZU9mTGFzdENoYXJQb3MgPSAoZnJvbUNhcHRpb24sIGZvcndhcmQsIGZyb20sIHRvKSA9PiBmaXJzdFBvc2l0aW9uSW4oZnJvbUNhcHRpb24uZG9tKS5iaW5kKGZpcnN0ID0+IGxhc3RQb3NpdGlvbkluKGZyb21DYXB0aW9uLmRvbSkubWFwKGxhc3QgPT4gZm9yd2FyZCA/IGZyb20uaXNFcXVhbChmaXJzdCkgJiYgdG8uaXNFcXVhbChsYXN0KSA6IGZyb20uaXNFcXVhbChsYXN0KSAmJiB0by5pc0VxdWFsKGZpcnN0KSkpLmdldE9yKHRydWUpO1xuICAgIGNvbnN0IGVtcHR5Q2FyZXRDYXB0aW9uID0gKGVkaXRvciwgZWxtKSA9PiBlbXB0eUVsZW1lbnQoZWRpdG9yLCBlbG0pO1xuICAgIGNvbnN0IHZhbGlkYXRlQ2FyZXRDYXB0aW9uID0gKHJvb3RFbG0sIGZyb21DYXB0aW9uLCB0bykgPT4gZ2V0UGFyZW50Q2FwdGlvbihyb290RWxtLCBTdWdhckVsZW1lbnQuZnJvbURvbSh0by5nZXROb2RlKCkpKS5mb2xkKCgpID0+IE9wdGlvbmFsLnNvbWUobm9vcCksIHRvQ2FwdGlvbiA9PiBzb21lSWYoIWVxKHRvQ2FwdGlvbiwgZnJvbUNhcHRpb24pLCBub29wKSk7XG4gICAgY29uc3QgZGVsZXRlQ2FyZXRJbnNpZGVDYXB0aW9uID0gKGVkaXRvciwgcm9vdEVsbSwgZm9yd2FyZCwgZnJvbUNhcHRpb24sIGZyb20pID0+IG5hdmlnYXRlKGZvcndhcmQsIGVkaXRvci5nZXRCb2R5KCksIGZyb20pLmZvbGQoKCkgPT4gT3B0aW9uYWwuc29tZShub29wKSwgdG8gPT4gaXNEZWxldGVPZkxhc3RDaGFyUG9zKGZyb21DYXB0aW9uLCBmb3J3YXJkLCBmcm9tLCB0bykgPyBlbXB0eUNhcmV0Q2FwdGlvbihlZGl0b3IsIGZyb21DYXB0aW9uKSA6IHZhbGlkYXRlQ2FyZXRDYXB0aW9uKHJvb3RFbG0sIGZyb21DYXB0aW9uLCB0bykpO1xuICAgIGNvbnN0IGRlbGV0ZUNhcmV0Q2VsbHMgPSAoZWRpdG9yLCBmb3J3YXJkLCByb290RWxtLCBzdGFydEVsbSkgPT4ge1xuICAgICAgY29uc3QgZnJvbSA9IENhcmV0UG9zaXRpb24uZnJvbVJhbmdlU3RhcnQoZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKSk7XG4gICAgICByZXR1cm4gZ2V0UGFyZW50Q2VsbChyb290RWxtLCBzdGFydEVsbSkuYmluZChmcm9tQ2VsbCA9PiBpc0VtcHR5JDIoZnJvbUNlbGwpID8gZW1wdHlFbGVtZW50KGVkaXRvciwgZnJvbUNlbGwpIDogZGVsZXRlQmV0d2VlbkNlbGxzKGVkaXRvciwgcm9vdEVsbSwgZm9yd2FyZCwgZnJvbUNlbGwsIGZyb20pKTtcbiAgICB9O1xuICAgIGNvbnN0IGRlbGV0ZUNhcmV0Q2FwdGlvbiA9IChlZGl0b3IsIGZvcndhcmQsIHJvb3RFbG0sIGZyb21DYXB0aW9uKSA9PiB7XG4gICAgICBjb25zdCBmcm9tID0gQ2FyZXRQb3NpdGlvbi5mcm9tUmFuZ2VTdGFydChlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpKTtcbiAgICAgIHJldHVybiBpc0VtcHR5JDIoZnJvbUNhcHRpb24pID8gZW1wdHlFbGVtZW50KGVkaXRvciwgZnJvbUNhcHRpb24pIDogZGVsZXRlQ2FyZXRJbnNpZGVDYXB0aW9uKGVkaXRvciwgcm9vdEVsbSwgZm9yd2FyZCwgZnJvbUNhcHRpb24sIGZyb20pO1xuICAgIH07XG4gICAgY29uc3QgaXNOZWFyVGFibGUgPSAoZm9yd2FyZCwgcG9zKSA9PiBmb3J3YXJkID8gaXNCZWZvcmVUYWJsZShwb3MpIDogaXNBZnRlclRhYmxlKHBvcyk7XG4gICAgY29uc3QgaXNCZWZvcmVPckFmdGVyVGFibGUgPSAoZWRpdG9yLCBmb3J3YXJkKSA9PiB7XG4gICAgICBjb25zdCBmcm9tUG9zID0gQ2FyZXRQb3NpdGlvbi5mcm9tUmFuZ2VTdGFydChlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpKTtcbiAgICAgIHJldHVybiBpc05lYXJUYWJsZShmb3J3YXJkLCBmcm9tUG9zKSB8fCBmcm9tUG9zaXRpb24oZm9yd2FyZCwgZWRpdG9yLmdldEJvZHkoKSwgZnJvbVBvcykuZXhpc3RzKHBvcyA9PiBpc05lYXJUYWJsZShmb3J3YXJkLCBwb3MpKTtcbiAgICB9O1xuICAgIGNvbnN0IGRlbGV0ZUNhcmV0JDMgPSAoZWRpdG9yLCBmb3J3YXJkLCBzdGFydEVsbSkgPT4ge1xuICAgICAgY29uc3Qgcm9vdEVsbSA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVkaXRvci5nZXRCb2R5KCkpO1xuICAgICAgcmV0dXJuIGdldFBhcmVudENhcHRpb24ocm9vdEVsbSwgc3RhcnRFbG0pLmZvbGQoKCkgPT4gZGVsZXRlQ2FyZXRDZWxscyhlZGl0b3IsIGZvcndhcmQsIHJvb3RFbG0sIHN0YXJ0RWxtKS5vclRodW5rKCgpID0+IHNvbWVJZihpc0JlZm9yZU9yQWZ0ZXJUYWJsZShlZGl0b3IsIGZvcndhcmQpLCBub29wKSksIGZyb21DYXB0aW9uID0+IGRlbGV0ZUNhcmV0Q2FwdGlvbihlZGl0b3IsIGZvcndhcmQsIHJvb3RFbG0sIGZyb21DYXB0aW9uKSk7XG4gICAgfTtcbiAgICBjb25zdCBiYWNrc3BhY2VEZWxldGUkOSA9IChlZGl0b3IsIGZvcndhcmQpID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0RWxtID0gU3VnYXJFbGVtZW50LmZyb21Eb20oZWRpdG9yLnNlbGVjdGlvbi5nZXRTdGFydCh0cnVlKSk7XG4gICAgICBjb25zdCBjZWxscyA9IGdldENlbGxzRnJvbUVkaXRvcihlZGl0b3IpO1xuICAgICAgcmV0dXJuIGVkaXRvci5zZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSAmJiBjZWxscy5sZW5ndGggPT09IDAgPyBkZWxldGVDYXJldCQzKGVkaXRvciwgZm9yd2FyZCwgc3RhcnRFbG0pIDogZGVsZXRlUmFuZ2UkMihlZGl0b3IsIHN0YXJ0RWxtLCBjZWxscyk7XG4gICAgfTtcblxuICAgIGNvbnN0IGdldENvbnRlbnRFZGl0YWJsZVJvb3QkMSA9IChyb290LCBub2RlKSA9PiB7XG4gICAgICB3aGlsZSAobm9kZSAmJiBub2RlICE9PSByb290KSB7XG4gICAgICAgIGlmIChpc0NvbnRlbnRFZGl0YWJsZVRydWUkNChub2RlKSB8fCBpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJGEobm9kZSkpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIGNvbnN0IHRyYXZlcnNlID0gKG5vZGUsIGZuKSA9PiB7XG4gICAgICBmbihub2RlKTtcbiAgICAgIGlmIChub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgdHJhdmVyc2Uobm9kZS5maXJzdENoaWxkLCBmbik7XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5uZXh0KSB7XG4gICAgICAgIHRyYXZlcnNlKG5vZGUubmV4dCwgZm4pO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgbWF0Y2hOb2RlJDEgPSAobm9kZUZpbHRlcnMsIGF0dHJpYnV0ZUZpbHRlcnMsIG5vZGUsIG1hdGNoZXMpID0+IHtcbiAgICAgIGNvbnN0IG5hbWUgPSBub2RlLm5hbWU7XG4gICAgICBmb3IgKGxldCBuaSA9IDAsIG5sID0gbm9kZUZpbHRlcnMubGVuZ3RoOyBuaSA8IG5sOyBuaSsrKSB7XG4gICAgICAgIGNvbnN0IGZpbHRlciA9IG5vZGVGaWx0ZXJzW25pXTtcbiAgICAgICAgaWYgKGZpbHRlci5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgY29uc3QgbWF0Y2ggPSBtYXRjaGVzLm5vZGVzW25hbWVdO1xuICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgbWF0Y2gubm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWF0Y2hlcy5ub2Rlc1tuYW1lXSA9IHtcbiAgICAgICAgICAgICAgZmlsdGVyLFxuICAgICAgICAgICAgICBub2RlczogW25vZGVdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5vZGUuYXR0cmlidXRlcykge1xuICAgICAgICBmb3IgKGxldCBhaSA9IDAsIGFsID0gYXR0cmlidXRlRmlsdGVycy5sZW5ndGg7IGFpIDwgYWw7IGFpKyspIHtcbiAgICAgICAgICBjb25zdCBmaWx0ZXIgPSBhdHRyaWJ1dGVGaWx0ZXJzW2FpXTtcbiAgICAgICAgICBjb25zdCBhdHRyTmFtZSA9IGZpbHRlci5uYW1lO1xuICAgICAgICAgIGlmIChhdHRyTmFtZSBpbiBub2RlLmF0dHJpYnV0ZXMubWFwKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IG1hdGNoZXMuYXR0cmlidXRlc1thdHRyTmFtZV07XG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgbWF0Y2gubm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1hdGNoZXMuYXR0cmlidXRlc1thdHRyTmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyLFxuICAgICAgICAgICAgICAgIG5vZGVzOiBbbm9kZV1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGZpbmRNYXRjaGluZ05vZGVzID0gKG5vZGVGaWx0ZXJzLCBhdHRyaWJ1dGVGaWx0ZXJzLCBub2RlKSA9PiB7XG4gICAgICBjb25zdCBtYXRjaGVzID0ge1xuICAgICAgICBub2Rlczoge30sXG4gICAgICAgIGF0dHJpYnV0ZXM6IHt9XG4gICAgICB9O1xuICAgICAgaWYgKG5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgICB0cmF2ZXJzZShub2RlLmZpcnN0Q2hpbGQsIG5vZGUgPT4ge1xuICAgICAgICAgIG1hdGNoTm9kZSQxKG5vZGVGaWx0ZXJzLCBhdHRyaWJ1dGVGaWx0ZXJzLCBub2RlLCBtYXRjaGVzKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2hlcztcbiAgICB9O1xuICAgIGNvbnN0IHJ1bkZpbHRlcnMgPSAobWF0Y2hlcywgYXJncykgPT4ge1xuICAgICAgY29uc3QgcnVuID0gbWF0Y2hSZWNvcmQgPT4ge1xuICAgICAgICBlYWNoJGYobWF0Y2hSZWNvcmQsIG1hdGNoID0+IHtcbiAgICAgICAgICBjb25zdCBub2RlcyA9IGZpbHRlciQ2KG1hdGNoLm5vZGVzLCBub2RlID0+IGlzTm9uTnVsbGFibGUobm9kZS5wYXJlbnQpKTtcbiAgICAgICAgICBlYWNoJGcobWF0Y2guZmlsdGVyLmNhbGxiYWNrcywgY2FsbGJhY2sgPT4ge1xuICAgICAgICAgICAgY2FsbGJhY2sobm9kZXMsIG1hdGNoLmZpbHRlci5uYW1lLCBhcmdzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgcnVuKG1hdGNoZXMubm9kZXMpO1xuICAgICAgcnVuKG1hdGNoZXMuYXR0cmlidXRlcyk7XG4gICAgfTtcbiAgICBjb25zdCBmaWx0ZXIkMyA9IChub2RlRmlsdGVycywgYXR0cmlidXRlRmlsdGVycywgbm9kZSwgYXJncyA9IHt9KSA9PiB7XG4gICAgICBjb25zdCBtYXRjaGVzID0gZmluZE1hdGNoaW5nTm9kZXMobm9kZUZpbHRlcnMsIGF0dHJpYnV0ZUZpbHRlcnMsIG5vZGUpO1xuICAgICAgcnVuRmlsdGVycyhtYXRjaGVzLCBhcmdzKTtcbiAgICB9O1xuXG4gICAgY29uc3QgcGFkZEVtcHR5Tm9kZSA9IChzZXR0aW5ncywgYXJncywgYmxvY2tFbGVtZW50cywgbm9kZSkgPT4ge1xuICAgICAgaWYgKGFyZ3MuaW5zZXJ0ICYmIGJsb2NrRWxlbWVudHNbbm9kZS5uYW1lXSkge1xuICAgICAgICBub2RlLmVtcHR5KCkuYXBwZW5kKG5ldyBBc3ROb2RlKCdicicsIDEpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuZW1wdHkoKS5hcHBlbmQobmV3IEFzdE5vZGUoJyN0ZXh0JywgMykpLnZhbHVlID0gbmJzcDtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGlzUGFkZGVkV2l0aE5ic3AgPSBub2RlID0+IGhhc09ubHlDaGlsZChub2RlLCAnI3RleHQnKSAmJiBub2RlLmZpcnN0Q2hpbGQudmFsdWUgPT09IG5ic3A7XG4gICAgY29uc3QgaGFzT25seUNoaWxkID0gKG5vZGUsIG5hbWUpID0+IG5vZGUgJiYgbm9kZS5maXJzdENoaWxkICYmIG5vZGUuZmlyc3RDaGlsZCA9PT0gbm9kZS5sYXN0Q2hpbGQgJiYgbm9kZS5maXJzdENoaWxkLm5hbWUgPT09IG5hbWU7XG4gICAgY29uc3QgaXNQYWRkZWQgPSAoc2NoZW1hLCBub2RlKSA9PiB7XG4gICAgICBjb25zdCBydWxlID0gc2NoZW1hLmdldEVsZW1lbnRSdWxlKG5vZGUubmFtZSk7XG4gICAgICByZXR1cm4gcnVsZSAmJiBydWxlLnBhZGRFbXB0eTtcbiAgICB9O1xuICAgIGNvbnN0IGlzRW1wdHkgPSAoc2NoZW1hLCBub25FbXB0eUVsZW1lbnRzLCB3aGl0ZXNwYWNlRWxlbWVudHMsIG5vZGUpID0+IG5vZGUuaXNFbXB0eShub25FbXB0eUVsZW1lbnRzLCB3aGl0ZXNwYWNlRWxlbWVudHMsIG5vZGUgPT4gaXNQYWRkZWQoc2NoZW1hLCBub2RlKSk7XG4gICAgY29uc3QgaXNMaW5lQnJlYWtOb2RlID0gKG5vZGUsIGJsb2NrRWxlbWVudHMpID0+IG5vZGUgJiYgKG5vZGUubmFtZSBpbiBibG9ja0VsZW1lbnRzIHx8IG5vZGUubmFtZSA9PT0gJ2JyJyk7XG5cbiAgICBjb25zdCByZW1vdmVPclVud3JhcEludmFsaWROb2RlID0gKG5vZGUsIHNjaGVtYSwgb3JpZ2luYWxOb2RlUGFyZW50ID0gbm9kZS5wYXJlbnQpID0+IHtcbiAgICAgIGlmIChzY2hlbWEuZ2V0U3BlY2lhbEVsZW1lbnRzKClbbm9kZS5uYW1lXSkge1xuICAgICAgICBub2RlLmVtcHR5KCkucmVtb3ZlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4oKTtcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZE5vZGUgb2YgY2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoIXNjaGVtYS5pc1ZhbGlkQ2hpbGQob3JpZ2luYWxOb2RlUGFyZW50Lm5hbWUsIGNoaWxkTm9kZS5uYW1lKSkge1xuICAgICAgICAgICAgcmVtb3ZlT3JVbndyYXBJbnZhbGlkTm9kZShjaGlsZE5vZGUsIHNjaGVtYSwgb3JpZ2luYWxOb2RlUGFyZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS51bndyYXAoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGNsZWFuSW52YWxpZE5vZGVzID0gKG5vZGVzLCBzY2hlbWEsIG9uQ3JlYXRlID0gbm9vcCkgPT4ge1xuICAgICAgY29uc3QgdGV4dEJsb2NrRWxlbWVudHMgPSBzY2hlbWEuZ2V0VGV4dEJsb2NrRWxlbWVudHMoKTtcbiAgICAgIGNvbnN0IG5vbkVtcHR5RWxlbWVudHMgPSBzY2hlbWEuZ2V0Tm9uRW1wdHlFbGVtZW50cygpO1xuICAgICAgY29uc3Qgd2hpdGVzcGFjZUVsZW1lbnRzID0gc2NoZW1hLmdldFdoaXRlc3BhY2VFbGVtZW50cygpO1xuICAgICAgY29uc3Qgbm9uU3BsaXR0YWJsZUVsZW1lbnRzID0gVG9vbHMubWFrZU1hcCgndHIsdGQsdGgsdGJvZHksdGhlYWQsdGZvb3QsdGFibGUnKTtcbiAgICAgIGNvbnN0IGZpeGVkID0gbmV3IFNldCgpO1xuICAgICAgZm9yIChsZXQgbmkgPSAwOyBuaSA8IG5vZGVzLmxlbmd0aDsgbmkrKykge1xuICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbbmldO1xuICAgICAgICBsZXQgcGFyZW50O1xuICAgICAgICBsZXQgbmV3UGFyZW50O1xuICAgICAgICBsZXQgdGVtcE5vZGU7XG4gICAgICAgIGlmICghbm9kZS5wYXJlbnQgfHwgZml4ZWQuaGFzKG5vZGUpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRleHRCbG9ja0VsZW1lbnRzW25vZGUubmFtZV0gJiYgbm9kZS5wYXJlbnQubmFtZSA9PT0gJ2xpJykge1xuICAgICAgICAgIGxldCBzaWJsaW5nID0gbm9kZS5uZXh0O1xuICAgICAgICAgIHdoaWxlIChzaWJsaW5nKSB7XG4gICAgICAgICAgICBpZiAodGV4dEJsb2NrRWxlbWVudHNbc2libGluZy5uYW1lXSkge1xuICAgICAgICAgICAgICBzaWJsaW5nLm5hbWUgPSAnbGknO1xuICAgICAgICAgICAgICBmaXhlZC5hZGQoc2libGluZyk7XG4gICAgICAgICAgICAgIG5vZGUucGFyZW50Lmluc2VydChzaWJsaW5nLCBub2RlLnBhcmVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNpYmxpbmcgPSBzaWJsaW5nLm5leHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUudW53cmFwKCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyZW50cyA9IFtub2RlXTtcbiAgICAgICAgZm9yIChwYXJlbnQgPSBub2RlLnBhcmVudDsgcGFyZW50ICYmICFzY2hlbWEuaXNWYWxpZENoaWxkKHBhcmVudC5uYW1lLCBub2RlLm5hbWUpICYmICFub25TcGxpdHRhYmxlRWxlbWVudHNbcGFyZW50Lm5hbWVdOyBwYXJlbnQgPSBwYXJlbnQucGFyZW50KSB7XG4gICAgICAgICAgcGFyZW50cy5wdXNoKHBhcmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBpZiAoc2NoZW1hLmlzVmFsaWRDaGlsZChwYXJlbnQubmFtZSwgbm9kZS5uYW1lKSkge1xuICAgICAgICAgICAgcGFyZW50cy5yZXZlcnNlKCk7XG4gICAgICAgICAgICBuZXdQYXJlbnQgPSBwYXJlbnRzWzBdLmNsb25lKCk7XG4gICAgICAgICAgICBvbkNyZWF0ZShuZXdQYXJlbnQpO1xuICAgICAgICAgICAgbGV0IGN1cnJlbnROb2RlID0gbmV3UGFyZW50O1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJlbnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICBpZiAoc2NoZW1hLmlzVmFsaWRDaGlsZChjdXJyZW50Tm9kZS5uYW1lLCBwYXJlbnRzW2ldLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdGVtcE5vZGUgPSBwYXJlbnRzW2ldLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgb25DcmVhdGUodGVtcE5vZGUpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLmFwcGVuZCh0ZW1wTm9kZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGVtcE5vZGUgPSBjdXJyZW50Tm9kZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmb3IgKGxldCBjaGlsZE5vZGUgPSBwYXJlbnRzW2ldLmZpcnN0Q2hpbGQ7IGNoaWxkTm9kZSAmJiBjaGlsZE5vZGUgIT09IHBhcmVudHNbaSArIDFdOykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHROb2RlID0gY2hpbGROb2RlLm5leHQ7XG4gICAgICAgICAgICAgICAgdGVtcE5vZGUuYXBwZW5kKGNoaWxkTm9kZSk7XG4gICAgICAgICAgICAgICAgY2hpbGROb2RlID0gbmV4dE5vZGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY3VycmVudE5vZGUgPSB0ZW1wTm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNFbXB0eShzY2hlbWEsIG5vbkVtcHR5RWxlbWVudHMsIHdoaXRlc3BhY2VFbGVtZW50cywgbmV3UGFyZW50KSkge1xuICAgICAgICAgICAgICBwYXJlbnQuaW5zZXJ0KG5ld1BhcmVudCwgcGFyZW50c1swXSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIHBhcmVudC5pbnNlcnQobm9kZSwgbmV3UGFyZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBhcmVudC5pbnNlcnQobm9kZSwgcGFyZW50c1swXSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnRzWzBdO1xuICAgICAgICAgICAgaWYgKGlzRW1wdHkoc2NoZW1hLCBub25FbXB0eUVsZW1lbnRzLCB3aGl0ZXNwYWNlRWxlbWVudHMsIHBhcmVudCkgfHwgaGFzT25seUNoaWxkKHBhcmVudCwgJ2JyJykpIHtcbiAgICAgICAgICAgICAgcGFyZW50LmVtcHR5KCkucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbW92ZU9yVW53cmFwSW52YWxpZE5vZGUobm9kZSwgc2NoZW1hKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS5wYXJlbnQpIHtcbiAgICAgICAgICBpZiAobm9kZS5uYW1lID09PSAnbGknKSB7XG4gICAgICAgICAgICBsZXQgc2libGluZyA9IG5vZGUucHJldjtcbiAgICAgICAgICAgIGlmIChzaWJsaW5nICYmIChzaWJsaW5nLm5hbWUgPT09ICd1bCcgfHwgc2libGluZy5uYW1lID09PSAnb2wnKSkge1xuICAgICAgICAgICAgICBzaWJsaW5nLmFwcGVuZChub2RlKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaWJsaW5nID0gbm9kZS5uZXh0O1xuICAgICAgICAgICAgaWYgKHNpYmxpbmcgJiYgKHNpYmxpbmcubmFtZSA9PT0gJ3VsJyB8fCBzaWJsaW5nLm5hbWUgPT09ICdvbCcpKSB7XG4gICAgICAgICAgICAgIHNpYmxpbmcuaW5zZXJ0KG5vZGUsIHNpYmxpbmcuZmlyc3RDaGlsZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgd3JhcHBlciA9IG5ldyBBc3ROb2RlKCd1bCcsIDEpO1xuICAgICAgICAgICAgb25DcmVhdGUod3JhcHBlcik7XG4gICAgICAgICAgICBub2RlLndyYXAod3JhcHBlcik7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNjaGVtYS5pc1ZhbGlkQ2hpbGQobm9kZS5wYXJlbnQubmFtZSwgJ2RpdicpICYmIHNjaGVtYS5pc1ZhbGlkQ2hpbGQoJ2RpdicsIG5vZGUubmFtZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHdyYXBwZXIgPSBuZXcgQXN0Tm9kZSgnZGl2JywgMSk7XG4gICAgICAgICAgICBvbkNyZWF0ZSh3cmFwcGVyKTtcbiAgICAgICAgICAgIG5vZGUud3JhcCh3cmFwcGVyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVtb3ZlT3JVbndyYXBJbnZhbGlkTm9kZShub2RlLCBzY2hlbWEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBjcmVhdGVSYW5nZSA9IChzYywgc28sIGVjLCBlbykgPT4ge1xuICAgICAgY29uc3Qgcm5nID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgIHJuZy5zZXRTdGFydChzYywgc28pO1xuICAgICAgcm5nLnNldEVuZChlYywgZW8pO1xuICAgICAgcmV0dXJuIHJuZztcbiAgICB9O1xuICAgIGNvbnN0IG5vcm1hbGl6ZUJsb2NrU2VsZWN0aW9uUmFuZ2UgPSBybmcgPT4ge1xuICAgICAgY29uc3Qgc3RhcnRQb3MgPSBDYXJldFBvc2l0aW9uLmZyb21SYW5nZVN0YXJ0KHJuZyk7XG4gICAgICBjb25zdCBlbmRQb3MgPSBDYXJldFBvc2l0aW9uLmZyb21SYW5nZUVuZChybmcpO1xuICAgICAgY29uc3Qgcm9vdE5vZGUgPSBybmcuY29tbW9uQW5jZXN0b3JDb250YWluZXI7XG4gICAgICByZXR1cm4gZnJvbVBvc2l0aW9uKGZhbHNlLCByb290Tm9kZSwgZW5kUG9zKS5tYXAobmV3RW5kUG9zID0+IHtcbiAgICAgICAgaWYgKCFpc0luU2FtZUJsb2NrKHN0YXJ0UG9zLCBlbmRQb3MsIHJvb3ROb2RlKSAmJiBpc0luU2FtZUJsb2NrKHN0YXJ0UG9zLCBuZXdFbmRQb3MsIHJvb3ROb2RlKSkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVSYW5nZShzdGFydFBvcy5jb250YWluZXIoKSwgc3RhcnRQb3Mub2Zmc2V0KCksIG5ld0VuZFBvcy5jb250YWluZXIoKSwgbmV3RW5kUG9zLm9mZnNldCgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcm5nO1xuICAgICAgICB9XG4gICAgICB9KS5nZXRPcihybmcpO1xuICAgIH07XG4gICAgY29uc3Qgbm9ybWFsaXplID0gcm5nID0+IHJuZy5jb2xsYXBzZWQgPyBybmcgOiBub3JtYWxpemVCbG9ja1NlbGVjdGlvblJhbmdlKHJuZyk7XG5cbiAgICBjb25zdCBoYXNPbmx5T25lQ2hpbGQkMSA9IG5vZGUgPT4ge1xuICAgICAgcmV0dXJuIG5vZGUuZmlyc3RDaGlsZCAmJiBub2RlLmZpcnN0Q2hpbGQgPT09IG5vZGUubGFzdENoaWxkO1xuICAgIH07XG4gICAgY29uc3QgaXNQYWRkaW5nTm9kZSA9IG5vZGUgPT4ge1xuICAgICAgcmV0dXJuIG5vZGUubmFtZSA9PT0gJ2JyJyB8fCBub2RlLnZhbHVlID09PSBuYnNwO1xuICAgIH07XG4gICAgY29uc3QgaXNQYWRkZWRFbXB0eUJsb2NrID0gKHNjaGVtYSwgbm9kZSkgPT4ge1xuICAgICAgY29uc3QgYmxvY2tFbGVtZW50cyA9IHNjaGVtYS5nZXRCbG9ja0VsZW1lbnRzKCk7XG4gICAgICByZXR1cm4gYmxvY2tFbGVtZW50c1tub2RlLm5hbWVdICYmIGhhc09ubHlPbmVDaGlsZCQxKG5vZGUpICYmIGlzUGFkZGluZ05vZGUobm9kZS5maXJzdENoaWxkKTtcbiAgICB9O1xuICAgIGNvbnN0IGlzRW1wdHlGcmFnbWVudEVsZW1lbnQgPSAoc2NoZW1hLCBub2RlKSA9PiB7XG4gICAgICBjb25zdCBub25FbXB0eUVsZW1lbnRzID0gc2NoZW1hLmdldE5vbkVtcHR5RWxlbWVudHMoKTtcbiAgICAgIHJldHVybiBub2RlICYmIChub2RlLmlzRW1wdHkobm9uRW1wdHlFbGVtZW50cykgfHwgaXNQYWRkZWRFbXB0eUJsb2NrKHNjaGVtYSwgbm9kZSkpO1xuICAgIH07XG4gICAgY29uc3QgaXNMaXN0RnJhZ21lbnQgPSAoc2NoZW1hLCBmcmFnbWVudCkgPT4ge1xuICAgICAgbGV0IGZpcnN0Q2hpbGQgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuICAgICAgbGV0IGxhc3RDaGlsZCA9IGZyYWdtZW50Lmxhc3RDaGlsZDtcbiAgICAgIGlmIChmaXJzdENoaWxkICYmIGZpcnN0Q2hpbGQubmFtZSA9PT0gJ21ldGEnKSB7XG4gICAgICAgIGZpcnN0Q2hpbGQgPSBmaXJzdENoaWxkLm5leHQ7XG4gICAgICB9XG4gICAgICBpZiAobGFzdENoaWxkICYmIGxhc3RDaGlsZC5hdHRyKCdpZCcpID09PSAnbWNlX21hcmtlcicpIHtcbiAgICAgICAgbGFzdENoaWxkID0gbGFzdENoaWxkLnByZXY7XG4gICAgICB9XG4gICAgICBpZiAoaXNFbXB0eUZyYWdtZW50RWxlbWVudChzY2hlbWEsIGxhc3RDaGlsZCkpIHtcbiAgICAgICAgbGFzdENoaWxkID0gbGFzdENoaWxkLnByZXY7XG4gICAgICB9XG4gICAgICBpZiAoIWZpcnN0Q2hpbGQgfHwgZmlyc3RDaGlsZCAhPT0gbGFzdENoaWxkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmaXJzdENoaWxkLm5hbWUgPT09ICd1bCcgfHwgZmlyc3RDaGlsZC5uYW1lID09PSAnb2wnO1xuICAgIH07XG4gICAgY29uc3QgY2xlYW51cERvbUZyYWdtZW50ID0gZG9tRnJhZ21lbnQgPT4ge1xuICAgICAgY29uc3QgZmlyc3RDaGlsZCA9IGRvbUZyYWdtZW50LmZpcnN0Q2hpbGQ7XG4gICAgICBjb25zdCBsYXN0Q2hpbGQgPSBkb21GcmFnbWVudC5sYXN0Q2hpbGQ7XG4gICAgICBpZiAoZmlyc3RDaGlsZCAmJiBmaXJzdENoaWxkLm5vZGVOYW1lID09PSAnTUVUQScpIHtcbiAgICAgICAgZmlyc3RDaGlsZC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGZpcnN0Q2hpbGQpO1xuICAgICAgfVxuICAgICAgaWYgKGxhc3RDaGlsZCAmJiBsYXN0Q2hpbGQuaWQgPT09ICdtY2VfbWFya2VyJykge1xuICAgICAgICBsYXN0Q2hpbGQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChsYXN0Q2hpbGQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRvbUZyYWdtZW50O1xuICAgIH07XG4gICAgY29uc3QgdG9Eb21GcmFnbWVudCA9IChkb20sIHNlcmlhbGl6ZXIsIGZyYWdtZW50KSA9PiB7XG4gICAgICBjb25zdCBodG1sID0gc2VyaWFsaXplci5zZXJpYWxpemUoZnJhZ21lbnQpO1xuICAgICAgY29uc3QgZG9tRnJhZ21lbnQgPSBkb20uY3JlYXRlRnJhZ21lbnQoaHRtbCk7XG4gICAgICByZXR1cm4gY2xlYW51cERvbUZyYWdtZW50KGRvbUZyYWdtZW50KTtcbiAgICB9O1xuICAgIGNvbnN0IGxpc3RJdGVtcyA9IGVsbSA9PiB7XG4gICAgICByZXR1cm4gZmlsdGVyJDYoZWxtLmNoaWxkTm9kZXMsIGNoaWxkID0+IHtcbiAgICAgICAgcmV0dXJuIGNoaWxkLm5vZGVOYW1lID09PSAnTEknO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBpc1BhZGRpbmcgPSBub2RlID0+IHtcbiAgICAgIHJldHVybiBub2RlLmRhdGEgPT09IG5ic3AgfHwgaXNCciQ1KG5vZGUpO1xuICAgIH07XG4gICAgY29uc3QgaXNMaXN0SXRlbVBhZGRlZCA9IG5vZGUgPT4ge1xuICAgICAgcmV0dXJuIG5vZGUgJiYgbm9kZS5maXJzdENoaWxkICYmIG5vZGUuZmlyc3RDaGlsZCA9PT0gbm9kZS5sYXN0Q2hpbGQgJiYgaXNQYWRkaW5nKG5vZGUuZmlyc3RDaGlsZCk7XG4gICAgfTtcbiAgICBjb25zdCBpc0VtcHR5T3JQYWRkZWQgPSBlbG0gPT4ge1xuICAgICAgcmV0dXJuICFlbG0uZmlyc3RDaGlsZCB8fCBpc0xpc3RJdGVtUGFkZGVkKGVsbSk7XG4gICAgfTtcbiAgICBjb25zdCB0cmltTGlzdEl0ZW1zID0gZWxtcyA9PiB7XG4gICAgICByZXR1cm4gZWxtcy5sZW5ndGggPiAwICYmIGlzRW1wdHlPclBhZGRlZChlbG1zW2VsbXMubGVuZ3RoIC0gMV0pID8gZWxtcy5zbGljZSgwLCAtMSkgOiBlbG1zO1xuICAgIH07XG4gICAgY29uc3QgZ2V0UGFyZW50TGkgPSAoZG9tLCBub2RlKSA9PiB7XG4gICAgICBjb25zdCBwYXJlbnRCbG9jayA9IGRvbS5nZXRQYXJlbnQobm9kZSwgZG9tLmlzQmxvY2spO1xuICAgICAgcmV0dXJuIHBhcmVudEJsb2NrICYmIHBhcmVudEJsb2NrLm5vZGVOYW1lID09PSAnTEknID8gcGFyZW50QmxvY2sgOiBudWxsO1xuICAgIH07XG4gICAgY29uc3QgaXNQYXJlbnRCbG9ja0xpID0gKGRvbSwgbm9kZSkgPT4ge1xuICAgICAgcmV0dXJuICEhZ2V0UGFyZW50TGkoZG9tLCBub2RlKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldFNwbGl0ID0gKHBhcmVudE5vZGUsIHJuZykgPT4ge1xuICAgICAgY29uc3QgYmVmb3JlUm5nID0gcm5nLmNsb25lUmFuZ2UoKTtcbiAgICAgIGNvbnN0IGFmdGVyUm5nID0gcm5nLmNsb25lUmFuZ2UoKTtcbiAgICAgIGJlZm9yZVJuZy5zZXRTdGFydEJlZm9yZShwYXJlbnROb2RlKTtcbiAgICAgIGFmdGVyUm5nLnNldEVuZEFmdGVyKHBhcmVudE5vZGUpO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgYmVmb3JlUm5nLmNsb25lQ29udGVudHMoKSxcbiAgICAgICAgYWZ0ZXJSbmcuY2xvbmVDb250ZW50cygpXG4gICAgICBdO1xuICAgIH07XG4gICAgY29uc3QgZmluZEZpcnN0SW4gPSAobm9kZSwgcm9vdE5vZGUpID0+IHtcbiAgICAgIGNvbnN0IGNhcmV0UG9zID0gQ2FyZXRQb3NpdGlvbi5iZWZvcmUobm9kZSk7XG4gICAgICBjb25zdCBjYXJldFdhbGtlciA9IENhcmV0V2Fsa2VyKHJvb3ROb2RlKTtcbiAgICAgIGNvbnN0IG5ld0NhcmV0UG9zID0gY2FyZXRXYWxrZXIubmV4dChjYXJldFBvcyk7XG4gICAgICByZXR1cm4gbmV3Q2FyZXRQb3MgPyBuZXdDYXJldFBvcy50b1JhbmdlKCkgOiBudWxsO1xuICAgIH07XG4gICAgY29uc3QgZmluZExhc3RPZiA9IChub2RlLCByb290Tm9kZSkgPT4ge1xuICAgICAgY29uc3QgY2FyZXRQb3MgPSBDYXJldFBvc2l0aW9uLmFmdGVyKG5vZGUpO1xuICAgICAgY29uc3QgY2FyZXRXYWxrZXIgPSBDYXJldFdhbGtlcihyb290Tm9kZSk7XG4gICAgICBjb25zdCBuZXdDYXJldFBvcyA9IGNhcmV0V2Fsa2VyLnByZXYoY2FyZXRQb3MpO1xuICAgICAgcmV0dXJuIG5ld0NhcmV0UG9zID8gbmV3Q2FyZXRQb3MudG9SYW5nZSgpIDogbnVsbDtcbiAgICB9O1xuICAgIGNvbnN0IGluc2VydE1pZGRsZSA9ICh0YXJnZXQsIGVsbXMsIHJvb3ROb2RlLCBybmcpID0+IHtcbiAgICAgIGNvbnN0IHBhcnRzID0gZ2V0U3BsaXQodGFyZ2V0LCBybmcpO1xuICAgICAgY29uc3QgcGFyZW50RWxtID0gdGFyZ2V0LnBhcmVudE5vZGU7XG4gICAgICBwYXJlbnRFbG0uaW5zZXJ0QmVmb3JlKHBhcnRzWzBdLCB0YXJnZXQpO1xuICAgICAgVG9vbHMuZWFjaChlbG1zLCBsaSA9PiB7XG4gICAgICAgIHBhcmVudEVsbS5pbnNlcnRCZWZvcmUobGksIHRhcmdldCk7XG4gICAgICB9KTtcbiAgICAgIHBhcmVudEVsbS5pbnNlcnRCZWZvcmUocGFydHNbMV0sIHRhcmdldCk7XG4gICAgICBwYXJlbnRFbG0ucmVtb3ZlQ2hpbGQodGFyZ2V0KTtcbiAgICAgIHJldHVybiBmaW5kTGFzdE9mKGVsbXNbZWxtcy5sZW5ndGggLSAxXSwgcm9vdE5vZGUpO1xuICAgIH07XG4gICAgY29uc3QgaW5zZXJ0QmVmb3JlJDEgPSAodGFyZ2V0LCBlbG1zLCByb290Tm9kZSkgPT4ge1xuICAgICAgY29uc3QgcGFyZW50RWxtID0gdGFyZ2V0LnBhcmVudE5vZGU7XG4gICAgICBUb29scy5lYWNoKGVsbXMsIGVsbSA9PiB7XG4gICAgICAgIHBhcmVudEVsbS5pbnNlcnRCZWZvcmUoZWxtLCB0YXJnZXQpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZmluZEZpcnN0SW4odGFyZ2V0LCByb290Tm9kZSk7XG4gICAgfTtcbiAgICBjb25zdCBpbnNlcnRBZnRlciQxID0gKHRhcmdldCwgZWxtcywgcm9vdE5vZGUsIGRvbSkgPT4ge1xuICAgICAgZG9tLmluc2VydEFmdGVyKGVsbXMucmV2ZXJzZSgpLCB0YXJnZXQpO1xuICAgICAgcmV0dXJuIGZpbmRMYXN0T2YoZWxtc1swXSwgcm9vdE5vZGUpO1xuICAgIH07XG4gICAgY29uc3QgaW5zZXJ0QXRDYXJldCQxID0gKHNlcmlhbGl6ZXIsIGRvbSwgcm5nLCBmcmFnbWVudCkgPT4ge1xuICAgICAgY29uc3QgZG9tRnJhZ21lbnQgPSB0b0RvbUZyYWdtZW50KGRvbSwgc2VyaWFsaXplciwgZnJhZ21lbnQpO1xuICAgICAgY29uc3QgbGlUYXJnZXQgPSBnZXRQYXJlbnRMaShkb20sIHJuZy5zdGFydENvbnRhaW5lcik7XG4gICAgICBjb25zdCBsaUVsbXMgPSB0cmltTGlzdEl0ZW1zKGxpc3RJdGVtcyhkb21GcmFnbWVudC5maXJzdENoaWxkKSk7XG4gICAgICBjb25zdCBCRUdJTk5JTkcgPSAxLCBFTkQgPSAyO1xuICAgICAgY29uc3Qgcm9vdE5vZGUgPSBkb20uZ2V0Um9vdCgpO1xuICAgICAgY29uc3QgaXNBdCA9IGxvY2F0aW9uID0+IHtcbiAgICAgICAgY29uc3QgY2FyZXRQb3MgPSBDYXJldFBvc2l0aW9uLmZyb21SYW5nZVN0YXJ0KHJuZyk7XG4gICAgICAgIGNvbnN0IGNhcmV0V2Fsa2VyID0gQ2FyZXRXYWxrZXIoZG9tLmdldFJvb3QoKSk7XG4gICAgICAgIGNvbnN0IG5ld1BvcyA9IGxvY2F0aW9uID09PSBCRUdJTk5JTkcgPyBjYXJldFdhbGtlci5wcmV2KGNhcmV0UG9zKSA6IGNhcmV0V2Fsa2VyLm5leHQoY2FyZXRQb3MpO1xuICAgICAgICByZXR1cm4gbmV3UG9zID8gZ2V0UGFyZW50TGkoZG9tLCBuZXdQb3MuZ2V0Tm9kZSgpKSAhPT0gbGlUYXJnZXQgOiB0cnVlO1xuICAgICAgfTtcbiAgICAgIGlmIChpc0F0KEJFR0lOTklORykpIHtcbiAgICAgICAgcmV0dXJuIGluc2VydEJlZm9yZSQxKGxpVGFyZ2V0LCBsaUVsbXMsIHJvb3ROb2RlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNBdChFTkQpKSB7XG4gICAgICAgIHJldHVybiBpbnNlcnRBZnRlciQxKGxpVGFyZ2V0LCBsaUVsbXMsIHJvb3ROb2RlLCBkb20pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGluc2VydE1pZGRsZShsaVRhcmdldCwgbGlFbG1zLCByb290Tm9kZSwgcm5nKTtcbiAgICB9O1xuXG4gICAgY29uc3QgaXNUYWJsZUNlbGwkMSA9IGlzVGFibGVDZWxsJDU7XG4gICAgY29uc3QgaXNUYWJsZUNlbGxDb250ZW50U2VsZWN0ZWQgPSAoZG9tLCBybmcsIGNlbGwpID0+IHtcbiAgICAgIGlmIChjZWxsICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGVuZENlbGwgPSBkb20uZ2V0UGFyZW50KHJuZy5lbmRDb250YWluZXIsIGlzVGFibGVDZWxsJDEpO1xuICAgICAgICByZXR1cm4gY2VsbCA9PT0gZW5kQ2VsbCAmJiBoYXNBbGxDb250ZW50c1NlbGVjdGVkKFN1Z2FyRWxlbWVudC5mcm9tRG9tKGNlbGwpLCBybmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgdmFsaWRJbnNlcnRpb24gPSAoZWRpdG9yLCB2YWx1ZSwgcGFyZW50Tm9kZSkgPT4ge1xuICAgICAgaWYgKHBhcmVudE5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLW1jZS1ib2d1cycpID09PSAnYWxsJykge1xuICAgICAgICBwYXJlbnROb2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVkaXRvci5kb20uY3JlYXRlRnJhZ21lbnQodmFsdWUpLCBwYXJlbnROb2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBwYXJlbnROb2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgIGNvbnN0IG5vZGUyID0gcGFyZW50Tm9kZS5sYXN0Q2hpbGQ7XG4gICAgICAgIGlmICghbm9kZSB8fCBub2RlID09PSBub2RlMiAmJiBub2RlLm5vZGVOYW1lID09PSAnQlInKSB7XG4gICAgICAgICAgZWRpdG9yLmRvbS5zZXRIVE1MKHBhcmVudE5vZGUsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNldENvbnRlbnQodmFsdWUsIHsgbm9fZXZlbnRzOiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCB0cmltQnJzRnJvbVRhYmxlQ2VsbCA9IChkb20sIGVsbSkgPT4ge1xuICAgICAgT3B0aW9uYWwuZnJvbShkb20uZ2V0UGFyZW50KGVsbSwgJ3RkLHRoJykpLm1hcChTdWdhckVsZW1lbnQuZnJvbURvbSkuZWFjaCh0cmltQmxvY2tUcmFpbGluZ0JyKTtcbiAgICB9O1xuICAgIGNvbnN0IHJlZHVjZUlubGluZVRleHRFbGVtZW50cyA9IChlZGl0b3IsIG1lcmdlKSA9PiB7XG4gICAgICBjb25zdCB0ZXh0SW5saW5lRWxlbWVudHMgPSBlZGl0b3Iuc2NoZW1hLmdldFRleHRJbmxpbmVFbGVtZW50cygpO1xuICAgICAgY29uc3QgZG9tID0gZWRpdG9yLmRvbTtcbiAgICAgIGlmIChtZXJnZSkge1xuICAgICAgICBjb25zdCByb290ID0gZWRpdG9yLmdldEJvZHkoKTtcbiAgICAgICAgY29uc3QgZWxlbWVudFV0aWxzID0gRWxlbWVudFV0aWxzKGRvbSk7XG4gICAgICAgIFRvb2xzLmVhY2goZG9tLnNlbGVjdCgnKltkYXRhLW1jZS1mcmFnbWVudF0nKSwgbm9kZSA9PiB7XG4gICAgICAgICAgY29uc3QgaXNJbmxpbmUgPSBpc05vbk51bGxhYmxlKHRleHRJbmxpbmVFbGVtZW50c1tub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCldKTtcbiAgICAgICAgICBpZiAoaXNJbmxpbmUgJiYgaGFzSW5oZXJpdGFibGVTdHlsZXMoZG9tLCBub2RlKSkge1xuICAgICAgICAgICAgZm9yIChsZXQgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZTsgaXNOb25OdWxsYWJsZShwYXJlbnROb2RlKSAmJiBwYXJlbnROb2RlICE9PSByb290OyBwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHN0eWxlQ29uZmxpY3QgPSBoYXNTdHlsZUNvbmZsaWN0KGRvbSwgbm9kZSwgcGFyZW50Tm9kZSk7XG4gICAgICAgICAgICAgIGlmIChzdHlsZUNvbmZsaWN0KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGVsZW1lbnRVdGlscy5jb21wYXJlKHBhcmVudE5vZGUsIG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgZG9tLnJlbW92ZShub2RlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBtYXJrRnJhZ21lbnRFbGVtZW50cyA9IGZyYWdtZW50ID0+IHtcbiAgICAgIGxldCBub2RlID0gZnJhZ21lbnQ7XG4gICAgICB3aGlsZSAobm9kZSA9IG5vZGUud2FsaygpKSB7XG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICAgICAgICBub2RlLmF0dHIoJ2RhdGEtbWNlLWZyYWdtZW50JywgJzEnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgdW5tYXJrRnJhZ21lbnRFbGVtZW50cyA9IGVsbSA9PiB7XG4gICAgICBUb29scy5lYWNoKGVsbS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnKicpLCBlbG0gPT4ge1xuICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlKCdkYXRhLW1jZS1mcmFnbWVudCcpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBpc1BhcnRPZkZyYWdtZW50ID0gbm9kZSA9PiB7XG4gICAgICByZXR1cm4gISFub2RlLmdldEF0dHJpYnV0ZSgnZGF0YS1tY2UtZnJhZ21lbnQnKTtcbiAgICB9O1xuICAgIGNvbnN0IGNhbkhhdmVDaGlsZHJlbiA9IChlZGl0b3IsIG5vZGUpID0+IHtcbiAgICAgIHJldHVybiBub2RlICYmICFlZGl0b3Iuc2NoZW1hLmdldFZvaWRFbGVtZW50cygpW25vZGUubm9kZU5hbWVdO1xuICAgIH07XG4gICAgY29uc3QgbW92ZVNlbGVjdGlvblRvTWFya2VyID0gKGVkaXRvciwgbWFya2VyKSA9PiB7XG4gICAgICBsZXQgbmV4dFJuZztcbiAgICAgIGNvbnN0IGRvbSA9IGVkaXRvci5kb207XG4gICAgICBjb25zdCBzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uO1xuICAgICAgaWYgKCFtYXJrZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2VsZWN0aW9uLnNjcm9sbEludG9WaWV3KG1hcmtlcik7XG4gICAgICBjb25zdCBwYXJlbnRFZGl0YWJsZUVsbSA9IGdldENvbnRlbnRFZGl0YWJsZVJvb3QkMShlZGl0b3IuZ2V0Qm9keSgpLCBtYXJrZXIpO1xuICAgICAgaWYgKGRvbS5nZXRDb250ZW50RWRpdGFibGUocGFyZW50RWRpdGFibGVFbG0pID09PSAnZmFsc2UnKSB7XG4gICAgICAgIGRvbS5yZW1vdmUobWFya2VyKTtcbiAgICAgICAgc2VsZWN0aW9uLnNlbGVjdChwYXJlbnRFZGl0YWJsZUVsbSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBybmcgPSBkb20uY3JlYXRlUm5nKCk7XG4gICAgICBjb25zdCBub2RlID0gbWFya2VyLnByZXZpb3VzU2libGluZztcbiAgICAgIGlmIChpc1RleHQkOChub2RlKSkge1xuICAgICAgICBybmcuc2V0U3RhcnQobm9kZSwgbm9kZS5ub2RlVmFsdWUubGVuZ3RoKTtcbiAgICAgICAgY29uc3Qgbm9kZTIgPSBtYXJrZXIubmV4dFNpYmxpbmc7XG4gICAgICAgIGlmIChpc1RleHQkOChub2RlMikpIHtcbiAgICAgICAgICBub2RlLmFwcGVuZERhdGEobm9kZTIuZGF0YSk7XG4gICAgICAgICAgbm9kZTIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlMik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJuZy5zZXRTdGFydEJlZm9yZShtYXJrZXIpO1xuICAgICAgICBybmcuc2V0RW5kQmVmb3JlKG1hcmtlcik7XG4gICAgICB9XG4gICAgICBjb25zdCBmaW5kTmV4dENhcmV0Um5nID0gcm5nID0+IHtcbiAgICAgICAgbGV0IGNhcmV0UG9zID0gQ2FyZXRQb3NpdGlvbi5mcm9tUmFuZ2VTdGFydChybmcpO1xuICAgICAgICBjb25zdCBjYXJldFdhbGtlciA9IENhcmV0V2Fsa2VyKGVkaXRvci5nZXRCb2R5KCkpO1xuICAgICAgICBjYXJldFBvcyA9IGNhcmV0V2Fsa2VyLm5leHQoY2FyZXRQb3MpO1xuICAgICAgICBpZiAoY2FyZXRQb3MpIHtcbiAgICAgICAgICByZXR1cm4gY2FyZXRQb3MudG9SYW5nZSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgcGFyZW50QmxvY2sgPSBkb20uZ2V0UGFyZW50KG1hcmtlciwgZG9tLmlzQmxvY2spO1xuICAgICAgZG9tLnJlbW92ZShtYXJrZXIpO1xuICAgICAgaWYgKHBhcmVudEJsb2NrICYmIGRvbS5pc0VtcHR5KHBhcmVudEJsb2NrKSkge1xuICAgICAgICBlbXB0eShTdWdhckVsZW1lbnQuZnJvbURvbShwYXJlbnRCbG9jaykpO1xuICAgICAgICBybmcuc2V0U3RhcnQocGFyZW50QmxvY2ssIDApO1xuICAgICAgICBybmcuc2V0RW5kKHBhcmVudEJsb2NrLCAwKTtcbiAgICAgICAgaWYgKCFpc1RhYmxlQ2VsbCQxKHBhcmVudEJsb2NrKSAmJiAhaXNQYXJ0T2ZGcmFnbWVudChwYXJlbnRCbG9jaykgJiYgKG5leHRSbmcgPSBmaW5kTmV4dENhcmV0Um5nKHJuZykpKSB7XG4gICAgICAgICAgcm5nID0gbmV4dFJuZztcbiAgICAgICAgICBkb20ucmVtb3ZlKHBhcmVudEJsb2NrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkb20uYWRkKHBhcmVudEJsb2NrLCBkb20uY3JlYXRlKCdicicsIHsgJ2RhdGEtbWNlLWJvZ3VzJzogJzEnIH0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc2VsZWN0aW9uLnNldFJuZyhybmcpO1xuICAgIH07XG4gICAgY29uc3QgZGVsZXRlU2VsZWN0ZWRDb250ZW50ID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IGRvbSA9IGVkaXRvci5kb207XG4gICAgICBjb25zdCBybmcgPSBub3JtYWxpemUoZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKSk7XG4gICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNldFJuZyhybmcpO1xuICAgICAgY29uc3Qgc3RhcnRDZWxsID0gZG9tLmdldFBhcmVudChybmcuc3RhcnRDb250YWluZXIsIGlzVGFibGVDZWxsJDEpO1xuICAgICAgaWYgKGlzVGFibGVDZWxsQ29udGVudFNlbGVjdGVkKGRvbSwgcm5nLCBzdGFydENlbGwpKSB7XG4gICAgICAgIGRlbGV0ZUNlbGxDb250ZW50cyhlZGl0b3IsIHJuZywgU3VnYXJFbGVtZW50LmZyb21Eb20oc3RhcnRDZWxsKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlZGl0b3IuZ2V0RG9jKCkuZXhlY0NvbW1hbmQoJ0RlbGV0ZScsIGZhbHNlLCBudWxsKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGluc2VydEh0bWxBdENhcmV0ID0gKGVkaXRvciwgdmFsdWUsIGRldGFpbHMpID0+IHtcbiAgICAgIGxldCBwYXJlbnROb2RlO1xuICAgICAgbGV0IHJuZywgbm9kZTtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb247XG4gICAgICBjb25zdCBkb20gPSBlZGl0b3IuZG9tO1xuICAgICAgY29uc3QgcGFyc2VyID0gZWRpdG9yLnBhcnNlcjtcbiAgICAgIGNvbnN0IG1lcmdlID0gZGV0YWlscy5tZXJnZTtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZXIgPSBIdG1sU2VyaWFsaXplcih7IHZhbGlkYXRlOiB0cnVlIH0sIGVkaXRvci5zY2hlbWEpO1xuICAgICAgY29uc3QgYm9va21hcmtIdG1sID0gJzxzcGFuIGlkPVwibWNlX21hcmtlclwiIGRhdGEtbWNlLXR5cGU9XCJib29rbWFya1wiPiYjeEZFRkY7PC9zcGFuPic7XG4gICAgICBpZiAodmFsdWUuaW5kZXhPZigneyRjYXJldH0nKSA9PT0gLTEpIHtcbiAgICAgICAgdmFsdWUgKz0gJ3skY2FyZXR9JztcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFx7XFwkY2FyZXRcXH0vLCBib29rbWFya0h0bWwpO1xuICAgICAgcm5nID0gc2VsZWN0aW9uLmdldFJuZygpO1xuICAgICAgY29uc3QgY2FyZXRFbGVtZW50ID0gcm5nLnN0YXJ0Q29udGFpbmVyIHx8IChybmcucGFyZW50RWxlbWVudCA/IHJuZy5wYXJlbnRFbGVtZW50KCkgOiBudWxsKTtcbiAgICAgIGNvbnN0IGJvZHkgPSBlZGl0b3IuZ2V0Qm9keSgpO1xuICAgICAgaWYgKGNhcmV0RWxlbWVudCA9PT0gYm9keSAmJiBzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSkge1xuICAgICAgICBpZiAoZG9tLmlzQmxvY2soYm9keS5maXJzdENoaWxkKSAmJiBjYW5IYXZlQ2hpbGRyZW4oZWRpdG9yLCBib2R5LmZpcnN0Q2hpbGQpICYmIGRvbS5pc0VtcHR5KGJvZHkuZmlyc3RDaGlsZCkpIHtcbiAgICAgICAgICBybmcgPSBkb20uY3JlYXRlUm5nKCk7XG4gICAgICAgICAgcm5nLnNldFN0YXJ0KGJvZHkuZmlyc3RDaGlsZCwgMCk7XG4gICAgICAgICAgcm5nLnNldEVuZChib2R5LmZpcnN0Q2hpbGQsIDApO1xuICAgICAgICAgIHNlbGVjdGlvbi5zZXRSbmcocm5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSkge1xuICAgICAgICBkZWxldGVTZWxlY3RlZENvbnRlbnQoZWRpdG9yKTtcbiAgICAgIH1cbiAgICAgIHBhcmVudE5vZGUgPSBzZWxlY3Rpb24uZ2V0Tm9kZSgpO1xuICAgICAgY29uc3QgcGFyc2VyQXJncyA9IHtcbiAgICAgICAgY29udGV4dDogcGFyZW50Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICBkYXRhOiBkZXRhaWxzLmRhdGEsXG4gICAgICAgIGluc2VydDogdHJ1ZVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGZyYWdtZW50ID0gcGFyc2VyLnBhcnNlKHZhbHVlLCBwYXJzZXJBcmdzKTtcbiAgICAgIGlmIChkZXRhaWxzLnBhc3RlID09PSB0cnVlICYmIGlzTGlzdEZyYWdtZW50KGVkaXRvci5zY2hlbWEsIGZyYWdtZW50KSAmJiBpc1BhcmVudEJsb2NrTGkoZG9tLCBwYXJlbnROb2RlKSkge1xuICAgICAgICBybmcgPSBpbnNlcnRBdENhcmV0JDEoc2VyaWFsaXplciwgZG9tLCBzZWxlY3Rpb24uZ2V0Um5nKCksIGZyYWdtZW50KTtcbiAgICAgICAgc2VsZWN0aW9uLnNldFJuZyhybmcpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBtYXJrRnJhZ21lbnRFbGVtZW50cyhmcmFnbWVudCk7XG4gICAgICBub2RlID0gZnJhZ21lbnQubGFzdENoaWxkO1xuICAgICAgaWYgKG5vZGUuYXR0cignaWQnKSA9PT0gJ21jZV9tYXJrZXInKSB7XG4gICAgICAgIGNvbnN0IG1hcmtlciA9IG5vZGU7XG4gICAgICAgIGZvciAobm9kZSA9IG5vZGUucHJldjsgbm9kZTsgbm9kZSA9IG5vZGUud2Fsayh0cnVlKSkge1xuICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09IDMgfHwgIWRvbS5pc0Jsb2NrKG5vZGUubmFtZSkpIHtcbiAgICAgICAgICAgIGlmIChlZGl0b3Iuc2NoZW1hLmlzVmFsaWRDaGlsZChub2RlLnBhcmVudC5uYW1lLCAnc3BhbicpKSB7XG4gICAgICAgICAgICAgIG5vZGUucGFyZW50Lmluc2VydChtYXJrZXIsIG5vZGUsIG5vZGUubmFtZSA9PT0gJ2JyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVkaXRvci5fc2VsZWN0aW9uT3ZlcnJpZGVzLnNob3dCbG9ja0NhcmV0Q29udGFpbmVyKHBhcmVudE5vZGUpO1xuICAgICAgaWYgKCFwYXJzZXJBcmdzLmludmFsaWQpIHtcbiAgICAgICAgdmFsdWUgPSBzZXJpYWxpemVyLnNlcmlhbGl6ZShmcmFnbWVudCk7XG4gICAgICAgIHZhbGlkSW5zZXJ0aW9uKGVkaXRvciwgdmFsdWUsIHBhcmVudE5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZXRDb250ZW50KGJvb2ttYXJrSHRtbCk7XG4gICAgICAgIHBhcmVudE5vZGUgPSBzZWxlY3Rpb24uZ2V0Tm9kZSgpO1xuICAgICAgICBjb25zdCByb290Tm9kZSA9IGVkaXRvci5nZXRCb2R5KCk7XG4gICAgICAgIGlmIChwYXJlbnROb2RlLm5vZGVUeXBlID09PSA5KSB7XG4gICAgICAgICAgcGFyZW50Tm9kZSA9IG5vZGUgPSByb290Tm9kZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlID0gcGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAobm9kZSAhPT0gcm9vdE5vZGUpIHtcbiAgICAgICAgICBwYXJlbnROb2RlID0gbm9kZTtcbiAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gcGFyZW50Tm9kZSA9PT0gcm9vdE5vZGUgPyByb290Tm9kZS5pbm5lckhUTUwgOiBkb20uZ2V0T3V0ZXJIVE1MKHBhcmVudE5vZGUpO1xuICAgICAgICBjb25zdCByb290ID0gcGFyc2VyLnBhcnNlKHZhbHVlKTtcbiAgICAgICAgZm9yIChsZXQgbWFya2VyTm9kZSA9IHJvb3Q7IG1hcmtlck5vZGU7IG1hcmtlck5vZGUgPSBtYXJrZXJOb2RlLndhbGsoKSkge1xuICAgICAgICAgIGlmIChtYXJrZXJOb2RlLmF0dHIoJ2lkJykgPT09ICdtY2VfbWFya2VyJykge1xuICAgICAgICAgICAgbWFya2VyTm9kZS5yZXBsYWNlKGZyYWdtZW50KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b0V4dHJhY3QgPSBmcmFnbWVudC5jaGlsZHJlbigpO1xuICAgICAgICBjb25zdCBwYXJlbnQgPSBmcmFnbWVudC5wYXJlbnQubmFtZTtcbiAgICAgICAgZnJhZ21lbnQudW53cmFwKCk7XG4gICAgICAgIGNvbnN0IGludmFsaWRDaGlsZHJlbiA9IGZpbHRlciQ2KHRvRXh0cmFjdCwgbm9kZSA9PiAhZWRpdG9yLnNjaGVtYS5pc1ZhbGlkQ2hpbGQocGFyZW50LCBub2RlLm5hbWUpKTtcbiAgICAgICAgY2xlYW5JbnZhbGlkTm9kZXMoaW52YWxpZENoaWxkcmVuLCBlZGl0b3Iuc2NoZW1hKTtcbiAgICAgICAgZmlsdGVyJDMocGFyc2VyLmdldE5vZGVGaWx0ZXJzKCksIHBhcnNlci5nZXRBdHRyaWJ1dGVGaWx0ZXJzKCksIHJvb3QpO1xuICAgICAgICB2YWx1ZSA9IHNlcmlhbGl6ZXIuc2VyaWFsaXplKHJvb3QpO1xuICAgICAgICBpZiAocGFyZW50Tm9kZSA9PT0gcm9vdE5vZGUpIHtcbiAgICAgICAgICBkb20uc2V0SFRNTChyb290Tm9kZSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRvbS5zZXRPdXRlckhUTUwocGFyZW50Tm9kZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZWR1Y2VJbmxpbmVUZXh0RWxlbWVudHMoZWRpdG9yLCBtZXJnZSk7XG4gICAgICBtb3ZlU2VsZWN0aW9uVG9NYXJrZXIoZWRpdG9yLCBkb20uZ2V0KCdtY2VfbWFya2VyJykpO1xuICAgICAgdW5tYXJrRnJhZ21lbnRFbGVtZW50cyhlZGl0b3IuZ2V0Qm9keSgpKTtcbiAgICAgIHRyaW1CcnNGcm9tVGFibGVDZWxsKGRvbSwgc2VsZWN0aW9uLmdldFN0YXJ0KCkpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG5cbiAgICBjb25zdCBpc1RyZWVOb2RlID0gY29udGVudCA9PiBjb250ZW50IGluc3RhbmNlb2YgQXN0Tm9kZTtcblxuICAgIGNvbnN0IG1vdmVTZWxlY3Rpb24gPSBlZGl0b3IgPT4ge1xuICAgICAgaWYgKGhhc0ZvY3VzKGVkaXRvcikpIHtcbiAgICAgICAgZmlyc3RQb3NpdGlvbkluKGVkaXRvci5nZXRCb2R5KCkpLmVhY2gocG9zID0+IHtcbiAgICAgICAgICBjb25zdCBub2RlID0gcG9zLmdldE5vZGUoKTtcbiAgICAgICAgICBjb25zdCBjYXJldFBvcyA9IGlzVGFibGUkMyhub2RlKSA/IGZpcnN0UG9zaXRpb25Jbihub2RlKS5nZXRPcihwb3MpIDogcG9zO1xuICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2V0Um5nKGNhcmV0UG9zLnRvUmFuZ2UoKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgc2V0RWRpdG9ySHRtbCA9IChlZGl0b3IsIGh0bWwsIG5vU2VsZWN0aW9uKSA9PiB7XG4gICAgICBlZGl0b3IuZG9tLnNldEhUTUwoZWRpdG9yLmdldEJvZHkoKSwgaHRtbCk7XG4gICAgICBpZiAobm9TZWxlY3Rpb24gIT09IHRydWUpIHtcbiAgICAgICAgbW92ZVNlbGVjdGlvbihlZGl0b3IpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgc2V0Q29udGVudFN0cmluZyA9IChlZGl0b3IsIGJvZHksIGNvbnRlbnQsIGFyZ3MpID0+IHtcbiAgICAgIGlmIChjb250ZW50Lmxlbmd0aCA9PT0gMCB8fCAvXlxccyskLy50ZXN0KGNvbnRlbnQpKSB7XG4gICAgICAgIGNvbnN0IHBhZGQgPSAnPGJyIGRhdGEtbWNlLWJvZ3VzPVwiMVwiPic7XG4gICAgICAgIGlmIChib2R5Lm5vZGVOYW1lID09PSAnVEFCTEUnKSB7XG4gICAgICAgICAgY29udGVudCA9ICc8dHI+PHRkPicgKyBwYWRkICsgJzwvdGQ+PC90cj4nO1xuICAgICAgICB9IGVsc2UgaWYgKC9eKFVMfE9MKSQvLnRlc3QoYm9keS5ub2RlTmFtZSkpIHtcbiAgICAgICAgICBjb250ZW50ID0gJzxsaT4nICsgcGFkZCArICc8L2xpPic7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZm9yY2VkUm9vdEJsb2NrTmFtZSA9IGdldEZvcmNlZFJvb3RCbG9jayhlZGl0b3IpO1xuICAgICAgICBpZiAoZWRpdG9yLnNjaGVtYS5pc1ZhbGlkQ2hpbGQoYm9keS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLCBmb3JjZWRSb290QmxvY2tOYW1lLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgICAgY29udGVudCA9IHBhZGQ7XG4gICAgICAgICAgY29udGVudCA9IGVkaXRvci5kb20uY3JlYXRlSFRNTChmb3JjZWRSb290QmxvY2tOYW1lLCBnZXRGb3JjZWRSb290QmxvY2tBdHRycyhlZGl0b3IpLCBjb250ZW50KTtcbiAgICAgICAgfSBlbHNlIGlmICghY29udGVudCkge1xuICAgICAgICAgIGNvbnRlbnQgPSBwYWRkO1xuICAgICAgICB9XG4gICAgICAgIHNldEVkaXRvckh0bWwoZWRpdG9yLCBjb250ZW50LCBhcmdzLm5vX3NlbGVjdGlvbik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY29udGVudCxcbiAgICAgICAgICBodG1sOiBjb250ZW50XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoYXJncy5mb3JtYXQgIT09ICdyYXcnKSB7XG4gICAgICAgICAgY29udGVudCA9IEh0bWxTZXJpYWxpemVyKHsgdmFsaWRhdGU6IGZhbHNlIH0sIGVkaXRvci5zY2hlbWEpLnNlcmlhbGl6ZShlZGl0b3IucGFyc2VyLnBhcnNlKGNvbnRlbnQsIHtcbiAgICAgICAgICAgIGlzUm9vdENvbnRlbnQ6IHRydWUsXG4gICAgICAgICAgICBpbnNlcnQ6IHRydWVcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHJpbW1lZEh0bWwgPSBpc1dzUHJlc2VydmVFbGVtZW50KFN1Z2FyRWxlbWVudC5mcm9tRG9tKGJvZHkpKSA/IGNvbnRlbnQgOiBUb29scy50cmltKGNvbnRlbnQpO1xuICAgICAgICBzZXRFZGl0b3JIdG1sKGVkaXRvciwgdHJpbW1lZEh0bWwsIGFyZ3Mubm9fc2VsZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjb250ZW50OiB0cmltbWVkSHRtbCxcbiAgICAgICAgICBodG1sOiB0cmltbWVkSHRtbFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgc2V0Q29udGVudFRyZWUgPSAoZWRpdG9yLCBib2R5LCBjb250ZW50LCBhcmdzKSA9PiB7XG4gICAgICBmaWx0ZXIkMyhlZGl0b3IucGFyc2VyLmdldE5vZGVGaWx0ZXJzKCksIGVkaXRvci5wYXJzZXIuZ2V0QXR0cmlidXRlRmlsdGVycygpLCBjb250ZW50KTtcbiAgICAgIGNvbnN0IGh0bWwgPSBIdG1sU2VyaWFsaXplcih7IHZhbGlkYXRlOiBmYWxzZSB9LCBlZGl0b3Iuc2NoZW1hKS5zZXJpYWxpemUoY29udGVudCk7XG4gICAgICBjb25zdCB0cmltbWVkSHRtbCA9IGlzV3NQcmVzZXJ2ZUVsZW1lbnQoU3VnYXJFbGVtZW50LmZyb21Eb20oYm9keSkpID8gaHRtbCA6IFRvb2xzLnRyaW0oaHRtbCk7XG4gICAgICBzZXRFZGl0b3JIdG1sKGVkaXRvciwgdHJpbW1lZEh0bWwsIGFyZ3Mubm9fc2VsZWN0aW9uKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbnRlbnQsXG4gICAgICAgIGh0bWw6IHRyaW1tZWRIdG1sXG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3Qgc2V0Q29udGVudEludGVybmFsID0gKGVkaXRvciwgY29udGVudCwgYXJncykgPT4ge1xuICAgICAgcmV0dXJuIE9wdGlvbmFsLmZyb20oZWRpdG9yLmdldEJvZHkoKSkubWFwKGJvZHkgPT4ge1xuICAgICAgICBpZiAoaXNUcmVlTm9kZShjb250ZW50KSkge1xuICAgICAgICAgIHJldHVybiBzZXRDb250ZW50VHJlZShlZGl0b3IsIGJvZHksIGNvbnRlbnQsIGFyZ3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBzZXRDb250ZW50U3RyaW5nKGVkaXRvciwgYm9keSwgY29udGVudCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH0pLmdldE9yKHtcbiAgICAgICAgY29udGVudCxcbiAgICAgICAgaHRtbDogaXNUcmVlTm9kZShhcmdzLmNvbnRlbnQpID8gJycgOiBhcmdzLmNvbnRlbnRcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCBzaWJsaW5nID0gKHNjb3BlLCBwcmVkaWNhdGUpID0+IHNpYmxpbmckMShzY29wZSwgcHJlZGljYXRlKS5pc1NvbWUoKTtcblxuICAgIGNvbnN0IGVuc3VyZUlzUm9vdCA9IGlzUm9vdCA9PiBpc0Z1bmN0aW9uKGlzUm9vdCkgPyBpc1Jvb3QgOiBuZXZlcjtcbiAgICBjb25zdCBhbmNlc3RvciA9IChzY29wZSwgdHJhbnNmb3JtLCBpc1Jvb3QpID0+IHtcbiAgICAgIGxldCBlbGVtZW50ID0gc2NvcGUuZG9tO1xuICAgICAgY29uc3Qgc3RvcCA9IGVuc3VyZUlzUm9vdChpc1Jvb3QpO1xuICAgICAgd2hpbGUgKGVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgICBjb25zdCBlbCA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVsZW1lbnQpO1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZCA9IHRyYW5zZm9ybShlbCk7XG4gICAgICAgIGlmICh0cmFuc2Zvcm1lZC5pc1NvbWUoKSkge1xuICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1lZDtcbiAgICAgICAgfSBlbHNlIGlmIChzdG9wKGVsKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgIH07XG4gICAgY29uc3QgY2xvc2VzdCQyID0gKHNjb3BlLCB0cmFuc2Zvcm0sIGlzUm9vdCkgPT4ge1xuICAgICAgY29uc3QgY3VycmVudCA9IHRyYW5zZm9ybShzY29wZSk7XG4gICAgICBjb25zdCBzdG9wID0gZW5zdXJlSXNSb290KGlzUm9vdCk7XG4gICAgICByZXR1cm4gY3VycmVudC5vclRodW5rKCgpID0+IHN0b3Aoc2NvcGUpID8gT3B0aW9uYWwubm9uZSgpIDogYW5jZXN0b3Ioc2NvcGUsIHRyYW5zZm9ybSwgc3RvcCkpO1xuICAgIH07XG5cbiAgICBjb25zdCBpc0VxJDMgPSBpc0VxJDU7XG4gICAgY29uc3QgbWF0Y2hlc1VuSW5oZXJpdGVkRm9ybWF0U2VsZWN0b3IgPSAoZWQsIG5vZGUsIG5hbWUpID0+IHtcbiAgICAgIGNvbnN0IGZvcm1hdExpc3QgPSBlZC5mb3JtYXR0ZXIuZ2V0KG5hbWUpO1xuICAgICAgaWYgKGZvcm1hdExpc3QpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmb3JtYXRMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgZm9ybWF0ID0gZm9ybWF0TGlzdFtpXTtcbiAgICAgICAgICBpZiAoaXNTZWxlY3RvckZvcm1hdChmb3JtYXQpICYmIGZvcm1hdC5pbmhlcml0ID09PSBmYWxzZSAmJiBlZC5kb20uaXMobm9kZSwgZm9ybWF0LnNlbGVjdG9yKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBjb25zdCBtYXRjaFBhcmVudHMgPSAoZWRpdG9yLCBub2RlLCBuYW1lLCB2YXJzLCBzaW1pbGFyKSA9PiB7XG4gICAgICBjb25zdCByb290ID0gZWRpdG9yLmRvbS5nZXRSb290KCk7XG4gICAgICBpZiAobm9kZSA9PT0gcm9vdCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBub2RlID0gZWRpdG9yLmRvbS5nZXRQYXJlbnQobm9kZSwgbm9kZSA9PiB7XG4gICAgICAgIGlmIChtYXRjaGVzVW5Jbmhlcml0ZWRGb3JtYXRTZWxlY3RvcihlZGl0b3IsIG5vZGUsIG5hbWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUucGFyZW50Tm9kZSA9PT0gcm9vdCB8fCAhIW1hdGNoTm9kZShlZGl0b3IsIG5vZGUsIG5hbWUsIHZhcnMsIHRydWUpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gISFtYXRjaE5vZGUoZWRpdG9yLCBub2RlLCBuYW1lLCB2YXJzLCBzaW1pbGFyKTtcbiAgICB9O1xuICAgIGNvbnN0IG1hdGNoTmFtZSA9IChkb20sIG5vZGUsIGZvcm1hdCkgPT4ge1xuICAgICAgaWYgKGlzSW5saW5lRm9ybWF0KGZvcm1hdCkgJiYgaXNFcSQzKG5vZGUsIGZvcm1hdC5pbmxpbmUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzQmxvY2tGb3JtYXQoZm9ybWF0KSAmJiBpc0VxJDMobm9kZSwgZm9ybWF0LmJsb2NrKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1NlbGVjdG9yRm9ybWF0KGZvcm1hdCkpIHtcbiAgICAgICAgcmV0dXJuIGlzRWxlbWVudCQ2KG5vZGUpICYmIGRvbS5pcyhub2RlLCBmb3JtYXQuc2VsZWN0b3IpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgY29uc3QgbWF0Y2hJdGVtcyA9IChkb20sIG5vZGUsIGZvcm1hdCwgaXRlbU5hbWUsIHNpbWlsYXIsIHZhcnMpID0+IHtcbiAgICAgIGNvbnN0IGl0ZW1zID0gZm9ybWF0W2l0ZW1OYW1lXTtcbiAgICAgIGlmIChpc0Z1bmN0aW9uKGZvcm1hdC5vbm1hdGNoKSkge1xuICAgICAgICByZXR1cm4gZm9ybWF0Lm9ubWF0Y2gobm9kZSwgZm9ybWF0LCBpdGVtTmFtZSk7XG4gICAgICB9XG4gICAgICBpZiAoaXRlbXMpIHtcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGl0ZW1zLmxlbmd0aCkpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBpdGVtcykge1xuICAgICAgICAgICAgaWYgKGhhcyQyKGl0ZW1zLCBrZXkpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gaXRlbU5hbWUgPT09ICdhdHRyaWJ1dGVzJyA/IGRvbS5nZXRBdHRyaWIobm9kZSwga2V5KSA6IGdldFN0eWxlKGRvbSwgbm9kZSwga2V5KTtcbiAgICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRWYWx1ZSA9IHJlcGxhY2VWYXJzKGl0ZW1zW2tleV0sIHZhcnMpO1xuICAgICAgICAgICAgICBjb25zdCBpc0VtcHR5VmFsdWUgPSBpc051bGxhYmxlKHZhbHVlKSB8fCBpc0VtcHR5JDModmFsdWUpO1xuICAgICAgICAgICAgICBpZiAoaXNFbXB0eVZhbHVlICYmIGlzTnVsbGFibGUoZXhwZWN0ZWRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoc2ltaWxhciAmJiBpc0VtcHR5VmFsdWUgJiYgIWZvcm1hdC5leGFjdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoKCFzaW1pbGFyIHx8IGZvcm1hdC5leGFjdCkgJiYgIWlzRXEkMyh2YWx1ZSwgbm9ybWFsaXplU3R5bGVWYWx1ZShleHBlY3RlZFZhbHVlLCBrZXkpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaXRlbU5hbWUgPT09ICdhdHRyaWJ1dGVzJyA/IGRvbS5nZXRBdHRyaWIobm9kZSwgaXRlbXNbaV0pIDogZ2V0U3R5bGUoZG9tLCBub2RlLCBpdGVtc1tpXSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIGNvbnN0IG1hdGNoTm9kZSA9IChlZCwgbm9kZSwgbmFtZSwgdmFycywgc2ltaWxhcikgPT4ge1xuICAgICAgY29uc3QgZm9ybWF0TGlzdCA9IGVkLmZvcm1hdHRlci5nZXQobmFtZSk7XG4gICAgICBjb25zdCBkb20gPSBlZC5kb207XG4gICAgICBpZiAoZm9ybWF0TGlzdCAmJiBub2RlKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZm9ybWF0TGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGZvcm1hdCA9IGZvcm1hdExpc3RbaV07XG4gICAgICAgICAgaWYgKG1hdGNoTmFtZShlZC5kb20sIG5vZGUsIGZvcm1hdCkgJiYgbWF0Y2hJdGVtcyhkb20sIG5vZGUsIGZvcm1hdCwgJ2F0dHJpYnV0ZXMnLCBzaW1pbGFyLCB2YXJzKSAmJiBtYXRjaEl0ZW1zKGRvbSwgbm9kZSwgZm9ybWF0LCAnc3R5bGVzJywgc2ltaWxhciwgdmFycykpIHtcbiAgICAgICAgICAgIGNvbnN0IGNsYXNzZXMgPSBmb3JtYXQuY2xhc3NlcztcbiAgICAgICAgICAgIGlmIChjbGFzc2VzKSB7XG4gICAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgY2xhc3Nlcy5sZW5ndGg7IHgrKykge1xuICAgICAgICAgICAgICAgIGlmICghZWQuZG9tLmhhc0NsYXNzKG5vZGUsIHJlcGxhY2VWYXJzKGNsYXNzZXNbeF0sIHZhcnMpKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG1hdGNoJDIgPSAoZWRpdG9yLCBuYW1lLCB2YXJzLCBub2RlLCBzaW1pbGFyKSA9PiB7XG4gICAgICBpZiAobm9kZSkge1xuICAgICAgICByZXR1cm4gbWF0Y2hQYXJlbnRzKGVkaXRvciwgbm9kZSwgbmFtZSwgdmFycywgc2ltaWxhcik7XG4gICAgICB9XG4gICAgICBub2RlID0gZWRpdG9yLnNlbGVjdGlvbi5nZXROb2RlKCk7XG4gICAgICBpZiAobWF0Y2hQYXJlbnRzKGVkaXRvciwgbm9kZSwgbmFtZSwgdmFycywgc2ltaWxhcikpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBjb25zdCBzdGFydE5vZGUgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldFN0YXJ0KCk7XG4gICAgICBpZiAoc3RhcnROb2RlICE9PSBub2RlKSB7XG4gICAgICAgIGlmIChtYXRjaFBhcmVudHMoZWRpdG9yLCBzdGFydE5vZGUsIG5hbWUsIHZhcnMsIHNpbWlsYXIpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIGNvbnN0IG1hdGNoQWxsID0gKGVkaXRvciwgbmFtZXMsIHZhcnMpID0+IHtcbiAgICAgIGNvbnN0IG1hdGNoZWRGb3JtYXROYW1lcyA9IFtdO1xuICAgICAgY29uc3QgY2hlY2tlZE1hcCA9IHt9O1xuICAgICAgY29uc3Qgc3RhcnRFbGVtZW50ID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRTdGFydCgpO1xuICAgICAgZWRpdG9yLmRvbS5nZXRQYXJlbnQoc3RhcnRFbGVtZW50LCBub2RlID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgICAgICBpZiAoIWNoZWNrZWRNYXBbbmFtZV0gJiYgbWF0Y2hOb2RlKGVkaXRvciwgbm9kZSwgbmFtZSwgdmFycykpIHtcbiAgICAgICAgICAgIGNoZWNrZWRNYXBbbmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgbWF0Y2hlZEZvcm1hdE5hbWVzLnB1c2gobmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBlZGl0b3IuZG9tLmdldFJvb3QoKSk7XG4gICAgICByZXR1cm4gbWF0Y2hlZEZvcm1hdE5hbWVzO1xuICAgIH07XG4gICAgY29uc3QgY2xvc2VzdCQxID0gKGVkaXRvciwgbmFtZXMpID0+IHtcbiAgICAgIGNvbnN0IGlzUm9vdCA9IGVsbSA9PiBlcShlbG0sIFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVkaXRvci5nZXRCb2R5KCkpKTtcbiAgICAgIGNvbnN0IG1hdGNoID0gKGVsbSwgbmFtZSkgPT4gbWF0Y2hOb2RlKGVkaXRvciwgZWxtLmRvbSwgbmFtZSkgPyBPcHRpb25hbC5zb21lKG5hbWUpIDogT3B0aW9uYWwubm9uZSgpO1xuICAgICAgcmV0dXJuIE9wdGlvbmFsLmZyb20oZWRpdG9yLnNlbGVjdGlvbi5nZXRTdGFydCh0cnVlKSkuYmluZChyYXdFbG0gPT4gY2xvc2VzdCQyKFN1Z2FyRWxlbWVudC5mcm9tRG9tKHJhd0VsbSksIGVsbSA9PiBmaW5kTWFwKG5hbWVzLCBuYW1lID0+IG1hdGNoKGVsbSwgbmFtZSkpLCBpc1Jvb3QpKS5nZXRPck51bGwoKTtcbiAgICB9O1xuICAgIGNvbnN0IGNhbkFwcGx5ID0gKGVkaXRvciwgbmFtZSkgPT4ge1xuICAgICAgY29uc3QgZm9ybWF0TGlzdCA9IGVkaXRvci5mb3JtYXR0ZXIuZ2V0KG5hbWUpO1xuICAgICAgY29uc3QgZG9tID0gZWRpdG9yLmRvbTtcbiAgICAgIGlmIChmb3JtYXRMaXN0KSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0Tm9kZSA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0U3RhcnQoKTtcbiAgICAgICAgY29uc3QgcGFyZW50cyA9IGdldFBhcmVudHMkMihkb20sIHN0YXJ0Tm9kZSk7XG4gICAgICAgIGZvciAobGV0IHggPSBmb3JtYXRMaXN0Lmxlbmd0aCAtIDE7IHggPj0gMDsgeC0tKSB7XG4gICAgICAgICAgY29uc3QgZm9ybWF0ID0gZm9ybWF0TGlzdFt4XTtcbiAgICAgICAgICBpZiAoIWlzU2VsZWN0b3JGb3JtYXQoZm9ybWF0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAobGV0IGkgPSBwYXJlbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAoZG9tLmlzKHBhcmVudHNbaV0sIGZvcm1hdC5zZWxlY3RvcikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBjb25zdCBtYXRjaEFsbE9uTm9kZSA9IChlZGl0b3IsIG5vZGUsIGZvcm1hdE5hbWVzKSA9PiBmb2xkbChmb3JtYXROYW1lcywgKGFjYywgbmFtZSkgPT4ge1xuICAgICAgY29uc3QgbWF0Y2hTaW1pbGFyID0gaXNWYXJpYWJsZUZvcm1hdE5hbWUoZWRpdG9yLCBuYW1lKTtcbiAgICAgIGlmIChlZGl0b3IuZm9ybWF0dGVyLm1hdGNoTm9kZShub2RlLCBuYW1lLCB7fSwgbWF0Y2hTaW1pbGFyKSkge1xuICAgICAgICByZXR1cm4gYWNjLmNvbmNhdChbbmFtZV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH1cbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCBaV1NQID0gWldTUCQxLCBDQVJFVF9JRCA9ICdfbWNlX2NhcmV0JztcbiAgICBjb25zdCBpbXBvcnROb2RlID0gKG93bmVyRG9jdW1lbnQsIG5vZGUpID0+IHtcbiAgICAgIHJldHVybiBvd25lckRvY3VtZW50LmltcG9ydE5vZGUobm9kZSwgdHJ1ZSk7XG4gICAgfTtcbiAgICBjb25zdCBnZXRFbXB0eUNhcmV0Q29udGFpbmVycyA9IG5vZGUgPT4ge1xuICAgICAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAzICYmIG5vZGUubm9kZVZhbHVlICE9PSBaV1NQIHx8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgbm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH07XG4gICAgY29uc3QgaXNDYXJldENvbnRhaW5lckVtcHR5ID0gbm9kZSA9PiB7XG4gICAgICByZXR1cm4gZ2V0RW1wdHlDYXJldENvbnRhaW5lcnMobm9kZSkubGVuZ3RoID4gMDtcbiAgICB9O1xuICAgIGNvbnN0IGZpbmRGaXJzdFRleHROb2RlID0gbm9kZSA9PiB7XG4gICAgICBpZiAobm9kZSkge1xuICAgICAgICBjb25zdCB3YWxrZXIgPSBuZXcgRG9tVHJlZVdhbGtlcihub2RlLCBub2RlKTtcbiAgICAgICAgZm9yIChub2RlID0gd2Fsa2VyLmN1cnJlbnQoKTsgbm9kZTsgbm9kZSA9IHdhbGtlci5uZXh0KCkpIHtcbiAgICAgICAgICBpZiAoaXNUZXh0JDgobm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBjb25zdCBjcmVhdGVDYXJldENvbnRhaW5lciA9IGZpbGwgPT4ge1xuICAgICAgY29uc3QgY2FyZXRDb250YWluZXIgPSBTdWdhckVsZW1lbnQuZnJvbVRhZygnc3BhbicpO1xuICAgICAgc2V0QWxsJDEoY2FyZXRDb250YWluZXIsIHtcbiAgICAgICAgJ2lkJzogQ0FSRVRfSUQsXG4gICAgICAgICdkYXRhLW1jZS1ib2d1cyc6ICcxJyxcbiAgICAgICAgJ2RhdGEtbWNlLXR5cGUnOiAnZm9ybWF0LWNhcmV0J1xuICAgICAgfSk7XG4gICAgICBpZiAoZmlsbCkge1xuICAgICAgICBhcHBlbmQkMShjYXJldENvbnRhaW5lciwgU3VnYXJFbGVtZW50LmZyb21UZXh0KFpXU1ApKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYXJldENvbnRhaW5lcjtcbiAgICB9O1xuICAgIGNvbnN0IHRyaW1ad3NwRnJvbUNhcmV0Q29udGFpbmVyID0gY2FyZXRDb250YWluZXJOb2RlID0+IHtcbiAgICAgIGNvbnN0IHRleHROb2RlID0gZmluZEZpcnN0VGV4dE5vZGUoY2FyZXRDb250YWluZXJOb2RlKTtcbiAgICAgIGlmICh0ZXh0Tm9kZSAmJiB0ZXh0Tm9kZS5ub2RlVmFsdWUuY2hhckF0KDApID09PSBaV1NQKSB7XG4gICAgICAgIHRleHROb2RlLmRlbGV0ZURhdGEoMCwgMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGV4dE5vZGU7XG4gICAgfTtcbiAgICBjb25zdCByZW1vdmVDYXJldENvbnRhaW5lck5vZGUgPSAoZWRpdG9yLCBub2RlLCBtb3ZlQ2FyZXQgPSB0cnVlKSA9PiB7XG4gICAgICBjb25zdCBkb20gPSBlZGl0b3IuZG9tLCBzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uO1xuICAgICAgaWYgKGlzQ2FyZXRDb250YWluZXJFbXB0eShub2RlKSkge1xuICAgICAgICBkZWxldGVFbGVtZW50JDIoZWRpdG9yLCBmYWxzZSwgU3VnYXJFbGVtZW50LmZyb21Eb20obm9kZSksIG1vdmVDYXJldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBybmcgPSBzZWxlY3Rpb24uZ2V0Um5nKCk7XG4gICAgICAgIGNvbnN0IGJsb2NrID0gZG9tLmdldFBhcmVudChub2RlLCBkb20uaXNCbG9jayk7XG4gICAgICAgIGNvbnN0IHN0YXJ0Q29udGFpbmVyID0gcm5nLnN0YXJ0Q29udGFpbmVyO1xuICAgICAgICBjb25zdCBzdGFydE9mZnNldCA9IHJuZy5zdGFydE9mZnNldDtcbiAgICAgICAgY29uc3QgZW5kQ29udGFpbmVyID0gcm5nLmVuZENvbnRhaW5lcjtcbiAgICAgICAgY29uc3QgZW5kT2Zmc2V0ID0gcm5nLmVuZE9mZnNldDtcbiAgICAgICAgY29uc3QgdGV4dE5vZGUgPSB0cmltWndzcEZyb21DYXJldENvbnRhaW5lcihub2RlKTtcbiAgICAgICAgZG9tLnJlbW92ZShub2RlLCB0cnVlKTtcbiAgICAgICAgaWYgKHN0YXJ0Q29udGFpbmVyID09PSB0ZXh0Tm9kZSAmJiBzdGFydE9mZnNldCA+IDApIHtcbiAgICAgICAgICBybmcuc2V0U3RhcnQodGV4dE5vZGUsIHN0YXJ0T2Zmc2V0IC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZENvbnRhaW5lciA9PT0gdGV4dE5vZGUgJiYgZW5kT2Zmc2V0ID4gMCkge1xuICAgICAgICAgIHJuZy5zZXRFbmQodGV4dE5vZGUsIGVuZE9mZnNldCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChibG9jayAmJiBkb20uaXNFbXB0eShibG9jaykpIHtcbiAgICAgICAgICBmaWxsV2l0aFBhZGRpbmdCcihTdWdhckVsZW1lbnQuZnJvbURvbShibG9jaykpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGVjdGlvbi5zZXRSbmcocm5nKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlbW92ZUNhcmV0Q29udGFpbmVyID0gKGVkaXRvciwgbm9kZSwgbW92ZUNhcmV0ID0gdHJ1ZSkgPT4ge1xuICAgICAgY29uc3QgZG9tID0gZWRpdG9yLmRvbSwgc2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbjtcbiAgICAgIGlmICghbm9kZSkge1xuICAgICAgICBub2RlID0gZ2V0UGFyZW50Q2FyZXRDb250YWluZXIoZWRpdG9yLmdldEJvZHkoKSwgc2VsZWN0aW9uLmdldFN0YXJ0KCkpO1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICB3aGlsZSAobm9kZSA9IGRvbS5nZXQoQ0FSRVRfSUQpKSB7XG4gICAgICAgICAgICByZW1vdmVDYXJldENvbnRhaW5lck5vZGUoZWRpdG9yLCBub2RlLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW1vdmVDYXJldENvbnRhaW5lck5vZGUoZWRpdG9yLCBub2RlLCBtb3ZlQ2FyZXQpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaW5zZXJ0Q2FyZXRDb250YWluZXJOb2RlID0gKGVkaXRvciwgY2FyZXRDb250YWluZXIsIGZvcm1hdE5vZGUpID0+IHtcbiAgICAgIGNvbnN0IGRvbSA9IGVkaXRvci5kb20sIGJsb2NrID0gZG9tLmdldFBhcmVudChmb3JtYXROb2RlLCBjdXJyeShpc1RleHRCbG9jayQxLCBlZGl0b3IpKTtcbiAgICAgIGlmIChibG9jayAmJiBkb20uaXNFbXB0eShibG9jaykpIHtcbiAgICAgICAgZm9ybWF0Tm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChjYXJldENvbnRhaW5lciwgZm9ybWF0Tm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW1vdmVUcmFpbGluZ0JyKFN1Z2FyRWxlbWVudC5mcm9tRG9tKGZvcm1hdE5vZGUpKTtcbiAgICAgICAgaWYgKGRvbS5pc0VtcHR5KGZvcm1hdE5vZGUpKSB7XG4gICAgICAgICAgZm9ybWF0Tm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChjYXJldENvbnRhaW5lciwgZm9ybWF0Tm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZG9tLmluc2VydEFmdGVyKGNhcmV0Q29udGFpbmVyLCBmb3JtYXROb2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgYXBwZW5kTm9kZSA9IChwYXJlbnROb2RlLCBub2RlKSA9PiB7XG4gICAgICBwYXJlbnROb2RlLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcbiAgICBjb25zdCBpbnNlcnRGb3JtYXROb2Rlc0ludG9DYXJldENvbnRhaW5lciA9IChmb3JtYXROb2RlcywgY2FyZXRDb250YWluZXIpID0+IHtcbiAgICAgIGNvbnN0IGlubmVyTW9zdEZvcm1hdE5vZGUgPSBmb2xkcihmb3JtYXROb2RlcywgKHBhcmVudE5vZGUsIGZvcm1hdE5vZGUpID0+IHtcbiAgICAgICAgcmV0dXJuIGFwcGVuZE5vZGUocGFyZW50Tm9kZSwgZm9ybWF0Tm9kZS5jbG9uZU5vZGUoZmFsc2UpKTtcbiAgICAgIH0sIGNhcmV0Q29udGFpbmVyKTtcbiAgICAgIHJldHVybiBhcHBlbmROb2RlKGlubmVyTW9zdEZvcm1hdE5vZGUsIGlubmVyTW9zdEZvcm1hdE5vZGUub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShaV1NQKSk7XG4gICAgfTtcbiAgICBjb25zdCBjbGVhbkZvcm1hdE5vZGUgPSAoZWRpdG9yLCBjYXJldENvbnRhaW5lciwgZm9ybWF0Tm9kZSwgbmFtZSwgdmFycywgc2ltaWxhcikgPT4ge1xuICAgICAgY29uc3QgZm9ybWF0dGVyID0gZWRpdG9yLmZvcm1hdHRlcjtcbiAgICAgIGNvbnN0IGRvbSA9IGVkaXRvci5kb207XG4gICAgICBjb25zdCB2YWxpZEZvcm1hdHMgPSBmaWx0ZXIkNihrZXlzKGZvcm1hdHRlci5nZXQoKSksIGZvcm1hdE5hbWUgPT4gZm9ybWF0TmFtZSAhPT0gbmFtZSAmJiAhY29udGFpbnMkMShmb3JtYXROYW1lLCAncmVtb3ZlZm9ybWF0JykpO1xuICAgICAgY29uc3QgbWF0Y2hlZEZvcm1hdHMgPSBtYXRjaEFsbE9uTm9kZShlZGl0b3IsIGZvcm1hdE5vZGUsIHZhbGlkRm9ybWF0cyk7XG4gICAgICBjb25zdCB1bmlxdWVGb3JtYXRzID0gZmlsdGVyJDYobWF0Y2hlZEZvcm1hdHMsIGZtdE5hbWUgPT4gIWFyZVNpbWlsYXJGb3JtYXRzKGVkaXRvciwgZm10TmFtZSwgbmFtZSkpO1xuICAgICAgaWYgKHVuaXF1ZUZvcm1hdHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBjbG9uZWRGb3JtYXROb2RlID0gZm9ybWF0Tm9kZS5jbG9uZU5vZGUoZmFsc2UpO1xuICAgICAgICBkb20uYWRkKGNhcmV0Q29udGFpbmVyLCBjbG9uZWRGb3JtYXROb2RlKTtcbiAgICAgICAgZm9ybWF0dGVyLnJlbW92ZShuYW1lLCB2YXJzLCBjbG9uZWRGb3JtYXROb2RlLCBzaW1pbGFyKTtcbiAgICAgICAgZG9tLnJlbW92ZShjbG9uZWRGb3JtYXROb2RlKTtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoY2xvbmVkRm9ybWF0Tm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgYXBwbHlDYXJldEZvcm1hdCA9IChlZGl0b3IsIG5hbWUsIHZhcnMpID0+IHtcbiAgICAgIGxldCBjYXJldENvbnRhaW5lciwgdGV4dE5vZGU7XG4gICAgICBjb25zdCBzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uO1xuICAgICAgY29uc3Qgc2VsZWN0aW9uUm5nID0gc2VsZWN0aW9uLmdldFJuZygpO1xuICAgICAgbGV0IG9mZnNldCA9IHNlbGVjdGlvblJuZy5zdGFydE9mZnNldDtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHNlbGVjdGlvblJuZy5zdGFydENvbnRhaW5lcjtcbiAgICAgIGNvbnN0IHRleHQgPSBjb250YWluZXIubm9kZVZhbHVlO1xuICAgICAgY2FyZXRDb250YWluZXIgPSBnZXRQYXJlbnRDYXJldENvbnRhaW5lcihlZGl0b3IuZ2V0Qm9keSgpLCBzZWxlY3Rpb24uZ2V0U3RhcnQoKSk7XG4gICAgICBpZiAoY2FyZXRDb250YWluZXIpIHtcbiAgICAgICAgdGV4dE5vZGUgPSBmaW5kRmlyc3RUZXh0Tm9kZShjYXJldENvbnRhaW5lcik7XG4gICAgICB9XG4gICAgICBjb25zdCB3b3JkY2hhclJlZ2V4ID0gL1teXFxzXFx1MDBhMFxcdTAwYWRcXHUyMDBiXFx1ZmVmZl0vO1xuICAgICAgaWYgKHRleHQgJiYgb2Zmc2V0ID4gMCAmJiBvZmZzZXQgPCB0ZXh0Lmxlbmd0aCAmJiB3b3JkY2hhclJlZ2V4LnRlc3QodGV4dC5jaGFyQXQob2Zmc2V0KSkgJiYgd29yZGNoYXJSZWdleC50ZXN0KHRleHQuY2hhckF0KG9mZnNldCAtIDEpKSkge1xuICAgICAgICBjb25zdCBib29rbWFyayA9IHNlbGVjdGlvbi5nZXRCb29rbWFyaygpO1xuICAgICAgICBzZWxlY3Rpb25SbmcuY29sbGFwc2UodHJ1ZSk7XG4gICAgICAgIGxldCBybmcgPSBleHBhbmRSbmcoZWRpdG9yLCBzZWxlY3Rpb25SbmcsIGVkaXRvci5mb3JtYXR0ZXIuZ2V0KG5hbWUpKTtcbiAgICAgICAgcm5nID0gc3BsaXQocm5nKTtcbiAgICAgICAgZWRpdG9yLmZvcm1hdHRlci5hcHBseShuYW1lLCB2YXJzLCBybmcpO1xuICAgICAgICBzZWxlY3Rpb24ubW92ZVRvQm9va21hcmsoYm9va21hcmspO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFjYXJldENvbnRhaW5lciB8fCB0ZXh0Tm9kZS5ub2RlVmFsdWUgIT09IFpXU1ApIHtcbiAgICAgICAgICBjYXJldENvbnRhaW5lciA9IGltcG9ydE5vZGUoZWRpdG9yLmdldERvYygpLCBjcmVhdGVDYXJldENvbnRhaW5lcih0cnVlKS5kb20pO1xuICAgICAgICAgIHRleHROb2RlID0gY2FyZXRDb250YWluZXIuZmlyc3RDaGlsZDtcbiAgICAgICAgICBzZWxlY3Rpb25SbmcuaW5zZXJ0Tm9kZShjYXJldENvbnRhaW5lcik7XG4gICAgICAgICAgb2Zmc2V0ID0gMTtcbiAgICAgICAgICBlZGl0b3IuZm9ybWF0dGVyLmFwcGx5KG5hbWUsIHZhcnMsIGNhcmV0Q29udGFpbmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlZGl0b3IuZm9ybWF0dGVyLmFwcGx5KG5hbWUsIHZhcnMsIGNhcmV0Q29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBzZWxlY3Rpb24uc2V0Q3Vyc29yTG9jYXRpb24odGV4dE5vZGUsIG9mZnNldCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCByZW1vdmVDYXJldEZvcm1hdCA9IChlZGl0b3IsIG5hbWUsIHZhcnMsIHNpbWlsYXIpID0+IHtcbiAgICAgIGNvbnN0IGRvbSA9IGVkaXRvci5kb207XG4gICAgICBjb25zdCBzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uO1xuICAgICAgbGV0IGhhc0NvbnRlbnRBZnRlciwgbm9kZSwgZm9ybWF0Tm9kZTtcbiAgICAgIGNvbnN0IHBhcmVudHMgPSBbXTtcbiAgICAgIGNvbnN0IHJuZyA9IHNlbGVjdGlvbi5nZXRSbmcoKTtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHJuZy5zdGFydENvbnRhaW5lcjtcbiAgICAgIGNvbnN0IG9mZnNldCA9IHJuZy5zdGFydE9mZnNldDtcbiAgICAgIG5vZGUgPSBjb250YWluZXI7XG4gICAgICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSAzKSB7XG4gICAgICAgIGlmIChvZmZzZXQgIT09IGNvbnRhaW5lci5ub2RlVmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgaGFzQ29udGVudEFmdGVyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgaWYgKG1hdGNoTm9kZShlZGl0b3IsIG5vZGUsIG5hbWUsIHZhcnMsIHNpbWlsYXIpKSB7XG4gICAgICAgICAgZm9ybWF0Tm9kZSA9IG5vZGU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICBoYXNDb250ZW50QWZ0ZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudHMucHVzaChub2RlKTtcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICAgIGlmICghZm9ybWF0Tm9kZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaGFzQ29udGVudEFmdGVyKSB7XG4gICAgICAgIGNvbnN0IGJvb2ttYXJrID0gc2VsZWN0aW9uLmdldEJvb2ttYXJrKCk7XG4gICAgICAgIHJuZy5jb2xsYXBzZSh0cnVlKTtcbiAgICAgICAgbGV0IGV4cGFuZGVkUm5nID0gZXhwYW5kUm5nKGVkaXRvciwgcm5nLCBlZGl0b3IuZm9ybWF0dGVyLmdldChuYW1lKSwgdHJ1ZSk7XG4gICAgICAgIGV4cGFuZGVkUm5nID0gc3BsaXQoZXhwYW5kZWRSbmcpO1xuICAgICAgICBlZGl0b3IuZm9ybWF0dGVyLnJlbW92ZShuYW1lLCB2YXJzLCBleHBhbmRlZFJuZywgc2ltaWxhcik7XG4gICAgICAgIHNlbGVjdGlvbi5tb3ZlVG9Cb29rbWFyayhib29rbWFyayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjYXJldENvbnRhaW5lciA9IGdldFBhcmVudENhcmV0Q29udGFpbmVyKGVkaXRvci5nZXRCb2R5KCksIGZvcm1hdE5vZGUpO1xuICAgICAgICBjb25zdCBuZXdDYXJldENvbnRhaW5lciA9IGNyZWF0ZUNhcmV0Q29udGFpbmVyKGZhbHNlKS5kb207XG4gICAgICAgIGluc2VydENhcmV0Q29udGFpbmVyTm9kZShlZGl0b3IsIG5ld0NhcmV0Q29udGFpbmVyLCBjYXJldENvbnRhaW5lciAhPT0gbnVsbCA/IGNhcmV0Q29udGFpbmVyIDogZm9ybWF0Tm9kZSk7XG4gICAgICAgIGNvbnN0IGNsZWFuZWRGb3JtYXROb2RlID0gY2xlYW5Gb3JtYXROb2RlKGVkaXRvciwgbmV3Q2FyZXRDb250YWluZXIsIGZvcm1hdE5vZGUsIG5hbWUsIHZhcnMsIHNpbWlsYXIpO1xuICAgICAgICBjb25zdCBjYXJldFRleHROb2RlID0gaW5zZXJ0Rm9ybWF0Tm9kZXNJbnRvQ2FyZXRDb250YWluZXIocGFyZW50cy5jb25jYXQoY2xlYW5lZEZvcm1hdE5vZGUudG9BcnJheSgpKSwgbmV3Q2FyZXRDb250YWluZXIpO1xuICAgICAgICByZW1vdmVDYXJldENvbnRhaW5lck5vZGUoZWRpdG9yLCBjYXJldENvbnRhaW5lciwgZmFsc2UpO1xuICAgICAgICBzZWxlY3Rpb24uc2V0Q3Vyc29yTG9jYXRpb24oY2FyZXRUZXh0Tm9kZSwgMSk7XG4gICAgICAgIGlmIChkb20uaXNFbXB0eShmb3JtYXROb2RlKSkge1xuICAgICAgICAgIGRvbS5yZW1vdmUoZm9ybWF0Tm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGRpc2FibGVDYXJldENvbnRhaW5lciA9IChlZGl0b3IsIGtleUNvZGUpID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb24sIGJvZHkgPSBlZGl0b3IuZ2V0Qm9keSgpO1xuICAgICAgcmVtb3ZlQ2FyZXRDb250YWluZXIoZWRpdG9yLCBudWxsLCBmYWxzZSk7XG4gICAgICBpZiAoKGtleUNvZGUgPT09IDggfHwga2V5Q29kZSA9PT0gNDYpICYmIHNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpICYmIHNlbGVjdGlvbi5nZXRTdGFydCgpLmlubmVySFRNTCA9PT0gWldTUCkge1xuICAgICAgICByZW1vdmVDYXJldENvbnRhaW5lcihlZGl0b3IsIGdldFBhcmVudENhcmV0Q29udGFpbmVyKGJvZHksIHNlbGVjdGlvbi5nZXRTdGFydCgpKSk7XG4gICAgICB9XG4gICAgICBpZiAoa2V5Q29kZSA9PT0gMzcgfHwga2V5Q29kZSA9PT0gMzkpIHtcbiAgICAgICAgcmVtb3ZlQ2FyZXRDb250YWluZXIoZWRpdG9yLCBnZXRQYXJlbnRDYXJldENvbnRhaW5lcihib2R5LCBzZWxlY3Rpb24uZ2V0U3RhcnQoKSkpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgc2V0dXAkdSA9IGVkaXRvciA9PiB7XG4gICAgICBlZGl0b3Iub24oJ21vdXNldXAga2V5ZG93bicsIGUgPT4ge1xuICAgICAgICBkaXNhYmxlQ2FyZXRDb250YWluZXIoZWRpdG9yLCBlLmtleUNvZGUpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCByZXBsYWNlV2l0aENhcmV0Rm9ybWF0ID0gKHRhcmdldE5vZGUsIGZvcm1hdE5vZGVzKSA9PiB7XG4gICAgICBjb25zdCBjYXJldENvbnRhaW5lciA9IGNyZWF0ZUNhcmV0Q29udGFpbmVyKGZhbHNlKTtcbiAgICAgIGNvbnN0IGlubmVyTW9zdCA9IGluc2VydEZvcm1hdE5vZGVzSW50b0NhcmV0Q29udGFpbmVyKGZvcm1hdE5vZGVzLCBjYXJldENvbnRhaW5lci5kb20pO1xuICAgICAgYmVmb3JlJDMoU3VnYXJFbGVtZW50LmZyb21Eb20odGFyZ2V0Tm9kZSksIGNhcmV0Q29udGFpbmVyKTtcbiAgICAgIHJlbW92ZSQ1KFN1Z2FyRWxlbWVudC5mcm9tRG9tKHRhcmdldE5vZGUpKTtcbiAgICAgIHJldHVybiBDYXJldFBvc2l0aW9uKGlubmVyTW9zdCwgMCk7XG4gICAgfTtcbiAgICBjb25zdCBpc0Zvcm1hdEVsZW1lbnQgPSAoZWRpdG9yLCBlbGVtZW50KSA9PiB7XG4gICAgICBjb25zdCBpbmxpbmVFbGVtZW50cyA9IGVkaXRvci5zY2hlbWEuZ2V0VGV4dElubGluZUVsZW1lbnRzKCk7XG4gICAgICByZXR1cm4gaGFzJDIoaW5saW5lRWxlbWVudHMsIG5hbWUoZWxlbWVudCkpICYmICFpc0NhcmV0Tm9kZShlbGVtZW50LmRvbSkgJiYgIWlzQm9ndXMkMihlbGVtZW50LmRvbSk7XG4gICAgfTtcbiAgICBjb25zdCBpc0VtcHR5Q2FyZXRGb3JtYXRFbGVtZW50ID0gZWxlbWVudCA9PiB7XG4gICAgICByZXR1cm4gaXNDYXJldE5vZGUoZWxlbWVudC5kb20pICYmIGlzQ2FyZXRDb250YWluZXJFbXB0eShlbGVtZW50LmRvbSk7XG4gICAgfTtcblxuICAgIGNvbnN0IHBvc3RQcm9jZXNzSG9va3MgPSB7fTtcbiAgICBjb25zdCBmaWx0ZXIkMiA9IGZpbHRlciQ0O1xuICAgIGNvbnN0IGVhY2gkYSA9IGVhY2gkZTtcbiAgICBjb25zdCBhZGRQb3N0UHJvY2Vzc0hvb2sgPSAobmFtZSwgaG9vaykgPT4ge1xuICAgICAgY29uc3QgaG9va3MgPSBwb3N0UHJvY2Vzc0hvb2tzW25hbWVdO1xuICAgICAgaWYgKCFob29rcykge1xuICAgICAgICBwb3N0UHJvY2Vzc0hvb2tzW25hbWVdID0gW107XG4gICAgICB9XG4gICAgICBwb3N0UHJvY2Vzc0hvb2tzW25hbWVdLnB1c2goaG9vayk7XG4gICAgfTtcbiAgICBjb25zdCBwb3N0UHJvY2VzcyQxID0gKG5hbWUsIGVkaXRvcikgPT4ge1xuICAgICAgZWFjaCRhKHBvc3RQcm9jZXNzSG9va3NbbmFtZV0sIGhvb2sgPT4ge1xuICAgICAgICBob29rKGVkaXRvcik7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGFkZFBvc3RQcm9jZXNzSG9vaygncHJlJywgZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IHJuZyA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCk7XG4gICAgICBsZXQgYmxvY2tzO1xuICAgICAgY29uc3QgaGFzUHJlU2libGluZyA9IHByZSA9PiB7XG4gICAgICAgIHJldHVybiBpc1ByZShwcmUucHJldmlvdXNTaWJsaW5nKSAmJiBpbmRleE9mKGJsb2NrcywgcHJlLnByZXZpb3VzU2libGluZykgIT09IC0xO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGpvaW5QcmUgPSAocHJlMSwgcHJlMikgPT4ge1xuICAgICAgICBjb25zdCBzUHJlMiA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKHByZTIpO1xuICAgICAgICBjb25zdCBkb2MgPSBkb2N1bWVudE9yT3duZXIoc1ByZTIpLmRvbTtcbiAgICAgICAgcmVtb3ZlJDUoc1ByZTIpO1xuICAgICAgICBhcHBlbmQoU3VnYXJFbGVtZW50LmZyb21Eb20ocHJlMSksIFtcbiAgICAgICAgICBTdWdhckVsZW1lbnQuZnJvbVRhZygnYnInLCBkb2MpLFxuICAgICAgICAgIFN1Z2FyRWxlbWVudC5mcm9tVGFnKCdicicsIGRvYyksXG4gICAgICAgICAgLi4uY2hpbGRyZW4oc1ByZTIpXG4gICAgICAgIF0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGlzUHJlID0gbWF0Y2hOb2RlTmFtZXMoWydwcmUnXSk7XG4gICAgICBpZiAoIXJuZy5jb2xsYXBzZWQpIHtcbiAgICAgICAgYmxvY2tzID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRTZWxlY3RlZEJsb2NrcygpO1xuICAgICAgICBlYWNoJGEoZmlsdGVyJDIoZmlsdGVyJDIoYmxvY2tzLCBpc1ByZSksIGhhc1ByZVNpYmxpbmcpLCBwcmUgPT4ge1xuICAgICAgICAgIGpvaW5QcmUocHJlLnByZXZpb3VzU2libGluZywgcHJlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBlYWNoJDkgPSBUb29scy5lYWNoO1xuICAgIGNvbnN0IGlzRWxlbWVudE5vZGUkMSA9IG5vZGUgPT4gaXNFbGVtZW50JDYobm9kZSkgJiYgIWlzQm9va21hcmtOb2RlJDEobm9kZSkgJiYgIWlzQ2FyZXROb2RlKG5vZGUpICYmICFpc0JvZ3VzJDIobm9kZSk7XG4gICAgY29uc3QgZmluZEVsZW1lbnRTaWJsaW5nID0gKG5vZGUsIHNpYmxpbmdOYW1lKSA9PiB7XG4gICAgICBmb3IgKGxldCBzaWJsaW5nID0gbm9kZTsgc2libGluZzsgc2libGluZyA9IHNpYmxpbmdbc2libGluZ05hbWVdKSB7XG4gICAgICAgIGlmIChpc1RleHQkOChzaWJsaW5nKSAmJiBpc05vdEVtcHR5KHNpYmxpbmcuZGF0YSkpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNFbGVtZW50JDYoc2libGluZykgJiYgIWlzQm9va21hcmtOb2RlJDEoc2libGluZykpIHtcbiAgICAgICAgICByZXR1cm4gc2libGluZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcbiAgICBjb25zdCBtZXJnZVNpYmxpbmdzTm9kZXMgPSAoZG9tLCBwcmV2LCBuZXh0KSA9PiB7XG4gICAgICBjb25zdCBlbGVtZW50VXRpbHMgPSBFbGVtZW50VXRpbHMoZG9tKTtcbiAgICAgIGlmIChwcmV2ICYmIG5leHQpIHtcbiAgICAgICAgcHJldiA9IGZpbmRFbGVtZW50U2libGluZyhwcmV2LCAncHJldmlvdXNTaWJsaW5nJyk7XG4gICAgICAgIG5leHQgPSBmaW5kRWxlbWVudFNpYmxpbmcobmV4dCwgJ25leHRTaWJsaW5nJyk7XG4gICAgICAgIGlmIChlbGVtZW50VXRpbHMuY29tcGFyZShwcmV2LCBuZXh0KSkge1xuICAgICAgICAgIGZvciAobGV0IHNpYmxpbmcgPSBwcmV2Lm5leHRTaWJsaW5nOyBzaWJsaW5nICYmIHNpYmxpbmcgIT09IG5leHQ7KSB7XG4gICAgICAgICAgICBjb25zdCB0bXBTaWJsaW5nID0gc2libGluZztcbiAgICAgICAgICAgIHNpYmxpbmcgPSBzaWJsaW5nLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgcHJldi5hcHBlbmRDaGlsZCh0bXBTaWJsaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZG9tLnJlbW92ZShuZXh0KTtcbiAgICAgICAgICBUb29scy5lYWNoKFRvb2xzLmdyZXAobmV4dC5jaGlsZE5vZGVzKSwgbm9kZSA9PiB7XG4gICAgICAgICAgICBwcmV2LmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICAgIGNvbnN0IG1lcmdlU2libGluZ3MgPSAoZG9tLCBmb3JtYXQsIHZhcnMsIG5vZGUpID0+IHtcbiAgICAgIGlmIChub2RlICYmIGZvcm1hdC5tZXJnZV9zaWJsaW5ncyAhPT0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgbmV3Tm9kZSA9IG1lcmdlU2libGluZ3NOb2Rlcyhkb20sIGdldE5vbldoaXRlU3BhY2VTaWJsaW5nKG5vZGUpLCBub2RlKTtcbiAgICAgICAgbWVyZ2VTaWJsaW5nc05vZGVzKGRvbSwgbmV3Tm9kZSwgZ2V0Tm9uV2hpdGVTcGFjZVNpYmxpbmcobmV3Tm9kZSwgdHJ1ZSkpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgY2xlYXJDaGlsZFN0eWxlcyA9IChkb20sIGZvcm1hdCwgbm9kZSkgPT4ge1xuICAgICAgaWYgKGZvcm1hdC5jbGVhcl9jaGlsZF9zdHlsZXMpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBmb3JtYXQubGlua3MgPyAnKjpub3QoYSknIDogJyonO1xuICAgICAgICBlYWNoJDkoZG9tLnNlbGVjdChzZWxlY3Rvciwgbm9kZSksIG5vZGUgPT4ge1xuICAgICAgICAgIGlmIChpc0VsZW1lbnROb2RlJDEobm9kZSkpIHtcbiAgICAgICAgICAgIGVhY2gkOShmb3JtYXQuc3R5bGVzLCAodmFsdWUsIG5hbWUpID0+IHtcbiAgICAgICAgICAgICAgZG9tLnNldFN0eWxlKG5vZGUsIG5hbWUsICcnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBwcm9jZXNzQ2hpbGRFbGVtZW50cyA9IChub2RlLCBmaWx0ZXIsIHByb2Nlc3MpID0+IHtcbiAgICAgIGVhY2gkOShub2RlLmNoaWxkTm9kZXMsIG5vZGUgPT4ge1xuICAgICAgICBpZiAoaXNFbGVtZW50Tm9kZSQxKG5vZGUpKSB7XG4gICAgICAgICAgaWYgKGZpbHRlcihub2RlKSkge1xuICAgICAgICAgICAgcHJvY2Vzcyhub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5vZGUuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgICBwcm9jZXNzQ2hpbGRFbGVtZW50cyhub2RlLCBmaWx0ZXIsIHByb2Nlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCB1bndyYXBFbXB0eVNwYW4gPSAoZG9tLCBub2RlKSA9PiB7XG4gICAgICBpZiAobm9kZS5ub2RlTmFtZSA9PT0gJ1NQQU4nICYmIGRvbS5nZXRBdHRyaWJzKG5vZGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBkb20ucmVtb3ZlKG5vZGUsIHRydWUpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaGFzU3R5bGUgPSAoZG9tLCBuYW1lKSA9PiBub2RlID0+ICEhKG5vZGUgJiYgZ2V0U3R5bGUoZG9tLCBub2RlLCBuYW1lKSk7XG4gICAgY29uc3QgYXBwbHlTdHlsZSA9IChkb20sIG5hbWUsIHZhbHVlKSA9PiBub2RlID0+IHtcbiAgICAgIGRvbS5zZXRTdHlsZShub2RlLCBuYW1lLCB2YWx1ZSk7XG4gICAgICBpZiAobm9kZS5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykgPT09ICcnKSB7XG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICAgICAgfVxuICAgICAgdW53cmFwRW1wdHlTcGFuKGRvbSwgbm9kZSk7XG4gICAgfTtcblxuICAgIGNvbnN0IHJlbW92ZVJlc3VsdCA9IEFkdC5nZW5lcmF0ZShbXG4gICAgICB7IGtlZXA6IFtdIH0sXG4gICAgICB7IHJlbmFtZTogWyduYW1lJ10gfSxcbiAgICAgIHsgcmVtb3ZlZDogW10gfVxuICAgIF0pO1xuICAgIGNvbnN0IE1DRV9BVFRSX1JFID0gL14oc3JjfGhyZWZ8c3R5bGUpJC87XG4gICAgY29uc3QgZWFjaCQ4ID0gVG9vbHMuZWFjaDtcbiAgICBjb25zdCBpc0VxJDIgPSBpc0VxJDU7XG4gICAgY29uc3QgaXNUYWJsZUNlbGxPclJvdyA9IG5vZGUgPT4gL14oVFJ8VEh8VEQpJC8udGVzdChub2RlLm5vZGVOYW1lKTtcbiAgICBjb25zdCBpc0NoaWxkT2ZJbmxpbmVQYXJlbnQgPSAoZG9tLCBub2RlLCBwYXJlbnQpID0+IGRvbS5pc0NoaWxkT2Yobm9kZSwgcGFyZW50KSAmJiBub2RlICE9PSBwYXJlbnQgJiYgIWRvbS5pc0Jsb2NrKHBhcmVudCk7XG4gICAgY29uc3QgZ2V0Q29udGFpbmVyID0gKGVkLCBybmcsIHN0YXJ0KSA9PiB7XG4gICAgICBsZXQgY29udGFpbmVyID0gcm5nW3N0YXJ0ID8gJ3N0YXJ0Q29udGFpbmVyJyA6ICdlbmRDb250YWluZXInXTtcbiAgICAgIGxldCBvZmZzZXQgPSBybmdbc3RhcnQgPyAnc3RhcnRPZmZzZXQnIDogJ2VuZE9mZnNldCddO1xuICAgICAgaWYgKGlzRWxlbWVudCQ2KGNvbnRhaW5lcikpIHtcbiAgICAgICAgY29uc3QgbGFzdElkeCA9IGNvbnRhaW5lci5jaGlsZE5vZGVzLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmICghc3RhcnQgJiYgb2Zmc2V0KSB7XG4gICAgICAgICAgb2Zmc2V0LS07XG4gICAgICAgIH1cbiAgICAgICAgY29udGFpbmVyID0gY29udGFpbmVyLmNoaWxkTm9kZXNbb2Zmc2V0ID4gbGFzdElkeCA/IGxhc3RJZHggOiBvZmZzZXRdO1xuICAgICAgfVxuICAgICAgaWYgKGlzVGV4dCQ4KGNvbnRhaW5lcikgJiYgc3RhcnQgJiYgb2Zmc2V0ID49IGNvbnRhaW5lci5ub2RlVmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIGNvbnRhaW5lciA9IG5ldyBEb21UcmVlV2Fsa2VyKGNvbnRhaW5lciwgZWQuZ2V0Qm9keSgpKS5uZXh0KCkgfHwgY29udGFpbmVyO1xuICAgICAgfVxuICAgICAgaWYgKGlzVGV4dCQ4KGNvbnRhaW5lcikgJiYgIXN0YXJ0ICYmIG9mZnNldCA9PT0gMCkge1xuICAgICAgICBjb250YWluZXIgPSBuZXcgRG9tVHJlZVdhbGtlcihjb250YWluZXIsIGVkLmdldEJvZHkoKSkucHJldigpIHx8IGNvbnRhaW5lcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgfTtcbiAgICBjb25zdCBub3JtYWxpemVUYWJsZVNlbGVjdGlvbiA9IChub2RlLCBzdGFydCkgPT4ge1xuICAgICAgY29uc3QgcHJvcCA9IHN0YXJ0ID8gJ2ZpcnN0Q2hpbGQnIDogJ2xhc3RDaGlsZCc7XG4gICAgICBpZiAoaXNUYWJsZUNlbGxPclJvdyhub2RlKSAmJiBub2RlW3Byb3BdKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkTm9kZSA9IG5vZGVbcHJvcF07XG4gICAgICAgIGlmIChub2RlLm5vZGVOYW1lID09PSAnVFInKSB7XG4gICAgICAgICAgcmV0dXJuIGNoaWxkTm9kZVtwcm9wXSB8fCBjaGlsZE5vZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGNoaWxkTm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcbiAgICBjb25zdCB3cmFwJDEgPSAoZG9tLCBub2RlLCBuYW1lLCBhdHRycykgPT4ge1xuICAgICAgY29uc3Qgd3JhcHBlciA9IGRvbS5jcmVhdGUobmFtZSwgYXR0cnMpO1xuICAgICAgbm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh3cmFwcGVyLCBub2RlKTtcbiAgICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9O1xuICAgIGNvbnN0IHdyYXBXaXRoU2libGluZ3MgPSAoZG9tLCBub2RlLCBuZXh0LCBuYW1lLCBhdHRycykgPT4ge1xuICAgICAgY29uc3Qgc3RhcnQgPSBTdWdhckVsZW1lbnQuZnJvbURvbShub2RlKTtcbiAgICAgIGNvbnN0IHdyYXBwZXIgPSBTdWdhckVsZW1lbnQuZnJvbURvbShkb20uY3JlYXRlKG5hbWUsIGF0dHJzKSk7XG4gICAgICBjb25zdCBzaWJsaW5ncyA9IG5leHQgPyBuZXh0U2libGluZ3Moc3RhcnQpIDogcHJldlNpYmxpbmdzKHN0YXJ0KTtcbiAgICAgIGFwcGVuZCh3cmFwcGVyLCBzaWJsaW5ncyk7XG4gICAgICBpZiAobmV4dCkge1xuICAgICAgICBiZWZvcmUkMyhzdGFydCwgd3JhcHBlcik7XG4gICAgICAgIHByZXBlbmQod3JhcHBlciwgc3RhcnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWZ0ZXIkNChzdGFydCwgd3JhcHBlcik7XG4gICAgICAgIGFwcGVuZCQxKHdyYXBwZXIsIHN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cmFwcGVyLmRvbTtcbiAgICB9O1xuICAgIGNvbnN0IGlzQ29sb3JGb3JtYXRBbmRBbmNob3IgPSAobm9kZSwgZm9ybWF0KSA9PiBmb3JtYXQubGlua3MgJiYgbm9kZS5ub2RlTmFtZSA9PT0gJ0EnO1xuICAgIGNvbnN0IHJlbW92ZU5vZGUgPSAoZWQsIG5vZGUsIGZvcm1hdCkgPT4ge1xuICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgIGxldCByb290QmxvY2tFbG07XG4gICAgICBjb25zdCBkb20gPSBlZC5kb207XG4gICAgICBjb25zdCBmb3JjZWRSb290QmxvY2sgPSBnZXRGb3JjZWRSb290QmxvY2soZWQpO1xuICAgICAgaWYgKGlzQmxvY2tGb3JtYXQoZm9ybWF0KSkge1xuICAgICAgICBpZiAocGFyZW50Tm9kZSA9PT0gZG9tLmdldFJvb3QoKSkge1xuICAgICAgICAgIGlmICghZm9ybWF0Lmxpc3RfYmxvY2sgfHwgIWlzRXEkMihub2RlLCBmb3JtYXQubGlzdF9ibG9jaykpIHtcbiAgICAgICAgICAgIGVhY2gkZyhmcm9tKG5vZGUuY2hpbGROb2RlcyksIG5vZGUgPT4ge1xuICAgICAgICAgICAgICBpZiAoaXNWYWxpZChlZCwgZm9yY2VkUm9vdEJsb2NrLCBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyb290QmxvY2tFbG0pIHtcbiAgICAgICAgICAgICAgICAgIHJvb3RCbG9ja0VsbSA9IHdyYXAkMShkb20sIG5vZGUsIGZvcmNlZFJvb3RCbG9jayk7XG4gICAgICAgICAgICAgICAgICBkb20uc2V0QXR0cmlicyhyb290QmxvY2tFbG0sIGdldEZvcmNlZFJvb3RCbG9ja0F0dHJzKGVkKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJvb3RCbG9ja0VsbS5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcm9vdEJsb2NrRWxtID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNNaXhlZEZvcm1hdChmb3JtYXQpICYmICFpc0VxJDIoZm9ybWF0LmlubGluZSwgbm9kZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZG9tLnJlbW92ZShub2RlLCB0cnVlKTtcbiAgICB9O1xuICAgIGNvbnN0IHJlbW92ZUZvcm1hdEludGVybmFsID0gKGVkLCBmb3JtYXQsIHZhcnMsIG5vZGUsIGNvbXBhcmVOb2RlKSA9PiB7XG4gICAgICBsZXQgc3R5bGVzTW9kaWZpZWQ7XG4gICAgICBjb25zdCBkb20gPSBlZC5kb207XG4gICAgICBpZiAoIW1hdGNoTmFtZShkb20sIG5vZGUsIGZvcm1hdCkgJiYgIWlzQ29sb3JGb3JtYXRBbmRBbmNob3Iobm9kZSwgZm9ybWF0KSkge1xuICAgICAgICByZXR1cm4gcmVtb3ZlUmVzdWx0LmtlZXAoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVsbSA9IG5vZGU7XG4gICAgICBpZiAoaXNJbmxpbmVGb3JtYXQoZm9ybWF0KSAmJiBmb3JtYXQucmVtb3ZlID09PSAnYWxsJyAmJiBpc0FycmF5JDEoZm9ybWF0LnByZXNlcnZlX2F0dHJpYnV0ZXMpKSB7XG4gICAgICAgIGNvbnN0IGF0dHJzVG9QcmVzZXJ2ZSA9IGZpbHRlciQ2KGRvbS5nZXRBdHRyaWJzKGVsbSksIGF0dHIgPT4gY29udGFpbnMkMihmb3JtYXQucHJlc2VydmVfYXR0cmlidXRlcywgYXR0ci5uYW1lLnRvTG93ZXJDYXNlKCkpKTtcbiAgICAgICAgZG9tLnJlbW92ZUFsbEF0dHJpYnMoZWxtKTtcbiAgICAgICAgZWFjaCRnKGF0dHJzVG9QcmVzZXJ2ZSwgYXR0ciA9PiBkb20uc2V0QXR0cmliKGVsbSwgYXR0ci5uYW1lLCBhdHRyLnZhbHVlKSk7XG4gICAgICAgIGlmIChhdHRyc1RvUHJlc2VydmUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJldHVybiByZW1vdmVSZXN1bHQucmVuYW1lKCdzcGFuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3JtYXQucmVtb3ZlICE9PSAnYWxsJykge1xuICAgICAgICBlYWNoJDgoZm9ybWF0LnN0eWxlcywgKHZhbHVlLCBuYW1lKSA9PiB7XG4gICAgICAgICAgdmFsdWUgPSBub3JtYWxpemVTdHlsZVZhbHVlKHJlcGxhY2VWYXJzKHZhbHVlLCB2YXJzKSwgbmFtZSArICcnKTtcbiAgICAgICAgICBpZiAoaXNOdW1iZXIobmFtZSkpIHtcbiAgICAgICAgICAgIG5hbWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIGNvbXBhcmVOb2RlID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGZvcm1hdC5yZW1vdmVfc2ltaWxhciB8fCAoIWNvbXBhcmVOb2RlIHx8IGlzRXEkMihnZXRTdHlsZShkb20sIGNvbXBhcmVOb2RlLCBuYW1lKSwgdmFsdWUpKSkge1xuICAgICAgICAgICAgZG9tLnNldFN0eWxlKGVsbSwgbmFtZSwgJycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdHlsZXNNb2RpZmllZCA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc3R5bGVzTW9kaWZpZWQgJiYgZG9tLmdldEF0dHJpYihlbG0sICdzdHlsZScpID09PSAnJykge1xuICAgICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1tY2Utc3R5bGUnKTtcbiAgICAgICAgfVxuICAgICAgICBlYWNoJDgoZm9ybWF0LmF0dHJpYnV0ZXMsICh2YWx1ZSwgbmFtZSkgPT4ge1xuICAgICAgICAgIGxldCB2YWx1ZU91dDtcbiAgICAgICAgICB2YWx1ZSA9IHJlcGxhY2VWYXJzKHZhbHVlLCB2YXJzKTtcbiAgICAgICAgICBpZiAoaXNOdW1iZXIobmFtZSkpIHtcbiAgICAgICAgICAgIG5hbWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIGNvbXBhcmVOb2RlID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGZvcm1hdC5yZW1vdmVfc2ltaWxhciB8fCAoIWNvbXBhcmVOb2RlIHx8IGlzRXEkMihkb20uZ2V0QXR0cmliKGNvbXBhcmVOb2RlLCBuYW1lKSwgdmFsdWUpKSkge1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdjbGFzcycpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBkb20uZ2V0QXR0cmliKGVsbSwgbmFtZSk7XG4gICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhbHVlT3V0ID0gJyc7XG4gICAgICAgICAgICAgICAgZWFjaCRnKHZhbHVlLnNwbGl0KC9cXHMrLyksIGNscyA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAoL21jZVxcLVxcdysvLnRlc3QoY2xzKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZU91dCArPSAodmFsdWVPdXQgPyAnICcgOiAnJykgKyBjbHM7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlT3V0KSB7XG4gICAgICAgICAgICAgICAgICBkb20uc2V0QXR0cmliKGVsbSwgbmFtZSwgdmFsdWVPdXQpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKE1DRV9BVFRSX1JFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1tY2UtJyArIG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdzdHlsZScgJiYgbWF0Y2hOb2RlTmFtZXMoWydsaSddKShlbG0pICYmIGRvbS5nZXRTdHlsZShlbG0sICdsaXN0LXN0eWxlLXR5cGUnKSA9PT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgICAgICAgIGRvbS5zZXRTdHlsZShlbG0sICdsaXN0LXN0eWxlLXR5cGUnLCAnbm9uZScpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2NsYXNzJykge1xuICAgICAgICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlKCdjbGFzc05hbWUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZWFjaCQ4KGZvcm1hdC5jbGFzc2VzLCB2YWx1ZSA9PiB7XG4gICAgICAgICAgdmFsdWUgPSByZXBsYWNlVmFycyh2YWx1ZSwgdmFycyk7XG4gICAgICAgICAgaWYgKCFjb21wYXJlTm9kZSB8fCBkb20uaGFzQ2xhc3MoY29tcGFyZU5vZGUsIHZhbHVlKSkge1xuICAgICAgICAgICAgZG9tLnJlbW92ZUNsYXNzKGVsbSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGF0dHJzID0gZG9tLmdldEF0dHJpYnMoZWxtKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGF0dHJOYW1lID0gYXR0cnNbaV0ubm9kZU5hbWU7XG4gICAgICAgICAgaWYgKGF0dHJOYW1lLmluZGV4T2YoJ18nKSAhPT0gMCAmJiBhdHRyTmFtZS5pbmRleE9mKCdkYXRhLScpICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVtb3ZlUmVzdWx0LmtlZXAoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3JtYXQucmVtb3ZlICE9PSAnbm9uZScpIHtcbiAgICAgICAgcmVtb3ZlTm9kZShlZCwgZWxtLCBmb3JtYXQpO1xuICAgICAgICByZXR1cm4gcmVtb3ZlUmVzdWx0LnJlbW92ZWQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZW1vdmVSZXN1bHQua2VlcCgpO1xuICAgIH07XG4gICAgY29uc3QgcmVtb3ZlRm9ybWF0JDEgPSAoZWQsIGZvcm1hdCwgdmFycywgbm9kZSwgY29tcGFyZU5vZGUpID0+IHJlbW92ZUZvcm1hdEludGVybmFsKGVkLCBmb3JtYXQsIHZhcnMsIG5vZGUsIGNvbXBhcmVOb2RlKS5mb2xkKG5ldmVyLCBuZXdOYW1lID0+IHtcbiAgICAgIGVkLmRvbS5yZW5hbWUobm9kZSwgbmV3TmFtZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LCBhbHdheXMpO1xuICAgIGNvbnN0IGZpbmRGb3JtYXRSb290ID0gKGVkaXRvciwgY29udGFpbmVyLCBuYW1lLCB2YXJzLCBzaW1pbGFyKSA9PiB7XG4gICAgICBsZXQgZm9ybWF0Um9vdDtcbiAgICAgIGVhY2gkZyhnZXRQYXJlbnRzJDIoZWRpdG9yLmRvbSwgY29udGFpbmVyLnBhcmVudE5vZGUpLnJldmVyc2UoKSwgcGFyZW50ID0+IHtcbiAgICAgICAgaWYgKCFmb3JtYXRSb290ICYmIHBhcmVudC5pZCAhPT0gJ19zdGFydCcgJiYgcGFyZW50LmlkICE9PSAnX2VuZCcpIHtcbiAgICAgICAgICBjb25zdCBmb3JtYXQgPSBtYXRjaE5vZGUoZWRpdG9yLCBwYXJlbnQsIG5hbWUsIHZhcnMsIHNpbWlsYXIpO1xuICAgICAgICAgIGlmIChmb3JtYXQgJiYgZm9ybWF0LnNwbGl0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgZm9ybWF0Um9vdCA9IHBhcmVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZvcm1hdFJvb3Q7XG4gICAgfTtcbiAgICBjb25zdCByZW1vdmVGb3JtYXRGcm9tQ2xvbmUgPSAoZWRpdG9yLCBmb3JtYXQsIHZhcnMsIGNsb25lKSA9PiByZW1vdmVGb3JtYXRJbnRlcm5hbChlZGl0b3IsIGZvcm1hdCwgdmFycywgY2xvbmUsIGNsb25lKS5mb2xkKGNvbnN0YW50KGNsb25lKSwgbmV3TmFtZSA9PiB7XG4gICAgICBjb25zdCBmcmFnbWVudCA9IGVkaXRvci5kb20uY3JlYXRlRnJhZ21lbnQoKTtcbiAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKGNsb25lKTtcbiAgICAgIHJldHVybiBlZGl0b3IuZG9tLnJlbmFtZShjbG9uZSwgbmV3TmFtZSk7XG4gICAgfSwgY29uc3RhbnQobnVsbCkpO1xuICAgIGNvbnN0IHdyYXBBbmRTcGxpdCA9IChlZGl0b3IsIGZvcm1hdExpc3QsIGZvcm1hdFJvb3QsIGNvbnRhaW5lciwgdGFyZ2V0LCBzcGxpdCwgZm9ybWF0LCB2YXJzKSA9PiB7XG4gICAgICBsZXQgY2xvbmUsIGxhc3RDbG9uZSwgZmlyc3RDbG9uZTtcbiAgICAgIGNvbnN0IGRvbSA9IGVkaXRvci5kb207XG4gICAgICBpZiAoZm9ybWF0Um9vdCkge1xuICAgICAgICBjb25zdCBmb3JtYXRSb290UGFyZW50ID0gZm9ybWF0Um9vdC5wYXJlbnROb2RlO1xuICAgICAgICBmb3IgKGxldCBwYXJlbnQgPSBjb250YWluZXIucGFyZW50Tm9kZTsgcGFyZW50ICYmIHBhcmVudCAhPT0gZm9ybWF0Um9vdFBhcmVudDsgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICBjbG9uZSA9IGRvbS5jbG9uZShwYXJlbnQsIGZhbHNlKTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZvcm1hdExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNsb25lID0gcmVtb3ZlRm9ybWF0RnJvbUNsb25lKGVkaXRvciwgZm9ybWF0TGlzdFtpXSwgdmFycywgY2xvbmUpO1xuICAgICAgICAgICAgaWYgKGNsb25lID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2xvbmUpIHtcbiAgICAgICAgICAgIGlmIChsYXN0Q2xvbmUpIHtcbiAgICAgICAgICAgICAgY2xvbmUuYXBwZW5kQ2hpbGQobGFzdENsb25lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZmlyc3RDbG9uZSkge1xuICAgICAgICAgICAgICBmaXJzdENsb25lID0gY2xvbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0Q2xvbmUgPSBjbG9uZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNwbGl0ICYmICghZm9ybWF0Lm1peGVkIHx8ICFkb20uaXNCbG9jayhmb3JtYXRSb290KSkpIHtcbiAgICAgICAgICBjb250YWluZXIgPSBkb20uc3BsaXQoZm9ybWF0Um9vdCwgY29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdENsb25lKSB7XG4gICAgICAgICAgdGFyZ2V0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGxhc3RDbG9uZSwgdGFyZ2V0KTtcbiAgICAgICAgICBmaXJzdENsb25lLmFwcGVuZENoaWxkKHRhcmdldCk7XG4gICAgICAgICAgaWYgKGlzSW5saW5lRm9ybWF0KGZvcm1hdCkpIHtcbiAgICAgICAgICAgIG1lcmdlU2libGluZ3MoZG9tLCBmb3JtYXQsIHZhcnMsIGxhc3RDbG9uZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgIH07XG4gICAgY29uc3QgcmVtb3ZlJDIgPSAoZWQsIG5hbWUsIHZhcnMsIG5vZGUsIHNpbWlsYXIpID0+IHtcbiAgICAgIGNvbnN0IGZvcm1hdExpc3QgPSBlZC5mb3JtYXR0ZXIuZ2V0KG5hbWUpO1xuICAgICAgY29uc3QgZm9ybWF0ID0gZm9ybWF0TGlzdFswXTtcbiAgICAgIGxldCBjb250ZW50RWRpdGFibGUgPSB0cnVlO1xuICAgICAgY29uc3QgZG9tID0gZWQuZG9tO1xuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gZWQuc2VsZWN0aW9uO1xuICAgICAgY29uc3Qgc3BsaXRUb0Zvcm1hdFJvb3QgPSBjb250YWluZXIgPT4ge1xuICAgICAgICBjb25zdCBmb3JtYXRSb290ID0gZmluZEZvcm1hdFJvb3QoZWQsIGNvbnRhaW5lciwgbmFtZSwgdmFycywgc2ltaWxhcik7XG4gICAgICAgIHJldHVybiB3cmFwQW5kU3BsaXQoZWQsIGZvcm1hdExpc3QsIGZvcm1hdFJvb3QsIGNvbnRhaW5lciwgY29udGFpbmVyLCB0cnVlLCBmb3JtYXQsIHZhcnMpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGlzUmVtb3ZlQm9va21hcmtOb2RlID0gbm9kZSA9PiBpc0Jvb2ttYXJrTm9kZSQxKG5vZGUpICYmIGlzRWxlbWVudCQ2KG5vZGUpICYmIChub2RlLmlkID09PSAnX3N0YXJ0JyB8fCBub2RlLmlkID09PSAnX2VuZCcpO1xuICAgICAgY29uc3QgcmVtb3ZlTm9kZUZvcm1hdCA9IG5vZGUgPT4gZXhpc3RzKGZvcm1hdExpc3QsIGZtdCA9PiByZW1vdmVGb3JtYXQkMShlZCwgZm10LCB2YXJzLCBub2RlLCBub2RlKSk7XG4gICAgICBjb25zdCBwcm9jZXNzID0gbm9kZSA9PiB7XG4gICAgICAgIGxldCBsYXN0Q29udGVudEVkaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgbGV0IGhhc0NvbnRlbnRFZGl0YWJsZVN0YXRlID0gZmFsc2U7XG4gICAgICAgIGlmIChpc0VsZW1lbnQkNihub2RlKSAmJiBkb20uZ2V0Q29udGVudEVkaXRhYmxlKG5vZGUpKSB7XG4gICAgICAgICAgbGFzdENvbnRlbnRFZGl0YWJsZSA9IGNvbnRlbnRFZGl0YWJsZTtcbiAgICAgICAgICBjb250ZW50RWRpdGFibGUgPSBkb20uZ2V0Q29udGVudEVkaXRhYmxlKG5vZGUpID09PSAndHJ1ZSc7XG4gICAgICAgICAgaGFzQ29udGVudEVkaXRhYmxlU3RhdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gZnJvbShub2RlLmNoaWxkTm9kZXMpO1xuICAgICAgICBpZiAoY29udGVudEVkaXRhYmxlICYmICFoYXNDb250ZW50RWRpdGFibGVTdGF0ZSkge1xuICAgICAgICAgIGNvbnN0IHJlbW92ZWQgPSByZW1vdmVOb2RlRm9ybWF0KG5vZGUpO1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnROb2RlTWF0Y2hlcyA9IHJlbW92ZWQgfHwgZXhpc3RzKGZvcm1hdExpc3QsIGYgPT4gbWF0Y2hOYW1lKGRvbSwgbm9kZSwgZikpO1xuICAgICAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgaWYgKCFjdXJyZW50Tm9kZU1hdGNoZXMgJiYgaXNOb25OdWxsYWJsZShwYXJlbnROb2RlKSAmJiBzaG91bGRFeHBhbmRUb1NlbGVjdG9yKGZvcm1hdCkpIHtcbiAgICAgICAgICAgIHJlbW92ZU5vZGVGb3JtYXQocGFyZW50Tm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQuZGVlcCkge1xuICAgICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgcHJvY2VzcyhjaGlsZHJlbltpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzQ29udGVudEVkaXRhYmxlU3RhdGUpIHtcbiAgICAgICAgICAgICAgY29udGVudEVkaXRhYmxlID0gbGFzdENvbnRlbnRFZGl0YWJsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGV4dERlY29yYXRpb25zID0gW1xuICAgICAgICAgICd1bmRlcmxpbmUnLFxuICAgICAgICAgICdsaW5lLXRocm91Z2gnLFxuICAgICAgICAgICdvdmVybGluZSdcbiAgICAgICAgXTtcbiAgICAgICAgZWFjaCRnKHRleHREZWNvcmF0aW9ucywgZGVjb3JhdGlvbiA9PiB7XG4gICAgICAgICAgaWYgKGlzRWxlbWVudCQ2KG5vZGUpICYmIGVkLmRvbS5nZXRTdHlsZShub2RlLCAndGV4dC1kZWNvcmF0aW9uJykgPT09IGRlY29yYXRpb24gJiYgbm9kZS5wYXJlbnROb2RlICYmIGdldFRleHREZWNvcmF0aW9uKGRvbSwgbm9kZS5wYXJlbnROb2RlKSA9PT0gZGVjb3JhdGlvbikge1xuICAgICAgICAgICAgcmVtb3ZlRm9ybWF0JDEoZWQsIHtcbiAgICAgICAgICAgICAgZGVlcDogZmFsc2UsXG4gICAgICAgICAgICAgIGV4YWN0OiB0cnVlLFxuICAgICAgICAgICAgICBpbmxpbmU6ICdzcGFuJyxcbiAgICAgICAgICAgICAgc3R5bGVzOiB7IHRleHREZWNvcmF0aW9uOiBkZWNvcmF0aW9uIH1cbiAgICAgICAgICAgIH0sIG51bGwsIG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgdW53cmFwID0gc3RhcnQgPT4ge1xuICAgICAgICBjb25zdCBub2RlID0gZG9tLmdldChzdGFydCA/ICdfc3RhcnQnIDogJ19lbmQnKTtcbiAgICAgICAgbGV0IG91dCA9IG5vZGVbc3RhcnQgPyAnZmlyc3RDaGlsZCcgOiAnbGFzdENoaWxkJ107XG4gICAgICAgIGlmIChpc1JlbW92ZUJvb2ttYXJrTm9kZShvdXQpKSB7XG4gICAgICAgICAgb3V0ID0gb3V0W3N0YXJ0ID8gJ2ZpcnN0Q2hpbGQnIDogJ2xhc3RDaGlsZCddO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1RleHQkOChvdXQpICYmIG91dC5kYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIG91dCA9IHN0YXJ0ID8gbm9kZS5wcmV2aW91c1NpYmxpbmcgfHwgbm9kZS5uZXh0U2libGluZyA6IG5vZGUubmV4dFNpYmxpbmcgfHwgbm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgICAgZG9tLnJlbW92ZShub2RlLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgIH07XG4gICAgICBjb25zdCByZW1vdmVSbmdTdHlsZSA9IHJuZyA9PiB7XG4gICAgICAgIGxldCBzdGFydENvbnRhaW5lciwgZW5kQ29udGFpbmVyO1xuICAgICAgICBsZXQgZXhwYW5kZWRSbmcgPSBleHBhbmRSbmcoZWQsIHJuZywgZm9ybWF0TGlzdCwgcm5nLmNvbGxhcHNlZCk7XG4gICAgICAgIGlmIChmb3JtYXQuc3BsaXQpIHtcbiAgICAgICAgICBleHBhbmRlZFJuZyA9IHNwbGl0KGV4cGFuZGVkUm5nKTtcbiAgICAgICAgICBzdGFydENvbnRhaW5lciA9IGdldENvbnRhaW5lcihlZCwgZXhwYW5kZWRSbmcsIHRydWUpO1xuICAgICAgICAgIGVuZENvbnRhaW5lciA9IGdldENvbnRhaW5lcihlZCwgZXhwYW5kZWRSbmcpO1xuICAgICAgICAgIGlmIChzdGFydENvbnRhaW5lciAhPT0gZW5kQ29udGFpbmVyKSB7XG4gICAgICAgICAgICBzdGFydENvbnRhaW5lciA9IG5vcm1hbGl6ZVRhYmxlU2VsZWN0aW9uKHN0YXJ0Q29udGFpbmVyLCB0cnVlKTtcbiAgICAgICAgICAgIGVuZENvbnRhaW5lciA9IG5vcm1hbGl6ZVRhYmxlU2VsZWN0aW9uKGVuZENvbnRhaW5lciwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKGlzQ2hpbGRPZklubGluZVBhcmVudChkb20sIHN0YXJ0Q29udGFpbmVyLCBlbmRDb250YWluZXIpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG1hcmtlciA9IE9wdGlvbmFsLmZyb20oc3RhcnRDb250YWluZXIuZmlyc3RDaGlsZCkuZ2V0T3Ioc3RhcnRDb250YWluZXIpO1xuICAgICAgICAgICAgICBzcGxpdFRvRm9ybWF0Um9vdCh3cmFwV2l0aFNpYmxpbmdzKGRvbSwgbWFya2VyLCB0cnVlLCAnc3BhbicsIHtcbiAgICAgICAgICAgICAgICAnaWQnOiAnX3N0YXJ0JyxcbiAgICAgICAgICAgICAgICAnZGF0YS1tY2UtdHlwZSc6ICdib29rbWFyaydcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICB1bndyYXAodHJ1ZSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0NoaWxkT2ZJbmxpbmVQYXJlbnQoZG9tLCBlbmRDb250YWluZXIsIHN0YXJ0Q29udGFpbmVyKSkge1xuICAgICAgICAgICAgICBjb25zdCBtYXJrZXIgPSBPcHRpb25hbC5mcm9tKGVuZENvbnRhaW5lci5sYXN0Q2hpbGQpLmdldE9yKGVuZENvbnRhaW5lcik7XG4gICAgICAgICAgICAgIHNwbGl0VG9Gb3JtYXRSb290KHdyYXBXaXRoU2libGluZ3MoZG9tLCBtYXJrZXIsIGZhbHNlLCAnc3BhbicsIHtcbiAgICAgICAgICAgICAgICAnaWQnOiAnX2VuZCcsXG4gICAgICAgICAgICAgICAgJ2RhdGEtbWNlLXR5cGUnOiAnYm9va21hcmsnXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgdW53cmFwKGZhbHNlKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhcnRDb250YWluZXIgPSB3cmFwJDEoZG9tLCBzdGFydENvbnRhaW5lciwgJ3NwYW4nLCB7XG4gICAgICAgICAgICAgICdpZCc6ICdfc3RhcnQnLFxuICAgICAgICAgICAgICAnZGF0YS1tY2UtdHlwZSc6ICdib29rbWFyaydcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZW5kQ29udGFpbmVyID0gd3JhcCQxKGRvbSwgZW5kQ29udGFpbmVyLCAnc3BhbicsIHtcbiAgICAgICAgICAgICAgJ2lkJzogJ19lbmQnLFxuICAgICAgICAgICAgICAnZGF0YS1tY2UtdHlwZSc6ICdib29rbWFyaydcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgbmV3Um5nID0gZG9tLmNyZWF0ZVJuZygpO1xuICAgICAgICAgICAgbmV3Um5nLnNldFN0YXJ0QWZ0ZXIoc3RhcnRDb250YWluZXIpO1xuICAgICAgICAgICAgbmV3Um5nLnNldEVuZEJlZm9yZShlbmRDb250YWluZXIpO1xuICAgICAgICAgICAgd2FsayQzKGRvbSwgbmV3Um5nLCBub2RlcyA9PiB7XG4gICAgICAgICAgICAgIGVhY2gkZyhub2RlcywgbiA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0Jvb2ttYXJrTm9kZSQxKG4pICYmICFpc0Jvb2ttYXJrTm9kZSQxKG4ucGFyZW50Tm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgIHNwbGl0VG9Gb3JtYXRSb290KG4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNwbGl0VG9Gb3JtYXRSb290KHN0YXJ0Q29udGFpbmVyKTtcbiAgICAgICAgICAgIHNwbGl0VG9Gb3JtYXRSb290KGVuZENvbnRhaW5lcik7XG4gICAgICAgICAgICBzdGFydENvbnRhaW5lciA9IHVud3JhcCh0cnVlKTtcbiAgICAgICAgICAgIGVuZENvbnRhaW5lciA9IHVud3JhcCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGFydENvbnRhaW5lciA9IGVuZENvbnRhaW5lciA9IHNwbGl0VG9Gb3JtYXRSb290KHN0YXJ0Q29udGFpbmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwYW5kZWRSbmcuc3RhcnRDb250YWluZXIgPSBzdGFydENvbnRhaW5lci5wYXJlbnROb2RlID8gc3RhcnRDb250YWluZXIucGFyZW50Tm9kZSA6IHN0YXJ0Q29udGFpbmVyO1xuICAgICAgICAgIGV4cGFuZGVkUm5nLnN0YXJ0T2Zmc2V0ID0gZG9tLm5vZGVJbmRleChzdGFydENvbnRhaW5lcik7XG4gICAgICAgICAgZXhwYW5kZWRSbmcuZW5kQ29udGFpbmVyID0gZW5kQ29udGFpbmVyLnBhcmVudE5vZGUgPyBlbmRDb250YWluZXIucGFyZW50Tm9kZSA6IGVuZENvbnRhaW5lcjtcbiAgICAgICAgICBleHBhbmRlZFJuZy5lbmRPZmZzZXQgPSBkb20ubm9kZUluZGV4KGVuZENvbnRhaW5lcikgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHdhbGskMyhkb20sIGV4cGFuZGVkUm5nLCBub2RlcyA9PiB7XG4gICAgICAgICAgZWFjaCRnKG5vZGVzLCBwcm9jZXNzKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgaWYgKGlzTm9kZShub2RlKSkge1xuICAgICAgICAgIGNvbnN0IHJuZyA9IGRvbS5jcmVhdGVSbmcoKTtcbiAgICAgICAgICBybmcuc2V0U3RhcnRCZWZvcmUobm9kZSk7XG4gICAgICAgICAgcm5nLnNldEVuZEFmdGVyKG5vZGUpO1xuICAgICAgICAgIHJlbW92ZVJuZ1N0eWxlKHJuZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtb3ZlUm5nU3R5bGUobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZmlyZUZvcm1hdFJlbW92ZShlZCwgbmFtZSwgbm9kZSwgdmFycyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChkb20uZ2V0Q29udGVudEVkaXRhYmxlKHNlbGVjdGlvbi5nZXROb2RlKCkpID09PSAnZmFsc2UnKSB7XG4gICAgICAgIG5vZGUgPSBzZWxlY3Rpb24uZ2V0Tm9kZSgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZvcm1hdExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoZm9ybWF0TGlzdFtpXS5jZUZhbHNlT3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIGlmIChyZW1vdmVGb3JtYXQkMShlZCwgZm9ybWF0TGlzdFtpXSwgdmFycywgbm9kZSwgbm9kZSkpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZpcmVGb3JtYXRSZW1vdmUoZWQsIG5hbWUsIG5vZGUsIHZhcnMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpIHx8ICFpc0lubGluZUZvcm1hdChmb3JtYXQpIHx8IGdldENlbGxzRnJvbUVkaXRvcihlZCkubGVuZ3RoKSB7XG4gICAgICAgIHByZXNlcnZlKHNlbGVjdGlvbiwgdHJ1ZSwgKCkgPT4ge1xuICAgICAgICAgIHJ1bk9uUmFuZ2VzKGVkLCByZW1vdmVSbmdTdHlsZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaXNJbmxpbmVGb3JtYXQoZm9ybWF0KSAmJiBtYXRjaCQyKGVkLCBuYW1lLCB2YXJzLCBzZWxlY3Rpb24uZ2V0U3RhcnQoKSkpIHtcbiAgICAgICAgICBtb3ZlU3RhcnQoZG9tLCBzZWxlY3Rpb24sIHNlbGVjdGlvbi5nZXRSbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWQubm9kZUNoYW5nZWQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbW92ZUNhcmV0Rm9ybWF0KGVkLCBuYW1lLCB2YXJzLCBzaW1pbGFyKTtcbiAgICAgIH1cbiAgICAgIGZpcmVGb3JtYXRSZW1vdmUoZWQsIG5hbWUsIG5vZGUsIHZhcnMpO1xuICAgIH07XG5cbiAgICBjb25zdCBlYWNoJDcgPSBUb29scy5lYWNoO1xuICAgIGNvbnN0IG1lcmdlVGV4dERlY29yYXRpb25zQW5kQ29sb3IgPSAoZG9tLCBmb3JtYXQsIHZhcnMsIG5vZGUpID0+IHtcbiAgICAgIGNvbnN0IHByb2Nlc3NUZXh0RGVjb3JhdGlvbnNBbmRDb2xvciA9IG4gPT4ge1xuICAgICAgICBpZiAobi5ub2RlVHlwZSA9PT0gMSAmJiBuLnBhcmVudE5vZGUgJiYgbi5wYXJlbnROb2RlLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgY29uc3QgdGV4dERlY29yYXRpb24gPSBnZXRUZXh0RGVjb3JhdGlvbihkb20sIG4ucGFyZW50Tm9kZSk7XG4gICAgICAgICAgaWYgKGRvbS5nZXRTdHlsZShuLCAnY29sb3InKSAmJiB0ZXh0RGVjb3JhdGlvbikge1xuICAgICAgICAgICAgZG9tLnNldFN0eWxlKG4sICd0ZXh0LWRlY29yYXRpb24nLCB0ZXh0RGVjb3JhdGlvbik7XG4gICAgICAgICAgfSBlbHNlIGlmIChkb20uZ2V0U3R5bGUobiwgJ3RleHQtZGVjb3JhdGlvbicpID09PSB0ZXh0RGVjb3JhdGlvbikge1xuICAgICAgICAgICAgZG9tLnNldFN0eWxlKG4sICd0ZXh0LWRlY29yYXRpb24nLCBudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAoZm9ybWF0LnN0eWxlcyAmJiAoZm9ybWF0LnN0eWxlcy5jb2xvciB8fCBmb3JtYXQuc3R5bGVzLnRleHREZWNvcmF0aW9uKSkge1xuICAgICAgICBUb29scy53YWxrKG5vZGUsIHByb2Nlc3NUZXh0RGVjb3JhdGlvbnNBbmRDb2xvciwgJ2NoaWxkTm9kZXMnKTtcbiAgICAgICAgcHJvY2Vzc1RleHREZWNvcmF0aW9uc0FuZENvbG9yKG5vZGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgbWVyZ2VCYWNrZ3JvdW5kQ29sb3JBbmRGb250U2l6ZSA9IChkb20sIGZvcm1hdCwgdmFycywgbm9kZSkgPT4ge1xuICAgICAgaWYgKGZvcm1hdC5zdHlsZXMgJiYgZm9ybWF0LnN0eWxlcy5iYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgcHJvY2Vzc0NoaWxkRWxlbWVudHMobm9kZSwgaGFzU3R5bGUoZG9tLCAnZm9udFNpemUnKSwgYXBwbHlTdHlsZShkb20sICdiYWNrZ3JvdW5kQ29sb3InLCByZXBsYWNlVmFycyhmb3JtYXQuc3R5bGVzLmJhY2tncm91bmRDb2xvciwgdmFycykpKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG1lcmdlU3ViU3VwID0gKGRvbSwgZm9ybWF0LCB2YXJzLCBub2RlKSA9PiB7XG4gICAgICBpZiAoaXNJbmxpbmVGb3JtYXQoZm9ybWF0KSAmJiAoZm9ybWF0LmlubGluZSA9PT0gJ3N1YicgfHwgZm9ybWF0LmlubGluZSA9PT0gJ3N1cCcpKSB7XG4gICAgICAgIHByb2Nlc3NDaGlsZEVsZW1lbnRzKG5vZGUsIGhhc1N0eWxlKGRvbSwgJ2ZvbnRTaXplJyksIGFwcGx5U3R5bGUoZG9tLCAnZm9udFNpemUnLCAnJykpO1xuICAgICAgICBkb20ucmVtb3ZlKGRvbS5zZWxlY3QoZm9ybWF0LmlubGluZSA9PT0gJ3N1cCcgPyAnc3ViJyA6ICdzdXAnLCBub2RlKSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBtZXJnZVdpdGhDaGlsZHJlbiA9IChlZGl0b3IsIGZvcm1hdExpc3QsIHZhcnMsIG5vZGUpID0+IHtcbiAgICAgIGVhY2gkNyhmb3JtYXRMaXN0LCBmb3JtYXQgPT4ge1xuICAgICAgICBpZiAoaXNJbmxpbmVGb3JtYXQoZm9ybWF0KSkge1xuICAgICAgICAgIGVhY2gkNyhlZGl0b3IuZG9tLnNlbGVjdChmb3JtYXQuaW5saW5lLCBub2RlKSwgY2hpbGQgPT4ge1xuICAgICAgICAgICAgaWYgKCFpc0VsZW1lbnROb2RlJDEoY2hpbGQpKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlbW92ZUZvcm1hdCQxKGVkaXRvciwgZm9ybWF0LCB2YXJzLCBjaGlsZCwgZm9ybWF0LmV4YWN0ID8gY2hpbGQgOiBudWxsKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjbGVhckNoaWxkU3R5bGVzKGVkaXRvci5kb20sIGZvcm1hdCwgbm9kZSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IG1lcmdlV2l0aFBhcmVudHMgPSAoZWRpdG9yLCBmb3JtYXQsIG5hbWUsIHZhcnMsIG5vZGUpID0+IHtcbiAgICAgIGlmIChtYXRjaE5vZGUoZWRpdG9yLCBub2RlLnBhcmVudE5vZGUsIG5hbWUsIHZhcnMpKSB7XG4gICAgICAgIGlmIChyZW1vdmVGb3JtYXQkMShlZGl0b3IsIGZvcm1hdCwgdmFycywgbm9kZSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3JtYXQubWVyZ2Vfd2l0aF9wYXJlbnRzKSB7XG4gICAgICAgIGVkaXRvci5kb20uZ2V0UGFyZW50KG5vZGUucGFyZW50Tm9kZSwgcGFyZW50ID0+IHtcbiAgICAgICAgICBpZiAobWF0Y2hOb2RlKGVkaXRvciwgcGFyZW50LCBuYW1lLCB2YXJzKSkge1xuICAgICAgICAgICAgcmVtb3ZlRm9ybWF0JDEoZWRpdG9yLCBmb3JtYXQsIHZhcnMsIG5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgZWFjaCQ2ID0gVG9vbHMuZWFjaDtcbiAgICBjb25zdCBpc0VsZW1lbnROb2RlID0gbm9kZSA9PiB7XG4gICAgICByZXR1cm4gaXNFbGVtZW50JDYobm9kZSkgJiYgIWlzQm9va21hcmtOb2RlJDEobm9kZSkgJiYgIWlzQ2FyZXROb2RlKG5vZGUpICYmICFpc0JvZ3VzJDIobm9kZSk7XG4gICAgfTtcbiAgICBjb25zdCBjYW5Gb3JtYXRCUiA9IChlZGl0b3IsIGZvcm1hdCwgbm9kZSwgcGFyZW50TmFtZSkgPT4ge1xuICAgICAgaWYgKGNhbkZvcm1hdEVtcHR5TGluZXMoZWRpdG9yKSAmJiBpc0lubGluZUZvcm1hdChmb3JtYXQpKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkQlJQYXJlbnRFbGVtZW50cyA9IGdldFRleHRSb290QmxvY2tFbGVtZW50cyhlZGl0b3Iuc2NoZW1hKTtcbiAgICAgICAgY29uc3QgaGFzQ2FyZXROb2RlU2libGluZyA9IHNpYmxpbmcoU3VnYXJFbGVtZW50LmZyb21Eb20obm9kZSksIHNpYmxpbmcgPT4gaXNDYXJldE5vZGUoc2libGluZy5kb20pKTtcbiAgICAgICAgcmV0dXJuIGhhc05vbk51bGxhYmxlS2V5KHZhbGlkQlJQYXJlbnRFbGVtZW50cywgcGFyZW50TmFtZSkgJiYgaXNFbXB0eSQyKFN1Z2FyRWxlbWVudC5mcm9tRG9tKG5vZGUucGFyZW50Tm9kZSksIGZhbHNlKSAmJiAhaGFzQ2FyZXROb2RlU2libGluZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGFwcGx5Rm9ybWF0JDEgPSAoZWQsIG5hbWUsIHZhcnMsIG5vZGUpID0+IHtcbiAgICAgIGNvbnN0IGZvcm1hdExpc3QgPSBlZC5mb3JtYXR0ZXIuZ2V0KG5hbWUpO1xuICAgICAgY29uc3QgZm9ybWF0ID0gZm9ybWF0TGlzdFswXTtcbiAgICAgIGNvbnN0IGlzQ29sbGFwc2VkID0gIW5vZGUgJiYgZWQuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCk7XG4gICAgICBjb25zdCBkb20gPSBlZC5kb207XG4gICAgICBjb25zdCBzZWxlY3Rpb24gPSBlZC5zZWxlY3Rpb247XG4gICAgICBjb25zdCBzZXRFbGVtZW50Rm9ybWF0ID0gKGVsbSwgZm10ID0gZm9ybWF0KSA9PiB7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGZtdC5vbmZvcm1hdCkpIHtcbiAgICAgICAgICBmbXQub25mb3JtYXQoZWxtLCBmbXQsIHZhcnMsIG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVhY2gkNihmbXQuc3R5bGVzLCAodmFsdWUsIG5hbWUpID0+IHtcbiAgICAgICAgICBkb20uc2V0U3R5bGUoZWxtLCBuYW1lLCByZXBsYWNlVmFycyh2YWx1ZSwgdmFycykpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGZtdC5zdHlsZXMpIHtcbiAgICAgICAgICBjb25zdCBzdHlsZVZhbCA9IGRvbS5nZXRBdHRyaWIoZWxtLCAnc3R5bGUnKTtcbiAgICAgICAgICBpZiAoc3R5bGVWYWwpIHtcbiAgICAgICAgICAgIGRvbS5zZXRBdHRyaWIoZWxtLCAnZGF0YS1tY2Utc3R5bGUnLCBzdHlsZVZhbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVhY2gkNihmbXQuYXR0cmlidXRlcywgKHZhbHVlLCBuYW1lKSA9PiB7XG4gICAgICAgICAgZG9tLnNldEF0dHJpYihlbG0sIG5hbWUsIHJlcGxhY2VWYXJzKHZhbHVlLCB2YXJzKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBlYWNoJDYoZm10LmNsYXNzZXMsIHZhbHVlID0+IHtcbiAgICAgICAgICB2YWx1ZSA9IHJlcGxhY2VWYXJzKHZhbHVlLCB2YXJzKTtcbiAgICAgICAgICBpZiAoIWRvbS5oYXNDbGFzcyhlbG0sIHZhbHVlKSkge1xuICAgICAgICAgICAgZG9tLmFkZENsYXNzKGVsbSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgYXBwbHlOb2RlU3R5bGUgPSAoZm9ybWF0TGlzdCwgbm9kZSkgPT4ge1xuICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgZWFjaCQ2KGZvcm1hdExpc3QsIGZvcm1hdCA9PiB7XG4gICAgICAgICAgaWYgKCFpc1NlbGVjdG9yRm9ybWF0KGZvcm1hdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzTm9uTnVsbGFibGUoZm9ybWF0LmNvbGxhcHNlZCkgJiYgZm9ybWF0LmNvbGxhcHNlZCAhPT0gaXNDb2xsYXBzZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRvbS5pcyhub2RlLCBmb3JtYXQuc2VsZWN0b3IpICYmICFpc0NhcmV0Tm9kZShub2RlKSkge1xuICAgICAgICAgICAgc2V0RWxlbWVudEZvcm1hdChub2RlLCBmb3JtYXQpO1xuICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgIH07XG4gICAgICBjb25zdCBjcmVhdGVXcmFwRWxlbWVudCA9IHdyYXBOYW1lID0+IHtcbiAgICAgICAgaWYgKGlzU3RyaW5nKHdyYXBOYW1lKSkge1xuICAgICAgICAgIGNvbnN0IHdyYXBFbG0gPSBkb20uY3JlYXRlKHdyYXBOYW1lKTtcbiAgICAgICAgICBzZXRFbGVtZW50Rm9ybWF0KHdyYXBFbG0pO1xuICAgICAgICAgIHJldHVybiB3cmFwRWxtO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgYXBwbHlSbmdTdHlsZSA9IChkb20sIHJuZywgbm9kZVNwZWNpZmljKSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld1dyYXBwZXJzID0gW107XG4gICAgICAgIGxldCBjb250ZW50RWRpdGFibGUgPSB0cnVlO1xuICAgICAgICBjb25zdCB3cmFwTmFtZSA9IGZvcm1hdC5pbmxpbmUgfHwgZm9ybWF0LmJsb2NrO1xuICAgICAgICBjb25zdCB3cmFwRWxtID0gY3JlYXRlV3JhcEVsZW1lbnQod3JhcE5hbWUpO1xuICAgICAgICB3YWxrJDMoZG9tLCBybmcsIG5vZGVzID0+IHtcbiAgICAgICAgICBsZXQgY3VycmVudFdyYXBFbG07XG4gICAgICAgICAgY29uc3QgcHJvY2VzcyA9IG5vZGUgPT4ge1xuICAgICAgICAgICAgbGV0IGhhc0NvbnRlbnRFZGl0YWJsZVN0YXRlID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgbGFzdENvbnRlbnRFZGl0YWJsZSA9IGNvbnRlbnRFZGl0YWJsZTtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVOYW1lID0gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudE5hbWUgPSBwYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAoaXNFbGVtZW50JDYobm9kZSkgJiYgZG9tLmdldENvbnRlbnRFZGl0YWJsZShub2RlKSkge1xuICAgICAgICAgICAgICBsYXN0Q29udGVudEVkaXRhYmxlID0gY29udGVudEVkaXRhYmxlO1xuICAgICAgICAgICAgICBjb250ZW50RWRpdGFibGUgPSBkb20uZ2V0Q29udGVudEVkaXRhYmxlKG5vZGUpID09PSAndHJ1ZSc7XG4gICAgICAgICAgICAgIGhhc0NvbnRlbnRFZGl0YWJsZVN0YXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0JyJDUobm9kZSkgJiYgIWNhbkZvcm1hdEJSKGVkLCBmb3JtYXQsIG5vZGUsIHBhcmVudE5hbWUpKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRXcmFwRWxtID0gbnVsbDtcbiAgICAgICAgICAgICAgaWYgKGlzQmxvY2tGb3JtYXQoZm9ybWF0KSkge1xuICAgICAgICAgICAgICAgIGRvbS5yZW1vdmUobm9kZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzQmxvY2tGb3JtYXQoZm9ybWF0KSAmJiBmb3JtYXQud3JhcHBlciAmJiBtYXRjaE5vZGUoZWQsIG5vZGUsIG5hbWUsIHZhcnMpKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRXcmFwRWxtID0gbnVsbDtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbnRlbnRFZGl0YWJsZSAmJiAhaGFzQ29udGVudEVkaXRhYmxlU3RhdGUgJiYgaXNCbG9ja0Zvcm1hdChmb3JtYXQpICYmICFmb3JtYXQud3JhcHBlciAmJiBpc1RleHRCbG9jayQxKGVkLCBub2RlTmFtZSkgJiYgaXNWYWxpZChlZCwgcGFyZW50TmFtZSwgd3JhcE5hbWUpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGVsbSA9IGRvbS5yZW5hbWUobm9kZSwgd3JhcE5hbWUpO1xuICAgICAgICAgICAgICBzZXRFbGVtZW50Rm9ybWF0KGVsbSk7XG4gICAgICAgICAgICAgIG5ld1dyYXBwZXJzLnB1c2goZWxtKTtcbiAgICAgICAgICAgICAgY3VycmVudFdyYXBFbG0gPSBudWxsO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTZWxlY3RvckZvcm1hdChmb3JtYXQpKSB7XG4gICAgICAgICAgICAgIGxldCBmb3VuZCA9IGFwcGx5Tm9kZVN0eWxlKGZvcm1hdExpc3QsIG5vZGUpO1xuICAgICAgICAgICAgICBpZiAoIWZvdW5kICYmIGlzTm9uTnVsbGFibGUocGFyZW50Tm9kZSkgJiYgc2hvdWxkRXhwYW5kVG9TZWxlY3Rvcihmb3JtYXQpKSB7XG4gICAgICAgICAgICAgICAgZm91bmQgPSBhcHBseU5vZGVTdHlsZShmb3JtYXRMaXN0LCBwYXJlbnROb2RlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWlzSW5saW5lRm9ybWF0KGZvcm1hdCkgfHwgZm91bmQpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50V3JhcEVsbSA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29udGVudEVkaXRhYmxlICYmICFoYXNDb250ZW50RWRpdGFibGVTdGF0ZSAmJiBpc1ZhbGlkKGVkLCB3cmFwTmFtZSwgbm9kZU5hbWUpICYmIGlzVmFsaWQoZWQsIHBhcmVudE5hbWUsIHdyYXBOYW1lKSAmJiAhKCFub2RlU3BlY2lmaWMgJiYgaXNUZXh0JDgobm9kZSkgJiYgaXNad3NwKG5vZGUuZGF0YSkpICYmICFpc0NhcmV0Tm9kZShub2RlKSAmJiAoIWlzSW5saW5lRm9ybWF0KGZvcm1hdCkgfHwgIWRvbS5pc0Jsb2NrKG5vZGUpKSkge1xuICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRXcmFwRWxtKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFdyYXBFbG0gPSBkb20uY2xvbmUod3JhcEVsbSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY3VycmVudFdyYXBFbG0sIG5vZGUpO1xuICAgICAgICAgICAgICAgIG5ld1dyYXBwZXJzLnB1c2goY3VycmVudFdyYXBFbG0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGN1cnJlbnRXcmFwRWxtLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY3VycmVudFdyYXBFbG0gPSBudWxsO1xuICAgICAgICAgICAgICBlYWNoJGcoZnJvbShub2RlLmNoaWxkTm9kZXMpLCBwcm9jZXNzKTtcbiAgICAgICAgICAgICAgaWYgKGhhc0NvbnRlbnRFZGl0YWJsZVN0YXRlKSB7XG4gICAgICAgICAgICAgICAgY29udGVudEVkaXRhYmxlID0gbGFzdENvbnRlbnRFZGl0YWJsZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjdXJyZW50V3JhcEVsbSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBlYWNoJGcobm9kZXMsIHByb2Nlc3MpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGZvcm1hdC5saW5rcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGVhY2gkZyhuZXdXcmFwcGVycywgbm9kZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwcm9jZXNzID0gbm9kZSA9PiB7XG4gICAgICAgICAgICAgIGlmIChub2RlLm5vZGVOYW1lID09PSAnQScpIHtcbiAgICAgICAgICAgICAgICBzZXRFbGVtZW50Rm9ybWF0KG5vZGUsIGZvcm1hdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWFjaCRnKGZyb20obm9kZS5jaGlsZE5vZGVzKSwgcHJvY2Vzcyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcHJvY2Vzcyhub2RlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlYWNoJGcobmV3V3JhcHBlcnMsIG5vZGUgPT4ge1xuICAgICAgICAgIGNvbnN0IGdldENoaWxkQ291bnQgPSBub2RlID0+IHtcbiAgICAgICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgICAgICBlYWNoJGcobm9kZS5jaGlsZE5vZGVzLCBub2RlID0+IHtcbiAgICAgICAgICAgICAgaWYgKCFpc0VtcHR5VGV4dE5vZGUkMShub2RlKSAmJiAhaXNCb29rbWFya05vZGUkMShub2RlKSkge1xuICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgICAgICAgIH07XG4gICAgICAgICAgY29uc3QgbWVyZ2VTdHlsZXMgPSBub2RlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkRWxlbWVudCA9IGZpbmQkMihub2RlLmNoaWxkTm9kZXMsIGlzRWxlbWVudE5vZGUpLmZpbHRlcihjaGlsZCA9PiBtYXRjaE5hbWUoZG9tLCBjaGlsZCwgZm9ybWF0KSk7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGRFbGVtZW50Lm1hcChjaGlsZCA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGNsb25lID0gZG9tLmNsb25lKGNoaWxkLCBmYWxzZSk7XG4gICAgICAgICAgICAgIHNldEVsZW1lbnRGb3JtYXQoY2xvbmUpO1xuICAgICAgICAgICAgICBkb20ucmVwbGFjZShjbG9uZSwgbm9kZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIGRvbS5yZW1vdmUoY2hpbGQsIHRydWUpO1xuICAgICAgICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgICAgICAgICB9KS5nZXRPcihub2RlKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnN0IGNoaWxkQ291bnQgPSBnZXRDaGlsZENvdW50KG5vZGUpO1xuICAgICAgICAgIGlmICgobmV3V3JhcHBlcnMubGVuZ3RoID4gMSB8fCAhZG9tLmlzQmxvY2sobm9kZSkpICYmIGNoaWxkQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgIGRvbS5yZW1vdmUobm9kZSwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0lubGluZUZvcm1hdChmb3JtYXQpIHx8IGlzQmxvY2tGb3JtYXQoZm9ybWF0KSAmJiBmb3JtYXQud3JhcHBlcikge1xuICAgICAgICAgICAgaWYgKCFmb3JtYXQuZXhhY3QgJiYgY2hpbGRDb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgICBub2RlID0gbWVyZ2VTdHlsZXMobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtZXJnZVdpdGhDaGlsZHJlbihlZCwgZm9ybWF0TGlzdCwgdmFycywgbm9kZSk7XG4gICAgICAgICAgICBtZXJnZVdpdGhQYXJlbnRzKGVkLCBmb3JtYXQsIG5hbWUsIHZhcnMsIG5vZGUpO1xuICAgICAgICAgICAgbWVyZ2VCYWNrZ3JvdW5kQ29sb3JBbmRGb250U2l6ZShkb20sIGZvcm1hdCwgdmFycywgbm9kZSk7XG4gICAgICAgICAgICBtZXJnZVRleHREZWNvcmF0aW9uc0FuZENvbG9yKGRvbSwgZm9ybWF0LCB2YXJzLCBub2RlKTtcbiAgICAgICAgICAgIG1lcmdlU3ViU3VwKGRvbSwgZm9ybWF0LCB2YXJzLCBub2RlKTtcbiAgICAgICAgICAgIG1lcmdlU2libGluZ3MoZG9tLCBmb3JtYXQsIHZhcnMsIG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgaWYgKGRvbS5nZXRDb250ZW50RWRpdGFibGUoc2VsZWN0aW9uLmdldE5vZGUoKSkgPT09ICdmYWxzZScpIHtcbiAgICAgICAgbm9kZSA9IHNlbGVjdGlvbi5nZXROb2RlKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gZm9ybWF0TGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBmb3JtYXRJdGVtID0gZm9ybWF0TGlzdFtpXTtcbiAgICAgICAgICBpZiAoZm9ybWF0SXRlbS5jZUZhbHNlT3ZlcnJpZGUgJiYgaXNTZWxlY3RvckZvcm1hdChmb3JtYXRJdGVtKSAmJiBkb20uaXMobm9kZSwgZm9ybWF0SXRlbS5zZWxlY3RvcikpIHtcbiAgICAgICAgICAgIHNldEVsZW1lbnRGb3JtYXQobm9kZSwgZm9ybWF0SXRlbSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmlyZUZvcm1hdEFwcGx5KGVkLCBuYW1lLCBub2RlLCB2YXJzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGZvcm1hdCkge1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgIGlmIChpc05vZGUobm9kZSkpIHtcbiAgICAgICAgICAgIGlmICghYXBwbHlOb2RlU3R5bGUoZm9ybWF0TGlzdCwgbm9kZSkpIHtcbiAgICAgICAgICAgICAgY29uc3Qgcm5nID0gZG9tLmNyZWF0ZVJuZygpO1xuICAgICAgICAgICAgICBybmcuc2V0U3RhcnRCZWZvcmUobm9kZSk7XG4gICAgICAgICAgICAgIHJuZy5zZXRFbmRBZnRlcihub2RlKTtcbiAgICAgICAgICAgICAgYXBwbHlSbmdTdHlsZShkb20sIGV4cGFuZFJuZyhlZCwgcm5nLCBmb3JtYXRMaXN0KSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFwcGx5Um5nU3R5bGUoZG9tLCBub2RlLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFpc0NvbGxhcHNlZCB8fCAhaXNJbmxpbmVGb3JtYXQoZm9ybWF0KSB8fCBnZXRDZWxsc0Zyb21FZGl0b3IoZWQpLmxlbmd0aCkge1xuICAgICAgICAgICAgc2VsZWN0aW9uLnNldFJuZyhub3JtYWxpemUoc2VsZWN0aW9uLmdldFJuZygpKSk7XG4gICAgICAgICAgICBwcmVzZXJ2ZShzZWxlY3Rpb24sIHRydWUsICgpID0+IHtcbiAgICAgICAgICAgICAgcnVuT25SYW5nZXMoZWQsIChzZWxlY3Rpb25SbmcsIGZha2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBleHBhbmRlZFJuZyA9IGZha2UgPyBzZWxlY3Rpb25SbmcgOiBleHBhbmRSbmcoZWQsIHNlbGVjdGlvblJuZywgZm9ybWF0TGlzdCk7XG4gICAgICAgICAgICAgICAgYXBwbHlSbmdTdHlsZShkb20sIGV4cGFuZGVkUm5nLCBmYWxzZSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBtb3ZlU3RhcnQoZG9tLCBzZWxlY3Rpb24sIHNlbGVjdGlvbi5nZXRSbmcoKSk7XG4gICAgICAgICAgICBlZC5ub2RlQ2hhbmdlZCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcHBseUNhcmV0Rm9ybWF0KGVkLCBuYW1lLCB2YXJzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcG9zdFByb2Nlc3MkMShuYW1lLCBlZCk7XG4gICAgICB9XG4gICAgICBmaXJlRm9ybWF0QXBwbHkoZWQsIG5hbWUsIG5vZGUsIHZhcnMpO1xuICAgIH07XG5cbiAgICBjb25zdCBoYXNWYXJzID0gdmFsdWUgPT4gaGFzJDIodmFsdWUsICd2YXJzJyk7XG4gICAgY29uc3Qgc2V0dXAkdCA9IChyZWdpc3RlcmVkRm9ybWF0TGlzdGVuZXJzLCBlZGl0b3IpID0+IHtcbiAgICAgIHJlZ2lzdGVyZWRGb3JtYXRMaXN0ZW5lcnMuc2V0KHt9KTtcbiAgICAgIGVkaXRvci5vbignTm9kZUNoYW5nZScsIGUgPT4ge1xuICAgICAgICB1cGRhdGVBbmRGaXJlQ2hhbmdlQ2FsbGJhY2tzKGVkaXRvciwgZS5lbGVtZW50LCByZWdpc3RlcmVkRm9ybWF0TGlzdGVuZXJzLmdldCgpKTtcbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLm9uKCdGb3JtYXRBcHBseSBGb3JtYXRSZW1vdmUnLCBlID0+IHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IE9wdGlvbmFsLmZyb20oZS5ub2RlKS5tYXAobm9kZU9yUmFuZ2UgPT4gaXNOb2RlKG5vZGVPclJhbmdlKSA/IG5vZGVPclJhbmdlIDogbm9kZU9yUmFuZ2Uuc3RhcnRDb250YWluZXIpLmJpbmQobm9kZSA9PiBpc0VsZW1lbnQkNihub2RlKSA/IE9wdGlvbmFsLnNvbWUobm9kZSkgOiBPcHRpb25hbC5mcm9tKG5vZGUucGFyZW50RWxlbWVudCkpLmdldE9yVGh1bmsoKCkgPT4gZmFsbGJhY2tFbGVtZW50KGVkaXRvcikpO1xuICAgICAgICB1cGRhdGVBbmRGaXJlQ2hhbmdlQ2FsbGJhY2tzKGVkaXRvciwgZWxlbWVudCwgcmVnaXN0ZXJlZEZvcm1hdExpc3RlbmVycy5nZXQoKSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGZhbGxiYWNrRWxlbWVudCA9IGVkaXRvciA9PiBlZGl0b3Iuc2VsZWN0aW9uLmdldFN0YXJ0KCk7XG4gICAgY29uc3QgbWF0Y2hpbmdOb2RlID0gKGVkaXRvciwgcGFyZW50cywgZm9ybWF0LCBzaW1pbGFyLCB2YXJzKSA9PiB7XG4gICAgICBjb25zdCBpc01hdGNoaW5nTm9kZSA9IG5vZGUgPT4ge1xuICAgICAgICBjb25zdCBtYXRjaGluZ0Zvcm1hdCA9IGVkaXRvci5mb3JtYXR0ZXIubWF0Y2hOb2RlKG5vZGUsIGZvcm1hdCwgdmFycyAhPT0gbnVsbCAmJiB2YXJzICE9PSB2b2lkIDAgPyB2YXJzIDoge30sIHNpbWlsYXIpO1xuICAgICAgICByZXR1cm4gIWlzVW5kZWZpbmVkKG1hdGNoaW5nRm9ybWF0KTtcbiAgICAgIH07XG4gICAgICBjb25zdCBpc1VuYWJsZVRvTWF0Y2ggPSBub2RlID0+IHtcbiAgICAgICAgaWYgKG1hdGNoZXNVbkluaGVyaXRlZEZvcm1hdFNlbGVjdG9yKGVkaXRvciwgbm9kZSwgZm9ybWF0KSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghc2ltaWxhcikge1xuICAgICAgICAgICAgcmV0dXJuIGlzTm9uTnVsbGFibGUoZWRpdG9yLmZvcm1hdHRlci5tYXRjaE5vZGUobm9kZSwgZm9ybWF0LCB2YXJzLCB0cnVlKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gZmluZFVudGlsJDEocGFyZW50cywgaXNNYXRjaGluZ05vZGUsIGlzVW5hYmxlVG9NYXRjaCk7XG4gICAgfTtcbiAgICBjb25zdCBnZXRQYXJlbnRzID0gKGVkaXRvciwgZWxtKSA9PiB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gZWxtICE9PSBudWxsICYmIGVsbSAhPT0gdm9pZCAwID8gZWxtIDogZmFsbGJhY2tFbGVtZW50KGVkaXRvcik7XG4gICAgICByZXR1cm4gZmlsdGVyJDYoZ2V0UGFyZW50cyQyKGVkaXRvci5kb20sIGVsZW1lbnQpLCBub2RlID0+IGlzRWxlbWVudCQ2KG5vZGUpICYmICFpc0JvZ3VzJDIobm9kZSkpO1xuICAgIH07XG4gICAgY29uc3QgdXBkYXRlQW5kRmlyZUNoYW5nZUNhbGxiYWNrcyA9IChlZGl0b3IsIGVsbSwgcmVnaXN0ZXJlZENhbGxiYWNrcykgPT4ge1xuICAgICAgY29uc3QgcGFyZW50cyA9IGdldFBhcmVudHMoZWRpdG9yLCBlbG0pO1xuICAgICAgZWFjaCRmKHJlZ2lzdGVyZWRDYWxsYmFja3MsIChkYXRhLCBmb3JtYXQpID0+IHtcbiAgICAgICAgY29uc3QgcnVuSWZDaGFuZ2VkID0gc3BlYyA9PiB7XG4gICAgICAgICAgY29uc3QgbWF0Y2ggPSBtYXRjaGluZ05vZGUoZWRpdG9yLCBwYXJlbnRzLCBmb3JtYXQsIHNwZWMuc2ltaWxhciwgaGFzVmFycyhzcGVjKSA/IHNwZWMudmFycyA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgY29uc3QgaXNTZXQgPSBtYXRjaC5pc1NvbWUoKTtcbiAgICAgICAgICBpZiAoc3BlYy5zdGF0ZS5nZXQoKSAhPT0gaXNTZXQpIHtcbiAgICAgICAgICAgIHNwZWMuc3RhdGUuc2V0KGlzU2V0KTtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBtYXRjaC5nZXRPcihlbG0pO1xuICAgICAgICAgICAgaWYgKGhhc1ZhcnMoc3BlYykpIHtcbiAgICAgICAgICAgICAgc3BlYy5jYWxsYmFjayhpc1NldCwge1xuICAgICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgICAgZm9ybWF0LFxuICAgICAgICAgICAgICAgIHBhcmVudHNcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlYWNoJGcoc3BlYy5jYWxsYmFja3MsIGNhbGxiYWNrID0+IGNhbGxiYWNrKGlzU2V0LCB7XG4gICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICBmb3JtYXQsXG4gICAgICAgICAgICAgICAgcGFyZW50c1xuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBlYWNoJGcoW1xuICAgICAgICAgIGRhdGEud2l0aFNpbWlsYXIsXG4gICAgICAgICAgZGF0YS53aXRob3V0U2ltaWxhclxuICAgICAgICBdLCBydW5JZkNoYW5nZWQpO1xuICAgICAgICBlYWNoJGcoZGF0YS53aXRoVmFycywgcnVuSWZDaGFuZ2VkKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgYWRkTGlzdGVuZXJzID0gKGVkaXRvciwgcmVnaXN0ZXJlZEZvcm1hdExpc3RlbmVycywgZm9ybWF0cywgY2FsbGJhY2ssIHNpbWlsYXIsIHZhcnMpID0+IHtcbiAgICAgIGNvbnN0IGZvcm1hdENoYW5nZUl0ZW1zID0gcmVnaXN0ZXJlZEZvcm1hdExpc3RlbmVycy5nZXQoKTtcbiAgICAgIGVhY2gkZyhmb3JtYXRzLnNwbGl0KCcsJyksIGZvcm1hdCA9PiB7XG4gICAgICAgIGNvbnN0IGdyb3VwID0gZ2V0JGEoZm9ybWF0Q2hhbmdlSXRlbXMsIGZvcm1hdCkuZ2V0T3JUaHVuaygoKSA9PiB7XG4gICAgICAgICAgY29uc3QgYmFzZSA9IHtcbiAgICAgICAgICAgIHdpdGhTaW1pbGFyOiB7XG4gICAgICAgICAgICAgIHN0YXRlOiBDZWxsKGZhbHNlKSxcbiAgICAgICAgICAgICAgc2ltaWxhcjogdHJ1ZSxcbiAgICAgICAgICAgICAgY2FsbGJhY2tzOiBbXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHdpdGhvdXRTaW1pbGFyOiB7XG4gICAgICAgICAgICAgIHN0YXRlOiBDZWxsKGZhbHNlKSxcbiAgICAgICAgICAgICAgc2ltaWxhcjogZmFsc2UsXG4gICAgICAgICAgICAgIGNhbGxiYWNrczogW11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB3aXRoVmFyczogW11cbiAgICAgICAgICB9O1xuICAgICAgICAgIGZvcm1hdENoYW5nZUl0ZW1zW2Zvcm1hdF0gPSBiYXNlO1xuICAgICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZ2V0Q3VycmVudCA9ICgpID0+IHtcbiAgICAgICAgICBjb25zdCBwYXJlbnRzID0gZ2V0UGFyZW50cyhlZGl0b3IpO1xuICAgICAgICAgIHJldHVybiBtYXRjaGluZ05vZGUoZWRpdG9yLCBwYXJlbnRzLCBmb3JtYXQsIHNpbWlsYXIsIHZhcnMpLmlzU29tZSgpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQodmFycykpIHtcbiAgICAgICAgICBjb25zdCB0b0FwcGVuZFRvID0gc2ltaWxhciA/IGdyb3VwLndpdGhTaW1pbGFyIDogZ3JvdXAud2l0aG91dFNpbWlsYXI7XG4gICAgICAgICAgdG9BcHBlbmRUby5jYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgaWYgKHRvQXBwZW5kVG8uY2FsbGJhY2tzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdG9BcHBlbmRUby5zdGF0ZS5zZXQoZ2V0Q3VycmVudCgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ3JvdXAud2l0aFZhcnMucHVzaCh7XG4gICAgICAgICAgICBzdGF0ZTogQ2VsbChnZXRDdXJyZW50KCkpLFxuICAgICAgICAgICAgc2ltaWxhcixcbiAgICAgICAgICAgIHZhcnMsXG4gICAgICAgICAgICBjYWxsYmFja1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyZWRGb3JtYXRMaXN0ZW5lcnMuc2V0KGZvcm1hdENoYW5nZUl0ZW1zKTtcbiAgICB9O1xuICAgIGNvbnN0IHJlbW92ZUxpc3RlbmVycyA9IChyZWdpc3RlcmVkRm9ybWF0TGlzdGVuZXJzLCBmb3JtYXRzLCBjYWxsYmFjaykgPT4ge1xuICAgICAgY29uc3QgZm9ybWF0Q2hhbmdlSXRlbXMgPSByZWdpc3RlcmVkRm9ybWF0TGlzdGVuZXJzLmdldCgpO1xuICAgICAgZWFjaCRnKGZvcm1hdHMuc3BsaXQoJywnKSwgZm9ybWF0ID0+IGdldCRhKGZvcm1hdENoYW5nZUl0ZW1zLCBmb3JtYXQpLmVhY2goZ3JvdXAgPT4ge1xuICAgICAgICBmb3JtYXRDaGFuZ2VJdGVtc1tmb3JtYXRdID0ge1xuICAgICAgICAgIHdpdGhTaW1pbGFyOiB7XG4gICAgICAgICAgICAuLi5ncm91cC53aXRoU2ltaWxhcixcbiAgICAgICAgICAgIGNhbGxiYWNrczogZmlsdGVyJDYoZ3JvdXAud2l0aFNpbWlsYXIuY2FsbGJhY2tzLCBjYiA9PiBjYiAhPT0gY2FsbGJhY2spXG4gICAgICAgICAgfSxcbiAgICAgICAgICB3aXRob3V0U2ltaWxhcjoge1xuICAgICAgICAgICAgLi4uZ3JvdXAud2l0aG91dFNpbWlsYXIsXG4gICAgICAgICAgICBjYWxsYmFja3M6IGZpbHRlciQ2KGdyb3VwLndpdGhvdXRTaW1pbGFyLmNhbGxiYWNrcywgY2IgPT4gY2IgIT09IGNhbGxiYWNrKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgd2l0aFZhcnM6IGZpbHRlciQ2KGdyb3VwLndpdGhWYXJzLCBpdGVtID0+IGl0ZW0uY2FsbGJhY2sgIT09IGNhbGxiYWNrKVxuICAgICAgICB9O1xuICAgICAgfSkpO1xuICAgICAgcmVnaXN0ZXJlZEZvcm1hdExpc3RlbmVycy5zZXQoZm9ybWF0Q2hhbmdlSXRlbXMpO1xuICAgIH07XG4gICAgY29uc3QgZm9ybWF0Q2hhbmdlZEludGVybmFsID0gKGVkaXRvciwgcmVnaXN0ZXJlZEZvcm1hdExpc3RlbmVycywgZm9ybWF0cywgY2FsbGJhY2ssIHNpbWlsYXIsIHZhcnMpID0+IHtcbiAgICAgIGlmIChyZWdpc3RlcmVkRm9ybWF0TGlzdGVuZXJzLmdldCgpID09PSBudWxsKSB7XG4gICAgICAgIHNldHVwJHQocmVnaXN0ZXJlZEZvcm1hdExpc3RlbmVycywgZWRpdG9yKTtcbiAgICAgIH1cbiAgICAgIGFkZExpc3RlbmVycyhlZGl0b3IsIHJlZ2lzdGVyZWRGb3JtYXRMaXN0ZW5lcnMsIGZvcm1hdHMsIGNhbGxiYWNrLCBzaW1pbGFyLCB2YXJzKTtcbiAgICAgIHJldHVybiB7IHVuYmluZDogKCkgPT4gcmVtb3ZlTGlzdGVuZXJzKHJlZ2lzdGVyZWRGb3JtYXRMaXN0ZW5lcnMsIGZvcm1hdHMsIGNhbGxiYWNrKSB9O1xuICAgIH07XG5cbiAgICBjb25zdCB0b2dnbGUgPSAoZWRpdG9yLCBuYW1lLCB2YXJzLCBub2RlKSA9PiB7XG4gICAgICBjb25zdCBmbXQgPSBlZGl0b3IuZm9ybWF0dGVyLmdldChuYW1lKTtcbiAgICAgIGlmIChtYXRjaCQyKGVkaXRvciwgbmFtZSwgdmFycywgbm9kZSkgJiYgKCEoJ3RvZ2dsZScgaW4gZm10WzBdKSB8fCBmbXRbMF0udG9nZ2xlKSkge1xuICAgICAgICByZW1vdmUkMihlZGl0b3IsIG5hbWUsIHZhcnMsIG5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXBwbHlGb3JtYXQkMShlZGl0b3IsIG5hbWUsIHZhcnMsIG5vZGUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBhcnIyW2ldID0gYXJyW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnIyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oYXJyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0Lmhhc093blByb3BlcnR5LCBzZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiwgaXNGcm96ZW4gPSBPYmplY3QuaXNGcm96ZW4sIGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mLCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICAgIHZhciBmcmVlemUgPSBPYmplY3QuZnJlZXplLCBzZWFsID0gT2JqZWN0LnNlYWwsIGNyZWF0ZSQ3ID0gT2JqZWN0LmNyZWF0ZTtcbiAgICB2YXIgX3JlZiA9IHR5cGVvZiBSZWZsZWN0ICE9PSAndW5kZWZpbmVkJyAmJiBSZWZsZWN0LCBhcHBseSA9IF9yZWYuYXBwbHksIGNvbnN0cnVjdCA9IF9yZWYuY29uc3RydWN0O1xuICAgIGlmICghYXBwbHkpIHtcbiAgICAgIGFwcGx5ID0gZnVuY3Rpb24gYXBwbHkoZnVuLCB0aGlzVmFsdWUsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZ1bi5hcHBseSh0aGlzVmFsdWUsIGFyZ3MpO1xuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCFmcmVlemUpIHtcbiAgICAgIGZyZWV6ZSA9IGZ1bmN0aW9uIGZyZWV6ZSh4KSB7XG4gICAgICAgIHJldHVybiB4O1xuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCFzZWFsKSB7XG4gICAgICBzZWFsID0gZnVuY3Rpb24gc2VhbCh4KSB7XG4gICAgICAgIHJldHVybiB4O1xuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCFjb25zdHJ1Y3QpIHtcbiAgICAgIGNvbnN0cnVjdCA9IGZ1bmN0aW9uIGNvbnN0cnVjdChGdW5jLCBhcmdzKSB7XG4gICAgICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KEZ1bmMsIFtudWxsXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGFyZ3MpKSkpKCk7XG4gICAgICB9O1xuICAgIH1cbiAgICB2YXIgYXJyYXlGb3JFYWNoID0gdW5hcHBseShBcnJheS5wcm90b3R5cGUuZm9yRWFjaCk7XG4gICAgdmFyIGFycmF5UG9wID0gdW5hcHBseShBcnJheS5wcm90b3R5cGUucG9wKTtcbiAgICB2YXIgYXJyYXlQdXNoID0gdW5hcHBseShBcnJheS5wcm90b3R5cGUucHVzaCk7XG4gICAgdmFyIHN0cmluZ1RvTG93ZXJDYXNlID0gdW5hcHBseShTdHJpbmcucHJvdG90eXBlLnRvTG93ZXJDYXNlKTtcbiAgICB2YXIgc3RyaW5nTWF0Y2ggPSB1bmFwcGx5KFN0cmluZy5wcm90b3R5cGUubWF0Y2gpO1xuICAgIHZhciBzdHJpbmdSZXBsYWNlID0gdW5hcHBseShTdHJpbmcucHJvdG90eXBlLnJlcGxhY2UpO1xuICAgIHZhciBzdHJpbmdJbmRleE9mID0gdW5hcHBseShTdHJpbmcucHJvdG90eXBlLmluZGV4T2YpO1xuICAgIHZhciBzdHJpbmdUcmltID0gdW5hcHBseShTdHJpbmcucHJvdG90eXBlLnRyaW0pO1xuICAgIHZhciByZWdFeHBUZXN0ID0gdW5hcHBseShSZWdFeHAucHJvdG90eXBlLnRlc3QpO1xuICAgIHZhciB0eXBlRXJyb3JDcmVhdGUgPSB1bmNvbnN0cnVjdChUeXBlRXJyb3IpO1xuICAgIGZ1bmN0aW9uIHVuYXBwbHkoZnVuYykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0aGlzQXJnKSB7XG4gICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzQXJnLCBhcmdzKTtcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVuY29uc3RydWN0KGZ1bmMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3QoZnVuYywgYXJncyk7XG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZGRUb1NldChzZXQsIGFycmF5KSB7XG4gICAgICBpZiAoc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgICAgc2V0UHJvdG90eXBlT2Yoc2V0LCBudWxsKTtcbiAgICAgIH1cbiAgICAgIHZhciBsID0gYXJyYXkubGVuZ3RoO1xuICAgICAgd2hpbGUgKGwtLSkge1xuICAgICAgICB2YXIgZWxlbWVudCA9IGFycmF5W2xdO1xuICAgICAgICBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdmFyIGxjRWxlbWVudCA9IHN0cmluZ1RvTG93ZXJDYXNlKGVsZW1lbnQpO1xuICAgICAgICAgIGlmIChsY0VsZW1lbnQgIT09IGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmICghaXNGcm96ZW4oYXJyYXkpKSB7XG4gICAgICAgICAgICAgIGFycmF5W2xdID0gbGNFbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxlbWVudCA9IGxjRWxlbWVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2V0W2VsZW1lbnRdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsb25lKG9iamVjdCkge1xuICAgICAgdmFyIG5ld09iamVjdCA9IGNyZWF0ZSQ3KG51bGwpO1xuICAgICAgdmFyIHByb3BlcnR5ID0gdm9pZCAwO1xuICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgaWYgKGFwcGx5KGhhc093blByb3BlcnR5LCBvYmplY3QsIFtwcm9wZXJ0eV0pKSB7XG4gICAgICAgICAgbmV3T2JqZWN0W3Byb3BlcnR5XSA9IG9iamVjdFtwcm9wZXJ0eV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdPYmplY3Q7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxvb2t1cEdldHRlcihvYmplY3QsIHByb3ApIHtcbiAgICAgIHdoaWxlIChvYmplY3QgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIGRlc2MgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wKTtcbiAgICAgICAgaWYgKGRlc2MpIHtcbiAgICAgICAgICBpZiAoZGVzYy5nZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmFwcGx5KGRlc2MuZ2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBkZXNjLnZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5hcHBseShkZXNjLnZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0ID0gZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGZhbGxiYWNrVmFsdWUoZWxlbWVudCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ2ZhbGxiYWNrIHZhbHVlIGZvcicsIGVsZW1lbnQpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxsYmFja1ZhbHVlO1xuICAgIH1cbiAgICB2YXIgaHRtbCA9IGZyZWV6ZShbXG4gICAgICAnYScsXG4gICAgICAnYWJicicsXG4gICAgICAnYWNyb255bScsXG4gICAgICAnYWRkcmVzcycsXG4gICAgICAnYXJlYScsXG4gICAgICAnYXJ0aWNsZScsXG4gICAgICAnYXNpZGUnLFxuICAgICAgJ2F1ZGlvJyxcbiAgICAgICdiJyxcbiAgICAgICdiZGknLFxuICAgICAgJ2JkbycsXG4gICAgICAnYmlnJyxcbiAgICAgICdibGluaycsXG4gICAgICAnYmxvY2txdW90ZScsXG4gICAgICAnYm9keScsXG4gICAgICAnYnInLFxuICAgICAgJ2J1dHRvbicsXG4gICAgICAnY2FudmFzJyxcbiAgICAgICdjYXB0aW9uJyxcbiAgICAgICdjZW50ZXInLFxuICAgICAgJ2NpdGUnLFxuICAgICAgJ2NvZGUnLFxuICAgICAgJ2NvbCcsXG4gICAgICAnY29sZ3JvdXAnLFxuICAgICAgJ2NvbnRlbnQnLFxuICAgICAgJ2RhdGEnLFxuICAgICAgJ2RhdGFsaXN0JyxcbiAgICAgICdkZCcsXG4gICAgICAnZGVjb3JhdG9yJyxcbiAgICAgICdkZWwnLFxuICAgICAgJ2RldGFpbHMnLFxuICAgICAgJ2RmbicsXG4gICAgICAnZGlhbG9nJyxcbiAgICAgICdkaXInLFxuICAgICAgJ2RpdicsXG4gICAgICAnZGwnLFxuICAgICAgJ2R0JyxcbiAgICAgICdlbGVtZW50JyxcbiAgICAgICdlbScsXG4gICAgICAnZmllbGRzZXQnLFxuICAgICAgJ2ZpZ2NhcHRpb24nLFxuICAgICAgJ2ZpZ3VyZScsXG4gICAgICAnZm9udCcsXG4gICAgICAnZm9vdGVyJyxcbiAgICAgICdmb3JtJyxcbiAgICAgICdoMScsXG4gICAgICAnaDInLFxuICAgICAgJ2gzJyxcbiAgICAgICdoNCcsXG4gICAgICAnaDUnLFxuICAgICAgJ2g2JyxcbiAgICAgICdoZWFkJyxcbiAgICAgICdoZWFkZXInLFxuICAgICAgJ2hncm91cCcsXG4gICAgICAnaHInLFxuICAgICAgJ2h0bWwnLFxuICAgICAgJ2knLFxuICAgICAgJ2ltZycsXG4gICAgICAnaW5wdXQnLFxuICAgICAgJ2lucycsXG4gICAgICAna2JkJyxcbiAgICAgICdsYWJlbCcsXG4gICAgICAnbGVnZW5kJyxcbiAgICAgICdsaScsXG4gICAgICAnbWFpbicsXG4gICAgICAnbWFwJyxcbiAgICAgICdtYXJrJyxcbiAgICAgICdtYXJxdWVlJyxcbiAgICAgICdtZW51JyxcbiAgICAgICdtZW51aXRlbScsXG4gICAgICAnbWV0ZXInLFxuICAgICAgJ25hdicsXG4gICAgICAnbm9icicsXG4gICAgICAnb2wnLFxuICAgICAgJ29wdGdyb3VwJyxcbiAgICAgICdvcHRpb24nLFxuICAgICAgJ291dHB1dCcsXG4gICAgICAncCcsXG4gICAgICAncGljdHVyZScsXG4gICAgICAncHJlJyxcbiAgICAgICdwcm9ncmVzcycsXG4gICAgICAncScsXG4gICAgICAncnAnLFxuICAgICAgJ3J0JyxcbiAgICAgICdydWJ5JyxcbiAgICAgICdzJyxcbiAgICAgICdzYW1wJyxcbiAgICAgICdzZWN0aW9uJyxcbiAgICAgICdzZWxlY3QnLFxuICAgICAgJ3NoYWRvdycsXG4gICAgICAnc21hbGwnLFxuICAgICAgJ3NvdXJjZScsXG4gICAgICAnc3BhY2VyJyxcbiAgICAgICdzcGFuJyxcbiAgICAgICdzdHJpa2UnLFxuICAgICAgJ3N0cm9uZycsXG4gICAgICAnc3R5bGUnLFxuICAgICAgJ3N1YicsXG4gICAgICAnc3VtbWFyeScsXG4gICAgICAnc3VwJyxcbiAgICAgICd0YWJsZScsXG4gICAgICAndGJvZHknLFxuICAgICAgJ3RkJyxcbiAgICAgICd0ZW1wbGF0ZScsXG4gICAgICAndGV4dGFyZWEnLFxuICAgICAgJ3Rmb290JyxcbiAgICAgICd0aCcsXG4gICAgICAndGhlYWQnLFxuICAgICAgJ3RpbWUnLFxuICAgICAgJ3RyJyxcbiAgICAgICd0cmFjaycsXG4gICAgICAndHQnLFxuICAgICAgJ3UnLFxuICAgICAgJ3VsJyxcbiAgICAgICd2YXInLFxuICAgICAgJ3ZpZGVvJyxcbiAgICAgICd3YnInXG4gICAgXSk7XG4gICAgdmFyIHN2ZyA9IGZyZWV6ZShbXG4gICAgICAnc3ZnJyxcbiAgICAgICdhJyxcbiAgICAgICdhbHRnbHlwaCcsXG4gICAgICAnYWx0Z2x5cGhkZWYnLFxuICAgICAgJ2FsdGdseXBoaXRlbScsXG4gICAgICAnYW5pbWF0ZWNvbG9yJyxcbiAgICAgICdhbmltYXRlbW90aW9uJyxcbiAgICAgICdhbmltYXRldHJhbnNmb3JtJyxcbiAgICAgICdjaXJjbGUnLFxuICAgICAgJ2NsaXBwYXRoJyxcbiAgICAgICdkZWZzJyxcbiAgICAgICdkZXNjJyxcbiAgICAgICdlbGxpcHNlJyxcbiAgICAgICdmaWx0ZXInLFxuICAgICAgJ2ZvbnQnLFxuICAgICAgJ2cnLFxuICAgICAgJ2dseXBoJyxcbiAgICAgICdnbHlwaHJlZicsXG4gICAgICAnaGtlcm4nLFxuICAgICAgJ2ltYWdlJyxcbiAgICAgICdsaW5lJyxcbiAgICAgICdsaW5lYXJncmFkaWVudCcsXG4gICAgICAnbWFya2VyJyxcbiAgICAgICdtYXNrJyxcbiAgICAgICdtZXRhZGF0YScsXG4gICAgICAnbXBhdGgnLFxuICAgICAgJ3BhdGgnLFxuICAgICAgJ3BhdHRlcm4nLFxuICAgICAgJ3BvbHlnb24nLFxuICAgICAgJ3BvbHlsaW5lJyxcbiAgICAgICdyYWRpYWxncmFkaWVudCcsXG4gICAgICAncmVjdCcsXG4gICAgICAnc3RvcCcsXG4gICAgICAnc3R5bGUnLFxuICAgICAgJ3N3aXRjaCcsXG4gICAgICAnc3ltYm9sJyxcbiAgICAgICd0ZXh0JyxcbiAgICAgICd0ZXh0cGF0aCcsXG4gICAgICAndGl0bGUnLFxuICAgICAgJ3RyZWYnLFxuICAgICAgJ3RzcGFuJyxcbiAgICAgICd2aWV3JyxcbiAgICAgICd2a2VybidcbiAgICBdKTtcbiAgICB2YXIgc3ZnRmlsdGVycyA9IGZyZWV6ZShbXG4gICAgICAnZmVCbGVuZCcsXG4gICAgICAnZmVDb2xvck1hdHJpeCcsXG4gICAgICAnZmVDb21wb25lbnRUcmFuc2ZlcicsXG4gICAgICAnZmVDb21wb3NpdGUnLFxuICAgICAgJ2ZlQ29udm9sdmVNYXRyaXgnLFxuICAgICAgJ2ZlRGlmZnVzZUxpZ2h0aW5nJyxcbiAgICAgICdmZURpc3BsYWNlbWVudE1hcCcsXG4gICAgICAnZmVEaXN0YW50TGlnaHQnLFxuICAgICAgJ2ZlRmxvb2QnLFxuICAgICAgJ2ZlRnVuY0EnLFxuICAgICAgJ2ZlRnVuY0InLFxuICAgICAgJ2ZlRnVuY0cnLFxuICAgICAgJ2ZlRnVuY1InLFxuICAgICAgJ2ZlR2F1c3NpYW5CbHVyJyxcbiAgICAgICdmZUltYWdlJyxcbiAgICAgICdmZU1lcmdlJyxcbiAgICAgICdmZU1lcmdlTm9kZScsXG4gICAgICAnZmVNb3JwaG9sb2d5JyxcbiAgICAgICdmZU9mZnNldCcsXG4gICAgICAnZmVQb2ludExpZ2h0JyxcbiAgICAgICdmZVNwZWN1bGFyTGlnaHRpbmcnLFxuICAgICAgJ2ZlU3BvdExpZ2h0JyxcbiAgICAgICdmZVRpbGUnLFxuICAgICAgJ2ZlVHVyYnVsZW5jZSdcbiAgICBdKTtcbiAgICB2YXIgc3ZnRGlzYWxsb3dlZCA9IGZyZWV6ZShbXG4gICAgICAnYW5pbWF0ZScsXG4gICAgICAnY29sb3ItcHJvZmlsZScsXG4gICAgICAnY3Vyc29yJyxcbiAgICAgICdkaXNjYXJkJyxcbiAgICAgICdmZWRyb3BzaGFkb3cnLFxuICAgICAgJ2ZvbnQtZmFjZScsXG4gICAgICAnZm9udC1mYWNlLWZvcm1hdCcsXG4gICAgICAnZm9udC1mYWNlLW5hbWUnLFxuICAgICAgJ2ZvbnQtZmFjZS1zcmMnLFxuICAgICAgJ2ZvbnQtZmFjZS11cmknLFxuICAgICAgJ2ZvcmVpZ25vYmplY3QnLFxuICAgICAgJ2hhdGNoJyxcbiAgICAgICdoYXRjaHBhdGgnLFxuICAgICAgJ21lc2gnLFxuICAgICAgJ21lc2hncmFkaWVudCcsXG4gICAgICAnbWVzaHBhdGNoJyxcbiAgICAgICdtZXNocm93JyxcbiAgICAgICdtaXNzaW5nLWdseXBoJyxcbiAgICAgICdzY3JpcHQnLFxuICAgICAgJ3NldCcsXG4gICAgICAnc29saWRjb2xvcicsXG4gICAgICAndW5rbm93bicsXG4gICAgICAndXNlJ1xuICAgIF0pO1xuICAgIHZhciBtYXRoTWwgPSBmcmVlemUoW1xuICAgICAgJ21hdGgnLFxuICAgICAgJ21lbmNsb3NlJyxcbiAgICAgICdtZXJyb3InLFxuICAgICAgJ21mZW5jZWQnLFxuICAgICAgJ21mcmFjJyxcbiAgICAgICdtZ2x5cGgnLFxuICAgICAgJ21pJyxcbiAgICAgICdtbGFiZWxlZHRyJyxcbiAgICAgICdtbXVsdGlzY3JpcHRzJyxcbiAgICAgICdtbicsXG4gICAgICAnbW8nLFxuICAgICAgJ21vdmVyJyxcbiAgICAgICdtcGFkZGVkJyxcbiAgICAgICdtcGhhbnRvbScsXG4gICAgICAnbXJvb3QnLFxuICAgICAgJ21yb3cnLFxuICAgICAgJ21zJyxcbiAgICAgICdtc3BhY2UnLFxuICAgICAgJ21zcXJ0JyxcbiAgICAgICdtc3R5bGUnLFxuICAgICAgJ21zdWInLFxuICAgICAgJ21zdXAnLFxuICAgICAgJ21zdWJzdXAnLFxuICAgICAgJ210YWJsZScsXG4gICAgICAnbXRkJyxcbiAgICAgICdtdGV4dCcsXG4gICAgICAnbXRyJyxcbiAgICAgICdtdW5kZXInLFxuICAgICAgJ211bmRlcm92ZXInXG4gICAgXSk7XG4gICAgdmFyIG1hdGhNbERpc2FsbG93ZWQgPSBmcmVlemUoW1xuICAgICAgJ21hY3Rpb24nLFxuICAgICAgJ21hbGlnbmdyb3VwJyxcbiAgICAgICdtYWxpZ25tYXJrJyxcbiAgICAgICdtbG9uZ2RpdicsXG4gICAgICAnbXNjYXJyaWVzJyxcbiAgICAgICdtc2NhcnJ5JyxcbiAgICAgICdtc2dyb3VwJyxcbiAgICAgICdtc3RhY2snLFxuICAgICAgJ21zbGluZScsXG4gICAgICAnbXNyb3cnLFxuICAgICAgJ3NlbWFudGljcycsXG4gICAgICAnYW5ub3RhdGlvbicsXG4gICAgICAnYW5ub3RhdGlvbi14bWwnLFxuICAgICAgJ21wcmVzY3JpcHRzJyxcbiAgICAgICdub25lJ1xuICAgIF0pO1xuICAgIHZhciB0ZXh0ID0gZnJlZXplKFsnI3RleHQnXSk7XG4gICAgdmFyIGh0bWwkMSA9IGZyZWV6ZShbXG4gICAgICAnYWNjZXB0JyxcbiAgICAgICdhY3Rpb24nLFxuICAgICAgJ2FsaWduJyxcbiAgICAgICdhbHQnLFxuICAgICAgJ2F1dG9jYXBpdGFsaXplJyxcbiAgICAgICdhdXRvY29tcGxldGUnLFxuICAgICAgJ2F1dG9waWN0dXJlaW5waWN0dXJlJyxcbiAgICAgICdhdXRvcGxheScsXG4gICAgICAnYmFja2dyb3VuZCcsXG4gICAgICAnYmdjb2xvcicsXG4gICAgICAnYm9yZGVyJyxcbiAgICAgICdjYXB0dXJlJyxcbiAgICAgICdjZWxscGFkZGluZycsXG4gICAgICAnY2VsbHNwYWNpbmcnLFxuICAgICAgJ2NoZWNrZWQnLFxuICAgICAgJ2NpdGUnLFxuICAgICAgJ2NsYXNzJyxcbiAgICAgICdjbGVhcicsXG4gICAgICAnY29sb3InLFxuICAgICAgJ2NvbHMnLFxuICAgICAgJ2NvbHNwYW4nLFxuICAgICAgJ2NvbnRyb2xzJyxcbiAgICAgICdjb250cm9sc2xpc3QnLFxuICAgICAgJ2Nvb3JkcycsXG4gICAgICAnY3Jvc3NvcmlnaW4nLFxuICAgICAgJ2RhdGV0aW1lJyxcbiAgICAgICdkZWNvZGluZycsXG4gICAgICAnZGVmYXVsdCcsXG4gICAgICAnZGlyJyxcbiAgICAgICdkaXNhYmxlZCcsXG4gICAgICAnZGlzYWJsZXBpY3R1cmVpbnBpY3R1cmUnLFxuICAgICAgJ2Rpc2FibGVyZW1vdGVwbGF5YmFjaycsXG4gICAgICAnZG93bmxvYWQnLFxuICAgICAgJ2RyYWdnYWJsZScsXG4gICAgICAnZW5jdHlwZScsXG4gICAgICAnZW50ZXJrZXloaW50JyxcbiAgICAgICdmYWNlJyxcbiAgICAgICdmb3InLFxuICAgICAgJ2hlYWRlcnMnLFxuICAgICAgJ2hlaWdodCcsXG4gICAgICAnaGlkZGVuJyxcbiAgICAgICdoaWdoJyxcbiAgICAgICdocmVmJyxcbiAgICAgICdocmVmbGFuZycsXG4gICAgICAnaWQnLFxuICAgICAgJ2lucHV0bW9kZScsXG4gICAgICAnaW50ZWdyaXR5JyxcbiAgICAgICdpc21hcCcsXG4gICAgICAna2luZCcsXG4gICAgICAnbGFiZWwnLFxuICAgICAgJ2xhbmcnLFxuICAgICAgJ2xpc3QnLFxuICAgICAgJ2xvYWRpbmcnLFxuICAgICAgJ2xvb3AnLFxuICAgICAgJ2xvdycsXG4gICAgICAnbWF4JyxcbiAgICAgICdtYXhsZW5ndGgnLFxuICAgICAgJ21lZGlhJyxcbiAgICAgICdtZXRob2QnLFxuICAgICAgJ21pbicsXG4gICAgICAnbWlubGVuZ3RoJyxcbiAgICAgICdtdWx0aXBsZScsXG4gICAgICAnbXV0ZWQnLFxuICAgICAgJ25hbWUnLFxuICAgICAgJ25vbmNlJyxcbiAgICAgICdub3NoYWRlJyxcbiAgICAgICdub3ZhbGlkYXRlJyxcbiAgICAgICdub3dyYXAnLFxuICAgICAgJ29wZW4nLFxuICAgICAgJ29wdGltdW0nLFxuICAgICAgJ3BhdHRlcm4nLFxuICAgICAgJ3BsYWNlaG9sZGVyJyxcbiAgICAgICdwbGF5c2lubGluZScsXG4gICAgICAncG9zdGVyJyxcbiAgICAgICdwcmVsb2FkJyxcbiAgICAgICdwdWJkYXRlJyxcbiAgICAgICdyYWRpb2dyb3VwJyxcbiAgICAgICdyZWFkb25seScsXG4gICAgICAncmVsJyxcbiAgICAgICdyZXF1aXJlZCcsXG4gICAgICAncmV2JyxcbiAgICAgICdyZXZlcnNlZCcsXG4gICAgICAncm9sZScsXG4gICAgICAncm93cycsXG4gICAgICAncm93c3BhbicsXG4gICAgICAnc3BlbGxjaGVjaycsXG4gICAgICAnc2NvcGUnLFxuICAgICAgJ3NlbGVjdGVkJyxcbiAgICAgICdzaGFwZScsXG4gICAgICAnc2l6ZScsXG4gICAgICAnc2l6ZXMnLFxuICAgICAgJ3NwYW4nLFxuICAgICAgJ3NyY2xhbmcnLFxuICAgICAgJ3N0YXJ0JyxcbiAgICAgICdzcmMnLFxuICAgICAgJ3NyY3NldCcsXG4gICAgICAnc3RlcCcsXG4gICAgICAnc3R5bGUnLFxuICAgICAgJ3N1bW1hcnknLFxuICAgICAgJ3RhYmluZGV4JyxcbiAgICAgICd0aXRsZScsXG4gICAgICAndHJhbnNsYXRlJyxcbiAgICAgICd0eXBlJyxcbiAgICAgICd1c2VtYXAnLFxuICAgICAgJ3ZhbGlnbicsXG4gICAgICAndmFsdWUnLFxuICAgICAgJ3dpZHRoJyxcbiAgICAgICd4bWxucycsXG4gICAgICAnc2xvdCdcbiAgICBdKTtcbiAgICB2YXIgc3ZnJDEgPSBmcmVlemUoW1xuICAgICAgJ2FjY2VudC1oZWlnaHQnLFxuICAgICAgJ2FjY3VtdWxhdGUnLFxuICAgICAgJ2FkZGl0aXZlJyxcbiAgICAgICdhbGlnbm1lbnQtYmFzZWxpbmUnLFxuICAgICAgJ2FzY2VudCcsXG4gICAgICAnYXR0cmlidXRlbmFtZScsXG4gICAgICAnYXR0cmlidXRldHlwZScsXG4gICAgICAnYXppbXV0aCcsXG4gICAgICAnYmFzZWZyZXF1ZW5jeScsXG4gICAgICAnYmFzZWxpbmUtc2hpZnQnLFxuICAgICAgJ2JlZ2luJyxcbiAgICAgICdiaWFzJyxcbiAgICAgICdieScsXG4gICAgICAnY2xhc3MnLFxuICAgICAgJ2NsaXAnLFxuICAgICAgJ2NsaXBwYXRodW5pdHMnLFxuICAgICAgJ2NsaXAtcGF0aCcsXG4gICAgICAnY2xpcC1ydWxlJyxcbiAgICAgICdjb2xvcicsXG4gICAgICAnY29sb3ItaW50ZXJwb2xhdGlvbicsXG4gICAgICAnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJyxcbiAgICAgICdjb2xvci1wcm9maWxlJyxcbiAgICAgICdjb2xvci1yZW5kZXJpbmcnLFxuICAgICAgJ2N4JyxcbiAgICAgICdjeScsXG4gICAgICAnZCcsXG4gICAgICAnZHgnLFxuICAgICAgJ2R5JyxcbiAgICAgICdkaWZmdXNlY29uc3RhbnQnLFxuICAgICAgJ2RpcmVjdGlvbicsXG4gICAgICAnZGlzcGxheScsXG4gICAgICAnZGl2aXNvcicsXG4gICAgICAnZHVyJyxcbiAgICAgICdlZGdlbW9kZScsXG4gICAgICAnZWxldmF0aW9uJyxcbiAgICAgICdlbmQnLFxuICAgICAgJ2ZpbGwnLFxuICAgICAgJ2ZpbGwtb3BhY2l0eScsXG4gICAgICAnZmlsbC1ydWxlJyxcbiAgICAgICdmaWx0ZXInLFxuICAgICAgJ2ZpbHRlcnVuaXRzJyxcbiAgICAgICdmbG9vZC1jb2xvcicsXG4gICAgICAnZmxvb2Qtb3BhY2l0eScsXG4gICAgICAnZm9udC1mYW1pbHknLFxuICAgICAgJ2ZvbnQtc2l6ZScsXG4gICAgICAnZm9udC1zaXplLWFkanVzdCcsXG4gICAgICAnZm9udC1zdHJldGNoJyxcbiAgICAgICdmb250LXN0eWxlJyxcbiAgICAgICdmb250LXZhcmlhbnQnLFxuICAgICAgJ2ZvbnQtd2VpZ2h0JyxcbiAgICAgICdmeCcsXG4gICAgICAnZnknLFxuICAgICAgJ2cxJyxcbiAgICAgICdnMicsXG4gICAgICAnZ2x5cGgtbmFtZScsXG4gICAgICAnZ2x5cGhyZWYnLFxuICAgICAgJ2dyYWRpZW50dW5pdHMnLFxuICAgICAgJ2dyYWRpZW50dHJhbnNmb3JtJyxcbiAgICAgICdoZWlnaHQnLFxuICAgICAgJ2hyZWYnLFxuICAgICAgJ2lkJyxcbiAgICAgICdpbWFnZS1yZW5kZXJpbmcnLFxuICAgICAgJ2luJyxcbiAgICAgICdpbjInLFxuICAgICAgJ2snLFxuICAgICAgJ2sxJyxcbiAgICAgICdrMicsXG4gICAgICAnazMnLFxuICAgICAgJ2s0JyxcbiAgICAgICdrZXJuaW5nJyxcbiAgICAgICdrZXlwb2ludHMnLFxuICAgICAgJ2tleXNwbGluZXMnLFxuICAgICAgJ2tleXRpbWVzJyxcbiAgICAgICdsYW5nJyxcbiAgICAgICdsZW5ndGhhZGp1c3QnLFxuICAgICAgJ2xldHRlci1zcGFjaW5nJyxcbiAgICAgICdrZXJuZWxtYXRyaXgnLFxuICAgICAgJ2tlcm5lbHVuaXRsZW5ndGgnLFxuICAgICAgJ2xpZ2h0aW5nLWNvbG9yJyxcbiAgICAgICdsb2NhbCcsXG4gICAgICAnbWFya2VyLWVuZCcsXG4gICAgICAnbWFya2VyLW1pZCcsXG4gICAgICAnbWFya2VyLXN0YXJ0JyxcbiAgICAgICdtYXJrZXJoZWlnaHQnLFxuICAgICAgJ21hcmtlcnVuaXRzJyxcbiAgICAgICdtYXJrZXJ3aWR0aCcsXG4gICAgICAnbWFza2NvbnRlbnR1bml0cycsXG4gICAgICAnbWFza3VuaXRzJyxcbiAgICAgICdtYXgnLFxuICAgICAgJ21hc2snLFxuICAgICAgJ21lZGlhJyxcbiAgICAgICdtZXRob2QnLFxuICAgICAgJ21vZGUnLFxuICAgICAgJ21pbicsXG4gICAgICAnbmFtZScsXG4gICAgICAnbnVtb2N0YXZlcycsXG4gICAgICAnb2Zmc2V0JyxcbiAgICAgICdvcGVyYXRvcicsXG4gICAgICAnb3BhY2l0eScsXG4gICAgICAnb3JkZXInLFxuICAgICAgJ29yaWVudCcsXG4gICAgICAnb3JpZW50YXRpb24nLFxuICAgICAgJ29yaWdpbicsXG4gICAgICAnb3ZlcmZsb3cnLFxuICAgICAgJ3BhaW50LW9yZGVyJyxcbiAgICAgICdwYXRoJyxcbiAgICAgICdwYXRobGVuZ3RoJyxcbiAgICAgICdwYXR0ZXJuY29udGVudHVuaXRzJyxcbiAgICAgICdwYXR0ZXJudHJhbnNmb3JtJyxcbiAgICAgICdwYXR0ZXJudW5pdHMnLFxuICAgICAgJ3BvaW50cycsXG4gICAgICAncHJlc2VydmVhbHBoYScsXG4gICAgICAncHJlc2VydmVhc3BlY3RyYXRpbycsXG4gICAgICAncHJpbWl0aXZldW5pdHMnLFxuICAgICAgJ3InLFxuICAgICAgJ3J4JyxcbiAgICAgICdyeScsXG4gICAgICAncmFkaXVzJyxcbiAgICAgICdyZWZ4JyxcbiAgICAgICdyZWZ5JyxcbiAgICAgICdyZXBlYXRjb3VudCcsXG4gICAgICAncmVwZWF0ZHVyJyxcbiAgICAgICdyZXN0YXJ0JyxcbiAgICAgICdyZXN1bHQnLFxuICAgICAgJ3JvdGF0ZScsXG4gICAgICAnc2NhbGUnLFxuICAgICAgJ3NlZWQnLFxuICAgICAgJ3NoYXBlLXJlbmRlcmluZycsXG4gICAgICAnc3BlY3VsYXJjb25zdGFudCcsXG4gICAgICAnc3BlY3VsYXJleHBvbmVudCcsXG4gICAgICAnc3ByZWFkbWV0aG9kJyxcbiAgICAgICdzdGFydG9mZnNldCcsXG4gICAgICAnc3RkZGV2aWF0aW9uJyxcbiAgICAgICdzdGl0Y2h0aWxlcycsXG4gICAgICAnc3RvcC1jb2xvcicsXG4gICAgICAnc3RvcC1vcGFjaXR5JyxcbiAgICAgICdzdHJva2UtZGFzaGFycmF5JyxcbiAgICAgICdzdHJva2UtZGFzaG9mZnNldCcsXG4gICAgICAnc3Ryb2tlLWxpbmVjYXAnLFxuICAgICAgJ3N0cm9rZS1saW5lam9pbicsXG4gICAgICAnc3Ryb2tlLW1pdGVybGltaXQnLFxuICAgICAgJ3N0cm9rZS1vcGFjaXR5JyxcbiAgICAgICdzdHJva2UnLFxuICAgICAgJ3N0cm9rZS13aWR0aCcsXG4gICAgICAnc3R5bGUnLFxuICAgICAgJ3N1cmZhY2VzY2FsZScsXG4gICAgICAnc3lzdGVtbGFuZ3VhZ2UnLFxuICAgICAgJ3RhYmluZGV4JyxcbiAgICAgICd0YXJnZXR4JyxcbiAgICAgICd0YXJnZXR5JyxcbiAgICAgICd0cmFuc2Zvcm0nLFxuICAgICAgJ3RyYW5zZm9ybS1vcmlnaW4nLFxuICAgICAgJ3RleHQtYW5jaG9yJyxcbiAgICAgICd0ZXh0LWRlY29yYXRpb24nLFxuICAgICAgJ3RleHQtcmVuZGVyaW5nJyxcbiAgICAgICd0ZXh0bGVuZ3RoJyxcbiAgICAgICd0eXBlJyxcbiAgICAgICd1MScsXG4gICAgICAndTInLFxuICAgICAgJ3VuaWNvZGUnLFxuICAgICAgJ3ZhbHVlcycsXG4gICAgICAndmlld2JveCcsXG4gICAgICAndmlzaWJpbGl0eScsXG4gICAgICAndmVyc2lvbicsXG4gICAgICAndmVydC1hZHYteScsXG4gICAgICAndmVydC1vcmlnaW4teCcsXG4gICAgICAndmVydC1vcmlnaW4teScsXG4gICAgICAnd2lkdGgnLFxuICAgICAgJ3dvcmQtc3BhY2luZycsXG4gICAgICAnd3JhcCcsXG4gICAgICAnd3JpdGluZy1tb2RlJyxcbiAgICAgICd4Y2hhbm5lbHNlbGVjdG9yJyxcbiAgICAgICd5Y2hhbm5lbHNlbGVjdG9yJyxcbiAgICAgICd4JyxcbiAgICAgICd4MScsXG4gICAgICAneDInLFxuICAgICAgJ3htbG5zJyxcbiAgICAgICd5JyxcbiAgICAgICd5MScsXG4gICAgICAneTInLFxuICAgICAgJ3onLFxuICAgICAgJ3pvb21hbmRwYW4nXG4gICAgXSk7XG4gICAgdmFyIG1hdGhNbCQxID0gZnJlZXplKFtcbiAgICAgICdhY2NlbnQnLFxuICAgICAgJ2FjY2VudHVuZGVyJyxcbiAgICAgICdhbGlnbicsXG4gICAgICAnYmV2ZWxsZWQnLFxuICAgICAgJ2Nsb3NlJyxcbiAgICAgICdjb2x1bW5zYWxpZ24nLFxuICAgICAgJ2NvbHVtbmxpbmVzJyxcbiAgICAgICdjb2x1bW5zcGFuJyxcbiAgICAgICdkZW5vbWFsaWduJyxcbiAgICAgICdkZXB0aCcsXG4gICAgICAnZGlyJyxcbiAgICAgICdkaXNwbGF5JyxcbiAgICAgICdkaXNwbGF5c3R5bGUnLFxuICAgICAgJ2VuY29kaW5nJyxcbiAgICAgICdmZW5jZScsXG4gICAgICAnZnJhbWUnLFxuICAgICAgJ2hlaWdodCcsXG4gICAgICAnaHJlZicsXG4gICAgICAnaWQnLFxuICAgICAgJ2xhcmdlb3AnLFxuICAgICAgJ2xlbmd0aCcsXG4gICAgICAnbGluZXRoaWNrbmVzcycsXG4gICAgICAnbHNwYWNlJyxcbiAgICAgICdscXVvdGUnLFxuICAgICAgJ21hdGhiYWNrZ3JvdW5kJyxcbiAgICAgICdtYXRoY29sb3InLFxuICAgICAgJ21hdGhzaXplJyxcbiAgICAgICdtYXRodmFyaWFudCcsXG4gICAgICAnbWF4c2l6ZScsXG4gICAgICAnbWluc2l6ZScsXG4gICAgICAnbW92YWJsZWxpbWl0cycsXG4gICAgICAnbm90YXRpb24nLFxuICAgICAgJ251bWFsaWduJyxcbiAgICAgICdvcGVuJyxcbiAgICAgICdyb3dhbGlnbicsXG4gICAgICAncm93bGluZXMnLFxuICAgICAgJ3Jvd3NwYWNpbmcnLFxuICAgICAgJ3Jvd3NwYW4nLFxuICAgICAgJ3JzcGFjZScsXG4gICAgICAncnF1b3RlJyxcbiAgICAgICdzY3JpcHRsZXZlbCcsXG4gICAgICAnc2NyaXB0bWluc2l6ZScsXG4gICAgICAnc2NyaXB0c2l6ZW11bHRpcGxpZXInLFxuICAgICAgJ3NlbGVjdGlvbicsXG4gICAgICAnc2VwYXJhdG9yJyxcbiAgICAgICdzZXBhcmF0b3JzJyxcbiAgICAgICdzdHJldGNoeScsXG4gICAgICAnc3Vic2NyaXB0c2hpZnQnLFxuICAgICAgJ3N1cHNjcmlwdHNoaWZ0JyxcbiAgICAgICdzeW1tZXRyaWMnLFxuICAgICAgJ3ZvZmZzZXQnLFxuICAgICAgJ3dpZHRoJyxcbiAgICAgICd4bWxucydcbiAgICBdKTtcbiAgICB2YXIgeG1sID0gZnJlZXplKFtcbiAgICAgICd4bGluazpocmVmJyxcbiAgICAgICd4bWw6aWQnLFxuICAgICAgJ3hsaW5rOnRpdGxlJyxcbiAgICAgICd4bWw6c3BhY2UnLFxuICAgICAgJ3htbG5zOnhsaW5rJ1xuICAgIF0pO1xuICAgIHZhciBNVVNUQUNIRV9FWFBSID0gc2VhbCgvXFx7XFx7W1xcc1xcU10qfFtcXHNcXFNdKlxcfVxcfS9nbSk7XG4gICAgdmFyIEVSQl9FWFBSID0gc2VhbCgvPCVbXFxzXFxTXSp8W1xcc1xcU10qJT4vZ20pO1xuICAgIHZhciBEQVRBX0FUVFIgPSBzZWFsKC9eZGF0YS1bXFwtXFx3LlxcdTAwQjctXFx1RkZGRl0vKTtcbiAgICB2YXIgQVJJQV9BVFRSID0gc2VhbCgvXmFyaWEtW1xcLVxcd10rJC8pO1xuICAgIHZhciBJU19BTExPV0VEX1VSSSA9IHNlYWwoL14oPzooPzooPzpmfGh0KXRwcz98bWFpbHRvfHRlbHxjYWxsdG98Y2lkfHhtcHApOnxbXmEtel18W2EteisuXFwtXSsoPzpbXmEteisuXFwtOl18JCkpL2kpO1xuICAgIHZhciBJU19TQ1JJUFRfT1JfREFUQSA9IHNlYWwoL14oPzpcXHcrc2NyaXB0fGRhdGEpOi9pKTtcbiAgICB2YXIgQVRUUl9XSElURVNQQUNFID0gc2VhbCgvW1xcdTAwMDAtXFx1MDAyMFxcdTAwQTBcXHUxNjgwXFx1MTgwRVxcdTIwMDAtXFx1MjAyOVxcdTIwNUZcXHUzMDAwXS9nKTtcbiAgICB2YXIgRE9DVFlQRV9OQU1FID0gc2VhbCgvXmh0bWwkL2kpO1xuICAgIHZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSAnc3ltYm9sJyA/IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH0gOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gJ3N5bWJvbCcgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gICAgZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5JDEoYXJyKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBhcnIyW2ldID0gYXJyW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnIyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oYXJyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGdldEdsb2JhbCA9IGZ1bmN0aW9uIGdldEdsb2JhbCgpIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiB3aW5kb3c7XG4gICAgfTtcbiAgICB2YXIgX2NyZWF0ZVRydXN0ZWRUeXBlc1BvbGljeSA9IGZ1bmN0aW9uIF9jcmVhdGVUcnVzdGVkVHlwZXNQb2xpY3kodHJ1c3RlZFR5cGVzLCBkb2N1bWVudCkge1xuICAgICAgaWYgKCh0eXBlb2YgdHJ1c3RlZFR5cGVzID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih0cnVzdGVkVHlwZXMpKSAhPT0gJ29iamVjdCcgfHwgdHlwZW9mIHRydXN0ZWRUeXBlcy5jcmVhdGVQb2xpY3kgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgc3VmZml4ID0gbnVsbDtcbiAgICAgIHZhciBBVFRSX05BTUUgPSAnZGF0YS10dC1wb2xpY3ktc3VmZml4JztcbiAgICAgIGlmIChkb2N1bWVudC5jdXJyZW50U2NyaXB0ICYmIGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuaGFzQXR0cmlidXRlKEFUVFJfTkFNRSkpIHtcbiAgICAgICAgc3VmZml4ID0gZG9jdW1lbnQuY3VycmVudFNjcmlwdC5nZXRBdHRyaWJ1dGUoQVRUUl9OQU1FKTtcbiAgICAgIH1cbiAgICAgIHZhciBwb2xpY3lOYW1lID0gJ2RvbXB1cmlmeScgKyAoc3VmZml4ID8gJyMnICsgc3VmZml4IDogJycpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHRydXN0ZWRUeXBlcy5jcmVhdGVQb2xpY3kocG9saWN5TmFtZSwge1xuICAgICAgICAgIGNyZWF0ZUhUTUw6IGZ1bmN0aW9uIGNyZWF0ZUhUTUwoaHRtbCQkMSkge1xuICAgICAgICAgICAgcmV0dXJuIGh0bWwkJDE7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdUcnVzdGVkVHlwZXMgcG9saWN5ICcgKyBwb2xpY3lOYW1lICsgJyBjb3VsZCBub3QgYmUgY3JlYXRlZC4nKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBjcmVhdGVET01QdXJpZnkoKSB7XG4gICAgICB2YXIgd2luZG93ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBnZXRHbG9iYWwoKTtcbiAgICAgIHZhciBET01QdXJpZnkgPSBmdW5jdGlvbiBET01QdXJpZnkocm9vdCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRE9NUHVyaWZ5KHJvb3QpO1xuICAgICAgfTtcbiAgICAgIERPTVB1cmlmeS52ZXJzaW9uID0gJzIuMy42JztcbiAgICAgIERPTVB1cmlmeS5yZW1vdmVkID0gW107XG4gICAgICBpZiAoIXdpbmRvdyB8fCAhd2luZG93LmRvY3VtZW50IHx8IHdpbmRvdy5kb2N1bWVudC5ub2RlVHlwZSAhPT0gOSkge1xuICAgICAgICBET01QdXJpZnkuaXNTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIERPTVB1cmlmeTtcbiAgICAgIH1cbiAgICAgIHZhciBvcmlnaW5hbERvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xuICAgICAgdmFyIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xuICAgICAgdmFyIERvY3VtZW50RnJhZ21lbnQgPSB3aW5kb3cuRG9jdW1lbnRGcmFnbWVudCwgSFRNTFRlbXBsYXRlRWxlbWVudCA9IHdpbmRvdy5IVE1MVGVtcGxhdGVFbGVtZW50LCBOb2RlID0gd2luZG93Lk5vZGUsIEVsZW1lbnQgPSB3aW5kb3cuRWxlbWVudCwgTm9kZUZpbHRlciA9IHdpbmRvdy5Ob2RlRmlsdGVyLCBfd2luZG93JE5hbWVkTm9kZU1hcCA9IHdpbmRvdy5OYW1lZE5vZGVNYXAsIE5hbWVkTm9kZU1hcCA9IF93aW5kb3ckTmFtZWROb2RlTWFwID09PSB1bmRlZmluZWQgPyB3aW5kb3cuTmFtZWROb2RlTWFwIHx8IHdpbmRvdy5Nb3pOYW1lZEF0dHJNYXAgOiBfd2luZG93JE5hbWVkTm9kZU1hcCwgSFRNTEZvcm1FbGVtZW50ID0gd2luZG93LkhUTUxGb3JtRWxlbWVudCwgRE9NUGFyc2VyID0gd2luZG93LkRPTVBhcnNlciwgdHJ1c3RlZFR5cGVzID0gd2luZG93LnRydXN0ZWRUeXBlcztcbiAgICAgIHZhciBFbGVtZW50UHJvdG90eXBlID0gRWxlbWVudC5wcm90b3R5cGU7XG4gICAgICB2YXIgY2xvbmVOb2RlID0gbG9va3VwR2V0dGVyKEVsZW1lbnRQcm90b3R5cGUsICdjbG9uZU5vZGUnKTtcbiAgICAgIHZhciBnZXROZXh0U2libGluZyA9IGxvb2t1cEdldHRlcihFbGVtZW50UHJvdG90eXBlLCAnbmV4dFNpYmxpbmcnKTtcbiAgICAgIHZhciBnZXRDaGlsZE5vZGVzID0gbG9va3VwR2V0dGVyKEVsZW1lbnRQcm90b3R5cGUsICdjaGlsZE5vZGVzJyk7XG4gICAgICB2YXIgZ2V0UGFyZW50Tm9kZSA9IGxvb2t1cEdldHRlcihFbGVtZW50UHJvdG90eXBlLCAncGFyZW50Tm9kZScpO1xuICAgICAgaWYgKHR5cGVvZiBIVE1MVGVtcGxhdGVFbGVtZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgIGlmICh0ZW1wbGF0ZS5jb250ZW50ICYmIHRlbXBsYXRlLmNvbnRlbnQub3duZXJEb2N1bWVudCkge1xuICAgICAgICAgIGRvY3VtZW50ID0gdGVtcGxhdGUuY29udGVudC5vd25lckRvY3VtZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgdHJ1c3RlZFR5cGVzUG9saWN5ID0gX2NyZWF0ZVRydXN0ZWRUeXBlc1BvbGljeSh0cnVzdGVkVHlwZXMsIG9yaWdpbmFsRG9jdW1lbnQpO1xuICAgICAgdmFyIGVtcHR5SFRNTCA9IHRydXN0ZWRUeXBlc1BvbGljeSA/IHRydXN0ZWRUeXBlc1BvbGljeS5jcmVhdGVIVE1MKCcnKSA6ICcnO1xuICAgICAgdmFyIF9kb2N1bWVudCA9IGRvY3VtZW50LCBpbXBsZW1lbnRhdGlvbiA9IF9kb2N1bWVudC5pbXBsZW1lbnRhdGlvbiwgY3JlYXRlTm9kZUl0ZXJhdG9yID0gX2RvY3VtZW50LmNyZWF0ZU5vZGVJdGVyYXRvciwgY3JlYXRlRG9jdW1lbnRGcmFnbWVudCA9IF9kb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50LCBnZXRFbGVtZW50c0J5VGFnTmFtZSA9IF9kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZTtcbiAgICAgIHZhciBpbXBvcnROb2RlID0gb3JpZ2luYWxEb2N1bWVudC5pbXBvcnROb2RlO1xuICAgICAgdmFyIGRvY3VtZW50TW9kZSA9IHt9O1xuICAgICAgdHJ5IHtcbiAgICAgICAgZG9jdW1lbnRNb2RlID0gY2xvbmUoZG9jdW1lbnQpLmRvY3VtZW50TW9kZSA/IGRvY3VtZW50LmRvY3VtZW50TW9kZSA6IHt9O1xuICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgfVxuICAgICAgdmFyIGhvb2tzID0ge307XG4gICAgICBET01QdXJpZnkuaXNTdXBwb3J0ZWQgPSB0eXBlb2YgZ2V0UGFyZW50Tm9kZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpbXBsZW1lbnRhdGlvbiAmJiB0eXBlb2YgaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudE1vZGUgIT09IDk7XG4gICAgICB2YXIgTVVTVEFDSEVfRVhQUiQkMSA9IE1VU1RBQ0hFX0VYUFIsIEVSQl9FWFBSJCQxID0gRVJCX0VYUFIsIERBVEFfQVRUUiQkMSA9IERBVEFfQVRUUiwgQVJJQV9BVFRSJCQxID0gQVJJQV9BVFRSLCBJU19TQ1JJUFRfT1JfREFUQSQkMSA9IElTX1NDUklQVF9PUl9EQVRBLCBBVFRSX1dISVRFU1BBQ0UkJDEgPSBBVFRSX1dISVRFU1BBQ0U7XG4gICAgICB2YXIgSVNfQUxMT1dFRF9VUkkkJDEgPSBJU19BTExPV0VEX1VSSTtcbiAgICAgIHZhciBBTExPV0VEX1RBR1MgPSBudWxsO1xuICAgICAgdmFyIERFRkFVTFRfQUxMT1dFRF9UQUdTID0gYWRkVG9TZXQoe30sIFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkkMShodG1sKSwgX3RvQ29uc3VtYWJsZUFycmF5JDEoc3ZnKSwgX3RvQ29uc3VtYWJsZUFycmF5JDEoc3ZnRmlsdGVycyksIF90b0NvbnN1bWFibGVBcnJheSQxKG1hdGhNbCksIF90b0NvbnN1bWFibGVBcnJheSQxKHRleHQpKSk7XG4gICAgICB2YXIgQUxMT1dFRF9BVFRSID0gbnVsbDtcbiAgICAgIHZhciBERUZBVUxUX0FMTE9XRURfQVRUUiA9IGFkZFRvU2V0KHt9LCBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5JDEoaHRtbCQxKSwgX3RvQ29uc3VtYWJsZUFycmF5JDEoc3ZnJDEpLCBfdG9Db25zdW1hYmxlQXJyYXkkMShtYXRoTWwkMSksIF90b0NvbnN1bWFibGVBcnJheSQxKHhtbCkpKTtcbiAgICAgIHZhciBDVVNUT01fRUxFTUVOVF9IQU5ETElORyA9IE9iamVjdC5zZWFsKE9iamVjdC5jcmVhdGUobnVsbCwge1xuICAgICAgICB0YWdOYW1lQ2hlY2s6IHtcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgYXR0cmlidXRlTmFtZUNoZWNrOiB7XG4gICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIGFsbG93Q3VzdG9taXplZEJ1aWx0SW5FbGVtZW50czoge1xuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgICAgdmFyIEZPUkJJRF9UQUdTID0gbnVsbDtcbiAgICAgIHZhciBGT1JCSURfQVRUUiA9IG51bGw7XG4gICAgICB2YXIgQUxMT1dfQVJJQV9BVFRSID0gdHJ1ZTtcbiAgICAgIHZhciBBTExPV19EQVRBX0FUVFIgPSB0cnVlO1xuICAgICAgdmFyIEFMTE9XX1VOS05PV05fUFJPVE9DT0xTID0gZmFsc2U7XG4gICAgICB2YXIgU0FGRV9GT1JfVEVNUExBVEVTID0gZmFsc2U7XG4gICAgICB2YXIgV0hPTEVfRE9DVU1FTlQgPSBmYWxzZTtcbiAgICAgIHZhciBTRVRfQ09ORklHID0gZmFsc2U7XG4gICAgICB2YXIgRk9SQ0VfQk9EWSA9IGZhbHNlO1xuICAgICAgdmFyIFJFVFVSTl9ET00gPSBmYWxzZTtcbiAgICAgIHZhciBSRVRVUk5fRE9NX0ZSQUdNRU5UID0gZmFsc2U7XG4gICAgICB2YXIgUkVUVVJOX1RSVVNURURfVFlQRSA9IGZhbHNlO1xuICAgICAgdmFyIFNBTklUSVpFX0RPTSA9IHRydWU7XG4gICAgICB2YXIgS0VFUF9DT05URU5UID0gdHJ1ZTtcbiAgICAgIHZhciBJTl9QTEFDRSA9IGZhbHNlO1xuICAgICAgdmFyIFVTRV9QUk9GSUxFUyA9IHt9O1xuICAgICAgdmFyIEZPUkJJRF9DT05URU5UUyA9IG51bGw7XG4gICAgICB2YXIgREVGQVVMVF9GT1JCSURfQ09OVEVOVFMgPSBhZGRUb1NldCh7fSwgW1xuICAgICAgICAnYW5ub3RhdGlvbi14bWwnLFxuICAgICAgICAnYXVkaW8nLFxuICAgICAgICAnY29sZ3JvdXAnLFxuICAgICAgICAnZGVzYycsXG4gICAgICAgICdmb3JlaWdub2JqZWN0JyxcbiAgICAgICAgJ2hlYWQnLFxuICAgICAgICAnaWZyYW1lJyxcbiAgICAgICAgJ21hdGgnLFxuICAgICAgICAnbWknLFxuICAgICAgICAnbW4nLFxuICAgICAgICAnbW8nLFxuICAgICAgICAnbXMnLFxuICAgICAgICAnbXRleHQnLFxuICAgICAgICAnbm9lbWJlZCcsXG4gICAgICAgICdub2ZyYW1lcycsXG4gICAgICAgICdub3NjcmlwdCcsXG4gICAgICAgICdwbGFpbnRleHQnLFxuICAgICAgICAnc2NyaXB0JyxcbiAgICAgICAgJ3N0eWxlJyxcbiAgICAgICAgJ3N2ZycsXG4gICAgICAgICd0ZW1wbGF0ZScsXG4gICAgICAgICd0aGVhZCcsXG4gICAgICAgICd0aXRsZScsXG4gICAgICAgICd2aWRlbycsXG4gICAgICAgICd4bXAnXG4gICAgICBdKTtcbiAgICAgIHZhciBEQVRBX1VSSV9UQUdTID0gbnVsbDtcbiAgICAgIHZhciBERUZBVUxUX0RBVEFfVVJJX1RBR1MgPSBhZGRUb1NldCh7fSwgW1xuICAgICAgICAnYXVkaW8nLFxuICAgICAgICAndmlkZW8nLFxuICAgICAgICAnaW1nJyxcbiAgICAgICAgJ3NvdXJjZScsXG4gICAgICAgICdpbWFnZScsXG4gICAgICAgICd0cmFjaydcbiAgICAgIF0pO1xuICAgICAgdmFyIFVSSV9TQUZFX0FUVFJJQlVURVMgPSBudWxsO1xuICAgICAgdmFyIERFRkFVTFRfVVJJX1NBRkVfQVRUUklCVVRFUyA9IGFkZFRvU2V0KHt9LCBbXG4gICAgICAgICdhbHQnLFxuICAgICAgICAnY2xhc3MnLFxuICAgICAgICAnZm9yJyxcbiAgICAgICAgJ2lkJyxcbiAgICAgICAgJ2xhYmVsJyxcbiAgICAgICAgJ25hbWUnLFxuICAgICAgICAncGF0dGVybicsXG4gICAgICAgICdwbGFjZWhvbGRlcicsXG4gICAgICAgICdyb2xlJyxcbiAgICAgICAgJ3N1bW1hcnknLFxuICAgICAgICAndGl0bGUnLFxuICAgICAgICAndmFsdWUnLFxuICAgICAgICAnc3R5bGUnLFxuICAgICAgICAneG1sbnMnXG4gICAgICBdKTtcbiAgICAgIHZhciBNQVRITUxfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnO1xuICAgICAgdmFyIFNWR19OQU1FU1BBQ0UgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xuICAgICAgdmFyIEhUTUxfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnO1xuICAgICAgdmFyIE5BTUVTUEFDRSA9IEhUTUxfTkFNRVNQQUNFO1xuICAgICAgdmFyIElTX0VNUFRZX0lOUFVUID0gZmFsc2U7XG4gICAgICB2YXIgUEFSU0VSX01FRElBX1RZUEUgPSB2b2lkIDA7XG4gICAgICB2YXIgU1VQUE9SVEVEX1BBUlNFUl9NRURJQV9UWVBFUyA9IFtcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3hodG1sK3htbCcsXG4gICAgICAgICd0ZXh0L2h0bWwnXG4gICAgICBdO1xuICAgICAgdmFyIERFRkFVTFRfUEFSU0VSX01FRElBX1RZUEUgPSAndGV4dC9odG1sJztcbiAgICAgIHZhciB0cmFuc2Zvcm1DYXNlRnVuYyA9IHZvaWQgMDtcbiAgICAgIHZhciBDT05GSUcgPSBudWxsO1xuICAgICAgdmFyIGZvcm1FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZm9ybScpO1xuICAgICAgdmFyIGlzUmVnZXhPckZ1bmN0aW9uID0gZnVuY3Rpb24gaXNSZWdleE9yRnVuY3Rpb24odGVzdFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0ZXN0VmFsdWUgaW5zdGFuY2VvZiBSZWdFeHAgfHwgdGVzdFZhbHVlIGluc3RhbmNlb2YgRnVuY3Rpb247XG4gICAgICB9O1xuICAgICAgdmFyIF9wYXJzZUNvbmZpZyA9IGZ1bmN0aW9uIF9wYXJzZUNvbmZpZyhjZmcpIHtcbiAgICAgICAgaWYgKENPTkZJRyAmJiBDT05GSUcgPT09IGNmZykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNmZyB8fCAodHlwZW9mIGNmZyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoY2ZnKSkgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgY2ZnID0ge307XG4gICAgICAgIH1cbiAgICAgICAgY2ZnID0gY2xvbmUoY2ZnKTtcbiAgICAgICAgQUxMT1dFRF9UQUdTID0gJ0FMTE9XRURfVEFHUycgaW4gY2ZnID8gYWRkVG9TZXQoe30sIGNmZy5BTExPV0VEX1RBR1MpIDogREVGQVVMVF9BTExPV0VEX1RBR1M7XG4gICAgICAgIEFMTE9XRURfQVRUUiA9ICdBTExPV0VEX0FUVFInIGluIGNmZyA/IGFkZFRvU2V0KHt9LCBjZmcuQUxMT1dFRF9BVFRSKSA6IERFRkFVTFRfQUxMT1dFRF9BVFRSO1xuICAgICAgICBVUklfU0FGRV9BVFRSSUJVVEVTID0gJ0FERF9VUklfU0FGRV9BVFRSJyBpbiBjZmcgPyBhZGRUb1NldChjbG9uZShERUZBVUxUX1VSSV9TQUZFX0FUVFJJQlVURVMpLCBjZmcuQUREX1VSSV9TQUZFX0FUVFIpIDogREVGQVVMVF9VUklfU0FGRV9BVFRSSUJVVEVTO1xuICAgICAgICBEQVRBX1VSSV9UQUdTID0gJ0FERF9EQVRBX1VSSV9UQUdTJyBpbiBjZmcgPyBhZGRUb1NldChjbG9uZShERUZBVUxUX0RBVEFfVVJJX1RBR1MpLCBjZmcuQUREX0RBVEFfVVJJX1RBR1MpIDogREVGQVVMVF9EQVRBX1VSSV9UQUdTO1xuICAgICAgICBGT1JCSURfQ09OVEVOVFMgPSAnRk9SQklEX0NPTlRFTlRTJyBpbiBjZmcgPyBhZGRUb1NldCh7fSwgY2ZnLkZPUkJJRF9DT05URU5UUykgOiBERUZBVUxUX0ZPUkJJRF9DT05URU5UUztcbiAgICAgICAgRk9SQklEX1RBR1MgPSAnRk9SQklEX1RBR1MnIGluIGNmZyA/IGFkZFRvU2V0KHt9LCBjZmcuRk9SQklEX1RBR1MpIDoge307XG4gICAgICAgIEZPUkJJRF9BVFRSID0gJ0ZPUkJJRF9BVFRSJyBpbiBjZmcgPyBhZGRUb1NldCh7fSwgY2ZnLkZPUkJJRF9BVFRSKSA6IHt9O1xuICAgICAgICBVU0VfUFJPRklMRVMgPSAnVVNFX1BST0ZJTEVTJyBpbiBjZmcgPyBjZmcuVVNFX1BST0ZJTEVTIDogZmFsc2U7XG4gICAgICAgIEFMTE9XX0FSSUFfQVRUUiA9IGNmZy5BTExPV19BUklBX0FUVFIgIT09IGZhbHNlO1xuICAgICAgICBBTExPV19EQVRBX0FUVFIgPSBjZmcuQUxMT1dfREFUQV9BVFRSICE9PSBmYWxzZTtcbiAgICAgICAgQUxMT1dfVU5LTk9XTl9QUk9UT0NPTFMgPSBjZmcuQUxMT1dfVU5LTk9XTl9QUk9UT0NPTFMgfHwgZmFsc2U7XG4gICAgICAgIFNBRkVfRk9SX1RFTVBMQVRFUyA9IGNmZy5TQUZFX0ZPUl9URU1QTEFURVMgfHwgZmFsc2U7XG4gICAgICAgIFdIT0xFX0RPQ1VNRU5UID0gY2ZnLldIT0xFX0RPQ1VNRU5UIHx8IGZhbHNlO1xuICAgICAgICBSRVRVUk5fRE9NID0gY2ZnLlJFVFVSTl9ET00gfHwgZmFsc2U7XG4gICAgICAgIFJFVFVSTl9ET01fRlJBR01FTlQgPSBjZmcuUkVUVVJOX0RPTV9GUkFHTUVOVCB8fCBmYWxzZTtcbiAgICAgICAgUkVUVVJOX1RSVVNURURfVFlQRSA9IGNmZy5SRVRVUk5fVFJVU1RFRF9UWVBFIHx8IGZhbHNlO1xuICAgICAgICBGT1JDRV9CT0RZID0gY2ZnLkZPUkNFX0JPRFkgfHwgZmFsc2U7XG4gICAgICAgIFNBTklUSVpFX0RPTSA9IGNmZy5TQU5JVElaRV9ET00gIT09IGZhbHNlO1xuICAgICAgICBLRUVQX0NPTlRFTlQgPSBjZmcuS0VFUF9DT05URU5UICE9PSBmYWxzZTtcbiAgICAgICAgSU5fUExBQ0UgPSBjZmcuSU5fUExBQ0UgfHwgZmFsc2U7XG4gICAgICAgIElTX0FMTE9XRURfVVJJJCQxID0gY2ZnLkFMTE9XRURfVVJJX1JFR0VYUCB8fCBJU19BTExPV0VEX1VSSSQkMTtcbiAgICAgICAgTkFNRVNQQUNFID0gY2ZnLk5BTUVTUEFDRSB8fCBIVE1MX05BTUVTUEFDRTtcbiAgICAgICAgaWYgKGNmZy5DVVNUT01fRUxFTUVOVF9IQU5ETElORyAmJiBpc1JlZ2V4T3JGdW5jdGlvbihjZmcuQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcudGFnTmFtZUNoZWNrKSkge1xuICAgICAgICAgIENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVjayA9IGNmZy5DVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2s7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNmZy5DVVNUT01fRUxFTUVOVF9IQU5ETElORyAmJiBpc1JlZ2V4T3JGdW5jdGlvbihjZmcuQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcuYXR0cmlidXRlTmFtZUNoZWNrKSkge1xuICAgICAgICAgIENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLmF0dHJpYnV0ZU5hbWVDaGVjayA9IGNmZy5DVVNUT01fRUxFTUVOVF9IQU5ETElORy5hdHRyaWJ1dGVOYW1lQ2hlY2s7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNmZy5DVVNUT01fRUxFTUVOVF9IQU5ETElORyAmJiB0eXBlb2YgY2ZnLkNVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLmFsbG93Q3VzdG9taXplZEJ1aWx0SW5FbGVtZW50cyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcuYWxsb3dDdXN0b21pemVkQnVpbHRJbkVsZW1lbnRzID0gY2ZnLkNVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLmFsbG93Q3VzdG9taXplZEJ1aWx0SW5FbGVtZW50cztcbiAgICAgICAgfVxuICAgICAgICBQQVJTRVJfTUVESUFfVFlQRSA9IFNVUFBPUlRFRF9QQVJTRVJfTUVESUFfVFlQRVMuaW5kZXhPZihjZmcuUEFSU0VSX01FRElBX1RZUEUpID09PSAtMSA/IFBBUlNFUl9NRURJQV9UWVBFID0gREVGQVVMVF9QQVJTRVJfTUVESUFfVFlQRSA6IFBBUlNFUl9NRURJQV9UWVBFID0gY2ZnLlBBUlNFUl9NRURJQV9UWVBFO1xuICAgICAgICB0cmFuc2Zvcm1DYXNlRnVuYyA9IFBBUlNFUl9NRURJQV9UWVBFID09PSAnYXBwbGljYXRpb24veGh0bWwreG1sJyA/IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH0gOiBzdHJpbmdUb0xvd2VyQ2FzZTtcbiAgICAgICAgaWYgKFNBRkVfRk9SX1RFTVBMQVRFUykge1xuICAgICAgICAgIEFMTE9XX0RBVEFfQVRUUiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChSRVRVUk5fRE9NX0ZSQUdNRU5UKSB7XG4gICAgICAgICAgUkVUVVJOX0RPTSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFVTRV9QUk9GSUxFUykge1xuICAgICAgICAgIEFMTE9XRURfVEFHUyA9IGFkZFRvU2V0KHt9LCBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5JDEodGV4dCkpKTtcbiAgICAgICAgICBBTExPV0VEX0FUVFIgPSBbXTtcbiAgICAgICAgICBpZiAoVVNFX1BST0ZJTEVTLmh0bWwgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGFkZFRvU2V0KEFMTE9XRURfVEFHUywgaHRtbCk7XG4gICAgICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIGh0bWwkMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChVU0VfUFJPRklMRVMuc3ZnID09PSB0cnVlKSB7XG4gICAgICAgICAgICBhZGRUb1NldChBTExPV0VEX1RBR1MsIHN2Zyk7XG4gICAgICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIHN2ZyQxKTtcbiAgICAgICAgICAgIGFkZFRvU2V0KEFMTE9XRURfQVRUUiwgeG1sKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFVTRV9QUk9GSUxFUy5zdmdGaWx0ZXJzID09PSB0cnVlKSB7XG4gICAgICAgICAgICBhZGRUb1NldChBTExPV0VEX1RBR1MsIHN2Z0ZpbHRlcnMpO1xuICAgICAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9BVFRSLCBzdmckMSk7XG4gICAgICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIHhtbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChVU0VfUFJPRklMRVMubWF0aE1sID09PSB0cnVlKSB7XG4gICAgICAgICAgICBhZGRUb1NldChBTExPV0VEX1RBR1MsIG1hdGhNbCk7XG4gICAgICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIG1hdGhNbCQxKTtcbiAgICAgICAgICAgIGFkZFRvU2V0KEFMTE9XRURfQVRUUiwgeG1sKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNmZy5BRERfVEFHUykge1xuICAgICAgICAgIGlmIChBTExPV0VEX1RBR1MgPT09IERFRkFVTFRfQUxMT1dFRF9UQUdTKSB7XG4gICAgICAgICAgICBBTExPV0VEX1RBR1MgPSBjbG9uZShBTExPV0VEX1RBR1MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhZGRUb1NldChBTExPV0VEX1RBR1MsIGNmZy5BRERfVEFHUyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNmZy5BRERfQVRUUikge1xuICAgICAgICAgIGlmIChBTExPV0VEX0FUVFIgPT09IERFRkFVTFRfQUxMT1dFRF9BVFRSKSB7XG4gICAgICAgICAgICBBTExPV0VEX0FUVFIgPSBjbG9uZShBTExPV0VEX0FUVFIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIGNmZy5BRERfQVRUUik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNmZy5BRERfVVJJX1NBRkVfQVRUUikge1xuICAgICAgICAgIGFkZFRvU2V0KFVSSV9TQUZFX0FUVFJJQlVURVMsIGNmZy5BRERfVVJJX1NBRkVfQVRUUik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNmZy5GT1JCSURfQ09OVEVOVFMpIHtcbiAgICAgICAgICBpZiAoRk9SQklEX0NPTlRFTlRTID09PSBERUZBVUxUX0ZPUkJJRF9DT05URU5UUykge1xuICAgICAgICAgICAgRk9SQklEX0NPTlRFTlRTID0gY2xvbmUoRk9SQklEX0NPTlRFTlRTKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYWRkVG9TZXQoRk9SQklEX0NPTlRFTlRTLCBjZmcuRk9SQklEX0NPTlRFTlRTKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoS0VFUF9DT05URU5UKSB7XG4gICAgICAgICAgQUxMT1dFRF9UQUdTWycjdGV4dCddID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoV0hPTEVfRE9DVU1FTlQpIHtcbiAgICAgICAgICBhZGRUb1NldChBTExPV0VEX1RBR1MsIFtcbiAgICAgICAgICAgICdodG1sJyxcbiAgICAgICAgICAgICdoZWFkJyxcbiAgICAgICAgICAgICdib2R5J1xuICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBTExPV0VEX1RBR1MudGFibGUpIHtcbiAgICAgICAgICBhZGRUb1NldChBTExPV0VEX1RBR1MsIFsndGJvZHknXSk7XG4gICAgICAgICAgZGVsZXRlIEZPUkJJRF9UQUdTLnRib2R5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChmcmVlemUpIHtcbiAgICAgICAgICBmcmVlemUoY2ZnKTtcbiAgICAgICAgfVxuICAgICAgICBDT05GSUcgPSBjZmc7XG4gICAgICB9O1xuICAgICAgdmFyIE1BVEhNTF9URVhUX0lOVEVHUkFUSU9OX1BPSU5UUyA9IGFkZFRvU2V0KHt9LCBbXG4gICAgICAgICdtaScsXG4gICAgICAgICdtbycsXG4gICAgICAgICdtbicsXG4gICAgICAgICdtcycsXG4gICAgICAgICdtdGV4dCdcbiAgICAgIF0pO1xuICAgICAgdmFyIEhUTUxfSU5URUdSQVRJT05fUE9JTlRTID0gYWRkVG9TZXQoe30sIFtcbiAgICAgICAgJ2ZvcmVpZ25vYmplY3QnLFxuICAgICAgICAnZGVzYycsXG4gICAgICAgICd0aXRsZScsXG4gICAgICAgICdhbm5vdGF0aW9uLXhtbCdcbiAgICAgIF0pO1xuICAgICAgdmFyIENPTU1PTl9TVkdfQU5EX0hUTUxfRUxFTUVOVFMgPSBhZGRUb1NldCh7fSwgW1xuICAgICAgICAndGl0bGUnLFxuICAgICAgICAnc3R5bGUnLFxuICAgICAgICAnZm9udCcsXG4gICAgICAgICdhJyxcbiAgICAgICAgJ3NjcmlwdCdcbiAgICAgIF0pO1xuICAgICAgdmFyIEFMTF9TVkdfVEFHUyA9IGFkZFRvU2V0KHt9LCBzdmcpO1xuICAgICAgYWRkVG9TZXQoQUxMX1NWR19UQUdTLCBzdmdGaWx0ZXJzKTtcbiAgICAgIGFkZFRvU2V0KEFMTF9TVkdfVEFHUywgc3ZnRGlzYWxsb3dlZCk7XG4gICAgICB2YXIgQUxMX01BVEhNTF9UQUdTID0gYWRkVG9TZXQoe30sIG1hdGhNbCk7XG4gICAgICBhZGRUb1NldChBTExfTUFUSE1MX1RBR1MsIG1hdGhNbERpc2FsbG93ZWQpO1xuICAgICAgdmFyIF9jaGVja1ZhbGlkTmFtZXNwYWNlID0gZnVuY3Rpb24gX2NoZWNrVmFsaWROYW1lc3BhY2UoZWxlbWVudCkge1xuICAgICAgICB2YXIgcGFyZW50ID0gZ2V0UGFyZW50Tm9kZShlbGVtZW50KTtcbiAgICAgICAgaWYgKCFwYXJlbnQgfHwgIXBhcmVudC50YWdOYW1lKSB7XG4gICAgICAgICAgcGFyZW50ID0ge1xuICAgICAgICAgICAgbmFtZXNwYWNlVVJJOiBIVE1MX05BTUVTUEFDRSxcbiAgICAgICAgICAgIHRhZ05hbWU6ICd0ZW1wbGF0ZSdcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciB0YWdOYW1lID0gc3RyaW5nVG9Mb3dlckNhc2UoZWxlbWVudC50YWdOYW1lKTtcbiAgICAgICAgdmFyIHBhcmVudFRhZ05hbWUgPSBzdHJpbmdUb0xvd2VyQ2FzZShwYXJlbnQudGFnTmFtZSk7XG4gICAgICAgIGlmIChlbGVtZW50Lm5hbWVzcGFjZVVSSSA9PT0gU1ZHX05BTUVTUEFDRSkge1xuICAgICAgICAgIGlmIChwYXJlbnQubmFtZXNwYWNlVVJJID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgICAgICAgICAgcmV0dXJuIHRhZ05hbWUgPT09ICdzdmcnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGFyZW50Lm5hbWVzcGFjZVVSSSA9PT0gTUFUSE1MX05BTUVTUEFDRSkge1xuICAgICAgICAgICAgcmV0dXJuIHRhZ05hbWUgPT09ICdzdmcnICYmIChwYXJlbnRUYWdOYW1lID09PSAnYW5ub3RhdGlvbi14bWwnIHx8IE1BVEhNTF9URVhUX0lOVEVHUkFUSU9OX1BPSU5UU1twYXJlbnRUYWdOYW1lXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBCb29sZWFuKEFMTF9TVkdfVEFHU1t0YWdOYW1lXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsZW1lbnQubmFtZXNwYWNlVVJJID09PSBNQVRITUxfTkFNRVNQQUNFKSB7XG4gICAgICAgICAgaWYgKHBhcmVudC5uYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICAgICAgICByZXR1cm4gdGFnTmFtZSA9PT0gJ21hdGgnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGFyZW50Lm5hbWVzcGFjZVVSSSA9PT0gU1ZHX05BTUVTUEFDRSkge1xuICAgICAgICAgICAgcmV0dXJuIHRhZ05hbWUgPT09ICdtYXRoJyAmJiBIVE1MX0lOVEVHUkFUSU9OX1BPSU5UU1twYXJlbnRUYWdOYW1lXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIEJvb2xlYW4oQUxMX01BVEhNTF9UQUdTW3RhZ05hbWVdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWxlbWVudC5uYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICAgICAgaWYgKHBhcmVudC5uYW1lc3BhY2VVUkkgPT09IFNWR19OQU1FU1BBQ0UgJiYgIUhUTUxfSU5URUdSQVRJT05fUE9JTlRTW3BhcmVudFRhZ05hbWVdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwYXJlbnQubmFtZXNwYWNlVVJJID09PSBNQVRITUxfTkFNRVNQQUNFICYmICFNQVRITUxfVEVYVF9JTlRFR1JBVElPTl9QT0lOVFNbcGFyZW50VGFnTmFtZV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuICFBTExfTUFUSE1MX1RBR1NbdGFnTmFtZV0gJiYgKENPTU1PTl9TVkdfQU5EX0hUTUxfRUxFTUVOVFNbdGFnTmFtZV0gfHwgIUFMTF9TVkdfVEFHU1t0YWdOYW1lXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICAgIHZhciBfZm9yY2VSZW1vdmUgPSBmdW5jdGlvbiBfZm9yY2VSZW1vdmUobm9kZSkge1xuICAgICAgICBhcnJheVB1c2goRE9NUHVyaWZ5LnJlbW92ZWQsIHsgZWxlbWVudDogbm9kZSB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbm9kZS5vdXRlckhUTUwgPSBlbXB0eUhUTUw7XG4gICAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB2YXIgX3JlbW92ZUF0dHJpYnV0ZSA9IGZ1bmN0aW9uIF9yZW1vdmVBdHRyaWJ1dGUobmFtZSwgbm9kZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGFycmF5UHVzaChET01QdXJpZnkucmVtb3ZlZCwge1xuICAgICAgICAgICAgYXR0cmlidXRlOiBub2RlLmdldEF0dHJpYnV0ZU5vZGUobmFtZSksXG4gICAgICAgICAgICBmcm9tOiBub2RlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICBhcnJheVB1c2goRE9NUHVyaWZ5LnJlbW92ZWQsIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZTogbnVsbCxcbiAgICAgICAgICAgIGZyb206IG5vZGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgaWYgKG5hbWUgPT09ICdpcycgJiYgIUFMTE9XRURfQVRUUltuYW1lXSkge1xuICAgICAgICAgIGlmIChSRVRVUk5fRE9NIHx8IFJFVFVSTl9ET01fRlJBR01FTlQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIF9mb3JjZVJlbW92ZShub2RlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgJycpO1xuICAgICAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHZhciBfaW5pdERvY3VtZW50ID0gZnVuY3Rpb24gX2luaXREb2N1bWVudChkaXJ0eSkge1xuICAgICAgICB2YXIgZG9jID0gdm9pZCAwO1xuICAgICAgICB2YXIgbGVhZGluZ1doaXRlc3BhY2UgPSB2b2lkIDA7XG4gICAgICAgIGlmIChGT1JDRV9CT0RZKSB7XG4gICAgICAgICAgZGlydHkgPSAnPHJlbW92ZT48L3JlbW92ZT4nICsgZGlydHk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG1hdGNoZXMgPSBzdHJpbmdNYXRjaChkaXJ0eSwgL15bXFxyXFxuXFx0IF0rLyk7XG4gICAgICAgICAgbGVhZGluZ1doaXRlc3BhY2UgPSBtYXRjaGVzICYmIG1hdGNoZXNbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFBBUlNFUl9NRURJQV9UWVBFID09PSAnYXBwbGljYXRpb24veGh0bWwreG1sJykge1xuICAgICAgICAgIGRpcnR5ID0gJzxodG1sIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiPjxoZWFkPjwvaGVhZD48Ym9keT4nICsgZGlydHkgKyAnPC9ib2R5PjwvaHRtbD4nO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkaXJ0eVBheWxvYWQgPSB0cnVzdGVkVHlwZXNQb2xpY3kgPyB0cnVzdGVkVHlwZXNQb2xpY3kuY3JlYXRlSFRNTChkaXJ0eSkgOiBkaXJ0eTtcbiAgICAgICAgaWYgKE5BTUVTUEFDRSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZG9jID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhkaXJ0eVBheWxvYWQsIFBBUlNFUl9NRURJQV9UWVBFKTtcbiAgICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZG9jIHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICAgICAgZG9jID0gaW1wbGVtZW50YXRpb24uY3JlYXRlRG9jdW1lbnQoTkFNRVNQQUNFLCAndGVtcGxhdGUnLCBudWxsKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZG9jLmRvY3VtZW50RWxlbWVudC5pbm5lckhUTUwgPSBJU19FTVBUWV9JTlBVVCA/ICcnIDogZGlydHlQYXlsb2FkO1xuICAgICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJvZHkgPSBkb2MuYm9keSB8fCBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICBpZiAoZGlydHkgJiYgbGVhZGluZ1doaXRlc3BhY2UpIHtcbiAgICAgICAgICBib2R5Lmluc2VydEJlZm9yZShkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsZWFkaW5nV2hpdGVzcGFjZSksIGJvZHkuY2hpbGROb2Rlc1swXSB8fCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTkFNRVNQQUNFID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgICAgICAgIHJldHVybiBnZXRFbGVtZW50c0J5VGFnTmFtZS5jYWxsKGRvYywgV0hPTEVfRE9DVU1FTlQgPyAnaHRtbCcgOiAnYm9keScpWzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBXSE9MRV9ET0NVTUVOVCA/IGRvYy5kb2N1bWVudEVsZW1lbnQgOiBib2R5O1xuICAgICAgfTtcbiAgICAgIHZhciBfY3JlYXRlSXRlcmF0b3IgPSBmdW5jdGlvbiBfY3JlYXRlSXRlcmF0b3Iocm9vdCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTm9kZUl0ZXJhdG9yLmNhbGwocm9vdC5vd25lckRvY3VtZW50IHx8IHJvb3QsIHJvb3QsIE5vZGVGaWx0ZXIuU0hPV19FTEVNRU5UIHwgTm9kZUZpbHRlci5TSE9XX0NPTU1FTlQgfCBOb2RlRmlsdGVyLlNIT1dfVEVYVCwgbnVsbCwgZmFsc2UpO1xuICAgICAgfTtcbiAgICAgIHZhciBfaXNDbG9iYmVyZWQgPSBmdW5jdGlvbiBfaXNDbG9iYmVyZWQoZWxtKSB7XG4gICAgICAgIHJldHVybiBlbG0gaW5zdGFuY2VvZiBIVE1MRm9ybUVsZW1lbnQgJiYgKHR5cGVvZiBlbG0ubm9kZU5hbWUgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBlbG0udGV4dENvbnRlbnQgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBlbG0ucmVtb3ZlQ2hpbGQgIT09ICdmdW5jdGlvbicgfHwgIShlbG0uYXR0cmlidXRlcyBpbnN0YW5jZW9mIE5hbWVkTm9kZU1hcCkgfHwgdHlwZW9mIGVsbS5yZW1vdmVBdHRyaWJ1dGUgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGVsbS5zZXRBdHRyaWJ1dGUgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGVsbS5uYW1lc3BhY2VVUkkgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBlbG0uaW5zZXJ0QmVmb3JlICE9PSAnZnVuY3Rpb24nKTtcbiAgICAgIH07XG4gICAgICB2YXIgX2lzTm9kZSA9IGZ1bmN0aW9uIF9pc05vZGUob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiAodHlwZW9mIE5vZGUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKE5vZGUpKSA9PT0gJ29iamVjdCcgPyBvYmplY3QgaW5zdGFuY2VvZiBOb2RlIDogb2JqZWN0ICYmICh0eXBlb2Ygb2JqZWN0ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihvYmplY3QpKSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iamVjdC5ub2RlVHlwZSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIG9iamVjdC5ub2RlTmFtZSA9PT0gJ3N0cmluZyc7XG4gICAgICB9O1xuICAgICAgdmFyIF9leGVjdXRlSG9vayA9IGZ1bmN0aW9uIF9leGVjdXRlSG9vayhlbnRyeVBvaW50LCBjdXJyZW50Tm9kZSwgZGF0YSkge1xuICAgICAgICBpZiAoIWhvb2tzW2VudHJ5UG9pbnRdKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGFycmF5Rm9yRWFjaChob29rc1tlbnRyeVBvaW50XSwgZnVuY3Rpb24gKGhvb2spIHtcbiAgICAgICAgICBob29rLmNhbGwoRE9NUHVyaWZ5LCBjdXJyZW50Tm9kZSwgZGF0YSwgQ09ORklHKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgdmFyIF9zYW5pdGl6ZUVsZW1lbnRzID0gZnVuY3Rpb24gX3Nhbml0aXplRWxlbWVudHMoY3VycmVudE5vZGUpIHtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSB2b2lkIDA7XG4gICAgICAgIF9leGVjdXRlSG9vaygnYmVmb3JlU2FuaXRpemVFbGVtZW50cycsIGN1cnJlbnROb2RlLCBudWxsKTtcbiAgICAgICAgaWYgKF9pc0Nsb2JiZXJlZChjdXJyZW50Tm9kZSkpIHtcbiAgICAgICAgICBfZm9yY2VSZW1vdmUoY3VycmVudE5vZGUpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWdFeHBUZXN0KC9bXFx1MDA4MC1cXHVGRkZGXS8sIGN1cnJlbnROb2RlLm5vZGVOYW1lKSkge1xuICAgICAgICAgIF9mb3JjZVJlbW92ZShjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRhZ05hbWUgPSB0cmFuc2Zvcm1DYXNlRnVuYyhjdXJyZW50Tm9kZS5ub2RlTmFtZSk7XG4gICAgICAgIF9leGVjdXRlSG9vaygndXBvblNhbml0aXplRWxlbWVudCcsIGN1cnJlbnROb2RlLCB7XG4gICAgICAgICAgdGFnTmFtZTogdGFnTmFtZSxcbiAgICAgICAgICBhbGxvd2VkVGFnczogQUxMT1dFRF9UQUdTXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY3VycmVudE5vZGUuaGFzQ2hpbGROb2RlcygpICYmICFfaXNOb2RlKGN1cnJlbnROb2RlLmZpcnN0RWxlbWVudENoaWxkKSAmJiAoIV9pc05vZGUoY3VycmVudE5vZGUuY29udGVudCkgfHwgIV9pc05vZGUoY3VycmVudE5vZGUuY29udGVudC5maXJzdEVsZW1lbnRDaGlsZCkpICYmIHJlZ0V4cFRlc3QoLzxbL1xcd10vZywgY3VycmVudE5vZGUuaW5uZXJIVE1MKSAmJiByZWdFeHBUZXN0KC88Wy9cXHddL2csIGN1cnJlbnROb2RlLnRleHRDb250ZW50KSkge1xuICAgICAgICAgIF9mb3JjZVJlbW92ZShjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhZ05hbWUgPT09ICdzZWxlY3QnICYmIHJlZ0V4cFRlc3QoLzx0ZW1wbGF0ZS9pLCBjdXJyZW50Tm9kZS5pbm5lckhUTUwpKSB7XG4gICAgICAgICAgX2ZvcmNlUmVtb3ZlKGN1cnJlbnROb2RlKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUFMTE9XRURfVEFHU1t0YWdOYW1lXSB8fCBGT1JCSURfVEFHU1t0YWdOYW1lXSkge1xuICAgICAgICAgIGlmICghRk9SQklEX1RBR1NbdGFnTmFtZV0gJiYgX2Jhc2ljQ3VzdG9tRWxlbWVudFRlc3QodGFnTmFtZSkpIHtcbiAgICAgICAgICAgIGlmIChDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2sgaW5zdGFuY2VvZiBSZWdFeHAgJiYgcmVnRXhwVGVzdChDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2ssIHRhZ05hbWUpKVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcudGFnTmFtZUNoZWNrIGluc3RhbmNlb2YgRnVuY3Rpb24gJiYgQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcudGFnTmFtZUNoZWNrKHRhZ05hbWUpKVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChLRUVQX0NPTlRFTlQgJiYgIUZPUkJJRF9DT05URU5UU1t0YWdOYW1lXSkge1xuICAgICAgICAgICAgdmFyIHBhcmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGN1cnJlbnROb2RlKSB8fCBjdXJyZW50Tm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgdmFyIGNoaWxkTm9kZXMgPSBnZXRDaGlsZE5vZGVzKGN1cnJlbnROb2RlKSB8fCBjdXJyZW50Tm9kZS5jaGlsZE5vZGVzO1xuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZXMgJiYgcGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICB2YXIgY2hpbGRDb3VudCA9IGNoaWxkTm9kZXMubGVuZ3RoO1xuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gY2hpbGRDb3VudCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY2xvbmVOb2RlKGNoaWxkTm9kZXNbaV0sIHRydWUpLCBnZXROZXh0U2libGluZyhjdXJyZW50Tm9kZSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIF9mb3JjZVJlbW92ZShjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnROb2RlIGluc3RhbmNlb2YgRWxlbWVudCAmJiAhX2NoZWNrVmFsaWROYW1lc3BhY2UoY3VycmVudE5vZGUpKSB7XG4gICAgICAgICAgX2ZvcmNlUmVtb3ZlKGN1cnJlbnROb2RlKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHRhZ05hbWUgPT09ICdub3NjcmlwdCcgfHwgdGFnTmFtZSA9PT0gJ25vZW1iZWQnKSAmJiByZWdFeHBUZXN0KC88XFwvbm8oc2NyaXB0fGVtYmVkKS9pLCBjdXJyZW50Tm9kZS5pbm5lckhUTUwpKSB7XG4gICAgICAgICAgX2ZvcmNlUmVtb3ZlKGN1cnJlbnROb2RlKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoU0FGRV9GT1JfVEVNUExBVEVTICYmIGN1cnJlbnROb2RlLm5vZGVUeXBlID09PSAzKSB7XG4gICAgICAgICAgY29udGVudCA9IGN1cnJlbnROb2RlLnRleHRDb250ZW50O1xuICAgICAgICAgIGNvbnRlbnQgPSBzdHJpbmdSZXBsYWNlKGNvbnRlbnQsIE1VU1RBQ0hFX0VYUFIkJDEsICcgJyk7XG4gICAgICAgICAgY29udGVudCA9IHN0cmluZ1JlcGxhY2UoY29udGVudCwgRVJCX0VYUFIkJDEsICcgJyk7XG4gICAgICAgICAgaWYgKGN1cnJlbnROb2RlLnRleHRDb250ZW50ICE9PSBjb250ZW50KSB7XG4gICAgICAgICAgICBhcnJheVB1c2goRE9NUHVyaWZ5LnJlbW92ZWQsIHsgZWxlbWVudDogY3VycmVudE5vZGUuY2xvbmVOb2RlKCkgfSk7XG4gICAgICAgICAgICBjdXJyZW50Tm9kZS50ZXh0Q29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF9leGVjdXRlSG9vaygnYWZ0ZXJTYW5pdGl6ZUVsZW1lbnRzJywgY3VycmVudE5vZGUsIG51bGwpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuICAgICAgdmFyIF9pc1ZhbGlkQXR0cmlidXRlID0gZnVuY3Rpb24gX2lzVmFsaWRBdHRyaWJ1dGUobGNUYWcsIGxjTmFtZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKFNBTklUSVpFX0RPTSAmJiAobGNOYW1lID09PSAnaWQnIHx8IGxjTmFtZSA9PT0gJ25hbWUnKSAmJiAodmFsdWUgaW4gZG9jdW1lbnQgfHwgdmFsdWUgaW4gZm9ybUVsZW1lbnQpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBTExPV19EQVRBX0FUVFIgJiYgIUZPUkJJRF9BVFRSW2xjTmFtZV0gJiYgcmVnRXhwVGVzdChEQVRBX0FUVFIkJDEsIGxjTmFtZSkpO1xuICAgICAgICBlbHNlIGlmIChBTExPV19BUklBX0FUVFIgJiYgcmVnRXhwVGVzdChBUklBX0FUVFIkJDEsIGxjTmFtZSkpO1xuICAgICAgICBlbHNlIGlmICghQUxMT1dFRF9BVFRSW2xjTmFtZV0gfHwgRk9SQklEX0FUVFJbbGNOYW1lXSkge1xuICAgICAgICAgIGlmIChfYmFzaWNDdXN0b21FbGVtZW50VGVzdChsY1RhZykgJiYgKENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVjayBpbnN0YW5jZW9mIFJlZ0V4cCAmJiByZWdFeHBUZXN0KENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVjaywgbGNUYWcpIHx8IENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVjayBpbnN0YW5jZW9mIEZ1bmN0aW9uICYmIENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVjayhsY1RhZykpICYmIChDVVNUT01fRUxFTUVOVF9IQU5ETElORy5hdHRyaWJ1dGVOYW1lQ2hlY2sgaW5zdGFuY2VvZiBSZWdFeHAgJiYgcmVnRXhwVGVzdChDVVNUT01fRUxFTUVOVF9IQU5ETElORy5hdHRyaWJ1dGVOYW1lQ2hlY2ssIGxjTmFtZSkgfHwgQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcuYXR0cmlidXRlTmFtZUNoZWNrIGluc3RhbmNlb2YgRnVuY3Rpb24gJiYgQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcuYXR0cmlidXRlTmFtZUNoZWNrKGxjTmFtZSkpIHx8IGxjTmFtZSA9PT0gJ2lzJyAmJiBDVVNUT01fRUxFTUVOVF9IQU5ETElORy5hbGxvd0N1c3RvbWl6ZWRCdWlsdEluRWxlbWVudHMgJiYgKENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVjayBpbnN0YW5jZW9mIFJlZ0V4cCAmJiByZWdFeHBUZXN0KENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVjaywgdmFsdWUpIHx8IENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVjayBpbnN0YW5jZW9mIEZ1bmN0aW9uICYmIENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVjayh2YWx1ZSkpKTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoVVJJX1NBRkVfQVRUUklCVVRFU1tsY05hbWVdKTtcbiAgICAgICAgZWxzZSBpZiAocmVnRXhwVGVzdChJU19BTExPV0VEX1VSSSQkMSwgc3RyaW5nUmVwbGFjZSh2YWx1ZSwgQVRUUl9XSElURVNQQUNFJCQxLCAnJykpKTtcbiAgICAgICAgZWxzZSBpZiAoKGxjTmFtZSA9PT0gJ3NyYycgfHwgbGNOYW1lID09PSAneGxpbms6aHJlZicgfHwgbGNOYW1lID09PSAnaHJlZicpICYmIGxjVGFnICE9PSAnc2NyaXB0JyAmJiBzdHJpbmdJbmRleE9mKHZhbHVlLCAnZGF0YTonKSA9PT0gMCAmJiBEQVRBX1VSSV9UQUdTW2xjVGFnXSk7XG4gICAgICAgIGVsc2UgaWYgKEFMTE9XX1VOS05PV05fUFJPVE9DT0xTICYmICFyZWdFeHBUZXN0KElTX1NDUklQVF9PUl9EQVRBJCQxLCBzdHJpbmdSZXBsYWNlKHZhbHVlLCBBVFRSX1dISVRFU1BBQ0UkJDEsICcnKSkpO1xuICAgICAgICBlbHNlIGlmICghdmFsdWUpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuICAgICAgdmFyIF9iYXNpY0N1c3RvbUVsZW1lbnRUZXN0ID0gZnVuY3Rpb24gX2Jhc2ljQ3VzdG9tRWxlbWVudFRlc3QodGFnTmFtZSkge1xuICAgICAgICByZXR1cm4gdGFnTmFtZS5pbmRleE9mKCctJykgPiAwO1xuICAgICAgfTtcbiAgICAgIHZhciBfc2FuaXRpemVBdHRyaWJ1dGVzID0gZnVuY3Rpb24gX3Nhbml0aXplQXR0cmlidXRlcyhjdXJyZW50Tm9kZSkge1xuICAgICAgICB2YXIgYXR0ciA9IHZvaWQgMDtcbiAgICAgICAgdmFyIHZhbHVlID0gdm9pZCAwO1xuICAgICAgICB2YXIgbGNOYW1lID0gdm9pZCAwO1xuICAgICAgICB2YXIgbCA9IHZvaWQgMDtcbiAgICAgICAgX2V4ZWN1dGVIb29rKCdiZWZvcmVTYW5pdGl6ZUF0dHJpYnV0ZXMnLCBjdXJyZW50Tm9kZSwgbnVsbCk7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gY3VycmVudE5vZGUuYXR0cmlidXRlcztcbiAgICAgICAgaWYgKCFhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBob29rRXZlbnQgPSB7XG4gICAgICAgICAgYXR0ck5hbWU6ICcnLFxuICAgICAgICAgIGF0dHJWYWx1ZTogJycsXG4gICAgICAgICAga2VlcEF0dHI6IHRydWUsXG4gICAgICAgICAgYWxsb3dlZEF0dHJpYnV0ZXM6IEFMTE9XRURfQVRUUlxuICAgICAgICB9O1xuICAgICAgICBsID0gYXR0cmlidXRlcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChsLS0pIHtcbiAgICAgICAgICBhdHRyID0gYXR0cmlidXRlc1tsXTtcbiAgICAgICAgICB2YXIgX2F0dHIgPSBhdHRyLCBuYW1lID0gX2F0dHIubmFtZSwgbmFtZXNwYWNlVVJJID0gX2F0dHIubmFtZXNwYWNlVVJJO1xuICAgICAgICAgIHZhbHVlID0gc3RyaW5nVHJpbShhdHRyLnZhbHVlKTtcbiAgICAgICAgICBsY05hbWUgPSB0cmFuc2Zvcm1DYXNlRnVuYyhuYW1lKTtcbiAgICAgICAgICB2YXIgaW5pdFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgaG9va0V2ZW50LmF0dHJOYW1lID0gbGNOYW1lO1xuICAgICAgICAgIGhvb2tFdmVudC5hdHRyVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICBob29rRXZlbnQua2VlcEF0dHIgPSB0cnVlO1xuICAgICAgICAgIGhvb2tFdmVudC5mb3JjZUtlZXBBdHRyID0gdW5kZWZpbmVkO1xuICAgICAgICAgIF9leGVjdXRlSG9vaygndXBvblNhbml0aXplQXR0cmlidXRlJywgY3VycmVudE5vZGUsIGhvb2tFdmVudCk7XG4gICAgICAgICAgdmFsdWUgPSBob29rRXZlbnQuYXR0clZhbHVlO1xuICAgICAgICAgIGlmIChob29rRXZlbnQuZm9yY2VLZWVwQXR0cikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaG9va0V2ZW50LmtlZXBBdHRyKSB7XG4gICAgICAgICAgICBfcmVtb3ZlQXR0cmlidXRlKG5hbWUsIGN1cnJlbnROb2RlKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVnRXhwVGVzdCgvXFwvPi9pLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgIF9yZW1vdmVBdHRyaWJ1dGUobmFtZSwgY3VycmVudE5vZGUpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChTQUZFX0ZPUl9URU1QTEFURVMpIHtcbiAgICAgICAgICAgIHZhbHVlID0gc3RyaW5nUmVwbGFjZSh2YWx1ZSwgTVVTVEFDSEVfRVhQUiQkMSwgJyAnKTtcbiAgICAgICAgICAgIHZhbHVlID0gc3RyaW5nUmVwbGFjZSh2YWx1ZSwgRVJCX0VYUFIkJDEsICcgJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBsY1RhZyA9IHRyYW5zZm9ybUNhc2VGdW5jKGN1cnJlbnROb2RlLm5vZGVOYW1lKTtcbiAgICAgICAgICBpZiAoIV9pc1ZhbGlkQXR0cmlidXRlKGxjVGFnLCBsY05hbWUsIHZhbHVlKSkge1xuICAgICAgICAgICAgX3JlbW92ZUF0dHJpYnV0ZShuYW1lLCBjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlICE9PSBpbml0VmFsdWUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmIChuYW1lc3BhY2VVUkkpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5zZXRBdHRyaWJ1dGVOUyhuYW1lc3BhY2VVUkksIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgICAgIF9yZW1vdmVBdHRyaWJ1dGUobmFtZSwgY3VycmVudE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBfZXhlY3V0ZUhvb2soJ2FmdGVyU2FuaXRpemVBdHRyaWJ1dGVzJywgY3VycmVudE5vZGUsIG51bGwpO1xuICAgICAgfTtcbiAgICAgIHZhciBfc2FuaXRpemVTaGFkb3dET00gPSBmdW5jdGlvbiBfc2FuaXRpemVTaGFkb3dET00oZnJhZ21lbnQpIHtcbiAgICAgICAgdmFyIHNoYWRvd05vZGUgPSB2b2lkIDA7XG4gICAgICAgIHZhciBzaGFkb3dJdGVyYXRvciA9IF9jcmVhdGVJdGVyYXRvcihmcmFnbWVudCk7XG4gICAgICAgIF9leGVjdXRlSG9vaygnYmVmb3JlU2FuaXRpemVTaGFkb3dET00nLCBmcmFnbWVudCwgbnVsbCk7XG4gICAgICAgIHdoaWxlIChzaGFkb3dOb2RlID0gc2hhZG93SXRlcmF0b3IubmV4dE5vZGUoKSkge1xuICAgICAgICAgIF9leGVjdXRlSG9vaygndXBvblNhbml0aXplU2hhZG93Tm9kZScsIHNoYWRvd05vZGUsIG51bGwpO1xuICAgICAgICAgIGlmIChfc2FuaXRpemVFbGVtZW50cyhzaGFkb3dOb2RlKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzaGFkb3dOb2RlLmNvbnRlbnQgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50KSB7XG4gICAgICAgICAgICBfc2FuaXRpemVTaGFkb3dET00oc2hhZG93Tm9kZS5jb250ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX3Nhbml0aXplQXR0cmlidXRlcyhzaGFkb3dOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBfZXhlY3V0ZUhvb2soJ2FmdGVyU2FuaXRpemVTaGFkb3dET00nLCBmcmFnbWVudCwgbnVsbCk7XG4gICAgICB9O1xuICAgICAgRE9NUHVyaWZ5LnNhbml0aXplID0gZnVuY3Rpb24gKGRpcnR5LCBjZmcpIHtcbiAgICAgICAgdmFyIGJvZHkgPSB2b2lkIDA7XG4gICAgICAgIHZhciBpbXBvcnRlZE5vZGUgPSB2b2lkIDA7XG4gICAgICAgIHZhciBjdXJyZW50Tm9kZSA9IHZvaWQgMDtcbiAgICAgICAgdmFyIG9sZE5vZGUgPSB2b2lkIDA7XG4gICAgICAgIHZhciByZXR1cm5Ob2RlID0gdm9pZCAwO1xuICAgICAgICBJU19FTVBUWV9JTlBVVCA9ICFkaXJ0eTtcbiAgICAgICAgaWYgKElTX0VNUFRZX0lOUFVUKSB7XG4gICAgICAgICAgZGlydHkgPSAnPCEtLT4nO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZGlydHkgIT09ICdzdHJpbmcnICYmICFfaXNOb2RlKGRpcnR5KSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgZGlydHkudG9TdHJpbmcgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IHR5cGVFcnJvckNyZWF0ZSgndG9TdHJpbmcgaXMgbm90IGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGlydHkgPSBkaXJ0eS50b1N0cmluZygpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkaXJ0eSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgdGhyb3cgdHlwZUVycm9yQ3JlYXRlKCdkaXJ0eSBpcyBub3QgYSBzdHJpbmcsIGFib3J0aW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghRE9NUHVyaWZ5LmlzU3VwcG9ydGVkKSB7XG4gICAgICAgICAgaWYgKF90eXBlb2Yod2luZG93LnRvU3RhdGljSFRNTCkgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB3aW5kb3cudG9TdGF0aWNIVE1MID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRpcnR5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICByZXR1cm4gd2luZG93LnRvU3RhdGljSFRNTChkaXJ0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX2lzTm9kZShkaXJ0eSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy50b1N0YXRpY0hUTUwoZGlydHkub3V0ZXJIVE1MKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGRpcnR5O1xuICAgICAgICB9XG4gICAgICAgIGlmICghU0VUX0NPTkZJRykge1xuICAgICAgICAgIF9wYXJzZUNvbmZpZyhjZmcpO1xuICAgICAgICB9XG4gICAgICAgIERPTVB1cmlmeS5yZW1vdmVkID0gW107XG4gICAgICAgIGlmICh0eXBlb2YgZGlydHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgSU5fUExBQ0UgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSU5fUExBQ0UpIHtcbiAgICAgICAgICBpZiAoZGlydHkubm9kZU5hbWUpIHtcbiAgICAgICAgICAgIHZhciB0YWdOYW1lID0gdHJhbnNmb3JtQ2FzZUZ1bmMoZGlydHkubm9kZU5hbWUpO1xuICAgICAgICAgICAgaWYgKCFBTExPV0VEX1RBR1NbdGFnTmFtZV0gfHwgRk9SQklEX1RBR1NbdGFnTmFtZV0pIHtcbiAgICAgICAgICAgICAgdGhyb3cgdHlwZUVycm9yQ3JlYXRlKCdyb290IG5vZGUgaXMgZm9yYmlkZGVuIGFuZCBjYW5ub3QgYmUgc2FuaXRpemVkIGluLXBsYWNlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGRpcnR5IGluc3RhbmNlb2YgTm9kZSkge1xuICAgICAgICAgIGJvZHkgPSBfaW5pdERvY3VtZW50KCc8IS0tLS0+Jyk7XG4gICAgICAgICAgaW1wb3J0ZWROb2RlID0gYm9keS5vd25lckRvY3VtZW50LmltcG9ydE5vZGUoZGlydHksIHRydWUpO1xuICAgICAgICAgIGlmIChpbXBvcnRlZE5vZGUubm9kZVR5cGUgPT09IDEgJiYgaW1wb3J0ZWROb2RlLm5vZGVOYW1lID09PSAnQk9EWScpIHtcbiAgICAgICAgICAgIGJvZHkgPSBpbXBvcnRlZE5vZGU7XG4gICAgICAgICAgfSBlbHNlIGlmIChpbXBvcnRlZE5vZGUubm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgICAgICAgICAgYm9keSA9IGltcG9ydGVkTm9kZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYm9keS5hcHBlbmRDaGlsZChpbXBvcnRlZE5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIVJFVFVSTl9ET00gJiYgIVNBRkVfRk9SX1RFTVBMQVRFUyAmJiAhV0hPTEVfRE9DVU1FTlQgJiYgZGlydHkuaW5kZXhPZignPCcpID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydXN0ZWRUeXBlc1BvbGljeSAmJiBSRVRVUk5fVFJVU1RFRF9UWVBFID8gdHJ1c3RlZFR5cGVzUG9saWN5LmNyZWF0ZUhUTUwoZGlydHkpIDogZGlydHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJvZHkgPSBfaW5pdERvY3VtZW50KGRpcnR5KTtcbiAgICAgICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgICAgIHJldHVybiBSRVRVUk5fRE9NID8gbnVsbCA6IFJFVFVSTl9UUlVTVEVEX1RZUEUgPyBlbXB0eUhUTUwgOiAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJvZHkgJiYgRk9SQ0VfQk9EWSkge1xuICAgICAgICAgIF9mb3JjZVJlbW92ZShib2R5LmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBub2RlSXRlcmF0b3IgPSBfY3JlYXRlSXRlcmF0b3IoSU5fUExBQ0UgPyBkaXJ0eSA6IGJvZHkpO1xuICAgICAgICB3aGlsZSAoY3VycmVudE5vZGUgPSBub2RlSXRlcmF0b3IubmV4dE5vZGUoKSkge1xuICAgICAgICAgIGlmIChjdXJyZW50Tm9kZS5ub2RlVHlwZSA9PT0gMyAmJiBjdXJyZW50Tm9kZSA9PT0gb2xkTm9kZSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChfc2FuaXRpemVFbGVtZW50cyhjdXJyZW50Tm9kZSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY3VycmVudE5vZGUuY29udGVudCBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpIHtcbiAgICAgICAgICAgIF9zYW5pdGl6ZVNoYWRvd0RPTShjdXJyZW50Tm9kZS5jb250ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX3Nhbml0aXplQXR0cmlidXRlcyhjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgb2xkTm9kZSA9IGN1cnJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIG9sZE5vZGUgPSBudWxsO1xuICAgICAgICBpZiAoSU5fUExBQ0UpIHtcbiAgICAgICAgICByZXR1cm4gZGlydHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFJFVFVSTl9ET00pIHtcbiAgICAgICAgICBpZiAoUkVUVVJOX0RPTV9GUkFHTUVOVCkge1xuICAgICAgICAgICAgcmV0dXJuTm9kZSA9IGNyZWF0ZURvY3VtZW50RnJhZ21lbnQuY2FsbChib2R5Lm93bmVyRG9jdW1lbnQpO1xuICAgICAgICAgICAgd2hpbGUgKGJvZHkuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICByZXR1cm5Ob2RlLmFwcGVuZENoaWxkKGJvZHkuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybk5vZGUgPSBib2R5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoQUxMT1dFRF9BVFRSLnNoYWRvd3Jvb3QpIHtcbiAgICAgICAgICAgIHJldHVybk5vZGUgPSBpbXBvcnROb2RlLmNhbGwob3JpZ2luYWxEb2N1bWVudCwgcmV0dXJuTm9kZSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXR1cm5Ob2RlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZXJpYWxpemVkSFRNTCA9IFdIT0xFX0RPQ1VNRU5UID8gYm9keS5vdXRlckhUTUwgOiBib2R5LmlubmVySFRNTDtcbiAgICAgICAgaWYgKFdIT0xFX0RPQ1VNRU5UICYmIEFMTE9XRURfVEFHU1snIWRvY3R5cGUnXSAmJiBib2R5Lm93bmVyRG9jdW1lbnQgJiYgYm9keS5vd25lckRvY3VtZW50LmRvY3R5cGUgJiYgYm9keS5vd25lckRvY3VtZW50LmRvY3R5cGUubmFtZSAmJiByZWdFeHBUZXN0KERPQ1RZUEVfTkFNRSwgYm9keS5vd25lckRvY3VtZW50LmRvY3R5cGUubmFtZSkpIHtcbiAgICAgICAgICBzZXJpYWxpemVkSFRNTCA9ICc8IURPQ1RZUEUgJyArIGJvZHkub3duZXJEb2N1bWVudC5kb2N0eXBlLm5hbWUgKyAnPlxcbicgKyBzZXJpYWxpemVkSFRNTDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoU0FGRV9GT1JfVEVNUExBVEVTKSB7XG4gICAgICAgICAgc2VyaWFsaXplZEhUTUwgPSBzdHJpbmdSZXBsYWNlKHNlcmlhbGl6ZWRIVE1MLCBNVVNUQUNIRV9FWFBSJCQxLCAnICcpO1xuICAgICAgICAgIHNlcmlhbGl6ZWRIVE1MID0gc3RyaW5nUmVwbGFjZShzZXJpYWxpemVkSFRNTCwgRVJCX0VYUFIkJDEsICcgJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydXN0ZWRUeXBlc1BvbGljeSAmJiBSRVRVUk5fVFJVU1RFRF9UWVBFID8gdHJ1c3RlZFR5cGVzUG9saWN5LmNyZWF0ZUhUTUwoc2VyaWFsaXplZEhUTUwpIDogc2VyaWFsaXplZEhUTUw7XG4gICAgICB9O1xuICAgICAgRE9NUHVyaWZ5LnNldENvbmZpZyA9IGZ1bmN0aW9uIChjZmcpIHtcbiAgICAgICAgX3BhcnNlQ29uZmlnKGNmZyk7XG4gICAgICAgIFNFVF9DT05GSUcgPSB0cnVlO1xuICAgICAgfTtcbiAgICAgIERPTVB1cmlmeS5jbGVhckNvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgQ09ORklHID0gbnVsbDtcbiAgICAgICAgU0VUX0NPTkZJRyA9IGZhbHNlO1xuICAgICAgfTtcbiAgICAgIERPTVB1cmlmeS5pc1ZhbGlkQXR0cmlidXRlID0gZnVuY3Rpb24gKHRhZywgYXR0ciwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCFDT05GSUcpIHtcbiAgICAgICAgICBfcGFyc2VDb25maWcoe30pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsY1RhZyA9IHRyYW5zZm9ybUNhc2VGdW5jKHRhZyk7XG4gICAgICAgIHZhciBsY05hbWUgPSB0cmFuc2Zvcm1DYXNlRnVuYyhhdHRyKTtcbiAgICAgICAgcmV0dXJuIF9pc1ZhbGlkQXR0cmlidXRlKGxjVGFnLCBsY05hbWUsIHZhbHVlKTtcbiAgICAgIH07XG4gICAgICBET01QdXJpZnkuYWRkSG9vayA9IGZ1bmN0aW9uIChlbnRyeVBvaW50LCBob29rRnVuY3Rpb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBob29rRnVuY3Rpb24gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaG9va3NbZW50cnlQb2ludF0gPSBob29rc1tlbnRyeVBvaW50XSB8fCBbXTtcbiAgICAgICAgYXJyYXlQdXNoKGhvb2tzW2VudHJ5UG9pbnRdLCBob29rRnVuY3Rpb24pO1xuICAgICAgfTtcbiAgICAgIERPTVB1cmlmeS5yZW1vdmVIb29rID0gZnVuY3Rpb24gKGVudHJ5UG9pbnQpIHtcbiAgICAgICAgaWYgKGhvb2tzW2VudHJ5UG9pbnRdKSB7XG4gICAgICAgICAgYXJyYXlQb3AoaG9va3NbZW50cnlQb2ludF0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgRE9NUHVyaWZ5LnJlbW92ZUhvb2tzID0gZnVuY3Rpb24gKGVudHJ5UG9pbnQpIHtcbiAgICAgICAgaWYgKGhvb2tzW2VudHJ5UG9pbnRdKSB7XG4gICAgICAgICAgaG9va3NbZW50cnlQb2ludF0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIERPTVB1cmlmeS5yZW1vdmVBbGxIb29rcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaG9va3MgPSB7fTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gRE9NUHVyaWZ5O1xuICAgIH1cbiAgICB2YXIgcHVyaWZ5ID0gY3JlYXRlRE9NUHVyaWZ5KCk7XG5cbiAgICBjb25zdCByZW1vdmVBdHRycyA9IChub2RlLCBuYW1lcykgPT4ge1xuICAgICAgZWFjaCRnKG5hbWVzLCBuYW1lID0+IHtcbiAgICAgICAgbm9kZS5hdHRyKG5hbWUsIG51bGwpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBhZGRGb250VG9TcGFuc0ZpbHRlciA9IChkb21QYXJzZXIsIHN0eWxlcywgZm9udFNpemVzKSA9PiB7XG4gICAgICBkb21QYXJzZXIuYWRkTm9kZUZpbHRlcignZm9udCcsIG5vZGVzID0+IHtcbiAgICAgICAgZWFjaCRnKG5vZGVzLCBub2RlID0+IHtcbiAgICAgICAgICBjb25zdCBwcm9wcyA9IHN0eWxlcy5wYXJzZShub2RlLmF0dHIoJ3N0eWxlJykpO1xuICAgICAgICAgIGNvbnN0IGNvbG9yID0gbm9kZS5hdHRyKCdjb2xvcicpO1xuICAgICAgICAgIGNvbnN0IGZhY2UgPSBub2RlLmF0dHIoJ2ZhY2UnKTtcbiAgICAgICAgICBjb25zdCBzaXplID0gbm9kZS5hdHRyKCdzaXplJyk7XG4gICAgICAgICAgaWYgKGNvbG9yKSB7XG4gICAgICAgICAgICBwcm9wcy5jb2xvciA9IGNvbG9yO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZmFjZSkge1xuICAgICAgICAgICAgcHJvcHNbJ2ZvbnQtZmFtaWx5J10gPSBmYWNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2l6ZSkge1xuICAgICAgICAgICAgcHJvcHNbJ2ZvbnQtc2l6ZSddID0gZm9udFNpemVzW3BhcnNlSW50KG5vZGUuYXR0cignc2l6ZScpLCAxMCkgLSAxXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZS5uYW1lID0gJ3NwYW4nO1xuICAgICAgICAgIG5vZGUuYXR0cignc3R5bGUnLCBzdHlsZXMuc2VyaWFsaXplKHByb3BzKSk7XG4gICAgICAgICAgcmVtb3ZlQXR0cnMobm9kZSwgW1xuICAgICAgICAgICAgJ2NvbG9yJyxcbiAgICAgICAgICAgICdmYWNlJyxcbiAgICAgICAgICAgICdzaXplJ1xuICAgICAgICAgIF0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgYWRkU3RyaWtlRmlsdGVyID0gKGRvbVBhcnNlciwgc2NoZW1hLCBzdHlsZXMpID0+IHtcbiAgICAgIGRvbVBhcnNlci5hZGROb2RlRmlsdGVyKCdzdHJpa2UnLCBub2RlcyA9PiB7XG4gICAgICAgIGNvbnN0IGNvbnZlcnRUb1NUYWcgPSBzY2hlbWEudHlwZSAhPT0gJ2h0bWw0JztcbiAgICAgICAgZWFjaCRnKG5vZGVzLCBub2RlID0+IHtcbiAgICAgICAgICBpZiAoY29udmVydFRvU1RhZykge1xuICAgICAgICAgICAgbm9kZS5uYW1lID0gJ3MnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwcm9wcyA9IHN0eWxlcy5wYXJzZShub2RlLmF0dHIoJ3N0eWxlJykpO1xuICAgICAgICAgICAgcHJvcHNbJ3RleHQtZGVjb3JhdGlvbiddID0gJ2xpbmUtdGhyb3VnaCc7XG4gICAgICAgICAgICBub2RlLm5hbWUgPSAnc3Bhbic7XG4gICAgICAgICAgICBub2RlLmF0dHIoJ3N0eWxlJywgc3R5bGVzLnNlcmlhbGl6ZShwcm9wcykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGFkZEZpbHRlcnMgPSAoZG9tUGFyc2VyLCBzZXR0aW5ncywgc2NoZW1hKSA9PiB7XG4gICAgICBjb25zdCBzdHlsZXMgPSBTdHlsZXMoKTtcbiAgICAgIGlmIChzZXR0aW5ncy5jb252ZXJ0X2ZvbnRzX3RvX3NwYW5zKSB7XG4gICAgICAgIGFkZEZvbnRUb1NwYW5zRmlsdGVyKGRvbVBhcnNlciwgc3R5bGVzLCBUb29scy5leHBsb2RlKHNldHRpbmdzLmZvbnRfc2l6ZV9sZWdhY3lfdmFsdWVzKSk7XG4gICAgICB9XG4gICAgICBhZGRTdHJpa2VGaWx0ZXIoZG9tUGFyc2VyLCBzY2hlbWEsIHN0eWxlcyk7XG4gICAgfTtcbiAgICBjb25zdCByZWdpc3RlciQ1ID0gKGRvbVBhcnNlciwgc2V0dGluZ3MsIHNjaGVtYSkgPT4ge1xuICAgICAgaWYgKHNldHRpbmdzLmlubGluZV9zdHlsZXMpIHtcbiAgICAgICAgYWRkRmlsdGVycyhkb21QYXJzZXIsIHNldHRpbmdzLCBzY2hlbWEpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBibG9iVXJpVG9CbG9iID0gdXJsID0+IHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlamVjdFdpdGhFcnJvciA9ICgpID0+IHtcbiAgICAgICAgICByZWplY3QoJ0Nhbm5vdCBjb252ZXJ0ICcgKyB1cmwgKyAnIHRvIEJsb2IuIFJlc291cmNlIG1pZ2h0IG5vdCBleGlzdCBvciBpcyBpbmFjY2Vzc2libGUuJyk7XG4gICAgICAgIH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSk7XG4gICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdibG9iJztcbiAgICAgICAgICB4aHIub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHhoci5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgICByZXNvbHZlKHhoci5yZXNwb25zZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWplY3RXaXRoRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIHhoci5vbmVycm9yID0gcmVqZWN0V2l0aEVycm9yO1xuICAgICAgICAgIHhoci5zZW5kKCk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgcmVqZWN0V2l0aEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgcGFyc2VEYXRhVXJpJDEgPSB1cmkgPT4ge1xuICAgICAgbGV0IHR5cGU7XG4gICAgICBjb25zdCB1cmlQYXJ0cyA9IGRlY29kZVVSSUNvbXBvbmVudCh1cmkpLnNwbGl0KCcsJyk7XG4gICAgICBjb25zdCBtYXRjaGVzID0gL2RhdGE6KFteO10rKS8uZXhlYyh1cmlQYXJ0c1swXSk7XG4gICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICB0eXBlID0gbWF0Y2hlc1sxXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIGRhdGE6IHVyaVBhcnRzWzFdXG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgYnVpbGRCbG9iID0gKHR5cGUsIGRhdGEpID0+IHtcbiAgICAgIGxldCBzdHI7XG4gICAgICB0cnkge1xuICAgICAgICBzdHIgPSBhdG9iKGRhdGEpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgfVxuICAgICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoc3RyLmxlbmd0aCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJbaV0gPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKG5ldyBCbG9iKFthcnJdLCB7IHR5cGUgfSkpO1xuICAgIH07XG4gICAgY29uc3QgZGF0YVVyaVRvQmxvYiA9IHVyaSA9PiB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIGNvbnN0IHt0eXBlLCBkYXRhfSA9IHBhcnNlRGF0YVVyaSQxKHVyaSk7XG4gICAgICAgIGJ1aWxkQmxvYih0eXBlLCBkYXRhKS5mb2xkKCgpID0+IHJlc29sdmUobmV3IEJsb2IoW10pKSwgcmVzb2x2ZSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHVyaVRvQmxvYiA9IHVybCA9PiB7XG4gICAgICBpZiAodXJsLmluZGV4T2YoJ2Jsb2I6JykgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGJsb2JVcmlUb0Jsb2IodXJsKTtcbiAgICAgIH1cbiAgICAgIGlmICh1cmwuaW5kZXhPZignZGF0YTonKSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZGF0YVVyaVRvQmxvYih1cmwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBjb25zdCBibG9iVG9EYXRhVXJpID0gYmxvYiA9PiB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgIHJlYWRlci5vbmxvYWRlbmQgPSAoKSA9PiB7XG4gICAgICAgICAgcmVzb2x2ZShyZWFkZXIucmVzdWx0KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoYmxvYik7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgbGV0IGNvdW50JDEgPSAwO1xuICAgIGNvbnN0IHVuaXF1ZUlkJDEgPSBwcmVmaXggPT4ge1xuICAgICAgcmV0dXJuIChwcmVmaXggfHwgJ2Jsb2JpZCcpICsgY291bnQkMSsrO1xuICAgIH07XG4gICAgY29uc3QgaW1hZ2VUb0Jsb2JJbmZvID0gKGJsb2JDYWNoZSwgaW1nLCByZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGxldCBiYXNlNjQsIGJsb2JJbmZvO1xuICAgICAgaWYgKGltZy5zcmMuaW5kZXhPZignYmxvYjonKSA9PT0gMCkge1xuICAgICAgICBibG9iSW5mbyA9IGJsb2JDYWNoZS5nZXRCeVVyaShpbWcuc3JjKTtcbiAgICAgICAgaWYgKGJsb2JJbmZvKSB7XG4gICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICBpbWFnZTogaW1nLFxuICAgICAgICAgICAgYmxvYkluZm9cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1cmlUb0Jsb2IoaW1nLnNyYykudGhlbihibG9iID0+IHtcbiAgICAgICAgICAgIGJsb2JUb0RhdGFVcmkoYmxvYikudGhlbihkYXRhVXJpID0+IHtcbiAgICAgICAgICAgICAgYmFzZTY0ID0gcGFyc2VEYXRhVXJpJDEoZGF0YVVyaSkuZGF0YTtcbiAgICAgICAgICAgICAgYmxvYkluZm8gPSBibG9iQ2FjaGUuY3JlYXRlKHVuaXF1ZUlkJDEoKSwgYmxvYiwgYmFzZTY0KTtcbiAgICAgICAgICAgICAgYmxvYkNhY2hlLmFkZChibG9iSW5mbyk7XG4gICAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgIGltYWdlOiBpbWcsXG4gICAgICAgICAgICAgICAgYmxvYkluZm9cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LCBlcnIgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qge2RhdGEsIHR5cGV9ID0gcGFyc2VEYXRhVXJpJDEoaW1nLnNyYyk7XG4gICAgICBiYXNlNjQgPSBkYXRhO1xuICAgICAgYmxvYkluZm8gPSBibG9iQ2FjaGUuZ2V0QnlEYXRhKGJhc2U2NCwgdHlwZSk7XG4gICAgICBpZiAoYmxvYkluZm8pIHtcbiAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgaW1hZ2U6IGltZyxcbiAgICAgICAgICBibG9iSW5mb1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVyaVRvQmxvYihpbWcuc3JjKS50aGVuKGJsb2IgPT4ge1xuICAgICAgICAgIGJsb2JJbmZvID0gYmxvYkNhY2hlLmNyZWF0ZSh1bmlxdWVJZCQxKCksIGJsb2IsIGJhc2U2NCk7XG4gICAgICAgICAgYmxvYkNhY2hlLmFkZChibG9iSW5mbyk7XG4gICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICBpbWFnZTogaW1nLFxuICAgICAgICAgICAgYmxvYkluZm9cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZXJyID0+IHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBnZXRBbGxJbWFnZXMgPSBlbG0gPT4ge1xuICAgICAgcmV0dXJuIGVsbSA/IGZyb20oZWxtLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdpbWcnKSkgOiBbXTtcbiAgICB9O1xuICAgIGNvbnN0IEltYWdlU2Nhbm5lciA9ICh1cGxvYWRTdGF0dXMsIGJsb2JDYWNoZSkgPT4ge1xuICAgICAgY29uc3QgY2FjaGVkUHJvbWlzZXMgPSB7fTtcbiAgICAgIGNvbnN0IGZpbmRBbGwgPSAoZWxtLCBwcmVkaWNhdGUpID0+IHtcbiAgICAgICAgaWYgKCFwcmVkaWNhdGUpIHtcbiAgICAgICAgICBwcmVkaWNhdGUgPSBhbHdheXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW1hZ2VzID0gZmlsdGVyJDYoZ2V0QWxsSW1hZ2VzKGVsbSksIGltZyA9PiB7XG4gICAgICAgICAgY29uc3Qgc3JjID0gaW1nLnNyYztcbiAgICAgICAgICBpZiAoaW1nLmhhc0F0dHJpYnV0ZSgnZGF0YS1tY2UtYm9ndXMnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW1nLmhhc0F0dHJpYnV0ZSgnZGF0YS1tY2UtcGxhY2Vob2xkZXInKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXNyYyB8fCBzcmMgPT09IEVudi50cmFuc3BhcmVudFNyYykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3JjLmluZGV4T2YoJ2Jsb2I6JykgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAhdXBsb2FkU3RhdHVzLmlzVXBsb2FkZWQoc3JjKSAmJiBwcmVkaWNhdGUoaW1nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNyYy5pbmRleE9mKCdkYXRhOicpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJlZGljYXRlKGltZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gbWFwJDMoaW1hZ2VzLCBpbWcgPT4ge1xuICAgICAgICAgIGlmIChjYWNoZWRQcm9taXNlc1tpbWcuc3JjXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICAgIGNhY2hlZFByb21pc2VzW2ltZy5zcmNdLnRoZW4oaW1hZ2VJbmZvID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGltYWdlSW5mbyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBpbWFnZUluZm87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgICAgaW1hZ2U6IGltZyxcbiAgICAgICAgICAgICAgICAgIGJsb2JJbmZvOiBpbWFnZUluZm8uYmxvYkluZm9cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgbmV3UHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGltYWdlVG9CbG9iSW5mbyhibG9iQ2FjaGUsIGltZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgICAgICBkZWxldGUgY2FjaGVkUHJvbWlzZXNbcmVzdWx0LmltYWdlLnNyY107XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgIGRlbGV0ZSBjYWNoZWRQcm9taXNlc1tpbWcuc3JjXTtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjYWNoZWRQcm9taXNlc1tpbWcuc3JjXSA9IG5ld1Byb21pc2U7XG4gICAgICAgICAgcmV0dXJuIG5ld1Byb21pc2U7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiB7IGZpbmRBbGwgfTtcbiAgICB9O1xuXG4gICAgY29uc3QgcGFyc2VEYXRhVXJpID0gdXJpID0+IHtcbiAgICAgIGNvbnN0IG1hdGNoZXMgPSAvZGF0YTooW147XSspO2Jhc2U2NCwoW2EtejAtOVxcK1xcLz1cXHNdKykvaS5leGVjKHVyaSk7XG4gICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZSh7XG4gICAgICAgICAgdHlwZTogbWF0Y2hlc1sxXSxcbiAgICAgICAgICBkYXRhOiBkZWNvZGVVUklDb21wb25lbnQobWF0Y2hlc1syXSlcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBpc0JvZ3VzSW1hZ2UgPSBpbWcgPT4gaXNOb25OdWxsYWJsZShpbWcuYXR0cignZGF0YS1tY2UtYm9ndXMnKSk7XG4gICAgY29uc3QgaXNJbnRlcm5hbEltYWdlU291cmNlID0gaW1nID0+IGltZy5hdHRyKCdzcmMnKSA9PT0gRW52LnRyYW5zcGFyZW50U3JjIHx8IGlzTm9uTnVsbGFibGUoaW1nLmF0dHIoJ2RhdGEtbWNlLXBsYWNlaG9sZGVyJykpO1xuICAgIGNvbnN0IHJlZ2lzdGVyQmFzZTY0SW1hZ2VGaWx0ZXIgPSAocGFyc2VyLCBzZXR0aW5ncykgPT4ge1xuICAgICAgY29uc3Qge2Jsb2JfY2FjaGU6IGJsb2JDYWNoZX0gPSBzZXR0aW5ncztcbiAgICAgIGNvbnN0IHByb2Nlc3NJbWFnZSA9IGltZyA9PiB7XG4gICAgICAgIGNvbnN0IGlucHV0U3JjID0gaW1nLmF0dHIoJ3NyYycpO1xuICAgICAgICBpZiAoaXNJbnRlcm5hbEltYWdlU291cmNlKGltZykgfHwgaXNCb2d1c0ltYWdlKGltZykpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VEYXRhVXJpKGlucHV0U3JjKS5iaW5kKCh7dHlwZSwgZGF0YX0pID0+IE9wdGlvbmFsLmZyb20oYmxvYkNhY2hlLmdldEJ5RGF0YShkYXRhLCB0eXBlKSkub3JUaHVuaygoKSA9PiBidWlsZEJsb2IodHlwZSwgZGF0YSkubWFwKGJsb2IgPT4ge1xuICAgICAgICAgIGNvbnN0IGJsb2JJbmZvID0gYmxvYkNhY2hlLmNyZWF0ZSh1bmlxdWVJZCQxKCksIGJsb2IsIGRhdGEpO1xuICAgICAgICAgIGJsb2JDYWNoZS5hZGQoYmxvYkluZm8pO1xuICAgICAgICAgIHJldHVybiBibG9iSW5mbztcbiAgICAgICAgfSkpKS5lYWNoKGJsb2JJbmZvID0+IHtcbiAgICAgICAgICBpbWcuYXR0cignc3JjJywgYmxvYkluZm8uYmxvYlVyaSgpKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgaWYgKGJsb2JDYWNoZSkge1xuICAgICAgICBwYXJzZXIuYWRkQXR0cmlidXRlRmlsdGVyKCdzcmMnLCBub2RlcyA9PiBlYWNoJGcobm9kZXMsIHByb2Nlc3NJbWFnZSkpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcmVnaXN0ZXIkNCA9IChwYXJzZXIsIHNldHRpbmdzKSA9PiB7XG4gICAgICBjb25zdCBzY2hlbWEgPSBwYXJzZXIuc2NoZW1hO1xuICAgICAgaWYgKHNldHRpbmdzLnJlbW92ZV90cmFpbGluZ19icnMpIHtcbiAgICAgICAgcGFyc2VyLmFkZE5vZGVGaWx0ZXIoJ2JyJywgKG5vZGVzLCBfLCBhcmdzKSA9PiB7XG4gICAgICAgICAgY29uc3QgYmxvY2tFbGVtZW50cyA9IFRvb2xzLmV4dGVuZCh7fSwgc2NoZW1hLmdldEJsb2NrRWxlbWVudHMoKSk7XG4gICAgICAgICAgY29uc3Qgbm9uRW1wdHlFbGVtZW50cyA9IHNjaGVtYS5nZXROb25FbXB0eUVsZW1lbnRzKCk7XG4gICAgICAgICAgY29uc3Qgd2hpdGVzcGFjZUVsZW1lbnRzID0gc2NoZW1hLmdldFdoaXRlc3BhY2VFbGVtZW50cygpO1xuICAgICAgICAgIGJsb2NrRWxlbWVudHMuYm9keSA9IDE7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gbm9kZS5wYXJlbnQ7XG4gICAgICAgICAgICBpZiAoYmxvY2tFbGVtZW50c1tub2RlLnBhcmVudC5uYW1lXSAmJiBub2RlID09PSBwYXJlbnQubGFzdENoaWxkKSB7XG4gICAgICAgICAgICAgIGxldCBwcmV2ID0gbm9kZS5wcmV2O1xuICAgICAgICAgICAgICB3aGlsZSAocHJldikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZOYW1lID0gcHJldi5uYW1lO1xuICAgICAgICAgICAgICAgIGlmIChwcmV2TmFtZSAhPT0gJ3NwYW4nIHx8IHByZXYuYXR0cignZGF0YS1tY2UtdHlwZScpICE9PSAnYm9va21hcmsnKSB7XG4gICAgICAgICAgICAgICAgICBpZiAocHJldk5hbWUgPT09ICdicicpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJldiA9IHByZXYucHJldjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzRW1wdHkoc2NoZW1hLCBub25FbXB0eUVsZW1lbnRzLCB3aGl0ZXNwYWNlRWxlbWVudHMsIHBhcmVudCkpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRSdWxlID0gc2NoZW1hLmdldEVsZW1lbnRSdWxlKHBhcmVudC5uYW1lKTtcbiAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50UnVsZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudFJ1bGUucmVtb3ZlRW1wdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudFJ1bGUucGFkZEVtcHR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgcGFkZEVtcHR5Tm9kZShzZXR0aW5ncywgYXJncywgYmxvY2tFbGVtZW50cywgcGFyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbGV0IGxhc3RQYXJlbnQgPSBub2RlO1xuICAgICAgICAgICAgICB3aGlsZSAocGFyZW50ICYmIHBhcmVudC5maXJzdENoaWxkID09PSBsYXN0UGFyZW50ICYmIHBhcmVudC5sYXN0Q2hpbGQgPT09IGxhc3RQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBsYXN0UGFyZW50ID0gcGFyZW50O1xuICAgICAgICAgICAgICAgIGlmIChibG9ja0VsZW1lbnRzW3BhcmVudC5uYW1lXSkge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGxhc3RQYXJlbnQgPT09IHBhcmVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRleHROb2RlID0gbmV3IEFzdE5vZGUoJyN0ZXh0JywgMyk7XG4gICAgICAgICAgICAgICAgdGV4dE5vZGUudmFsdWUgPSBuYnNwO1xuICAgICAgICAgICAgICAgIG5vZGUucmVwbGFjZSh0ZXh0Tm9kZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcGFyc2VyLmFkZEF0dHJpYnV0ZUZpbHRlcignaHJlZicsIG5vZGVzID0+IHtcbiAgICAgICAgbGV0IGkgPSBub2Rlcy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGFwcGVuZFJlbCA9IHJlbCA9PiB7XG4gICAgICAgICAgY29uc3QgcGFydHMgPSByZWwuc3BsaXQoJyAnKS5maWx0ZXIocCA9PiBwLmxlbmd0aCA+IDApO1xuICAgICAgICAgIHJldHVybiBwYXJ0cy5jb25jYXQoWydub29wZW5lciddKS5zb3J0KCkuam9pbignICcpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBhZGROb09wZW5lciA9IHJlbCA9PiB7XG4gICAgICAgICAgY29uc3QgbmV3UmVsID0gcmVsID8gVG9vbHMudHJpbShyZWwpIDogJyc7XG4gICAgICAgICAgaWYgKCEvXFxiKG5vb3BlbmVyKVxcYi9nLnRlc3QobmV3UmVsKSkge1xuICAgICAgICAgICAgcmV0dXJuIGFwcGVuZFJlbChuZXdSZWwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3UmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFzZXR0aW5ncy5hbGxvd191bnNhZmVfbGlua190YXJnZXQpIHtcbiAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgICBpZiAobm9kZS5uYW1lID09PSAnYScgJiYgbm9kZS5hdHRyKCd0YXJnZXQnKSA9PT0gJ19ibGFuaycpIHtcbiAgICAgICAgICAgICAgbm9kZS5hdHRyKCdyZWwnLCBhZGROb09wZW5lcihub2RlLmF0dHIoJ3JlbCcpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmICghc2V0dGluZ3MuYWxsb3dfaHRtbF9pbl9uYW1lZF9hbmNob3IpIHtcbiAgICAgICAgcGFyc2VyLmFkZEF0dHJpYnV0ZUZpbHRlcignaWQsbmFtZScsIG5vZGVzID0+IHtcbiAgICAgICAgICBsZXQgaSA9IG5vZGVzLmxlbmd0aCwgc2libGluZywgcHJldlNpYmxpbmcsIHBhcmVudCwgbm9kZTtcbiAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgICBpZiAobm9kZS5uYW1lID09PSAnYScgJiYgbm9kZS5maXJzdENoaWxkICYmICFub2RlLmF0dHIoJ2hyZWYnKSkge1xuICAgICAgICAgICAgICBwYXJlbnQgPSBub2RlLnBhcmVudDtcbiAgICAgICAgICAgICAgc2libGluZyA9IG5vZGUubGFzdENoaWxkO1xuICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgcHJldlNpYmxpbmcgPSBzaWJsaW5nLnByZXY7XG4gICAgICAgICAgICAgICAgcGFyZW50Lmluc2VydChzaWJsaW5nLCBub2RlKTtcbiAgICAgICAgICAgICAgICBzaWJsaW5nID0gcHJldlNpYmxpbmc7XG4gICAgICAgICAgICAgIH0gd2hpbGUgKHNpYmxpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoc2V0dGluZ3MuZml4X2xpc3RfZWxlbWVudHMpIHtcbiAgICAgICAgcGFyc2VyLmFkZE5vZGVGaWx0ZXIoJ3VsLG9sJywgbm9kZXMgPT4ge1xuICAgICAgICAgIGxldCBpID0gbm9kZXMubGVuZ3RoLCBub2RlLCBwYXJlbnROb2RlO1xuICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICAgIHBhcmVudE5vZGUgPSBub2RlLnBhcmVudDtcbiAgICAgICAgICAgIGlmIChwYXJlbnROb2RlLm5hbWUgPT09ICd1bCcgfHwgcGFyZW50Tm9kZS5uYW1lID09PSAnb2wnKSB7XG4gICAgICAgICAgICAgIGlmIChub2RlLnByZXYgJiYgbm9kZS5wcmV2Lm5hbWUgPT09ICdsaScpIHtcbiAgICAgICAgICAgICAgICBub2RlLnByZXYuYXBwZW5kKG5vZGUpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpID0gbmV3IEFzdE5vZGUoJ2xpJywgMSk7XG4gICAgICAgICAgICAgICAgbGkuYXR0cignc3R5bGUnLCAnbGlzdC1zdHlsZS10eXBlOiBub25lJyk7XG4gICAgICAgICAgICAgICAgbm9kZS53cmFwKGxpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoc2V0dGluZ3MudmFsaWRhdGUgJiYgc2NoZW1hLmdldFZhbGlkQ2xhc3NlcygpKSB7XG4gICAgICAgIHBhcnNlci5hZGRBdHRyaWJ1dGVGaWx0ZXIoJ2NsYXNzJywgbm9kZXMgPT4ge1xuICAgICAgICAgIGNvbnN0IHZhbGlkQ2xhc3NlcyA9IHNjaGVtYS5nZXRWYWxpZENsYXNzZXMoKTtcbiAgICAgICAgICBsZXQgaSA9IG5vZGVzLmxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgICBjb25zdCBjbGFzc0xpc3QgPSBub2RlLmF0dHIoJ2NsYXNzJykuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgIGxldCBjbGFzc1ZhbHVlID0gJyc7XG4gICAgICAgICAgICBmb3IgKGxldCBjaSA9IDA7IGNpIDwgY2xhc3NMaXN0Lmxlbmd0aDsgY2krKykge1xuICAgICAgICAgICAgICBjb25zdCBjbGFzc05hbWUgPSBjbGFzc0xpc3RbY2ldO1xuICAgICAgICAgICAgICBsZXQgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgbGV0IHZhbGlkQ2xhc3Nlc01hcCA9IHZhbGlkQ2xhc3Nlc1snKiddO1xuICAgICAgICAgICAgICBpZiAodmFsaWRDbGFzc2VzTWFwICYmIHZhbGlkQ2xhc3Nlc01hcFtjbGFzc05hbWVdKSB7XG4gICAgICAgICAgICAgICAgdmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhbGlkQ2xhc3Nlc01hcCA9IHZhbGlkQ2xhc3Nlc1tub2RlLm5hbWVdO1xuICAgICAgICAgICAgICBpZiAoIXZhbGlkICYmIHZhbGlkQ2xhc3Nlc01hcCAmJiB2YWxpZENsYXNzZXNNYXBbY2xhc3NOYW1lXSkge1xuICAgICAgICAgICAgICAgIHZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodmFsaWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2xhc3NWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgY2xhc3NWYWx1ZSArPSAnICc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNsYXNzVmFsdWUgKz0gY2xhc3NOYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWNsYXNzVmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNsYXNzVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZS5hdHRyKCdjbGFzcycsIGNsYXNzVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZWdpc3RlckJhc2U2NEltYWdlRmlsdGVyKHBhcnNlciwgc2V0dGluZ3MpO1xuICAgIH07XG5cbiAgICBjb25zdCBlYWNoJDUgPSBUb29scy5lYWNoLCB0cmltID0gVG9vbHMudHJpbTtcbiAgICBjb25zdCBxdWVyeVBhcnRzID0gJ3NvdXJjZSBwcm90b2NvbCBhdXRob3JpdHkgdXNlckluZm8gdXNlciBwYXNzd29yZCBob3N0IHBvcnQgcmVsYXRpdmUgcGF0aCBkaXJlY3RvcnkgZmlsZSBxdWVyeSBhbmNob3InLnNwbGl0KCcgJyk7XG4gICAgY29uc3QgREVGQVVMVF9QT1JUUyA9IHtcbiAgICAgIGZ0cDogMjEsXG4gICAgICBodHRwOiA4MCxcbiAgICAgIGh0dHBzOiA0NDMsXG4gICAgICBtYWlsdG86IDI1XG4gICAgfTtcbiAgICBjb25zdCBzYWZlU3ZnRGF0YVVybEVsZW1lbnRzID0gW1xuICAgICAgJ2ltZycsXG4gICAgICAndmlkZW8nXG4gICAgXTtcbiAgICBjb25zdCBibG9ja1N2Z0RhdGFVcmlzID0gKGFsbG93U3ZnRGF0YVVybHMsIHRhZ05hbWUpID0+IHtcbiAgICAgIGlmIChpc05vbk51bGxhYmxlKGFsbG93U3ZnRGF0YVVybHMpKSB7XG4gICAgICAgIHJldHVybiAhYWxsb3dTdmdEYXRhVXJscztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBpc05vbk51bGxhYmxlKHRhZ05hbWUpID8gIWNvbnRhaW5zJDIoc2FmZVN2Z0RhdGFVcmxFbGVtZW50cywgdGFnTmFtZSkgOiB0cnVlO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZGVjb2RlVXJpID0gZW5jb2RlZFVyaSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVuY29kZWRVcmkpO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgcmV0dXJuIHVuZXNjYXBlKGVuY29kZWRVcmkpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaXNJbnZhbGlkVXJpID0gKHNldHRpbmdzLCB1cmksIHRhZ05hbWUpID0+IHtcbiAgICAgIGNvbnN0IGRlY29kZWRVcmkgPSBkZWNvZGVVcmkodXJpKTtcbiAgICAgIGlmIChzZXR0aW5ncy5hbGxvd19zY3JpcHRfdXJscykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKC8oKGphdmF8dmIpc2NyaXB0fG1odG1sKTovaS50ZXN0KGRlY29kZWRVcmkpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChzZXR0aW5ncy5hbGxvd19odG1sX2RhdGFfdXJscykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKC9eZGF0YTppbWFnZVxcLy9pLnRlc3QoZGVjb2RlZFVyaSkpIHtcbiAgICAgICAgcmV0dXJuIGJsb2NrU3ZnRGF0YVVyaXMoc2V0dGluZ3MuYWxsb3dfc3ZnX2RhdGFfdXJscywgdGFnTmFtZSkgJiYgL15kYXRhOmltYWdlXFwvc3ZnXFwreG1sL2kudGVzdChkZWNvZGVkVXJpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAvXmRhdGE6L2kudGVzdChkZWNvZGVkVXJpKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNsYXNzIFVSSSB7XG4gICAgICBjb25zdHJ1Y3Rvcih1cmwsIHNldHRpbmdzKSB7XG4gICAgICAgIHVybCA9IHRyaW0odXJsKTtcbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzIHx8IHt9O1xuICAgICAgICBjb25zdCBiYXNlVXJpID0gdGhpcy5zZXR0aW5ncy5iYXNlX3VyaTtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmICgvXihbXFx3XFwtXSspOihbXlxcL117Mn0pL2kudGVzdCh1cmwpIHx8IC9eXFxzKiMvLnRlc3QodXJsKSkge1xuICAgICAgICAgIHNlbGYuc291cmNlID0gdXJsO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc1Byb3RvY29sUmVsYXRpdmUgPSB1cmwuaW5kZXhPZignLy8nKSA9PT0gMDtcbiAgICAgICAgaWYgKHVybC5pbmRleE9mKCcvJykgPT09IDAgJiYgIWlzUHJvdG9jb2xSZWxhdGl2ZSkge1xuICAgICAgICAgIHVybCA9IChiYXNlVXJpID8gYmFzZVVyaS5wcm90b2NvbCB8fCAnaHR0cCcgOiAnaHR0cCcpICsgJzovL21jZV9ob3N0JyArIHVybDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIS9eW1xcd1xcLV0qOj9cXC9cXC8vLnRlc3QodXJsKSkge1xuICAgICAgICAgIGNvbnN0IGJhc2VVcmwgPSB0aGlzLnNldHRpbmdzLmJhc2VfdXJpID8gdGhpcy5zZXR0aW5ncy5iYXNlX3VyaS5wYXRoIDogbmV3IFVSSShkb2N1bWVudC5sb2NhdGlvbi5ocmVmKS5kaXJlY3Rvcnk7XG4gICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuYmFzZV91cmkgJiYgdGhpcy5zZXR0aW5ncy5iYXNlX3VyaS5wcm90b2NvbCA9PSAnJykge1xuICAgICAgICAgICAgdXJsID0gJy8vbWNlX2hvc3QnICsgc2VsZi50b0Fic1BhdGgoYmFzZVVybCwgdXJsKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSAvKFteIz9dKikoWyM/XT8uKikvLmV4ZWModXJsKTtcbiAgICAgICAgICAgIHVybCA9IChiYXNlVXJpICYmIGJhc2VVcmkucHJvdG9jb2wgfHwgJ2h0dHAnKSArICc6Ly9tY2VfaG9zdCcgKyBzZWxmLnRvQWJzUGF0aChiYXNlVXJsLCBtYXRjaFsxXSkgKyBtYXRjaFsyXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoL0BAL2csICcobWNlX2F0KScpO1xuICAgICAgICBjb25zdCB1cmxNYXRjaCA9IC9eKD86KD8hW146QF0rOlteOkBcXC9dKkApKFteOlxcLz8jLl0rKTopPyg/OlxcL1xcLyk/KCg/OigoW146QFxcL10qKTo/KFteOkBcXC9dKikpP0ApPyhcXFtbYS16QS1aMC05Oi4lXStcXF18W146XFwvPyNdKikoPzo6KFxcZCopKT8pKCgoXFwvKD86W14/I10oPyFbXj8jXFwvXSpcXC5bXj8jXFwvLl0rKD86Wz8jXXwkKSkpKlxcLz8pPyhbXj8jXFwvXSopKSg/OlxcPyhbXiNdKikpPyg/OiMoLiopKT8pLy5leGVjKHVybCk7XG4gICAgICAgIGVhY2gkNShxdWVyeVBhcnRzLCAodiwgaSkgPT4ge1xuICAgICAgICAgIGxldCBwYXJ0ID0gdXJsTWF0Y2hbaV07XG4gICAgICAgICAgaWYgKHBhcnQpIHtcbiAgICAgICAgICAgIHBhcnQgPSBwYXJ0LnJlcGxhY2UoL1xcKG1jZV9hdFxcKS9nLCAnQEAnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZlt2XSA9IHBhcnQ7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoYmFzZVVyaSkge1xuICAgICAgICAgIGlmICghc2VsZi5wcm90b2NvbCkge1xuICAgICAgICAgICAgc2VsZi5wcm90b2NvbCA9IGJhc2VVcmkucHJvdG9jb2w7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghc2VsZi51c2VySW5mbykge1xuICAgICAgICAgICAgc2VsZi51c2VySW5mbyA9IGJhc2VVcmkudXNlckluZm87XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghc2VsZi5wb3J0ICYmIHNlbGYuaG9zdCA9PT0gJ21jZV9ob3N0Jykge1xuICAgICAgICAgICAgc2VsZi5wb3J0ID0gYmFzZVVyaS5wb3J0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXNlbGYuaG9zdCB8fCBzZWxmLmhvc3QgPT09ICdtY2VfaG9zdCcpIHtcbiAgICAgICAgICAgIHNlbGYuaG9zdCA9IGJhc2VVcmkuaG9zdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZi5zb3VyY2UgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNQcm90b2NvbFJlbGF0aXZlKSB7XG4gICAgICAgICAgc2VsZi5wcm90b2NvbCA9ICcnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdGF0aWMgcGFyc2VEYXRhVXJpKHVyaSkge1xuICAgICAgICBsZXQgdHlwZTtcbiAgICAgICAgY29uc3QgdXJpQ29tcG9uZW50cyA9IGRlY29kZVVSSUNvbXBvbmVudCh1cmkpLnNwbGl0KCcsJyk7XG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSAvZGF0YTooW147XSspLy5leGVjKHVyaUNvbXBvbmVudHNbMF0pO1xuICAgICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICAgIHR5cGUgPSBtYXRjaGVzWzFdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBkYXRhOiB1cmlDb21wb25lbnRzWzFdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBzdGF0aWMgaXNEb21TYWZlKHVyaSwgY29udGV4dCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmIChvcHRpb25zLmFsbG93X3NjcmlwdF91cmxzKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgZGVjb2RlZFVyaSA9IEVudGl0aWVzLmRlY29kZSh1cmkpLnJlcGxhY2UoL1tcXHNcXHUwMDAwLVxcdTAwMUZdKy9nLCAnJyk7XG4gICAgICAgICAgcmV0dXJuICFpc0ludmFsaWRVcmkob3B0aW9ucywgZGVjb2RlZFVyaSwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0YXRpYyBnZXREb2N1bWVudEJhc2VVcmwobG9jKSB7XG4gICAgICAgIGxldCBiYXNlVXJsO1xuICAgICAgICBpZiAobG9jLnByb3RvY29sLmluZGV4T2YoJ2h0dHAnKSAhPT0gMCAmJiBsb2MucHJvdG9jb2wgIT09ICdmaWxlOicpIHtcbiAgICAgICAgICBiYXNlVXJsID0gbG9jLmhyZWY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmFzZVVybCA9IGxvYy5wcm90b2NvbCArICcvLycgKyBsb2MuaG9zdCArIGxvYy5wYXRobmFtZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoL15bXjpdKzpcXC9cXC9cXC8/W15cXC9dK1xcLy8udGVzdChiYXNlVXJsKSkge1xuICAgICAgICAgIGJhc2VVcmwgPSBiYXNlVXJsLnJlcGxhY2UoL1tcXD8jXS4qJC8sICcnKS5yZXBsYWNlKC9bXFwvXFxcXF1bXlxcL10rJC8sICcnKTtcbiAgICAgICAgICBpZiAoIS9bXFwvXFxcXF0kLy50ZXN0KGJhc2VVcmwpKSB7XG4gICAgICAgICAgICBiYXNlVXJsICs9ICcvJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2VVcmw7XG4gICAgICB9XG4gICAgICBzZXRQYXRoKHBhdGgpIHtcbiAgICAgICAgY29uc3QgcGF0aE1hdGNoID0gL14oLio/KVxcLz8oXFx3Kyk/JC8uZXhlYyhwYXRoKTtcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aE1hdGNoWzBdO1xuICAgICAgICB0aGlzLmRpcmVjdG9yeSA9IHBhdGhNYXRjaFsxXTtcbiAgICAgICAgdGhpcy5maWxlID0gcGF0aE1hdGNoWzJdO1xuICAgICAgICB0aGlzLnNvdXJjZSA9ICcnO1xuICAgICAgICB0aGlzLmdldFVSSSgpO1xuICAgICAgfVxuICAgICAgdG9SZWxhdGl2ZSh1cmkpIHtcbiAgICAgICAgbGV0IG91dHB1dDtcbiAgICAgICAgaWYgKHVyaSA9PT0gJy4vJykge1xuICAgICAgICAgIHJldHVybiB1cmk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVsYXRpdmVVcmkgPSBuZXcgVVJJKHVyaSwgeyBiYXNlX3VyaTogdGhpcyB9KTtcbiAgICAgICAgaWYgKHJlbGF0aXZlVXJpLmhvc3QgIT09ICdtY2VfaG9zdCcgJiYgdGhpcy5ob3N0ICE9PSByZWxhdGl2ZVVyaS5ob3N0ICYmIHJlbGF0aXZlVXJpLmhvc3QgfHwgdGhpcy5wb3J0ICE9PSByZWxhdGl2ZVVyaS5wb3J0IHx8IHRoaXMucHJvdG9jb2wgIT09IHJlbGF0aXZlVXJpLnByb3RvY29sICYmIHJlbGF0aXZlVXJpLnByb3RvY29sICE9PSAnJykge1xuICAgICAgICAgIHJldHVybiByZWxhdGl2ZVVyaS5nZXRVUkkoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0dSA9IHRoaXMuZ2V0VVJJKCksIHV1ID0gcmVsYXRpdmVVcmkuZ2V0VVJJKCk7XG4gICAgICAgIGlmICh0dSA9PT0gdXUgfHwgdHUuY2hhckF0KHR1Lmxlbmd0aCAtIDEpID09PSAnLycgJiYgdHUuc3Vic3RyKDAsIHR1Lmxlbmd0aCAtIDEpID09PSB1dSkge1xuICAgICAgICAgIHJldHVybiB0dTtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXQgPSB0aGlzLnRvUmVsUGF0aCh0aGlzLnBhdGgsIHJlbGF0aXZlVXJpLnBhdGgpO1xuICAgICAgICBpZiAocmVsYXRpdmVVcmkucXVlcnkpIHtcbiAgICAgICAgICBvdXRwdXQgKz0gJz8nICsgcmVsYXRpdmVVcmkucXVlcnk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlbGF0aXZlVXJpLmFuY2hvcikge1xuICAgICAgICAgIG91dHB1dCArPSAnIycgKyByZWxhdGl2ZVVyaS5hbmNob3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgIH1cbiAgICAgIHRvQWJzb2x1dGUodXJpLCBub0hvc3QpIHtcbiAgICAgICAgY29uc3QgYWJzb2x1dGVVcmkgPSBuZXcgVVJJKHVyaSwgeyBiYXNlX3VyaTogdGhpcyB9KTtcbiAgICAgICAgcmV0dXJuIGFic29sdXRlVXJpLmdldFVSSShub0hvc3QgJiYgdGhpcy5pc1NhbWVPcmlnaW4oYWJzb2x1dGVVcmkpKTtcbiAgICAgIH1cbiAgICAgIGlzU2FtZU9yaWdpbih1cmkpIHtcbiAgICAgICAgaWYgKHRoaXMuaG9zdCA9PSB1cmkuaG9zdCAmJiB0aGlzLnByb3RvY29sID09IHVyaS5wcm90b2NvbCkge1xuICAgICAgICAgIGlmICh0aGlzLnBvcnQgPT0gdXJpLnBvcnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBkZWZhdWx0UG9ydCA9IERFRkFVTFRfUE9SVFNbdGhpcy5wcm90b2NvbF07XG4gICAgICAgICAgaWYgKGRlZmF1bHRQb3J0ICYmICh0aGlzLnBvcnQgfHwgZGVmYXVsdFBvcnQpID09ICh1cmkucG9ydCB8fCBkZWZhdWx0UG9ydCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB0b1JlbFBhdGgoYmFzZSwgcGF0aCkge1xuICAgICAgICBsZXQgYnJlYWtQb2ludCA9IDAsIG91dCA9ICcnLCBpLCBsO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkQmFzZSA9IGJhc2Uuc3Vic3RyaW5nKDAsIGJhc2UubGFzdEluZGV4T2YoJy8nKSkuc3BsaXQoJy8nKTtcbiAgICAgICAgY29uc3QgaXRlbXMgPSBwYXRoLnNwbGl0KCcvJyk7XG4gICAgICAgIGlmIChub3JtYWxpemVkQmFzZS5sZW5ndGggPj0gaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgZm9yIChpID0gMCwgbCA9IG5vcm1hbGl6ZWRCYXNlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgPj0gaXRlbXMubGVuZ3RoIHx8IG5vcm1hbGl6ZWRCYXNlW2ldICE9PSBpdGVtc1tpXSkge1xuICAgICAgICAgICAgICBicmVha1BvaW50ID0gaSArIDE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm9ybWFsaXplZEJhc2UubGVuZ3RoIDwgaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgZm9yIChpID0gMCwgbCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgPj0gbm9ybWFsaXplZEJhc2UubGVuZ3RoIHx8IG5vcm1hbGl6ZWRCYXNlW2ldICE9PSBpdGVtc1tpXSkge1xuICAgICAgICAgICAgICBicmVha1BvaW50ID0gaSArIDE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYnJlYWtQb2ludCA9PT0gMSkge1xuICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBub3JtYWxpemVkQmFzZS5sZW5ndGggLSAoYnJlYWtQb2ludCAtIDEpOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgb3V0ICs9ICcuLi8nO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IGJyZWFrUG9pbnQgLSAxLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGkgIT09IGJyZWFrUG9pbnQgLSAxKSB7XG4gICAgICAgICAgICBvdXQgKz0gJy8nICsgaXRlbXNbaV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dCArPSBpdGVtc1tpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgIH1cbiAgICAgIHRvQWJzUGF0aChiYXNlLCBwYXRoKSB7XG4gICAgICAgIGxldCBpLCBuYiA9IDAsIG8gPSBbXSwgb3V0UGF0aDtcbiAgICAgICAgY29uc3QgdHIgPSAvXFwvJC8udGVzdChwYXRoKSA/ICcvJyA6ICcnO1xuICAgICAgICBsZXQgbm9ybWFsaXplZEJhc2UgPSBiYXNlLnNwbGl0KCcvJyk7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRQYXRoID0gcGF0aC5zcGxpdCgnLycpO1xuICAgICAgICBlYWNoJDUobm9ybWFsaXplZEJhc2UsIGsgPT4ge1xuICAgICAgICAgIGlmIChrKSB7XG4gICAgICAgICAgICBvLnB1c2goayk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbm9ybWFsaXplZEJhc2UgPSBvO1xuICAgICAgICBmb3IgKGkgPSBub3JtYWxpemVkUGF0aC5sZW5ndGggLSAxLCBvID0gW107IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKG5vcm1hbGl6ZWRQYXRoW2ldLmxlbmd0aCA9PT0gMCB8fCBub3JtYWxpemVkUGF0aFtpXSA9PT0gJy4nKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5vcm1hbGl6ZWRQYXRoW2ldID09PSAnLi4nKSB7XG4gICAgICAgICAgICBuYisrO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChuYiA+IDApIHtcbiAgICAgICAgICAgIG5iLS07XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgby5wdXNoKG5vcm1hbGl6ZWRQYXRoW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBpID0gbm9ybWFsaXplZEJhc2UubGVuZ3RoIC0gbmI7XG4gICAgICAgIGlmIChpIDw9IDApIHtcbiAgICAgICAgICBvdXRQYXRoID0gcmV2ZXJzZShvKS5qb2luKCcvJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0UGF0aCA9IG5vcm1hbGl6ZWRCYXNlLnNsaWNlKDAsIGkpLmpvaW4oJy8nKSArICcvJyArIHJldmVyc2Uobykuam9pbignLycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdXRQYXRoLmluZGV4T2YoJy8nKSAhPT0gMCkge1xuICAgICAgICAgIG91dFBhdGggPSAnLycgKyBvdXRQYXRoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0ciAmJiBvdXRQYXRoLmxhc3RJbmRleE9mKCcvJykgIT09IG91dFBhdGgubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIG91dFBhdGggKz0gdHI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dFBhdGg7XG4gICAgICB9XG4gICAgICBnZXRVUkkobm9Qcm90b0hvc3QgPSBmYWxzZSkge1xuICAgICAgICBsZXQgcztcbiAgICAgICAgaWYgKCF0aGlzLnNvdXJjZSB8fCBub1Byb3RvSG9zdCkge1xuICAgICAgICAgIHMgPSAnJztcbiAgICAgICAgICBpZiAoIW5vUHJvdG9Ib3N0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm90b2NvbCkge1xuICAgICAgICAgICAgICBzICs9IHRoaXMucHJvdG9jb2wgKyAnOi8vJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHMgKz0gJy8vJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnVzZXJJbmZvKSB7XG4gICAgICAgICAgICAgIHMgKz0gdGhpcy51c2VySW5mbyArICdAJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmhvc3QpIHtcbiAgICAgICAgICAgICAgcyArPSB0aGlzLmhvc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5wb3J0KSB7XG4gICAgICAgICAgICAgIHMgKz0gJzonICsgdGhpcy5wb3J0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5wYXRoKSB7XG4gICAgICAgICAgICBzICs9IHRoaXMucGF0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMucXVlcnkpIHtcbiAgICAgICAgICAgIHMgKz0gJz8nICsgdGhpcy5xdWVyeTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuYW5jaG9yKSB7XG4gICAgICAgICAgICBzICs9ICcjJyArIHRoaXMuYW5jaG9yO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnNvdXJjZSA9IHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IG1ha2VNYXAgPSBUb29scy5tYWtlTWFwLCBlYWNoJDQgPSBUb29scy5lYWNoLCBleHBsb2RlJDEgPSBUb29scy5leHBsb2RlLCBleHRlbmQkMSA9IFRvb2xzLmV4dGVuZDtcbiAgICBjb25zdCBiYXNlUHVyaWZ5Q29uZmlnID0ge1xuICAgICAgSU5fUExBQ0U6IHRydWUsXG4gICAgICBBTExPV19VTktOT1dOX1BST1RPQ09MUzogdHJ1ZSxcbiAgICAgIEFMTE9XRURfVEFHUzogW1xuICAgICAgICAnI2NvbW1lbnQnLFxuICAgICAgICAnI2NkYXRhLXNlY3Rpb24nLFxuICAgICAgICAnYm9keSdcbiAgICAgIF0sXG4gICAgICBBTExPV0VEX0FUVFI6IFtdXG4gICAgfTtcbiAgICBjb25zdCBmaWx0ZXJlZFVybEF0dHJzID0gVG9vbHMubWFrZU1hcCgnc3JjLGhyZWYsZGF0YSxiYWNrZ3JvdW5kLGFjdGlvbixmb3JtYWN0aW9uLHBvc3Rlcix4bGluazpocmVmJyk7XG4gICAgY29uc3QgaW50ZXJuYWxFbGVtZW50QXR0ciA9ICdkYXRhLW1jZS10eXBlJztcbiAgICBjb25zdCBnZXRQdXJpZnlDb25maWcgPSAoc2V0dGluZ3MsIG1pbWVUeXBlKSA9PiB7XG4gICAgICBjb25zdCBjb25maWcgPSB7IC4uLmJhc2VQdXJpZnlDb25maWcgfTtcbiAgICAgIGNvbmZpZy5QQVJTRVJfTUVESUFfVFlQRSA9IG1pbWVUeXBlO1xuICAgICAgaWYgKHNldHRpbmdzLmFsbG93X3NjcmlwdF91cmxzKSB7XG4gICAgICAgIGNvbmZpZy5BTExPV0VEX1VSSV9SRUdFWFAgPSAvLiovO1xuICAgICAgfSBlbHNlIGlmIChzZXR0aW5ncy5hbGxvd19odG1sX2RhdGFfdXJscykge1xuICAgICAgICBjb25maWcuQUxMT1dFRF9VUklfUkVHRVhQID0gL14oPyEoXFx3K3NjcmlwdHxtaHRtbCk6KS9pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9O1xuICAgIGNvbnN0IHNldHVwUHVyaWZ5ID0gKHNldHRpbmdzLCBzY2hlbWEpID0+IHtcbiAgICAgIGNvbnN0IHB1cmlmeSQxID0gcHVyaWZ5KCk7XG4gICAgICBjb25zdCB2YWxpZGF0ZSA9IHNldHRpbmdzLnZhbGlkYXRlO1xuICAgICAgbGV0IHVpZCA9IDA7XG4gICAgICBwdXJpZnkkMS5hZGRIb29rKCd1cG9uU2FuaXRpemVFbGVtZW50JywgKGVsZSwgZXZ0KSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmIChlbGUubm9kZVR5cGUgPT09IENPTU1FTlQgJiYgIXNldHRpbmdzLmFsbG93X2NvbmRpdGlvbmFsX2NvbW1lbnRzICYmIC9eXFxbaWYvaS50ZXN0KGVsZS5ub2RlVmFsdWUpKSB7XG4gICAgICAgICAgZWxlLm5vZGVWYWx1ZSA9ICcgJyArIGVsZS5ub2RlVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFnTmFtZSA9IGV2dC50YWdOYW1lO1xuICAgICAgICBpZiAoZWxlLm5vZGVUeXBlICE9PSBFTEVNRU5UIHx8IHRhZ05hbWUgPT09ICdib2R5Jykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbGVtZW50ID0gU3VnYXJFbGVtZW50LmZyb21Eb20oZWxlKTtcbiAgICAgICAgY29uc3QgaXNJbnRlcm5hbEVsZW1lbnQgPSBoYXMkMShlbGVtZW50LCBpbnRlcm5hbEVsZW1lbnRBdHRyKTtcbiAgICAgICAgY29uc3QgYm9ndXMgPSBnZXQkOShlbGVtZW50LCAnZGF0YS1tY2UtYm9ndXMnKTtcbiAgICAgICAgaWYgKCFpc0ludGVybmFsRWxlbWVudCAmJiBpc1N0cmluZyhib2d1cykpIHtcbiAgICAgICAgICBpZiAoYm9ndXMgPT09ICdhbGwnKSB7XG4gICAgICAgICAgICByZW1vdmUkNShlbGVtZW50KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdW53cmFwKGVsZW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcnVsZSA9IHNjaGVtYS5nZXRFbGVtZW50UnVsZSh0YWdOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICBpZiAodmFsaWRhdGUgJiYgIXJ1bGUpIHtcbiAgICAgICAgICB1bndyYXAoZWxlbWVudCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV2dC5hbGxvd2VkVGFnc1t0YWdOYW1lXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbGlkYXRlICYmICFpc0ludGVybmFsRWxlbWVudCkge1xuICAgICAgICAgIGVhY2gkZygoX2EgPSBydWxlLmF0dHJpYnV0ZXNGb3JjZWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdLCBhdHRyID0+IHtcbiAgICAgICAgICAgIHNldCQyKGVsZW1lbnQsIGF0dHIubmFtZSwgYXR0ci52YWx1ZSA9PT0gJ3skdWlkfScgPyBgbWNlXyR7IHVpZCsrIH1gIDogYXR0ci52YWx1ZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZWFjaCRnKChfYiA9IHJ1bGUuYXR0cmlidXRlc0RlZmF1bHQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdLCBhdHRyID0+IHtcbiAgICAgICAgICAgIGlmICghaGFzJDEoZWxlbWVudCwgYXR0ci5uYW1lKSkge1xuICAgICAgICAgICAgICBzZXQkMihlbGVtZW50LCBhdHRyLm5hbWUsIGF0dHIudmFsdWUgPT09ICd7JHVpZH0nID8gYG1jZV8keyB1aWQrKyB9YCA6IGF0dHIudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChydWxlLmF0dHJpYnV0ZXNSZXF1aXJlZCAmJiAhZXhpc3RzKHJ1bGUuYXR0cmlidXRlc1JlcXVpcmVkLCBhdHRyID0+IGhhcyQxKGVsZW1lbnQsIGF0dHIpKSkge1xuICAgICAgICAgICAgdW53cmFwKGVsZW1lbnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocnVsZS5yZW1vdmVFbXB0eUF0dHJzICYmIGhhc05vbmUoZWxlbWVudCkpIHtcbiAgICAgICAgICAgIHVud3JhcChlbGVtZW50KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJ1bGUub3V0cHV0TmFtZSAmJiBydWxlLm91dHB1dE5hbWUgIT09IHRhZ05hbWUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgbXV0YXRlKGVsZW1lbnQsIHJ1bGUub3V0cHV0TmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHB1cmlmeSQxLmFkZEhvb2soJ3Vwb25TYW5pdGl6ZUF0dHJpYnV0ZScsIChlbGUsIGV2dCkgPT4ge1xuICAgICAgICBjb25zdCB0YWdOYW1lID0gZWxlLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3Qge2F0dHJOYW1lLCBhdHRyVmFsdWV9ID0gZXZ0O1xuICAgICAgICBldnQua2VlcEF0dHIgPSAhdmFsaWRhdGUgfHwgc2NoZW1hLmlzVmFsaWQodGFnTmFtZSwgYXR0ck5hbWUpIHx8IHN0YXJ0c1dpdGgoYXR0ck5hbWUsICdkYXRhLScpIHx8IHN0YXJ0c1dpdGgoYXR0ck5hbWUsICdhcmlhLScpO1xuICAgICAgICBpZiAoYXR0ck5hbWUgaW4gZmlsdGVyZWRVcmxBdHRycyAmJiBpc0ludmFsaWRVcmkoc2V0dGluZ3MsIGF0dHJWYWx1ZSwgdGFnTmFtZSkpIHtcbiAgICAgICAgICBldnQua2VlcEF0dHIgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZ0LmtlZXBBdHRyKSB7XG4gICAgICAgICAgZXZ0LmFsbG93ZWRBdHRyaWJ1dGVzW2F0dHJOYW1lXSA9IHRydWU7XG4gICAgICAgICAgaWYgKGF0dHJOYW1lIGluIHNjaGVtYS5nZXRCb29sQXR0cnMoKSkge1xuICAgICAgICAgICAgZXZ0LmF0dHJWYWx1ZSA9IGF0dHJOYW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2V0dGluZ3MuYWxsb3dfc3ZnX2RhdGFfdXJscyAmJiBzdGFydHNXaXRoKGF0dHJWYWx1ZSwgJ2RhdGE6aW1hZ2Uvc3ZnK3htbCcpKSB7XG4gICAgICAgICAgICBldnQuZm9yY2VLZWVwQXR0ciA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGVsZS5oYXNBdHRyaWJ1dGUoaW50ZXJuYWxFbGVtZW50QXR0cikgJiYgKGF0dHJOYW1lID09PSAnaWQnIHx8IGF0dHJOYW1lID09PSAnY2xhc3MnIHx8IGF0dHJOYW1lID09PSAnc3R5bGUnKSkge1xuICAgICAgICAgIGV2dC5mb3JjZUtlZXBBdHRyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcHVyaWZ5JDE7XG4gICAgfTtcbiAgICBjb25zdCB0cmFuc2ZlckNoaWxkcmVuID0gKHBhcmVudCwgbmF0aXZlUGFyZW50LCBzcGVjaWFsRWxlbWVudHMpID0+IHtcbiAgICAgIGNvbnN0IHBhcmVudE5hbWUgPSBwYXJlbnQubmFtZTtcbiAgICAgIGNvbnN0IGlzU3BlY2lhbCA9IHBhcmVudE5hbWUgaW4gc3BlY2lhbEVsZW1lbnRzICYmIHBhcmVudE5hbWUgIT09ICd0aXRsZScgJiYgcGFyZW50TmFtZSAhPT0gJ3RleHRhcmVhJztcbiAgICAgIGNvbnN0IGNoaWxkTm9kZXMgPSBuYXRpdmVQYXJlbnQuY2hpbGROb2RlcztcbiAgICAgIGZvciAobGV0IG5pID0gMCwgbmwgPSBjaGlsZE5vZGVzLmxlbmd0aDsgbmkgPCBubDsgbmkrKykge1xuICAgICAgICBjb25zdCBuYXRpdmVDaGlsZCA9IGNoaWxkTm9kZXNbbmldO1xuICAgICAgICBjb25zdCBjaGlsZCA9IG5ldyBBc3ROb2RlKG5hdGl2ZUNoaWxkLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksIG5hdGl2ZUNoaWxkLm5vZGVUeXBlKTtcbiAgICAgICAgaWYgKGlzRWxlbWVudCQ2KG5hdGl2ZUNoaWxkKSkge1xuICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBuYXRpdmVDaGlsZC5hdHRyaWJ1dGVzO1xuICAgICAgICAgIGZvciAobGV0IGFpID0gMCwgYWwgPSBhdHRyaWJ1dGVzLmxlbmd0aDsgYWkgPCBhbDsgYWkrKykge1xuICAgICAgICAgICAgY29uc3QgYXR0ciA9IGF0dHJpYnV0ZXNbYWldO1xuICAgICAgICAgICAgY2hpbGQuYXR0cihhdHRyLm5hbWUsIGF0dHIudmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpc1RleHQkOChuYXRpdmVDaGlsZCkpIHtcbiAgICAgICAgICBjaGlsZC52YWx1ZSA9IG5hdGl2ZUNoaWxkLmRhdGE7XG4gICAgICAgICAgaWYgKGlzU3BlY2lhbCkge1xuICAgICAgICAgICAgY2hpbGQucmF3ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaXNDb21tZW50KG5hdGl2ZUNoaWxkKSB8fCBpc0NEYXRhKG5hdGl2ZUNoaWxkKSB8fCBpc1BpKG5hdGl2ZUNoaWxkKSkge1xuICAgICAgICAgIGNoaWxkLnZhbHVlID0gbmF0aXZlQ2hpbGQuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICB0cmFuc2ZlckNoaWxkcmVuKGNoaWxkLCBuYXRpdmVDaGlsZCwgc3BlY2lhbEVsZW1lbnRzKTtcbiAgICAgICAgcGFyZW50LmFwcGVuZChjaGlsZCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCB3YWxrVHJlZSA9IChyb290LCBwcmVwcm9jZXNzb3JzLCBwb3N0cHJvY2Vzc29ycykgPT4ge1xuICAgICAgY29uc3QgdHJhdmVyc2VPcmRlciA9IFtdO1xuICAgICAgZm9yIChsZXQgbm9kZSA9IHJvb3QsIGxhc3ROb2RlID0gbm9kZTsgaXNOb25OdWxsYWJsZShub2RlKTsgbGFzdE5vZGUgPSBub2RlLCBub2RlID0gbm9kZS53YWxrKCkpIHtcbiAgICAgICAgZWFjaCRnKHByZXByb2Nlc3NvcnMsIHByZXByb2Nlc3MgPT4gcHJlcHJvY2Vzcyhub2RlKSk7XG4gICAgICAgIGlmIChpc051bGxhYmxlKG5vZGUucGFyZW50KSAmJiBub2RlICE9PSByb290KSB7XG4gICAgICAgICAgbm9kZSA9IGxhc3ROb2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyYXZlcnNlT3JkZXIucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IHRyYXZlcnNlT3JkZXIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRyYXZlcnNlT3JkZXJbaV07XG4gICAgICAgIGVhY2gkZyhwb3N0cHJvY2Vzc29ycywgcG9zdHByb2Nlc3MgPT4gcG9zdHByb2Nlc3Mobm9kZSkpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgd2hpdGVzcGFjZUNsZWFuZXIgPSAocm9vdCwgc2NoZW1hLCBzZXR0aW5ncywgYXJncykgPT4ge1xuICAgICAgY29uc3QgdmFsaWRhdGUgPSBzZXR0aW5ncy52YWxpZGF0ZTtcbiAgICAgIGNvbnN0IG5vbkVtcHR5RWxlbWVudHMgPSBzY2hlbWEuZ2V0Tm9uRW1wdHlFbGVtZW50cygpO1xuICAgICAgY29uc3Qgd2hpdGVzcGFjZUVsZW1lbnRzID0gc2NoZW1hLmdldFdoaXRlc3BhY2VFbGVtZW50cygpO1xuICAgICAgY29uc3QgYmxvY2tFbGVtZW50cyA9IGV4dGVuZCQxKG1ha2VNYXAoJ3NjcmlwdCxzdHlsZSxoZWFkLGh0bWwsYm9keSx0aXRsZSxtZXRhLHBhcmFtJyksIHNjaGVtYS5nZXRCbG9ja0VsZW1lbnRzKCkpO1xuICAgICAgY29uc3QgdGV4dFJvb3RCbG9ja0VsZW1lbnRzID0gZ2V0VGV4dFJvb3RCbG9ja0VsZW1lbnRzKHNjaGVtYSk7XG4gICAgICBjb25zdCBhbGxXaGl0ZVNwYWNlUmVnRXhwID0gL1sgXFx0XFxyXFxuXSsvZztcbiAgICAgIGNvbnN0IHN0YXJ0V2hpdGVTcGFjZVJlZ0V4cCA9IC9eWyBcXHRcXHJcXG5dKy87XG4gICAgICBjb25zdCBlbmRXaGl0ZVNwYWNlUmVnRXhwID0gL1sgXFx0XFxyXFxuXSskLztcbiAgICAgIGNvbnN0IGhhc1doaXRlc3BhY2VQYXJlbnQgPSBub2RlID0+IHtcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgICAgICB3aGlsZSAoaXNOb25OdWxsYWJsZShub2RlKSkge1xuICAgICAgICAgIGlmIChub2RlLm5hbWUgaW4gd2hpdGVzcGFjZUVsZW1lbnRzKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuICAgICAgY29uc3QgaXNUZXh0Um9vdEJsb2NrRW1wdHkgPSBub2RlID0+IHtcbiAgICAgICAgbGV0IHRlbXBOb2RlID0gbm9kZTtcbiAgICAgICAgd2hpbGUgKGlzTm9uTnVsbGFibGUodGVtcE5vZGUpKSB7XG4gICAgICAgICAgaWYgKHRlbXBOb2RlLm5hbWUgaW4gdGV4dFJvb3RCbG9ja0VsZW1lbnRzKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNFbXB0eShzY2hlbWEsIG5vbkVtcHR5RWxlbWVudHMsIHdoaXRlc3BhY2VFbGVtZW50cywgdGVtcE5vZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZW1wTm9kZSA9IHRlbXBOb2RlLnBhcmVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGlzQXRFZGdlT2ZCbG9jayA9IChub2RlLCBzdGFydCkgPT4ge1xuICAgICAgICBjb25zdCBuZWlnaGJvdXIgPSBzdGFydCA/IG5vZGUucHJldiA6IG5vZGUubmV4dDtcbiAgICAgICAgaWYgKGlzTm9uTnVsbGFibGUobmVpZ2hib3VyKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZS5wYXJlbnQubmFtZSBpbiBibG9ja0VsZW1lbnRzICYmIChub2RlLnBhcmVudCAhPT0gcm9vdCB8fCBhcmdzLmlzUm9vdENvbnRlbnQpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHByZXByb2Nlc3MgPSBub2RlID0+IHtcbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gMykge1xuICAgICAgICAgIGlmICghaGFzV2hpdGVzcGFjZVBhcmVudChub2RlKSkge1xuICAgICAgICAgICAgbGV0IHRleHQgPSBub2RlLnZhbHVlO1xuICAgICAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZShhbGxXaGl0ZVNwYWNlUmVnRXhwLCAnICcpO1xuICAgICAgICAgICAgaWYgKGlzTGluZUJyZWFrTm9kZShub2RlLnByZXYsIGJsb2NrRWxlbWVudHMpIHx8IGlzQXRFZGdlT2ZCbG9jayhub2RlLCB0cnVlKSkge1xuICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKHN0YXJ0V2hpdGVTcGFjZVJlZ0V4cCwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIG5vZGUucmVtb3ZlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBub2RlLnZhbHVlID0gdGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBwb3N0cHJvY2VzcyA9IG5vZGUgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICAgICAgICBjb25zdCBlbGVtZW50UnVsZSA9IHNjaGVtYS5nZXRFbGVtZW50UnVsZShub2RlLm5hbWUpO1xuICAgICAgICAgIGlmICh2YWxpZGF0ZSAmJiBlbGVtZW50UnVsZSkge1xuICAgICAgICAgICAgY29uc3QgaXNOb2RlRW1wdHkgPSBpc0VtcHR5KHNjaGVtYSwgbm9uRW1wdHlFbGVtZW50cywgd2hpdGVzcGFjZUVsZW1lbnRzLCBub2RlKTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50UnVsZS5wYWRkSW5FbXB0eUJsb2NrICYmIGlzTm9kZUVtcHR5ICYmIGlzVGV4dFJvb3RCbG9ja0VtcHR5KG5vZGUpKSB7XG4gICAgICAgICAgICAgIHBhZGRFbXB0eU5vZGUoc2V0dGluZ3MsIGFyZ3MsIGJsb2NrRWxlbWVudHMsIG5vZGUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50UnVsZS5yZW1vdmVFbXB0eSAmJiBpc05vZGVFbXB0eSkge1xuICAgICAgICAgICAgICBpZiAoYmxvY2tFbGVtZW50c1tub2RlLm5hbWVdKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlLnVud3JhcCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnRSdWxlLnBhZGRFbXB0eSAmJiAoaXNOb2RlRW1wdHkgfHwgaXNQYWRkZWRXaXRoTmJzcChub2RlKSkpIHtcbiAgICAgICAgICAgICAgcGFkZEVtcHR5Tm9kZShzZXR0aW5ncywgYXJncywgYmxvY2tFbGVtZW50cywgbm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gMykge1xuICAgICAgICAgIGlmICghaGFzV2hpdGVzcGFjZVBhcmVudChub2RlKSkge1xuICAgICAgICAgICAgbGV0IHRleHQgPSBub2RlLnZhbHVlO1xuICAgICAgICAgICAgaWYgKGJsb2NrRWxlbWVudHNbKF9hID0gbm9kZS5uZXh0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubmFtZV0gfHwgaXNBdEVkZ2VPZkJsb2NrKG5vZGUsIGZhbHNlKSkge1xuICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKGVuZFdoaXRlU3BhY2VSZWdFeHAsICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbm9kZS52YWx1ZSA9IHRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgcHJlcHJvY2VzcyxcbiAgICAgICAgcG9zdHByb2Nlc3NcbiAgICAgIF07XG4gICAgfTtcbiAgICBjb25zdCBnZXRSb290QmxvY2tOYW1lID0gKHNldHRpbmdzLCBhcmdzKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBuYW1lID0gKF9hID0gYXJncy5mb3JjZWRfcm9vdF9ibG9jaykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogc2V0dGluZ3MuZm9yY2VkX3Jvb3RfYmxvY2s7XG4gICAgICBpZiAobmFtZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfSBlbHNlIGlmIChuYW1lID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiAncCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IERvbVBhcnNlciA9IChzZXR0aW5ncyA9IHt9LCBzY2hlbWEgPSBTY2hlbWEoKSkgPT4ge1xuICAgICAgY29uc3Qgbm9kZUZpbHRlcnMgPSB7fTtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZUZpbHRlcnMgPSBbXTtcbiAgICAgIGNvbnN0IGRlZmF1bHRlZFNldHRpbmdzID0ge1xuICAgICAgICB2YWxpZGF0ZTogdHJ1ZSxcbiAgICAgICAgcm9vdF9uYW1lOiAnYm9keScsXG4gICAgICAgIC4uLnNldHRpbmdzXG4gICAgICB9O1xuICAgICAgY29uc3QgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuICAgICAgY29uc3QgcHVyaWZ5ID0gc2V0dXBQdXJpZnkoZGVmYXVsdGVkU2V0dGluZ3MsIHNjaGVtYSk7XG4gICAgICBjb25zdCBwYXJzZUFuZFNhbml0aXplV2l0aENvbnRleHQgPSAoaHRtbCwgcm9vdE5hbWUsIGZvcm1hdCA9ICdodG1sJykgPT4ge1xuICAgICAgICBjb25zdCBtaW1lVHlwZSA9IGZvcm1hdCA9PT0gJ3hodG1sJyA/ICdhcHBsaWNhdGlvbi94aHRtbCt4bWwnIDogJ3RleHQvaHRtbCc7XG4gICAgICAgIGNvbnN0IGlzU3BlY2lhbFJvb3QgPSBoYXMkMihzY2hlbWEuZ2V0U3BlY2lhbEVsZW1lbnRzKCksIHJvb3ROYW1lLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICBjb25zdCBjb250ZW50ID0gaXNTcGVjaWFsUm9vdCA/IGA8JHsgcm9vdE5hbWUgfT4keyBodG1sIH08LyR7IHJvb3ROYW1lIH0+YCA6IGh0bWw7XG4gICAgICAgIGNvbnN0IHdyYXBwZWRIdG1sID0gZm9ybWF0ID09PSAneGh0bWwnID8gYDxodG1sIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiPjxoZWFkPjwvaGVhZD48Ym9keT4keyBjb250ZW50IH08L2JvZHk+PC9odG1sPmAgOiBgPGJvZHk+JHsgY29udGVudCB9PC9ib2R5PmA7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHdyYXBwZWRIdG1sLCBtaW1lVHlwZSkuYm9keTtcbiAgICAgICAgcHVyaWZ5LnNhbml0aXplKGJvZHksIGdldFB1cmlmeUNvbmZpZyhkZWZhdWx0ZWRTZXR0aW5ncywgbWltZVR5cGUpKTtcbiAgICAgICAgcHVyaWZ5LnJlbW92ZWQgPSBbXTtcbiAgICAgICAgcmV0dXJuIGlzU3BlY2lhbFJvb3QgPyBib2R5LmZpcnN0Q2hpbGQgOiBib2R5O1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGFkZE5vZGVGaWx0ZXIgPSAobmFtZSwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgZWFjaCQ0KGV4cGxvZGUkMShuYW1lKSwgbmFtZSA9PiB7XG4gICAgICAgICAgbGV0IGxpc3QgPSBub2RlRmlsdGVyc1tuYW1lXTtcbiAgICAgICAgICBpZiAoIWxpc3QpIHtcbiAgICAgICAgICAgIG5vZGVGaWx0ZXJzW25hbWVdID0gbGlzdCA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsaXN0LnB1c2goY2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBjb25zdCBnZXROb2RlRmlsdGVycyA9ICgpID0+IHtcbiAgICAgICAgY29uc3Qgb3V0ID0gW107XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBub2RlRmlsdGVycykge1xuICAgICAgICAgIGlmIChoYXMkMihub2RlRmlsdGVycywgbmFtZSkpIHtcbiAgICAgICAgICAgIG91dC5wdXNoKHtcbiAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgY2FsbGJhY2tzOiBub2RlRmlsdGVyc1tuYW1lXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgICB9O1xuICAgICAgY29uc3QgYWRkQXR0cmlidXRlRmlsdGVyID0gKG5hbWUsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIGVhY2gkNChleHBsb2RlJDEobmFtZSksIG5hbWUgPT4ge1xuICAgICAgICAgIGxldCBpO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhdHRyaWJ1dGVGaWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlRmlsdGVyc1tpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgICAgIGF0dHJpYnV0ZUZpbHRlcnNbaV0uY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGF0dHJpYnV0ZUZpbHRlcnMucHVzaCh7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgY2FsbGJhY2tzOiBbY2FsbGJhY2tdXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGdldEF0dHJpYnV0ZUZpbHRlcnMgPSAoKSA9PiBbXS5jb25jYXQoYXR0cmlidXRlRmlsdGVycyk7XG4gICAgICBjb25zdCBmaW5kSW52YWxpZENoaWxkcmVuID0gKG5vZGUsIGludmFsaWRDaGlsZHJlbikgPT4ge1xuICAgICAgICBjb25zdCBwYXJlbnQgPSBub2RlLnBhcmVudDtcbiAgICAgICAgaWYgKHBhcmVudCAmJiBzY2hlbWEuY2hpbGRyZW5bbm9kZS5uYW1lXSAmJiAhc2NoZW1hLmlzVmFsaWRDaGlsZChwYXJlbnQubmFtZSwgbm9kZS5uYW1lKSkge1xuICAgICAgICAgIGludmFsaWRDaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgYWRkUm9vdEJsb2NrcyA9IChyb290Tm9kZSwgcm9vdEJsb2NrTmFtZSkgPT4ge1xuICAgICAgICBjb25zdCBibG9ja0VsZW1lbnRzID0gZXh0ZW5kJDEobWFrZU1hcCgnc2NyaXB0LHN0eWxlLGhlYWQsaHRtbCxib2R5LHRpdGxlLG1ldGEscGFyYW0nKSwgc2NoZW1hLmdldEJsb2NrRWxlbWVudHMoKSk7XG4gICAgICAgIGNvbnN0IHN0YXJ0V2hpdGVTcGFjZVJlZ0V4cCA9IC9eWyBcXHRcXHJcXG5dKy87XG4gICAgICAgIGNvbnN0IGVuZFdoaXRlU3BhY2VSZWdFeHAgPSAvWyBcXHRcXHJcXG5dKyQvO1xuICAgICAgICBsZXQgbm9kZSA9IHJvb3ROb2RlLmZpcnN0Q2hpbGQsIHJvb3RCbG9ja05vZGUgPSBudWxsO1xuICAgICAgICBjb25zdCB0cmltID0gcm9vdEJsb2NrID0+IHtcbiAgICAgICAgICBpZiAocm9vdEJsb2NrKSB7XG4gICAgICAgICAgICBub2RlID0gcm9vdEJsb2NrLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICBpZiAobm9kZSAmJiBub2RlLnR5cGUgPT09IDMpIHtcbiAgICAgICAgICAgICAgbm9kZS52YWx1ZSA9IG5vZGUudmFsdWUucmVwbGFjZShzdGFydFdoaXRlU3BhY2VSZWdFeHAsICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUgPSByb290QmxvY2subGFzdENoaWxkO1xuICAgICAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS50eXBlID09PSAzKSB7XG4gICAgICAgICAgICAgIG5vZGUudmFsdWUgPSBub2RlLnZhbHVlLnJlcGxhY2UoZW5kV2hpdGVTcGFjZVJlZ0V4cCwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFzY2hlbWEuaXNWYWxpZENoaWxkKHJvb3ROb2RlLm5hbWUsIHJvb3RCbG9ja05hbWUudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICBjb25zdCBuZXh0ID0gbm9kZS5uZXh0O1xuICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09IDMgfHwgbm9kZS50eXBlID09PSAxICYmIG5vZGUubmFtZSAhPT0gJ3AnICYmICFibG9ja0VsZW1lbnRzW25vZGUubmFtZV0gJiYgIW5vZGUuYXR0cihpbnRlcm5hbEVsZW1lbnRBdHRyKSkge1xuICAgICAgICAgICAgaWYgKCFyb290QmxvY2tOb2RlKSB7XG4gICAgICAgICAgICAgIHJvb3RCbG9ja05vZGUgPSBuZXcgQXN0Tm9kZShyb290QmxvY2tOYW1lLCAxKTtcbiAgICAgICAgICAgICAgcm9vdEJsb2NrTm9kZS5hdHRyKGRlZmF1bHRlZFNldHRpbmdzLmZvcmNlZF9yb290X2Jsb2NrX2F0dHJzKTtcbiAgICAgICAgICAgICAgcm9vdE5vZGUuaW5zZXJ0KHJvb3RCbG9ja05vZGUsIG5vZGUpO1xuICAgICAgICAgICAgICByb290QmxvY2tOb2RlLmFwcGVuZChub2RlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJvb3RCbG9ja05vZGUuYXBwZW5kKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cmltKHJvb3RCbG9ja05vZGUpO1xuICAgICAgICAgICAgcm9vdEJsb2NrTm9kZSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIHRyaW0ocm9vdEJsb2NrTm9kZSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgcGFyc2UgPSAoaHRtbCwgYXJncyA9IHt9KSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgdmFsaWRhdGUgPSBkZWZhdWx0ZWRTZXR0aW5ncy52YWxpZGF0ZTtcbiAgICAgICAgY29uc3Qgcm9vdE5hbWUgPSAoX2EgPSBhcmdzLmNvbnRleHQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRlZmF1bHRlZFNldHRpbmdzLnJvb3RfbmFtZTtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHBhcnNlQW5kU2FuaXRpemVXaXRoQ29udGV4dChodG1sLCByb290TmFtZSwgYXJncy5mb3JtYXQpO1xuICAgICAgICBjb25zdCByb290Tm9kZSA9IG5ldyBBc3ROb2RlKHJvb3ROYW1lLCAxMSk7XG4gICAgICAgIHRyYW5zZmVyQ2hpbGRyZW4ocm9vdE5vZGUsIGVsZW1lbnQsIHNjaGVtYS5nZXRTcGVjaWFsRWxlbWVudHMoKSk7XG4gICAgICAgIGNvbnN0IFt3aGl0ZXNwYWNlUHJlLCB3aGl0ZXNwYWNlUG9zdF0gPSB3aGl0ZXNwYWNlQ2xlYW5lcihyb290Tm9kZSwgc2NoZW1hLCBkZWZhdWx0ZWRTZXR0aW5ncywgYXJncyk7XG4gICAgICAgIGNvbnN0IGludmFsaWRDaGlsZHJlbiA9IFtdO1xuICAgICAgICBjb25zdCBpbnZhbGlkRmluZGVyID0gdmFsaWRhdGUgPyBub2RlID0+IGZpbmRJbnZhbGlkQ2hpbGRyZW4obm9kZSwgaW52YWxpZENoaWxkcmVuKSA6IG5vb3A7XG4gICAgICAgIGNvbnN0IG5vZGVGaWx0ZXJzID0gZ2V0Tm9kZUZpbHRlcnMoKTtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHtcbiAgICAgICAgICBub2Rlczoge30sXG4gICAgICAgICAgYXR0cmlidXRlczoge31cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbWF0Y2hGaW5kZXIgPSBub2RlID0+IG1hdGNoTm9kZSQxKG5vZGVGaWx0ZXJzLCBhdHRyaWJ1dGVGaWx0ZXJzLCBub2RlLCBtYXRjaGVzKTtcbiAgICAgICAgd2Fsa1RyZWUocm9vdE5vZGUsIFtcbiAgICAgICAgICB3aGl0ZXNwYWNlUHJlLFxuICAgICAgICAgIG1hdGNoRmluZGVyXG4gICAgICAgIF0sIFtcbiAgICAgICAgICB3aGl0ZXNwYWNlUG9zdCxcbiAgICAgICAgICBpbnZhbGlkRmluZGVyXG4gICAgICAgIF0pO1xuICAgICAgICBpbnZhbGlkQ2hpbGRyZW4ucmV2ZXJzZSgpO1xuICAgICAgICBpZiAodmFsaWRhdGUgJiYgaW52YWxpZENoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBpZiAoYXJncy5jb250ZXh0KSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIHBhc3M6IHRvcExldmVsQ2hpbGRyZW4sXG4gICAgICAgICAgICAgIGZhaWw6IG90aGVyQ2hpbGRyZW5cbiAgICAgICAgICAgIH0gPSBwYXJ0aXRpb24kMihpbnZhbGlkQ2hpbGRyZW4sIGNoaWxkID0+IGNoaWxkLnBhcmVudCA9PT0gcm9vdE5vZGUpO1xuICAgICAgICAgICAgY2xlYW5JbnZhbGlkTm9kZXMob3RoZXJDaGlsZHJlbiwgc2NoZW1hLCBtYXRjaEZpbmRlcik7XG4gICAgICAgICAgICBhcmdzLmludmFsaWQgPSB0b3BMZXZlbENoaWxkcmVuLmxlbmd0aCA+IDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNsZWFuSW52YWxpZE5vZGVzKGludmFsaWRDaGlsZHJlbiwgc2NoZW1hLCBtYXRjaEZpbmRlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJvb3RCbG9ja05hbWUgPSBnZXRSb290QmxvY2tOYW1lKGRlZmF1bHRlZFNldHRpbmdzLCBhcmdzKTtcbiAgICAgICAgaWYgKHJvb3RCbG9ja05hbWUgJiYgKHJvb3ROb2RlLm5hbWUgPT09ICdib2R5JyB8fCBhcmdzLmlzUm9vdENvbnRlbnQpKSB7XG4gICAgICAgICAgYWRkUm9vdEJsb2Nrcyhyb290Tm9kZSwgcm9vdEJsb2NrTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhcmdzLmludmFsaWQpIHtcbiAgICAgICAgICBydW5GaWx0ZXJzKG1hdGNoZXMsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb290Tm9kZTtcbiAgICAgIH07XG4gICAgICBjb25zdCBleHBvcnRzID0ge1xuICAgICAgICBzY2hlbWEsXG4gICAgICAgIGFkZEF0dHJpYnV0ZUZpbHRlcixcbiAgICAgICAgZ2V0QXR0cmlidXRlRmlsdGVycyxcbiAgICAgICAgYWRkTm9kZUZpbHRlcixcbiAgICAgICAgZ2V0Tm9kZUZpbHRlcnMsXG4gICAgICAgIHBhcnNlXG4gICAgICB9O1xuICAgICAgcmVnaXN0ZXIkNChleHBvcnRzLCBkZWZhdWx0ZWRTZXR0aW5ncyk7XG4gICAgICByZWdpc3RlciQ1KGV4cG9ydHMsIGRlZmF1bHRlZFNldHRpbmdzLCBzY2hlbWEpO1xuICAgICAgcmV0dXJuIGV4cG9ydHM7XG4gICAgfTtcblxuICAgIGNvbnN0IHNlcmlhbGl6ZUNvbnRlbnQgPSBjb250ZW50ID0+IGlzVHJlZU5vZGUoY29udGVudCkgPyBIdG1sU2VyaWFsaXplcih7IHZhbGlkYXRlOiBmYWxzZSB9KS5zZXJpYWxpemUoY29udGVudCkgOiBjb250ZW50O1xuICAgIGNvbnN0IHdpdGhTZXJpYWxpemVkQ29udGVudCA9IChjb250ZW50LCBmaXJlRXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWRDb250ZW50ID0gc2VyaWFsaXplQ29udGVudChjb250ZW50KTtcbiAgICAgIGNvbnN0IGV2ZW50QXJncyA9IGZpcmVFdmVudChzZXJpYWxpemVkQ29udGVudCk7XG4gICAgICBpZiAoZXZlbnRBcmdzLmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgIHJldHVybiBldmVudEFyZ3M7XG4gICAgICB9IGVsc2UgaWYgKGlzVHJlZU5vZGUoY29udGVudCkpIHtcbiAgICAgICAgaWYgKGV2ZW50QXJncy5jb250ZW50ICE9PSBzZXJpYWxpemVkQ29udGVudCkge1xuICAgICAgICAgIGNvbnN0IHJvb3ROb2RlID0gRG9tUGFyc2VyKHtcbiAgICAgICAgICAgIHZhbGlkYXRlOiBmYWxzZSxcbiAgICAgICAgICAgIGZvcmNlZF9yb290X2Jsb2NrOiBmYWxzZVxuICAgICAgICAgIH0pLnBhcnNlKGV2ZW50QXJncy5jb250ZW50LCB7IGNvbnRleHQ6IGNvbnRlbnQubmFtZSB9KTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uZXZlbnRBcmdzLFxuICAgICAgICAgICAgY29udGVudDogcm9vdE5vZGVcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5ldmVudEFyZ3MsXG4gICAgICAgICAgICBjb250ZW50XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50QXJncztcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHByZVByb2Nlc3NHZXRDb250ZW50ID0gKGVkaXRvciwgYXJncykgPT4ge1xuICAgICAgaWYgKGFyZ3Mubm9fZXZlbnRzKSB7XG4gICAgICAgIHJldHVybiBSZXN1bHQudmFsdWUoYXJncyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBldmVudEFyZ3MgPSBmaXJlQmVmb3JlR2V0Q29udGVudChlZGl0b3IsIGFyZ3MpO1xuICAgICAgICBpZiAoZXZlbnRBcmdzLmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgcmV0dXJuIFJlc3VsdC5lcnJvcihmaXJlR2V0Q29udGVudChlZGl0b3IsIHtcbiAgICAgICAgICAgIGNvbnRlbnQ6ICcnLFxuICAgICAgICAgICAgLi4uZXZlbnRBcmdzXG4gICAgICAgICAgfSkuY29udGVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFJlc3VsdC52YWx1ZShldmVudEFyZ3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBwb3N0UHJvY2Vzc0dldENvbnRlbnQgPSAoZWRpdG9yLCBjb250ZW50LCBhcmdzKSA9PiB7XG4gICAgICBpZiAoYXJncy5ub19ldmVudHMpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBwcm9jZXNzZWRFdmVudEFyZ3MgPSB3aXRoU2VyaWFsaXplZENvbnRlbnQoY29udGVudCwgYyA9PiBmaXJlR2V0Q29udGVudChlZGl0b3IsIHtcbiAgICAgICAgICAuLi5hcmdzLFxuICAgICAgICAgIGNvbnRlbnQ6IGNcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gcHJvY2Vzc2VkRXZlbnRBcmdzLmNvbnRlbnQ7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBwcmVQcm9jZXNzU2V0Q29udGVudCA9IChlZGl0b3IsIGFyZ3MpID0+IHtcbiAgICAgIGlmIChhcmdzLm5vX2V2ZW50cykge1xuICAgICAgICByZXR1cm4gUmVzdWx0LnZhbHVlKGFyZ3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcHJvY2Vzc2VkRXZlbnRBcmdzID0gd2l0aFNlcmlhbGl6ZWRDb250ZW50KGFyZ3MuY29udGVudCwgY29udGVudCA9PiBmaXJlQmVmb3JlU2V0Q29udGVudChlZGl0b3IsIHtcbiAgICAgICAgICAuLi5hcmdzLFxuICAgICAgICAgIGNvbnRlbnRcbiAgICAgICAgfSkpO1xuICAgICAgICBpZiAocHJvY2Vzc2VkRXZlbnRBcmdzLmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgZmlyZVNldENvbnRlbnQoZWRpdG9yLCBwcm9jZXNzZWRFdmVudEFyZ3MpO1xuICAgICAgICAgIHJldHVybiBSZXN1bHQuZXJyb3IodW5kZWZpbmVkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gUmVzdWx0LnZhbHVlKHByb2Nlc3NlZEV2ZW50QXJncyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHBvc3RQcm9jZXNzU2V0Q29udGVudCA9IChlZGl0b3IsIGNvbnRlbnQsIGFyZ3MpID0+IHtcbiAgICAgIGlmICghYXJncy5ub19ldmVudHMpIHtcbiAgICAgICAgZmlyZVNldENvbnRlbnQoZWRpdG9yLCB7XG4gICAgICAgICAgLi4uYXJncyxcbiAgICAgICAgICBjb250ZW50XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCB0YWJsZU1vZGVsID0gKGVsZW1lbnQsIHdpZHRoLCByb3dzKSA9PiAoe1xuICAgICAgZWxlbWVudCxcbiAgICAgIHdpZHRoLFxuICAgICAgcm93c1xuICAgIH0pO1xuICAgIGNvbnN0IHRhYmxlUm93ID0gKGVsZW1lbnQsIGNlbGxzKSA9PiAoe1xuICAgICAgZWxlbWVudCxcbiAgICAgIGNlbGxzXG4gICAgfSk7XG4gICAgY29uc3QgY2VsbFBvc2l0aW9uID0gKHgsIHkpID0+ICh7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH0pO1xuICAgIGNvbnN0IGdldFNwYW4gPSAodGQsIGtleSkgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSBwYXJzZUludChnZXQkOSh0ZCwga2V5KSwgMTApO1xuICAgICAgcmV0dXJuIGlzTmFOKHZhbHVlKSA/IDEgOiB2YWx1ZTtcbiAgICB9O1xuICAgIGNvbnN0IGZpbGxvdXQgPSAodGFibGUsIHgsIHksIHRyLCB0ZCkgPT4ge1xuICAgICAgY29uc3Qgcm93c3BhbiA9IGdldFNwYW4odGQsICdyb3dzcGFuJyk7XG4gICAgICBjb25zdCBjb2xzcGFuID0gZ2V0U3Bhbih0ZCwgJ2NvbHNwYW4nKTtcbiAgICAgIGNvbnN0IHJvd3MgPSB0YWJsZS5yb3dzO1xuICAgICAgZm9yIChsZXQgeTIgPSB5OyB5MiA8IHkgKyByb3dzcGFuOyB5MisrKSB7XG4gICAgICAgIGlmICghcm93c1t5Ml0pIHtcbiAgICAgICAgICByb3dzW3kyXSA9IHRhYmxlUm93KGRlZXAkMSh0ciksIFtdKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCB4MiA9IHg7IHgyIDwgeCArIGNvbHNwYW47IHgyKyspIHtcbiAgICAgICAgICBjb25zdCBjZWxscyA9IHJvd3NbeTJdLmNlbGxzO1xuICAgICAgICAgIGNlbGxzW3gyXSA9IHkyID09PSB5ICYmIHgyID09PSB4ID8gdGQgOiBzaGFsbG93JDEodGQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBjZWxsRXhpc3RzID0gKHRhYmxlLCB4LCB5KSA9PiB7XG4gICAgICBjb25zdCByb3dzID0gdGFibGUucm93cztcbiAgICAgIGNvbnN0IGNlbGxzID0gcm93c1t5XSA/IHJvd3NbeV0uY2VsbHMgOiBbXTtcbiAgICAgIHJldHVybiAhIWNlbGxzW3hdO1xuICAgIH07XG4gICAgY29uc3Qgc2tpcENlbGxzWCA9ICh0YWJsZSwgeCwgeSkgPT4ge1xuICAgICAgd2hpbGUgKGNlbGxFeGlzdHModGFibGUsIHgsIHkpKSB7XG4gICAgICAgIHgrKztcbiAgICAgIH1cbiAgICAgIHJldHVybiB4O1xuICAgIH07XG4gICAgY29uc3QgZ2V0V2lkdGggPSByb3dzID0+IHtcbiAgICAgIHJldHVybiBmb2xkbChyb3dzLCAoYWNjLCByb3cpID0+IHtcbiAgICAgICAgcmV0dXJuIHJvdy5jZWxscy5sZW5ndGggPiBhY2MgPyByb3cuY2VsbHMubGVuZ3RoIDogYWNjO1xuICAgICAgfSwgMCk7XG4gICAgfTtcbiAgICBjb25zdCBmaW5kRWxlbWVudFBvcyA9ICh0YWJsZSwgZWxlbWVudCkgPT4ge1xuICAgICAgY29uc3Qgcm93cyA9IHRhYmxlLnJvd3M7XG4gICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHJvd3MubGVuZ3RoOyB5KyspIHtcbiAgICAgICAgY29uc3QgY2VsbHMgPSByb3dzW3ldLmNlbGxzO1xuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IGNlbGxzLmxlbmd0aDsgeCsrKSB7XG4gICAgICAgICAgaWYgKGVxKGNlbGxzW3hdLCBlbGVtZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoY2VsbFBvc2l0aW9uKHgsIHkpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgfTtcbiAgICBjb25zdCBleHRyYWN0Um93cyA9ICh0YWJsZSwgc3gsIHN5LCBleCwgZXkpID0+IHtcbiAgICAgIGNvbnN0IG5ld1Jvd3MgPSBbXTtcbiAgICAgIGNvbnN0IHJvd3MgPSB0YWJsZS5yb3dzO1xuICAgICAgZm9yIChsZXQgeSA9IHN5OyB5IDw9IGV5OyB5KyspIHtcbiAgICAgICAgY29uc3QgY2VsbHMgPSByb3dzW3ldLmNlbGxzO1xuICAgICAgICBjb25zdCBzbGljZSA9IHN4IDwgZXggPyBjZWxscy5zbGljZShzeCwgZXggKyAxKSA6IGNlbGxzLnNsaWNlKGV4LCBzeCArIDEpO1xuICAgICAgICBuZXdSb3dzLnB1c2godGFibGVSb3cocm93c1t5XS5lbGVtZW50LCBzbGljZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld1Jvd3M7XG4gICAgfTtcbiAgICBjb25zdCBzdWJUYWJsZSA9ICh0YWJsZSwgc3RhcnRQb3MsIGVuZFBvcykgPT4ge1xuICAgICAgY29uc3Qgc3ggPSBzdGFydFBvcy54LCBzeSA9IHN0YXJ0UG9zLnk7XG4gICAgICBjb25zdCBleCA9IGVuZFBvcy54LCBleSA9IGVuZFBvcy55O1xuICAgICAgY29uc3QgbmV3Um93cyA9IHN5IDwgZXkgPyBleHRyYWN0Um93cyh0YWJsZSwgc3gsIHN5LCBleCwgZXkpIDogZXh0cmFjdFJvd3ModGFibGUsIHN4LCBleSwgZXgsIHN5KTtcbiAgICAgIHJldHVybiB0YWJsZU1vZGVsKHRhYmxlLmVsZW1lbnQsIGdldFdpZHRoKG5ld1Jvd3MpLCBuZXdSb3dzKTtcbiAgICB9O1xuICAgIGNvbnN0IGNyZWF0ZURvbVRhYmxlID0gKHRhYmxlLCByb3dzKSA9PiB7XG4gICAgICBjb25zdCB0YWJsZUVsZW1lbnQgPSBzaGFsbG93JDEodGFibGUuZWxlbWVudCk7XG4gICAgICBjb25zdCB0YWJsZUJvZHkgPSBTdWdhckVsZW1lbnQuZnJvbVRhZygndGJvZHknKTtcbiAgICAgIGFwcGVuZCh0YWJsZUJvZHksIHJvd3MpO1xuICAgICAgYXBwZW5kJDEodGFibGVFbGVtZW50LCB0YWJsZUJvZHkpO1xuICAgICAgcmV0dXJuIHRhYmxlRWxlbWVudDtcbiAgICB9O1xuICAgIGNvbnN0IG1vZGVsUm93c1RvRG9tUm93cyA9IHRhYmxlID0+IHtcbiAgICAgIHJldHVybiBtYXAkMyh0YWJsZS5yb3dzLCByb3cgPT4ge1xuICAgICAgICBjb25zdCBjZWxscyA9IG1hcCQzKHJvdy5jZWxscywgY2VsbCA9PiB7XG4gICAgICAgICAgY29uc3QgdGQgPSBkZWVwJDEoY2VsbCk7XG4gICAgICAgICAgcmVtb3ZlJGEodGQsICdjb2xzcGFuJyk7XG4gICAgICAgICAgcmVtb3ZlJGEodGQsICdyb3dzcGFuJyk7XG4gICAgICAgICAgcmV0dXJuIHRkO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdHIgPSBzaGFsbG93JDEocm93LmVsZW1lbnQpO1xuICAgICAgICBhcHBlbmQodHIsIGNlbGxzKTtcbiAgICAgICAgcmV0dXJuIHRyO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBmcm9tRG9tID0gdGFibGVFbG0gPT4ge1xuICAgICAgY29uc3QgdGFibGUgPSB0YWJsZU1vZGVsKHNoYWxsb3ckMSh0YWJsZUVsbSksIDAsIFtdKTtcbiAgICAgIGVhY2gkZyhkZXNjZW5kYW50cyh0YWJsZUVsbSwgJ3RyJyksICh0ciwgeSkgPT4ge1xuICAgICAgICBlYWNoJGcoZGVzY2VuZGFudHModHIsICd0ZCx0aCcpLCAodGQsIHgpID0+IHtcbiAgICAgICAgICBmaWxsb3V0KHRhYmxlLCBza2lwQ2VsbHNYKHRhYmxlLCB4LCB5KSwgeSwgdHIsIHRkKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0YWJsZU1vZGVsKHRhYmxlLmVsZW1lbnQsIGdldFdpZHRoKHRhYmxlLnJvd3MpLCB0YWJsZS5yb3dzKTtcbiAgICB9O1xuICAgIGNvbnN0IHRvRG9tID0gdGFibGUgPT4ge1xuICAgICAgcmV0dXJuIGNyZWF0ZURvbVRhYmxlKHRhYmxlLCBtb2RlbFJvd3NUb0RvbVJvd3ModGFibGUpKTtcbiAgICB9O1xuICAgIGNvbnN0IHN1YnNlY3Rpb24gPSAodGFibGUsIHN0YXJ0RWxlbWVudCwgZW5kRWxlbWVudCkgPT4ge1xuICAgICAgcmV0dXJuIGZpbmRFbGVtZW50UG9zKHRhYmxlLCBzdGFydEVsZW1lbnQpLmJpbmQoc3RhcnRQb3MgPT4ge1xuICAgICAgICByZXR1cm4gZmluZEVsZW1lbnRQb3ModGFibGUsIGVuZEVsZW1lbnQpLm1hcChlbmRQb3MgPT4ge1xuICAgICAgICAgIHJldHVybiBzdWJUYWJsZSh0YWJsZSwgc3RhcnRQb3MsIGVuZFBvcyk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGZpbmRQYXJlbnRMaXN0Q29udGFpbmVyID0gcGFyZW50cyA9PiBmaW5kJDIocGFyZW50cywgZWxtID0+IG5hbWUoZWxtKSA9PT0gJ3VsJyB8fCBuYW1lKGVsbSkgPT09ICdvbCcpO1xuICAgIGNvbnN0IGdldEZ1bGx5U2VsZWN0ZWRMaXN0V3JhcHBlcnMgPSAocGFyZW50cywgcm5nKSA9PiBmaW5kJDIocGFyZW50cywgZWxtID0+IG5hbWUoZWxtKSA9PT0gJ2xpJyAmJiBoYXNBbGxDb250ZW50c1NlbGVjdGVkKGVsbSwgcm5nKSkuZm9sZChjb25zdGFudChbXSksIF9saSA9PiBmaW5kUGFyZW50TGlzdENvbnRhaW5lcihwYXJlbnRzKS5tYXAobGlzdENvbnQgPT4ge1xuICAgICAgY29uc3QgbGlzdEVsbSA9IFN1Z2FyRWxlbWVudC5mcm9tVGFnKG5hbWUobGlzdENvbnQpKTtcbiAgICAgIGNvbnN0IGxpc3RTdHlsZXMgPSBmaWx0ZXIkNShnZXRBbGxSYXcobGlzdENvbnQpLCAoX3N0eWxlLCBuYW1lKSA9PiBzdGFydHNXaXRoKG5hbWUsICdsaXN0LXN0eWxlJykpO1xuICAgICAgc2V0QWxsKGxpc3RFbG0sIGxpc3RTdHlsZXMpO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgU3VnYXJFbGVtZW50LmZyb21UYWcoJ2xpJyksXG4gICAgICAgIGxpc3RFbG1cbiAgICAgIF07XG4gICAgfSkuZ2V0T3IoW10pKTtcbiAgICBjb25zdCB3cmFwID0gKGlubmVyRWxtLCBlbG1zKSA9PiB7XG4gICAgICBjb25zdCB3cmFwcGVkID0gZm9sZGwoZWxtcywgKGFjYywgZWxtKSA9PiB7XG4gICAgICAgIGFwcGVuZCQxKGVsbSwgYWNjKTtcbiAgICAgICAgcmV0dXJuIGVsbTtcbiAgICAgIH0sIGlubmVyRWxtKTtcbiAgICAgIHJldHVybiBlbG1zLmxlbmd0aCA+IDAgPyBmcm9tRWxlbWVudHMoW3dyYXBwZWRdKSA6IHdyYXBwZWQ7XG4gICAgfTtcbiAgICBjb25zdCBkaXJlY3RMaXN0V3JhcHBlcnMgPSBjb21tb25BbmNob3JDb250YWluZXIgPT4ge1xuICAgICAgaWYgKGlzTGlzdEl0ZW0oY29tbW9uQW5jaG9yQ29udGFpbmVyKSkge1xuICAgICAgICByZXR1cm4gcGFyZW50KGNvbW1vbkFuY2hvckNvbnRhaW5lcikuZmlsdGVyKGlzTGlzdCkuZm9sZChjb25zdGFudChbXSksIGxpc3RFbG0gPT4gW1xuICAgICAgICAgIGNvbW1vbkFuY2hvckNvbnRhaW5lcixcbiAgICAgICAgICBsaXN0RWxtXG4gICAgICAgIF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGlzTGlzdChjb21tb25BbmNob3JDb250YWluZXIpID8gW2NvbW1vbkFuY2hvckNvbnRhaW5lcl0gOiBbXTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGdldFdyYXBFbGVtZW50cyA9IChyb290Tm9kZSwgcm5nKSA9PiB7XG4gICAgICBjb25zdCBjb21tb25BbmNob3JDb250YWluZXIgPSBTdWdhckVsZW1lbnQuZnJvbURvbShybmcuY29tbW9uQW5jZXN0b3JDb250YWluZXIpO1xuICAgICAgY29uc3QgcGFyZW50cyA9IHBhcmVudHNBbmRTZWxmKGNvbW1vbkFuY2hvckNvbnRhaW5lciwgcm9vdE5vZGUpO1xuICAgICAgY29uc3Qgd3JhcEVsZW1lbnRzID0gZmlsdGVyJDYocGFyZW50cywgZWxtID0+IGlzSW5saW5lJDEoZWxtKSB8fCBpc0hlYWRpbmcoZWxtKSk7XG4gICAgICBjb25zdCBsaXN0V3JhcHBlcnMgPSBnZXRGdWxseVNlbGVjdGVkTGlzdFdyYXBwZXJzKHBhcmVudHMsIHJuZyk7XG4gICAgICBjb25zdCBhbGxXcmFwcGVycyA9IHdyYXBFbGVtZW50cy5jb25jYXQobGlzdFdyYXBwZXJzLmxlbmd0aCA/IGxpc3RXcmFwcGVycyA6IGRpcmVjdExpc3RXcmFwcGVycyhjb21tb25BbmNob3JDb250YWluZXIpKTtcbiAgICAgIHJldHVybiBtYXAkMyhhbGxXcmFwcGVycywgc2hhbGxvdyQxKTtcbiAgICB9O1xuICAgIGNvbnN0IGVtcHR5RnJhZ21lbnQgPSAoKSA9PiBmcm9tRWxlbWVudHMoW10pO1xuICAgIGNvbnN0IGdldEZyYWdtZW50RnJvbVJhbmdlID0gKHJvb3ROb2RlLCBybmcpID0+IHdyYXAoU3VnYXJFbGVtZW50LmZyb21Eb20ocm5nLmNsb25lQ29udGVudHMoKSksIGdldFdyYXBFbGVtZW50cyhyb290Tm9kZSwgcm5nKSk7XG4gICAgY29uc3QgZ2V0UGFyZW50VGFibGUgPSAocm9vdEVsbSwgY2VsbCkgPT4gYW5jZXN0b3IkMihjZWxsLCAndGFibGUnLCBjdXJyeShlcSwgcm9vdEVsbSkpO1xuICAgIGNvbnN0IGdldFRhYmxlRnJhZ21lbnQgPSAocm9vdE5vZGUsIHNlbGVjdGVkVGFibGVDZWxscykgPT4gZ2V0UGFyZW50VGFibGUocm9vdE5vZGUsIHNlbGVjdGVkVGFibGVDZWxsc1swXSkuYmluZCh0YWJsZUVsbSA9PiB7XG4gICAgICBjb25zdCBmaXJzdENlbGwgPSBzZWxlY3RlZFRhYmxlQ2VsbHNbMF07XG4gICAgICBjb25zdCBsYXN0Q2VsbCA9IHNlbGVjdGVkVGFibGVDZWxsc1tzZWxlY3RlZFRhYmxlQ2VsbHMubGVuZ3RoIC0gMV07XG4gICAgICBjb25zdCBmdWxsVGFibGVNb2RlbCA9IGZyb21Eb20odGFibGVFbG0pO1xuICAgICAgcmV0dXJuIHN1YnNlY3Rpb24oZnVsbFRhYmxlTW9kZWwsIGZpcnN0Q2VsbCwgbGFzdENlbGwpLm1hcChzZWN0aW9uZWRUYWJsZU1vZGVsID0+IGZyb21FbGVtZW50cyhbdG9Eb20oc2VjdGlvbmVkVGFibGVNb2RlbCldKSk7XG4gICAgfSkuZ2V0T3JUaHVuayhlbXB0eUZyYWdtZW50KTtcbiAgICBjb25zdCBnZXRTZWxlY3Rpb25GcmFnbWVudCA9IChyb290Tm9kZSwgcmFuZ2VzKSA9PiByYW5nZXMubGVuZ3RoID4gMCAmJiByYW5nZXNbMF0uY29sbGFwc2VkID8gZW1wdHlGcmFnbWVudCgpIDogZ2V0RnJhZ21lbnRGcm9tUmFuZ2Uocm9vdE5vZGUsIHJhbmdlc1swXSk7XG4gICAgY29uc3QgcmVhZCQzID0gKHJvb3ROb2RlLCByYW5nZXMpID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGVkQ2VsbHMgPSBnZXRDZWxsc0Zyb21FbGVtZW50T3JSYW5nZXMocmFuZ2VzLCByb290Tm9kZSk7XG4gICAgICByZXR1cm4gc2VsZWN0ZWRDZWxscy5sZW5ndGggPiAwID8gZ2V0VGFibGVGcmFnbWVudChyb290Tm9kZSwgc2VsZWN0ZWRDZWxscykgOiBnZXRTZWxlY3Rpb25GcmFnbWVudChyb290Tm9kZSwgcmFuZ2VzKTtcbiAgICB9O1xuXG4gICAgY29uc3QgaXNDb2xsYXBzaWJsZVdoaXRlc3BhY2UgPSAodGV4dCwgaW5kZXgpID0+IGluZGV4ID49IDAgJiYgaW5kZXggPCB0ZXh0Lmxlbmd0aCAmJiBpc1doaXRlU3BhY2UodGV4dC5jaGFyQXQoaW5kZXgpKTtcbiAgICBjb25zdCBnZXRJbm5lclRleHQgPSBiaW4gPT4ge1xuICAgICAgcmV0dXJuIHRyaW0kMShiaW4uaW5uZXJUZXh0KTtcbiAgICB9O1xuICAgIGNvbnN0IGdldENvbnRleHROb2RlTmFtZSA9IHBhcmVudEJsb2NrT3B0ID0+IHBhcmVudEJsb2NrT3B0Lm1hcChibG9jayA9PiBibG9jay5ub2RlTmFtZSkuZ2V0T3IoJ2RpdicpLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgZ2V0VGV4dENvbnRlbnQgPSBlZGl0b3IgPT4gT3B0aW9uYWwuZnJvbShlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpKS5tYXAocm5nID0+IHtcbiAgICAgIGNvbnN0IHBhcmVudEJsb2NrT3B0ID0gT3B0aW9uYWwuZnJvbShlZGl0b3IuZG9tLmdldFBhcmVudChybmcuY29tbW9uQW5jZXN0b3JDb250YWluZXIsIGVkaXRvci5kb20uaXNCbG9jaykpO1xuICAgICAgY29uc3QgYm9keSA9IGVkaXRvci5nZXRCb2R5KCk7XG4gICAgICBjb25zdCBjb250ZXh0Tm9kZU5hbWUgPSBnZXRDb250ZXh0Tm9kZU5hbWUocGFyZW50QmxvY2tPcHQpO1xuICAgICAgY29uc3QgYmluID0gZWRpdG9yLmRvbS5hZGQoYm9keSwgY29udGV4dE5vZGVOYW1lLCB7XG4gICAgICAgICdkYXRhLW1jZS1ib2d1cyc6ICdhbGwnLFxuICAgICAgICAnc3R5bGUnOiAnb3ZlcmZsb3c6IGhpZGRlbjsgb3BhY2l0eTogMDsnXG4gICAgICB9LCBybmcuY2xvbmVDb250ZW50cygpKTtcbiAgICAgIGNvbnN0IHRleHQgPSBnZXRJbm5lclRleHQoYmluKTtcbiAgICAgIGNvbnN0IG5vblJlbmRlcmVkVGV4dCA9IHRyaW0kMShiaW4udGV4dENvbnRlbnQpO1xuICAgICAgZWRpdG9yLmRvbS5yZW1vdmUoYmluKTtcbiAgICAgIGlmIChpc0NvbGxhcHNpYmxlV2hpdGVzcGFjZShub25SZW5kZXJlZFRleHQsIDApIHx8IGlzQ29sbGFwc2libGVXaGl0ZXNwYWNlKG5vblJlbmRlcmVkVGV4dCwgbm9uUmVuZGVyZWRUZXh0Lmxlbmd0aCAtIDEpKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudEJsb2NrID0gcGFyZW50QmxvY2tPcHQuZ2V0T3IoYm9keSk7XG4gICAgICAgIGNvbnN0IHBhcmVudEJsb2NrVGV4dCA9IGdldElubmVyVGV4dChwYXJlbnRCbG9jayk7XG4gICAgICAgIGNvbnN0IHRleHRJbmRleCA9IHBhcmVudEJsb2NrVGV4dC5pbmRleE9mKHRleHQpO1xuICAgICAgICBpZiAodGV4dEluZGV4ID09PSAtMSkge1xuICAgICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGhhc1Byb2NlZWRpbmdTcGFjZSA9IGlzQ29sbGFwc2libGVXaGl0ZXNwYWNlKHBhcmVudEJsb2NrVGV4dCwgdGV4dEluZGV4IC0gMSk7XG4gICAgICAgICAgY29uc3QgaGFzVHJhaWxpbmdTcGFjZSA9IGlzQ29sbGFwc2libGVXaGl0ZXNwYWNlKHBhcmVudEJsb2NrVGV4dCwgdGV4dEluZGV4ICsgdGV4dC5sZW5ndGgpO1xuICAgICAgICAgIHJldHVybiAoaGFzUHJvY2VlZGluZ1NwYWNlID8gJyAnIDogJycpICsgdGV4dCArIChoYXNUcmFpbGluZ1NwYWNlID8gJyAnIDogJycpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgIH1cbiAgICB9KS5nZXRPcignJyk7XG4gICAgY29uc3QgZ2V0U2VyaWFsaXplZENvbnRlbnQgPSAoZWRpdG9yLCBhcmdzKSA9PiB7XG4gICAgICBjb25zdCBybmcgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpLCB0bXBFbG0gPSBlZGl0b3IuZG9tLmNyZWF0ZSgnYm9keScpO1xuICAgICAgY29uc3Qgc2VsID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRTZWwoKTtcbiAgICAgIGNvbnN0IHJhbmdlcyA9IHByb2Nlc3NSYW5nZXMoZWRpdG9yLCBnZXRSYW5nZXMkMShzZWwpKTtcbiAgICAgIGNvbnN0IGZyYWdtZW50ID0gYXJncy5jb250ZXh0dWFsID8gcmVhZCQzKFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVkaXRvci5nZXRCb2R5KCkpLCByYW5nZXMpLmRvbSA6IHJuZy5jbG9uZUNvbnRlbnRzKCk7XG4gICAgICBpZiAoZnJhZ21lbnQpIHtcbiAgICAgICAgdG1wRWxtLmFwcGVuZENoaWxkKGZyYWdtZW50KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlZGl0b3Iuc2VsZWN0aW9uLnNlcmlhbGl6ZXIuc2VyaWFsaXplKHRtcEVsbSwgYXJncyk7XG4gICAgfTtcbiAgICBjb25zdCBleHRyYWN0U2VsZWN0ZWRDb250ZW50ID0gKGVkaXRvciwgYXJncykgPT4ge1xuICAgICAgaWYgKGFyZ3MuZm9ybWF0ID09PSAndGV4dCcpIHtcbiAgICAgICAgcmV0dXJuIGdldFRleHRDb250ZW50KGVkaXRvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjb250ZW50ID0gZ2V0U2VyaWFsaXplZENvbnRlbnQoZWRpdG9yLCBhcmdzKTtcbiAgICAgICAgaWYgKGFyZ3MuZm9ybWF0ID09PSAndHJlZScpIHtcbiAgICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZWRpdG9yLnNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpID8gJycgOiBjb250ZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBzZXR1cEFyZ3MkMyA9IChhcmdzLCBmb3JtYXQpID0+ICh7XG4gICAgICAuLi5hcmdzLFxuICAgICAgZm9ybWF0LFxuICAgICAgZ2V0OiB0cnVlLFxuICAgICAgc2VsZWN0aW9uOiB0cnVlLFxuICAgICAgZ2V0SW5uZXI6IHRydWVcbiAgICB9KTtcbiAgICBjb25zdCBnZXRTZWxlY3RlZENvbnRlbnRJbnRlcm5hbCA9IChlZGl0b3IsIGZvcm1hdCwgYXJncyA9IHt9KSA9PiB7XG4gICAgICBjb25zdCBkZWZhdWx0ZWRBcmdzID0gc2V0dXBBcmdzJDMoYXJncywgZm9ybWF0KTtcbiAgICAgIHJldHVybiBwcmVQcm9jZXNzR2V0Q29udGVudChlZGl0b3IsIGRlZmF1bHRlZEFyZ3MpLmZvbGQoaWRlbnRpdHksIHVwZGF0ZWRBcmdzID0+IHtcbiAgICAgICAgY29uc3QgY29udGVudCA9IGV4dHJhY3RTZWxlY3RlZENvbnRlbnQoZWRpdG9yLCB1cGRhdGVkQXJncyk7XG4gICAgICAgIHJldHVybiBwb3N0UHJvY2Vzc0dldENvbnRlbnQoZWRpdG9yLCBjb250ZW50LCB1cGRhdGVkQXJncyk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3QgS0VFUCA9IDAsIElOU0VSVCA9IDEsIERFTEVURSA9IDI7XG4gICAgY29uc3QgZGlmZiA9IChsZWZ0LCByaWdodCkgPT4ge1xuICAgICAgY29uc3Qgc2l6ZSA9IGxlZnQubGVuZ3RoICsgcmlnaHQubGVuZ3RoICsgMjtcbiAgICAgIGNvbnN0IHZEb3duID0gbmV3IEFycmF5KHNpemUpO1xuICAgICAgY29uc3QgdlVwID0gbmV3IEFycmF5KHNpemUpO1xuICAgICAgY29uc3Qgc25ha2UgPSAoc3RhcnQsIGVuZCwgZGlhZykgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgIGVuZCxcbiAgICAgICAgICBkaWFnXG4gICAgICAgIH07XG4gICAgICB9O1xuICAgICAgY29uc3QgYnVpbGRTY3JpcHQgPSAoc3RhcnQxLCBlbmQxLCBzdGFydDIsIGVuZDIsIHNjcmlwdCkgPT4ge1xuICAgICAgICBjb25zdCBtaWRkbGUgPSBnZXRNaWRkbGVTbmFrZShzdGFydDEsIGVuZDEsIHN0YXJ0MiwgZW5kMik7XG4gICAgICAgIGlmIChtaWRkbGUgPT09IG51bGwgfHwgbWlkZGxlLnN0YXJ0ID09PSBlbmQxICYmIG1pZGRsZS5kaWFnID09PSBlbmQxIC0gZW5kMiB8fCBtaWRkbGUuZW5kID09PSBzdGFydDEgJiYgbWlkZGxlLmRpYWcgPT09IHN0YXJ0MSAtIHN0YXJ0Mikge1xuICAgICAgICAgIGxldCBpID0gc3RhcnQxO1xuICAgICAgICAgIGxldCBqID0gc3RhcnQyO1xuICAgICAgICAgIHdoaWxlIChpIDwgZW5kMSB8fCBqIDwgZW5kMikge1xuICAgICAgICAgICAgaWYgKGkgPCBlbmQxICYmIGogPCBlbmQyICYmIGxlZnRbaV0gPT09IHJpZ2h0W2pdKSB7XG4gICAgICAgICAgICAgIHNjcmlwdC5wdXNoKFtcbiAgICAgICAgICAgICAgICBLRUVQLFxuICAgICAgICAgICAgICAgIGxlZnRbaV1cbiAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgICAgKytqO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGVuZDEgLSBzdGFydDEgPiBlbmQyIC0gc3RhcnQyKSB7XG4gICAgICAgICAgICAgICAgc2NyaXB0LnB1c2goW1xuICAgICAgICAgICAgICAgICAgREVMRVRFLFxuICAgICAgICAgICAgICAgICAgbGVmdFtpXVxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzY3JpcHQucHVzaChbXG4gICAgICAgICAgICAgICAgICBJTlNFUlQsXG4gICAgICAgICAgICAgICAgICByaWdodFtqXVxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICsrajtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBidWlsZFNjcmlwdChzdGFydDEsIG1pZGRsZS5zdGFydCwgc3RhcnQyLCBtaWRkbGUuc3RhcnQgLSBtaWRkbGUuZGlhZywgc2NyaXB0KTtcbiAgICAgICAgICBmb3IgKGxldCBpMiA9IG1pZGRsZS5zdGFydDsgaTIgPCBtaWRkbGUuZW5kOyArK2kyKSB7XG4gICAgICAgICAgICBzY3JpcHQucHVzaChbXG4gICAgICAgICAgICAgIEtFRVAsXG4gICAgICAgICAgICAgIGxlZnRbaTJdXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnVpbGRTY3JpcHQobWlkZGxlLmVuZCwgZW5kMSwgbWlkZGxlLmVuZCAtIG1pZGRsZS5kaWFnLCBlbmQyLCBzY3JpcHQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgYnVpbGRTbmFrZSA9IChzdGFydCwgZGlhZywgZW5kMSwgZW5kMikgPT4ge1xuICAgICAgICBsZXQgZW5kID0gc3RhcnQ7XG4gICAgICAgIHdoaWxlIChlbmQgLSBkaWFnIDwgZW5kMiAmJiBlbmQgPCBlbmQxICYmIGxlZnRbZW5kXSA9PT0gcmlnaHRbZW5kIC0gZGlhZ10pIHtcbiAgICAgICAgICArK2VuZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc25ha2Uoc3RhcnQsIGVuZCwgZGlhZyk7XG4gICAgICB9O1xuICAgICAgY29uc3QgZ2V0TWlkZGxlU25ha2UgPSAoc3RhcnQxLCBlbmQxLCBzdGFydDIsIGVuZDIpID0+IHtcbiAgICAgICAgY29uc3QgbSA9IGVuZDEgLSBzdGFydDE7XG4gICAgICAgIGNvbnN0IG4gPSBlbmQyIC0gc3RhcnQyO1xuICAgICAgICBpZiAobSA9PT0gMCB8fCBuID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVsdGEgPSBtIC0gbjtcbiAgICAgICAgY29uc3Qgc3VtID0gbiArIG07XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IChzdW0gJSAyID09PSAwID8gc3VtIDogc3VtICsgMSkgLyAyO1xuICAgICAgICB2RG93blsxICsgb2Zmc2V0XSA9IHN0YXJ0MTtcbiAgICAgICAgdlVwWzEgKyBvZmZzZXRdID0gZW5kMSArIDE7XG4gICAgICAgIGxldCBkLCBrLCBpLCB4LCB5O1xuICAgICAgICBmb3IgKGQgPSAwOyBkIDw9IG9mZnNldDsgKytkKSB7XG4gICAgICAgICAgZm9yIChrID0gLWQ7IGsgPD0gZDsgayArPSAyKSB7XG4gICAgICAgICAgICBpID0gayArIG9mZnNldDtcbiAgICAgICAgICAgIGlmIChrID09PSAtZCB8fCBrICE9PSBkICYmIHZEb3duW2kgLSAxXSA8IHZEb3duW2kgKyAxXSkge1xuICAgICAgICAgICAgICB2RG93bltpXSA9IHZEb3duW2kgKyAxXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZEb3duW2ldID0gdkRvd25baSAtIDFdICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHggPSB2RG93bltpXTtcbiAgICAgICAgICAgIHkgPSB4IC0gc3RhcnQxICsgc3RhcnQyIC0gaztcbiAgICAgICAgICAgIHdoaWxlICh4IDwgZW5kMSAmJiB5IDwgZW5kMiAmJiBsZWZ0W3hdID09PSByaWdodFt5XSkge1xuICAgICAgICAgICAgICB2RG93bltpXSA9ICsreDtcbiAgICAgICAgICAgICAgKyt5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlbHRhICUgMiAhPT0gMCAmJiBkZWx0YSAtIGQgPD0gayAmJiBrIDw9IGRlbHRhICsgZCkge1xuICAgICAgICAgICAgICBpZiAodlVwW2kgLSBkZWx0YV0gPD0gdkRvd25baV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnVpbGRTbmFrZSh2VXBbaSAtIGRlbHRhXSwgayArIHN0YXJ0MSAtIHN0YXJ0MiwgZW5kMSwgZW5kMik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChrID0gZGVsdGEgLSBkOyBrIDw9IGRlbHRhICsgZDsgayArPSAyKSB7XG4gICAgICAgICAgICBpID0gayArIG9mZnNldCAtIGRlbHRhO1xuICAgICAgICAgICAgaWYgKGsgPT09IGRlbHRhIC0gZCB8fCBrICE9PSBkZWx0YSArIGQgJiYgdlVwW2kgKyAxXSA8PSB2VXBbaSAtIDFdKSB7XG4gICAgICAgICAgICAgIHZVcFtpXSA9IHZVcFtpICsgMV0gLSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdlVwW2ldID0gdlVwW2kgLSAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHggPSB2VXBbaV0gLSAxO1xuICAgICAgICAgICAgeSA9IHggLSBzdGFydDEgKyBzdGFydDIgLSBrO1xuICAgICAgICAgICAgd2hpbGUgKHggPj0gc3RhcnQxICYmIHkgPj0gc3RhcnQyICYmIGxlZnRbeF0gPT09IHJpZ2h0W3ldKSB7XG4gICAgICAgICAgICAgIHZVcFtpXSA9IHgtLTtcbiAgICAgICAgICAgICAgeS0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlbHRhICUgMiA9PT0gMCAmJiAtZCA8PSBrICYmIGsgPD0gZCkge1xuICAgICAgICAgICAgICBpZiAodlVwW2ldIDw9IHZEb3duW2kgKyBkZWx0YV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnVpbGRTbmFrZSh2VXBbaV0sIGsgKyBzdGFydDEgLSBzdGFydDIsIGVuZDEsIGVuZDIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3Qgc2NyaXB0ID0gW107XG4gICAgICBidWlsZFNjcmlwdCgwLCBsZWZ0Lmxlbmd0aCwgMCwgcmlnaHQubGVuZ3RoLCBzY3JpcHQpO1xuICAgICAgcmV0dXJuIHNjcmlwdDtcbiAgICB9O1xuXG4gICAgY29uc3QgZ2V0T3V0ZXJIdG1sID0gZWxtID0+IHtcbiAgICAgIGlmIChpc0VsZW1lbnQkNihlbG0pKSB7XG4gICAgICAgIHJldHVybiBlbG0ub3V0ZXJIVE1MO1xuICAgICAgfSBlbHNlIGlmIChpc1RleHQkOChlbG0pKSB7XG4gICAgICAgIHJldHVybiBFbnRpdGllcy5lbmNvZGVSYXcoZWxtLmRhdGEsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNDb21tZW50KGVsbSkpIHtcbiAgICAgICAgcmV0dXJuICc8IS0tJyArIGVsbS5kYXRhICsgJy0tPic7XG4gICAgICB9XG4gICAgICByZXR1cm4gJyc7XG4gICAgfTtcbiAgICBjb25zdCBjcmVhdGVGcmFnbWVudCA9IGh0bWwgPT4ge1xuICAgICAgbGV0IG5vZGU7XG4gICAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGNvbnN0IGZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICBpZiAoaHRtbCkge1xuICAgICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChub2RlID0gY29udGFpbmVyLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgZnJhZy5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcmFnO1xuICAgIH07XG4gICAgY29uc3QgaW5zZXJ0QXQgPSAoZWxtLCBodG1sLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgZnJhZ21lbnQgPSBjcmVhdGVGcmFnbWVudChodG1sKTtcbiAgICAgIGlmIChlbG0uaGFzQ2hpbGROb2RlcygpICYmIGluZGV4IDwgZWxtLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGVsbS5jaGlsZE5vZGVzW2luZGV4XTtcbiAgICAgICAgdGFyZ2V0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGZyYWdtZW50LCB0YXJnZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxtLmFwcGVuZENoaWxkKGZyYWdtZW50KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlbW92ZUF0ID0gKGVsbSwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChlbG0uaGFzQ2hpbGROb2RlcygpICYmIGluZGV4IDwgZWxtLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGVsbS5jaGlsZE5vZGVzW2luZGV4XTtcbiAgICAgICAgdGFyZ2V0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGFwcGx5RGlmZiA9IChkaWZmLCBlbG0pID0+IHtcbiAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICBlYWNoJGcoZGlmZiwgYWN0aW9uID0+IHtcbiAgICAgICAgaWYgKGFjdGlvblswXSA9PT0gS0VFUCkge1xuICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgIH0gZWxzZSBpZiAoYWN0aW9uWzBdID09PSBJTlNFUlQpIHtcbiAgICAgICAgICBpbnNlcnRBdChlbG0sIGFjdGlvblsxXSwgaW5kZXgpO1xuICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgIH0gZWxzZSBpZiAoYWN0aW9uWzBdID09PSBERUxFVEUpIHtcbiAgICAgICAgICByZW1vdmVBdChlbG0sIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCByZWFkJDIgPSBlbG0gPT4ge1xuICAgICAgcmV0dXJuIGZpbHRlciQ2KG1hcCQzKGZyb20oZWxtLmNoaWxkTm9kZXMpLCBnZXRPdXRlckh0bWwpLCBpdGVtID0+IHtcbiAgICAgICAgcmV0dXJuIGl0ZW0ubGVuZ3RoID4gMDtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3Qgd3JpdGUgPSAoZnJhZ21lbnRzLCBlbG0pID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRGcmFnbWVudHMgPSBtYXAkMyhmcm9tKGVsbS5jaGlsZE5vZGVzKSwgZ2V0T3V0ZXJIdG1sKTtcbiAgICAgIGFwcGx5RGlmZihkaWZmKGN1cnJlbnRGcmFnbWVudHMsIGZyYWdtZW50cyksIGVsbSk7XG4gICAgICByZXR1cm4gZWxtO1xuICAgIH07XG5cbiAgICBjb25zdCBsYXp5VGVtcERvY3VtZW50ID0gY2FjaGVkKCgpID0+IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCgndW5kbycpKTtcbiAgICBjb25zdCBoYXNJZnJhbWVzID0gaHRtbCA9PiB7XG4gICAgICByZXR1cm4gaHRtbC5pbmRleE9mKCc8L2lmcmFtZT4nKSAhPT0gLTE7XG4gICAgfTtcbiAgICBjb25zdCBjcmVhdGVGcmFnbWVudGVkTGV2ZWwgPSBmcmFnbWVudHMgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2ZyYWdtZW50ZWQnLFxuICAgICAgICBmcmFnbWVudHMsXG4gICAgICAgIGNvbnRlbnQ6ICcnLFxuICAgICAgICBib29rbWFyazogbnVsbCxcbiAgICAgICAgYmVmb3JlQm9va21hcms6IG51bGxcbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBjcmVhdGVDb21wbGV0ZUxldmVsID0gY29udGVudCA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnY29tcGxldGUnLFxuICAgICAgICBmcmFnbWVudHM6IG51bGwsXG4gICAgICAgIGNvbnRlbnQsXG4gICAgICAgIGJvb2ttYXJrOiBudWxsLFxuICAgICAgICBiZWZvcmVCb29rbWFyazogbnVsbFxuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IGNyZWF0ZUZyb21FZGl0b3IgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgZnJhZ21lbnRzID0gcmVhZCQyKGVkaXRvci5nZXRCb2R5KCkpO1xuICAgICAgY29uc3QgdHJpbW1lZEZyYWdtZW50cyA9IGJpbmQkMyhmcmFnbWVudHMsIGh0bWwgPT4ge1xuICAgICAgICBjb25zdCB0cmltbWVkID0gdHJpbUludGVybmFsKGVkaXRvci5zZXJpYWxpemVyLCBodG1sKTtcbiAgICAgICAgcmV0dXJuIHRyaW1tZWQubGVuZ3RoID4gMCA/IFt0cmltbWVkXSA6IFtdO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBjb250ZW50ID0gdHJpbW1lZEZyYWdtZW50cy5qb2luKCcnKTtcbiAgICAgIHJldHVybiBoYXNJZnJhbWVzKGNvbnRlbnQpID8gY3JlYXRlRnJhZ21lbnRlZExldmVsKHRyaW1tZWRGcmFnbWVudHMpIDogY3JlYXRlQ29tcGxldGVMZXZlbChjb250ZW50KTtcbiAgICB9O1xuICAgIGNvbnN0IGFwcGx5VG9FZGl0b3IgPSAoZWRpdG9yLCBsZXZlbCwgYmVmb3JlKSA9PiB7XG4gICAgICBjb25zdCBib29rbWFyayA9IGJlZm9yZSA/IGxldmVsLmJlZm9yZUJvb2ttYXJrIDogbGV2ZWwuYm9va21hcms7XG4gICAgICBpZiAobGV2ZWwudHlwZSA9PT0gJ2ZyYWdtZW50ZWQnKSB7XG4gICAgICAgIHdyaXRlKGxldmVsLmZyYWdtZW50cywgZWRpdG9yLmdldEJvZHkoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlZGl0b3Iuc2V0Q29udGVudChsZXZlbC5jb250ZW50LCB7XG4gICAgICAgICAgZm9ybWF0OiAncmF3JyxcbiAgICAgICAgICBub19zZWxlY3Rpb246IGlzTm9uTnVsbGFibGUoYm9va21hcmspICYmIGlzUGF0aEJvb2ttYXJrKGJvb2ttYXJrKSA/ICFib29rbWFyay5pc0Zha2VDYXJldCA6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBlZGl0b3Iuc2VsZWN0aW9uLm1vdmVUb0Jvb2ttYXJrKGJvb2ttYXJrKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldExldmVsQ29udGVudCA9IGxldmVsID0+IHtcbiAgICAgIHJldHVybiBsZXZlbC50eXBlID09PSAnZnJhZ21lbnRlZCcgPyBsZXZlbC5mcmFnbWVudHMuam9pbignJykgOiBsZXZlbC5jb250ZW50O1xuICAgIH07XG4gICAgY29uc3QgZ2V0Q2xlYW5MZXZlbENvbnRlbnQgPSBsZXZlbCA9PiB7XG4gICAgICBjb25zdCBlbG0gPSBTdWdhckVsZW1lbnQuZnJvbVRhZygnYm9keScsIGxhenlUZW1wRG9jdW1lbnQoKSk7XG4gICAgICBzZXQoZWxtLCBnZXRMZXZlbENvbnRlbnQobGV2ZWwpKTtcbiAgICAgIGVhY2gkZyhkZXNjZW5kYW50cyhlbG0sICcqW2RhdGEtbWNlLWJvZ3VzXScpLCB1bndyYXApO1xuICAgICAgcmV0dXJuIGdldCQ2KGVsbSk7XG4gICAgfTtcbiAgICBjb25zdCBoYXNFcXVhbENvbnRlbnQgPSAobGV2ZWwxLCBsZXZlbDIpID0+IGdldExldmVsQ29udGVudChsZXZlbDEpID09PSBnZXRMZXZlbENvbnRlbnQobGV2ZWwyKTtcbiAgICBjb25zdCBoYXNFcXVhbENsZWFuZWRDb250ZW50ID0gKGxldmVsMSwgbGV2ZWwyKSA9PiBnZXRDbGVhbkxldmVsQ29udGVudChsZXZlbDEpID09PSBnZXRDbGVhbkxldmVsQ29udGVudChsZXZlbDIpO1xuICAgIGNvbnN0IGlzRXEkMSA9IChsZXZlbDEsIGxldmVsMikgPT4ge1xuICAgICAgaWYgKCFsZXZlbDEgfHwgIWxldmVsMikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGhhc0VxdWFsQ29udGVudChsZXZlbDEsIGxldmVsMikpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaGFzRXF1YWxDbGVhbmVkQ29udGVudChsZXZlbDEsIGxldmVsMik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGlzVW5sb2NrZWQgPSBsb2NrcyA9PiBsb2Nrcy5nZXQoKSA9PT0gMDtcblxuICAgIGNvbnN0IHNldFR5cGluZyA9ICh1bmRvTWFuYWdlciwgdHlwaW5nLCBsb2NrcykgPT4ge1xuICAgICAgaWYgKGlzVW5sb2NrZWQobG9ja3MpKSB7XG4gICAgICAgIHVuZG9NYW5hZ2VyLnR5cGluZyA9IHR5cGluZztcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGVuZFR5cGluZyA9ICh1bmRvTWFuYWdlciwgbG9ja3MpID0+IHtcbiAgICAgIGlmICh1bmRvTWFuYWdlci50eXBpbmcpIHtcbiAgICAgICAgc2V0VHlwaW5nKHVuZG9NYW5hZ2VyLCBmYWxzZSwgbG9ja3MpO1xuICAgICAgICB1bmRvTWFuYWdlci5hZGQoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGVuZFR5cGluZ0xldmVsSWdub3JlTG9ja3MgPSB1bmRvTWFuYWdlciA9PiB7XG4gICAgICBpZiAodW5kb01hbmFnZXIudHlwaW5nKSB7XG4gICAgICAgIHVuZG9NYW5hZ2VyLnR5cGluZyA9IGZhbHNlO1xuICAgICAgICB1bmRvTWFuYWdlci5hZGQoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgYmVmb3JlQ2hhbmdlJDEgPSAoZWRpdG9yLCBsb2NrcywgYmVmb3JlQm9va21hcmspID0+IHtcbiAgICAgIGlmIChpc1VubG9ja2VkKGxvY2tzKSkge1xuICAgICAgICBiZWZvcmVCb29rbWFyay5zZXQoZ2V0VW5kb0Jvb2ttYXJrKGVkaXRvci5zZWxlY3Rpb24pKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGFkZFVuZG9MZXZlbCQxID0gKGVkaXRvciwgdW5kb01hbmFnZXIsIGluZGV4LCBsb2NrcywgYmVmb3JlQm9va21hcmssIGxldmVsLCBldmVudCkgPT4ge1xuICAgICAgY29uc3QgY3VycmVudExldmVsID0gY3JlYXRlRnJvbUVkaXRvcihlZGl0b3IpO1xuICAgICAgbGV2ZWwgPSBsZXZlbCB8fCB7fTtcbiAgICAgIGxldmVsID0gVG9vbHMuZXh0ZW5kKGxldmVsLCBjdXJyZW50TGV2ZWwpO1xuICAgICAgaWYgKGlzVW5sb2NrZWQobG9ja3MpID09PSBmYWxzZSB8fCBlZGl0b3IucmVtb3ZlZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxhc3RMZXZlbCA9IHVuZG9NYW5hZ2VyLmRhdGFbaW5kZXguZ2V0KCldO1xuICAgICAgaWYgKGVkaXRvci5kaXNwYXRjaCgnQmVmb3JlQWRkVW5kbycsIHtcbiAgICAgICAgICBsZXZlbCxcbiAgICAgICAgICBsYXN0TGV2ZWwsXG4gICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcbiAgICAgICAgfSkuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAobGFzdExldmVsICYmIGlzRXEkMShsYXN0TGV2ZWwsIGxldmVsKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICh1bmRvTWFuYWdlci5kYXRhW2luZGV4LmdldCgpXSkge1xuICAgICAgICBiZWZvcmVCb29rbWFyay5nZXQoKS5lYWNoKGJtID0+IHtcbiAgICAgICAgICB1bmRvTWFuYWdlci5kYXRhW2luZGV4LmdldCgpXS5iZWZvcmVCb29rbWFyayA9IGJtO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGN1c3RvbVVuZG9SZWRvTGV2ZWxzID0gZ2V0Q3VzdG9tVW5kb1JlZG9MZXZlbHMoZWRpdG9yKTtcbiAgICAgIGlmIChjdXN0b21VbmRvUmVkb0xldmVscykge1xuICAgICAgICBpZiAodW5kb01hbmFnZXIuZGF0YS5sZW5ndGggPiBjdXN0b21VbmRvUmVkb0xldmVscykge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdW5kb01hbmFnZXIuZGF0YS5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIHVuZG9NYW5hZ2VyLmRhdGFbaV0gPSB1bmRvTWFuYWdlci5kYXRhW2kgKyAxXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdW5kb01hbmFnZXIuZGF0YS5sZW5ndGgtLTtcbiAgICAgICAgICBpbmRleC5zZXQodW5kb01hbmFnZXIuZGF0YS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXZlbC5ib29rbWFyayA9IGdldFVuZG9Cb29rbWFyayhlZGl0b3Iuc2VsZWN0aW9uKTtcbiAgICAgIGlmIChpbmRleC5nZXQoKSA8IHVuZG9NYW5hZ2VyLmRhdGEubGVuZ3RoIC0gMSkge1xuICAgICAgICB1bmRvTWFuYWdlci5kYXRhLmxlbmd0aCA9IGluZGV4LmdldCgpICsgMTtcbiAgICAgIH1cbiAgICAgIHVuZG9NYW5hZ2VyLmRhdGEucHVzaChsZXZlbCk7XG4gICAgICBpbmRleC5zZXQodW5kb01hbmFnZXIuZGF0YS5sZW5ndGggLSAxKTtcbiAgICAgIGNvbnN0IGFyZ3MgPSB7XG4gICAgICAgIGxldmVsLFxuICAgICAgICBsYXN0TGV2ZWwsXG4gICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50XG4gICAgICB9O1xuICAgICAgaWYgKGluZGV4LmdldCgpID4gMCkge1xuICAgICAgICBlZGl0b3Iuc2V0RGlydHkodHJ1ZSk7XG4gICAgICAgIGVkaXRvci5kaXNwYXRjaCgnQWRkVW5kbycsIGFyZ3MpO1xuICAgICAgICBlZGl0b3IuZGlzcGF0Y2goJ2NoYW5nZScsIGFyZ3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWRpdG9yLmRpc3BhdGNoKCdBZGRVbmRvJywgYXJncyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGV2ZWw7XG4gICAgfTtcbiAgICBjb25zdCBjbGVhciQxID0gKGVkaXRvciwgdW5kb01hbmFnZXIsIGluZGV4KSA9PiB7XG4gICAgICB1bmRvTWFuYWdlci5kYXRhID0gW107XG4gICAgICBpbmRleC5zZXQoMCk7XG4gICAgICB1bmRvTWFuYWdlci50eXBpbmcgPSBmYWxzZTtcbiAgICAgIGVkaXRvci5kaXNwYXRjaCgnQ2xlYXJVbmRvcycpO1xuICAgIH07XG4gICAgY29uc3QgZXh0cmEkMSA9IChlZGl0b3IsIHVuZG9NYW5hZ2VyLCBpbmRleCwgY2FsbGJhY2sxLCBjYWxsYmFjazIpID0+IHtcbiAgICAgIGlmICh1bmRvTWFuYWdlci50cmFuc2FjdChjYWxsYmFjazEpKSB7XG4gICAgICAgIGNvbnN0IGJvb2ttYXJrID0gdW5kb01hbmFnZXIuZGF0YVtpbmRleC5nZXQoKV0uYm9va21hcms7XG4gICAgICAgIGNvbnN0IGxhc3RMZXZlbCA9IHVuZG9NYW5hZ2VyLmRhdGFbaW5kZXguZ2V0KCkgLSAxXTtcbiAgICAgICAgYXBwbHlUb0VkaXRvcihlZGl0b3IsIGxhc3RMZXZlbCwgdHJ1ZSk7XG4gICAgICAgIGlmICh1bmRvTWFuYWdlci50cmFuc2FjdChjYWxsYmFjazIpKSB7XG4gICAgICAgICAgdW5kb01hbmFnZXIuZGF0YVtpbmRleC5nZXQoKSAtIDFdLmJlZm9yZUJvb2ttYXJrID0gYm9va21hcms7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlZG8kMSA9IChlZGl0b3IsIGluZGV4LCBkYXRhKSA9PiB7XG4gICAgICBsZXQgbGV2ZWw7XG4gICAgICBpZiAoaW5kZXguZ2V0KCkgPCBkYXRhLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgaW5kZXguc2V0KGluZGV4LmdldCgpICsgMSk7XG4gICAgICAgIGxldmVsID0gZGF0YVtpbmRleC5nZXQoKV07XG4gICAgICAgIGFwcGx5VG9FZGl0b3IoZWRpdG9yLCBsZXZlbCwgZmFsc2UpO1xuICAgICAgICBlZGl0b3Iuc2V0RGlydHkodHJ1ZSk7XG4gICAgICAgIGVkaXRvci5kaXNwYXRjaCgnUmVkbycsIHsgbGV2ZWwgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGV2ZWw7XG4gICAgfTtcbiAgICBjb25zdCB1bmRvJDEgPSAoZWRpdG9yLCB1bmRvTWFuYWdlciwgbG9ja3MsIGluZGV4KSA9PiB7XG4gICAgICBsZXQgbGV2ZWw7XG4gICAgICBpZiAodW5kb01hbmFnZXIudHlwaW5nKSB7XG4gICAgICAgIHVuZG9NYW5hZ2VyLmFkZCgpO1xuICAgICAgICB1bmRvTWFuYWdlci50eXBpbmcgPSBmYWxzZTtcbiAgICAgICAgc2V0VHlwaW5nKHVuZG9NYW5hZ2VyLCBmYWxzZSwgbG9ja3MpO1xuICAgICAgfVxuICAgICAgaWYgKGluZGV4LmdldCgpID4gMCkge1xuICAgICAgICBpbmRleC5zZXQoaW5kZXguZ2V0KCkgLSAxKTtcbiAgICAgICAgbGV2ZWwgPSB1bmRvTWFuYWdlci5kYXRhW2luZGV4LmdldCgpXTtcbiAgICAgICAgYXBwbHlUb0VkaXRvcihlZGl0b3IsIGxldmVsLCB0cnVlKTtcbiAgICAgICAgZWRpdG9yLnNldERpcnR5KHRydWUpO1xuICAgICAgICBlZGl0b3IuZGlzcGF0Y2goJ1VuZG8nLCB7IGxldmVsIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxldmVsO1xuICAgIH07XG4gICAgY29uc3QgcmVzZXQkMSA9IHVuZG9NYW5hZ2VyID0+IHtcbiAgICAgIHVuZG9NYW5hZ2VyLmNsZWFyKCk7XG4gICAgICB1bmRvTWFuYWdlci5hZGQoKTtcbiAgICB9O1xuICAgIGNvbnN0IGhhc1VuZG8kMSA9IChlZGl0b3IsIHVuZG9NYW5hZ2VyLCBpbmRleCkgPT4gaW5kZXguZ2V0KCkgPiAwIHx8IHVuZG9NYW5hZ2VyLnR5cGluZyAmJiB1bmRvTWFuYWdlci5kYXRhWzBdICYmICFpc0VxJDEoY3JlYXRlRnJvbUVkaXRvcihlZGl0b3IpLCB1bmRvTWFuYWdlci5kYXRhWzBdKTtcbiAgICBjb25zdCBoYXNSZWRvJDEgPSAodW5kb01hbmFnZXIsIGluZGV4KSA9PiBpbmRleC5nZXQoKSA8IHVuZG9NYW5hZ2VyLmRhdGEubGVuZ3RoIC0gMSAmJiAhdW5kb01hbmFnZXIudHlwaW5nO1xuICAgIGNvbnN0IHRyYW5zYWN0JDEgPSAodW5kb01hbmFnZXIsIGxvY2tzLCBjYWxsYmFjaykgPT4ge1xuICAgICAgZW5kVHlwaW5nKHVuZG9NYW5hZ2VyLCBsb2Nrcyk7XG4gICAgICB1bmRvTWFuYWdlci5iZWZvcmVDaGFuZ2UoKTtcbiAgICAgIHVuZG9NYW5hZ2VyLmlnbm9yZShjYWxsYmFjayk7XG4gICAgICByZXR1cm4gdW5kb01hbmFnZXIuYWRkKCk7XG4gICAgfTtcbiAgICBjb25zdCBpZ25vcmUkMSA9IChsb2NrcywgY2FsbGJhY2spID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxvY2tzLnNldChsb2Nrcy5nZXQoKSArIDEpO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgbG9ja3Muc2V0KGxvY2tzLmdldCgpIC0gMSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGFkZFZpc3VhbEludGVybmFsID0gKGVkaXRvciwgZWxtKSA9PiB7XG4gICAgICBjb25zdCBkb20gPSBlZGl0b3IuZG9tO1xuICAgICAgY29uc3Qgc2NvcGUgPSBpc05vbk51bGxhYmxlKGVsbSkgPyBlbG0gOiBlZGl0b3IuZ2V0Qm9keSgpO1xuICAgICAgaWYgKGlzVW5kZWZpbmVkKGVkaXRvci5oYXNWaXN1YWwpKSB7XG4gICAgICAgIGVkaXRvci5oYXNWaXN1YWwgPSBpc1Zpc3VhbEFpZHNFbmFibGVkKGVkaXRvcik7XG4gICAgICB9XG4gICAgICBlYWNoJGcoZG9tLnNlbGVjdCgndGFibGUsYScsIHNjb3BlKSwgbWF0Y2hlZEVsbSA9PiB7XG4gICAgICAgIHN3aXRjaCAobWF0Y2hlZEVsbS5ub2RlTmFtZSkge1xuICAgICAgICBjYXNlICdUQUJMRSc6XG4gICAgICAgICAgY29uc3QgY2xzID0gZ2V0VmlzdWFsQWlkc1RhYmxlQ2xhc3MoZWRpdG9yKTtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IGRvbS5nZXRBdHRyaWIobWF0Y2hlZEVsbSwgJ2JvcmRlcicpO1xuICAgICAgICAgIGlmICgoIXZhbHVlIHx8IHZhbHVlID09PSAnMCcpICYmIGVkaXRvci5oYXNWaXN1YWwpIHtcbiAgICAgICAgICAgIGRvbS5hZGRDbGFzcyhtYXRjaGVkRWxtLCBjbHMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb20ucmVtb3ZlQ2xhc3MobWF0Y2hlZEVsbSwgY2xzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAgIGlmICghZG9tLmdldEF0dHJpYihtYXRjaGVkRWxtLCAnaHJlZicpKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGRvbS5nZXRBdHRyaWIobWF0Y2hlZEVsbSwgJ25hbWUnKSB8fCBtYXRjaGVkRWxtLmlkO1xuICAgICAgICAgICAgY29uc3QgY2xzID0gZ2V0VmlzdWFsQWlkc0FuY2hvckNsYXNzKGVkaXRvcik7XG4gICAgICAgICAgICBpZiAodmFsdWUgJiYgZWRpdG9yLmhhc1Zpc3VhbCkge1xuICAgICAgICAgICAgICBkb20uYWRkQ2xhc3MobWF0Y2hlZEVsbSwgY2xzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRvbS5yZW1vdmVDbGFzcyhtYXRjaGVkRWxtLCBjbHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBlZGl0b3IuZGlzcGF0Y2goJ1Zpc3VhbEFpZCcsIHtcbiAgICAgICAgZWxlbWVudDogZWxtLFxuICAgICAgICBoYXNWaXN1YWw6IGVkaXRvci5oYXNWaXN1YWxcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCBtYWtlUGxhaW5BZGFwdG9yID0gZWRpdG9yID0+ICh7XG4gICAgICBpbml0OiB7IGJpbmRFdmVudHM6IG5vb3AgfSxcbiAgICAgIHVuZG9NYW5hZ2VyOiB7XG4gICAgICAgIGJlZm9yZUNoYW5nZTogKGxvY2tzLCBiZWZvcmVCb29rbWFyaykgPT4gYmVmb3JlQ2hhbmdlJDEoZWRpdG9yLCBsb2NrcywgYmVmb3JlQm9va21hcmspLFxuICAgICAgICBhZGQ6ICh1bmRvTWFuYWdlciwgaW5kZXgsIGxvY2tzLCBiZWZvcmVCb29rbWFyaywgbGV2ZWwsIGV2ZW50KSA9PiBhZGRVbmRvTGV2ZWwkMShlZGl0b3IsIHVuZG9NYW5hZ2VyLCBpbmRleCwgbG9ja3MsIGJlZm9yZUJvb2ttYXJrLCBsZXZlbCwgZXZlbnQpLFxuICAgICAgICB1bmRvOiAodW5kb01hbmFnZXIsIGxvY2tzLCBpbmRleCkgPT4gdW5kbyQxKGVkaXRvciwgdW5kb01hbmFnZXIsIGxvY2tzLCBpbmRleCksXG4gICAgICAgIHJlZG86IChpbmRleCwgZGF0YSkgPT4gcmVkbyQxKGVkaXRvciwgaW5kZXgsIGRhdGEpLFxuICAgICAgICBjbGVhcjogKHVuZG9NYW5hZ2VyLCBpbmRleCkgPT4gY2xlYXIkMShlZGl0b3IsIHVuZG9NYW5hZ2VyLCBpbmRleCksXG4gICAgICAgIHJlc2V0OiB1bmRvTWFuYWdlciA9PiByZXNldCQxKHVuZG9NYW5hZ2VyKSxcbiAgICAgICAgaGFzVW5kbzogKHVuZG9NYW5hZ2VyLCBpbmRleCkgPT4gaGFzVW5kbyQxKGVkaXRvciwgdW5kb01hbmFnZXIsIGluZGV4KSxcbiAgICAgICAgaGFzUmVkbzogKHVuZG9NYW5hZ2VyLCBpbmRleCkgPT4gaGFzUmVkbyQxKHVuZG9NYW5hZ2VyLCBpbmRleCksXG4gICAgICAgIHRyYW5zYWN0OiAodW5kb01hbmFnZXIsIGxvY2tzLCBjYWxsYmFjaykgPT4gdHJhbnNhY3QkMSh1bmRvTWFuYWdlciwgbG9ja3MsIGNhbGxiYWNrKSxcbiAgICAgICAgaWdub3JlOiAobG9ja3MsIGNhbGxiYWNrKSA9PiBpZ25vcmUkMShsb2NrcywgY2FsbGJhY2spLFxuICAgICAgICBleHRyYTogKHVuZG9NYW5hZ2VyLCBpbmRleCwgY2FsbGJhY2sxLCBjYWxsYmFjazIpID0+IGV4dHJhJDEoZWRpdG9yLCB1bmRvTWFuYWdlciwgaW5kZXgsIGNhbGxiYWNrMSwgY2FsbGJhY2syKVxuICAgICAgfSxcbiAgICAgIGZvcm1hdHRlcjoge1xuICAgICAgICBtYXRjaDogKG5hbWUsIHZhcnMsIG5vZGUsIHNpbWlsYXIpID0+IG1hdGNoJDIoZWRpdG9yLCBuYW1lLCB2YXJzLCBub2RlLCBzaW1pbGFyKSxcbiAgICAgICAgbWF0Y2hBbGw6IChuYW1lcywgdmFycykgPT4gbWF0Y2hBbGwoZWRpdG9yLCBuYW1lcywgdmFycyksXG4gICAgICAgIG1hdGNoTm9kZTogKG5vZGUsIG5hbWUsIHZhcnMsIHNpbWlsYXIpID0+IG1hdGNoTm9kZShlZGl0b3IsIG5vZGUsIG5hbWUsIHZhcnMsIHNpbWlsYXIpLFxuICAgICAgICBjYW5BcHBseTogbmFtZSA9PiBjYW5BcHBseShlZGl0b3IsIG5hbWUpLFxuICAgICAgICBjbG9zZXN0OiBuYW1lcyA9PiBjbG9zZXN0JDEoZWRpdG9yLCBuYW1lcyksXG4gICAgICAgIGFwcGx5OiAobmFtZSwgdmFycywgbm9kZSkgPT4gYXBwbHlGb3JtYXQkMShlZGl0b3IsIG5hbWUsIHZhcnMsIG5vZGUpLFxuICAgICAgICByZW1vdmU6IChuYW1lLCB2YXJzLCBub2RlLCBzaW1pbGFyKSA9PiByZW1vdmUkMihlZGl0b3IsIG5hbWUsIHZhcnMsIG5vZGUsIHNpbWlsYXIpLFxuICAgICAgICB0b2dnbGU6IChuYW1lLCB2YXJzLCBub2RlKSA9PiB0b2dnbGUoZWRpdG9yLCBuYW1lLCB2YXJzLCBub2RlKSxcbiAgICAgICAgZm9ybWF0Q2hhbmdlZDogKHJlZ2lzdGVyZWRGb3JtYXRMaXN0ZW5lcnMsIGZvcm1hdHMsIGNhbGxiYWNrLCBzaW1pbGFyLCB2YXJzKSA9PiBmb3JtYXRDaGFuZ2VkSW50ZXJuYWwoZWRpdG9yLCByZWdpc3RlcmVkRm9ybWF0TGlzdGVuZXJzLCBmb3JtYXRzLCBjYWxsYmFjaywgc2ltaWxhciwgdmFycylcbiAgICAgIH0sXG4gICAgICBlZGl0b3I6IHtcbiAgICAgICAgZ2V0Q29udGVudDogYXJncyA9PiBnZXRDb250ZW50SW50ZXJuYWwoZWRpdG9yLCBhcmdzKSxcbiAgICAgICAgc2V0Q29udGVudDogKGNvbnRlbnQsIGFyZ3MpID0+IHNldENvbnRlbnRJbnRlcm5hbChlZGl0b3IsIGNvbnRlbnQsIGFyZ3MpLFxuICAgICAgICBpbnNlcnRDb250ZW50OiAodmFsdWUsIGRldGFpbHMpID0+IGluc2VydEh0bWxBdENhcmV0KGVkaXRvciwgdmFsdWUsIGRldGFpbHMpLFxuICAgICAgICBhZGRWaXN1YWw6IGVsbSA9PiBhZGRWaXN1YWxJbnRlcm5hbChlZGl0b3IsIGVsbSlcbiAgICAgIH0sXG4gICAgICBzZWxlY3Rpb246IHsgZ2V0Q29udGVudDogKGZvcm1hdCwgYXJncykgPT4gZ2V0U2VsZWN0ZWRDb250ZW50SW50ZXJuYWwoZWRpdG9yLCBmb3JtYXQsIGFyZ3MpIH0sXG4gICAgICBhdXRvY29tcGxldGVyOiB7XG4gICAgICAgIGFkZERlY29yYXRpb246IHJhbmdlID0+IGNyZWF0ZSQ4KGVkaXRvciwgcmFuZ2UpLFxuICAgICAgICByZW1vdmVEZWNvcmF0aW9uOiAoKSA9PiByZW1vdmUkMyhlZGl0b3IsIFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVkaXRvci5nZXRCb2R5KCkpKVxuICAgICAgfSxcbiAgICAgIHJhdzogeyBnZXRNb2RlbDogKCkgPT4gT3B0aW9uYWwubm9uZSgpIH1cbiAgICB9KTtcbiAgICBjb25zdCBtYWtlUnRjQWRhcHRvciA9IHJ0Y0VkaXRvciA9PiB7XG4gICAgICBjb25zdCBkZWZhdWx0VmFycyA9IHZhcnMgPT4gaXNPYmplY3QodmFycykgPyB2YXJzIDoge307XG4gICAgICBjb25zdCB7aW5pdCwgdW5kb01hbmFnZXIsIGZvcm1hdHRlciwgZWRpdG9yLCBzZWxlY3Rpb24sIGF1dG9jb21wbGV0ZXIsIHJhd30gPSBydGNFZGl0b3I7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbml0OiB7IGJpbmRFdmVudHM6IGluaXQuYmluZEV2ZW50cyB9LFxuICAgICAgICB1bmRvTWFuYWdlcjoge1xuICAgICAgICAgIGJlZm9yZUNoYW5nZTogdW5kb01hbmFnZXIuYmVmb3JlQ2hhbmdlLFxuICAgICAgICAgIGFkZDogdW5kb01hbmFnZXIuYWRkLFxuICAgICAgICAgIHVuZG86IHVuZG9NYW5hZ2VyLnVuZG8sXG4gICAgICAgICAgcmVkbzogdW5kb01hbmFnZXIucmVkbyxcbiAgICAgICAgICBjbGVhcjogdW5kb01hbmFnZXIuY2xlYXIsXG4gICAgICAgICAgcmVzZXQ6IHVuZG9NYW5hZ2VyLnJlc2V0LFxuICAgICAgICAgIGhhc1VuZG86IHVuZG9NYW5hZ2VyLmhhc1VuZG8sXG4gICAgICAgICAgaGFzUmVkbzogdW5kb01hbmFnZXIuaGFzUmVkbyxcbiAgICAgICAgICB0cmFuc2FjdDogKF91bmRvTWFuYWdlciwgX2xvY2tzLCBmbikgPT4gdW5kb01hbmFnZXIudHJhbnNhY3QoZm4pLFxuICAgICAgICAgIGlnbm9yZTogKF9sb2NrcywgY2FsbGJhY2spID0+IHVuZG9NYW5hZ2VyLmlnbm9yZShjYWxsYmFjayksXG4gICAgICAgICAgZXh0cmE6IChfdW5kb01hbmFnZXIsIF9pbmRleCwgY2FsbGJhY2sxLCBjYWxsYmFjazIpID0+IHVuZG9NYW5hZ2VyLmV4dHJhKGNhbGxiYWNrMSwgY2FsbGJhY2syKVxuICAgICAgICB9LFxuICAgICAgICBmb3JtYXR0ZXI6IHtcbiAgICAgICAgICBtYXRjaDogKG5hbWUsIHZhcnMsIF9ub2RlLCBzaW1pbGFyKSA9PiBmb3JtYXR0ZXIubWF0Y2gobmFtZSwgZGVmYXVsdFZhcnModmFycyksIHNpbWlsYXIpLFxuICAgICAgICAgIG1hdGNoQWxsOiBmb3JtYXR0ZXIubWF0Y2hBbGwsXG4gICAgICAgICAgbWF0Y2hOb2RlOiBmb3JtYXR0ZXIubWF0Y2hOb2RlLFxuICAgICAgICAgIGNhbkFwcGx5OiBuYW1lID0+IGZvcm1hdHRlci5jYW5BcHBseShuYW1lKSxcbiAgICAgICAgICBjbG9zZXN0OiBuYW1lcyA9PiBmb3JtYXR0ZXIuY2xvc2VzdChuYW1lcyksXG4gICAgICAgICAgYXBwbHk6IChuYW1lLCB2YXJzLCBfbm9kZSkgPT4gZm9ybWF0dGVyLmFwcGx5KG5hbWUsIGRlZmF1bHRWYXJzKHZhcnMpKSxcbiAgICAgICAgICByZW1vdmU6IChuYW1lLCB2YXJzLCBfbm9kZSwgX3NpbWlsYXIpID0+IGZvcm1hdHRlci5yZW1vdmUobmFtZSwgZGVmYXVsdFZhcnModmFycykpLFxuICAgICAgICAgIHRvZ2dsZTogKG5hbWUsIHZhcnMsIF9ub2RlKSA9PiBmb3JtYXR0ZXIudG9nZ2xlKG5hbWUsIGRlZmF1bHRWYXJzKHZhcnMpKSxcbiAgICAgICAgICBmb3JtYXRDaGFuZ2VkOiAoX3JmbCwgZm9ybWF0cywgY2FsbGJhY2ssIHNpbWlsYXIsIHZhcnMpID0+IGZvcm1hdHRlci5mb3JtYXRDaGFuZ2VkKGZvcm1hdHMsIGNhbGxiYWNrLCBzaW1pbGFyLCB2YXJzKVxuICAgICAgICB9LFxuICAgICAgICBlZGl0b3I6IHtcbiAgICAgICAgICBnZXRDb250ZW50OiBhcmdzID0+IGVkaXRvci5nZXRDb250ZW50KGFyZ3MpLFxuICAgICAgICAgIHNldENvbnRlbnQ6IChjb250ZW50LCBhcmdzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBjb250ZW50OiBlZGl0b3Iuc2V0Q29udGVudChjb250ZW50LCBhcmdzKSxcbiAgICAgICAgICAgICAgaHRtbDogJydcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpbnNlcnRDb250ZW50OiAoY29udGVudCwgX2RldGFpbHMpID0+IHtcbiAgICAgICAgICAgIGVkaXRvci5pbnNlcnRDb250ZW50KGNvbnRlbnQpO1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYWRkVmlzdWFsOiBlZGl0b3IuYWRkVmlzdWFsXG4gICAgICAgIH0sXG4gICAgICAgIHNlbGVjdGlvbjogeyBnZXRDb250ZW50OiAoX2Zvcm1hdCwgYXJncykgPT4gc2VsZWN0aW9uLmdldENvbnRlbnQoYXJncykgfSxcbiAgICAgICAgYXV0b2NvbXBsZXRlcjoge1xuICAgICAgICAgIGFkZERlY29yYXRpb246IGF1dG9jb21wbGV0ZXIuYWRkRGVjb3JhdGlvbixcbiAgICAgICAgICByZW1vdmVEZWNvcmF0aW9uOiBhdXRvY29tcGxldGVyLnJlbW92ZURlY29yYXRpb25cbiAgICAgICAgfSxcbiAgICAgICAgcmF3OiB7IGdldE1vZGVsOiAoKSA9PiBPcHRpb25hbC5zb21lKHJhdy5nZXRSYXdNb2RlbCgpKSB9XG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgbWFrZU5vb3BBZGFwdG9yID0gKCkgPT4ge1xuICAgICAgY29uc3QgbnVsID0gY29uc3RhbnQobnVsbCk7XG4gICAgICBjb25zdCBlbXB0eSA9IGNvbnN0YW50KCcnKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluaXQ6IHsgYmluZEV2ZW50czogbm9vcCB9LFxuICAgICAgICB1bmRvTWFuYWdlcjoge1xuICAgICAgICAgIGJlZm9yZUNoYW5nZTogbm9vcCxcbiAgICAgICAgICBhZGQ6IG51bCxcbiAgICAgICAgICB1bmRvOiBudWwsXG4gICAgICAgICAgcmVkbzogbnVsLFxuICAgICAgICAgIGNsZWFyOiBub29wLFxuICAgICAgICAgIHJlc2V0OiBub29wLFxuICAgICAgICAgIGhhc1VuZG86IG5ldmVyLFxuICAgICAgICAgIGhhc1JlZG86IG5ldmVyLFxuICAgICAgICAgIHRyYW5zYWN0OiBudWwsXG4gICAgICAgICAgaWdub3JlOiBub29wLFxuICAgICAgICAgIGV4dHJhOiBub29wXG4gICAgICAgIH0sXG4gICAgICAgIGZvcm1hdHRlcjoge1xuICAgICAgICAgIG1hdGNoOiBuZXZlcixcbiAgICAgICAgICBtYXRjaEFsbDogY29uc3RhbnQoW10pLFxuICAgICAgICAgIG1hdGNoTm9kZTogY29uc3RhbnQodW5kZWZpbmVkKSxcbiAgICAgICAgICBjYW5BcHBseTogbmV2ZXIsXG4gICAgICAgICAgY2xvc2VzdDogZW1wdHksXG4gICAgICAgICAgYXBwbHk6IG5vb3AsXG4gICAgICAgICAgcmVtb3ZlOiBub29wLFxuICAgICAgICAgIHRvZ2dsZTogbm9vcCxcbiAgICAgICAgICBmb3JtYXRDaGFuZ2VkOiBjb25zdGFudCh7IHVuYmluZDogbm9vcCB9KVxuICAgICAgICB9LFxuICAgICAgICBlZGl0b3I6IHtcbiAgICAgICAgICBnZXRDb250ZW50OiBlbXB0eSxcbiAgICAgICAgICBzZXRDb250ZW50OiBjb25zdGFudCh7XG4gICAgICAgICAgICBjb250ZW50OiAnJyxcbiAgICAgICAgICAgIGh0bWw6ICcnXG4gICAgICAgICAgfSksXG4gICAgICAgICAgaW5zZXJ0Q29udGVudDogY29uc3RhbnQoJycpLFxuICAgICAgICAgIGFkZFZpc3VhbDogbm9vcFxuICAgICAgICB9LFxuICAgICAgICBzZWxlY3Rpb246IHsgZ2V0Q29udGVudDogZW1wdHkgfSxcbiAgICAgICAgYXV0b2NvbXBsZXRlcjoge1xuICAgICAgICAgIGFkZERlY29yYXRpb246IG5vb3AsXG4gICAgICAgICAgcmVtb3ZlRGVjb3JhdGlvbjogbm9vcFxuICAgICAgICB9LFxuICAgICAgICByYXc6IHsgZ2V0TW9kZWw6IGNvbnN0YW50KE9wdGlvbmFsLm5vbmUoKSkgfVxuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IGlzUnRjID0gZWRpdG9yID0+IGhhcyQyKGVkaXRvci5wbHVnaW5zLCAncnRjJyk7XG4gICAgY29uc3QgZ2V0UnRjU2V0dXAgPSBlZGl0b3IgPT4gZ2V0JGEoZWRpdG9yLnBsdWdpbnMsICdydGMnKS5iaW5kKHJ0Y1BsdWdpbiA9PiBPcHRpb25hbC5mcm9tKHJ0Y1BsdWdpbi5zZXR1cCkpO1xuICAgIGNvbnN0IHNldHVwJHMgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgZWRpdG9yQ2FzdCA9IGVkaXRvcjtcbiAgICAgIHJldHVybiBnZXRSdGNTZXR1cChlZGl0b3IpLmZvbGQoKCkgPT4ge1xuICAgICAgICBlZGl0b3JDYXN0LnJ0Y0luc3RhbmNlID0gbWFrZVBsYWluQWRhcHRvcihlZGl0b3IpO1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgfSwgc2V0dXAgPT4ge1xuICAgICAgICBlZGl0b3JDYXN0LnJ0Y0luc3RhbmNlID0gbWFrZU5vb3BBZGFwdG9yKCk7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKCgpID0+IHNldHVwKCkudGhlbihydGNFZGl0b3IgPT4ge1xuICAgICAgICAgIGVkaXRvckNhc3QucnRjSW5zdGFuY2UgPSBtYWtlUnRjQWRhcHRvcihydGNFZGl0b3IpO1xuICAgICAgICAgIHJldHVybiBydGNFZGl0b3IucnRjLmlzUmVtb3RlO1xuICAgICAgICB9KSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGdldFJ0Y0luc3RhbmNlV2l0aEZhbGxiYWNrID0gZWRpdG9yID0+IGVkaXRvci5ydGNJbnN0YW5jZSA/IGVkaXRvci5ydGNJbnN0YW5jZSA6IG1ha2VQbGFpbkFkYXB0b3IoZWRpdG9yKTtcbiAgICBjb25zdCBnZXRSdGNJbnN0YW5jZVdpdGhFcnJvciA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBydGNJbnN0YW5jZSA9IGVkaXRvci5ydGNJbnN0YW5jZTtcbiAgICAgIGlmICghcnRjSW5zdGFuY2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZ2V0IFJUQyBpbnN0YW5jZSBub3QgeWV0IGluaXRpYWxpemVkLicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJ0Y0luc3RhbmNlO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgYmVmb3JlQ2hhbmdlID0gKGVkaXRvciwgbG9ja3MsIGJlZm9yZUJvb2ttYXJrKSA9PiB7XG4gICAgICBnZXRSdGNJbnN0YW5jZVdpdGhFcnJvcihlZGl0b3IpLnVuZG9NYW5hZ2VyLmJlZm9yZUNoYW5nZShsb2NrcywgYmVmb3JlQm9va21hcmspO1xuICAgIH07XG4gICAgY29uc3QgYWRkVW5kb0xldmVsID0gKGVkaXRvciwgdW5kb01hbmFnZXIsIGluZGV4LCBsb2NrcywgYmVmb3JlQm9va21hcmssIGxldmVsLCBldmVudCkgPT4gZ2V0UnRjSW5zdGFuY2VXaXRoRXJyb3IoZWRpdG9yKS51bmRvTWFuYWdlci5hZGQodW5kb01hbmFnZXIsIGluZGV4LCBsb2NrcywgYmVmb3JlQm9va21hcmssIGxldmVsLCBldmVudCk7XG4gICAgY29uc3QgdW5kbyA9IChlZGl0b3IsIHVuZG9NYW5hZ2VyLCBsb2NrcywgaW5kZXgpID0+IGdldFJ0Y0luc3RhbmNlV2l0aEVycm9yKGVkaXRvcikudW5kb01hbmFnZXIudW5kbyh1bmRvTWFuYWdlciwgbG9ja3MsIGluZGV4KTtcbiAgICBjb25zdCByZWRvID0gKGVkaXRvciwgaW5kZXgsIGRhdGEpID0+IGdldFJ0Y0luc3RhbmNlV2l0aEVycm9yKGVkaXRvcikudW5kb01hbmFnZXIucmVkbyhpbmRleCwgZGF0YSk7XG4gICAgY29uc3QgY2xlYXIgPSAoZWRpdG9yLCB1bmRvTWFuYWdlciwgaW5kZXgpID0+IHtcbiAgICAgIGdldFJ0Y0luc3RhbmNlV2l0aEVycm9yKGVkaXRvcikudW5kb01hbmFnZXIuY2xlYXIodW5kb01hbmFnZXIsIGluZGV4KTtcbiAgICB9O1xuICAgIGNvbnN0IHJlc2V0ID0gKGVkaXRvciwgdW5kb01hbmFnZXIpID0+IHtcbiAgICAgIGdldFJ0Y0luc3RhbmNlV2l0aEVycm9yKGVkaXRvcikudW5kb01hbmFnZXIucmVzZXQodW5kb01hbmFnZXIpO1xuICAgIH07XG4gICAgY29uc3QgaGFzVW5kbyA9IChlZGl0b3IsIHVuZG9NYW5hZ2VyLCBpbmRleCkgPT4gZ2V0UnRjSW5zdGFuY2VXaXRoRXJyb3IoZWRpdG9yKS51bmRvTWFuYWdlci5oYXNVbmRvKHVuZG9NYW5hZ2VyLCBpbmRleCk7XG4gICAgY29uc3QgaGFzUmVkbyA9IChlZGl0b3IsIHVuZG9NYW5hZ2VyLCBpbmRleCkgPT4gZ2V0UnRjSW5zdGFuY2VXaXRoRXJyb3IoZWRpdG9yKS51bmRvTWFuYWdlci5oYXNSZWRvKHVuZG9NYW5hZ2VyLCBpbmRleCk7XG4gICAgY29uc3QgdHJhbnNhY3QgPSAoZWRpdG9yLCB1bmRvTWFuYWdlciwgbG9ja3MsIGNhbGxiYWNrKSA9PiBnZXRSdGNJbnN0YW5jZVdpdGhFcnJvcihlZGl0b3IpLnVuZG9NYW5hZ2VyLnRyYW5zYWN0KHVuZG9NYW5hZ2VyLCBsb2NrcywgY2FsbGJhY2spO1xuICAgIGNvbnN0IGlnbm9yZSA9IChlZGl0b3IsIGxvY2tzLCBjYWxsYmFjaykgPT4ge1xuICAgICAgZ2V0UnRjSW5zdGFuY2VXaXRoRXJyb3IoZWRpdG9yKS51bmRvTWFuYWdlci5pZ25vcmUobG9ja3MsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIGNvbnN0IGV4dHJhID0gKGVkaXRvciwgdW5kb01hbmFnZXIsIGluZGV4LCBjYWxsYmFjazEsIGNhbGxiYWNrMikgPT4ge1xuICAgICAgZ2V0UnRjSW5zdGFuY2VXaXRoRXJyb3IoZWRpdG9yKS51bmRvTWFuYWdlci5leHRyYSh1bmRvTWFuYWdlciwgaW5kZXgsIGNhbGxiYWNrMSwgY2FsbGJhY2syKTtcbiAgICB9O1xuICAgIGNvbnN0IG1hdGNoRm9ybWF0ID0gKGVkaXRvciwgbmFtZSwgdmFycywgbm9kZSwgc2ltaWxhcikgPT4gZ2V0UnRjSW5zdGFuY2VXaXRoRXJyb3IoZWRpdG9yKS5mb3JtYXR0ZXIubWF0Y2gobmFtZSwgdmFycywgbm9kZSwgc2ltaWxhcik7XG4gICAgY29uc3QgbWF0Y2hBbGxGb3JtYXRzID0gKGVkaXRvciwgbmFtZXMsIHZhcnMpID0+IGdldFJ0Y0luc3RhbmNlV2l0aEVycm9yKGVkaXRvcikuZm9ybWF0dGVyLm1hdGNoQWxsKG5hbWVzLCB2YXJzKTtcbiAgICBjb25zdCBtYXRjaE5vZGVGb3JtYXQgPSAoZWRpdG9yLCBub2RlLCBuYW1lLCB2YXJzLCBzaW1pbGFyKSA9PiBnZXRSdGNJbnN0YW5jZVdpdGhFcnJvcihlZGl0b3IpLmZvcm1hdHRlci5tYXRjaE5vZGUobm9kZSwgbmFtZSwgdmFycywgc2ltaWxhcik7XG4gICAgY29uc3QgY2FuQXBwbHlGb3JtYXQgPSAoZWRpdG9yLCBuYW1lKSA9PiBnZXRSdGNJbnN0YW5jZVdpdGhFcnJvcihlZGl0b3IpLmZvcm1hdHRlci5jYW5BcHBseShuYW1lKTtcbiAgICBjb25zdCBjbG9zZXN0Rm9ybWF0ID0gKGVkaXRvciwgbmFtZXMpID0+IGdldFJ0Y0luc3RhbmNlV2l0aEVycm9yKGVkaXRvcikuZm9ybWF0dGVyLmNsb3Nlc3QobmFtZXMpO1xuICAgIGNvbnN0IGFwcGx5Rm9ybWF0ID0gKGVkaXRvciwgbmFtZSwgdmFycywgbm9kZSkgPT4ge1xuICAgICAgZ2V0UnRjSW5zdGFuY2VXaXRoRXJyb3IoZWRpdG9yKS5mb3JtYXR0ZXIuYXBwbHkobmFtZSwgdmFycywgbm9kZSk7XG4gICAgfTtcbiAgICBjb25zdCByZW1vdmVGb3JtYXQgPSAoZWRpdG9yLCBuYW1lLCB2YXJzLCBub2RlLCBzaW1pbGFyKSA9PiB7XG4gICAgICBnZXRSdGNJbnN0YW5jZVdpdGhFcnJvcihlZGl0b3IpLmZvcm1hdHRlci5yZW1vdmUobmFtZSwgdmFycywgbm9kZSwgc2ltaWxhcik7XG4gICAgfTtcbiAgICBjb25zdCB0b2dnbGVGb3JtYXQgPSAoZWRpdG9yLCBuYW1lLCB2YXJzLCBub2RlKSA9PiB7XG4gICAgICBnZXRSdGNJbnN0YW5jZVdpdGhFcnJvcihlZGl0b3IpLmZvcm1hdHRlci50b2dnbGUobmFtZSwgdmFycywgbm9kZSk7XG4gICAgfTtcbiAgICBjb25zdCBmb3JtYXRDaGFuZ2VkID0gKGVkaXRvciwgcmVnaXN0ZXJlZEZvcm1hdExpc3RlbmVycywgZm9ybWF0cywgY2FsbGJhY2ssIHNpbWlsYXIsIHZhcnMpID0+IGdldFJ0Y0luc3RhbmNlV2l0aEVycm9yKGVkaXRvcikuZm9ybWF0dGVyLmZvcm1hdENoYW5nZWQocmVnaXN0ZXJlZEZvcm1hdExpc3RlbmVycywgZm9ybWF0cywgY2FsbGJhY2ssIHNpbWlsYXIsIHZhcnMpO1xuICAgIGNvbnN0IGdldENvbnRlbnQkMiA9IChlZGl0b3IsIGFyZ3MpID0+IGdldFJ0Y0luc3RhbmNlV2l0aEZhbGxiYWNrKGVkaXRvcikuZWRpdG9yLmdldENvbnRlbnQoYXJncyk7XG4gICAgY29uc3Qgc2V0Q29udGVudCQyID0gKGVkaXRvciwgY29udGVudCwgYXJncykgPT4gZ2V0UnRjSW5zdGFuY2VXaXRoRmFsbGJhY2soZWRpdG9yKS5lZGl0b3Iuc2V0Q29udGVudChjb250ZW50LCBhcmdzKTtcbiAgICBjb25zdCBpbnNlcnRDb250ZW50JDEgPSAoZWRpdG9yLCB2YWx1ZSwgZGV0YWlscykgPT4gZ2V0UnRjSW5zdGFuY2VXaXRoRmFsbGJhY2soZWRpdG9yKS5lZGl0b3IuaW5zZXJ0Q29udGVudCh2YWx1ZSwgZGV0YWlscyk7XG4gICAgY29uc3QgZ2V0U2VsZWN0ZWRDb250ZW50ID0gKGVkaXRvciwgZm9ybWF0LCBhcmdzKSA9PiBnZXRSdGNJbnN0YW5jZVdpdGhFcnJvcihlZGl0b3IpLnNlbGVjdGlvbi5nZXRDb250ZW50KGZvcm1hdCwgYXJncyk7XG4gICAgY29uc3QgYWRkVmlzdWFsJDEgPSAoZWRpdG9yLCBlbG0pID0+IGdldFJ0Y0luc3RhbmNlV2l0aEVycm9yKGVkaXRvcikuZWRpdG9yLmFkZFZpc3VhbChlbG0pO1xuICAgIGNvbnN0IGJpbmRFdmVudHMgPSBlZGl0b3IgPT4gZ2V0UnRjSW5zdGFuY2VXaXRoRXJyb3IoZWRpdG9yKS5pbml0LmJpbmRFdmVudHMoKTtcbiAgICBjb25zdCBhZGRBdXRvY29tcGxldGVyRGVjb3JhdGlvbiA9IChlZGl0b3IsIHJhbmdlKSA9PiBnZXRSdGNJbnN0YW5jZVdpdGhFcnJvcihlZGl0b3IpLmF1dG9jb21wbGV0ZXIuYWRkRGVjb3JhdGlvbihyYW5nZSk7XG4gICAgY29uc3QgcmVtb3ZlQXV0b2NvbXBsZXRlckRlY29yYXRpb24gPSBlZGl0b3IgPT4gZ2V0UnRjSW5zdGFuY2VXaXRoRXJyb3IoZWRpdG9yKS5hdXRvY29tcGxldGVyLnJlbW92ZURlY29yYXRpb24oKTtcblxuICAgIGNvbnN0IGdldENvbnRlbnQkMSA9IChlZGl0b3IsIGFyZ3MgPSB7fSkgPT4ge1xuICAgICAgY29uc3QgZm9ybWF0ID0gYXJncy5mb3JtYXQgPyBhcmdzLmZvcm1hdCA6ICdodG1sJztcbiAgICAgIHJldHVybiBnZXRTZWxlY3RlZENvbnRlbnQoZWRpdG9yLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH07XG5cbiAgICBjb25zdCByZW1vdmVFbXB0eSA9IHRleHQgPT4ge1xuICAgICAgaWYgKHRleHQuZG9tLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZW1vdmUkNSh0ZXh0KTtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKHRleHQpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgd2Fsa1Bhc3RCb29rbWFyayA9IChub2RlLCBzdGFydCkgPT4gbm9kZS5maWx0ZXIoZWxtID0+IEJvb2ttYXJrTWFuYWdlci5pc0Jvb2ttYXJrTm9kZShlbG0uZG9tKSkuYmluZChzdGFydCA/IG5leHRTaWJsaW5nIDogcHJldlNpYmxpbmcpO1xuICAgIGNvbnN0IG1lcmdlJDEgPSAob3V0ZXIsIGlubmVyLCBybmcsIHN0YXJ0KSA9PiB7XG4gICAgICBjb25zdCBvdXRlckVsbSA9IG91dGVyLmRvbTtcbiAgICAgIGNvbnN0IGlubmVyRWxtID0gaW5uZXIuZG9tO1xuICAgICAgY29uc3Qgb2xkTGVuZ3RoID0gc3RhcnQgPyBvdXRlckVsbS5sZW5ndGggOiBpbm5lckVsbS5sZW5ndGg7XG4gICAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgbWVyZ2VUZXh0Tm9kZXMob3V0ZXJFbG0sIGlubmVyRWxtLCBmYWxzZSwgIXN0YXJ0KTtcbiAgICAgICAgcm5nLnNldFN0YXJ0KGlubmVyRWxtLCBvbGRMZW5ndGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWVyZ2VUZXh0Tm9kZXMoaW5uZXJFbG0sIG91dGVyRWxtLCBmYWxzZSwgIXN0YXJ0KTtcbiAgICAgICAgcm5nLnNldEVuZChpbm5lckVsbSwgb2xkTGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG5vcm1hbGl6ZVRleHRJZlJlcXVpcmVkID0gKGlubmVyLCBzdGFydCkgPT4ge1xuICAgICAgcGFyZW50KGlubmVyKS5lYWNoKHJvb3QgPT4ge1xuICAgICAgICBjb25zdCB0ZXh0ID0gaW5uZXIuZG9tO1xuICAgICAgICBpZiAoc3RhcnQgJiYgbmVlZHNUb0JlTmJzcExlZnQocm9vdCwgQ2FyZXRQb3NpdGlvbih0ZXh0LCAwKSkpIHtcbiAgICAgICAgICBub3JtYWxpemVXaGl0ZXNwYWNlQWZ0ZXIodGV4dCwgMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXN0YXJ0ICYmIG5lZWRzVG9CZU5ic3BSaWdodChyb290LCBDYXJldFBvc2l0aW9uKHRleHQsIHRleHQubGVuZ3RoKSkpIHtcbiAgICAgICAgICBub3JtYWxpemVXaGl0ZXNwYWNlQmVmb3JlKHRleHQsIHRleHQubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBtZXJnZUFuZE5vcm1hbGl6ZVRleHQgPSAob3V0ZXJOb2RlLCBpbm5lck5vZGUsIHJuZywgc3RhcnQpID0+IHtcbiAgICAgIG91dGVyTm9kZS5iaW5kKG91dGVyID0+IHtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplciA9IHN0YXJ0ID8gbm9ybWFsaXplV2hpdGVzcGFjZUJlZm9yZSA6IG5vcm1hbGl6ZVdoaXRlc3BhY2VBZnRlcjtcbiAgICAgICAgbm9ybWFsaXplcihvdXRlci5kb20sIHN0YXJ0ID8gb3V0ZXIuZG9tLmxlbmd0aCA6IDApO1xuICAgICAgICByZXR1cm4gaW5uZXJOb2RlLmZpbHRlcihpc1RleHQkOSkubWFwKGlubmVyID0+IG1lcmdlJDEob3V0ZXIsIGlubmVyLCBybmcsIHN0YXJ0KSk7XG4gICAgICB9KS5vclRodW5rKCgpID0+IHtcbiAgICAgICAgY29uc3QgaW5uZXJUZXh0Tm9kZSA9IHdhbGtQYXN0Qm9va21hcmsoaW5uZXJOb2RlLCBzdGFydCkub3IoaW5uZXJOb2RlKS5maWx0ZXIoaXNUZXh0JDkpO1xuICAgICAgICByZXR1cm4gaW5uZXJUZXh0Tm9kZS5tYXAoaW5uZXIgPT4gbm9ybWFsaXplVGV4dElmUmVxdWlyZWQoaW5uZXIsIHN0YXJ0KSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHJuZ1NldENvbnRlbnQgPSAocm5nLCBmcmFnbWVudCkgPT4ge1xuICAgICAgY29uc3QgZmlyc3RDaGlsZCA9IE9wdGlvbmFsLmZyb20oZnJhZ21lbnQuZmlyc3RDaGlsZCkubWFwKFN1Z2FyRWxlbWVudC5mcm9tRG9tKTtcbiAgICAgIGNvbnN0IGxhc3RDaGlsZCA9IE9wdGlvbmFsLmZyb20oZnJhZ21lbnQubGFzdENoaWxkKS5tYXAoU3VnYXJFbGVtZW50LmZyb21Eb20pO1xuICAgICAgcm5nLmRlbGV0ZUNvbnRlbnRzKCk7XG4gICAgICBybmcuaW5zZXJ0Tm9kZShmcmFnbWVudCk7XG4gICAgICBjb25zdCBwcmV2VGV4dCA9IGZpcnN0Q2hpbGQuYmluZChwcmV2U2libGluZykuZmlsdGVyKGlzVGV4dCQ5KS5iaW5kKHJlbW92ZUVtcHR5KTtcbiAgICAgIGNvbnN0IG5leHRUZXh0ID0gbGFzdENoaWxkLmJpbmQobmV4dFNpYmxpbmcpLmZpbHRlcihpc1RleHQkOSkuYmluZChyZW1vdmVFbXB0eSk7XG4gICAgICBtZXJnZUFuZE5vcm1hbGl6ZVRleHQocHJldlRleHQsIGZpcnN0Q2hpbGQsIHJuZywgdHJ1ZSk7XG4gICAgICBtZXJnZUFuZE5vcm1hbGl6ZVRleHQobmV4dFRleHQsIGxhc3RDaGlsZCwgcm5nLCBmYWxzZSk7XG4gICAgICBybmcuY29sbGFwc2UoZmFsc2UpO1xuICAgIH07XG4gICAgY29uc3Qgc2V0dXBBcmdzJDIgPSAoYXJncywgY29udGVudCkgPT4gKHtcbiAgICAgIGZvcm1hdDogJ2h0bWwnLFxuICAgICAgLi4uYXJncyxcbiAgICAgIHNldDogdHJ1ZSxcbiAgICAgIHNlbGVjdGlvbjogdHJ1ZSxcbiAgICAgIGNvbnRlbnRcbiAgICB9KTtcbiAgICBjb25zdCBjbGVhbkNvbnRlbnQgPSAoZWRpdG9yLCBhcmdzKSA9PiB7XG4gICAgICBpZiAoYXJncy5mb3JtYXQgIT09ICdyYXcnKSB7XG4gICAgICAgIGNvbnN0IHJuZyA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCk7XG4gICAgICAgIGNvbnN0IGNvbnRleHRCbG9jayA9IGVkaXRvci5kb20uZ2V0UGFyZW50KHJuZy5jb21tb25BbmNlc3RvckNvbnRhaW5lciwgZWRpdG9yLmRvbS5pc0Jsb2NrKTtcbiAgICAgICAgY29uc3QgY29udGV4dEFyZ3MgPSBjb250ZXh0QmxvY2sgPyB7IGNvbnRleHQ6IGNvbnRleHRCbG9jay5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIH0gOiB7fTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGVkaXRvci5wYXJzZXIucGFyc2UoYXJncy5jb250ZW50LCB7XG4gICAgICAgICAgZm9yY2VkX3Jvb3RfYmxvY2s6IGZhbHNlLFxuICAgICAgICAgIC4uLmNvbnRleHRBcmdzLFxuICAgICAgICAgIC4uLmFyZ3NcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBIdG1sU2VyaWFsaXplcih7IHZhbGlkYXRlOiBmYWxzZSB9LCBlZGl0b3Iuc2NoZW1hKS5zZXJpYWxpemUobm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYXJncy5jb250ZW50O1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgc2V0Q29udGVudCQxID0gKGVkaXRvciwgY29udGVudCwgYXJncyA9IHt9KSA9PiB7XG4gICAgICBjb25zdCBkZWZhdWx0ZWRBcmdzID0gc2V0dXBBcmdzJDIoYXJncywgY29udGVudCk7XG4gICAgICBwcmVQcm9jZXNzU2V0Q29udGVudChlZGl0b3IsIGRlZmF1bHRlZEFyZ3MpLmVhY2godXBkYXRlZEFyZ3MgPT4ge1xuICAgICAgICBjb25zdCBjbGVhbmVkQ29udGVudCA9IGNsZWFuQ29udGVudChlZGl0b3IsIHVwZGF0ZWRBcmdzKTtcbiAgICAgICAgY29uc3Qgcm5nID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKTtcbiAgICAgICAgcm5nU2V0Q29udGVudChybmcsIHJuZy5jcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQoY2xlYW5lZENvbnRlbnQpKTtcbiAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZXRSbmcocm5nKTtcbiAgICAgICAgc2Nyb2xsUmFuZ2VJbnRvVmlldyhlZGl0b3IsIHJuZyk7XG4gICAgICAgIHBvc3RQcm9jZXNzU2V0Q29udGVudChlZGl0b3IsIGNsZWFuZWRDb250ZW50LCB1cGRhdGVkQXJncyk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3QgZGVsZXRlRnJvbUNhbGxiYWNrTWFwID0gKGNhbGxiYWNrTWFwLCBzZWxlY3RvciwgY2FsbGJhY2spID0+IHtcbiAgICAgIGlmIChjYWxsYmFja01hcCAmJiBoYXMkMihjYWxsYmFja01hcCwgc2VsZWN0b3IpKSB7XG4gICAgICAgIGNvbnN0IG5ld0NhbGxiYWNrcyA9IGZpbHRlciQ2KGNhbGxiYWNrTWFwW3NlbGVjdG9yXSwgY2IgPT4gY2IgIT09IGNhbGxiYWNrKTtcbiAgICAgICAgaWYgKG5ld0NhbGxiYWNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBkZWxldGUgY2FsbGJhY2tNYXBbc2VsZWN0b3JdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbGxiYWNrTWFwW3NlbGVjdG9yXSA9IG5ld0NhbGxiYWNrcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdmFyIFNlbGVjdG9yQ2hhbmdlZCA9IChkb20sIGVkaXRvcikgPT4ge1xuICAgICAgbGV0IHNlbGVjdG9yQ2hhbmdlZERhdGE7XG4gICAgICBsZXQgY3VycmVudFNlbGVjdG9ycztcbiAgICAgIGNvbnN0IGZpbmRNYXRjaGluZ05vZGUgPSAoc2VsZWN0b3IsIG5vZGVzKSA9PiBmaW5kJDIobm9kZXMsIG5vZGUgPT4gZG9tLmlzKG5vZGUsIHNlbGVjdG9yKSk7XG4gICAgICBjb25zdCBnZXRQYXJlbnRzID0gZWxlbSA9PiBkb20uZ2V0UGFyZW50cyhlbGVtLCBudWxsLCBkb20uZ2V0Um9vdCgpKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNlbGVjdG9yQ2hhbmdlZFdpdGhVbmJpbmQ6IChzZWxlY3RvciwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgICBpZiAoIXNlbGVjdG9yQ2hhbmdlZERhdGEpIHtcbiAgICAgICAgICAgIHNlbGVjdG9yQ2hhbmdlZERhdGEgPSB7fTtcbiAgICAgICAgICAgIGN1cnJlbnRTZWxlY3RvcnMgPSB7fTtcbiAgICAgICAgICAgIGVkaXRvci5vbignTm9kZUNoYW5nZScsIGUgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBub2RlID0gZS5lbGVtZW50O1xuICAgICAgICAgICAgICBjb25zdCBwYXJlbnRzID0gZ2V0UGFyZW50cyhub2RlKTtcbiAgICAgICAgICAgICAgY29uc3QgbWF0Y2hlZFNlbGVjdG9ycyA9IHt9O1xuICAgICAgICAgICAgICBUb29scy5lYWNoKHNlbGVjdG9yQ2hhbmdlZERhdGEsIChjYWxsYmFja3MsIHNlbGVjdG9yKSA9PiB7XG4gICAgICAgICAgICAgICAgZmluZE1hdGNoaW5nTm9kZShzZWxlY3RvciwgcGFyZW50cykuZWFjaChub2RlID0+IHtcbiAgICAgICAgICAgICAgICAgIGlmICghY3VycmVudFNlbGVjdG9yc1tzZWxlY3Rvcl0pIHtcbiAgICAgICAgICAgICAgICAgICAgZWFjaCRnKGNhbGxiYWNrcywgY2FsbGJhY2sgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHRydWUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudHNcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZWxlY3RvcnNbc2VsZWN0b3JdID0gY2FsbGJhY2tzO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgbWF0Y2hlZFNlbGVjdG9yc1tzZWxlY3Rvcl0gPSBjYWxsYmFja3M7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBUb29scy5lYWNoKGN1cnJlbnRTZWxlY3RvcnMsIChjYWxsYmFja3MsIHNlbGVjdG9yKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaGVkU2VsZWN0b3JzW3NlbGVjdG9yXSkge1xuICAgICAgICAgICAgICAgICAgZGVsZXRlIGN1cnJlbnRTZWxlY3RvcnNbc2VsZWN0b3JdO1xuICAgICAgICAgICAgICAgICAgVG9vbHMuZWFjaChjYWxsYmFja3MsIGNhbGxiYWNrID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZmFsc2UsIHtcbiAgICAgICAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yLFxuICAgICAgICAgICAgICAgICAgICAgIHBhcmVudHNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghc2VsZWN0b3JDaGFuZ2VkRGF0YVtzZWxlY3Rvcl0pIHtcbiAgICAgICAgICAgIHNlbGVjdG9yQ2hhbmdlZERhdGFbc2VsZWN0b3JdID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGVjdG9yQ2hhbmdlZERhdGFbc2VsZWN0b3JdLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgIGZpbmRNYXRjaGluZ05vZGUoc2VsZWN0b3IsIGdldFBhcmVudHMoZWRpdG9yLnNlbGVjdGlvbi5nZXRTdGFydCgpKSkuZWFjaCgoKSA9PiB7XG4gICAgICAgICAgICBjdXJyZW50U2VsZWN0b3JzW3NlbGVjdG9yXSA9IHNlbGVjdG9yQ2hhbmdlZERhdGFbc2VsZWN0b3JdO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1bmJpbmQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgZGVsZXRlRnJvbUNhbGxiYWNrTWFwKHNlbGVjdG9yQ2hhbmdlZERhdGEsIHNlbGVjdG9yLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgIGRlbGV0ZUZyb21DYWxsYmFja01hcChjdXJyZW50U2VsZWN0b3JzLCBzZWxlY3RvciwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IGlzQXR0YWNoZWRUb0RvbSA9IG5vZGUgPT4ge1xuICAgICAgcmV0dXJuICEhKG5vZGUgJiYgbm9kZS5vd25lckRvY3VtZW50KSAmJiBjb250YWlucyhTdWdhckVsZW1lbnQuZnJvbURvbShub2RlLm93bmVyRG9jdW1lbnQpLCBTdWdhckVsZW1lbnQuZnJvbURvbShub2RlKSk7XG4gICAgfTtcbiAgICBjb25zdCBpc1ZhbGlkUmFuZ2UgPSBybmcgPT4ge1xuICAgICAgaWYgKCFybmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGlzQXR0YWNoZWRUb0RvbShybmcuc3RhcnRDb250YWluZXIpICYmIGlzQXR0YWNoZWRUb0RvbShybmcuZW5kQ29udGFpbmVyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IEVkaXRvclNlbGVjdGlvbiA9IChkb20sIHdpbiwgc2VyaWFsaXplciwgZWRpdG9yKSA9PiB7XG4gICAgICBsZXQgc2VsZWN0ZWRSYW5nZTtcbiAgICAgIGxldCBleHBsaWNpdFJhbmdlO1xuICAgICAgY29uc3Qge3NlbGVjdG9yQ2hhbmdlZFdpdGhVbmJpbmR9ID0gU2VsZWN0b3JDaGFuZ2VkKGRvbSwgZWRpdG9yKTtcbiAgICAgIGNvbnN0IHNldEN1cnNvckxvY2F0aW9uID0gKG5vZGUsIG9mZnNldCkgPT4ge1xuICAgICAgICBjb25zdCBybmcgPSBkb20uY3JlYXRlUm5nKCk7XG4gICAgICAgIGlmIChpc05vbk51bGxhYmxlKG5vZGUpICYmIGlzTm9uTnVsbGFibGUob2Zmc2V0KSkge1xuICAgICAgICAgIHJuZy5zZXRTdGFydChub2RlLCBvZmZzZXQpO1xuICAgICAgICAgIHJuZy5zZXRFbmQobm9kZSwgb2Zmc2V0KTtcbiAgICAgICAgICBzZXRSbmcocm5nKTtcbiAgICAgICAgICBjb2xsYXBzZShmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbW92ZUVuZFBvaW50KGRvbSwgcm5nLCBlZGl0b3IuZ2V0Qm9keSgpLCB0cnVlKTtcbiAgICAgICAgICBzZXRSbmcocm5nKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGdldENvbnRlbnQgPSBhcmdzID0+IGdldENvbnRlbnQkMShlZGl0b3IsIGFyZ3MpO1xuICAgICAgY29uc3Qgc2V0Q29udGVudCA9IChjb250ZW50LCBhcmdzKSA9PiBzZXRDb250ZW50JDEoZWRpdG9yLCBjb250ZW50LCBhcmdzKTtcbiAgICAgIGNvbnN0IGdldFN0YXJ0JDEgPSByZWFsID0+IGdldFN0YXJ0KGVkaXRvci5nZXRCb2R5KCksIGdldFJuZyQxKCksIHJlYWwpO1xuICAgICAgY29uc3QgZ2V0RW5kID0gcmVhbCA9PiBnZXRFbmQkMShlZGl0b3IuZ2V0Qm9keSgpLCBnZXRSbmckMSgpLCByZWFsKTtcbiAgICAgIGNvbnN0IGdldEJvb2ttYXJrID0gKHR5cGUsIG5vcm1hbGl6ZWQpID0+IGJvb2ttYXJrTWFuYWdlci5nZXRCb29rbWFyayh0eXBlLCBub3JtYWxpemVkKTtcbiAgICAgIGNvbnN0IG1vdmVUb0Jvb2ttYXJrID0gYm9va21hcmsgPT4gYm9va21hcmtNYW5hZ2VyLm1vdmVUb0Jvb2ttYXJrKGJvb2ttYXJrKTtcbiAgICAgIGNvbnN0IHNlbGVjdCQxID0gKG5vZGUsIGNvbnRlbnQpID0+IHtcbiAgICAgICAgc2VsZWN0KGRvbSwgbm9kZSwgY29udGVudCkuZWFjaChzZXRSbmcpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH07XG4gICAgICBjb25zdCBpc0NvbGxhcHNlZCA9ICgpID0+IHtcbiAgICAgICAgY29uc3Qgcm5nID0gZ2V0Um5nJDEoKSwgc2VsID0gZ2V0U2VsKCk7XG4gICAgICAgIGlmICghcm5nIHx8IHJuZy5pdGVtKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChybmcuY29tcGFyZUVuZFBvaW50cykge1xuICAgICAgICAgIHJldHVybiBybmcuY29tcGFyZUVuZFBvaW50cygnU3RhcnRUb0VuZCcsIHJuZykgPT09IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICFzZWwgfHwgcm5nLmNvbGxhcHNlZDtcbiAgICAgIH07XG4gICAgICBjb25zdCBjb2xsYXBzZSA9IHRvU3RhcnQgPT4ge1xuICAgICAgICBjb25zdCBybmcgPSBnZXRSbmckMSgpO1xuICAgICAgICBybmcuY29sbGFwc2UoISF0b1N0YXJ0KTtcbiAgICAgICAgc2V0Um5nKHJuZyk7XG4gICAgICB9O1xuICAgICAgY29uc3QgZ2V0U2VsID0gKCkgPT4gd2luLmdldFNlbGVjdGlvbiA/IHdpbi5nZXRTZWxlY3Rpb24oKSA6IHdpbi5kb2N1bWVudC5zZWxlY3Rpb247XG4gICAgICBjb25zdCBnZXRSbmckMSA9ICgpID0+IHtcbiAgICAgICAgbGV0IHNlbGVjdGlvbiwgcm5nLCBlbG07XG4gICAgICAgIGNvbnN0IHRyeUNvbXBhcmVCb3VuZGFyeVBvaW50cyA9IChob3csIHNvdXJjZVJhbmdlLCBkZXN0aW5hdGlvblJhbmdlKSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2VSYW5nZS5jb21wYXJlQm91bmRhcnlQb2ludHMoaG93LCBkZXN0aW5hdGlvblJhbmdlKTtcbiAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZG9jID0gd2luLmRvY3VtZW50O1xuICAgICAgICBpZiAoZWRpdG9yLmJvb2ttYXJrICE9PSB1bmRlZmluZWQgJiYgaGFzRm9jdXMoZWRpdG9yKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBjb25zdCBib29rbWFyayA9IGdldFJuZyhlZGl0b3IpO1xuICAgICAgICAgIGlmIChib29rbWFyay5pc1NvbWUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGJvb2ttYXJrLm1hcChyID0+IHByb2Nlc3NSYW5nZXMoZWRpdG9yLCBbcl0pWzBdKS5nZXRPcihkb2MuY3JlYXRlUmFuZ2UoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKChzZWxlY3Rpb24gPSBnZXRTZWwoKSkgJiYgIWlzUmVzdHJpY3RlZE5vZGUoc2VsZWN0aW9uLmFuY2hvck5vZGUpKSB7XG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uLnJhbmdlQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAgIHJuZyA9IHNlbGVjdGlvbi5nZXRSYW5nZUF0KDApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcm5nID0gc2VsZWN0aW9uLmNyZWF0ZVJhbmdlID8gc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCkgOiBkb2MuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJuZyA9IHByb2Nlc3NSYW5nZXMoZWRpdG9yLCBbcm5nXSlbMF07XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICB9XG4gICAgICAgIGlmICghcm5nKSB7XG4gICAgICAgICAgcm5nID0gZG9jLmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJuZy5zZXRTdGFydCAmJiBybmcuc3RhcnRDb250YWluZXIubm9kZVR5cGUgPT09IDkgJiYgcm5nLmNvbGxhcHNlZCkge1xuICAgICAgICAgIGVsbSA9IGRvbS5nZXRSb290KCk7XG4gICAgICAgICAgcm5nLnNldFN0YXJ0KGVsbSwgMCk7XG4gICAgICAgICAgcm5nLnNldEVuZChlbG0sIDApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxlY3RlZFJhbmdlICYmIGV4cGxpY2l0UmFuZ2UpIHtcbiAgICAgICAgICBpZiAodHJ5Q29tcGFyZUJvdW5kYXJ5UG9pbnRzKHJuZy5TVEFSVF9UT19TVEFSVCwgcm5nLCBzZWxlY3RlZFJhbmdlKSA9PT0gMCAmJiB0cnlDb21wYXJlQm91bmRhcnlQb2ludHMocm5nLkVORF9UT19FTkQsIHJuZywgc2VsZWN0ZWRSYW5nZSkgPT09IDApIHtcbiAgICAgICAgICAgIHJuZyA9IGV4cGxpY2l0UmFuZ2U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGVjdGVkUmFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgZXhwbGljaXRSYW5nZSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBybmc7XG4gICAgICB9O1xuICAgICAgY29uc3Qgc2V0Um5nID0gKHJuZywgZm9yd2FyZCkgPT4ge1xuICAgICAgICBsZXQgbm9kZTtcbiAgICAgICAgaWYgKCFpc1ZhbGlkUmFuZ2Uocm5nKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWwgPSBnZXRTZWwoKTtcbiAgICAgICAgY29uc3QgZXZ0ID0gZWRpdG9yLmRpc3BhdGNoKCdTZXRTZWxlY3Rpb25SYW5nZScsIHtcbiAgICAgICAgICByYW5nZTogcm5nLFxuICAgICAgICAgIGZvcndhcmRcbiAgICAgICAgfSk7XG4gICAgICAgIHJuZyA9IGV2dC5yYW5nZTtcbiAgICAgICAgaWYgKHNlbCkge1xuICAgICAgICAgIGV4cGxpY2l0UmFuZ2UgPSBybmc7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgICAgIHNlbC5hZGRSYW5nZShybmcpO1xuICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmb3J3YXJkID09PSBmYWxzZSAmJiBzZWwuZXh0ZW5kKSB7XG4gICAgICAgICAgICBzZWwuY29sbGFwc2Uocm5nLmVuZENvbnRhaW5lciwgcm5nLmVuZE9mZnNldCk7XG4gICAgICAgICAgICBzZWwuZXh0ZW5kKHJuZy5zdGFydENvbnRhaW5lciwgcm5nLnN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZWN0ZWRSYW5nZSA9IHNlbC5yYW5nZUNvdW50ID4gMCA/IHNlbC5nZXRSYW5nZUF0KDApIDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJuZy5jb2xsYXBzZWQgJiYgcm5nLnN0YXJ0Q29udGFpbmVyID09PSBybmcuZW5kQ29udGFpbmVyICYmIHNlbC5zZXRCYXNlQW5kRXh0ZW50KSB7XG4gICAgICAgICAgaWYgKHJuZy5lbmRPZmZzZXQgLSBybmcuc3RhcnRPZmZzZXQgPCAyKSB7XG4gICAgICAgICAgICBpZiAocm5nLnN0YXJ0Q29udGFpbmVyLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgICAgICBub2RlID0gcm5nLnN0YXJ0Q29udGFpbmVyLmNoaWxkTm9kZXNbcm5nLnN0YXJ0T2Zmc2V0XTtcbiAgICAgICAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS50YWdOYW1lID09PSAnSU1HJykge1xuICAgICAgICAgICAgICAgIHNlbC5zZXRCYXNlQW5kRXh0ZW50KHJuZy5zdGFydENvbnRhaW5lciwgcm5nLnN0YXJ0T2Zmc2V0LCBybmcuZW5kQ29udGFpbmVyLCBybmcuZW5kT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsLmFuY2hvck5vZGUgIT09IHJuZy5zdGFydENvbnRhaW5lciB8fCBzZWwuZm9jdXNOb2RlICE9PSBybmcuZW5kQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgICBzZWwuc2V0QmFzZUFuZEV4dGVudChub2RlLCAwLCBub2RlLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWRpdG9yLmRpc3BhdGNoKCdBZnRlclNldFNlbGVjdGlvblJhbmdlJywge1xuICAgICAgICAgIHJhbmdlOiBybmcsXG4gICAgICAgICAgZm9yd2FyZFxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBjb25zdCBzZXROb2RlID0gZWxtID0+IHtcbiAgICAgICAgc2V0Q29udGVudChkb20uZ2V0T3V0ZXJIVE1MKGVsbSkpO1xuICAgICAgICByZXR1cm4gZWxtO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGdldE5vZGUkMSA9ICgpID0+IGdldE5vZGUoZWRpdG9yLmdldEJvZHkoKSwgZ2V0Um5nJDEoKSk7XG4gICAgICBjb25zdCBnZXRTZWxlY3RlZEJsb2NrcyQxID0gKHN0YXJ0RWxtLCBlbmRFbG0pID0+IGdldFNlbGVjdGVkQmxvY2tzKGRvbSwgZ2V0Um5nJDEoKSwgc3RhcnRFbG0sIGVuZEVsbSk7XG4gICAgICBjb25zdCBpc0ZvcndhcmQgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHNlbCA9IGdldFNlbCgpO1xuICAgICAgICBjb25zdCBhbmNob3JOb2RlID0gc2VsID09PSBudWxsIHx8IHNlbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VsLmFuY2hvck5vZGU7XG4gICAgICAgIGNvbnN0IGZvY3VzTm9kZSA9IHNlbCA9PT0gbnVsbCB8fCBzZWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlbC5mb2N1c05vZGU7XG4gICAgICAgIGlmICghc2VsIHx8ICFhbmNob3JOb2RlIHx8ICFmb2N1c05vZGUgfHwgaXNSZXN0cmljdGVkTm9kZShhbmNob3JOb2RlKSB8fCBpc1Jlc3RyaWN0ZWROb2RlKGZvY3VzTm9kZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhbmNob3JSYW5nZSA9IGRvbS5jcmVhdGVSbmcoKTtcbiAgICAgICAgYW5jaG9yUmFuZ2Uuc2V0U3RhcnQoYW5jaG9yTm9kZSwgc2VsLmFuY2hvck9mZnNldCk7XG4gICAgICAgIGFuY2hvclJhbmdlLmNvbGxhcHNlKHRydWUpO1xuICAgICAgICBjb25zdCBmb2N1c1JhbmdlID0gZG9tLmNyZWF0ZVJuZygpO1xuICAgICAgICBmb2N1c1JhbmdlLnNldFN0YXJ0KGZvY3VzTm9kZSwgc2VsLmZvY3VzT2Zmc2V0KTtcbiAgICAgICAgZm9jdXNSYW5nZS5jb2xsYXBzZSh0cnVlKTtcbiAgICAgICAgcmV0dXJuIGFuY2hvclJhbmdlLmNvbXBhcmVCb3VuZGFyeVBvaW50cyhhbmNob3JSYW5nZS5TVEFSVF9UT19TVEFSVCwgZm9jdXNSYW5nZSkgPD0gMDtcbiAgICAgIH07XG4gICAgICBjb25zdCBub3JtYWxpemUgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHJuZyA9IGdldFJuZyQxKCk7XG4gICAgICAgIGNvbnN0IHNlbCA9IGdldFNlbCgpO1xuICAgICAgICBpZiAoIWhhc011bHRpcGxlUmFuZ2VzKHNlbCkgJiYgaGFzQW55UmFuZ2VzKGVkaXRvcikpIHtcbiAgICAgICAgICBjb25zdCBub3JtUm5nID0gbm9ybWFsaXplJDIoZG9tLCBybmcpO1xuICAgICAgICAgIG5vcm1SbmcuZWFjaChub3JtUm5nID0+IHtcbiAgICAgICAgICAgIHNldFJuZyhub3JtUm5nLCBpc0ZvcndhcmQoKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIG5vcm1SbmcuZ2V0T3Iocm5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm5nO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHNlbGVjdG9yQ2hhbmdlZCA9IChzZWxlY3RvciwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgc2VsZWN0b3JDaGFuZ2VkV2l0aFVuYmluZChzZWxlY3RvciwgY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gZXhwb3J0cztcbiAgICAgIH07XG4gICAgICBjb25zdCBnZXRTY3JvbGxDb250YWluZXIgPSAoKSA9PiB7XG4gICAgICAgIGxldCBzY3JvbGxDb250YWluZXI7XG4gICAgICAgIGxldCBub2RlID0gZG9tLmdldFJvb3QoKTtcbiAgICAgICAgd2hpbGUgKG5vZGUgJiYgbm9kZS5ub2RlTmFtZSAhPT0gJ0JPRFknKSB7XG4gICAgICAgICAgaWYgKG5vZGUuc2Nyb2xsSGVpZ2h0ID4gbm9kZS5jbGllbnRIZWlnaHQpIHtcbiAgICAgICAgICAgIHNjcm9sbENvbnRhaW5lciA9IG5vZGU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2Nyb2xsQ29udGFpbmVyO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHNjcm9sbEludG9WaWV3ID0gKGVsbSwgYWxpZ25Ub1RvcCkgPT4ge1xuICAgICAgICBpZiAoaXNOb25OdWxsYWJsZShlbG0pKSB7XG4gICAgICAgICAgc2Nyb2xsRWxlbWVudEludG9WaWV3KGVkaXRvciwgZWxtLCBhbGlnblRvVG9wKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzY3JvbGxSYW5nZUludG9WaWV3KGVkaXRvciwgZ2V0Um5nJDEoKSwgYWxpZ25Ub1RvcCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBwbGFjZUNhcmV0QXQgPSAoY2xpZW50WCwgY2xpZW50WSkgPT4gc2V0Um5nKGZyb21Qb2ludChjbGllbnRYLCBjbGllbnRZLCBlZGl0b3IuZ2V0RG9jKCkpKTtcbiAgICAgIGNvbnN0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCA9ICgpID0+IHtcbiAgICAgICAgY29uc3Qgcm5nID0gZ2V0Um5nJDEoKTtcbiAgICAgICAgcmV0dXJuIHJuZy5jb2xsYXBzZWQgPyBDYXJldFBvc2l0aW9uLmZyb21SYW5nZVN0YXJ0KHJuZykuZ2V0Q2xpZW50UmVjdHMoKVswXSA6IHJuZy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBkZXN0cm95ID0gKCkgPT4ge1xuICAgICAgICB3aW4gPSBzZWxlY3RlZFJhbmdlID0gZXhwbGljaXRSYW5nZSA9IG51bGw7XG4gICAgICAgIGNvbnRyb2xTZWxlY3Rpb24uZGVzdHJveSgpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGV4cG9ydHMgPSB7XG4gICAgICAgIGJvb2ttYXJrTWFuYWdlcjogbnVsbCxcbiAgICAgICAgY29udHJvbFNlbGVjdGlvbjogbnVsbCxcbiAgICAgICAgZG9tLFxuICAgICAgICB3aW4sXG4gICAgICAgIHNlcmlhbGl6ZXIsXG4gICAgICAgIGVkaXRvcixcbiAgICAgICAgY29sbGFwc2UsXG4gICAgICAgIHNldEN1cnNvckxvY2F0aW9uLFxuICAgICAgICBnZXRDb250ZW50LFxuICAgICAgICBzZXRDb250ZW50LFxuICAgICAgICBnZXRCb29rbWFyayxcbiAgICAgICAgbW92ZVRvQm9va21hcmssXG4gICAgICAgIHNlbGVjdDogc2VsZWN0JDEsXG4gICAgICAgIGlzQ29sbGFwc2VkLFxuICAgICAgICBpc0ZvcndhcmQsXG4gICAgICAgIHNldE5vZGUsXG4gICAgICAgIGdldE5vZGU6IGdldE5vZGUkMSxcbiAgICAgICAgZ2V0U2VsLFxuICAgICAgICBzZXRSbmcsXG4gICAgICAgIGdldFJuZzogZ2V0Um5nJDEsXG4gICAgICAgIGdldFN0YXJ0OiBnZXRTdGFydCQxLFxuICAgICAgICBnZXRFbmQsXG4gICAgICAgIGdldFNlbGVjdGVkQmxvY2tzOiBnZXRTZWxlY3RlZEJsb2NrcyQxLFxuICAgICAgICBub3JtYWxpemUsXG4gICAgICAgIHNlbGVjdG9yQ2hhbmdlZCxcbiAgICAgICAgc2VsZWN0b3JDaGFuZ2VkV2l0aFVuYmluZCxcbiAgICAgICAgZ2V0U2Nyb2xsQ29udGFpbmVyLFxuICAgICAgICBzY3JvbGxJbnRvVmlldyxcbiAgICAgICAgcGxhY2VDYXJldEF0LFxuICAgICAgICBnZXRCb3VuZGluZ0NsaWVudFJlY3QsXG4gICAgICAgIGRlc3Ryb3lcbiAgICAgIH07XG4gICAgICBjb25zdCBib29rbWFya01hbmFnZXIgPSBCb29rbWFya01hbmFnZXIoZXhwb3J0cyk7XG4gICAgICBjb25zdCBjb250cm9sU2VsZWN0aW9uID0gQ29udHJvbFNlbGVjdGlvbihleHBvcnRzLCBlZGl0b3IpO1xuICAgICAgZXhwb3J0cy5ib29rbWFya01hbmFnZXIgPSBib29rbWFya01hbmFnZXI7XG4gICAgICBleHBvcnRzLmNvbnRyb2xTZWxlY3Rpb24gPSBjb250cm9sU2VsZWN0aW9uO1xuICAgICAgcmV0dXJuIGV4cG9ydHM7XG4gICAgfTtcblxuICAgIGNvbnN0IHJlZ2lzdGVyJDMgPSAoaHRtbFBhcnNlciwgc2V0dGluZ3MsIGRvbSkgPT4ge1xuICAgICAgaHRtbFBhcnNlci5hZGRBdHRyaWJ1dGVGaWx0ZXIoJ2RhdGEtbWNlLXRhYmluZGV4JywgKG5vZGVzLCBuYW1lKSA9PiB7XG4gICAgICAgIGxldCBpID0gbm9kZXMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgIG5vZGUuYXR0cigndGFiaW5kZXgnLCBub2RlLmF0dHIoJ2RhdGEtbWNlLXRhYmluZGV4JykpO1xuICAgICAgICAgIG5vZGUuYXR0cihuYW1lLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBodG1sUGFyc2VyLmFkZEF0dHJpYnV0ZUZpbHRlcignc3JjLGhyZWYsc3R5bGUnLCAobm9kZXMsIG5hbWUpID0+IHtcbiAgICAgICAgY29uc3QgaW50ZXJuYWxOYW1lID0gJ2RhdGEtbWNlLScgKyBuYW1lO1xuICAgICAgICBjb25zdCB1cmxDb252ZXJ0ZXIgPSBzZXR0aW5ncy51cmxfY29udmVydGVyO1xuICAgICAgICBjb25zdCB1cmxDb252ZXJ0ZXJTY29wZSA9IHNldHRpbmdzLnVybF9jb252ZXJ0ZXJfc2NvcGU7XG4gICAgICAgIGxldCBpID0gbm9kZXMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgIGxldCB2YWx1ZSA9IG5vZGUuYXR0cihpbnRlcm5hbE5hbWUpO1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBub2RlLmF0dHIobmFtZSwgdmFsdWUubGVuZ3RoID4gMCA/IHZhbHVlIDogbnVsbCk7XG4gICAgICAgICAgICBub2RlLmF0dHIoaW50ZXJuYWxOYW1lLCBudWxsKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBub2RlLmF0dHIobmFtZSk7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ3N0eWxlJykge1xuICAgICAgICAgICAgICB2YWx1ZSA9IGRvbS5zZXJpYWxpemVTdHlsZShkb20ucGFyc2VTdHlsZSh2YWx1ZSksIG5vZGUubmFtZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHVybENvbnZlcnRlcikge1xuICAgICAgICAgICAgICB2YWx1ZSA9IHVybENvbnZlcnRlci5jYWxsKHVybENvbnZlcnRlclNjb3BlLCB2YWx1ZSwgbmFtZSwgbm9kZS5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUuYXR0cihuYW1lLCB2YWx1ZS5sZW5ndGggPiAwID8gdmFsdWUgOiBudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaHRtbFBhcnNlci5hZGRBdHRyaWJ1dGVGaWx0ZXIoJ2NsYXNzJywgbm9kZXMgPT4ge1xuICAgICAgICBsZXQgaSA9IG5vZGVzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICBsZXQgdmFsdWUgPSBub2RlLmF0dHIoJ2NsYXNzJyk7XG4gICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG5vZGUuYXR0cignY2xhc3MnKS5yZXBsYWNlKC8oPzpefFxccyltY2UtaXRlbS1cXHcrKD8hXFxTKS9nLCAnJyk7XG4gICAgICAgICAgICBub2RlLmF0dHIoJ2NsYXNzJywgdmFsdWUubGVuZ3RoID4gMCA/IHZhbHVlIDogbnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGh0bWxQYXJzZXIuYWRkQXR0cmlidXRlRmlsdGVyKCdkYXRhLW1jZS10eXBlJywgKG5vZGVzLCBuYW1lLCBhcmdzKSA9PiB7XG4gICAgICAgIGxldCBpID0gbm9kZXMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgIGlmIChub2RlLmF0dHIoJ2RhdGEtbWNlLXR5cGUnKSA9PT0gJ2Jvb2ttYXJrJyAmJiAhYXJncy5jbGVhbnVwKSB7XG4gICAgICAgICAgICBjb25zdCBoYXNDaGlsZHJlbiA9IE9wdGlvbmFsLmZyb20obm9kZS5maXJzdENoaWxkKS5leGlzdHMoZmlyc3RDaGlsZCA9PiAhaXNad3NwKGZpcnN0Q2hpbGQudmFsdWUpKTtcbiAgICAgICAgICAgIGlmIChoYXNDaGlsZHJlbikge1xuICAgICAgICAgICAgICBub2RlLnVud3JhcCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaHRtbFBhcnNlci5hZGROb2RlRmlsdGVyKCdub3NjcmlwdCcsIG5vZGVzID0+IHtcbiAgICAgICAgbGV0IGkgPSBub2Rlcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV0uZmlyc3RDaGlsZDtcbiAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgbm9kZS52YWx1ZSA9IEVudGl0aWVzLmRlY29kZShub2RlLnZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaHRtbFBhcnNlci5hZGROb2RlRmlsdGVyKCdzY3JpcHQsc3R5bGUnLCAobm9kZXMsIG5hbWUpID0+IHtcbiAgICAgICAgY29uc3QgdHJpbSA9IHZhbHVlID0+IHtcbiAgICAgICAgICByZXR1cm4gdmFsdWUucmVwbGFjZSgvKDwhLS1cXFtDREFUQVxcW3xcXF1cXF0tLT4pL2csICdcXG4nKS5yZXBsYWNlKC9eW1xcclxcbl0qfFtcXHJcXG5dKiQvZywgJycpLnJlcGxhY2UoL15cXHMqKCg8IS0tKT8oXFxzKlxcL1xcLyk/XFxzKjwhXFxbQ0RBVEFcXFt8KDwhLS1cXHMqKT9cXC9cXCpcXHMqPCFcXFtDREFUQVxcW1xccypcXCpcXC98KFxcL1xcLyk/XFxzKjwhLS18XFwvXFwqXFxzKjwhLS1cXHMqXFwqXFwvKVxccypbXFxyXFxuXSovZ2ksICcnKS5yZXBsYWNlKC9cXHMqKFxcL1xcKlxccypcXF1cXF0+XFxzKlxcKlxcLygtLT4pP3xcXHMqXFwvXFwvXFxzKlxcXVxcXT4oLS0+KT98XFwvXFwvXFxzKigtLT4pP3xcXF1cXF0+fFxcL1xcKlxccyotLT5cXHMqXFwqXFwvfFxccyotLT5cXHMqKVxccyokL2csICcnKTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGkgPSBub2Rlcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBub2RlLmZpcnN0Q2hpbGQgPyBub2RlLmZpcnN0Q2hpbGQudmFsdWUgOiAnJztcbiAgICAgICAgICBpZiAobmFtZSA9PT0gJ3NjcmlwdCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBub2RlLmF0dHIoJ3R5cGUnKTtcbiAgICAgICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICAgIG5vZGUuYXR0cigndHlwZScsIHR5cGUgPT09ICdtY2Utbm8vdHlwZScgPyBudWxsIDogdHlwZS5yZXBsYWNlKC9ebWNlXFwtLywgJycpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5lbGVtZW50X2Zvcm1hdCA9PT0gJ3hodG1sJyAmJiB2YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIG5vZGUuZmlyc3RDaGlsZC52YWx1ZSA9ICcvLyA8IVtDREFUQVtcXG4nICsgdHJpbSh2YWx1ZSkgKyAnXFxuLy8gXV0+JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmVsZW1lbnRfZm9ybWF0ID09PSAneGh0bWwnICYmIHZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgbm9kZS5maXJzdENoaWxkLnZhbHVlID0gJzwhLS1cXG4nICsgdHJpbSh2YWx1ZSkgKyAnXFxuLS0+JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaHRtbFBhcnNlci5hZGROb2RlRmlsdGVyKCcjY29tbWVudCcsIG5vZGVzID0+IHtcbiAgICAgICAgbGV0IGkgPSBub2Rlcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgaWYgKHNldHRpbmdzLnByZXNlcnZlX2NkYXRhICYmIG5vZGUudmFsdWUuaW5kZXhPZignW0NEQVRBWycpID09PSAwKSB7XG4gICAgICAgICAgICBub2RlLm5hbWUgPSAnI2NkYXRhJztcbiAgICAgICAgICAgIG5vZGUudHlwZSA9IDQ7XG4gICAgICAgICAgICBub2RlLnZhbHVlID0gZG9tLmRlY29kZShub2RlLnZhbHVlLnJlcGxhY2UoL15cXFtDREFUQVxcW3xcXF1cXF0kL2csICcnKSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChub2RlLnZhbHVlLmluZGV4T2YoJ21jZTpwcm90ZWN0ZWQgJykgPT09IDApIHtcbiAgICAgICAgICAgIG5vZGUubmFtZSA9ICcjdGV4dCc7XG4gICAgICAgICAgICBub2RlLnR5cGUgPSAzO1xuICAgICAgICAgICAgbm9kZS5yYXcgPSB0cnVlO1xuICAgICAgICAgICAgbm9kZS52YWx1ZSA9IHVuZXNjYXBlKG5vZGUudmFsdWUpLnN1YnN0cigxNCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGh0bWxQYXJzZXIuYWRkTm9kZUZpbHRlcigneG1sOm5hbWVzcGFjZSxpbnB1dCcsIChub2RlcywgbmFtZSkgPT4ge1xuICAgICAgICBsZXQgaSA9IG5vZGVzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICBpZiAobm9kZS50eXBlID09PSA3KSB7XG4gICAgICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2lucHV0JyAmJiAhbm9kZS5hdHRyKCd0eXBlJykpIHtcbiAgICAgICAgICAgICAgbm9kZS5hdHRyKCd0eXBlJywgJ3RleHQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaHRtbFBhcnNlci5hZGRBdHRyaWJ1dGVGaWx0ZXIoJ2RhdGEtbWNlLXR5cGUnLCBub2RlcyA9PiB7XG4gICAgICAgIGVhY2gkZyhub2Rlcywgbm9kZSA9PiB7XG4gICAgICAgICAgaWYgKG5vZGUuYXR0cignZGF0YS1tY2UtdHlwZScpID09PSAnZm9ybWF0LWNhcmV0Jykge1xuICAgICAgICAgICAgaWYgKG5vZGUuaXNFbXB0eShodG1sUGFyc2VyLnNjaGVtYS5nZXROb25FbXB0eUVsZW1lbnRzKCkpKSB7XG4gICAgICAgICAgICAgIG5vZGUucmVtb3ZlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBub2RlLnVud3JhcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGh0bWxQYXJzZXIuYWRkQXR0cmlidXRlRmlsdGVyKCdkYXRhLW1jZS1zcmMsZGF0YS1tY2UtaHJlZixkYXRhLW1jZS1zdHlsZSwnICsgJ2RhdGEtbWNlLXNlbGVjdGVkLGRhdGEtbWNlLWV4cGFuZG8sJyArICdkYXRhLW1jZS10eXBlLGRhdGEtbWNlLXJlc2l6ZSxkYXRhLW1jZS1wbGFjZWhvbGRlcicsIChub2RlcywgbmFtZSkgPT4ge1xuICAgICAgICBsZXQgaSA9IG5vZGVzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgIG5vZGVzW2ldLmF0dHIobmFtZSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgdHJpbVRyYWlsaW5nQnIgPSByb290Tm9kZSA9PiB7XG4gICAgICBjb25zdCBpc0JyID0gbm9kZSA9PiB7XG4gICAgICAgIHJldHVybiBub2RlICYmIG5vZGUubmFtZSA9PT0gJ2JyJztcbiAgICAgIH07XG4gICAgICBjb25zdCBick5vZGUxID0gcm9vdE5vZGUubGFzdENoaWxkO1xuICAgICAgaWYgKGlzQnIoYnJOb2RlMSkpIHtcbiAgICAgICAgY29uc3QgYnJOb2RlMiA9IGJyTm9kZTEucHJldjtcbiAgICAgICAgaWYgKGlzQnIoYnJOb2RlMikpIHtcbiAgICAgICAgICBick5vZGUxLnJlbW92ZSgpO1xuICAgICAgICAgIGJyTm9kZTIucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgcHJlUHJvY2VzcyQxID0gKGVkaXRvciwgbm9kZSwgYXJncykgPT4ge1xuICAgICAgbGV0IG9sZERvYztcbiAgICAgIGNvbnN0IGRvbSA9IGVkaXRvci5kb207XG4gICAgICBsZXQgY2xvbmVkTm9kZSA9IG5vZGUuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgY29uc3QgaW1wbCA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uO1xuICAgICAgaWYgKGltcGwuY3JlYXRlSFRNTERvY3VtZW50KSB7XG4gICAgICAgIGNvbnN0IGRvYyA9IGltcGwuY3JlYXRlSFRNTERvY3VtZW50KCcnKTtcbiAgICAgICAgVG9vbHMuZWFjaChjbG9uZWROb2RlLm5vZGVOYW1lID09PSAnQk9EWScgPyBjbG9uZWROb2RlLmNoaWxkTm9kZXMgOiBbY2xvbmVkTm9kZV0sIG5vZGUgPT4ge1xuICAgICAgICAgIGRvYy5ib2R5LmFwcGVuZENoaWxkKGRvYy5pbXBvcnROb2RlKG5vZGUsIHRydWUpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjbG9uZWROb2RlLm5vZGVOYW1lICE9PSAnQk9EWScpIHtcbiAgICAgICAgICBjbG9uZWROb2RlID0gZG9jLmJvZHkuZmlyc3RDaGlsZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbG9uZWROb2RlID0gZG9jLmJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgb2xkRG9jID0gZG9tLmRvYztcbiAgICAgICAgZG9tLmRvYyA9IGRvYztcbiAgICAgIH1cbiAgICAgIGZpcmVQcmVQcm9jZXNzKGVkaXRvciwge1xuICAgICAgICAuLi5hcmdzLFxuICAgICAgICBub2RlOiBjbG9uZWROb2RlXG4gICAgICB9KTtcbiAgICAgIGlmIChvbGREb2MpIHtcbiAgICAgICAgZG9tLmRvYyA9IG9sZERvYztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjbG9uZWROb2RlO1xuICAgIH07XG4gICAgY29uc3Qgc2hvdWxkRmlyZUV2ZW50ID0gKGVkaXRvciwgYXJncykgPT4ge1xuICAgICAgcmV0dXJuIGVkaXRvciAmJiBlZGl0b3IuaGFzRXZlbnRMaXN0ZW5lcnMoJ1ByZVByb2Nlc3MnKSAmJiAhYXJncy5ub19ldmVudHM7XG4gICAgfTtcbiAgICBjb25zdCBwcm9jZXNzJDEgPSAoZWRpdG9yLCBub2RlLCBhcmdzKSA9PiB7XG4gICAgICByZXR1cm4gc2hvdWxkRmlyZUV2ZW50KGVkaXRvciwgYXJncykgPyBwcmVQcm9jZXNzJDEoZWRpdG9yLCBub2RlLCBhcmdzKSA6IG5vZGU7XG4gICAgfTtcblxuICAgIGNvbnN0IGFkZFRlbXBBdHRyID0gKGh0bWxQYXJzZXIsIHRlbXBBdHRycywgbmFtZSkgPT4ge1xuICAgICAgaWYgKFRvb2xzLmluQXJyYXkodGVtcEF0dHJzLCBuYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgaHRtbFBhcnNlci5hZGRBdHRyaWJ1dGVGaWx0ZXIobmFtZSwgKG5vZGVzLCBuYW1lKSA9PiB7XG4gICAgICAgICAgbGV0IGkgPSBub2Rlcy5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgbm9kZXNbaV0uYXR0cihuYW1lLCBudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0ZW1wQXR0cnMucHVzaChuYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHBvc3RQcm9jZXNzID0gKGVkaXRvciwgYXJncywgY29udGVudCkgPT4ge1xuICAgICAgaWYgKCFhcmdzLm5vX2V2ZW50cyAmJiBlZGl0b3IpIHtcbiAgICAgICAgY29uc3Qgb3V0QXJncyA9IGZpcmVQb3N0UHJvY2VzcyhlZGl0b3IsIHtcbiAgICAgICAgICAuLi5hcmdzLFxuICAgICAgICAgIGNvbnRlbnRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvdXRBcmdzLmNvbnRlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGdldEh0bWxGcm9tTm9kZSA9IChkb20sIG5vZGUsIGFyZ3MpID0+IHtcbiAgICAgIGNvbnN0IGh0bWwgPSB0cmltJDEoYXJncy5nZXRJbm5lciA/IG5vZGUuaW5uZXJIVE1MIDogZG9tLmdldE91dGVySFRNTChub2RlKSk7XG4gICAgICByZXR1cm4gYXJncy5zZWxlY3Rpb24gfHwgaXNXc1ByZXNlcnZlRWxlbWVudChTdWdhckVsZW1lbnQuZnJvbURvbShub2RlKSkgPyBodG1sIDogVG9vbHMudHJpbShodG1sKTtcbiAgICB9O1xuICAgIGNvbnN0IHBhcnNlSHRtbCA9IChodG1sUGFyc2VyLCBodG1sLCBhcmdzKSA9PiB7XG4gICAgICBjb25zdCBwYXJzZXJBcmdzID0gYXJncy5zZWxlY3Rpb24gPyB7XG4gICAgICAgIGZvcmNlZF9yb290X2Jsb2NrOiBmYWxzZSxcbiAgICAgICAgLi4uYXJnc1xuICAgICAgfSA6IGFyZ3M7XG4gICAgICBjb25zdCByb290Tm9kZSA9IGh0bWxQYXJzZXIucGFyc2UoaHRtbCwgcGFyc2VyQXJncyk7XG4gICAgICB0cmltVHJhaWxpbmdCcihyb290Tm9kZSk7XG4gICAgICByZXR1cm4gcm9vdE5vZGU7XG4gICAgfTtcbiAgICBjb25zdCBzZXJpYWxpemVOb2RlID0gKHNldHRpbmdzLCBzY2hlbWEsIG5vZGUpID0+IHtcbiAgICAgIGNvbnN0IGh0bWxTZXJpYWxpemVyID0gSHRtbFNlcmlhbGl6ZXIoc2V0dGluZ3MsIHNjaGVtYSk7XG4gICAgICByZXR1cm4gaHRtbFNlcmlhbGl6ZXIuc2VyaWFsaXplKG5vZGUpO1xuICAgIH07XG4gICAgY29uc3QgdG9IdG1sID0gKGVkaXRvciwgc2V0dGluZ3MsIHNjaGVtYSwgcm9vdE5vZGUsIGFyZ3MpID0+IHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBzZXJpYWxpemVOb2RlKHNldHRpbmdzLCBzY2hlbWEsIHJvb3ROb2RlKTtcbiAgICAgIHJldHVybiBwb3N0UHJvY2VzcyhlZGl0b3IsIGFyZ3MsIGNvbnRlbnQpO1xuICAgIH07XG4gICAgY29uc3QgRG9tU2VyaWFsaXplckltcGwgPSAoc2V0dGluZ3MsIGVkaXRvcikgPT4ge1xuICAgICAgY29uc3QgdGVtcEF0dHJzID0gWydkYXRhLW1jZS1zZWxlY3RlZCddO1xuICAgICAgY29uc3QgZG9tID0gZWRpdG9yICYmIGVkaXRvci5kb20gPyBlZGl0b3IuZG9tIDogRE9NVXRpbHMuRE9NO1xuICAgICAgY29uc3Qgc2NoZW1hID0gZWRpdG9yICYmIGVkaXRvci5zY2hlbWEgPyBlZGl0b3Iuc2NoZW1hIDogU2NoZW1hKHNldHRpbmdzKTtcbiAgICAgIHNldHRpbmdzLmVudGl0eV9lbmNvZGluZyA9IHNldHRpbmdzLmVudGl0eV9lbmNvZGluZyB8fCAnbmFtZWQnO1xuICAgICAgc2V0dGluZ3MucmVtb3ZlX3RyYWlsaW5nX2JycyA9ICdyZW1vdmVfdHJhaWxpbmdfYnJzJyBpbiBzZXR0aW5ncyA/IHNldHRpbmdzLnJlbW92ZV90cmFpbGluZ19icnMgOiB0cnVlO1xuICAgICAgY29uc3QgaHRtbFBhcnNlciA9IERvbVBhcnNlcihzZXR0aW5ncywgc2NoZW1hKTtcbiAgICAgIHJlZ2lzdGVyJDMoaHRtbFBhcnNlciwgc2V0dGluZ3MsIGRvbSk7XG4gICAgICBjb25zdCBzZXJpYWxpemUgPSAobm9kZSwgcGFyc2VyQXJncyA9IHt9KSA9PiB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB7XG4gICAgICAgICAgZm9ybWF0OiAnaHRtbCcsXG4gICAgICAgICAgLi4ucGFyc2VyQXJnc1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB0YXJnZXROb2RlID0gcHJvY2VzcyQxKGVkaXRvciwgbm9kZSwgYXJncyk7XG4gICAgICAgIGNvbnN0IGh0bWwgPSBnZXRIdG1sRnJvbU5vZGUoZG9tLCB0YXJnZXROb2RlLCBhcmdzKTtcbiAgICAgICAgY29uc3Qgcm9vdE5vZGUgPSBwYXJzZUh0bWwoaHRtbFBhcnNlciwgaHRtbCwgYXJncyk7XG4gICAgICAgIHJldHVybiBhcmdzLmZvcm1hdCA9PT0gJ3RyZWUnID8gcm9vdE5vZGUgOiB0b0h0bWwoZWRpdG9yLCBzZXR0aW5ncywgc2NoZW1hLCByb290Tm9kZSwgYXJncyk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2NoZW1hLFxuICAgICAgICBhZGROb2RlRmlsdGVyOiBodG1sUGFyc2VyLmFkZE5vZGVGaWx0ZXIsXG4gICAgICAgIGFkZEF0dHJpYnV0ZUZpbHRlcjogaHRtbFBhcnNlci5hZGRBdHRyaWJ1dGVGaWx0ZXIsXG4gICAgICAgIHNlcmlhbGl6ZTogc2VyaWFsaXplLFxuICAgICAgICBhZGRSdWxlczogc2NoZW1hLmFkZFZhbGlkRWxlbWVudHMsXG4gICAgICAgIHNldFJ1bGVzOiBzY2hlbWEuc2V0VmFsaWRFbGVtZW50cyxcbiAgICAgICAgYWRkVGVtcEF0dHI6IGN1cnJ5KGFkZFRlbXBBdHRyLCBodG1sUGFyc2VyLCB0ZW1wQXR0cnMpLFxuICAgICAgICBnZXRUZW1wQXR0cnM6IGNvbnN0YW50KHRlbXBBdHRycyksXG4gICAgICAgIGdldE5vZGVGaWx0ZXJzOiBodG1sUGFyc2VyLmdldE5vZGVGaWx0ZXJzLFxuICAgICAgICBnZXRBdHRyaWJ1dGVGaWx0ZXJzOiBodG1sUGFyc2VyLmdldEF0dHJpYnV0ZUZpbHRlcnNcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IERvbVNlcmlhbGl6ZXIgPSAoc2V0dGluZ3MsIGVkaXRvcikgPT4ge1xuICAgICAgY29uc3QgZG9tU2VyaWFsaXplciA9IERvbVNlcmlhbGl6ZXJJbXBsKHNldHRpbmdzLCBlZGl0b3IpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2NoZW1hOiBkb21TZXJpYWxpemVyLnNjaGVtYSxcbiAgICAgICAgYWRkTm9kZUZpbHRlcjogZG9tU2VyaWFsaXplci5hZGROb2RlRmlsdGVyLFxuICAgICAgICBhZGRBdHRyaWJ1dGVGaWx0ZXI6IGRvbVNlcmlhbGl6ZXIuYWRkQXR0cmlidXRlRmlsdGVyLFxuICAgICAgICBzZXJpYWxpemU6IGRvbVNlcmlhbGl6ZXIuc2VyaWFsaXplLFxuICAgICAgICBhZGRSdWxlczogZG9tU2VyaWFsaXplci5hZGRSdWxlcyxcbiAgICAgICAgc2V0UnVsZXM6IGRvbVNlcmlhbGl6ZXIuc2V0UnVsZXMsXG4gICAgICAgIGFkZFRlbXBBdHRyOiBkb21TZXJpYWxpemVyLmFkZFRlbXBBdHRyLFxuICAgICAgICBnZXRUZW1wQXR0cnM6IGRvbVNlcmlhbGl6ZXIuZ2V0VGVtcEF0dHJzLFxuICAgICAgICBnZXROb2RlRmlsdGVyczogZG9tU2VyaWFsaXplci5nZXROb2RlRmlsdGVycyxcbiAgICAgICAgZ2V0QXR0cmlidXRlRmlsdGVyczogZG9tU2VyaWFsaXplci5nZXRBdHRyaWJ1dGVGaWx0ZXJzXG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCBkZWZhdWx0Rm9ybWF0JDEgPSAnaHRtbCc7XG4gICAgY29uc3Qgc2V0dXBBcmdzJDEgPSAoYXJncywgZm9ybWF0KSA9PiAoe1xuICAgICAgLi4uYXJncyxcbiAgICAgIGZvcm1hdCxcbiAgICAgIGdldDogdHJ1ZSxcbiAgICAgIGdldElubmVyOiB0cnVlXG4gICAgfSk7XG4gICAgY29uc3QgZ2V0Q29udGVudCA9IChlZGl0b3IsIGFyZ3MgPSB7fSkgPT4ge1xuICAgICAgY29uc3QgZm9ybWF0ID0gYXJncy5mb3JtYXQgPyBhcmdzLmZvcm1hdCA6IGRlZmF1bHRGb3JtYXQkMTtcbiAgICAgIGNvbnN0IGRlZmF1bHRlZEFyZ3MgPSBzZXR1cEFyZ3MkMShhcmdzLCBmb3JtYXQpO1xuICAgICAgcmV0dXJuIHByZVByb2Nlc3NHZXRDb250ZW50KGVkaXRvciwgZGVmYXVsdGVkQXJncykuZm9sZChpZGVudGl0eSwgdXBkYXRlZEFyZ3MgPT4ge1xuICAgICAgICBjb25zdCBjb250ZW50ID0gZ2V0Q29udGVudCQyKGVkaXRvciwgdXBkYXRlZEFyZ3MpO1xuICAgICAgICByZXR1cm4gcG9zdFByb2Nlc3NHZXRDb250ZW50KGVkaXRvciwgY29udGVudCwgdXBkYXRlZEFyZ3MpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGRlZmF1bHRGb3JtYXQgPSAnaHRtbCc7XG4gICAgY29uc3Qgc2V0dXBBcmdzID0gKGFyZ3MsIGNvbnRlbnQpID0+ICh7XG4gICAgICBmb3JtYXQ6IGRlZmF1bHRGb3JtYXQsXG4gICAgICAuLi5hcmdzLFxuICAgICAgc2V0OiB0cnVlLFxuICAgICAgY29udGVudFxuICAgIH0pO1xuICAgIGNvbnN0IHNldENvbnRlbnQgPSAoZWRpdG9yLCBjb250ZW50LCBhcmdzID0ge30pID0+IHtcbiAgICAgIGNvbnN0IGRlZmF1bHRlZEFyZ3MgPSBzZXR1cEFyZ3MoYXJncywgY29udGVudCk7XG4gICAgICByZXR1cm4gcHJlUHJvY2Vzc1NldENvbnRlbnQoZWRpdG9yLCBkZWZhdWx0ZWRBcmdzKS5tYXAodXBkYXRlZEFyZ3MgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBzZXRDb250ZW50JDIoZWRpdG9yLCB1cGRhdGVkQXJncy5jb250ZW50LCB1cGRhdGVkQXJncyk7XG4gICAgICAgIHBvc3RQcm9jZXNzU2V0Q29udGVudChlZGl0b3IsIHJlc3VsdC5odG1sLCB1cGRhdGVkQXJncyk7XG4gICAgICAgIHJldHVybiByZXN1bHQuY29udGVudDtcbiAgICAgIH0pLmdldE9yKGNvbnRlbnQpO1xuICAgIH07XG5cbiAgICBjb25zdCByZW1vdmVkT3B0aW9ucyA9ICgnYXV0b3Jlc2l6ZV9vbl9pbml0LGNvbnRlbnRfZWRpdGFibGVfc3RhdGUscGFkZF9lbXB0eV93aXRoX2JyLGJsb2NrX2VsZW1lbnRzLCcgKyAnYm9vbGVhbl9hdHRyaWJ1dGVzLGVkaXRvcl9kZXNlbGVjdG9yLGVkaXRvcl9zZWxlY3RvcixlbGVtZW50cyxmaWxlX2Jyb3dzZXJfY2FsbGJhY2tfdHlwZXMsZmlsZXBpY2tlcl92YWxpZGF0b3JfaGFuZGxlciwnICsgJ2ZvcmNlX2hleF9zdHlsZV9jb2xvcnMsZm9yY2VfcF9uZXdsaW5lcyxnZWNrb19zcGVsbGNoZWNrLGltYWdlc19kYXRhaW1nX2ZpbHRlcixtZWRpYV9zY3JpcHRzLG1vZGUsbW92ZV9jYXJldF9iZWZvcmVfb25fZW50ZXJfZWxlbWVudHMsJyArICdub25fZW1wdHlfZWxlbWVudHMsc2VsZl9jbG9zaW5nX2VsZW1lbnRzLHNob3J0X2VuZGVkX2VsZW1lbnRzLHNwZWNpYWwsc3BlbGxjaGVja2VyX3NlbGVjdF9sYW5ndWFnZXMsc3BlbGxjaGVja2VyX3doaXRlbGlzdCwnICsgJ3RhYl9mb2N1cyx0YWJmb2N1c19lbGVtZW50cyx0YWJsZV9yZXNwb25zaXZlX3dpZHRoLHRleHRfYmxvY2tfZWxlbWVudHMsdGV4dF9pbmxpbmVfZWxlbWVudHMsdG9vbGJhcl9kcmF3ZXIsdHlwZXMsdmFsaWRhdGUsd2hpdGVzcGFjZV9lbGVtZW50cywnICsgJ3Bhc3RlX2VuYWJsZV9kZWZhdWx0X2ZpbHRlcnMscGFzdGVfZmlsdGVyX2Ryb3AscGFzdGVfd29yZF92YWxpZF9lbGVtZW50cyxwYXN0ZV9yZXRhaW5fc3R5bGVfcHJvcGVydGllcyxwYXN0ZV9jb252ZXJ0X3dvcmRfZmFrZV9saXN0cycpLnNwbGl0KCcsJyk7XG4gICAgY29uc3QgcmVtb3ZlZFBsdWdpbnMgPSAnYmJjb2RlLGNvbG9ycGlja2VyLGNvbnRleHRtZW51LGZ1bGxwYWdlLGxlZ2FjeW91dHB1dCxzcGVsbGNoZWNrZXIsdGV4dGNvbG9yJy5zcGxpdCgnLCcpO1xuICAgIGNvbnN0IGdldFJlbW92ZWRPcHRpb25zID0gb3B0aW9ucyA9PiB7XG4gICAgICBjb25zdCBzZXR0aW5nTmFtZXMgPSBmaWx0ZXIkNihyZW1vdmVkT3B0aW9ucywgc2V0dGluZyA9PiBoYXMkMihvcHRpb25zLCBzZXR0aW5nKSk7XG4gICAgICBjb25zdCBmb3JjZWRSb290QmxvY2sgPSBvcHRpb25zLmZvcmNlZF9yb290X2Jsb2NrO1xuICAgICAgaWYgKGZvcmNlZFJvb3RCbG9jayA9PT0gZmFsc2UgfHwgZm9yY2VkUm9vdEJsb2NrID09PSAnJykge1xuICAgICAgICBzZXR0aW5nTmFtZXMucHVzaCgnZm9yY2VkX3Jvb3RfYmxvY2sgKGZhbHNlIG9ubHkpJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc29ydChzZXR0aW5nTmFtZXMpO1xuICAgIH07XG4gICAgY29uc3QgZ2V0UmVtb3ZlZFBsdWdpbnMgPSBvcHRpb25zID0+IHtcbiAgICAgIGNvbnN0IHBsdWdpbnMgPSBUb29scy5tYWtlTWFwKG9wdGlvbnMucGx1Z2lucywgJyAnKTtcbiAgICAgIGNvbnN0IGhhc1BsdWdpbiA9IHBsdWdpbiA9PiBoYXMkMihwbHVnaW5zLCBwbHVnaW4pO1xuICAgICAgY29uc3QgcGx1Z2luTmFtZXMgPSBmaWx0ZXIkNihyZW1vdmVkUGx1Z2lucywgaGFzUGx1Z2luKTtcbiAgICAgIHJldHVybiBzb3J0KHBsdWdpbk5hbWVzKTtcbiAgICB9O1xuICAgIGNvbnN0IGxvZ1JlbW92ZWRXYXJuaW5ncyA9IChyYXdPcHRpb25zLCBub3JtYWxpemVkT3B0aW9ucykgPT4ge1xuICAgICAgY29uc3QgcmVtb3ZlZE9wdGlvbnMgPSBnZXRSZW1vdmVkT3B0aW9ucyhyYXdPcHRpb25zKTtcbiAgICAgIGNvbnN0IHJlbW92ZWRQbHVnaW5zID0gZ2V0UmVtb3ZlZFBsdWdpbnMobm9ybWFsaXplZE9wdGlvbnMpO1xuICAgICAgY29uc3QgaGFzUmVtb3ZlZFBsdWdpbnMgPSByZW1vdmVkUGx1Z2lucy5sZW5ndGggPiAwO1xuICAgICAgY29uc3QgaGFzUmVtb3ZlZE9wdGlvbnMgPSByZW1vdmVkT3B0aW9ucy5sZW5ndGggPiAwO1xuICAgICAgY29uc3QgaXNMZWdhY3lNb2JpbGVUaGVtZSA9IG5vcm1hbGl6ZWRPcHRpb25zLnRoZW1lID09PSAnbW9iaWxlJztcbiAgICAgIGlmIChoYXNSZW1vdmVkUGx1Z2lucyB8fCBoYXNSZW1vdmVkT3B0aW9ucyB8fCBpc0xlZ2FjeU1vYmlsZVRoZW1lKSB7XG4gICAgICAgIGNvbnN0IGxpc3RKb2luZXIgPSAnXFxuLSAnO1xuICAgICAgICBjb25zdCB0aGVtZXNNZXNzYWdlID0gaXNMZWdhY3lNb2JpbGVUaGVtZSA/IGBcXG5cXG5UaGVtZXM6JHsgbGlzdEpvaW5lciB9bW9iaWxlYCA6ICcnO1xuICAgICAgICBjb25zdCBwbHVnaW5zTWVzc2FnZSA9IGhhc1JlbW92ZWRQbHVnaW5zID8gYFxcblxcblBsdWdpbnM6JHsgbGlzdEpvaW5lciB9JHsgcmVtb3ZlZFBsdWdpbnMuam9pbihsaXN0Sm9pbmVyKSB9YCA6ICcnO1xuICAgICAgICBjb25zdCBvcHRpb25zTWVzc2FnZSA9IGhhc1JlbW92ZWRPcHRpb25zID8gYFxcblxcbk9wdGlvbnM6JHsgbGlzdEpvaW5lciB9JHsgcmVtb3ZlZE9wdGlvbnMuam9pbihsaXN0Sm9pbmVyKSB9YCA6ICcnO1xuICAgICAgICBjb25zb2xlLndhcm4oJ1RoZSBmb2xsb3dpbmcgZGVwcmVjYXRlZCBmZWF0dXJlcyBhcmUgY3VycmVudGx5IGVuYWJsZWQgYW5kIGhhdmUgYmVlbiByZW1vdmVkIGluIFRpbnlNQ0UgNi4wLiBUaGVzZSBmZWF0dXJlcyB3aWxsIG5vIGxvbmdlciB3b3JrIGFuZCBzaG91bGQgYmUgcmVtb3ZlZCBmcm9tIHRoZSBUaW55TUNFIGNvbmZpZ3VyYXRpb24uICcgKyAnU2VlIGh0dHBzOi8vd3d3LnRpbnkuY2xvdWQvZG9jcy90aW55bWNlLzYvbWlncmF0aW9uLWZyb20tNXgvIGZvciBtb3JlIGluZm9ybWF0aW9uLicgKyB0aGVtZXNNZXNzYWdlICsgcGx1Z2luc01lc3NhZ2UgKyBvcHRpb25zTWVzc2FnZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBsb2dXYXJuaW5ncyA9IChyYXdPcHRpb25zLCBub3JtYWxpemVkT3B0aW9ucykgPT4ge1xuICAgICAgbG9nUmVtb3ZlZFdhcm5pbmdzKHJhd09wdGlvbnMsIG5vcm1hbGl6ZWRPcHRpb25zKTtcbiAgICB9O1xuXG4gICAgY29uc3QgRE9NJDggPSBET01VdGlscy5ET007XG4gICAgY29uc3QgcmVzdG9yZU9yaWdpbmFsU3R5bGVzID0gZWRpdG9yID0+IHtcbiAgICAgIERPTSQ4LnNldFN0eWxlKGVkaXRvci5pZCwgJ2Rpc3BsYXknLCBlZGl0b3Iub3JnRGlzcGxheSk7XG4gICAgfTtcbiAgICBjb25zdCBzYWZlRGVzdHJveSA9IHggPT4gT3B0aW9uYWwuZnJvbSh4KS5lYWNoKHggPT4geC5kZXN0cm95KCkpO1xuICAgIGNvbnN0IGNsZWFyRG9tUmVmZXJlbmNlcyA9IGVkaXRvciA9PiB7XG4gICAgICBlZGl0b3IuY29udGVudEFyZWFDb250YWluZXIgPSBlZGl0b3IuZm9ybUVsZW1lbnQgPSBlZGl0b3IuY29udGFpbmVyID0gZWRpdG9yLmVkaXRvckNvbnRhaW5lciA9IG51bGw7XG4gICAgICBlZGl0b3IuYm9keUVsZW1lbnQgPSBlZGl0b3IuY29udGVudERvY3VtZW50ID0gZWRpdG9yLmNvbnRlbnRXaW5kb3cgPSBudWxsO1xuICAgICAgZWRpdG9yLmlmcmFtZUVsZW1lbnQgPSBlZGl0b3IudGFyZ2V0RWxtID0gbnVsbDtcbiAgICAgIGlmIChlZGl0b3Iuc2VsZWN0aW9uKSB7XG4gICAgICAgIGVkaXRvci5zZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uLndpbiA9IGVkaXRvci5zZWxlY3Rpb24uZG9tID0gZWRpdG9yLnNlbGVjdGlvbi5kb20uZG9jID0gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlc3RvcmVGb3JtID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IGZvcm0gPSBlZGl0b3IuZm9ybUVsZW1lbnQ7XG4gICAgICBpZiAoZm9ybSkge1xuICAgICAgICBpZiAoZm9ybS5fbWNlT2xkU3VibWl0KSB7XG4gICAgICAgICAgZm9ybS5zdWJtaXQgPSBmb3JtLl9tY2VPbGRTdWJtaXQ7XG4gICAgICAgICAgZm9ybS5fbWNlT2xkU3VibWl0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBET00kOC51bmJpbmQoZm9ybSwgJ3N1Ym1pdCByZXNldCcsIGVkaXRvci5mb3JtRXZlbnREZWxlZ2F0ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCByZW1vdmUkMSA9IGVkaXRvciA9PiB7XG4gICAgICBpZiAoIWVkaXRvci5yZW1vdmVkKSB7XG4gICAgICAgIGNvbnN0IHtfc2VsZWN0aW9uT3ZlcnJpZGVzLCBlZGl0b3JVcGxvYWR9ID0gZWRpdG9yO1xuICAgICAgICBjb25zdCBib2R5ID0gZWRpdG9yLmdldEJvZHkoKTtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IGVkaXRvci5nZXRFbGVtZW50KCk7XG4gICAgICAgIGlmIChib2R5KSB7XG4gICAgICAgICAgZWRpdG9yLnNhdmUoeyBpc19yZW1vdmluZzogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBlZGl0b3IucmVtb3ZlZCA9IHRydWU7XG4gICAgICAgIGVkaXRvci51bmJpbmRBbGxOYXRpdmVFdmVudHMoKTtcbiAgICAgICAgaWYgKGVkaXRvci5oYXNIaWRkZW5JbnB1dCAmJiBlbGVtZW50KSB7XG4gICAgICAgICAgRE9NJDgucmVtb3ZlKGVsZW1lbnQubmV4dFNpYmxpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGZpcmVSZW1vdmUoZWRpdG9yKTtcbiAgICAgICAgZWRpdG9yLmVkaXRvck1hbmFnZXIucmVtb3ZlKGVkaXRvcik7XG4gICAgICAgIGlmICghZWRpdG9yLmlubGluZSAmJiBib2R5KSB7XG4gICAgICAgICAgcmVzdG9yZU9yaWdpbmFsU3R5bGVzKGVkaXRvcik7XG4gICAgICAgIH1cbiAgICAgICAgZmlyZURldGFjaChlZGl0b3IpO1xuICAgICAgICBET00kOC5yZW1vdmUoZWRpdG9yLmdldENvbnRhaW5lcigpKTtcbiAgICAgICAgc2FmZURlc3Ryb3koX3NlbGVjdGlvbk92ZXJyaWRlcyk7XG4gICAgICAgIHNhZmVEZXN0cm95KGVkaXRvclVwbG9hZCk7XG4gICAgICAgIGVkaXRvci5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBkZXN0cm95ID0gKGVkaXRvciwgYXV0b21hdGljKSA9PiB7XG4gICAgICBjb25zdCB7c2VsZWN0aW9uLCBkb219ID0gZWRpdG9yO1xuICAgICAgaWYgKGVkaXRvci5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFhdXRvbWF0aWMgJiYgIWVkaXRvci5yZW1vdmVkKSB7XG4gICAgICAgIGVkaXRvci5yZW1vdmUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFhdXRvbWF0aWMpIHtcbiAgICAgICAgZWRpdG9yLmVkaXRvck1hbmFnZXIub2ZmKCdiZWZvcmV1bmxvYWQnLCBlZGl0b3IuX2JlZm9yZVVubG9hZCk7XG4gICAgICAgIGlmIChlZGl0b3IudGhlbWUgJiYgZWRpdG9yLnRoZW1lLmRlc3Ryb3kpIHtcbiAgICAgICAgICBlZGl0b3IudGhlbWUuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIHNhZmVEZXN0cm95KHNlbGVjdGlvbik7XG4gICAgICAgIHNhZmVEZXN0cm95KGRvbSk7XG4gICAgICB9XG4gICAgICByZXN0b3JlRm9ybShlZGl0b3IpO1xuICAgICAgY2xlYXJEb21SZWZlcmVuY2VzKGVkaXRvcik7XG4gICAgICBlZGl0b3IuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgY29uc3QgQ3JlYXRlSWNvbk1hbmFnZXIgPSAoKSA9PiB7XG4gICAgICBjb25zdCBsb29rdXAgPSB7fTtcbiAgICAgIGNvbnN0IGFkZCA9IChpZCwgaWNvblBhY2spID0+IHtcbiAgICAgICAgbG9va3VwW2lkXSA9IGljb25QYWNrO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGdldCA9IGlkID0+IHtcbiAgICAgICAgaWYgKGxvb2t1cFtpZF0pIHtcbiAgICAgICAgICByZXR1cm4gbG9va3VwW2lkXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBpY29uczoge30gfTtcbiAgICAgIH07XG4gICAgICBjb25zdCBoYXMgPSBpZCA9PiBoYXMkMihsb29rdXAsIGlkKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFkZCxcbiAgICAgICAgZ2V0LFxuICAgICAgICBoYXNcbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBJY29uTWFuYWdlciA9IENyZWF0ZUljb25NYW5hZ2VyKCk7XG5cbiAgICBjb25zdCBNb2RlbE1hbmFnZXIgPSBBZGRPbk1hbmFnZXIuTW9kZWxNYW5hZ2VyO1xuXG4gICAgY29uc3QgZ2V0UHJvcCA9IChwcm9wTmFtZSwgZWxtKSA9PiB7XG4gICAgICBjb25zdCByYXdFbG0gPSBlbG0uZG9tO1xuICAgICAgcmV0dXJuIHJhd0VsbVtwcm9wTmFtZV07XG4gICAgfTtcbiAgICBjb25zdCBnZXRDb21wdXRlZFNpemVQcm9wID0gKHByb3BOYW1lLCBlbG0pID0+IHBhcnNlSW50KGdldCQ3KGVsbSwgcHJvcE5hbWUpLCAxMCk7XG4gICAgY29uc3QgZ2V0Q2xpZW50V2lkdGggPSBjdXJyeShnZXRQcm9wLCAnY2xpZW50V2lkdGgnKTtcbiAgICBjb25zdCBnZXRDbGllbnRIZWlnaHQgPSBjdXJyeShnZXRQcm9wLCAnY2xpZW50SGVpZ2h0Jyk7XG4gICAgY29uc3QgZ2V0TWFyZ2luVG9wID0gY3VycnkoZ2V0Q29tcHV0ZWRTaXplUHJvcCwgJ21hcmdpbi10b3AnKTtcbiAgICBjb25zdCBnZXRNYXJnaW5MZWZ0ID0gY3VycnkoZ2V0Q29tcHV0ZWRTaXplUHJvcCwgJ21hcmdpbi1sZWZ0Jyk7XG4gICAgY29uc3QgZ2V0Qm91bmRpbmdDbGllbnRSZWN0ID0gZWxtID0+IGVsbS5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgaXNJbnNpZGVFbGVtZW50Q29udGVudEFyZWEgPSAoYm9keUVsbSwgY2xpZW50WCwgY2xpZW50WSkgPT4ge1xuICAgICAgY29uc3QgY2xpZW50V2lkdGggPSBnZXRDbGllbnRXaWR0aChib2R5RWxtKTtcbiAgICAgIGNvbnN0IGNsaWVudEhlaWdodCA9IGdldENsaWVudEhlaWdodChib2R5RWxtKTtcbiAgICAgIHJldHVybiBjbGllbnRYID49IDAgJiYgY2xpZW50WSA+PSAwICYmIGNsaWVudFggPD0gY2xpZW50V2lkdGggJiYgY2xpZW50WSA8PSBjbGllbnRIZWlnaHQ7XG4gICAgfTtcbiAgICBjb25zdCB0cmFuc3Bvc2UgPSAoaW5saW5lLCBlbG0sIGNsaWVudFgsIGNsaWVudFkpID0+IHtcbiAgICAgIGNvbnN0IGNsaWVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxtKTtcbiAgICAgIGNvbnN0IGRlbHRhWCA9IGlubGluZSA/IGNsaWVudFJlY3QubGVmdCArIGVsbS5kb20uY2xpZW50TGVmdCArIGdldE1hcmdpbkxlZnQoZWxtKSA6IDA7XG4gICAgICBjb25zdCBkZWx0YVkgPSBpbmxpbmUgPyBjbGllbnRSZWN0LnRvcCArIGVsbS5kb20uY2xpZW50VG9wICsgZ2V0TWFyZ2luVG9wKGVsbSkgOiAwO1xuICAgICAgY29uc3QgeCA9IGNsaWVudFggLSBkZWx0YVg7XG4gICAgICBjb25zdCB5ID0gY2xpZW50WSAtIGRlbHRhWTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBpc1hZSW5Db250ZW50QXJlYSA9IChlZGl0b3IsIGNsaWVudFgsIGNsaWVudFkpID0+IHtcbiAgICAgIGNvbnN0IGJvZHlFbG0gPSBTdWdhckVsZW1lbnQuZnJvbURvbShlZGl0b3IuZ2V0Qm9keSgpKTtcbiAgICAgIGNvbnN0IHRhcmdldEVsbSA9IGVkaXRvci5pbmxpbmUgPyBib2R5RWxtIDogZG9jdW1lbnRFbGVtZW50KGJvZHlFbG0pO1xuICAgICAgY29uc3QgdHJhbnNwb3NlZFBvaW50ID0gdHJhbnNwb3NlKGVkaXRvci5pbmxpbmUsIHRhcmdldEVsbSwgY2xpZW50WCwgY2xpZW50WSk7XG4gICAgICByZXR1cm4gaXNJbnNpZGVFbGVtZW50Q29udGVudEFyZWEodGFyZ2V0RWxtLCB0cmFuc3Bvc2VkUG9pbnQueCwgdHJhbnNwb3NlZFBvaW50LnkpO1xuICAgIH07XG4gICAgY29uc3QgZnJvbURvbVNhZmUgPSBub2RlID0+IE9wdGlvbmFsLmZyb20obm9kZSkubWFwKFN1Z2FyRWxlbWVudC5mcm9tRG9tKTtcbiAgICBjb25zdCBpc0VkaXRvckF0dGFjaGVkVG9Eb20gPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgcmF3Q29udGFpbmVyID0gZWRpdG9yLmlubGluZSA/IGVkaXRvci5nZXRCb2R5KCkgOiBlZGl0b3IuZ2V0Q29udGVudEFyZWFDb250YWluZXIoKTtcbiAgICAgIHJldHVybiBmcm9tRG9tU2FmZShyYXdDb250YWluZXIpLm1hcChpbkJvZHkpLmdldE9yKGZhbHNlKTtcbiAgICB9O1xuXG4gICAgY29uc3QgTm90aWZpY2F0aW9uTWFuYWdlckltcGwgPSAoKSA9PiB7XG4gICAgICBjb25zdCB1bmltcGxlbWVudGVkID0gKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZW1lIGRpZCBub3QgcHJvdmlkZSBhIE5vdGlmaWNhdGlvbk1hbmFnZXIgaW1wbGVtZW50YXRpb24uJyk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb3BlbjogdW5pbXBsZW1lbnRlZCxcbiAgICAgICAgY2xvc2U6IHVuaW1wbGVtZW50ZWQsXG4gICAgICAgIGdldEFyZ3M6IHVuaW1wbGVtZW50ZWRcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IE5vdGlmaWNhdGlvbk1hbmFnZXIgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3Qgbm90aWZpY2F0aW9ucyA9IFtdO1xuICAgICAgY29uc3QgZ2V0SW1wbGVtZW50YXRpb24gPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRoZW1lID0gZWRpdG9yLnRoZW1lO1xuICAgICAgICByZXR1cm4gdGhlbWUgJiYgdGhlbWUuZ2V0Tm90aWZpY2F0aW9uTWFuYWdlckltcGwgPyB0aGVtZS5nZXROb3RpZmljYXRpb25NYW5hZ2VySW1wbCgpIDogTm90aWZpY2F0aW9uTWFuYWdlckltcGwoKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBnZXRUb3BOb3RpZmljYXRpb24gPSAoKSA9PiB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5mcm9tKG5vdGlmaWNhdGlvbnNbMF0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGlzRXF1YWwgPSAoYSwgYikgPT4ge1xuICAgICAgICByZXR1cm4gYS50eXBlID09PSBiLnR5cGUgJiYgYS50ZXh0ID09PSBiLnRleHQgJiYgIWEucHJvZ3Jlc3NCYXIgJiYgIWEudGltZW91dCAmJiAhYi5wcm9ncmVzc0JhciAmJiAhYi50aW1lb3V0O1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlcG9zaXRpb24gPSAoKSA9PiB7XG4gICAgICAgIGVhY2gkZyhub3RpZmljYXRpb25zLCBub3RpZmljYXRpb24gPT4ge1xuICAgICAgICAgIG5vdGlmaWNhdGlvbi5yZXBvc2l0aW9uKCk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGFkZE5vdGlmaWNhdGlvbiA9IG5vdGlmaWNhdGlvbiA9PiB7XG4gICAgICAgIG5vdGlmaWNhdGlvbnMucHVzaChub3RpZmljYXRpb24pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGNsb3NlTm90aWZpY2F0aW9uID0gbm90aWZpY2F0aW9uID0+IHtcbiAgICAgICAgZmluZEluZGV4JDIobm90aWZpY2F0aW9ucywgb3RoZXJOb3RpZmljYXRpb24gPT4ge1xuICAgICAgICAgIHJldHVybiBvdGhlck5vdGlmaWNhdGlvbiA9PT0gbm90aWZpY2F0aW9uO1xuICAgICAgICB9KS5lYWNoKGluZGV4ID0+IHtcbiAgICAgICAgICBub3RpZmljYXRpb25zLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IG9wZW4gPSAoc3BlYywgZmlyZUV2ZW50ID0gdHJ1ZSkgPT4ge1xuICAgICAgICBpZiAoZWRpdG9yLnJlbW92ZWQgfHwgIWlzRWRpdG9yQXR0YWNoZWRUb0RvbShlZGl0b3IpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaXJlRXZlbnQpIHtcbiAgICAgICAgICBlZGl0b3IuZGlzcGF0Y2goJ0JlZm9yZU9wZW5Ob3RpZmljYXRpb24nLCB7IG5vdGlmaWNhdGlvbjogc3BlYyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmluZCQyKG5vdGlmaWNhdGlvbnMsIG5vdGlmaWNhdGlvbiA9PiB7XG4gICAgICAgICAgcmV0dXJuIGlzRXF1YWwoZ2V0SW1wbGVtZW50YXRpb24oKS5nZXRBcmdzKG5vdGlmaWNhdGlvbiksIHNwZWMpO1xuICAgICAgICB9KS5nZXRPclRodW5rKCgpID0+IHtcbiAgICAgICAgICBlZGl0b3IuZWRpdG9yTWFuYWdlci5zZXRBY3RpdmUoZWRpdG9yKTtcbiAgICAgICAgICBjb25zdCBub3RpZmljYXRpb24gPSBnZXRJbXBsZW1lbnRhdGlvbigpLm9wZW4oc3BlYywgKCkgPT4ge1xuICAgICAgICAgICAgY2xvc2VOb3RpZmljYXRpb24obm90aWZpY2F0aW9uKTtcbiAgICAgICAgICAgIHJlcG9zaXRpb24oKTtcbiAgICAgICAgICAgIGdldFRvcE5vdGlmaWNhdGlvbigpLmZvbGQoKCkgPT4gZWRpdG9yLmZvY3VzKCksIHRvcCA9PiBmb2N1cyQxKFN1Z2FyRWxlbWVudC5mcm9tRG9tKHRvcC5nZXRFbCgpKSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGFkZE5vdGlmaWNhdGlvbihub3RpZmljYXRpb24pO1xuICAgICAgICAgIHJlcG9zaXRpb24oKTtcbiAgICAgICAgICBlZGl0b3IuZGlzcGF0Y2goJ09wZW5Ob3RpZmljYXRpb24nLCB7IG5vdGlmaWNhdGlvbjogeyAuLi5ub3RpZmljYXRpb24gfSB9KTtcbiAgICAgICAgICByZXR1cm4gbm90aWZpY2F0aW9uO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBjb25zdCBjbG9zZSA9ICgpID0+IHtcbiAgICAgICAgZ2V0VG9wTm90aWZpY2F0aW9uKCkuZWFjaChub3RpZmljYXRpb24gPT4ge1xuICAgICAgICAgIGdldEltcGxlbWVudGF0aW9uKCkuY2xvc2Uobm90aWZpY2F0aW9uKTtcbiAgICAgICAgICBjbG9zZU5vdGlmaWNhdGlvbihub3RpZmljYXRpb24pO1xuICAgICAgICAgIHJlcG9zaXRpb24oKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgZ2V0Tm90aWZpY2F0aW9ucyA9IGNvbnN0YW50KG5vdGlmaWNhdGlvbnMpO1xuICAgICAgY29uc3QgcmVnaXN0ZXJFdmVudHMgPSBlZGl0b3IgPT4ge1xuICAgICAgICBlZGl0b3Iub24oJ1NraW5Mb2FkZWQnLCAoKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc2VydmljZU1lc3NhZ2UgPSBnZXRTZXJ2aWNlTWVzc2FnZShlZGl0b3IpO1xuICAgICAgICAgIGlmIChzZXJ2aWNlTWVzc2FnZSkge1xuICAgICAgICAgICAgb3Blbih7XG4gICAgICAgICAgICAgIHRleHQ6IHNlcnZpY2VNZXNzYWdlLFxuICAgICAgICAgICAgICB0eXBlOiAnd2FybmluZycsXG4gICAgICAgICAgICAgIHRpbWVvdXQ6IDBcbiAgICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVwb3NpdGlvbigpO1xuICAgICAgICB9KTtcbiAgICAgICAgZWRpdG9yLm9uKCdzaG93IFJlc2l6ZUVkaXRvciBSZXNpemVXaW5kb3cgTm9kZUNoYW5nZScsICgpID0+IHtcbiAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVwb3NpdGlvbik7XG4gICAgICAgIH0pO1xuICAgICAgICBlZGl0b3Iub24oJ3JlbW92ZScsICgpID0+IHtcbiAgICAgICAgICBlYWNoJGcobm90aWZpY2F0aW9ucy5zbGljZSgpLCBub3RpZmljYXRpb24gPT4ge1xuICAgICAgICAgICAgZ2V0SW1wbGVtZW50YXRpb24oKS5jbG9zZShub3RpZmljYXRpb24pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICByZWdpc3RlckV2ZW50cyhlZGl0b3IpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb3BlbixcbiAgICAgICAgY2xvc2UsXG4gICAgICAgIGdldE5vdGlmaWNhdGlvbnNcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IFBsdWdpbk1hbmFnZXIgPSBBZGRPbk1hbmFnZXIuUGx1Z2luTWFuYWdlcjtcblxuICAgIGNvbnN0IFRoZW1lTWFuYWdlciA9IEFkZE9uTWFuYWdlci5UaGVtZU1hbmFnZXI7XG5cbiAgICB2YXIgV2luZG93TWFuYWdlckltcGwgPSAoKSA9PiB7XG4gICAgICBjb25zdCB1bmltcGxlbWVudGVkID0gKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZW1lIGRpZCBub3QgcHJvdmlkZSBhIFdpbmRvd01hbmFnZXIgaW1wbGVtZW50YXRpb24uJyk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb3BlbjogdW5pbXBsZW1lbnRlZCxcbiAgICAgICAgb3BlblVybDogdW5pbXBsZW1lbnRlZCxcbiAgICAgICAgYWxlcnQ6IHVuaW1wbGVtZW50ZWQsXG4gICAgICAgIGNvbmZpcm06IHVuaW1wbGVtZW50ZWQsXG4gICAgICAgIGNsb3NlOiB1bmltcGxlbWVudGVkLFxuICAgICAgICBnZXRQYXJhbXM6IHVuaW1wbGVtZW50ZWQsXG4gICAgICAgIHNldFBhcmFtczogdW5pbXBsZW1lbnRlZFxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgY29uc3QgV2luZG93TWFuYWdlciA9IGVkaXRvciA9PiB7XG4gICAgICBsZXQgZGlhbG9ncyA9IFtdO1xuICAgICAgY29uc3QgZ2V0SW1wbGVtZW50YXRpb24gPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRoZW1lID0gZWRpdG9yLnRoZW1lO1xuICAgICAgICByZXR1cm4gdGhlbWUgJiYgdGhlbWUuZ2V0V2luZG93TWFuYWdlckltcGwgPyB0aGVtZS5nZXRXaW5kb3dNYW5hZ2VySW1wbCgpIDogV2luZG93TWFuYWdlckltcGwoKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBmdW5jQmluZCA9IChzY29wZSwgZikgPT4ge1xuICAgICAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICByZXR1cm4gZiA/IGYuYXBwbHkoc2NvcGUsIGFyZ3MpIDogdW5kZWZpbmVkO1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGZpcmVPcGVuRXZlbnQgPSBkaWFsb2cgPT4ge1xuICAgICAgICBlZGl0b3IuZGlzcGF0Y2goJ09wZW5XaW5kb3cnLCB7IGRpYWxvZyB9KTtcbiAgICAgIH07XG4gICAgICBjb25zdCBmaXJlQ2xvc2VFdmVudCA9IGRpYWxvZyA9PiB7XG4gICAgICAgIGVkaXRvci5kaXNwYXRjaCgnQ2xvc2VXaW5kb3cnLCB7IGRpYWxvZyB9KTtcbiAgICAgIH07XG4gICAgICBjb25zdCBhZGREaWFsb2cgPSBkaWFsb2cgPT4ge1xuICAgICAgICBkaWFsb2dzLnB1c2goZGlhbG9nKTtcbiAgICAgICAgZmlyZU9wZW5FdmVudChkaWFsb2cpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGNsb3NlRGlhbG9nID0gZGlhbG9nID0+IHtcbiAgICAgICAgZmlyZUNsb3NlRXZlbnQoZGlhbG9nKTtcbiAgICAgICAgZGlhbG9ncyA9IGZpbHRlciQ2KGRpYWxvZ3MsIG90aGVyRGlhbG9nID0+IHtcbiAgICAgICAgICByZXR1cm4gb3RoZXJEaWFsb2cgIT09IGRpYWxvZztcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChkaWFsb2dzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGVkaXRvci5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgZ2V0VG9wRGlhbG9nID0gKCkgPT4ge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwuZnJvbShkaWFsb2dzW2RpYWxvZ3MubGVuZ3RoIC0gMV0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHN0b3JlU2VsZWN0aW9uQW5kT3BlbkRpYWxvZyA9IG9wZW5EaWFsb2cgPT4ge1xuICAgICAgICBlZGl0b3IuZWRpdG9yTWFuYWdlci5zZXRBY3RpdmUoZWRpdG9yKTtcbiAgICAgICAgc3RvcmUoZWRpdG9yKTtcbiAgICAgICAgZWRpdG9yLnVpLnNob3coKTtcbiAgICAgICAgY29uc3QgZGlhbG9nID0gb3BlbkRpYWxvZygpO1xuICAgICAgICBhZGREaWFsb2coZGlhbG9nKTtcbiAgICAgICAgcmV0dXJuIGRpYWxvZztcbiAgICAgIH07XG4gICAgICBjb25zdCBvcGVuID0gKGFyZ3MsIHBhcmFtcykgPT4ge1xuICAgICAgICByZXR1cm4gc3RvcmVTZWxlY3Rpb25BbmRPcGVuRGlhbG9nKCgpID0+IGdldEltcGxlbWVudGF0aW9uKCkub3BlbihhcmdzLCBwYXJhbXMsIGNsb3NlRGlhbG9nKSk7XG4gICAgICB9O1xuICAgICAgY29uc3Qgb3BlblVybCA9IGFyZ3MgPT4ge1xuICAgICAgICByZXR1cm4gc3RvcmVTZWxlY3Rpb25BbmRPcGVuRGlhbG9nKCgpID0+IGdldEltcGxlbWVudGF0aW9uKCkub3BlblVybChhcmdzLCBjbG9zZURpYWxvZykpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGFsZXJ0ID0gKG1lc3NhZ2UsIGNhbGxiYWNrLCBzY29wZSkgPT4ge1xuICAgICAgICBjb25zdCB3aW5kb3dNYW5hZ2VySW1wbCA9IGdldEltcGxlbWVudGF0aW9uKCk7XG4gICAgICAgIHdpbmRvd01hbmFnZXJJbXBsLmFsZXJ0KG1lc3NhZ2UsIGZ1bmNCaW5kKHNjb3BlID8gc2NvcGUgOiB3aW5kb3dNYW5hZ2VySW1wbCwgY2FsbGJhY2spKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBjb25maXJtID0gKG1lc3NhZ2UsIGNhbGxiYWNrLCBzY29wZSkgPT4ge1xuICAgICAgICBjb25zdCB3aW5kb3dNYW5hZ2VySW1wbCA9IGdldEltcGxlbWVudGF0aW9uKCk7XG4gICAgICAgIHdpbmRvd01hbmFnZXJJbXBsLmNvbmZpcm0obWVzc2FnZSwgZnVuY0JpbmQoc2NvcGUgPyBzY29wZSA6IHdpbmRvd01hbmFnZXJJbXBsLCBjYWxsYmFjaykpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGNsb3NlID0gKCkgPT4ge1xuICAgICAgICBnZXRUb3BEaWFsb2coKS5lYWNoKGRpYWxvZyA9PiB7XG4gICAgICAgICAgZ2V0SW1wbGVtZW50YXRpb24oKS5jbG9zZShkaWFsb2cpO1xuICAgICAgICAgIGNsb3NlRGlhbG9nKGRpYWxvZyk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGVkaXRvci5vbigncmVtb3ZlJywgKCkgPT4ge1xuICAgICAgICBlYWNoJGcoZGlhbG9ncywgZGlhbG9nID0+IHtcbiAgICAgICAgICBnZXRJbXBsZW1lbnRhdGlvbigpLmNsb3NlKGRpYWxvZyk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvcGVuLFxuICAgICAgICBvcGVuVXJsLFxuICAgICAgICBhbGVydCxcbiAgICAgICAgY29uZmlybSxcbiAgICAgICAgY2xvc2VcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IGRpc3BsYXlOb3RpZmljYXRpb24gPSAoZWRpdG9yLCBtZXNzYWdlKSA9PiB7XG4gICAgICBlZGl0b3Iubm90aWZpY2F0aW9uTWFuYWdlci5vcGVuKHtcbiAgICAgICAgdHlwZTogJ2Vycm9yJyxcbiAgICAgICAgdGV4dDogbWVzc2FnZVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBkaXNwbGF5RXJyb3IgPSAoZWRpdG9yLCBtZXNzYWdlKSA9PiB7XG4gICAgICBpZiAoZWRpdG9yLl9za2luTG9hZGVkKSB7XG4gICAgICAgIGRpc3BsYXlOb3RpZmljYXRpb24oZWRpdG9yLCBtZXNzYWdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVkaXRvci5vbignU2tpbkxvYWRlZCcsICgpID0+IHtcbiAgICAgICAgICBkaXNwbGF5Tm90aWZpY2F0aW9uKGVkaXRvciwgbWVzc2FnZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgdXBsb2FkRXJyb3IgPSAoZWRpdG9yLCBtZXNzYWdlKSA9PiB7XG4gICAgICBkaXNwbGF5RXJyb3IoZWRpdG9yLCBJMThuLnRyYW5zbGF0ZShbXG4gICAgICAgICdGYWlsZWQgdG8gdXBsb2FkIGltYWdlOiB7MH0nLFxuICAgICAgICBtZXNzYWdlXG4gICAgICBdKSk7XG4gICAgfTtcbiAgICBjb25zdCBsb2dFcnJvciA9IChlZGl0b3IsIGVycm9yVHlwZSwgbXNnKSA9PiB7XG4gICAgICBmaXJlRXJyb3IoZWRpdG9yLCBlcnJvclR5cGUsIHsgbWVzc2FnZTogbXNnIH0pO1xuICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgIH07XG4gICAgY29uc3QgY3JlYXRlTG9hZEVycm9yID0gKHR5cGUsIHVybCwgbmFtZSkgPT4gbmFtZSA/IGBGYWlsZWQgdG8gbG9hZCAkeyB0eXBlIH06ICR7IG5hbWUgfSBmcm9tIHVybCAkeyB1cmwgfWAgOiBgRmFpbGVkIHRvIGxvYWQgJHsgdHlwZSB9IHVybDogJHsgdXJsIH1gO1xuICAgIGNvbnN0IHBsdWdpbkxvYWRFcnJvciA9IChlZGl0b3IsIHVybCwgbmFtZSkgPT4ge1xuICAgICAgbG9nRXJyb3IoZWRpdG9yLCAnUGx1Z2luTG9hZEVycm9yJywgY3JlYXRlTG9hZEVycm9yKCdwbHVnaW4nLCB1cmwsIG5hbWUpKTtcbiAgICB9O1xuICAgIGNvbnN0IGljb25zTG9hZEVycm9yID0gKGVkaXRvciwgdXJsLCBuYW1lKSA9PiB7XG4gICAgICBsb2dFcnJvcihlZGl0b3IsICdJY29uc0xvYWRFcnJvcicsIGNyZWF0ZUxvYWRFcnJvcignaWNvbnMnLCB1cmwsIG5hbWUpKTtcbiAgICB9O1xuICAgIGNvbnN0IGxhbmd1YWdlTG9hZEVycm9yID0gKGVkaXRvciwgdXJsLCBuYW1lKSA9PiB7XG4gICAgICBsb2dFcnJvcihlZGl0b3IsICdMYW5ndWFnZUxvYWRFcnJvcicsIGNyZWF0ZUxvYWRFcnJvcignbGFuZ3VhZ2UnLCB1cmwsIG5hbWUpKTtcbiAgICB9O1xuICAgIGNvbnN0IHRoZW1lTG9hZEVycm9yID0gKGVkaXRvciwgdXJsLCBuYW1lKSA9PiB7XG4gICAgICBsb2dFcnJvcihlZGl0b3IsICdUaGVtZUxvYWRFcnJvcicsIGNyZWF0ZUxvYWRFcnJvcigndGhlbWUnLCB1cmwsIG5hbWUpKTtcbiAgICB9O1xuICAgIGNvbnN0IG1vZGVsTG9hZEVycm9yID0gKGVkaXRvciwgdXJsLCBuYW1lKSA9PiB7XG4gICAgICBsb2dFcnJvcihlZGl0b3IsICdNb2RlbExvYWRFcnJvcicsIGNyZWF0ZUxvYWRFcnJvcignbW9kZWwnLCB1cmwsIG5hbWUpKTtcbiAgICB9O1xuICAgIGNvbnN0IHBsdWdpbkluaXRFcnJvciA9IChlZGl0b3IsIG5hbWUsIGVycikgPT4ge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IEkxOG4udHJhbnNsYXRlKFtcbiAgICAgICAgJ0ZhaWxlZCB0byBpbml0aWFsaXplIHBsdWdpbjogezB9JyxcbiAgICAgICAgbmFtZVxuICAgICAgXSk7XG4gICAgICBmaXJlRXJyb3IoZWRpdG9yLCAnUGx1Z2luTG9hZEVycm9yJywgeyBtZXNzYWdlIH0pO1xuICAgICAgaW5pdEVycm9yKG1lc3NhZ2UsIGVycik7XG4gICAgICBkaXNwbGF5RXJyb3IoZWRpdG9yLCBtZXNzYWdlKTtcbiAgICB9O1xuICAgIGNvbnN0IGluaXRFcnJvciA9IChtZXNzYWdlLCAuLi54KSA9PiB7XG4gICAgICBjb25zdCBjb25zb2xlID0gd2luZG93LmNvbnNvbGU7XG4gICAgICBpZiAoY29uc29sZSkge1xuICAgICAgICBpZiAoY29uc29sZS5lcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSwgLi4ueCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2cobWVzc2FnZSwgLi4ueCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgaXNDb250ZW50Q3NzU2tpbk5hbWUgPSB1cmwgPT4gL15bYS16MC05XFwtXSskL2kudGVzdCh1cmwpO1xuICAgIGNvbnN0IGdldENvbnRlbnRDc3NVcmxzID0gZWRpdG9yID0+IHtcbiAgICAgIHJldHVybiB0cmFuc2Zvcm1Ub1VybHMoZWRpdG9yLCBnZXRDb250ZW50Q3NzKGVkaXRvcikpO1xuICAgIH07XG4gICAgY29uc3QgZ2V0Rm9udENzc1VybHMgPSBlZGl0b3IgPT4ge1xuICAgICAgcmV0dXJuIHRyYW5zZm9ybVRvVXJscyhlZGl0b3IsIGdldEZvbnRDc3MoZWRpdG9yKSk7XG4gICAgfTtcbiAgICBjb25zdCB0cmFuc2Zvcm1Ub1VybHMgPSAoZWRpdG9yLCBjc3NMaW5rcykgPT4ge1xuICAgICAgY29uc3Qgc2tpblVybCA9IGVkaXRvci5lZGl0b3JNYW5hZ2VyLmJhc2VVUkwgKyAnL3NraW5zL2NvbnRlbnQnO1xuICAgICAgY29uc3Qgc3VmZml4ID0gZWRpdG9yLmVkaXRvck1hbmFnZXIuc3VmZml4O1xuICAgICAgY29uc3QgY29udGVudENzc0ZpbGUgPSBgY29udGVudCR7IHN1ZmZpeCB9LmNzc2A7XG4gICAgICBjb25zdCBpbmxpbmUgPSBlZGl0b3IuaW5saW5lID09PSB0cnVlO1xuICAgICAgcmV0dXJuIG1hcCQzKGNzc0xpbmtzLCB1cmwgPT4ge1xuICAgICAgICBpZiAoaXNDb250ZW50Q3NzU2tpbk5hbWUodXJsKSAmJiAhaW5saW5lKSB7XG4gICAgICAgICAgcmV0dXJuIGAkeyBza2luVXJsIH0vJHsgdXJsIH0vJHsgY29udGVudENzc0ZpbGUgfWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGVkaXRvci5kb2N1bWVudEJhc2VVUkkudG9BYnNvbHV0ZSh1cmwpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGFwcGVuZENvbnRlbnRDc3NGcm9tU2V0dGluZ3MgPSBlZGl0b3IgPT4ge1xuICAgICAgZWRpdG9yLmNvbnRlbnRDU1MgPSBlZGl0b3IuY29udGVudENTUy5jb25jYXQoZ2V0Q29udGVudENzc1VybHMoZWRpdG9yKSwgZ2V0Rm9udENzc1VybHMoZWRpdG9yKSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGZpbHRlciQxID0gYWx3YXlzO1xuICAgIGNvbnN0IGJpbmQkMSA9IChlbGVtZW50LCBldmVudCwgaGFuZGxlcikgPT4gYmluZCQyKGVsZW1lbnQsIGV2ZW50LCBmaWx0ZXIkMSwgaGFuZGxlcik7XG5cbiAgICBjb25zdCBVcGxvYWRTdGF0dXMgPSAoKSA9PiB7XG4gICAgICBjb25zdCBQRU5ESU5HID0gMSwgVVBMT0FERUQgPSAyO1xuICAgICAgbGV0IGJsb2JVcmlTdGF0dXNlcyA9IHt9O1xuICAgICAgY29uc3QgY3JlYXRlU3RhdHVzID0gKHN0YXR1cywgcmVzdWx0VXJpKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3RhdHVzLFxuICAgICAgICAgIHJlc3VsdFVyaVxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGhhc0Jsb2JVcmkgPSBibG9iVXJpID0+IHtcbiAgICAgICAgcmV0dXJuIGJsb2JVcmkgaW4gYmxvYlVyaVN0YXR1c2VzO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGdldFJlc3VsdFVyaSA9IGJsb2JVcmkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBibG9iVXJpU3RhdHVzZXNbYmxvYlVyaV07XG4gICAgICAgIHJldHVybiByZXN1bHQgPyByZXN1bHQucmVzdWx0VXJpIDogbnVsbDtcbiAgICAgIH07XG4gICAgICBjb25zdCBpc1BlbmRpbmcgPSBibG9iVXJpID0+IHtcbiAgICAgICAgcmV0dXJuIGhhc0Jsb2JVcmkoYmxvYlVyaSkgPyBibG9iVXJpU3RhdHVzZXNbYmxvYlVyaV0uc3RhdHVzID09PSBQRU5ESU5HIDogZmFsc2U7XG4gICAgICB9O1xuICAgICAgY29uc3QgaXNVcGxvYWRlZCA9IGJsb2JVcmkgPT4ge1xuICAgICAgICByZXR1cm4gaGFzQmxvYlVyaShibG9iVXJpKSA/IGJsb2JVcmlTdGF0dXNlc1tibG9iVXJpXS5zdGF0dXMgPT09IFVQTE9BREVEIDogZmFsc2U7XG4gICAgICB9O1xuICAgICAgY29uc3QgbWFya1BlbmRpbmcgPSBibG9iVXJpID0+IHtcbiAgICAgICAgYmxvYlVyaVN0YXR1c2VzW2Jsb2JVcmldID0gY3JlYXRlU3RhdHVzKFBFTkRJTkcsIG51bGwpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IG1hcmtVcGxvYWRlZCA9IChibG9iVXJpLCByZXN1bHRVcmkpID0+IHtcbiAgICAgICAgYmxvYlVyaVN0YXR1c2VzW2Jsb2JVcmldID0gY3JlYXRlU3RhdHVzKFVQTE9BREVELCByZXN1bHRVcmkpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlbW92ZUZhaWxlZCA9IGJsb2JVcmkgPT4ge1xuICAgICAgICBkZWxldGUgYmxvYlVyaVN0YXR1c2VzW2Jsb2JVcmldO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGRlc3Ryb3kgPSAoKSA9PiB7XG4gICAgICAgIGJsb2JVcmlTdGF0dXNlcyA9IHt9O1xuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGhhc0Jsb2JVcmksXG4gICAgICAgIGdldFJlc3VsdFVyaSxcbiAgICAgICAgaXNQZW5kaW5nLFxuICAgICAgICBpc1VwbG9hZGVkLFxuICAgICAgICBtYXJrUGVuZGluZyxcbiAgICAgICAgbWFya1VwbG9hZGVkLFxuICAgICAgICByZW1vdmVGYWlsZWQsXG4gICAgICAgIGRlc3Ryb3lcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGxldCBjb3VudCA9IDA7XG4gICAgY29uc3Qgc2VlZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHJuZCA9ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDQyOTQ5NjcyOTUpLnRvU3RyaW5nKDM2KTtcbiAgICAgIH07XG4gICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgIHJldHVybiAncycgKyBub3cudG9TdHJpbmcoMzYpICsgcm5kKCkgKyBybmQoKSArIHJuZCgpO1xuICAgIH07XG4gICAgY29uc3QgdXVpZCA9IHByZWZpeCA9PiB7XG4gICAgICByZXR1cm4gcHJlZml4ICsgY291bnQrKyArIHNlZWQoKTtcbiAgICB9O1xuXG4gICAgY29uc3QgQmxvYkNhY2hlID0gKCkgPT4ge1xuICAgICAgbGV0IGNhY2hlID0gW107XG4gICAgICBjb25zdCBtaW1lVG9FeHQgPSBtaW1lID0+IHtcbiAgICAgICAgY29uc3QgbWltZXMgPSB7XG4gICAgICAgICAgJ2ltYWdlL2pwZWcnOiAnanBnJyxcbiAgICAgICAgICAnaW1hZ2UvanBnJzogJ2pwZycsXG4gICAgICAgICAgJ2ltYWdlL2dpZic6ICdnaWYnLFxuICAgICAgICAgICdpbWFnZS9wbmcnOiAncG5nJyxcbiAgICAgICAgICAnaW1hZ2UvYXBuZyc6ICdhcG5nJyxcbiAgICAgICAgICAnaW1hZ2UvYXZpZic6ICdhdmlmJyxcbiAgICAgICAgICAnaW1hZ2Uvc3ZnK3htbCc6ICdzdmcnLFxuICAgICAgICAgICdpbWFnZS93ZWJwJzogJ3dlYnAnLFxuICAgICAgICAgICdpbWFnZS9ibXAnOiAnYm1wJyxcbiAgICAgICAgICAnaW1hZ2UvdGlmZic6ICd0aWZmJ1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbWltZXNbbWltZS50b0xvd2VyQ2FzZSgpXSB8fCAnZGF0JztcbiAgICAgIH07XG4gICAgICBjb25zdCBjcmVhdGUgPSAobywgYmxvYiwgYmFzZTY0LCBuYW1lLCBmaWxlbmFtZSkgPT4ge1xuICAgICAgICBpZiAoaXNTdHJpbmcobykpIHtcbiAgICAgICAgICBjb25zdCBpZCA9IG87XG4gICAgICAgICAgcmV0dXJuIHRvQmxvYkluZm8oe1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgZmlsZW5hbWUsXG4gICAgICAgICAgICBibG9iLFxuICAgICAgICAgICAgYmFzZTY0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QobykpIHtcbiAgICAgICAgICByZXR1cm4gdG9CbG9iSW5mbyhvKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gaW5wdXQgdHlwZScpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgdG9CbG9iSW5mbyA9IG8gPT4ge1xuICAgICAgICBpZiAoIW8uYmxvYiB8fCAhby5iYXNlNjQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Jsb2IgYW5kIGJhc2U2NCByZXByZXNlbnRhdGlvbnMgb2YgdGhlIGltYWdlIGFyZSByZXF1aXJlZCBmb3IgQmxvYkluZm8gdG8gYmUgY3JlYXRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlkID0gby5pZCB8fCB1dWlkKCdibG9iaWQnKTtcbiAgICAgICAgY29uc3QgbmFtZSA9IG8ubmFtZSB8fCBpZDtcbiAgICAgICAgY29uc3QgYmxvYiA9IG8uYmxvYjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpZDogY29uc3RhbnQoaWQpLFxuICAgICAgICAgIG5hbWU6IGNvbnN0YW50KG5hbWUpLFxuICAgICAgICAgIGZpbGVuYW1lOiBjb25zdGFudChvLmZpbGVuYW1lIHx8IG5hbWUgKyAnLicgKyBtaW1lVG9FeHQoYmxvYi50eXBlKSksXG4gICAgICAgICAgYmxvYjogY29uc3RhbnQoYmxvYiksXG4gICAgICAgICAgYmFzZTY0OiBjb25zdGFudChvLmJhc2U2NCksXG4gICAgICAgICAgYmxvYlVyaTogY29uc3RhbnQoby5ibG9iVXJpIHx8IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYikpLFxuICAgICAgICAgIHVyaTogY29uc3RhbnQoby51cmkpXG4gICAgICAgIH07XG4gICAgICB9O1xuICAgICAgY29uc3QgYWRkID0gYmxvYkluZm8gPT4ge1xuICAgICAgICBpZiAoIWdldChibG9iSW5mby5pZCgpKSkge1xuICAgICAgICAgIGNhY2hlLnB1c2goYmxvYkluZm8pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgZmluZEZpcnN0ID0gcHJlZGljYXRlID0+IGZpbmQkMihjYWNoZSwgcHJlZGljYXRlKS5nZXRPclVuZGVmaW5lZCgpO1xuICAgICAgY29uc3QgZ2V0ID0gaWQgPT4gZmluZEZpcnN0KGNhY2hlZEJsb2JJbmZvID0+IGNhY2hlZEJsb2JJbmZvLmlkKCkgPT09IGlkKTtcbiAgICAgIGNvbnN0IGdldEJ5VXJpID0gYmxvYlVyaSA9PiBmaW5kRmlyc3QoYmxvYkluZm8gPT4gYmxvYkluZm8uYmxvYlVyaSgpID09PSBibG9iVXJpKTtcbiAgICAgIGNvbnN0IGdldEJ5RGF0YSA9IChiYXNlNjQsIHR5cGUpID0+IGZpbmRGaXJzdChibG9iSW5mbyA9PiBibG9iSW5mby5iYXNlNjQoKSA9PT0gYmFzZTY0ICYmIGJsb2JJbmZvLmJsb2IoKS50eXBlID09PSB0eXBlKTtcbiAgICAgIGNvbnN0IHJlbW92ZUJ5VXJpID0gYmxvYlVyaSA9PiB7XG4gICAgICAgIGNhY2hlID0gZmlsdGVyJDYoY2FjaGUsIGJsb2JJbmZvID0+IHtcbiAgICAgICAgICBpZiAoYmxvYkluZm8uYmxvYlVyaSgpID09PSBibG9iVXJpKSB7XG4gICAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKGJsb2JJbmZvLmJsb2JVcmkoKSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBjb25zdCBkZXN0cm95ID0gKCkgPT4ge1xuICAgICAgICBlYWNoJGcoY2FjaGUsIGNhY2hlZEJsb2JJbmZvID0+IHtcbiAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKGNhY2hlZEJsb2JJbmZvLmJsb2JVcmkoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjYWNoZSA9IFtdO1xuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNyZWF0ZSxcbiAgICAgICAgYWRkLFxuICAgICAgICBnZXQsXG4gICAgICAgIGdldEJ5VXJpLFxuICAgICAgICBnZXRCeURhdGEsXG4gICAgICAgIGZpbmRGaXJzdCxcbiAgICAgICAgcmVtb3ZlQnlVcmksXG4gICAgICAgIGRlc3Ryb3lcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IFVwbG9hZGVyID0gKHVwbG9hZFN0YXR1cywgc2V0dGluZ3MpID0+IHtcbiAgICAgIGNvbnN0IHBlbmRpbmdQcm9taXNlcyA9IHt9O1xuICAgICAgY29uc3QgcGF0aEpvaW4gPSAocGF0aDEsIHBhdGgyKSA9PiB7XG4gICAgICAgIGlmIChwYXRoMSkge1xuICAgICAgICAgIHJldHVybiBwYXRoMS5yZXBsYWNlKC9cXC8kLywgJycpICsgJy8nICsgcGF0aDIucmVwbGFjZSgvXlxcLy8sICcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aDI7XG4gICAgICB9O1xuICAgICAgY29uc3QgZGVmYXVsdEhhbmRsZXIgPSAoYmxvYkluZm8sIHByb2dyZXNzKSA9PiBuZXcgUHJvbWlzZSgoc3VjY2VzcywgZmFpbHVyZSkgPT4ge1xuICAgICAgICBjb25zdCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgeGhyLm9wZW4oJ1BPU1QnLCBzZXR0aW5ncy51cmwpO1xuICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gc2V0dGluZ3MuY3JlZGVudGlhbHM7XG4gICAgICAgIHhoci51cGxvYWQub25wcm9ncmVzcyA9IGUgPT4ge1xuICAgICAgICAgIHByb2dyZXNzKGUubG9hZGVkIC8gZS50b3RhbCAqIDEwMCk7XG4gICAgICAgIH07XG4gICAgICAgIHhoci5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICAgIGZhaWx1cmUoJ0ltYWdlIHVwbG9hZCBmYWlsZWQgZHVlIHRvIGEgWEhSIFRyYW5zcG9ydCBlcnJvci4gQ29kZTogJyArIHhoci5zdGF0dXMpO1xuICAgICAgICB9O1xuICAgICAgICB4aHIub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgIGlmICh4aHIuc3RhdHVzIDwgMjAwIHx8IHhoci5zdGF0dXMgPj0gMzAwKSB7XG4gICAgICAgICAgICBmYWlsdXJlKCdIVFRQIEVycm9yOiAnICsgeGhyLnN0YXR1cyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGpzb24gPSBKU09OLnBhcnNlKHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgICAgIGlmICghanNvbiB8fCAhaXNTdHJpbmcoanNvbi5sb2NhdGlvbikpIHtcbiAgICAgICAgICAgIGZhaWx1cmUoJ0ludmFsaWQgSlNPTjogJyArIHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdWNjZXNzKHBhdGhKb2luKHNldHRpbmdzLmJhc2VQYXRoLCBqc29uLmxvY2F0aW9uKSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICAgIGZvcm1EYXRhLmFwcGVuZCgnZmlsZScsIGJsb2JJbmZvLmJsb2IoKSwgYmxvYkluZm8uZmlsZW5hbWUoKSk7XG4gICAgICAgIHhoci5zZW5kKGZvcm1EYXRhKTtcbiAgICAgIH0pO1xuICAgICAgY29uc3Qgbm9VcGxvYWQgPSAoKSA9PiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgcmVzb2x2ZShbXSk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGhhbmRsZXJTdWNjZXNzID0gKGJsb2JJbmZvLCB1cmwpID0+ICh7XG4gICAgICAgIHVybCxcbiAgICAgICAgYmxvYkluZm8sXG4gICAgICAgIHN0YXR1czogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBjb25zdCBoYW5kbGVyRmFpbHVyZSA9IChibG9iSW5mbywgZXJyb3IpID0+ICh7XG4gICAgICAgIHVybDogJycsXG4gICAgICAgIGJsb2JJbmZvLFxuICAgICAgICBzdGF0dXM6IGZhbHNlLFxuICAgICAgICBlcnJvclxuICAgICAgfSk7XG4gICAgICBjb25zdCByZXNvbHZlUGVuZGluZyA9IChibG9iVXJpLCByZXN1bHQpID0+IHtcbiAgICAgICAgVG9vbHMuZWFjaChwZW5kaW5nUHJvbWlzZXNbYmxvYlVyaV0sIHJlc29sdmUgPT4ge1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlbGV0ZSBwZW5kaW5nUHJvbWlzZXNbYmxvYlVyaV07XG4gICAgICB9O1xuICAgICAgY29uc3QgdXBsb2FkQmxvYkluZm8gPSAoYmxvYkluZm8sIGhhbmRsZXIsIG9wZW5Ob3RpZmljYXRpb24pID0+IHtcbiAgICAgICAgdXBsb2FkU3RhdHVzLm1hcmtQZW5kaW5nKGJsb2JJbmZvLmJsb2JVcmkoKSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICBsZXQgbm90aWZpY2F0aW9uO1xuICAgICAgICAgIGxldCBwcm9ncmVzcztcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY2xvc2VOb3RpZmljYXRpb24gPSAoKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChub3RpZmljYXRpb24pIHtcbiAgICAgICAgICAgICAgICBub3RpZmljYXRpb24uY2xvc2UoKTtcbiAgICAgICAgICAgICAgICBwcm9ncmVzcyA9IG5vb3A7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBzdWNjZXNzID0gdXJsID0+IHtcbiAgICAgICAgICAgICAgY2xvc2VOb3RpZmljYXRpb24oKTtcbiAgICAgICAgICAgICAgdXBsb2FkU3RhdHVzLm1hcmtVcGxvYWRlZChibG9iSW5mby5ibG9iVXJpKCksIHVybCk7XG4gICAgICAgICAgICAgIHJlc29sdmVQZW5kaW5nKGJsb2JJbmZvLmJsb2JVcmkoKSwgaGFuZGxlclN1Y2Nlc3MoYmxvYkluZm8sIHVybCkpO1xuICAgICAgICAgICAgICByZXNvbHZlKGhhbmRsZXJTdWNjZXNzKGJsb2JJbmZvLCB1cmwpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBmYWlsdXJlID0gZXJyb3IgPT4ge1xuICAgICAgICAgICAgICBjbG9zZU5vdGlmaWNhdGlvbigpO1xuICAgICAgICAgICAgICB1cGxvYWRTdGF0dXMucmVtb3ZlRmFpbGVkKGJsb2JJbmZvLmJsb2JVcmkoKSk7XG4gICAgICAgICAgICAgIHJlc29sdmVQZW5kaW5nKGJsb2JJbmZvLmJsb2JVcmkoKSwgaGFuZGxlckZhaWx1cmUoYmxvYkluZm8sIGVycm9yKSk7XG4gICAgICAgICAgICAgIHJlc29sdmUoaGFuZGxlckZhaWx1cmUoYmxvYkluZm8sIGVycm9yKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcHJvZ3Jlc3MgPSBwZXJjZW50ID0+IHtcbiAgICAgICAgICAgICAgaWYgKHBlcmNlbnQgPCAwIHx8IHBlcmNlbnQgPiAxMDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgT3B0aW9uYWwuZnJvbShub3RpZmljYXRpb24pLm9yVGh1bmsoKCkgPT4gT3B0aW9uYWwuZnJvbShvcGVuTm90aWZpY2F0aW9uKS5tYXAoYXBwbHkkMSkpLmVhY2gobiA9PiB7XG4gICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uID0gbjtcbiAgICAgICAgICAgICAgICBuLnByb2dyZXNzQmFyLnZhbHVlKHBlcmNlbnQpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBoYW5kbGVyKGJsb2JJbmZvLCBwcm9ncmVzcykudGhlbihzdWNjZXNzLCBlcnIgPT4ge1xuICAgICAgICAgICAgICBmYWlsdXJlKGlzU3RyaW5nKGVycikgPyB7IG1lc3NhZ2U6IGVyciB9IDogZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICByZXNvbHZlKGhhbmRsZXJGYWlsdXJlKGJsb2JJbmZvLCBleCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgaXNEZWZhdWx0SGFuZGxlciA9IGhhbmRsZXIgPT4gaGFuZGxlciA9PT0gZGVmYXVsdEhhbmRsZXI7XG4gICAgICBjb25zdCBwZW5kaW5nVXBsb2FkQmxvYkluZm8gPSBibG9iSW5mbyA9PiB7XG4gICAgICAgIGNvbnN0IGJsb2JVcmkgPSBibG9iSW5mby5ibG9iVXJpKCk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICBwZW5kaW5nUHJvbWlzZXNbYmxvYlVyaV0gPSBwZW5kaW5nUHJvbWlzZXNbYmxvYlVyaV0gfHwgW107XG4gICAgICAgICAgcGVuZGluZ1Byb21pc2VzW2Jsb2JVcmldLnB1c2gocmVzb2x2ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHVwbG9hZEJsb2JzID0gKGJsb2JJbmZvcywgb3Blbk5vdGlmaWNhdGlvbikgPT4ge1xuICAgICAgICBibG9iSW5mb3MgPSBUb29scy5ncmVwKGJsb2JJbmZvcywgYmxvYkluZm8gPT4gIXVwbG9hZFN0YXR1cy5pc1VwbG9hZGVkKGJsb2JJbmZvLmJsb2JVcmkoKSkpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoVG9vbHMubWFwKGJsb2JJbmZvcywgYmxvYkluZm8gPT4gdXBsb2FkU3RhdHVzLmlzUGVuZGluZyhibG9iSW5mby5ibG9iVXJpKCkpID8gcGVuZGluZ1VwbG9hZEJsb2JJbmZvKGJsb2JJbmZvKSA6IHVwbG9hZEJsb2JJbmZvKGJsb2JJbmZvLCBzZXR0aW5ncy5oYW5kbGVyLCBvcGVuTm90aWZpY2F0aW9uKSkpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHVwbG9hZCA9IChibG9iSW5mb3MsIG9wZW5Ob3RpZmljYXRpb24pID0+ICFzZXR0aW5ncy51cmwgJiYgaXNEZWZhdWx0SGFuZGxlcihzZXR0aW5ncy5oYW5kbGVyKSA/IG5vVXBsb2FkKCkgOiB1cGxvYWRCbG9icyhibG9iSW5mb3MsIG9wZW5Ob3RpZmljYXRpb24pO1xuICAgICAgaWYgKGlzRnVuY3Rpb24oc2V0dGluZ3MuaGFuZGxlcikgPT09IGZhbHNlKSB7XG4gICAgICAgIHNldHRpbmdzLmhhbmRsZXIgPSBkZWZhdWx0SGFuZGxlcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHVwbG9hZCB9O1xuICAgIH07XG5cbiAgICBjb25zdCBvcGVuTm90aWZpY2F0aW9uID0gZWRpdG9yID0+ICgpID0+IGVkaXRvci5ub3RpZmljYXRpb25NYW5hZ2VyLm9wZW4oe1xuICAgICAgdGV4dDogZWRpdG9yLnRyYW5zbGF0ZSgnSW1hZ2UgdXBsb2FkaW5nLi4uJyksXG4gICAgICB0eXBlOiAnaW5mbycsXG4gICAgICB0aW1lb3V0OiAtMSxcbiAgICAgIHByb2dyZXNzQmFyOiB0cnVlXG4gICAgfSk7XG4gICAgY29uc3QgY3JlYXRlVXBsb2FkZXIgPSAoZWRpdG9yLCB1cGxvYWRTdGF0dXMpID0+IFVwbG9hZGVyKHVwbG9hZFN0YXR1cywge1xuICAgICAgdXJsOiBnZXRJbWFnZVVwbG9hZFVybChlZGl0b3IpLFxuICAgICAgYmFzZVBhdGg6IGdldEltYWdlVXBsb2FkQmFzZVBhdGgoZWRpdG9yKSxcbiAgICAgIGNyZWRlbnRpYWxzOiBnZXRJbWFnZXNVcGxvYWRDcmVkZW50aWFscyhlZGl0b3IpLFxuICAgICAgaGFuZGxlcjogZ2V0SW1hZ2VzVXBsb2FkSGFuZGxlcihlZGl0b3IpXG4gICAgfSk7XG4gICAgY29uc3QgSW1hZ2VVcGxvYWRlciA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCB1cGxvYWRTdGF0dXMgPSBVcGxvYWRTdGF0dXMoKTtcbiAgICAgIGNvbnN0IHVwbG9hZGVyID0gY3JlYXRlVXBsb2FkZXIoZWRpdG9yLCB1cGxvYWRTdGF0dXMpO1xuICAgICAgcmV0dXJuIHsgdXBsb2FkOiAoYmxvYkluZm9zLCBzaG93Tm90aWZpY2F0aW9uID0gdHJ1ZSkgPT4gdXBsb2FkZXIudXBsb2FkKGJsb2JJbmZvcywgc2hvd05vdGlmaWNhdGlvbiA/IG9wZW5Ob3RpZmljYXRpb24oZWRpdG9yKSA6IHVuZGVmaW5lZCkgfTtcbiAgICB9O1xuXG4gICAgY29uc3QgVXBsb2FkQ2hhbmdlSGFuZGxlciA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBsYXN0Q2hhbmdlZExldmVsID0gQ2VsbChudWxsKTtcbiAgICAgIGVkaXRvci5vbignY2hhbmdlIEFkZFVuZG8nLCBlID0+IHtcbiAgICAgICAgbGFzdENoYW5nZWRMZXZlbC5zZXQoeyAuLi5lLmxldmVsIH0pO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBmaXJlSWZDaGFuZ2VkID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBkYXRhID0gZWRpdG9yLnVuZG9NYW5hZ2VyLmRhdGE7XG4gICAgICAgIGxhc3QkMyhkYXRhKS5maWx0ZXIobGV2ZWwgPT4ge1xuICAgICAgICAgIHJldHVybiAhaXNFcSQxKGxhc3RDaGFuZ2VkTGV2ZWwuZ2V0KCksIGxldmVsKTtcbiAgICAgICAgfSkuZWFjaChsZXZlbCA9PiB7XG4gICAgICAgICAgZWRpdG9yLnNldERpcnR5KHRydWUpO1xuICAgICAgICAgIGVkaXRvci5kaXNwYXRjaCgnY2hhbmdlJywge1xuICAgICAgICAgICAgbGV2ZWwsXG4gICAgICAgICAgICBsYXN0TGV2ZWw6IGdldCRiKGRhdGEsIGRhdGEubGVuZ3RoIC0gMikuZ2V0T3JOdWxsKClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHsgZmlyZUlmQ2hhbmdlZCB9O1xuICAgIH07XG4gICAgY29uc3QgRWRpdG9yVXBsb2FkID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IGJsb2JDYWNoZSA9IEJsb2JDYWNoZSgpO1xuICAgICAgbGV0IHVwbG9hZGVyLCBpbWFnZVNjYW5uZXI7XG4gICAgICBjb25zdCB1cGxvYWRTdGF0dXMgPSBVcGxvYWRTdGF0dXMoKTtcbiAgICAgIGNvbnN0IHVybEZpbHRlcnMgPSBbXTtcbiAgICAgIGNvbnN0IGNoYW5nZUhhbmRsZXIgPSBVcGxvYWRDaGFuZ2VIYW5kbGVyKGVkaXRvcik7XG4gICAgICBjb25zdCBhbGl2ZUd1YXJkID0gY2FsbGJhY2sgPT4ge1xuICAgICAgICByZXR1cm4gcmVzdWx0ID0+IHtcbiAgICAgICAgICBpZiAoZWRpdG9yLnNlbGVjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICBjb25zdCBjYWNoZUludmFsaWRhdG9yID0gdXJsID0+IHVybCArICh1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgIGNvbnN0IHJlcGxhY2VTdHJpbmcgPSAoY29udGVudCwgc2VhcmNoLCByZXBsYWNlKSA9PiB7XG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBpbmRleCA9IGNvbnRlbnQuaW5kZXhPZihzZWFyY2gsIGluZGV4KTtcbiAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5zdWJzdHJpbmcoMCwgaW5kZXgpICsgcmVwbGFjZSArIGNvbnRlbnQuc3Vic3RyKGluZGV4ICsgc2VhcmNoLmxlbmd0aCk7XG4gICAgICAgICAgICBpbmRleCArPSByZXBsYWNlLmxlbmd0aCAtIHNlYXJjaC5sZW5ndGggKyAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoaW5kZXggIT09IC0xKTtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICB9O1xuICAgICAgY29uc3QgcmVwbGFjZUltYWdlVXJsID0gKGNvbnRlbnQsIHRhcmdldFVybCwgcmVwbGFjZW1lbnRVcmwpID0+IHtcbiAgICAgICAgY29uc3QgcmVwbGFjZW1lbnRTdHJpbmcgPSBgc3JjPVwiJHsgcmVwbGFjZW1lbnRVcmwgfVwiJHsgcmVwbGFjZW1lbnRVcmwgPT09IEVudi50cmFuc3BhcmVudFNyYyA/ICcgZGF0YS1tY2UtcGxhY2Vob2xkZXI9XCIxXCInIDogJycgfWA7XG4gICAgICAgIGNvbnRlbnQgPSByZXBsYWNlU3RyaW5nKGNvbnRlbnQsIGBzcmM9XCIkeyB0YXJnZXRVcmwgfVwiYCwgcmVwbGFjZW1lbnRTdHJpbmcpO1xuICAgICAgICBjb250ZW50ID0gcmVwbGFjZVN0cmluZyhjb250ZW50LCAnZGF0YS1tY2Utc3JjPVwiJyArIHRhcmdldFVybCArICdcIicsICdkYXRhLW1jZS1zcmM9XCInICsgcmVwbGFjZW1lbnRVcmwgKyAnXCInKTtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICB9O1xuICAgICAgY29uc3QgcmVwbGFjZVVybEluVW5kb1N0YWNrID0gKHRhcmdldFVybCwgcmVwbGFjZW1lbnRVcmwpID0+IHtcbiAgICAgICAgZWFjaCRnKGVkaXRvci51bmRvTWFuYWdlci5kYXRhLCBsZXZlbCA9PiB7XG4gICAgICAgICAgaWYgKGxldmVsLnR5cGUgPT09ICdmcmFnbWVudGVkJykge1xuICAgICAgICAgICAgbGV2ZWwuZnJhZ21lbnRzID0gbWFwJDMobGV2ZWwuZnJhZ21lbnRzLCBmcmFnbWVudCA9PiByZXBsYWNlSW1hZ2VVcmwoZnJhZ21lbnQsIHRhcmdldFVybCwgcmVwbGFjZW1lbnRVcmwpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV2ZWwuY29udGVudCA9IHJlcGxhY2VJbWFnZVVybChsZXZlbC5jb250ZW50LCB0YXJnZXRVcmwsIHJlcGxhY2VtZW50VXJsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlcGxhY2VJbWFnZVVyaUluVmlldyA9IChpbWFnZSwgcmVzdWx0VXJpKSA9PiB7XG4gICAgICAgIGNvbnN0IHNyYyA9IGVkaXRvci5jb252ZXJ0VVJMKHJlc3VsdFVyaSwgJ3NyYycpO1xuICAgICAgICByZXBsYWNlVXJsSW5VbmRvU3RhY2soaW1hZ2Uuc3JjLCByZXN1bHRVcmkpO1xuICAgICAgICBzZXRBbGwkMShTdWdhckVsZW1lbnQuZnJvbURvbShpbWFnZSksIHtcbiAgICAgICAgICAnc3JjJzogc2hvdWxkUmV1c2VGaWxlTmFtZShlZGl0b3IpID8gY2FjaGVJbnZhbGlkYXRvcihyZXN1bHRVcmkpIDogcmVzdWx0VXJpLFxuICAgICAgICAgICdkYXRhLW1jZS1zcmMnOiBzcmNcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgdXBsb2FkSW1hZ2VzID0gKCkgPT4ge1xuICAgICAgICBpZiAoIXVwbG9hZGVyKSB7XG4gICAgICAgICAgdXBsb2FkZXIgPSBjcmVhdGVVcGxvYWRlcihlZGl0b3IsIHVwbG9hZFN0YXR1cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjYW5Gb3JJbWFnZXMoKS50aGVuKGFsaXZlR3VhcmQoaW1hZ2VJbmZvcyA9PiB7XG4gICAgICAgICAgY29uc3QgYmxvYkluZm9zID0gbWFwJDMoaW1hZ2VJbmZvcywgaW1hZ2VJbmZvID0+IGltYWdlSW5mby5ibG9iSW5mbyk7XG4gICAgICAgICAgcmV0dXJuIHVwbG9hZGVyLnVwbG9hZChibG9iSW5mb3MsIG9wZW5Ob3RpZmljYXRpb24oZWRpdG9yKSkudGhlbihhbGl2ZUd1YXJkKHJlc3VsdCA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbWFnZXNUb1JlbW92ZSA9IFtdO1xuICAgICAgICAgICAgY29uc3QgZmlsdGVyZWRSZXN1bHQgPSBtYXAkMyhyZXN1bHQsICh1cGxvYWRJbmZvLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBibG9iSW5mbyA9IGltYWdlSW5mb3NbaW5kZXhdLmJsb2JJbmZvO1xuICAgICAgICAgICAgICBjb25zdCBpbWFnZSA9IGltYWdlSW5mb3NbaW5kZXhdLmltYWdlO1xuICAgICAgICAgICAgICBsZXQgcmVtb3ZlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBpZiAodXBsb2FkSW5mby5zdGF0dXMgJiYgc2hvdWxkUmVwbGFjZUJsb2JVcmlzKGVkaXRvcikpIHtcbiAgICAgICAgICAgICAgICBibG9iQ2FjaGUucmVtb3ZlQnlVcmkoaW1hZ2Uuc3JjKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNSdGMoZWRpdG9yKSkgOyBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJlcGxhY2VJbWFnZVVyaUluVmlldyhpbWFnZSwgdXBsb2FkSW5mby51cmwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh1cGxvYWRJbmZvLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVwbG9hZEluZm8uZXJyb3IucmVtb3ZlKSB7XG4gICAgICAgICAgICAgICAgICByZXBsYWNlVXJsSW5VbmRvU3RhY2soaW1hZ2UuZ2V0QXR0cmlidXRlKCdzcmMnKSwgRW52LnRyYW5zcGFyZW50U3JjKTtcbiAgICAgICAgICAgICAgICAgIGltYWdlc1RvUmVtb3ZlLnB1c2goaW1hZ2UpO1xuICAgICAgICAgICAgICAgICAgcmVtb3ZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVwbG9hZEVycm9yKGVkaXRvciwgdXBsb2FkSW5mby5lcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGltYWdlLFxuICAgICAgICAgICAgICAgIHN0YXR1czogdXBsb2FkSW5mby5zdGF0dXMsXG4gICAgICAgICAgICAgICAgdXBsb2FkVXJpOiB1cGxvYWRJbmZvLnVybCxcbiAgICAgICAgICAgICAgICBibG9iSW5mbyxcbiAgICAgICAgICAgICAgICByZW1vdmVkXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChmaWx0ZXJlZFJlc3VsdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGNoYW5nZUhhbmRsZXIuZmlyZUlmQ2hhbmdlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGltYWdlc1RvUmVtb3ZlLmxlbmd0aCA+IDAgJiYgIWlzUnRjKGVkaXRvcikpIHtcbiAgICAgICAgICAgICAgZWRpdG9yLnVuZG9NYW5hZ2VyLnRyYW5zYWN0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBlYWNoJGcoaW1hZ2VzVG9SZW1vdmUsIGVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgICAgICAgZWRpdG9yLmRvbS5yZW1vdmUoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICBibG9iQ2FjaGUucmVtb3ZlQnlVcmkoZWxlbWVudC5zcmMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXJlZFJlc3VsdDtcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0pKTtcbiAgICAgIH07XG4gICAgICBjb25zdCB1cGxvYWRJbWFnZXNBdXRvID0gKCkgPT4gaXNBdXRvbWF0aWNVcGxvYWRzRW5hYmxlZChlZGl0b3IpID8gdXBsb2FkSW1hZ2VzKCkgOiBQcm9taXNlLnJlc29sdmUoW10pO1xuICAgICAgY29uc3QgaXNWYWxpZERhdGFVcmlJbWFnZSA9IGltZ0VsbSA9PiBmb3JhbGwodXJsRmlsdGVycywgZmlsdGVyID0+IGZpbHRlcihpbWdFbG0pKTtcbiAgICAgIGNvbnN0IGFkZEZpbHRlciA9IGZpbHRlciA9PiB7XG4gICAgICAgIHVybEZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHNjYW5Gb3JJbWFnZXMgPSAoKSA9PiB7XG4gICAgICAgIGlmICghaW1hZ2VTY2FubmVyKSB7XG4gICAgICAgICAgaW1hZ2VTY2FubmVyID0gSW1hZ2VTY2FubmVyKHVwbG9hZFN0YXR1cywgYmxvYkNhY2hlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW1hZ2VTY2FubmVyLmZpbmRBbGwoZWRpdG9yLmdldEJvZHkoKSwgaXNWYWxpZERhdGFVcmlJbWFnZSkudGhlbihhbGl2ZUd1YXJkKHJlc3VsdCA9PiB7XG4gICAgICAgICAgcmVzdWx0ID0gZmlsdGVyJDYocmVzdWx0LCByZXN1bHRJdGVtID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0SXRlbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgZGlzcGxheUVycm9yKGVkaXRvciwgcmVzdWx0SXRlbSk7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChpc1J0YyhlZGl0b3IpKSA7IGVsc2Uge1xuICAgICAgICAgICAgZWFjaCRnKHJlc3VsdCwgcmVzdWx0SXRlbSA9PiB7XG4gICAgICAgICAgICAgIHJlcGxhY2VVcmxJblVuZG9TdGFjayhyZXN1bHRJdGVtLmltYWdlLnNyYywgcmVzdWx0SXRlbS5ibG9iSW5mby5ibG9iVXJpKCkpO1xuICAgICAgICAgICAgICByZXN1bHRJdGVtLmltYWdlLnNyYyA9IHJlc3VsdEl0ZW0uYmxvYkluZm8uYmxvYlVyaSgpO1xuICAgICAgICAgICAgICByZXN1bHRJdGVtLmltYWdlLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1tY2Utc3JjJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSkpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGRlc3Ryb3kgPSAoKSA9PiB7XG4gICAgICAgIGJsb2JDYWNoZS5kZXN0cm95KCk7XG4gICAgICAgIHVwbG9hZFN0YXR1cy5kZXN0cm95KCk7XG4gICAgICAgIGltYWdlU2Nhbm5lciA9IHVwbG9hZGVyID0gbnVsbDtcbiAgICAgIH07XG4gICAgICBjb25zdCByZXBsYWNlQmxvYlVyaXMgPSBjb250ZW50ID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQucmVwbGFjZSgvc3JjPVwiKGJsb2I6W15cIl0rKVwiL2csIChtYXRjaCwgYmxvYlVyaSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdFVyaSA9IHVwbG9hZFN0YXR1cy5nZXRSZXN1bHRVcmkoYmxvYlVyaSk7XG4gICAgICAgICAgaWYgKHJlc3VsdFVyaSkge1xuICAgICAgICAgICAgcmV0dXJuICdzcmM9XCInICsgcmVzdWx0VXJpICsgJ1wiJztcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGJsb2JJbmZvID0gYmxvYkNhY2hlLmdldEJ5VXJpKGJsb2JVcmkpO1xuICAgICAgICAgIGlmICghYmxvYkluZm8pIHtcbiAgICAgICAgICAgIGJsb2JJbmZvID0gZm9sZGwoZWRpdG9yLmVkaXRvck1hbmFnZXIuZ2V0KCksIChyZXN1bHQsIGVkaXRvcikgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0IHx8IGVkaXRvci5lZGl0b3JVcGxvYWQgJiYgZWRpdG9yLmVkaXRvclVwbG9hZC5ibG9iQ2FjaGUuZ2V0QnlVcmkoYmxvYlVyaSk7XG4gICAgICAgICAgICB9LCBudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGJsb2JJbmZvKSB7XG4gICAgICAgICAgICBjb25zdCBibG9iID0gYmxvYkluZm8uYmxvYigpO1xuICAgICAgICAgICAgcmV0dXJuICdzcmM9XCJkYXRhOicgKyBibG9iLnR5cGUgKyAnO2Jhc2U2NCwnICsgYmxvYkluZm8uYmFzZTY0KCkgKyAnXCInO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGVkaXRvci5vbignU2V0Q29udGVudCcsICgpID0+IHtcbiAgICAgICAgaWYgKGlzQXV0b21hdGljVXBsb2Fkc0VuYWJsZWQoZWRpdG9yKSkge1xuICAgICAgICAgIHVwbG9hZEltYWdlc0F1dG8oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzY2FuRm9ySW1hZ2VzKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLm9uKCdSYXdTYXZlQ29udGVudCcsIGUgPT4ge1xuICAgICAgICBlLmNvbnRlbnQgPSByZXBsYWNlQmxvYlVyaXMoZS5jb250ZW50KTtcbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLm9uKCdHZXRDb250ZW50JywgZSA9PiB7XG4gICAgICAgIGlmIChlLnNvdXJjZV92aWV3IHx8IGUuZm9ybWF0ID09PSAncmF3JyB8fCBlLmZvcm1hdCA9PT0gJ3RyZWUnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGUuY29udGVudCA9IHJlcGxhY2VCbG9iVXJpcyhlLmNvbnRlbnQpO1xuICAgICAgfSk7XG4gICAgICBlZGl0b3Iub24oJ1Bvc3RSZW5kZXInLCAoKSA9PiB7XG4gICAgICAgIGVkaXRvci5wYXJzZXIuYWRkTm9kZUZpbHRlcignaW1nJywgaW1hZ2VzID0+IHtcbiAgICAgICAgICBlYWNoJGcoaW1hZ2VzLCBpbWcgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3JjID0gaW1nLmF0dHIoJ3NyYycpO1xuICAgICAgICAgICAgaWYgKGJsb2JDYWNoZS5nZXRCeVVyaShzcmMpKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdFVyaSA9IHVwbG9hZFN0YXR1cy5nZXRSZXN1bHRVcmkoc3JjKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHRVcmkpIHtcbiAgICAgICAgICAgICAgaW1nLmF0dHIoJ3NyYycsIHJlc3VsdFVyaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBibG9iQ2FjaGUsXG4gICAgICAgIGFkZEZpbHRlcixcbiAgICAgICAgdXBsb2FkSW1hZ2VzLFxuICAgICAgICB1cGxvYWRJbWFnZXNBdXRvLFxuICAgICAgICBzY2FuRm9ySW1hZ2VzLFxuICAgICAgICBkZXN0cm95XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCBnZXQkMSA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBkb20gPSBlZGl0b3IuZG9tO1xuICAgICAgY29uc3Qgc2NoZW1hVHlwZSA9IGVkaXRvci5zY2hlbWEudHlwZTtcbiAgICAgIGNvbnN0IGZvcm1hdHMgPSB7XG4gICAgICAgIHZhbGlnbnRvcDogW3tcbiAgICAgICAgICAgIHNlbGVjdG9yOiAndGQsdGgnLFxuICAgICAgICAgICAgc3R5bGVzOiB7IHZlcnRpY2FsQWxpZ246ICd0b3AnIH1cbiAgICAgICAgICB9XSxcbiAgICAgICAgdmFsaWdubWlkZGxlOiBbe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICd0ZCx0aCcsXG4gICAgICAgICAgICBzdHlsZXM6IHsgdmVydGljYWxBbGlnbjogJ21pZGRsZScgfVxuICAgICAgICAgIH1dLFxuICAgICAgICB2YWxpZ25ib3R0b206IFt7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ3RkLHRoJyxcbiAgICAgICAgICAgIHN0eWxlczogeyB2ZXJ0aWNhbEFsaWduOiAnYm90dG9tJyB9XG4gICAgICAgICAgfV0sXG4gICAgICAgIGFsaWdubGVmdDogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnZmlndXJlLmltYWdlJyxcbiAgICAgICAgICAgIGNvbGxhcHNlZDogZmFsc2UsXG4gICAgICAgICAgICBjbGFzc2VzOiAnYWxpZ24tbGVmdCcsXG4gICAgICAgICAgICBjZUZhbHNlT3ZlcnJpZGU6IHRydWUsXG4gICAgICAgICAgICBwcmV2aWV3OiAnZm9udC1mYW1pbHkgZm9udC1zaXplJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdmaWd1cmUscCxoMSxoMixoMyxoNCxoNSxoNix0ZCx0aCx0cixkaXYsdWwsb2wsbGknLFxuICAgICAgICAgICAgc3R5bGVzOiB7IHRleHRBbGlnbjogJ2xlZnQnIH0sXG4gICAgICAgICAgICBpbmhlcml0OiBmYWxzZSxcbiAgICAgICAgICAgIHByZXZpZXc6IGZhbHNlXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ2ltZyxhdWRpbyx2aWRlbycsXG4gICAgICAgICAgICBjb2xsYXBzZWQ6IGZhbHNlLFxuICAgICAgICAgICAgc3R5bGVzOiB7IGZsb2F0OiAnbGVmdCcgfSxcbiAgICAgICAgICAgIHByZXZpZXc6ICdmb250LWZhbWlseSBmb250LXNpemUnXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ3RhYmxlJyxcbiAgICAgICAgICAgIGNvbGxhcHNlZDogZmFsc2UsXG4gICAgICAgICAgICBzdHlsZXM6IHtcbiAgICAgICAgICAgICAgbWFyZ2luTGVmdDogJzBweCcsXG4gICAgICAgICAgICAgIG1hcmdpblJpZ2h0OiAnYXV0bydcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbmZvcm1hdDogdGFibGUgPT4ge1xuICAgICAgICAgICAgICBkb20uc2V0U3R5bGUodGFibGUsICdmbG9hdCcsIG51bGwpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByZXZpZXc6ICdmb250LWZhbWlseSBmb250LXNpemUnXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBhbGlnbmNlbnRlcjogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnZmlndXJlLHAsaDEsaDIsaDMsaDQsaDUsaDYsdGQsdGgsdHIsZGl2LHVsLG9sLGxpJyxcbiAgICAgICAgICAgIHN0eWxlczogeyB0ZXh0QWxpZ246ICdjZW50ZXInIH0sXG4gICAgICAgICAgICBpbmhlcml0OiBmYWxzZSxcbiAgICAgICAgICAgIHByZXZpZXc6ICdmb250LWZhbWlseSBmb250LXNpemUnXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ2ZpZ3VyZS5pbWFnZScsXG4gICAgICAgICAgICBjb2xsYXBzZWQ6IGZhbHNlLFxuICAgICAgICAgICAgY2xhc3NlczogJ2FsaWduLWNlbnRlcicsXG4gICAgICAgICAgICBjZUZhbHNlT3ZlcnJpZGU6IHRydWUsXG4gICAgICAgICAgICBwcmV2aWV3OiAnZm9udC1mYW1pbHkgZm9udC1zaXplJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdpbWcsYXVkaW8sdmlkZW8nLFxuICAgICAgICAgICAgY29sbGFwc2VkOiBmYWxzZSxcbiAgICAgICAgICAgIHN0eWxlczoge1xuICAgICAgICAgICAgICBkaXNwbGF5OiAnYmxvY2snLFxuICAgICAgICAgICAgICBtYXJnaW5MZWZ0OiAnYXV0bycsXG4gICAgICAgICAgICAgIG1hcmdpblJpZ2h0OiAnYXV0bydcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcmV2aWV3OiBmYWxzZVxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgc2VsZWN0b3I6ICd0YWJsZScsXG4gICAgICAgICAgICBjb2xsYXBzZWQ6IGZhbHNlLFxuICAgICAgICAgICAgc3R5bGVzOiB7XG4gICAgICAgICAgICAgIG1hcmdpbkxlZnQ6ICdhdXRvJyxcbiAgICAgICAgICAgICAgbWFyZ2luUmlnaHQ6ICdhdXRvJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByZXZpZXc6ICdmb250LWZhbWlseSBmb250LXNpemUnXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBhbGlnbnJpZ2h0OiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdmaWd1cmUuaW1hZ2UnLFxuICAgICAgICAgICAgY29sbGFwc2VkOiBmYWxzZSxcbiAgICAgICAgICAgIGNsYXNzZXM6ICdhbGlnbi1yaWdodCcsXG4gICAgICAgICAgICBjZUZhbHNlT3ZlcnJpZGU6IHRydWUsXG4gICAgICAgICAgICBwcmV2aWV3OiAnZm9udC1mYW1pbHkgZm9udC1zaXplJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdmaWd1cmUscCxoMSxoMixoMyxoNCxoNSxoNix0ZCx0aCx0cixkaXYsdWwsb2wsbGknLFxuICAgICAgICAgICAgc3R5bGVzOiB7IHRleHRBbGlnbjogJ3JpZ2h0JyB9LFxuICAgICAgICAgICAgaW5oZXJpdDogZmFsc2UsXG4gICAgICAgICAgICBwcmV2aWV3OiAnZm9udC1mYW1pbHkgZm9udC1zaXplJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdpbWcsYXVkaW8sdmlkZW8nLFxuICAgICAgICAgICAgY29sbGFwc2VkOiBmYWxzZSxcbiAgICAgICAgICAgIHN0eWxlczogeyBmbG9hdDogJ3JpZ2h0JyB9LFxuICAgICAgICAgICAgcHJldmlldzogJ2ZvbnQtZmFtaWx5IGZvbnQtc2l6ZSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAndGFibGUnLFxuICAgICAgICAgICAgY29sbGFwc2VkOiBmYWxzZSxcbiAgICAgICAgICAgIHN0eWxlczoge1xuICAgICAgICAgICAgICBtYXJnaW5SaWdodDogJzBweCcsXG4gICAgICAgICAgICAgIG1hcmdpbkxlZnQ6ICdhdXRvJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uZm9ybWF0OiB0YWJsZSA9PiB7XG4gICAgICAgICAgICAgIGRvbS5zZXRTdHlsZSh0YWJsZSwgJ2Zsb2F0JywgbnVsbCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJldmlldzogJ2ZvbnQtZmFtaWx5IGZvbnQtc2l6ZSdcbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIGFsaWduanVzdGlmeTogW3tcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnZmlndXJlLHAsaDEsaDIsaDMsaDQsaDUsaDYsdGQsdGgsdHIsZGl2LHVsLG9sLGxpJyxcbiAgICAgICAgICAgIHN0eWxlczogeyB0ZXh0QWxpZ246ICdqdXN0aWZ5JyB9LFxuICAgICAgICAgICAgaW5oZXJpdDogZmFsc2UsXG4gICAgICAgICAgICBwcmV2aWV3OiAnZm9udC1mYW1pbHkgZm9udC1zaXplJ1xuICAgICAgICAgIH1dLFxuICAgICAgICBib2xkOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgaW5saW5lOiAnc3Ryb25nJyxcbiAgICAgICAgICAgIHJlbW92ZTogJ2FsbCcsXG4gICAgICAgICAgICBwcmVzZXJ2ZV9hdHRyaWJ1dGVzOiBbXG4gICAgICAgICAgICAgICdjbGFzcycsXG4gICAgICAgICAgICAgICdzdHlsZSdcbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlubGluZTogJ3NwYW4nLFxuICAgICAgICAgICAgc3R5bGVzOiB7IGZvbnRXZWlnaHQ6ICdib2xkJyB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpbmxpbmU6ICdiJyxcbiAgICAgICAgICAgIHJlbW92ZTogJ2FsbCcsXG4gICAgICAgICAgICBwcmVzZXJ2ZV9hdHRyaWJ1dGVzOiBbXG4gICAgICAgICAgICAgICdjbGFzcycsXG4gICAgICAgICAgICAgICdzdHlsZSdcbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIGl0YWxpYzogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlubGluZTogJ2VtJyxcbiAgICAgICAgICAgIHJlbW92ZTogJ2FsbCcsXG4gICAgICAgICAgICBwcmVzZXJ2ZV9hdHRyaWJ1dGVzOiBbXG4gICAgICAgICAgICAgICdjbGFzcycsXG4gICAgICAgICAgICAgICdzdHlsZSdcbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlubGluZTogJ3NwYW4nLFxuICAgICAgICAgICAgc3R5bGVzOiB7IGZvbnRTdHlsZTogJ2l0YWxpYycgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgaW5saW5lOiAnaScsXG4gICAgICAgICAgICByZW1vdmU6ICdhbGwnLFxuICAgICAgICAgICAgcHJlc2VydmVfYXR0cmlidXRlczogW1xuICAgICAgICAgICAgICAnY2xhc3MnLFxuICAgICAgICAgICAgICAnc3R5bGUnXG4gICAgICAgICAgICBdXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICB1bmRlcmxpbmU6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpbmxpbmU6ICdzcGFuJyxcbiAgICAgICAgICAgIHN0eWxlczogeyB0ZXh0RGVjb3JhdGlvbjogJ3VuZGVybGluZScgfSxcbiAgICAgICAgICAgIGV4YWN0OiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpbmxpbmU6ICd1JyxcbiAgICAgICAgICAgIHJlbW92ZTogJ2FsbCcsXG4gICAgICAgICAgICBwcmVzZXJ2ZV9hdHRyaWJ1dGVzOiBbXG4gICAgICAgICAgICAgICdjbGFzcycsXG4gICAgICAgICAgICAgICdzdHlsZSdcbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHN0cmlrZXRocm91Z2g6ICgoKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3BhbiA9IHtcbiAgICAgICAgICAgIGlubGluZTogJ3NwYW4nLFxuICAgICAgICAgICAgc3R5bGVzOiB7IHRleHREZWNvcmF0aW9uOiAnbGluZS10aHJvdWdoJyB9LFxuICAgICAgICAgICAgZXhhY3Q6IHRydWVcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnN0IHN0cmlrZSA9IHtcbiAgICAgICAgICAgIGlubGluZTogJ3N0cmlrZScsXG4gICAgICAgICAgICByZW1vdmU6ICdhbGwnLFxuICAgICAgICAgICAgcHJlc2VydmVfYXR0cmlidXRlczogW1xuICAgICAgICAgICAgICAnY2xhc3MnLFxuICAgICAgICAgICAgICAnc3R5bGUnXG4gICAgICAgICAgICBdXG4gICAgICAgICAgfTtcbiAgICAgICAgICBjb25zdCBzID0ge1xuICAgICAgICAgICAgaW5saW5lOiAncycsXG4gICAgICAgICAgICByZW1vdmU6ICdhbGwnLFxuICAgICAgICAgICAgcHJlc2VydmVfYXR0cmlidXRlczogW1xuICAgICAgICAgICAgICAnY2xhc3MnLFxuICAgICAgICAgICAgICAnc3R5bGUnXG4gICAgICAgICAgICBdXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gc2NoZW1hVHlwZSAhPT0gJ2h0bWw0JyA/IFtcbiAgICAgICAgICAgIHMsXG4gICAgICAgICAgICBzcGFuLFxuICAgICAgICAgICAgc3RyaWtlXG4gICAgICAgICAgXSA6IFtcbiAgICAgICAgICAgIHNwYW4sXG4gICAgICAgICAgICBzLFxuICAgICAgICAgICAgc3RyaWtlXG4gICAgICAgICAgXTtcbiAgICAgICAgfSkoKSxcbiAgICAgICAgZm9yZWNvbG9yOiB7XG4gICAgICAgICAgaW5saW5lOiAnc3BhbicsXG4gICAgICAgICAgc3R5bGVzOiB7IGNvbG9yOiAnJXZhbHVlJyB9LFxuICAgICAgICAgIGxpbmtzOiB0cnVlLFxuICAgICAgICAgIHJlbW92ZV9zaW1pbGFyOiB0cnVlLFxuICAgICAgICAgIGNsZWFyX2NoaWxkX3N0eWxlczogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBoaWxpdGVjb2xvcjoge1xuICAgICAgICAgIGlubGluZTogJ3NwYW4nLFxuICAgICAgICAgIHN0eWxlczogeyBiYWNrZ3JvdW5kQ29sb3I6ICcldmFsdWUnIH0sXG4gICAgICAgICAgbGlua3M6IHRydWUsXG4gICAgICAgICAgcmVtb3ZlX3NpbWlsYXI6IHRydWUsXG4gICAgICAgICAgY2xlYXJfY2hpbGRfc3R5bGVzOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIGZvbnRuYW1lOiB7XG4gICAgICAgICAgaW5saW5lOiAnc3BhbicsXG4gICAgICAgICAgdG9nZ2xlOiBmYWxzZSxcbiAgICAgICAgICBzdHlsZXM6IHsgZm9udEZhbWlseTogJyV2YWx1ZScgfSxcbiAgICAgICAgICBjbGVhcl9jaGlsZF9zdHlsZXM6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgZm9udHNpemU6IHtcbiAgICAgICAgICBpbmxpbmU6ICdzcGFuJyxcbiAgICAgICAgICB0b2dnbGU6IGZhbHNlLFxuICAgICAgICAgIHN0eWxlczogeyBmb250U2l6ZTogJyV2YWx1ZScgfSxcbiAgICAgICAgICBjbGVhcl9jaGlsZF9zdHlsZXM6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgbGluZWhlaWdodDoge1xuICAgICAgICAgIHNlbGVjdG9yOiAnaDEsaDIsaDMsaDQsaDUsaDYscCxsaSx0ZCx0aCxkaXYnLFxuICAgICAgICAgIHN0eWxlczogeyBsaW5lSGVpZ2h0OiAnJXZhbHVlJyB9XG4gICAgICAgIH0sXG4gICAgICAgIGZvbnRzaXplX2NsYXNzOiB7XG4gICAgICAgICAgaW5saW5lOiAnc3BhbicsXG4gICAgICAgICAgYXR0cmlidXRlczogeyBjbGFzczogJyV2YWx1ZScgfVxuICAgICAgICB9LFxuICAgICAgICBibG9ja3F1b3RlOiB7XG4gICAgICAgICAgYmxvY2s6ICdibG9ja3F1b3RlJyxcbiAgICAgICAgICB3cmFwcGVyOiB0cnVlLFxuICAgICAgICAgIHJlbW92ZTogJ2FsbCdcbiAgICAgICAgfSxcbiAgICAgICAgc3Vic2NyaXB0OiB7IGlubGluZTogJ3N1YicgfSxcbiAgICAgICAgc3VwZXJzY3JpcHQ6IHsgaW5saW5lOiAnc3VwJyB9LFxuICAgICAgICBjb2RlOiB7IGlubGluZTogJ2NvZGUnIH0sXG4gICAgICAgIGxpbms6IHtcbiAgICAgICAgICBpbmxpbmU6ICdhJyxcbiAgICAgICAgICBzZWxlY3RvcjogJ2EnLFxuICAgICAgICAgIHJlbW92ZTogJ2FsbCcsXG4gICAgICAgICAgc3BsaXQ6IHRydWUsXG4gICAgICAgICAgZGVlcDogdHJ1ZSxcbiAgICAgICAgICBvbm1hdGNoOiAobm9kZSwgX2ZtdCwgX2l0ZW1OYW1lKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gaXNFbGVtZW50JDYobm9kZSkgJiYgbm9kZS5oYXNBdHRyaWJ1dGUoJ2hyZWYnKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uZm9ybWF0OiAoZWxtLCBfZm10LCB2YXJzKSA9PiB7XG4gICAgICAgICAgICBUb29scy5lYWNoKHZhcnMsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICAgIGRvbS5zZXRBdHRyaWIoZWxtLCBrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbGFuZzoge1xuICAgICAgICAgIGlubGluZTogJ3NwYW4nLFxuICAgICAgICAgIGNsZWFyX2NoaWxkX3N0eWxlczogdHJ1ZSxcbiAgICAgICAgICByZW1vdmVfc2ltaWxhcjogdHJ1ZSxcbiAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAnbGFuZyc6ICcldmFsdWUnLFxuICAgICAgICAgICAgJ2RhdGEtbWNlLWxhbmcnOiB2YXJzID0+IHtcbiAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICByZXR1cm4gKF9hID0gdmFycyA9PT0gbnVsbCB8fCB2YXJzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YXJzLmN1c3RvbVZhbHVlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlZm9ybWF0OiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdiLHN0cm9uZyxlbSxpLGZvbnQsdSxzdHJpa2UscyxzdWIsc3VwLGRmbixjb2RlLHNhbXAsa2JkLHZhcixjaXRlLG1hcmsscSxkZWwsaW5zLHNtYWxsJyxcbiAgICAgICAgICAgIHJlbW92ZTogJ2FsbCcsXG4gICAgICAgICAgICBzcGxpdDogdHJ1ZSxcbiAgICAgICAgICAgIGV4cGFuZDogZmFsc2UsXG4gICAgICAgICAgICBibG9ja19leHBhbmQ6IHRydWUsXG4gICAgICAgICAgICBkZWVwOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ3NwYW4nLFxuICAgICAgICAgICAgYXR0cmlidXRlczogW1xuICAgICAgICAgICAgICAnc3R5bGUnLFxuICAgICAgICAgICAgICAnY2xhc3MnXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgcmVtb3ZlOiAnZW1wdHknLFxuICAgICAgICAgICAgc3BsaXQ6IHRydWUsXG4gICAgICAgICAgICBleHBhbmQ6IGZhbHNlLFxuICAgICAgICAgICAgZGVlcDogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgc2VsZWN0b3I6ICcqJyxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFtcbiAgICAgICAgICAgICAgJ3N0eWxlJyxcbiAgICAgICAgICAgICAgJ2NsYXNzJ1xuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHNwbGl0OiBmYWxzZSxcbiAgICAgICAgICAgIGV4cGFuZDogZmFsc2UsXG4gICAgICAgICAgICBkZWVwOiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9O1xuICAgICAgVG9vbHMuZWFjaCgncCBoMSBoMiBoMyBoNCBoNSBoNiBkaXYgYWRkcmVzcyBwcmUgZHQgZGQgc2FtcCcuc3BsaXQoL1xccy8pLCBuYW1lID0+IHtcbiAgICAgICAgZm9ybWF0c1tuYW1lXSA9IHtcbiAgICAgICAgICBibG9jazogbmFtZSxcbiAgICAgICAgICByZW1vdmU6ICdhbGwnXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmb3JtYXRzO1xuICAgIH07XG5cbiAgICBjb25zdCBnZW5lcmljQmFzZSA9IHtcbiAgICAgIHJlbW92ZV9zaW1pbGFyOiB0cnVlLFxuICAgICAgaW5oZXJpdDogZmFsc2VcbiAgICB9O1xuICAgIGNvbnN0IGNlbGxCYXNlID0ge1xuICAgICAgc2VsZWN0b3I6ICd0ZCx0aCcsXG4gICAgICAuLi5nZW5lcmljQmFzZVxuICAgIH07XG4gICAgY29uc3QgY2VsbEZvcm1hdHMgPSB7XG4gICAgICB0YWJsZWNlbGxiYWNrZ3JvdW5kY29sb3I6IHtcbiAgICAgICAgc3R5bGVzOiB7IGJhY2tncm91bmRDb2xvcjogJyV2YWx1ZScgfSxcbiAgICAgICAgLi4uY2VsbEJhc2VcbiAgICAgIH0sXG4gICAgICB0YWJsZWNlbGx2ZXJ0aWNhbGFsaWduOiB7XG4gICAgICAgIHN0eWxlczogeyAndmVydGljYWwtYWxpZ24nOiAnJXZhbHVlJyB9LFxuICAgICAgICAuLi5jZWxsQmFzZVxuICAgICAgfSxcbiAgICAgIHRhYmxlY2VsbGJvcmRlcmNvbG9yOiB7XG4gICAgICAgIHN0eWxlczogeyBib3JkZXJDb2xvcjogJyV2YWx1ZScgfSxcbiAgICAgICAgLi4uY2VsbEJhc2VcbiAgICAgIH0sXG4gICAgICB0YWJsZWNlbGxjbGFzczoge1xuICAgICAgICBjbGFzc2VzOiBbJyV2YWx1ZSddLFxuICAgICAgICAuLi5jZWxsQmFzZVxuICAgICAgfSxcbiAgICAgIHRhYmxlY2xhc3M6IHtcbiAgICAgICAgc2VsZWN0b3I6ICd0YWJsZScsXG4gICAgICAgIGNsYXNzZXM6IFsnJXZhbHVlJ10sXG4gICAgICAgIC4uLmdlbmVyaWNCYXNlXG4gICAgICB9LFxuICAgICAgdGFibGVjZWxsYm9yZGVyc3R5bGU6IHtcbiAgICAgICAgc3R5bGVzOiB7IGJvcmRlclN0eWxlOiAnJXZhbHVlJyB9LFxuICAgICAgICAuLi5jZWxsQmFzZVxuICAgICAgfSxcbiAgICAgIHRhYmxlY2VsbGJvcmRlcndpZHRoOiB7XG4gICAgICAgIHN0eWxlczogeyBib3JkZXJXaWR0aDogJyV2YWx1ZScgfSxcbiAgICAgICAgLi4uY2VsbEJhc2VcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGdldCA9IGNvbnN0YW50KGNlbGxGb3JtYXRzKTtcblxuICAgIGNvbnN0IEZvcm1hdFJlZ2lzdHJ5ID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IGZvcm1hdHMgPSB7fTtcbiAgICAgIGNvbnN0IGdldCQyID0gbmFtZSA9PiBpc05vbk51bGxhYmxlKG5hbWUpID8gZm9ybWF0c1tuYW1lXSA6IGZvcm1hdHM7XG4gICAgICBjb25zdCBoYXMgPSBuYW1lID0+IGhhcyQyKGZvcm1hdHMsIG5hbWUpO1xuICAgICAgY29uc3QgcmVnaXN0ZXIgPSAobmFtZSwgZm9ybWF0KSA9PiB7XG4gICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgaWYgKCFpc1N0cmluZyhuYW1lKSkge1xuICAgICAgICAgICAgZWFjaCRmKG5hbWUsIChmb3JtYXQsIG5hbWUpID0+IHtcbiAgICAgICAgICAgICAgcmVnaXN0ZXIobmFtZSwgZm9ybWF0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWlzQXJyYXkkMShmb3JtYXQpKSB7XG4gICAgICAgICAgICAgIGZvcm1hdCA9IFtmb3JtYXRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWFjaCRnKGZvcm1hdCwgZm9ybWF0ID0+IHtcbiAgICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGZvcm1hdC5kZWVwKSkge1xuICAgICAgICAgICAgICAgIGZvcm1hdC5kZWVwID0gIWlzU2VsZWN0b3JGb3JtYXQoZm9ybWF0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQoZm9ybWF0LnNwbGl0KSkge1xuICAgICAgICAgICAgICAgIGZvcm1hdC5zcGxpdCA9ICFpc1NlbGVjdG9yRm9ybWF0KGZvcm1hdCkgfHwgaXNJbmxpbmVGb3JtYXQoZm9ybWF0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQoZm9ybWF0LnJlbW92ZSkgJiYgaXNTZWxlY3RvckZvcm1hdChmb3JtYXQpICYmICFpc0lubGluZUZvcm1hdChmb3JtYXQpKSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0LnJlbW92ZSA9ICdub25lJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaXNTZWxlY3RvckZvcm1hdChmb3JtYXQpICYmIGlzSW5saW5lRm9ybWF0KGZvcm1hdCkpIHtcbiAgICAgICAgICAgICAgICBmb3JtYXQubWl4ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvcm1hdC5ibG9ja19leHBhbmQgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpc1N0cmluZyhmb3JtYXQuY2xhc3NlcykpIHtcbiAgICAgICAgICAgICAgICBmb3JtYXQuY2xhc3NlcyA9IGZvcm1hdC5jbGFzc2VzLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZm9ybWF0c1tuYW1lXSA9IGZvcm1hdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCB1bnJlZ2lzdGVyID0gbmFtZSA9PiB7XG4gICAgICAgIGlmIChuYW1lICYmIGZvcm1hdHNbbmFtZV0pIHtcbiAgICAgICAgICBkZWxldGUgZm9ybWF0c1tuYW1lXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0cztcbiAgICAgIH07XG4gICAgICByZWdpc3RlcihnZXQkMShlZGl0b3IpKTtcbiAgICAgIHJlZ2lzdGVyKGdldCgpKTtcbiAgICAgIHJlZ2lzdGVyKGdldEZvcm1hdHMoZWRpdG9yKSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBnZXQ6IGdldCQyLFxuICAgICAgICBoYXMsXG4gICAgICAgIHJlZ2lzdGVyLFxuICAgICAgICB1bnJlZ2lzdGVyXG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCBlYWNoJDMgPSBUb29scy5lYWNoO1xuICAgIGNvbnN0IGRvbSA9IERPTVV0aWxzLkRPTTtcbiAgICBjb25zdCBwYXJzZWRTZWxlY3RvclRvSHRtbCA9IChhbmNlc3RyeSwgZWRpdG9yKSA9PiB7XG4gICAgICBsZXQgZWxtLCBpdGVtLCBmcmFnbWVudDtcbiAgICAgIGNvbnN0IHNjaGVtYSA9IGVkaXRvciAmJiBlZGl0b3Iuc2NoZW1hIHx8IFNjaGVtYSh7fSk7XG4gICAgICBjb25zdCBkZWNvcmF0ZSA9IChlbG0sIGl0ZW0pID0+IHtcbiAgICAgICAgaWYgKGl0ZW0uY2xhc3Nlcy5sZW5ndGgpIHtcbiAgICAgICAgICBkb20uYWRkQ2xhc3MoZWxtLCBpdGVtLmNsYXNzZXMuam9pbignICcpKTtcbiAgICAgICAgfVxuICAgICAgICBkb20uc2V0QXR0cmlicyhlbG0sIGl0ZW0uYXR0cnMpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGNyZWF0ZUVsZW1lbnQgPSBzSXRlbSA9PiB7XG4gICAgICAgIGl0ZW0gPSB0eXBlb2Ygc0l0ZW0gPT09ICdzdHJpbmcnID8ge1xuICAgICAgICAgIG5hbWU6IHNJdGVtLFxuICAgICAgICAgIGNsYXNzZXM6IFtdLFxuICAgICAgICAgIGF0dHJzOiB7fVxuICAgICAgICB9IDogc0l0ZW07XG4gICAgICAgIGNvbnN0IGVsbSA9IGRvbS5jcmVhdGUoaXRlbS5uYW1lKTtcbiAgICAgICAgZGVjb3JhdGUoZWxtLCBpdGVtKTtcbiAgICAgICAgcmV0dXJuIGVsbTtcbiAgICAgIH07XG4gICAgICBjb25zdCBnZXRSZXF1aXJlZFBhcmVudCA9IChlbG0sIGNhbmRpZGF0ZSkgPT4ge1xuICAgICAgICBjb25zdCBuYW1lID0gdHlwZW9mIGVsbSAhPT0gJ3N0cmluZycgPyBlbG0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA6IGVsbTtcbiAgICAgICAgY29uc3QgZWxtUnVsZSA9IHNjaGVtYS5nZXRFbGVtZW50UnVsZShuYW1lKTtcbiAgICAgICAgY29uc3QgcGFyZW50c1JlcXVpcmVkID0gZWxtUnVsZSAmJiBlbG1SdWxlLnBhcmVudHNSZXF1aXJlZDtcbiAgICAgICAgaWYgKHBhcmVudHNSZXF1aXJlZCAmJiBwYXJlbnRzUmVxdWlyZWQubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBUb29scy5pbkFycmF5KHBhcmVudHNSZXF1aXJlZCwgY2FuZGlkYXRlKSAhPT0gLTEgPyBjYW5kaWRhdGUgOiBwYXJlbnRzUmVxdWlyZWRbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3Qgd3JhcEluSHRtbCA9IChlbG0sIGFuY2VzdHJ5LCBzaWJsaW5ncykgPT4ge1xuICAgICAgICBsZXQgcGFyZW50LCBwYXJlbnRDYW5kaWRhdGU7XG4gICAgICAgIGNvbnN0IGFuY2VzdG9yID0gYW5jZXN0cnkubGVuZ3RoID4gMCAmJiBhbmNlc3RyeVswXTtcbiAgICAgICAgY29uc3QgYW5jZXN0b3JOYW1lID0gYW5jZXN0b3IgJiYgYW5jZXN0b3IubmFtZTtcbiAgICAgICAgY29uc3QgcGFyZW50UmVxdWlyZWQgPSBnZXRSZXF1aXJlZFBhcmVudChlbG0sIGFuY2VzdG9yTmFtZSk7XG4gICAgICAgIGlmIChwYXJlbnRSZXF1aXJlZCkge1xuICAgICAgICAgIGlmIChhbmNlc3Rvck5hbWUgPT09IHBhcmVudFJlcXVpcmVkKSB7XG4gICAgICAgICAgICBwYXJlbnRDYW5kaWRhdGUgPSBhbmNlc3RyeVswXTtcbiAgICAgICAgICAgIGFuY2VzdHJ5ID0gYW5jZXN0cnkuc2xpY2UoMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcmVudENhbmRpZGF0ZSA9IHBhcmVudFJlcXVpcmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChhbmNlc3Rvcikge1xuICAgICAgICAgIHBhcmVudENhbmRpZGF0ZSA9IGFuY2VzdHJ5WzBdO1xuICAgICAgICAgIGFuY2VzdHJ5ID0gYW5jZXN0cnkuc2xpY2UoMSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXNpYmxpbmdzKSB7XG4gICAgICAgICAgcmV0dXJuIGVsbTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyZW50Q2FuZGlkYXRlKSB7XG4gICAgICAgICAgcGFyZW50ID0gY3JlYXRlRWxlbWVudChwYXJlbnRDYW5kaWRhdGUpO1xuICAgICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChlbG0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaWJsaW5ncykge1xuICAgICAgICAgIGlmICghcGFyZW50KSB7XG4gICAgICAgICAgICBwYXJlbnQgPSBkb20uY3JlYXRlKCdkaXYnKTtcbiAgICAgICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChlbG0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBUb29scy5lYWNoKHNpYmxpbmdzLCBzaWJsaW5nID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNpYmxpbmdFbG0gPSBjcmVhdGVFbGVtZW50KHNpYmxpbmcpO1xuICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShzaWJsaW5nRWxtLCBlbG0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cmFwSW5IdG1sKHBhcmVudCwgYW5jZXN0cnksIHBhcmVudENhbmRpZGF0ZSAmJiBwYXJlbnRDYW5kaWRhdGUuc2libGluZ3MpO1xuICAgICAgfTtcbiAgICAgIGlmIChhbmNlc3RyeSAmJiBhbmNlc3RyeS5sZW5ndGgpIHtcbiAgICAgICAgaXRlbSA9IGFuY2VzdHJ5WzBdO1xuICAgICAgICBlbG0gPSBjcmVhdGVFbGVtZW50KGl0ZW0pO1xuICAgICAgICBmcmFnbWVudCA9IGRvbS5jcmVhdGUoJ2RpdicpO1xuICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZCh3cmFwSW5IdG1sKGVsbSwgYW5jZXN0cnkuc2xpY2UoMSksIGl0ZW0uc2libGluZ3MpKTtcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcGFyc2VTZWxlY3Rvckl0ZW0gPSBpdGVtID0+IHtcbiAgICAgIGxldCB0YWdOYW1lO1xuICAgICAgY29uc3Qgb2JqID0ge1xuICAgICAgICBjbGFzc2VzOiBbXSxcbiAgICAgICAgYXR0cnM6IHt9XG4gICAgICB9O1xuICAgICAgaXRlbSA9IG9iai5zZWxlY3RvciA9IFRvb2xzLnRyaW0oaXRlbSk7XG4gICAgICBpZiAoaXRlbSAhPT0gJyonKSB7XG4gICAgICAgIHRhZ05hbWUgPSBpdGVtLnJlcGxhY2UoLyg/OihbI1xcLl18Ojo/KShbXFx3XFwtXSspfChcXFspKFteXFxdXSspXFxdPykvZywgKCQwLCAkMSwgJDIsICQzLCAkNCkgPT4ge1xuICAgICAgICAgIHN3aXRjaCAoJDEpIHtcbiAgICAgICAgICBjYXNlICcjJzpcbiAgICAgICAgICAgIG9iai5hdHRycy5pZCA9ICQyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnLic6XG4gICAgICAgICAgICBvYmouY2xhc3Nlcy5wdXNoKCQyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJzonOlxuICAgICAgICAgICAgaWYgKFRvb2xzLmluQXJyYXkoJ2NoZWNrZWQgZGlzYWJsZWQgZW5hYmxlZCByZWFkLW9ubHkgcmVxdWlyZWQnLnNwbGl0KCcgJyksICQyKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgb2JqLmF0dHJzWyQyXSA9ICQyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgkMyA9PT0gJ1snKSB7XG4gICAgICAgICAgICBjb25zdCBtID0gJDQubWF0Y2goLyhbXFx3XFwtXSspKD86XFw9XFxcIihbXlxcXCJdKykpPy8pO1xuICAgICAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgICAgb2JqLmF0dHJzW21bMV1dID0gbVsyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIG9iai5uYW1lID0gdGFnTmFtZSB8fCAnZGl2JztcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcbiAgICBjb25zdCBwYXJzZVNlbGVjdG9yID0gc2VsZWN0b3IgPT4ge1xuICAgICAgaWYgKCFzZWxlY3RvciB8fCB0eXBlb2Ygc2VsZWN0b3IgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3Iuc3BsaXQoL1xccyosXFxzKi8pWzBdO1xuICAgICAgc2VsZWN0b3IgPSBzZWxlY3Rvci5yZXBsYWNlKC9cXHMqKH5cXCt8fnxcXCt8PilcXHMqL2csICckMScpO1xuICAgICAgcmV0dXJuIFRvb2xzLm1hcChzZWxlY3Rvci5zcGxpdCgvKD86PnxcXHMrKD8hW15cXFtcXF1dK1xcXSkpLyksIGl0ZW0gPT4ge1xuICAgICAgICBjb25zdCBzaWJsaW5ncyA9IFRvb2xzLm1hcChpdGVtLnNwbGl0KC8oPzp+XFwrfH58XFwrKS8pLCBwYXJzZVNlbGVjdG9ySXRlbSk7XG4gICAgICAgIGNvbnN0IG9iaiA9IHNpYmxpbmdzLnBvcCgpO1xuICAgICAgICBpZiAoc2libGluZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgb2JqLnNpYmxpbmdzID0gc2libGluZ3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH0pLnJldmVyc2UoKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldENzc1RleHQgPSAoZWRpdG9yLCBmb3JtYXQpID0+IHtcbiAgICAgIGxldCBuYW1lLCBwcmV2aWV3RnJhZztcbiAgICAgIGxldCBwcmV2aWV3Q3NzID0gJycsIHBhcmVudEZvbnRTaXplO1xuICAgICAgbGV0IHByZXZpZXdTdHlsZXMgPSBnZXRQcmV2aWV3U3R5bGVzKGVkaXRvcik7XG4gICAgICBpZiAocHJldmlld1N0eWxlcyA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVtb3ZlVmFycyA9IHZhbCA9PiB7XG4gICAgICAgIHJldHVybiB2YWwucmVwbGFjZSgvJShcXHcrKS9nLCAnJyk7XG4gICAgICB9O1xuICAgICAgaWYgKHR5cGVvZiBmb3JtYXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGZvcm1hdCA9IGVkaXRvci5mb3JtYXR0ZXIuZ2V0KGZvcm1hdCk7XG4gICAgICAgIGlmICghZm9ybWF0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdFswXTtcbiAgICAgIH1cbiAgICAgIGlmICgncHJldmlldycgaW4gZm9ybWF0KSB7XG4gICAgICAgIGNvbnN0IHByZXZpZXdPcHQgPSBnZXQkYShmb3JtYXQsICdwcmV2aWV3Jyk7XG4gICAgICAgIGlmIChpcyQyKHByZXZpZXdPcHQsIGZhbHNlKSkge1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aWV3U3R5bGVzID0gcHJldmlld09wdC5nZXRPcihwcmV2aWV3U3R5bGVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbmFtZSA9IGZvcm1hdC5ibG9jayB8fCBmb3JtYXQuaW5saW5lIHx8ICdzcGFuJztcbiAgICAgIGNvbnN0IGl0ZW1zID0gcGFyc2VTZWxlY3Rvcihmb3JtYXQuc2VsZWN0b3IpO1xuICAgICAgaWYgKGl0ZW1zLmxlbmd0aCkge1xuICAgICAgICBpZiAoIWl0ZW1zWzBdLm5hbWUpIHtcbiAgICAgICAgICBpdGVtc1swXS5uYW1lID0gbmFtZTtcbiAgICAgICAgfVxuICAgICAgICBuYW1lID0gZm9ybWF0LnNlbGVjdG9yO1xuICAgICAgICBwcmV2aWV3RnJhZyA9IHBhcnNlZFNlbGVjdG9yVG9IdG1sKGl0ZW1zLCBlZGl0b3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJldmlld0ZyYWcgPSBwYXJzZWRTZWxlY3RvclRvSHRtbChbbmFtZV0sIGVkaXRvcik7XG4gICAgICB9XG4gICAgICBjb25zdCBwcmV2aWV3RWxtID0gZG9tLnNlbGVjdChuYW1lLCBwcmV2aWV3RnJhZylbMF0gfHwgcHJldmlld0ZyYWcuZmlyc3RDaGlsZDtcbiAgICAgIGVhY2gkMyhmb3JtYXQuc3R5bGVzLCAodmFsdWUsIG5hbWUpID0+IHtcbiAgICAgICAgY29uc3QgbmV3VmFsdWUgPSByZW1vdmVWYXJzKHZhbHVlKTtcbiAgICAgICAgaWYgKG5ld1ZhbHVlKSB7XG4gICAgICAgICAgZG9tLnNldFN0eWxlKHByZXZpZXdFbG0sIG5hbWUsIG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBlYWNoJDMoZm9ybWF0LmF0dHJpYnV0ZXMsICh2YWx1ZSwgbmFtZSkgPT4ge1xuICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHJlbW92ZVZhcnModmFsdWUpO1xuICAgICAgICBpZiAobmV3VmFsdWUpIHtcbiAgICAgICAgICBkb20uc2V0QXR0cmliKHByZXZpZXdFbG0sIG5hbWUsIG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBlYWNoJDMoZm9ybWF0LmNsYXNzZXMsIHZhbHVlID0+IHtcbiAgICAgICAgY29uc3QgbmV3VmFsdWUgPSByZW1vdmVWYXJzKHZhbHVlKTtcbiAgICAgICAgaWYgKCFkb20uaGFzQ2xhc3MocHJldmlld0VsbSwgbmV3VmFsdWUpKSB7XG4gICAgICAgICAgZG9tLmFkZENsYXNzKHByZXZpZXdFbG0sIG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBlZGl0b3IuZGlzcGF0Y2goJ1ByZXZpZXdGb3JtYXRzJyk7XG4gICAgICBkb20uc2V0U3R5bGVzKHByZXZpZXdGcmFnLCB7XG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICBsZWZ0OiAtNjU1MzVcbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLmdldEJvZHkoKS5hcHBlbmRDaGlsZChwcmV2aWV3RnJhZyk7XG4gICAgICBwYXJlbnRGb250U2l6ZSA9IGRvbS5nZXRTdHlsZShlZGl0b3IuZ2V0Qm9keSgpLCAnZm9udFNpemUnLCB0cnVlKTtcbiAgICAgIHBhcmVudEZvbnRTaXplID0gL3B4JC8udGVzdChwYXJlbnRGb250U2l6ZSkgPyBwYXJzZUludChwYXJlbnRGb250U2l6ZSwgMTApIDogMDtcbiAgICAgIGVhY2gkMyhwcmV2aWV3U3R5bGVzLnNwbGl0KCcgJyksIG5hbWUgPT4ge1xuICAgICAgICBsZXQgdmFsdWUgPSBkb20uZ2V0U3R5bGUocHJldmlld0VsbSwgbmFtZSwgdHJ1ZSk7XG4gICAgICAgIGlmIChuYW1lID09PSAnYmFja2dyb3VuZC1jb2xvcicgJiYgL3RyYW5zcGFyZW50fHJnYmFcXHMqXFwoW14pXSssXFxzKjBcXCkvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgdmFsdWUgPSBkb20uZ2V0U3R5bGUoZWRpdG9yLmdldEJvZHkoKSwgbmFtZSwgdHJ1ZSk7XG4gICAgICAgICAgaWYgKHJnYmFUb0hleFN0cmluZyh2YWx1ZSkudG9Mb3dlckNhc2UoKSA9PT0gJyNmZmZmZmYnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lID09PSAnY29sb3InKSB7XG4gICAgICAgICAgaWYgKHJnYmFUb0hleFN0cmluZyh2YWx1ZSkudG9Mb3dlckNhc2UoKSA9PT0gJyMwMDAwMDAnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lID09PSAnZm9udC1zaXplJykge1xuICAgICAgICAgIGlmICgvZW18JSQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAocGFyZW50Rm9udFNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbnVtVmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKSAvICgvJSQvLnRlc3QodmFsdWUpID8gMTAwIDogMSk7XG4gICAgICAgICAgICB2YWx1ZSA9IG51bVZhbHVlICogcGFyZW50Rm9udFNpemUgKyAncHgnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZSA9PT0gJ2JvcmRlcicgJiYgdmFsdWUpIHtcbiAgICAgICAgICBwcmV2aWV3Q3NzICs9ICdwYWRkaW5nOjAgMnB4Oyc7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlld0NzcyArPSBuYW1lICsgJzonICsgdmFsdWUgKyAnOyc7XG4gICAgICB9KTtcbiAgICAgIGVkaXRvci5kaXNwYXRjaCgnQWZ0ZXJQcmV2aWV3Rm9ybWF0cycpO1xuICAgICAgZG9tLnJlbW92ZShwcmV2aWV3RnJhZyk7XG4gICAgICByZXR1cm4gcHJldmlld0NzcztcbiAgICB9O1xuXG4gICAgY29uc3Qgc2V0dXAkciA9IGVkaXRvciA9PiB7XG4gICAgICBlZGl0b3IuYWRkU2hvcnRjdXQoJ21ldGErYicsICcnLCAnQm9sZCcpO1xuICAgICAgZWRpdG9yLmFkZFNob3J0Y3V0KCdtZXRhK2knLCAnJywgJ0l0YWxpYycpO1xuICAgICAgZWRpdG9yLmFkZFNob3J0Y3V0KCdtZXRhK3UnLCAnJywgJ1VuZGVybGluZScpO1xuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gNjsgaSsrKSB7XG4gICAgICAgIGVkaXRvci5hZGRTaG9ydGN1dCgnYWNjZXNzKycgKyBpLCAnJywgW1xuICAgICAgICAgICdGb3JtYXRCbG9jaycsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgJ2gnICsgaVxuICAgICAgICBdKTtcbiAgICAgIH1cbiAgICAgIGVkaXRvci5hZGRTaG9ydGN1dCgnYWNjZXNzKzcnLCAnJywgW1xuICAgICAgICAnRm9ybWF0QmxvY2snLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgJ3AnXG4gICAgICBdKTtcbiAgICAgIGVkaXRvci5hZGRTaG9ydGN1dCgnYWNjZXNzKzgnLCAnJywgW1xuICAgICAgICAnRm9ybWF0QmxvY2snLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgJ2RpdidcbiAgICAgIF0pO1xuICAgICAgZWRpdG9yLmFkZFNob3J0Y3V0KCdhY2Nlc3MrOScsICcnLCBbXG4gICAgICAgICdGb3JtYXRCbG9jaycsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAnYWRkcmVzcydcbiAgICAgIF0pO1xuICAgIH07XG5cbiAgICBjb25zdCBGb3JtYXR0ZXIgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgZm9ybWF0cyA9IEZvcm1hdFJlZ2lzdHJ5KGVkaXRvcik7XG4gICAgICBjb25zdCBmb3JtYXRDaGFuZ2VTdGF0ZSA9IENlbGwobnVsbCk7XG4gICAgICBzZXR1cCRyKGVkaXRvcik7XG4gICAgICBzZXR1cCR1KGVkaXRvcik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBnZXQ6IGZvcm1hdHMuZ2V0LFxuICAgICAgICBoYXM6IGZvcm1hdHMuaGFzLFxuICAgICAgICByZWdpc3RlcjogZm9ybWF0cy5yZWdpc3RlcixcbiAgICAgICAgdW5yZWdpc3RlcjogZm9ybWF0cy51bnJlZ2lzdGVyLFxuICAgICAgICBhcHBseTogKG5hbWUsIHZhcnMsIG5vZGUpID0+IHtcbiAgICAgICAgICBhcHBseUZvcm1hdChlZGl0b3IsIG5hbWUsIHZhcnMsIG5vZGUpO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmU6IChuYW1lLCB2YXJzLCBub2RlLCBzaW1pbGFyKSA9PiB7XG4gICAgICAgICAgcmVtb3ZlRm9ybWF0KGVkaXRvciwgbmFtZSwgdmFycywgbm9kZSwgc2ltaWxhcik7XG4gICAgICAgIH0sXG4gICAgICAgIHRvZ2dsZTogKG5hbWUsIHZhcnMsIG5vZGUpID0+IHtcbiAgICAgICAgICB0b2dnbGVGb3JtYXQoZWRpdG9yLCBuYW1lLCB2YXJzLCBub2RlKTtcbiAgICAgICAgfSxcbiAgICAgICAgbWF0Y2g6IChuYW1lLCB2YXJzLCBub2RlLCBzaW1pbGFyKSA9PiBtYXRjaEZvcm1hdChlZGl0b3IsIG5hbWUsIHZhcnMsIG5vZGUsIHNpbWlsYXIpLFxuICAgICAgICBjbG9zZXN0OiBuYW1lcyA9PiBjbG9zZXN0Rm9ybWF0KGVkaXRvciwgbmFtZXMpLFxuICAgICAgICBtYXRjaEFsbDogKG5hbWVzLCB2YXJzKSA9PiBtYXRjaEFsbEZvcm1hdHMoZWRpdG9yLCBuYW1lcywgdmFycyksXG4gICAgICAgIG1hdGNoTm9kZTogKG5vZGUsIG5hbWUsIHZhcnMsIHNpbWlsYXIpID0+IG1hdGNoTm9kZUZvcm1hdChlZGl0b3IsIG5vZGUsIG5hbWUsIHZhcnMsIHNpbWlsYXIpLFxuICAgICAgICBjYW5BcHBseTogbmFtZSA9PiBjYW5BcHBseUZvcm1hdChlZGl0b3IsIG5hbWUpLFxuICAgICAgICBmb3JtYXRDaGFuZ2VkOiAoZm9ybWF0cywgY2FsbGJhY2ssIHNpbWlsYXIsIHZhcnMpID0+IGZvcm1hdENoYW5nZWQoZWRpdG9yLCBmb3JtYXRDaGFuZ2VTdGF0ZSwgZm9ybWF0cywgY2FsbGJhY2ssIHNpbWlsYXIsIHZhcnMpLFxuICAgICAgICBnZXRDc3NUZXh0OiBjdXJyeShnZXRDc3NUZXh0LCBlZGl0b3IpXG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCBzaG91bGRJZ25vcmVDb21tYW5kID0gY21kID0+IHtcbiAgICAgIHN3aXRjaCAoY21kLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgIGNhc2UgJ3VuZG8nOlxuICAgICAgY2FzZSAncmVkbyc6XG4gICAgICBjYXNlICdtY2Vmb2N1cyc6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcmVnaXN0ZXJFdmVudHMgPSAoZWRpdG9yLCB1bmRvTWFuYWdlciwgbG9ja3MpID0+IHtcbiAgICAgIGNvbnN0IGlzRmlyc3RUeXBlZENoYXJhY3RlciA9IENlbGwoZmFsc2UpO1xuICAgICAgY29uc3QgYWRkTm9uVHlwaW5nVW5kb0xldmVsID0gZSA9PiB7XG4gICAgICAgIHNldFR5cGluZyh1bmRvTWFuYWdlciwgZmFsc2UsIGxvY2tzKTtcbiAgICAgICAgdW5kb01hbmFnZXIuYWRkKHt9LCBlKTtcbiAgICAgIH07XG4gICAgICBlZGl0b3Iub24oJ2luaXQnLCAoKSA9PiB7XG4gICAgICAgIHVuZG9NYW5hZ2VyLmFkZCgpO1xuICAgICAgfSk7XG4gICAgICBlZGl0b3Iub24oJ0JlZm9yZUV4ZWNDb21tYW5kJywgZSA9PiB7XG4gICAgICAgIGNvbnN0IGNtZCA9IGUuY29tbWFuZDtcbiAgICAgICAgaWYgKCFzaG91bGRJZ25vcmVDb21tYW5kKGNtZCkpIHtcbiAgICAgICAgICBlbmRUeXBpbmcodW5kb01hbmFnZXIsIGxvY2tzKTtcbiAgICAgICAgICB1bmRvTWFuYWdlci5iZWZvcmVDaGFuZ2UoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBlZGl0b3Iub24oJ0V4ZWNDb21tYW5kJywgZSA9PiB7XG4gICAgICAgIGNvbnN0IGNtZCA9IGUuY29tbWFuZDtcbiAgICAgICAgaWYgKCFzaG91bGRJZ25vcmVDb21tYW5kKGNtZCkpIHtcbiAgICAgICAgICBhZGROb25UeXBpbmdVbmRvTGV2ZWwoZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLm9uKCdPYmplY3RSZXNpemVTdGFydCBjdXQnLCAoKSA9PiB7XG4gICAgICAgIHVuZG9NYW5hZ2VyLmJlZm9yZUNoYW5nZSgpO1xuICAgICAgfSk7XG4gICAgICBlZGl0b3Iub24oJ1NhdmVDb250ZW50IE9iamVjdFJlc2l6ZWQgYmx1cicsIGFkZE5vblR5cGluZ1VuZG9MZXZlbCk7XG4gICAgICBlZGl0b3Iub24oJ2RyYWdlbmQnLCBhZGROb25UeXBpbmdVbmRvTGV2ZWwpO1xuICAgICAgZWRpdG9yLm9uKCdrZXl1cCcsIGUgPT4ge1xuICAgICAgICBjb25zdCBrZXlDb2RlID0gZS5rZXlDb2RlO1xuICAgICAgICBpZiAoZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5Q29kZSA+PSAzMyAmJiBrZXlDb2RlIDw9IDM2IHx8IGtleUNvZGUgPj0gMzcgJiYga2V5Q29kZSA8PSA0MCB8fCBrZXlDb2RlID09PSA0NSB8fCBlLmN0cmxLZXkpIHtcbiAgICAgICAgICBhZGROb25UeXBpbmdVbmRvTGV2ZWwoKTtcbiAgICAgICAgICBlZGl0b3Iubm9kZUNoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5Q29kZSA9PT0gNDYgfHwga2V5Q29kZSA9PT0gOCkge1xuICAgICAgICAgIGVkaXRvci5ub2RlQ2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0ZpcnN0VHlwZWRDaGFyYWN0ZXIuZ2V0KCkgJiYgdW5kb01hbmFnZXIudHlwaW5nICYmIGlzRXEkMShjcmVhdGVGcm9tRWRpdG9yKGVkaXRvciksIHVuZG9NYW5hZ2VyLmRhdGFbMF0pID09PSBmYWxzZSkge1xuICAgICAgICAgIGlmIChlZGl0b3IuaXNEaXJ0eSgpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgZWRpdG9yLnNldERpcnR5KHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlZGl0b3IuZGlzcGF0Y2goJ1R5cGluZ1VuZG8nKTtcbiAgICAgICAgICBpc0ZpcnN0VHlwZWRDaGFyYWN0ZXIuc2V0KGZhbHNlKTtcbiAgICAgICAgICBlZGl0b3Iubm9kZUNoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBlZGl0b3Iub24oJ2tleWRvd24nLCBlID0+IHtcbiAgICAgICAgY29uc3Qga2V5Q29kZSA9IGUua2V5Q29kZTtcbiAgICAgICAgaWYgKGUuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleUNvZGUgPj0gMzMgJiYga2V5Q29kZSA8PSAzNiB8fCBrZXlDb2RlID49IDM3ICYmIGtleUNvZGUgPD0gNDAgfHwga2V5Q29kZSA9PT0gNDUpIHtcbiAgICAgICAgICBpZiAodW5kb01hbmFnZXIudHlwaW5nKSB7XG4gICAgICAgICAgICBhZGROb25UeXBpbmdVbmRvTGV2ZWwoZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtb2RLZXkgPSBlLmN0cmxLZXkgJiYgIWUuYWx0S2V5IHx8IGUubWV0YUtleTtcbiAgICAgICAgaWYgKChrZXlDb2RlIDwgMTYgfHwga2V5Q29kZSA+IDIwKSAmJiBrZXlDb2RlICE9PSAyMjQgJiYga2V5Q29kZSAhPT0gOTEgJiYgIXVuZG9NYW5hZ2VyLnR5cGluZyAmJiAhbW9kS2V5KSB7XG4gICAgICAgICAgdW5kb01hbmFnZXIuYmVmb3JlQ2hhbmdlKCk7XG4gICAgICAgICAgc2V0VHlwaW5nKHVuZG9NYW5hZ2VyLCB0cnVlLCBsb2Nrcyk7XG4gICAgICAgICAgdW5kb01hbmFnZXIuYWRkKHt9LCBlKTtcbiAgICAgICAgICBpc0ZpcnN0VHlwZWRDaGFyYWN0ZXIuc2V0KHRydWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGVkaXRvci5vbignbW91c2Vkb3duJywgZSA9PiB7XG4gICAgICAgIGlmICh1bmRvTWFuYWdlci50eXBpbmcpIHtcbiAgICAgICAgICBhZGROb25UeXBpbmdVbmRvTGV2ZWwoZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY29uc3QgaXNJbnNlcnRSZXBsYWNlbWVudFRleHQgPSBldmVudCA9PiBldmVudC5pbnB1dFR5cGUgPT09ICdpbnNlcnRSZXBsYWNlbWVudFRleHQnO1xuICAgICAgY29uc3QgaXNJbnNlcnRUZXh0RGF0YU51bGwgPSBldmVudCA9PiBldmVudC5pbnB1dFR5cGUgPT09ICdpbnNlcnRUZXh0JyAmJiBldmVudC5kYXRhID09PSBudWxsO1xuICAgICAgY29uc3QgaXNJbnNlcnRGcm9tUGFzdGVPckRyb3AgPSBldmVudCA9PiBldmVudC5pbnB1dFR5cGUgPT09ICdpbnNlcnRGcm9tUGFzdGUnIHx8IGV2ZW50LmlucHV0VHlwZSA9PT0gJ2luc2VydEZyb21Ecm9wJztcbiAgICAgIGVkaXRvci5vbignaW5wdXQnLCBlID0+IHtcbiAgICAgICAgaWYgKGUuaW5wdXRUeXBlICYmIChpc0luc2VydFJlcGxhY2VtZW50VGV4dChlKSB8fCBpc0luc2VydFRleHREYXRhTnVsbChlKSB8fCBpc0luc2VydEZyb21QYXN0ZU9yRHJvcChlKSkpIHtcbiAgICAgICAgICBhZGROb25UeXBpbmdVbmRvTGV2ZWwoZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLm9uKCdBZGRVbmRvIFVuZG8gUmVkbyBDbGVhclVuZG9zJywgZSA9PiB7XG4gICAgICAgIGlmICghZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICAgIGVkaXRvci5ub2RlQ2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGFkZEtleWJvYXJkU2hvcnRjdXRzID0gZWRpdG9yID0+IHtcbiAgICAgIGVkaXRvci5hZGRTaG9ydGN1dCgnbWV0YSt6JywgJycsICdVbmRvJyk7XG4gICAgICBlZGl0b3IuYWRkU2hvcnRjdXQoJ21ldGEreSxtZXRhK3NoaWZ0K3onLCAnJywgJ1JlZG8nKTtcbiAgICB9O1xuXG4gICAgY29uc3QgVW5kb01hbmFnZXIgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgYmVmb3JlQm9va21hcmsgPSB2YWx1ZSQyKCk7XG4gICAgICBjb25zdCBsb2NrcyA9IENlbGwoMCk7XG4gICAgICBjb25zdCBpbmRleCA9IENlbGwoMCk7XG4gICAgICBjb25zdCB1bmRvTWFuYWdlciA9IHtcbiAgICAgICAgZGF0YTogW10sXG4gICAgICAgIHR5cGluZzogZmFsc2UsXG4gICAgICAgIGJlZm9yZUNoYW5nZTogKCkgPT4ge1xuICAgICAgICAgIGJlZm9yZUNoYW5nZShlZGl0b3IsIGxvY2tzLCBiZWZvcmVCb29rbWFyayk7XG4gICAgICAgIH0sXG4gICAgICAgIGFkZDogKGxldmVsLCBldmVudCkgPT4ge1xuICAgICAgICAgIHJldHVybiBhZGRVbmRvTGV2ZWwoZWRpdG9yLCB1bmRvTWFuYWdlciwgaW5kZXgsIGxvY2tzLCBiZWZvcmVCb29rbWFyaywgbGV2ZWwsIGV2ZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5kbzogKCkgPT4ge1xuICAgICAgICAgIHJldHVybiB1bmRvKGVkaXRvciwgdW5kb01hbmFnZXIsIGxvY2tzLCBpbmRleCk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlZG86ICgpID0+IHtcbiAgICAgICAgICByZXR1cm4gcmVkbyhlZGl0b3IsIGluZGV4LCB1bmRvTWFuYWdlci5kYXRhKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xlYXI6ICgpID0+IHtcbiAgICAgICAgICBjbGVhcihlZGl0b3IsIHVuZG9NYW5hZ2VyLCBpbmRleCk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlc2V0OiAoKSA9PiB7XG4gICAgICAgICAgcmVzZXQoZWRpdG9yLCB1bmRvTWFuYWdlcik7XG4gICAgICAgIH0sXG4gICAgICAgIGhhc1VuZG86ICgpID0+IHtcbiAgICAgICAgICByZXR1cm4gaGFzVW5kbyhlZGl0b3IsIHVuZG9NYW5hZ2VyLCBpbmRleCk7XG4gICAgICAgIH0sXG4gICAgICAgIGhhc1JlZG86ICgpID0+IHtcbiAgICAgICAgICByZXR1cm4gaGFzUmVkbyhlZGl0b3IsIHVuZG9NYW5hZ2VyLCBpbmRleCk7XG4gICAgICAgIH0sXG4gICAgICAgIHRyYW5zYWN0OiBjYWxsYmFjayA9PiB7XG4gICAgICAgICAgcmV0dXJuIHRyYW5zYWN0KGVkaXRvciwgdW5kb01hbmFnZXIsIGxvY2tzLCBjYWxsYmFjayk7XG4gICAgICAgIH0sXG4gICAgICAgIGlnbm9yZTogY2FsbGJhY2sgPT4ge1xuICAgICAgICAgIGlnbm9yZShlZGl0b3IsIGxvY2tzLCBjYWxsYmFjayk7XG4gICAgICAgIH0sXG4gICAgICAgIGV4dHJhOiAoY2FsbGJhY2sxLCBjYWxsYmFjazIpID0+IHtcbiAgICAgICAgICBleHRyYShlZGl0b3IsIHVuZG9NYW5hZ2VyLCBpbmRleCwgY2FsbGJhY2sxLCBjYWxsYmFjazIpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKCFpc1J0YyhlZGl0b3IpKSB7XG4gICAgICAgIHJlZ2lzdGVyRXZlbnRzKGVkaXRvciwgdW5kb01hbmFnZXIsIGxvY2tzKTtcbiAgICAgIH1cbiAgICAgIGFkZEtleWJvYXJkU2hvcnRjdXRzKGVkaXRvcik7XG4gICAgICByZXR1cm4gdW5kb01hbmFnZXI7XG4gICAgfTtcblxuICAgIGNvbnN0IG5vblR5cGluZ0tleWNvZGVzID0gW1xuICAgICAgOSxcbiAgICAgIDI3LFxuICAgICAgVksuSE9NRSxcbiAgICAgIFZLLkVORCxcbiAgICAgIDE5LFxuICAgICAgMjAsXG4gICAgICA0NCxcbiAgICAgIDE0NCxcbiAgICAgIDE0NSxcbiAgICAgIDMzLFxuICAgICAgMzQsXG4gICAgICA0NSxcbiAgICAgIDE2LFxuICAgICAgMTcsXG4gICAgICAxOCxcbiAgICAgIDkxLFxuICAgICAgOTIsXG4gICAgICA5MyxcbiAgICAgIFZLLkRPV04sXG4gICAgICBWSy5VUCxcbiAgICAgIFZLLkxFRlQsXG4gICAgICBWSy5SSUdIVFxuICAgIF0uY29uY2F0KEVudi5icm93c2VyLmlzRmlyZWZveCgpID8gWzIyNF0gOiBbXSk7XG4gICAgY29uc3QgcGxhY2Vob2xkZXJBdHRyID0gJ2RhdGEtbWNlLXBsYWNlaG9sZGVyJztcbiAgICBjb25zdCBpc0tleWJvYXJkRXZlbnQgPSBlID0+IGUudHlwZSA9PT0gJ2tleWRvd24nIHx8IGUudHlwZSA9PT0gJ2tleXVwJztcbiAgICBjb25zdCBpc0RlbGV0ZUV2ZW50ID0gZSA9PiB7XG4gICAgICBjb25zdCBrZXlDb2RlID0gZS5rZXlDb2RlO1xuICAgICAgcmV0dXJuIGtleUNvZGUgPT09IFZLLkJBQ0tTUEFDRSB8fCBrZXlDb2RlID09PSBWSy5ERUxFVEU7XG4gICAgfTtcbiAgICBjb25zdCBpc05vblR5cGluZ0tleWJvYXJkRXZlbnQgPSBlID0+IHtcbiAgICAgIGlmIChpc0tleWJvYXJkRXZlbnQoZSkpIHtcbiAgICAgICAgY29uc3Qga2V5Q29kZSA9IGUua2V5Q29kZTtcbiAgICAgICAgcmV0dXJuICFpc0RlbGV0ZUV2ZW50KGUpICYmIChWSy5tZXRhS2V5UHJlc3NlZChlKSB8fCBlLmFsdEtleSB8fCBrZXlDb2RlID49IDExMiAmJiBrZXlDb2RlIDw9IDEyMyB8fCBjb250YWlucyQyKG5vblR5cGluZ0tleWNvZGVzLCBrZXlDb2RlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBpc1R5cGluZ0tleWJvYXJkRXZlbnQgPSBlID0+IGlzS2V5Ym9hcmRFdmVudChlKSAmJiAhKGlzRGVsZXRlRXZlbnQoZSkgfHwgZS50eXBlID09PSAna2V5dXAnICYmIGUua2V5Q29kZSA9PT0gMjI5KTtcbiAgICBjb25zdCBpc1Zpc3VhbGx5RW1wdHkgPSAoZG9tLCByb290RWxtLCBmb3JjZWRSb290QmxvY2spID0+IHtcbiAgICAgIGlmIChpc0VtcHR5JDIoU3VnYXJFbGVtZW50LmZyb21Eb20ocm9vdEVsbSksIGZhbHNlKSkge1xuICAgICAgICBjb25zdCBmaXJzdEVsZW1lbnQgPSByb290RWxtLmZpcnN0RWxlbWVudENoaWxkO1xuICAgICAgICBpZiAoIWZpcnN0RWxlbWVudCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGRvbS5nZXRTdHlsZShyb290RWxtLmZpcnN0RWxlbWVudENoaWxkLCAncGFkZGluZy1sZWZ0JykgfHwgZG9tLmdldFN0eWxlKHJvb3RFbG0uZmlyc3RFbGVtZW50Q2hpbGQsICdwYWRkaW5nLXJpZ2h0JykpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZvcmNlZFJvb3RCbG9jayA9PT0gZmlyc3RFbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHNldHVwJHEgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgZG9tID0gZWRpdG9yLmRvbTtcbiAgICAgIGNvbnN0IHJvb3RCbG9jayA9IGdldEZvcmNlZFJvb3RCbG9jayhlZGl0b3IpO1xuICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSBnZXRQbGFjZWhvbGRlcihlZGl0b3IpO1xuICAgICAgY29uc3QgdXBkYXRlUGxhY2Vob2xkZXIgPSAoZSwgaW5pdGlhbCkgPT4ge1xuICAgICAgICBpZiAoaXNOb25UeXBpbmdLZXlib2FyZEV2ZW50KGUpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJvZHkgPSBlZGl0b3IuZ2V0Qm9keSgpO1xuICAgICAgICBjb25zdCBzaG93UGxhY2Vob2xkZXIgPSBpc1R5cGluZ0tleWJvYXJkRXZlbnQoZSkgPyBmYWxzZSA6IGlzVmlzdWFsbHlFbXB0eShkb20sIGJvZHksIHJvb3RCbG9jayk7XG4gICAgICAgIGNvbnN0IGlzUGxhY2Vob2xkZXJTaG93biA9IGRvbS5nZXRBdHRyaWIoYm9keSwgcGxhY2Vob2xkZXJBdHRyKSAhPT0gJyc7XG4gICAgICAgIGlmIChpc1BsYWNlaG9sZGVyU2hvd24gIT09IHNob3dQbGFjZWhvbGRlciB8fCBpbml0aWFsKSB7XG4gICAgICAgICAgZG9tLnNldEF0dHJpYihib2R5LCBwbGFjZWhvbGRlckF0dHIsIHNob3dQbGFjZWhvbGRlciA/IHBsYWNlaG9sZGVyIDogbnVsbCk7XG4gICAgICAgICAgZG9tLnNldEF0dHJpYihib2R5LCAnYXJpYS1wbGFjZWhvbGRlcicsIHNob3dQbGFjZWhvbGRlciA/IHBsYWNlaG9sZGVyIDogbnVsbCk7XG4gICAgICAgICAgZmlyZVBsYWNlaG9sZGVyVG9nZ2xlKGVkaXRvciwgc2hvd1BsYWNlaG9sZGVyKTtcbiAgICAgICAgICBlZGl0b3Iub24oc2hvd1BsYWNlaG9sZGVyID8gJ2tleWRvd24nIDogJ2tleXVwJywgdXBkYXRlUGxhY2Vob2xkZXIpO1xuICAgICAgICAgIGVkaXRvci5vZmYoc2hvd1BsYWNlaG9sZGVyID8gJ2tleXVwJyA6ICdrZXlkb3duJywgdXBkYXRlUGxhY2Vob2xkZXIpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKHBsYWNlaG9sZGVyKSB7XG4gICAgICAgIGVkaXRvci5vbignaW5pdCcsIGUgPT4ge1xuICAgICAgICAgIHVwZGF0ZVBsYWNlaG9sZGVyKGUsIHRydWUpO1xuICAgICAgICAgIGVkaXRvci5vbignY2hhbmdlIFNldENvbnRlbnQgRXhlY0NvbW1hbmQnLCB1cGRhdGVQbGFjZWhvbGRlcik7XG4gICAgICAgICAgZWRpdG9yLm9uKCdwYXN0ZScsIGUgPT4gRGVsYXkuc2V0RWRpdG9yVGltZW91dChlZGl0b3IsICgpID0+IHVwZGF0ZVBsYWNlaG9sZGVyKGUpKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBzdHJvbmdSdGwgPSAvW1xcdTA1OTEtXFx1MDdGRlxcdUZCMUQtXFx1RkRGRlxcdUZFNzAtXFx1RkVGQ10vO1xuICAgIGNvbnN0IGhhc1N0cm9uZ1J0bCA9IHRleHQgPT4gc3Ryb25nUnRsLnRlc3QodGV4dCk7XG5cbiAgICBjb25zdCBpc0lubGluZVRhcmdldCA9IChlZGl0b3IsIGVsbSkgPT4gaXMkMShTdWdhckVsZW1lbnQuZnJvbURvbShlbG0pLCBnZXRJbmxpbmVCb3VuZGFyeVNlbGVjdG9yKGVkaXRvcikpO1xuICAgIGNvbnN0IGlzUnRsID0gZWxlbWVudCA9PiBET01VdGlscy5ET00uZ2V0U3R5bGUoZWxlbWVudCwgJ2RpcmVjdGlvbicsIHRydWUpID09PSAncnRsJyB8fCBoYXNTdHJvbmdSdGwoZWxlbWVudC50ZXh0Q29udGVudCk7XG4gICAgY29uc3QgZmluZElubGluZVBhcmVudHMgPSAoaXNJbmxpbmVUYXJnZXQsIHJvb3ROb2RlLCBwb3MpID0+IGZpbHRlciQ2KERPTVV0aWxzLkRPTS5nZXRQYXJlbnRzKHBvcy5jb250YWluZXIoKSwgJyonLCByb290Tm9kZSksIGlzSW5saW5lVGFyZ2V0KTtcbiAgICBjb25zdCBmaW5kUm9vdElubGluZSA9IChpc0lubGluZVRhcmdldCwgcm9vdE5vZGUsIHBvcykgPT4ge1xuICAgICAgY29uc3QgcGFyZW50cyA9IGZpbmRJbmxpbmVQYXJlbnRzKGlzSW5saW5lVGFyZ2V0LCByb290Tm9kZSwgcG9zKTtcbiAgICAgIHJldHVybiBPcHRpb25hbC5mcm9tKHBhcmVudHNbcGFyZW50cy5sZW5ndGggLSAxXSk7XG4gICAgfTtcbiAgICBjb25zdCBoYXNTYW1lUGFyZW50QmxvY2sgPSAocm9vdE5vZGUsIG5vZGUxLCBub2RlMikgPT4ge1xuICAgICAgY29uc3QgYmxvY2sxID0gZ2V0UGFyZW50QmxvY2skMyhub2RlMSwgcm9vdE5vZGUpO1xuICAgICAgY29uc3QgYmxvY2syID0gZ2V0UGFyZW50QmxvY2skMyhub2RlMiwgcm9vdE5vZGUpO1xuICAgICAgcmV0dXJuIGJsb2NrMSAmJiBibG9jazEgPT09IGJsb2NrMjtcbiAgICB9O1xuICAgIGNvbnN0IGlzQXRad3NwID0gcG9zID0+IGlzQmVmb3JlSW5saW5lKHBvcykgfHwgaXNBZnRlcklubGluZShwb3MpO1xuICAgIGNvbnN0IG5vcm1hbGl6ZVBvc2l0aW9uID0gKGZvcndhcmQsIHBvcykgPT4ge1xuICAgICAgaWYgKCFwb3MpIHtcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHBvcy5jb250YWluZXIoKSwgb2Zmc2V0ID0gcG9zLm9mZnNldCgpO1xuICAgICAgaWYgKGZvcndhcmQpIHtcbiAgICAgICAgaWYgKGlzQ2FyZXRDb250YWluZXJJbmxpbmUoY29udGFpbmVyKSkge1xuICAgICAgICAgIGlmIChpc1RleHQkOChjb250YWluZXIubmV4dFNpYmxpbmcpKSB7XG4gICAgICAgICAgICByZXR1cm4gQ2FyZXRQb3NpdGlvbihjb250YWluZXIubmV4dFNpYmxpbmcsIDApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gQ2FyZXRQb3NpdGlvbi5hZnRlcihjb250YWluZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gaXNCZWZvcmVJbmxpbmUocG9zKSA/IENhcmV0UG9zaXRpb24oY29udGFpbmVyLCBvZmZzZXQgKyAxKSA6IHBvcztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzQ2FyZXRDb250YWluZXJJbmxpbmUoY29udGFpbmVyKSkge1xuICAgICAgICAgIGlmIChpc1RleHQkOChjb250YWluZXIucHJldmlvdXNTaWJsaW5nKSkge1xuICAgICAgICAgICAgcmV0dXJuIENhcmV0UG9zaXRpb24oY29udGFpbmVyLnByZXZpb3VzU2libGluZywgY29udGFpbmVyLnByZXZpb3VzU2libGluZy5kYXRhLmxlbmd0aCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBDYXJldFBvc2l0aW9uLmJlZm9yZShjb250YWluZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gaXNBZnRlcklubGluZShwb3MpID8gQ2FyZXRQb3NpdGlvbihjb250YWluZXIsIG9mZnNldCAtIDEpIDogcG9zO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBub3JtYWxpemVGb3J3YXJkcyA9IGN1cnJ5KG5vcm1hbGl6ZVBvc2l0aW9uLCB0cnVlKTtcbiAgICBjb25zdCBub3JtYWxpemVCYWNrd2FyZHMgPSBjdXJyeShub3JtYWxpemVQb3NpdGlvbiwgZmFsc2UpO1xuXG4gICAgY29uc3QgZXhlY0NvbW1hbmRJZ25vcmVJbnB1dEV2ZW50cyA9IChlZGl0b3IsIGNvbW1hbmQpID0+IHtcbiAgICAgIGNvbnN0IGlucHV0QmxvY2tlciA9IGUgPT4gZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgIGVkaXRvci5vbignYmVmb3JlaW5wdXQgaW5wdXQnLCBpbnB1dEJsb2NrZXIsIHRydWUpO1xuICAgICAgZWRpdG9yLmdldERvYygpLmV4ZWNDb21tYW5kKGNvbW1hbmQpO1xuICAgICAgZWRpdG9yLm9mZignYmVmb3JlaW5wdXQgaW5wdXQnLCBpbnB1dEJsb2NrZXIpO1xuICAgIH07XG4gICAgY29uc3QgZXhlY0RlbGV0ZUNvbW1hbmQgPSBlZGl0b3IgPT4gZXhlY0NvbW1hbmRJZ25vcmVJbnB1dEV2ZW50cyhlZGl0b3IsICdEZWxldGUnKTtcbiAgICBjb25zdCBleGVjRm9yd2FyZERlbGV0ZUNvbW1hbmQgPSBlZGl0b3IgPT4gZXhlY0NvbW1hbmRJZ25vcmVJbnB1dEV2ZW50cyhlZGl0b3IsICdGb3J3YXJkRGVsZXRlJyk7XG4gICAgY29uc3QgaXNCZWZvcmVSb290ID0gcm9vdE5vZGUgPT4gZWxtID0+IGVxKHJvb3ROb2RlLCBTdWdhckVsZW1lbnQuZnJvbURvbShlbG0uZG9tLnBhcmVudE5vZGUpKTtcbiAgICBjb25zdCBpc1RleHRCbG9ja09yTGlzdEl0ZW0gPSBlbGVtZW50ID0+IGlzVGV4dEJsb2NrJDIoZWxlbWVudCkgfHwgaXNMaXN0SXRlbShlbGVtZW50KTtcbiAgICBjb25zdCBnZXRQYXJlbnRCbG9jayQyID0gKHJvb3ROb2RlLCBlbG0pID0+IHtcbiAgICAgIGlmIChjb250YWlucyhyb290Tm9kZSwgZWxtKSkge1xuICAgICAgICByZXR1cm4gY2xvc2VzdCQ0KGVsbSwgaXNUZXh0QmxvY2tPckxpc3RJdGVtLCBpc0JlZm9yZVJvb3Qocm9vdE5vZGUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBwbGFjZUNhcmV0SW5FbXB0eUJvZHkgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgYm9keSA9IGVkaXRvci5nZXRCb2R5KCk7XG4gICAgICBjb25zdCBub2RlID0gYm9keS5maXJzdENoaWxkICYmIGVkaXRvci5kb20uaXNCbG9jayhib2R5LmZpcnN0Q2hpbGQpID8gYm9keS5maXJzdENoaWxkIDogYm9keTtcbiAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2V0Q3Vyc29yTG9jYXRpb24obm9kZSwgMCk7XG4gICAgfTtcbiAgICBjb25zdCBwYWRkRW1wdHlCb2R5ID0gZWRpdG9yID0+IHtcbiAgICAgIGlmIChlZGl0b3IuZG9tLmlzRW1wdHkoZWRpdG9yLmdldEJvZHkoKSkpIHtcbiAgICAgICAgZWRpdG9yLnNldENvbnRlbnQoJycpO1xuICAgICAgICBwbGFjZUNhcmV0SW5FbXB0eUJvZHkoZWRpdG9yKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHdpbGxEZWxldGVMYXN0UG9zaXRpb25JbkVsZW1lbnQgPSAoZm9yd2FyZCwgZnJvbVBvcywgZWxtKSA9PiBsaWZ0MihmaXJzdFBvc2l0aW9uSW4oZWxtKSwgbGFzdFBvc2l0aW9uSW4oZWxtKSwgKGZpcnN0UG9zLCBsYXN0UG9zKSA9PiB7XG4gICAgICBjb25zdCBub3JtYWxpemVkRmlyc3RQb3MgPSBub3JtYWxpemVQb3NpdGlvbih0cnVlLCBmaXJzdFBvcyk7XG4gICAgICBjb25zdCBub3JtYWxpemVkTGFzdFBvcyA9IG5vcm1hbGl6ZVBvc2l0aW9uKGZhbHNlLCBsYXN0UG9zKTtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRGcm9tUG9zID0gbm9ybWFsaXplUG9zaXRpb24oZmFsc2UsIGZyb21Qb3MpO1xuICAgICAgaWYgKGZvcndhcmQpIHtcbiAgICAgICAgcmV0dXJuIG5leHRQb3NpdGlvbihlbG0sIG5vcm1hbGl6ZWRGcm9tUG9zKS5leGlzdHMobmV4dFBvcyA9PiBuZXh0UG9zLmlzRXF1YWwobm9ybWFsaXplZExhc3RQb3MpICYmIGZyb21Qb3MuaXNFcXVhbChub3JtYWxpemVkRmlyc3RQb3MpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwcmV2UG9zaXRpb24oZWxtLCBub3JtYWxpemVkRnJvbVBvcykuZXhpc3RzKHByZXZQb3MgPT4gcHJldlBvcy5pc0VxdWFsKG5vcm1hbGl6ZWRGaXJzdFBvcykgJiYgZnJvbVBvcy5pc0VxdWFsKG5vcm1hbGl6ZWRMYXN0UG9zKSk7XG4gICAgICB9XG4gICAgfSkuZ2V0T3IodHJ1ZSk7XG5cbiAgICBjb25zdCBibG9ja1Bvc2l0aW9uID0gKGJsb2NrLCBwb3NpdGlvbikgPT4gKHtcbiAgICAgIGJsb2NrLFxuICAgICAgcG9zaXRpb25cbiAgICB9KTtcbiAgICBjb25zdCBibG9ja0JvdW5kYXJ5ID0gKGZyb20sIHRvKSA9PiAoe1xuICAgICAgZnJvbSxcbiAgICAgIHRvXG4gICAgfSk7XG4gICAgY29uc3QgZ2V0QmxvY2tQb3NpdGlvbiA9IChyb290Tm9kZSwgcG9zKSA9PiB7XG4gICAgICBjb25zdCByb290RWxtID0gU3VnYXJFbGVtZW50LmZyb21Eb20ocm9vdE5vZGUpO1xuICAgICAgY29uc3QgY29udGFpbmVyRWxtID0gU3VnYXJFbGVtZW50LmZyb21Eb20ocG9zLmNvbnRhaW5lcigpKTtcbiAgICAgIHJldHVybiBnZXRQYXJlbnRCbG9jayQyKHJvb3RFbG0sIGNvbnRhaW5lckVsbSkubWFwKGJsb2NrID0+IGJsb2NrUG9zaXRpb24oYmxvY2ssIHBvcykpO1xuICAgIH07XG4gICAgY29uc3QgaXNEaWZmZXJlbnRCbG9ja3MgPSBibG9ja0JvdW5kYXJ5ID0+IGVxKGJsb2NrQm91bmRhcnkuZnJvbS5ibG9jaywgYmxvY2tCb3VuZGFyeS50by5ibG9jaykgPT09IGZhbHNlO1xuICAgIGNvbnN0IGhhc1NhbWVQYXJlbnQgPSBibG9ja0JvdW5kYXJ5ID0+IHBhcmVudChibG9ja0JvdW5kYXJ5LmZyb20uYmxvY2spLmJpbmQocGFyZW50MSA9PiBwYXJlbnQoYmxvY2tCb3VuZGFyeS50by5ibG9jaykuZmlsdGVyKHBhcmVudDIgPT4gZXEocGFyZW50MSwgcGFyZW50MikpKS5pc1NvbWUoKTtcbiAgICBjb25zdCBpc0VkaXRhYmxlJDIgPSBibG9ja0JvdW5kYXJ5ID0+IGlzQ29udGVudEVkaXRhYmxlRmFsc2UkYShibG9ja0JvdW5kYXJ5LmZyb20uYmxvY2suZG9tKSA9PT0gZmFsc2UgJiYgaXNDb250ZW50RWRpdGFibGVGYWxzZSRhKGJsb2NrQm91bmRhcnkudG8uYmxvY2suZG9tKSA9PT0gZmFsc2U7XG4gICAgY29uc3Qgc2tpcExhc3RCciA9IChyb290Tm9kZSwgZm9yd2FyZCwgYmxvY2tQb3NpdGlvbikgPT4ge1xuICAgICAgaWYgKGlzQnIkNShibG9ja1Bvc2l0aW9uLnBvc2l0aW9uLmdldE5vZGUoKSkgJiYgaXNFbXB0eSQyKGJsb2NrUG9zaXRpb24uYmxvY2spID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gcG9zaXRpb25JbihmYWxzZSwgYmxvY2tQb3NpdGlvbi5ibG9jay5kb20pLmJpbmQobGFzdFBvc2l0aW9uSW5CbG9jayA9PiB7XG4gICAgICAgICAgaWYgKGxhc3RQb3NpdGlvbkluQmxvY2suaXNFcXVhbChibG9ja1Bvc2l0aW9uLnBvc2l0aW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZyb21Qb3NpdGlvbihmb3J3YXJkLCByb290Tm9kZSwgbGFzdFBvc2l0aW9uSW5CbG9jaykuYmluZCh0byA9PiBnZXRCbG9ja1Bvc2l0aW9uKHJvb3ROb2RlLCB0bykpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZShibG9ja1Bvc2l0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLmdldE9yKGJsb2NrUG9zaXRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGJsb2NrUG9zaXRpb247XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCByZWFkRnJvbVJhbmdlID0gKHJvb3ROb2RlLCBmb3J3YXJkLCBybmcpID0+IHtcbiAgICAgIGNvbnN0IGZyb21CbG9ja1BvcyA9IGdldEJsb2NrUG9zaXRpb24ocm9vdE5vZGUsIENhcmV0UG9zaXRpb24uZnJvbVJhbmdlU3RhcnQocm5nKSk7XG4gICAgICBjb25zdCB0b0Jsb2NrUG9zID0gZnJvbUJsb2NrUG9zLmJpbmQoYmxvY2tQb3MgPT4gZnJvbVBvc2l0aW9uKGZvcndhcmQsIHJvb3ROb2RlLCBibG9ja1Bvcy5wb3NpdGlvbikuYmluZCh0byA9PiBnZXRCbG9ja1Bvc2l0aW9uKHJvb3ROb2RlLCB0bykubWFwKGJsb2NrUG9zID0+IHNraXBMYXN0QnIocm9vdE5vZGUsIGZvcndhcmQsIGJsb2NrUG9zKSkpKTtcbiAgICAgIHJldHVybiBsaWZ0Mihmcm9tQmxvY2tQb3MsIHRvQmxvY2tQb3MsIGJsb2NrQm91bmRhcnkpLmZpbHRlcihibG9ja0JvdW5kYXJ5ID0+IGlzRGlmZmVyZW50QmxvY2tzKGJsb2NrQm91bmRhcnkpICYmIGhhc1NhbWVQYXJlbnQoYmxvY2tCb3VuZGFyeSkgJiYgaXNFZGl0YWJsZSQyKGJsb2NrQm91bmRhcnkpKTtcbiAgICB9O1xuICAgIGNvbnN0IHJlYWQkMSA9IChyb290Tm9kZSwgZm9yd2FyZCwgcm5nKSA9PiBybmcuY29sbGFwc2VkID8gcmVhZEZyb21SYW5nZShyb290Tm9kZSwgZm9yd2FyZCwgcm5nKSA6IE9wdGlvbmFsLm5vbmUoKTtcblxuICAgIGNvbnN0IGdldENoaWxkcmVuVW50aWxCbG9ja0JvdW5kYXJ5ID0gYmxvY2sgPT4ge1xuICAgICAgY29uc3QgY2hpbGRyZW4kMSA9IGNoaWxkcmVuKGJsb2NrKTtcbiAgICAgIHJldHVybiBmaW5kSW5kZXgkMihjaGlsZHJlbiQxLCBpc0Jsb2NrJDIpLmZvbGQoY29uc3RhbnQoY2hpbGRyZW4kMSksIGluZGV4ID0+IGNoaWxkcmVuJDEuc2xpY2UoMCwgaW5kZXgpKTtcbiAgICB9O1xuICAgIGNvbnN0IGV4dHJhY3RDaGlsZHJlbiA9IGJsb2NrID0+IHtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gZ2V0Q2hpbGRyZW5VbnRpbEJsb2NrQm91bmRhcnkoYmxvY2spO1xuICAgICAgZWFjaCRnKGNoaWxkcmVuLCByZW1vdmUkNSk7XG4gICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgfTtcbiAgICBjb25zdCByZW1vdmVFbXB0eVJvb3QgPSAocm9vdE5vZGUsIGJsb2NrKSA9PiB7XG4gICAgICBjb25zdCBwYXJlbnRzID0gcGFyZW50c0FuZFNlbGYoYmxvY2ssIHJvb3ROb2RlKTtcbiAgICAgIHJldHVybiBmaW5kJDIocGFyZW50cy5yZXZlcnNlKCksIGVsZW1lbnQgPT4gaXNFbXB0eSQyKGVsZW1lbnQpKS5lYWNoKHJlbW92ZSQ1KTtcbiAgICB9O1xuICAgIGNvbnN0IGlzRW1wdHlCZWZvcmUgPSBlbCA9PiBmaWx0ZXIkNihwcmV2U2libGluZ3MoZWwpLCBlbCA9PiAhaXNFbXB0eSQyKGVsKSkubGVuZ3RoID09PSAwO1xuICAgIGNvbnN0IG5lc3RlZEJsb2NrTWVyZ2UgPSAocm9vdE5vZGUsIGZyb21CbG9jaywgdG9CbG9jaywgaW5zZXJ0aW9uUG9pbnQpID0+IHtcbiAgICAgIGlmIChpc0VtcHR5JDIodG9CbG9jaykpIHtcbiAgICAgICAgZmlsbFdpdGhQYWRkaW5nQnIodG9CbG9jayk7XG4gICAgICAgIHJldHVybiBmaXJzdFBvc2l0aW9uSW4odG9CbG9jay5kb20pO1xuICAgICAgfVxuICAgICAgaWYgKGlzRW1wdHlCZWZvcmUoaW5zZXJ0aW9uUG9pbnQpICYmIGlzRW1wdHkkMihmcm9tQmxvY2spKSB7XG4gICAgICAgIGJlZm9yZSQzKGluc2VydGlvblBvaW50LCBTdWdhckVsZW1lbnQuZnJvbVRhZygnYnInKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IHByZXZQb3NpdGlvbih0b0Jsb2NrLmRvbSwgQ2FyZXRQb3NpdGlvbi5iZWZvcmUoaW5zZXJ0aW9uUG9pbnQuZG9tKSk7XG4gICAgICBlYWNoJGcoZXh0cmFjdENoaWxkcmVuKGZyb21CbG9jayksIGNoaWxkID0+IHtcbiAgICAgICAgYmVmb3JlJDMoaW5zZXJ0aW9uUG9pbnQsIGNoaWxkKTtcbiAgICAgIH0pO1xuICAgICAgcmVtb3ZlRW1wdHlSb290KHJvb3ROb2RlLCBmcm9tQmxvY2spO1xuICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgIH07XG4gICAgY29uc3Qgc2lkZWxvbmdCbG9ja01lcmdlID0gKHJvb3ROb2RlLCBmcm9tQmxvY2ssIHRvQmxvY2spID0+IHtcbiAgICAgIGlmIChpc0VtcHR5JDIodG9CbG9jaykpIHtcbiAgICAgICAgcmVtb3ZlJDUodG9CbG9jayk7XG4gICAgICAgIGlmIChpc0VtcHR5JDIoZnJvbUJsb2NrKSkge1xuICAgICAgICAgIGZpbGxXaXRoUGFkZGluZ0JyKGZyb21CbG9jayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpcnN0UG9zaXRpb25Jbihmcm9tQmxvY2suZG9tKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gbGFzdFBvc2l0aW9uSW4odG9CbG9jay5kb20pO1xuICAgICAgZWFjaCRnKGV4dHJhY3RDaGlsZHJlbihmcm9tQmxvY2spLCBjaGlsZCA9PiB7XG4gICAgICAgIGFwcGVuZCQxKHRvQmxvY2ssIGNoaWxkKTtcbiAgICAgIH0pO1xuICAgICAgcmVtb3ZlRW1wdHlSb290KHJvb3ROb2RlLCBmcm9tQmxvY2spO1xuICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgIH07XG4gICAgY29uc3QgZmluZEluc2VydGlvblBvaW50ID0gKHRvQmxvY2ssIGJsb2NrKSA9PiB7XG4gICAgICBjb25zdCBwYXJlbnRzQW5kU2VsZiQxID0gcGFyZW50c0FuZFNlbGYoYmxvY2ssIHRvQmxvY2spO1xuICAgICAgcmV0dXJuIE9wdGlvbmFsLmZyb20ocGFyZW50c0FuZFNlbGYkMVtwYXJlbnRzQW5kU2VsZiQxLmxlbmd0aCAtIDFdKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldEluc2VydGlvblBvaW50ID0gKGZyb21CbG9jaywgdG9CbG9jaykgPT4gY29udGFpbnModG9CbG9jaywgZnJvbUJsb2NrKSA/IGZpbmRJbnNlcnRpb25Qb2ludCh0b0Jsb2NrLCBmcm9tQmxvY2spIDogT3B0aW9uYWwubm9uZSgpO1xuICAgIGNvbnN0IHRyaW1CciA9IChmaXJzdCwgYmxvY2spID0+IHtcbiAgICAgIHBvc2l0aW9uSW4oZmlyc3QsIGJsb2NrLmRvbSkubWFwKHBvc2l0aW9uID0+IHBvc2l0aW9uLmdldE5vZGUoKSkubWFwKFN1Z2FyRWxlbWVudC5mcm9tRG9tKS5maWx0ZXIoaXNCciQ0KS5lYWNoKHJlbW92ZSQ1KTtcbiAgICB9O1xuICAgIGNvbnN0IG1lcmdlQmxvY2tJbnRvID0gKHJvb3ROb2RlLCBmcm9tQmxvY2ssIHRvQmxvY2spID0+IHtcbiAgICAgIHRyaW1Ccih0cnVlLCBmcm9tQmxvY2spO1xuICAgICAgdHJpbUJyKGZhbHNlLCB0b0Jsb2NrKTtcbiAgICAgIHJldHVybiBnZXRJbnNlcnRpb25Qb2ludChmcm9tQmxvY2ssIHRvQmxvY2spLmZvbGQoY3Vycnkoc2lkZWxvbmdCbG9ja01lcmdlLCByb290Tm9kZSwgZnJvbUJsb2NrLCB0b0Jsb2NrKSwgY3VycnkobmVzdGVkQmxvY2tNZXJnZSwgcm9vdE5vZGUsIGZyb21CbG9jaywgdG9CbG9jaykpO1xuICAgIH07XG4gICAgY29uc3QgbWVyZ2VCbG9ja3MgPSAocm9vdE5vZGUsIGZvcndhcmQsIGJsb2NrMSwgYmxvY2syKSA9PiBmb3J3YXJkID8gbWVyZ2VCbG9ja0ludG8ocm9vdE5vZGUsIGJsb2NrMiwgYmxvY2sxKSA6IG1lcmdlQmxvY2tJbnRvKHJvb3ROb2RlLCBibG9jazEsIGJsb2NrMik7XG5cbiAgICBjb25zdCBiYWNrc3BhY2VEZWxldGUkOCA9IChlZGl0b3IsIGZvcndhcmQpID0+IHtcbiAgICAgIGNvbnN0IHJvb3ROb2RlID0gU3VnYXJFbGVtZW50LmZyb21Eb20oZWRpdG9yLmdldEJvZHkoKSk7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IHJlYWQkMShyb290Tm9kZS5kb20sIGZvcndhcmQsIGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCkpLm1hcChibG9ja0JvdW5kYXJ5ID0+ICgpID0+IHtcbiAgICAgICAgbWVyZ2VCbG9ja3Mocm9vdE5vZGUsIGZvcndhcmQsIGJsb2NrQm91bmRhcnkuZnJvbS5ibG9jaywgYmxvY2tCb3VuZGFyeS50by5ibG9jaykuZWFjaChwb3MgPT4ge1xuICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2V0Um5nKHBvcy50b1JhbmdlKCkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgIH07XG5cbiAgICBjb25zdCBkZWxldGVSYW5nZU1lcmdlQmxvY2tzID0gKHJvb3ROb2RlLCBzZWxlY3Rpb24pID0+IHtcbiAgICAgIGNvbnN0IHJuZyA9IHNlbGVjdGlvbi5nZXRSbmcoKTtcbiAgICAgIHJldHVybiBsaWZ0MihnZXRQYXJlbnRCbG9jayQyKHJvb3ROb2RlLCBTdWdhckVsZW1lbnQuZnJvbURvbShybmcuc3RhcnRDb250YWluZXIpKSwgZ2V0UGFyZW50QmxvY2skMihyb290Tm9kZSwgU3VnYXJFbGVtZW50LmZyb21Eb20ocm5nLmVuZENvbnRhaW5lcikpLCAoYmxvY2sxLCBibG9jazIpID0+IHtcbiAgICAgICAgaWYgKGVxKGJsb2NrMSwgYmxvY2syKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZSgoKSA9PiB7XG4gICAgICAgICAgICBybmcuZGVsZXRlQ29udGVudHMoKTtcbiAgICAgICAgICAgIG1lcmdlQmxvY2tzKHJvb3ROb2RlLCB0cnVlLCBibG9jazEsIGJsb2NrMikuZWFjaChwb3MgPT4ge1xuICAgICAgICAgICAgICBzZWxlY3Rpb24uc2V0Um5nKHBvcy50b1JhbmdlKCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgICAgfVxuICAgICAgfSkuZ2V0T3IoT3B0aW9uYWwubm9uZSgpKTtcbiAgICB9O1xuICAgIGNvbnN0IGlzUmF3Tm9kZUluVGFibGUgPSAocm9vdCwgcmF3Tm9kZSkgPT4ge1xuICAgICAgY29uc3Qgbm9kZSA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKHJhd05vZGUpO1xuICAgICAgY29uc3QgaXNSb290ID0gY3VycnkoZXEsIHJvb3QpO1xuICAgICAgcmV0dXJuIGFuY2VzdG9yJDMobm9kZSwgaXNUYWJsZUNlbGwkNCwgaXNSb290KS5pc1NvbWUoKTtcbiAgICB9O1xuICAgIGNvbnN0IGlzU2VsZWN0aW9uSW5UYWJsZSA9IChyb290LCBybmcpID0+IGlzUmF3Tm9kZUluVGFibGUocm9vdCwgcm5nLnN0YXJ0Q29udGFpbmVyKSB8fCBpc1Jhd05vZGVJblRhYmxlKHJvb3QsIHJuZy5lbmRDb250YWluZXIpO1xuICAgIGNvbnN0IGlzRXZlcnl0aGluZ1NlbGVjdGVkID0gKHJvb3QsIHJuZykgPT4ge1xuICAgICAgY29uc3Qgbm9QcmV2aW91cyA9IHByZXZQb3NpdGlvbihyb290LmRvbSwgQ2FyZXRQb3NpdGlvbi5mcm9tUmFuZ2VTdGFydChybmcpKS5pc05vbmUoKTtcbiAgICAgIGNvbnN0IG5vTmV4dCA9IG5leHRQb3NpdGlvbihyb290LmRvbSwgQ2FyZXRQb3NpdGlvbi5mcm9tUmFuZ2VFbmQocm5nKSkuaXNOb25lKCk7XG4gICAgICByZXR1cm4gIWlzU2VsZWN0aW9uSW5UYWJsZShyb290LCBybmcpICYmIG5vUHJldmlvdXMgJiYgbm9OZXh0O1xuICAgIH07XG4gICAgY29uc3QgZW1wdHlFZGl0b3IgPSBlZGl0b3IgPT4ge1xuICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoKCkgPT4ge1xuICAgICAgICBlZGl0b3Iuc2V0Q29udGVudCgnJyk7XG4gICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2V0Q3Vyc29yTG9jYXRpb24oKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgZGVsZXRlUmFuZ2UkMSA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCByb290Tm9kZSA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVkaXRvci5nZXRCb2R5KCkpO1xuICAgICAgY29uc3Qgcm5nID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKTtcbiAgICAgIHJldHVybiBpc0V2ZXJ5dGhpbmdTZWxlY3RlZChyb290Tm9kZSwgcm5nKSA/IGVtcHR5RWRpdG9yKGVkaXRvcikgOiBkZWxldGVSYW5nZU1lcmdlQmxvY2tzKHJvb3ROb2RlLCBlZGl0b3Iuc2VsZWN0aW9uKTtcbiAgICB9O1xuICAgIGNvbnN0IGJhY2tzcGFjZURlbGV0ZSQ3ID0gKGVkaXRvciwgX2ZvcndhcmQpID0+IGVkaXRvci5zZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSA/IE9wdGlvbmFsLm5vbmUoKSA6IGRlbGV0ZVJhbmdlJDEoZWRpdG9yKTtcblxuICAgIGNvbnN0IGlzQ29udGVudEVkaXRhYmxlVHJ1ZSQxID0gaXNDb250ZW50RWRpdGFibGVUcnVlJDQ7XG4gICAgY29uc3QgaXNDb250ZW50RWRpdGFibGVGYWxzZSQ0ID0gaXNDb250ZW50RWRpdGFibGVGYWxzZSRhO1xuICAgIGNvbnN0IHNob3dDYXJldCA9IChkaXJlY3Rpb24sIGVkaXRvciwgbm9kZSwgYmVmb3JlLCBzY3JvbGxJbnRvVmlldykgPT4gT3B0aW9uYWwuZnJvbShlZGl0b3IuX3NlbGVjdGlvbk92ZXJyaWRlcy5zaG93Q2FyZXQoZGlyZWN0aW9uLCBub2RlLCBiZWZvcmUsIHNjcm9sbEludG9WaWV3KSk7XG4gICAgY29uc3QgZ2V0Tm9kZVJhbmdlID0gbm9kZSA9PiB7XG4gICAgICBjb25zdCBybmcgPSBub2RlLm93bmVyRG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgIHJuZy5zZWxlY3ROb2RlKG5vZGUpO1xuICAgICAgcmV0dXJuIHJuZztcbiAgICB9O1xuICAgIGNvbnN0IHNlbGVjdE5vZGUgPSAoZWRpdG9yLCBub2RlKSA9PiB7XG4gICAgICBjb25zdCBlID0gZWRpdG9yLmRpc3BhdGNoKCdCZWZvcmVPYmplY3RTZWxlY3RlZCcsIHsgdGFyZ2V0OiBub2RlIH0pO1xuICAgICAgaWYgKGUuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKGdldE5vZGVSYW5nZShub2RlKSk7XG4gICAgfTtcbiAgICBjb25zdCByZW5kZXJDYXJldEF0UmFuZ2UgPSAoZWRpdG9yLCByYW5nZSwgc2Nyb2xsSW50b1ZpZXcpID0+IHtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRSYW5nZSA9IG5vcm1hbGl6ZVJhbmdlKDEsIGVkaXRvci5nZXRCb2R5KCksIHJhbmdlKTtcbiAgICAgIGNvbnN0IGNhcmV0UG9zaXRpb24gPSBDYXJldFBvc2l0aW9uLmZyb21SYW5nZVN0YXJ0KG5vcm1hbGl6ZWRSYW5nZSk7XG4gICAgICBjb25zdCBjYXJldFBvc2l0aW9uTm9kZSA9IGNhcmV0UG9zaXRpb24uZ2V0Tm9kZSgpO1xuICAgICAgaWYgKGlzSW5saW5lRmFrZUNhcmV0VGFyZ2V0KGNhcmV0UG9zaXRpb25Ob2RlKSkge1xuICAgICAgICByZXR1cm4gc2hvd0NhcmV0KDEsIGVkaXRvciwgY2FyZXRQb3NpdGlvbk5vZGUsICFjYXJldFBvc2l0aW9uLmlzQXRFbmQoKSwgZmFsc2UpO1xuICAgICAgfVxuICAgICAgY29uc3QgY2FyZXRQb3NpdGlvbkJlZm9yZU5vZGUgPSBjYXJldFBvc2l0aW9uLmdldE5vZGUodHJ1ZSk7XG4gICAgICBpZiAoaXNJbmxpbmVGYWtlQ2FyZXRUYXJnZXQoY2FyZXRQb3NpdGlvbkJlZm9yZU5vZGUpKSB7XG4gICAgICAgIHJldHVybiBzaG93Q2FyZXQoMSwgZWRpdG9yLCBjYXJldFBvc2l0aW9uQmVmb3JlTm9kZSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNlUm9vdCA9IGVkaXRvci5kb20uZ2V0UGFyZW50KGNhcmV0UG9zaXRpb24uZ2V0Tm9kZSgpLCBub2RlID0+IGlzQ29udGVudEVkaXRhYmxlRmFsc2UkNChub2RlKSB8fCBpc0NvbnRlbnRFZGl0YWJsZVRydWUkMShub2RlKSk7XG4gICAgICBpZiAoaXNJbmxpbmVGYWtlQ2FyZXRUYXJnZXQoY2VSb290KSkge1xuICAgICAgICByZXR1cm4gc2hvd0NhcmV0KDEsIGVkaXRvciwgY2VSb290LCBmYWxzZSwgc2Nyb2xsSW50b1ZpZXcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICB9O1xuICAgIGNvbnN0IHJlbmRlclJhbmdlQ2FyZXQgPSAoZWRpdG9yLCByYW5nZSwgc2Nyb2xsSW50b1ZpZXcpID0+IHJhbmdlLmNvbGxhcHNlZCA/IHJlbmRlckNhcmV0QXRSYW5nZShlZGl0b3IsIHJhbmdlLCBzY3JvbGxJbnRvVmlldykuZ2V0T3IocmFuZ2UpIDogcmFuZ2U7XG5cbiAgICBjb25zdCBpc0JlZm9yZUJvdW5kYXJ5ID0gcG9zID0+IGlzQmVmb3JlQ29udGVudEVkaXRhYmxlRmFsc2UocG9zKSB8fCBpc0JlZm9yZU1lZGlhKHBvcyk7XG4gICAgY29uc3QgaXNBZnRlckJvdW5kYXJ5ID0gcG9zID0+IGlzQWZ0ZXJDb250ZW50RWRpdGFibGVGYWxzZShwb3MpIHx8IGlzQWZ0ZXJNZWRpYShwb3MpO1xuICAgIGNvbnN0IHRyaW1FbXB0eVRleHROb2RlID0gKGRvbSwgbm9kZSkgPT4ge1xuICAgICAgaWYgKGlzVGV4dCQ4KG5vZGUpICYmIG5vZGUuZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZG9tLnJlbW92ZShub2RlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGRlbGV0ZUNvbnRlbnRBbmRTaG93Q2FyZXQgPSAoZWRpdG9yLCByYW5nZSwgbm9kZSwgZGlyZWN0aW9uLCBmb3J3YXJkLCBwZWVrQ2FyZXRQb3NpdGlvbikgPT4ge1xuICAgICAgc2hvd0NhcmV0KGRpcmVjdGlvbiwgZWRpdG9yLCBwZWVrQ2FyZXRQb3NpdGlvbi5nZXROb2RlKCFmb3J3YXJkKSwgZm9yd2FyZCwgdHJ1ZSkuZWFjaChjYXJldFJhbmdlID0+IHtcbiAgICAgICAgaWYgKHJhbmdlLmNvbGxhcHNlZCkge1xuICAgICAgICAgIGNvbnN0IGRlbGV0ZVJhbmdlID0gcmFuZ2UuY2xvbmVSYW5nZSgpO1xuICAgICAgICAgIGlmIChmb3J3YXJkKSB7XG4gICAgICAgICAgICBkZWxldGVSYW5nZS5zZXRFbmQoY2FyZXRSYW5nZS5zdGFydENvbnRhaW5lciwgY2FyZXRSYW5nZS5zdGFydE9mZnNldCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZVJhbmdlLnNldFN0YXJ0KGNhcmV0UmFuZ2UuZW5kQ29udGFpbmVyLCBjYXJldFJhbmdlLmVuZE9mZnNldCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlbGV0ZVJhbmdlLmRlbGV0ZUNvbnRlbnRzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmFuZ2UuZGVsZXRlQ29udGVudHMoKTtcbiAgICAgICAgfVxuICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNldFJuZyhjYXJldFJhbmdlKTtcbiAgICAgIH0pO1xuICAgICAgdHJpbUVtcHR5VGV4dE5vZGUoZWRpdG9yLmRvbSwgbm9kZSk7XG4gICAgfTtcbiAgICBjb25zdCBkZWxldGVCb3VuZGFyeVRleHQgPSAoZWRpdG9yLCBmb3J3YXJkKSA9PiB7XG4gICAgICBjb25zdCByYW5nZSA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCk7XG4gICAgICBpZiAoIWlzVGV4dCQ4KHJhbmdlLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyKSkge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgfVxuICAgICAgY29uc3QgZGlyZWN0aW9uID0gZm9yd2FyZCA/IEhEaXJlY3Rpb24uRm9yd2FyZHMgOiBIRGlyZWN0aW9uLkJhY2t3YXJkcztcbiAgICAgIGNvbnN0IGNhcmV0V2Fsa2VyID0gQ2FyZXRXYWxrZXIoZWRpdG9yLmdldEJvZHkoKSk7XG4gICAgICBjb25zdCBnZXROZXh0UG9zRm4gPSBjdXJyeShnZXRWaXN1YWxDYXJldFBvc2l0aW9uLCBmb3J3YXJkID8gY2FyZXRXYWxrZXIubmV4dCA6IGNhcmV0V2Fsa2VyLnByZXYpO1xuICAgICAgY29uc3QgaXNCZWZvcmVGbiA9IGZvcndhcmQgPyBpc0JlZm9yZUJvdW5kYXJ5IDogaXNBZnRlckJvdW5kYXJ5O1xuICAgICAgY29uc3QgY2FyZXRQb3NpdGlvbiA9IGdldE5vcm1hbGl6ZWRSYW5nZUVuZFBvaW50KGRpcmVjdGlvbiwgZWRpdG9yLmdldEJvZHkoKSwgcmFuZ2UpO1xuICAgICAgY29uc3QgbmV4dENhcmV0UG9zaXRpb24gPSBub3JtYWxpemVQb3NpdGlvbihmb3J3YXJkLCBnZXROZXh0UG9zRm4oY2FyZXRQb3NpdGlvbikpO1xuICAgICAgaWYgKCFuZXh0Q2FyZXRQb3NpdGlvbiB8fCAhaXNNb3ZlSW5zaWRlU2FtZUJsb2NrKGNhcmV0UG9zaXRpb24sIG5leHRDYXJldFBvc2l0aW9uKSkge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgfSBlbHNlIGlmIChpc0JlZm9yZUZuKG5leHRDYXJldFBvc2l0aW9uKSkge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZSgoKSA9PiBkZWxldGVDb250ZW50QW5kU2hvd0NhcmV0KGVkaXRvciwgcmFuZ2UsIGNhcmV0UG9zaXRpb24uZ2V0Tm9kZSgpLCBkaXJlY3Rpb24sIGZvcndhcmQsIG5leHRDYXJldFBvc2l0aW9uKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBwZWVrQ2FyZXRQb3NpdGlvbiA9IGdldE5leHRQb3NGbihuZXh0Q2FyZXRQb3NpdGlvbik7XG4gICAgICBpZiAocGVla0NhcmV0UG9zaXRpb24gJiYgaXNCZWZvcmVGbihwZWVrQ2FyZXRQb3NpdGlvbikpIHtcbiAgICAgICAgaWYgKGlzTW92ZUluc2lkZVNhbWVCbG9jayhuZXh0Q2FyZXRQb3NpdGlvbiwgcGVla0NhcmV0UG9zaXRpb24pKSB7XG4gICAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoKCkgPT4gZGVsZXRlQ29udGVudEFuZFNob3dDYXJldChlZGl0b3IsIHJhbmdlLCBjYXJldFBvc2l0aW9uLmdldE5vZGUoKSwgZGlyZWN0aW9uLCBmb3J3YXJkLCBwZWVrQ2FyZXRQb3NpdGlvbikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgIH07XG4gICAgY29uc3QgYmFja3NwYWNlRGVsZXRlJDYgPSAoZWRpdG9yLCBmb3J3YXJkKSA9PiBkZWxldGVCb3VuZGFyeVRleHQoZWRpdG9yLCBmb3J3YXJkKTtcblxuICAgIGNvbnN0IGlzQ29tcG91bmRFbGVtZW50ID0gbm9kZSA9PiBpc1RhYmxlQ2VsbCQ0KFN1Z2FyRWxlbWVudC5mcm9tRG9tKG5vZGUpKSB8fCBpc0xpc3RJdGVtKFN1Z2FyRWxlbWVudC5mcm9tRG9tKG5vZGUpKTtcbiAgICBjb25zdCBEZWxldGVBY3Rpb24gPSBBZHQuZ2VuZXJhdGUoW1xuICAgICAgeyByZW1vdmU6IFsnZWxlbWVudCddIH0sXG4gICAgICB7IG1vdmVUb0VsZW1lbnQ6IFsnZWxlbWVudCddIH0sXG4gICAgICB7IG1vdmVUb1Bvc2l0aW9uOiBbJ3Bvc2l0aW9uJ10gfVxuICAgIF0pO1xuICAgIGNvbnN0IGlzQXRDb250ZW50RWRpdGFibGVCbG9ja0NhcmV0ID0gKGZvcndhcmQsIGZyb20pID0+IHtcbiAgICAgIGNvbnN0IGVsbSA9IGZyb20uZ2V0Tm9kZShmb3J3YXJkID09PSBmYWxzZSk7XG4gICAgICBjb25zdCBjYXJldExvY2F0aW9uID0gZm9yd2FyZCA/ICdhZnRlcicgOiAnYmVmb3JlJztcbiAgICAgIHJldHVybiBpc0VsZW1lbnQkNihlbG0pICYmIGVsbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtbWNlLWNhcmV0JykgPT09IGNhcmV0TG9jYXRpb247XG4gICAgfTtcbiAgICBjb25zdCBpc0RlbGV0ZUZyb21DZWZEaWZmZXJlbnRCbG9ja3MgPSAocm9vdCwgZm9yd2FyZCwgZnJvbSwgdG8pID0+IHtcbiAgICAgIGNvbnN0IGluU2FtZUJsb2NrID0gZWxtID0+IGlzSW5saW5lJDEoU3VnYXJFbGVtZW50LmZyb21Eb20oZWxtKSkgJiYgIWlzSW5TYW1lQmxvY2soZnJvbSwgdG8sIHJvb3QpO1xuICAgICAgcmV0dXJuIGdldFJlbGF0aXZlQ2VmRWxtKCFmb3J3YXJkLCBmcm9tKS5mb2xkKCgpID0+IGdldFJlbGF0aXZlQ2VmRWxtKGZvcndhcmQsIHRvKS5mb2xkKG5ldmVyLCBpblNhbWVCbG9jayksIGluU2FtZUJsb2NrKTtcbiAgICB9O1xuICAgIGNvbnN0IGRlbGV0ZUVtcHR5QmxvY2tPck1vdmVUb0NlZiA9IChyb290LCBmb3J3YXJkLCBmcm9tLCB0bykgPT4ge1xuICAgICAgY29uc3QgdG9DZWZFbG0gPSB0by5nZXROb2RlKGZvcndhcmQgPT09IGZhbHNlKTtcbiAgICAgIHJldHVybiBnZXRQYXJlbnRCbG9jayQyKFN1Z2FyRWxlbWVudC5mcm9tRG9tKHJvb3QpLCBTdWdhckVsZW1lbnQuZnJvbURvbShmcm9tLmdldE5vZGUoKSkpLm1hcChibG9ja0VsbSA9PiBpc0VtcHR5JDIoYmxvY2tFbG0pID8gRGVsZXRlQWN0aW9uLnJlbW92ZShibG9ja0VsbS5kb20pIDogRGVsZXRlQWN0aW9uLm1vdmVUb0VsZW1lbnQodG9DZWZFbG0pKS5vclRodW5rKCgpID0+IE9wdGlvbmFsLnNvbWUoRGVsZXRlQWN0aW9uLm1vdmVUb0VsZW1lbnQodG9DZWZFbG0pKSk7XG4gICAgfTtcbiAgICBjb25zdCBmaW5kQ2VmUG9zaXRpb24gPSAocm9vdCwgZm9yd2FyZCwgZnJvbSkgPT4gZnJvbVBvc2l0aW9uKGZvcndhcmQsIHJvb3QsIGZyb20pLmJpbmQodG8gPT4ge1xuICAgICAgaWYgKGlzQ29tcG91bmRFbGVtZW50KHRvLmdldE5vZGUoKSkpIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWxldGVGcm9tQ2VmRGlmZmVyZW50QmxvY2tzKHJvb3QsIGZvcndhcmQsIGZyb20sIHRvKSkge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgfSBlbHNlIGlmIChmb3J3YXJkICYmIGlzQ29udGVudEVkaXRhYmxlRmFsc2UkYSh0by5nZXROb2RlKCkpKSB7XG4gICAgICAgIHJldHVybiBkZWxldGVFbXB0eUJsb2NrT3JNb3ZlVG9DZWYocm9vdCwgZm9yd2FyZCwgZnJvbSwgdG8pO1xuICAgICAgfSBlbHNlIGlmIChmb3J3YXJkID09PSBmYWxzZSAmJiBpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJGEodG8uZ2V0Tm9kZSh0cnVlKSkpIHtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZUVtcHR5QmxvY2tPck1vdmVUb0NlZihyb290LCBmb3J3YXJkLCBmcm9tLCB0byk7XG4gICAgICB9IGVsc2UgaWYgKGZvcndhcmQgJiYgaXNBZnRlckNvbnRlbnRFZGl0YWJsZUZhbHNlKGZyb20pKSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKERlbGV0ZUFjdGlvbi5tb3ZlVG9Qb3NpdGlvbih0bykpO1xuICAgICAgfSBlbHNlIGlmIChmb3J3YXJkID09PSBmYWxzZSAmJiBpc0JlZm9yZUNvbnRlbnRFZGl0YWJsZUZhbHNlKGZyb20pKSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKERlbGV0ZUFjdGlvbi5tb3ZlVG9Qb3NpdGlvbih0bykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBnZXRDb250ZW50RWRpdGFibGVCbG9ja0FjdGlvbiA9IChmb3J3YXJkLCBlbG0pID0+IHtcbiAgICAgIGlmIChmb3J3YXJkICYmIGlzQ29udGVudEVkaXRhYmxlRmFsc2UkYShlbG0ubmV4dFNpYmxpbmcpKSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKERlbGV0ZUFjdGlvbi5tb3ZlVG9FbGVtZW50KGVsbS5uZXh0U2libGluZykpO1xuICAgICAgfSBlbHNlIGlmIChmb3J3YXJkID09PSBmYWxzZSAmJiBpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJGEoZWxtLnByZXZpb3VzU2libGluZykpIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoRGVsZXRlQWN0aW9uLm1vdmVUb0VsZW1lbnQoZWxtLnByZXZpb3VzU2libGluZykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHNraXBNb3ZlVG9BY3Rpb25Gcm9tSW5saW5lQ2VmVG9Db250ZW50ID0gKHJvb3QsIGZyb20sIGRlbGV0ZUFjdGlvbikgPT4gZGVsZXRlQWN0aW9uLmZvbGQoZWxtID0+IE9wdGlvbmFsLnNvbWUoRGVsZXRlQWN0aW9uLnJlbW92ZShlbG0pKSwgZWxtID0+IE9wdGlvbmFsLnNvbWUoRGVsZXRlQWN0aW9uLm1vdmVUb0VsZW1lbnQoZWxtKSksIHRvID0+IHtcbiAgICAgIGlmIChpc0luU2FtZUJsb2NrKGZyb20sIHRvLCByb290KSkge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoRGVsZXRlQWN0aW9uLm1vdmVUb1Bvc2l0aW9uKHRvKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgZ2V0Q29udGVudEVkaXRhYmxlQWN0aW9uID0gKHJvb3QsIGZvcndhcmQsIGZyb20pID0+IHtcbiAgICAgIGlmIChpc0F0Q29udGVudEVkaXRhYmxlQmxvY2tDYXJldChmb3J3YXJkLCBmcm9tKSkge1xuICAgICAgICByZXR1cm4gZ2V0Q29udGVudEVkaXRhYmxlQmxvY2tBY3Rpb24oZm9yd2FyZCwgZnJvbS5nZXROb2RlKGZvcndhcmQgPT09IGZhbHNlKSkuZm9sZCgoKSA9PiBmaW5kQ2VmUG9zaXRpb24ocm9vdCwgZm9yd2FyZCwgZnJvbSksIE9wdGlvbmFsLnNvbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZpbmRDZWZQb3NpdGlvbihyb290LCBmb3J3YXJkLCBmcm9tKS5iaW5kKGRlbGV0ZUFjdGlvbiA9PiBza2lwTW92ZVRvQWN0aW9uRnJvbUlubGluZUNlZlRvQ29udGVudChyb290LCBmcm9tLCBkZWxldGVBY3Rpb24pKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlYWQgPSAocm9vdCwgZm9yd2FyZCwgcm5nKSA9PiB7XG4gICAgICBjb25zdCBub3JtYWxpemVkUmFuZ2UgPSBub3JtYWxpemVSYW5nZShmb3J3YXJkID8gMSA6IC0xLCByb290LCBybmcpO1xuICAgICAgY29uc3QgZnJvbSA9IENhcmV0UG9zaXRpb24uZnJvbVJhbmdlU3RhcnQobm9ybWFsaXplZFJhbmdlKTtcbiAgICAgIGNvbnN0IHJvb3RFbGVtZW50ID0gU3VnYXJFbGVtZW50LmZyb21Eb20ocm9vdCk7XG4gICAgICBpZiAoZm9yd2FyZCA9PT0gZmFsc2UgJiYgaXNBZnRlckNvbnRlbnRFZGl0YWJsZUZhbHNlKGZyb20pKSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKERlbGV0ZUFjdGlvbi5yZW1vdmUoZnJvbS5nZXROb2RlKHRydWUpKSk7XG4gICAgICB9IGVsc2UgaWYgKGZvcndhcmQgJiYgaXNCZWZvcmVDb250ZW50RWRpdGFibGVGYWxzZShmcm9tKSkge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZShEZWxldGVBY3Rpb24ucmVtb3ZlKGZyb20uZ2V0Tm9kZSgpKSk7XG4gICAgICB9IGVsc2UgaWYgKGZvcndhcmQgPT09IGZhbHNlICYmIGlzQmVmb3JlQ29udGVudEVkaXRhYmxlRmFsc2UoZnJvbSkgJiYgaXNBZnRlckJyKHJvb3RFbGVtZW50LCBmcm9tKSkge1xuICAgICAgICByZXR1cm4gZmluZFByZXZpb3VzQnIocm9vdEVsZW1lbnQsIGZyb20pLm1hcChiciA9PiBEZWxldGVBY3Rpb24ucmVtb3ZlKGJyLmdldE5vZGUoKSkpO1xuICAgICAgfSBlbHNlIGlmIChmb3J3YXJkICYmIGlzQWZ0ZXJDb250ZW50RWRpdGFibGVGYWxzZShmcm9tKSAmJiBpc0JlZm9yZUJyJDEocm9vdEVsZW1lbnQsIGZyb20pKSB7XG4gICAgICAgIHJldHVybiBmaW5kTmV4dEJyKHJvb3RFbGVtZW50LCBmcm9tKS5tYXAoYnIgPT4gRGVsZXRlQWN0aW9uLnJlbW92ZShici5nZXROb2RlKCkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBnZXRDb250ZW50RWRpdGFibGVBY3Rpb24ocm9vdCwgZm9yd2FyZCwgZnJvbSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGRlbGV0ZUVsZW1lbnQkMSA9IChlZGl0b3IsIGZvcndhcmQpID0+IGVsZW1lbnQgPT4ge1xuICAgICAgZWRpdG9yLl9zZWxlY3Rpb25PdmVycmlkZXMuaGlkZUZha2VDYXJldCgpO1xuICAgICAgZGVsZXRlRWxlbWVudCQyKGVkaXRvciwgZm9yd2FyZCwgU3VnYXJFbGVtZW50LmZyb21Eb20oZWxlbWVudCkpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBjb25zdCBtb3ZlVG9FbGVtZW50ID0gKGVkaXRvciwgZm9yd2FyZCkgPT4gZWxlbWVudCA9PiB7XG4gICAgICBjb25zdCBwb3MgPSBmb3J3YXJkID8gQ2FyZXRQb3NpdGlvbi5iZWZvcmUoZWxlbWVudCkgOiBDYXJldFBvc2l0aW9uLmFmdGVyKGVsZW1lbnQpO1xuICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZXRSbmcocG9zLnRvUmFuZ2UoKSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIGNvbnN0IG1vdmVUb1Bvc2l0aW9uID0gZWRpdG9yID0+IHBvcyA9PiB7XG4gICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNldFJuZyhwb3MudG9SYW5nZSgpKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgY29uc3QgZ2V0QW5jZXN0b3JDZSA9IChlZGl0b3IsIG5vZGUpID0+IE9wdGlvbmFsLmZyb20oZ2V0Q29udGVudEVkaXRhYmxlUm9vdCQxKGVkaXRvci5nZXRCb2R5KCksIG5vZGUpKTtcbiAgICBjb25zdCBiYWNrc3BhY2VEZWxldGVDYXJldCA9IChlZGl0b3IsIGZvcndhcmQpID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGVkTm9kZSA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0Tm9kZSgpO1xuICAgICAgcmV0dXJuIGdldEFuY2VzdG9yQ2UoZWRpdG9yLCBzZWxlY3RlZE5vZGUpLmZpbHRlcihpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJGEpLmZvbGQoKCkgPT4gcmVhZChlZGl0b3IuZ2V0Qm9keSgpLCBmb3J3YXJkLCBlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpKS5tYXAoZGVsZXRlQWN0aW9uID0+ICgpID0+IGRlbGV0ZUFjdGlvbi5mb2xkKGRlbGV0ZUVsZW1lbnQkMShlZGl0b3IsIGZvcndhcmQpLCBtb3ZlVG9FbGVtZW50KGVkaXRvciwgZm9yd2FyZCksIG1vdmVUb1Bvc2l0aW9uKGVkaXRvcikpKSwgKCkgPT4gT3B0aW9uYWwuc29tZShub29wKSk7XG4gICAgfTtcbiAgICBjb25zdCBkZWxldGVPZmZzY3JlZW5TZWxlY3Rpb24gPSByb290RWxlbWVudCA9PiB7XG4gICAgICBlYWNoJGcoZGVzY2VuZGFudHMocm9vdEVsZW1lbnQsICcubWNlLW9mZnNjcmVlbi1zZWxlY3Rpb24nKSwgcmVtb3ZlJDUpO1xuICAgIH07XG4gICAgY29uc3QgYmFja3NwYWNlRGVsZXRlUmFuZ2UgPSAoZWRpdG9yLCBmb3J3YXJkKSA9PiB7XG4gICAgICBjb25zdCBzZWxlY3RlZE5vZGUgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldE5vZGUoKTtcbiAgICAgIGlmIChpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJGEoc2VsZWN0ZWROb2RlKSAmJiAhaXNUYWJsZUNlbGwkNShzZWxlY3RlZE5vZGUpKSB7XG4gICAgICAgIGNvbnN0IGhhc0NlZkFuY2VzdG9yID0gZ2V0QW5jZXN0b3JDZShlZGl0b3IsIHNlbGVjdGVkTm9kZS5wYXJlbnROb2RlKS5maWx0ZXIoaXNDb250ZW50RWRpdGFibGVGYWxzZSRhKTtcbiAgICAgICAgcmV0dXJuIGhhc0NlZkFuY2VzdG9yLmZvbGQoKCkgPT4gT3B0aW9uYWwuc29tZSgoKSA9PiB7XG4gICAgICAgICAgZGVsZXRlT2Zmc2NyZWVuU2VsZWN0aW9uKFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVkaXRvci5nZXRCb2R5KCkpKTtcbiAgICAgICAgICBkZWxldGVFbGVtZW50JDIoZWRpdG9yLCBmb3J3YXJkLCBTdWdhckVsZW1lbnQuZnJvbURvbShlZGl0b3Iuc2VsZWN0aW9uLmdldE5vZGUoKSkpO1xuICAgICAgICAgIHBhZGRFbXB0eUJvZHkoZWRpdG9yKTtcbiAgICAgICAgfSksICgpID0+IE9wdGlvbmFsLnNvbWUobm9vcCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICB9O1xuICAgIGNvbnN0IHBhZGRFbXB0eUVsZW1lbnQgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgZG9tID0gZWRpdG9yLmRvbSwgc2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbjtcbiAgICAgIGNvbnN0IGNlUm9vdCA9IGdldENvbnRlbnRFZGl0YWJsZVJvb3QkMShlZGl0b3IuZ2V0Qm9keSgpLCBzZWxlY3Rpb24uZ2V0Tm9kZSgpKTtcbiAgICAgIGlmIChpc0NvbnRlbnRFZGl0YWJsZVRydWUkNChjZVJvb3QpICYmIGRvbS5pc0Jsb2NrKGNlUm9vdCkgJiYgZG9tLmlzRW1wdHkoY2VSb290KSkge1xuICAgICAgICBjb25zdCBiciA9IGRvbS5jcmVhdGUoJ2JyJywgeyAnZGF0YS1tY2UtYm9ndXMnOiAnMScgfSk7XG4gICAgICAgIGRvbS5zZXRIVE1MKGNlUm9vdCwgJycpO1xuICAgICAgICBjZVJvb3QuYXBwZW5kQ2hpbGQoYnIpO1xuICAgICAgICBzZWxlY3Rpb24uc2V0Um5nKENhcmV0UG9zaXRpb24uYmVmb3JlKGJyKS50b1JhbmdlKCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBjb25zdCBiYWNrc3BhY2VEZWxldGUkNSA9IChlZGl0b3IsIGZvcndhcmQpID0+IHtcbiAgICAgIGlmIChlZGl0b3Iuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgICAgcmV0dXJuIGJhY2tzcGFjZURlbGV0ZUNhcmV0KGVkaXRvciwgZm9yd2FyZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYmFja3NwYWNlRGVsZXRlUmFuZ2UoZWRpdG9yLCBmb3J3YXJkKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgZGVsZXRlQ2FyZXQkMiA9IChlZGl0b3IsIGZvcndhcmQpID0+IHtcbiAgICAgIGNvbnN0IGZyb21Qb3MgPSBDYXJldFBvc2l0aW9uLmZyb21SYW5nZVN0YXJ0KGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCkpO1xuICAgICAgcmV0dXJuIGZyb21Qb3NpdGlvbihmb3J3YXJkLCBlZGl0b3IuZ2V0Qm9keSgpLCBmcm9tUG9zKS5maWx0ZXIocG9zID0+IGZvcndhcmQgPyBpc0JlZm9yZUltYWdlQmxvY2socG9zKSA6IGlzQWZ0ZXJJbWFnZUJsb2NrKHBvcykpLmJpbmQocG9zID0+IE9wdGlvbmFsLmZyb20oZ2V0Q2hpbGROb2RlQXRSZWxhdGl2ZU9mZnNldChmb3J3YXJkID8gMCA6IC0xLCBwb3MpKSkubWFwKGVsbSA9PiAoKSA9PiBlZGl0b3Iuc2VsZWN0aW9uLnNlbGVjdChlbG0pKTtcbiAgICB9O1xuICAgIGNvbnN0IGJhY2tzcGFjZURlbGV0ZSQ0ID0gKGVkaXRvciwgZm9yd2FyZCkgPT4gZWRpdG9yLnNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpID8gZGVsZXRlQ2FyZXQkMihlZGl0b3IsIGZvcndhcmQpIDogT3B0aW9uYWwubm9uZSgpO1xuXG4gICAgY29uc3QgaXNUZXh0JDEgPSBpc1RleHQkODtcbiAgICBjb25zdCBzdGFydHNXaXRoQ2FyZXRDb250YWluZXIgPSBub2RlID0+IGlzVGV4dCQxKG5vZGUpICYmIG5vZGUuZGF0YVswXSA9PT0gWldTUCQxO1xuICAgIGNvbnN0IGVuZHNXaXRoQ2FyZXRDb250YWluZXIgPSBub2RlID0+IGlzVGV4dCQxKG5vZGUpICYmIG5vZGUuZGF0YVtub2RlLmRhdGEubGVuZ3RoIC0gMV0gPT09IFpXU1AkMTtcbiAgICBjb25zdCBjcmVhdGVad3NwID0gbm9kZSA9PiBub2RlLm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoWldTUCQxKTtcbiAgICBjb25zdCBpbnNlcnRCZWZvcmUgPSBub2RlID0+IHtcbiAgICAgIGlmIChpc1RleHQkMShub2RlLnByZXZpb3VzU2libGluZykpIHtcbiAgICAgICAgaWYgKGVuZHNXaXRoQ2FyZXRDb250YWluZXIobm9kZS5wcmV2aW91c1NpYmxpbmcpKSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUucHJldmlvdXNTaWJsaW5nLmFwcGVuZERhdGEoWldTUCQxKTtcbiAgICAgICAgICByZXR1cm4gbm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNUZXh0JDEobm9kZSkpIHtcbiAgICAgICAgaWYgKHN0YXJ0c1dpdGhDYXJldENvbnRhaW5lcihub2RlKSkge1xuICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUuaW5zZXJ0RGF0YSgwLCBaV1NQJDEpO1xuICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBuZXdOb2RlID0gY3JlYXRlWndzcChub2RlKTtcbiAgICAgICAgbm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdOb2RlLCBub2RlKTtcbiAgICAgICAgcmV0dXJuIG5ld05vZGU7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBpbnNlcnRBZnRlciA9IG5vZGUgPT4ge1xuICAgICAgaWYgKGlzVGV4dCQxKG5vZGUubmV4dFNpYmxpbmcpKSB7XG4gICAgICAgIGlmIChzdGFydHNXaXRoQ2FyZXRDb250YWluZXIobm9kZS5uZXh0U2libGluZykpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLm5leHRTaWJsaW5nLmluc2VydERhdGEoMCwgWldTUCQxKTtcbiAgICAgICAgICByZXR1cm4gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc1RleHQkMShub2RlKSkge1xuICAgICAgICBpZiAoZW5kc1dpdGhDYXJldENvbnRhaW5lcihub2RlKSkge1xuICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUuYXBwZW5kRGF0YShaV1NQJDEpO1xuICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBuZXdOb2RlID0gY3JlYXRlWndzcChub2RlKTtcbiAgICAgICAgaWYgKG5vZGUubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICBub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld05vZGUsIG5vZGUubmV4dFNpYmxpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChuZXdOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3Tm9kZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGluc2VydElubGluZSA9IChiZWZvcmUsIG5vZGUpID0+IGJlZm9yZSA/IGluc2VydEJlZm9yZShub2RlKSA6IGluc2VydEFmdGVyKG5vZGUpO1xuICAgIGNvbnN0IGluc2VydElubGluZUJlZm9yZSA9IGN1cnJ5KGluc2VydElubGluZSwgdHJ1ZSk7XG4gICAgY29uc3QgaW5zZXJ0SW5saW5lQWZ0ZXIgPSBjdXJyeShpbnNlcnRJbmxpbmUsIGZhbHNlKTtcblxuICAgIGNvbnN0IGluc2VydElubGluZVBvcyA9IChwb3MsIGJlZm9yZSkgPT4ge1xuICAgICAgaWYgKGlzVGV4dCQ4KHBvcy5jb250YWluZXIoKSkpIHtcbiAgICAgICAgcmV0dXJuIGluc2VydElubGluZShiZWZvcmUsIHBvcy5jb250YWluZXIoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaW5zZXJ0SW5saW5lKGJlZm9yZSwgcG9zLmdldE5vZGUoKSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBpc1Bvc0NhcmV0Q29udGFpbmVyID0gKHBvcywgY2FyZXQpID0+IHtcbiAgICAgIGNvbnN0IGNhcmV0Tm9kZSA9IGNhcmV0LmdldCgpO1xuICAgICAgcmV0dXJuIGNhcmV0Tm9kZSAmJiBwb3MuY29udGFpbmVyKCkgPT09IGNhcmV0Tm9kZSAmJiBpc0NhcmV0Q29udGFpbmVySW5saW5lKGNhcmV0Tm9kZSk7XG4gICAgfTtcbiAgICBjb25zdCByZW5kZXJDYXJldCA9IChjYXJldCwgbG9jYXRpb24pID0+IGxvY2F0aW9uLmZvbGQoZWxlbWVudCA9PiB7XG4gICAgICByZW1vdmUkNChjYXJldC5nZXQoKSk7XG4gICAgICBjb25zdCB0ZXh0ID0gaW5zZXJ0SW5saW5lQmVmb3JlKGVsZW1lbnQpO1xuICAgICAgY2FyZXQuc2V0KHRleHQpO1xuICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoQ2FyZXRQb3NpdGlvbih0ZXh0LCB0ZXh0Lmxlbmd0aCAtIDEpKTtcbiAgICB9LCBlbGVtZW50ID0+IGZpcnN0UG9zaXRpb25JbihlbGVtZW50KS5tYXAocG9zID0+IHtcbiAgICAgIGlmICghaXNQb3NDYXJldENvbnRhaW5lcihwb3MsIGNhcmV0KSkge1xuICAgICAgICByZW1vdmUkNChjYXJldC5nZXQoKSk7XG4gICAgICAgIGNvbnN0IHRleHQgPSBpbnNlcnRJbmxpbmVQb3MocG9zLCB0cnVlKTtcbiAgICAgICAgY2FyZXQuc2V0KHRleHQpO1xuICAgICAgICByZXR1cm4gQ2FyZXRQb3NpdGlvbih0ZXh0LCAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBDYXJldFBvc2l0aW9uKGNhcmV0LmdldCgpLCAxKTtcbiAgICAgIH1cbiAgICB9KSwgZWxlbWVudCA9PiBsYXN0UG9zaXRpb25JbihlbGVtZW50KS5tYXAocG9zID0+IHtcbiAgICAgIGlmICghaXNQb3NDYXJldENvbnRhaW5lcihwb3MsIGNhcmV0KSkge1xuICAgICAgICByZW1vdmUkNChjYXJldC5nZXQoKSk7XG4gICAgICAgIGNvbnN0IHRleHQgPSBpbnNlcnRJbmxpbmVQb3MocG9zLCBmYWxzZSk7XG4gICAgICAgIGNhcmV0LnNldCh0ZXh0KTtcbiAgICAgICAgcmV0dXJuIENhcmV0UG9zaXRpb24odGV4dCwgdGV4dC5sZW5ndGggLSAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBDYXJldFBvc2l0aW9uKGNhcmV0LmdldCgpLCBjYXJldC5nZXQoKS5sZW5ndGggLSAxKTtcbiAgICAgIH1cbiAgICB9KSwgZWxlbWVudCA9PiB7XG4gICAgICByZW1vdmUkNChjYXJldC5nZXQoKSk7XG4gICAgICBjb25zdCB0ZXh0ID0gaW5zZXJ0SW5saW5lQWZ0ZXIoZWxlbWVudCk7XG4gICAgICBjYXJldC5zZXQodGV4dCk7XG4gICAgICByZXR1cm4gT3B0aW9uYWwuc29tZShDYXJldFBvc2l0aW9uKHRleHQsIDEpKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGV2YWx1YXRlVW50aWwgPSAoZm5zLCBhcmdzKSA9PiB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBmbnNbaV0uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIGlmIChyZXN1bHQuaXNTb21lKCkpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgIH07XG5cbiAgICBjb25zdCBMb2NhdGlvbiA9IEFkdC5nZW5lcmF0ZShbXG4gICAgICB7IGJlZm9yZTogWydlbGVtZW50J10gfSxcbiAgICAgIHsgc3RhcnQ6IFsnZWxlbWVudCddIH0sXG4gICAgICB7IGVuZDogWydlbGVtZW50J10gfSxcbiAgICAgIHsgYWZ0ZXI6IFsnZWxlbWVudCddIH1cbiAgICBdKTtcbiAgICBjb25zdCByZXNjb3BlJDEgPSAocm9vdE5vZGUsIG5vZGUpID0+IHtcbiAgICAgIGNvbnN0IHBhcmVudEJsb2NrID0gZ2V0UGFyZW50QmxvY2skMyhub2RlLCByb290Tm9kZSk7XG4gICAgICByZXR1cm4gcGFyZW50QmxvY2sgPyBwYXJlbnRCbG9jayA6IHJvb3ROb2RlO1xuICAgIH07XG4gICAgY29uc3QgYmVmb3JlID0gKGlzSW5saW5lVGFyZ2V0LCByb290Tm9kZSwgcG9zKSA9PiB7XG4gICAgICBjb25zdCBuUG9zID0gbm9ybWFsaXplRm9yd2FyZHMocG9zKTtcbiAgICAgIGNvbnN0IHNjb3BlID0gcmVzY29wZSQxKHJvb3ROb2RlLCBuUG9zLmNvbnRhaW5lcigpKTtcbiAgICAgIHJldHVybiBmaW5kUm9vdElubGluZShpc0lubGluZVRhcmdldCwgc2NvcGUsIG5Qb3MpLmZvbGQoKCkgPT4gbmV4dFBvc2l0aW9uKHNjb3BlLCBuUG9zKS5iaW5kKGN1cnJ5KGZpbmRSb290SW5saW5lLCBpc0lubGluZVRhcmdldCwgc2NvcGUpKS5tYXAoaW5saW5lID0+IExvY2F0aW9uLmJlZm9yZShpbmxpbmUpKSwgT3B0aW9uYWwubm9uZSk7XG4gICAgfTtcbiAgICBjb25zdCBpc05vdEluc2lkZUZvcm1hdENhcmV0Q29udGFpbmVyID0gKHJvb3ROb2RlLCBlbG0pID0+IGdldFBhcmVudENhcmV0Q29udGFpbmVyKHJvb3ROb2RlLCBlbG0pID09PSBudWxsO1xuICAgIGNvbnN0IGZpbmRJbnNpZGVSb290SW5saW5lID0gKGlzSW5saW5lVGFyZ2V0LCByb290Tm9kZSwgcG9zKSA9PiBmaW5kUm9vdElubGluZShpc0lubGluZVRhcmdldCwgcm9vdE5vZGUsIHBvcykuZmlsdGVyKGN1cnJ5KGlzTm90SW5zaWRlRm9ybWF0Q2FyZXRDb250YWluZXIsIHJvb3ROb2RlKSk7XG4gICAgY29uc3Qgc3RhcnQkMSA9IChpc0lubGluZVRhcmdldCwgcm9vdE5vZGUsIHBvcykgPT4ge1xuICAgICAgY29uc3QgblBvcyA9IG5vcm1hbGl6ZUJhY2t3YXJkcyhwb3MpO1xuICAgICAgcmV0dXJuIGZpbmRJbnNpZGVSb290SW5saW5lKGlzSW5saW5lVGFyZ2V0LCByb290Tm9kZSwgblBvcykuYmluZChpbmxpbmUgPT4ge1xuICAgICAgICBjb25zdCBwcmV2UG9zID0gcHJldlBvc2l0aW9uKGlubGluZSwgblBvcyk7XG4gICAgICAgIHJldHVybiBwcmV2UG9zLmlzTm9uZSgpID8gT3B0aW9uYWwuc29tZShMb2NhdGlvbi5zdGFydChpbmxpbmUpKSA6IE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgZW5kID0gKGlzSW5saW5lVGFyZ2V0LCByb290Tm9kZSwgcG9zKSA9PiB7XG4gICAgICBjb25zdCBuUG9zID0gbm9ybWFsaXplRm9yd2FyZHMocG9zKTtcbiAgICAgIHJldHVybiBmaW5kSW5zaWRlUm9vdElubGluZShpc0lubGluZVRhcmdldCwgcm9vdE5vZGUsIG5Qb3MpLmJpbmQoaW5saW5lID0+IHtcbiAgICAgICAgY29uc3QgbmV4dFBvcyA9IG5leHRQb3NpdGlvbihpbmxpbmUsIG5Qb3MpO1xuICAgICAgICByZXR1cm4gbmV4dFBvcy5pc05vbmUoKSA/IE9wdGlvbmFsLnNvbWUoTG9jYXRpb24uZW5kKGlubGluZSkpIDogT3B0aW9uYWwubm9uZSgpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBhZnRlciA9IChpc0lubGluZVRhcmdldCwgcm9vdE5vZGUsIHBvcykgPT4ge1xuICAgICAgY29uc3QgblBvcyA9IG5vcm1hbGl6ZUJhY2t3YXJkcyhwb3MpO1xuICAgICAgY29uc3Qgc2NvcGUgPSByZXNjb3BlJDEocm9vdE5vZGUsIG5Qb3MuY29udGFpbmVyKCkpO1xuICAgICAgcmV0dXJuIGZpbmRSb290SW5saW5lKGlzSW5saW5lVGFyZ2V0LCBzY29wZSwgblBvcykuZm9sZCgoKSA9PiBwcmV2UG9zaXRpb24oc2NvcGUsIG5Qb3MpLmJpbmQoY3VycnkoZmluZFJvb3RJbmxpbmUsIGlzSW5saW5lVGFyZ2V0LCBzY29wZSkpLm1hcChpbmxpbmUgPT4gTG9jYXRpb24uYWZ0ZXIoaW5saW5lKSksIE9wdGlvbmFsLm5vbmUpO1xuICAgIH07XG4gICAgY29uc3QgaXNWYWxpZExvY2F0aW9uID0gbG9jYXRpb24gPT4gaXNSdGwoZ2V0RWxlbWVudChsb2NhdGlvbikpID09PSBmYWxzZTtcbiAgICBjb25zdCByZWFkTG9jYXRpb24gPSAoaXNJbmxpbmVUYXJnZXQsIHJvb3ROb2RlLCBwb3MpID0+IHtcbiAgICAgIGNvbnN0IGxvY2F0aW9uID0gZXZhbHVhdGVVbnRpbChbXG4gICAgICAgIGJlZm9yZSxcbiAgICAgICAgc3RhcnQkMSxcbiAgICAgICAgZW5kLFxuICAgICAgICBhZnRlclxuICAgICAgXSwgW1xuICAgICAgICBpc0lubGluZVRhcmdldCxcbiAgICAgICAgcm9vdE5vZGUsXG4gICAgICAgIHBvc1xuICAgICAgXSk7XG4gICAgICByZXR1cm4gbG9jYXRpb24uZmlsdGVyKGlzVmFsaWRMb2NhdGlvbik7XG4gICAgfTtcbiAgICBjb25zdCBnZXRFbGVtZW50ID0gbG9jYXRpb24gPT4gbG9jYXRpb24uZm9sZChpZGVudGl0eSwgaWRlbnRpdHksIGlkZW50aXR5LCBpZGVudGl0eSk7XG4gICAgY29uc3QgZ2V0TmFtZSA9IGxvY2F0aW9uID0+IGxvY2F0aW9uLmZvbGQoY29uc3RhbnQoJ2JlZm9yZScpLCBjb25zdGFudCgnc3RhcnQnKSwgY29uc3RhbnQoJ2VuZCcpLCBjb25zdGFudCgnYWZ0ZXInKSk7XG4gICAgY29uc3Qgb3V0c2lkZSA9IGxvY2F0aW9uID0+IGxvY2F0aW9uLmZvbGQoTG9jYXRpb24uYmVmb3JlLCBMb2NhdGlvbi5iZWZvcmUsIExvY2F0aW9uLmFmdGVyLCBMb2NhdGlvbi5hZnRlcik7XG4gICAgY29uc3QgaW5zaWRlID0gbG9jYXRpb24gPT4gbG9jYXRpb24uZm9sZChMb2NhdGlvbi5zdGFydCwgTG9jYXRpb24uc3RhcnQsIExvY2F0aW9uLmVuZCwgTG9jYXRpb24uZW5kKTtcbiAgICBjb25zdCBpc0VxID0gKGxvY2F0aW9uMSwgbG9jYXRpb24yKSA9PiBnZXROYW1lKGxvY2F0aW9uMSkgPT09IGdldE5hbWUobG9jYXRpb24yKSAmJiBnZXRFbGVtZW50KGxvY2F0aW9uMSkgPT09IGdldEVsZW1lbnQobG9jYXRpb24yKTtcbiAgICBjb25zdCBiZXR3ZWVuSW5saW5lcyA9IChmb3J3YXJkLCBpc0lubGluZVRhcmdldCwgcm9vdE5vZGUsIGZyb20sIHRvLCBsb2NhdGlvbikgPT4gbGlmdDIoZmluZFJvb3RJbmxpbmUoaXNJbmxpbmVUYXJnZXQsIHJvb3ROb2RlLCBmcm9tKSwgZmluZFJvb3RJbmxpbmUoaXNJbmxpbmVUYXJnZXQsIHJvb3ROb2RlLCB0byksIChmcm9tSW5saW5lLCB0b0lubGluZSkgPT4ge1xuICAgICAgaWYgKGZyb21JbmxpbmUgIT09IHRvSW5saW5lICYmIGhhc1NhbWVQYXJlbnRCbG9jayhyb290Tm9kZSwgZnJvbUlubGluZSwgdG9JbmxpbmUpKSB7XG4gICAgICAgIHJldHVybiBMb2NhdGlvbi5hZnRlcihmb3J3YXJkID8gZnJvbUlubGluZSA6IHRvSW5saW5lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBsb2NhdGlvbjtcbiAgICAgIH1cbiAgICB9KS5nZXRPcihsb2NhdGlvbik7XG4gICAgY29uc3Qgc2tpcE5vTW92ZW1lbnQgPSAoZnJvbUxvY2F0aW9uLCB0b0xvY2F0aW9uKSA9PiBmcm9tTG9jYXRpb24uZm9sZChhbHdheXMsIGZyb21Mb2NhdGlvbiA9PiAhaXNFcShmcm9tTG9jYXRpb24sIHRvTG9jYXRpb24pKTtcbiAgICBjb25zdCBmaW5kTG9jYXRpb25UcmF2ZXJzZSA9IChmb3J3YXJkLCBpc0lubGluZVRhcmdldCwgcm9vdE5vZGUsIGZyb21Mb2NhdGlvbiwgcG9zKSA9PiB7XG4gICAgICBjb25zdCBmcm9tID0gbm9ybWFsaXplUG9zaXRpb24oZm9yd2FyZCwgcG9zKTtcbiAgICAgIGNvbnN0IHRvID0gZnJvbVBvc2l0aW9uKGZvcndhcmQsIHJvb3ROb2RlLCBmcm9tKS5tYXAoY3Vycnkobm9ybWFsaXplUG9zaXRpb24sIGZvcndhcmQpKTtcbiAgICAgIGNvbnN0IGxvY2F0aW9uID0gdG8uZm9sZCgoKSA9PiBmcm9tTG9jYXRpb24ubWFwKG91dHNpZGUpLCB0byA9PiByZWFkTG9jYXRpb24oaXNJbmxpbmVUYXJnZXQsIHJvb3ROb2RlLCB0bykubWFwKGN1cnJ5KGJldHdlZW5JbmxpbmVzLCBmb3J3YXJkLCBpc0lubGluZVRhcmdldCwgcm9vdE5vZGUsIGZyb20sIHRvKSkuZmlsdGVyKGN1cnJ5KHNraXBOb01vdmVtZW50LCBmcm9tTG9jYXRpb24pKSk7XG4gICAgICByZXR1cm4gbG9jYXRpb24uZmlsdGVyKGlzVmFsaWRMb2NhdGlvbik7XG4gICAgfTtcbiAgICBjb25zdCBmaW5kTG9jYXRpb25TaW1wbGUgPSAoZm9yd2FyZCwgbG9jYXRpb24pID0+IHtcbiAgICAgIGlmIChmb3J3YXJkKSB7XG4gICAgICAgIHJldHVybiBsb2NhdGlvbi5mb2xkKGNvbXBvc2UoT3B0aW9uYWwuc29tZSwgTG9jYXRpb24uc3RhcnQpLCBPcHRpb25hbC5ub25lLCBjb21wb3NlKE9wdGlvbmFsLnNvbWUsIExvY2F0aW9uLmFmdGVyKSwgT3B0aW9uYWwubm9uZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbG9jYXRpb24uZm9sZChPcHRpb25hbC5ub25lLCBjb21wb3NlKE9wdGlvbmFsLnNvbWUsIExvY2F0aW9uLmJlZm9yZSksIE9wdGlvbmFsLm5vbmUsIGNvbXBvc2UoT3B0aW9uYWwuc29tZSwgTG9jYXRpb24uZW5kKSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBmaW5kTG9jYXRpb24kMSA9IChmb3J3YXJkLCBpc0lubGluZVRhcmdldCwgcm9vdE5vZGUsIHBvcykgPT4ge1xuICAgICAgY29uc3QgZnJvbSA9IG5vcm1hbGl6ZVBvc2l0aW9uKGZvcndhcmQsIHBvcyk7XG4gICAgICBjb25zdCBmcm9tTG9jYXRpb24gPSByZWFkTG9jYXRpb24oaXNJbmxpbmVUYXJnZXQsIHJvb3ROb2RlLCBmcm9tKTtcbiAgICAgIHJldHVybiByZWFkTG9jYXRpb24oaXNJbmxpbmVUYXJnZXQsIHJvb3ROb2RlLCBmcm9tKS5iaW5kKGN1cnJ5KGZpbmRMb2NhdGlvblNpbXBsZSwgZm9yd2FyZCkpLm9yVGh1bmsoKCkgPT4gZmluZExvY2F0aW9uVHJhdmVyc2UoZm9yd2FyZCwgaXNJbmxpbmVUYXJnZXQsIHJvb3ROb2RlLCBmcm9tTG9jYXRpb24sIHBvcykpO1xuICAgIH07XG5cbiAgICBjb25zdCBoYXNTZWxlY3Rpb25Nb2RpZnlBcGkgPSBlZGl0b3IgPT4ge1xuICAgICAgcmV0dXJuIGlzRnVuY3Rpb24oZWRpdG9yLnNlbGVjdGlvbi5nZXRTZWwoKS5tb2RpZnkpO1xuICAgIH07XG4gICAgY29uc3QgbW92ZVJlbCA9IChmb3J3YXJkLCBzZWxlY3Rpb24sIHBvcykgPT4ge1xuICAgICAgY29uc3QgZGVsdGEgPSBmb3J3YXJkID8gMSA6IC0xO1xuICAgICAgc2VsZWN0aW9uLnNldFJuZyhDYXJldFBvc2l0aW9uKHBvcy5jb250YWluZXIoKSwgcG9zLm9mZnNldCgpICsgZGVsdGEpLnRvUmFuZ2UoKSk7XG4gICAgICBzZWxlY3Rpb24uZ2V0U2VsKCkubW9kaWZ5KCdtb3ZlJywgZm9yd2FyZCA/ICdmb3J3YXJkJyA6ICdiYWNrd2FyZCcsICd3b3JkJyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIGNvbnN0IG1vdmVCeVdvcmQgPSAoZm9yd2FyZCwgZWRpdG9yKSA9PiB7XG4gICAgICBjb25zdCBybmcgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpO1xuICAgICAgY29uc3QgcG9zID0gZm9yd2FyZCA/IENhcmV0UG9zaXRpb24uZnJvbVJhbmdlRW5kKHJuZykgOiBDYXJldFBvc2l0aW9uLmZyb21SYW5nZVN0YXJ0KHJuZyk7XG4gICAgICBpZiAoIWhhc1NlbGVjdGlvbk1vZGlmeUFwaShlZGl0b3IpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoZm9yd2FyZCAmJiBpc0JlZm9yZUlubGluZShwb3MpKSB7XG4gICAgICAgIHJldHVybiBtb3ZlUmVsKHRydWUsIGVkaXRvci5zZWxlY3Rpb24sIHBvcyk7XG4gICAgICB9IGVsc2UgaWYgKCFmb3J3YXJkICYmIGlzQWZ0ZXJJbmxpbmUocG9zKSkge1xuICAgICAgICByZXR1cm4gbW92ZVJlbChmYWxzZSwgZWRpdG9yLnNlbGVjdGlvbiwgcG9zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIEJyZWFrVHlwZTtcbiAgICAoZnVuY3Rpb24gKEJyZWFrVHlwZSkge1xuICAgICAgQnJlYWtUeXBlW0JyZWFrVHlwZVsnQnInXSA9IDBdID0gJ0JyJztcbiAgICAgIEJyZWFrVHlwZVtCcmVha1R5cGVbJ0Jsb2NrJ10gPSAxXSA9ICdCbG9jayc7XG4gICAgICBCcmVha1R5cGVbQnJlYWtUeXBlWydXcmFwJ10gPSAyXSA9ICdXcmFwJztcbiAgICAgIEJyZWFrVHlwZVtCcmVha1R5cGVbJ0VvbCddID0gM10gPSAnRW9sJztcbiAgICB9KEJyZWFrVHlwZSB8fCAoQnJlYWtUeXBlID0ge30pKSk7XG4gICAgY29uc3QgZmxpcCA9IChkaXJlY3Rpb24sIHBvc2l0aW9ucykgPT4gZGlyZWN0aW9uID09PSBIRGlyZWN0aW9uLkJhY2t3YXJkcyA/IHJldmVyc2UocG9zaXRpb25zKSA6IHBvc2l0aW9ucztcbiAgICBjb25zdCB3YWxrJDEgPSAoZGlyZWN0aW9uLCBjYXJldFdhbGtlciwgcG9zKSA9PiBkaXJlY3Rpb24gPT09IEhEaXJlY3Rpb24uRm9yd2FyZHMgPyBjYXJldFdhbGtlci5uZXh0KHBvcykgOiBjYXJldFdhbGtlci5wcmV2KHBvcyk7XG4gICAgY29uc3QgZ2V0QnJlYWtUeXBlID0gKHNjb3BlLCBkaXJlY3Rpb24sIGN1cnJlbnRQb3MsIG5leHRQb3MpID0+IHtcbiAgICAgIGlmIChpc0JyJDUobmV4dFBvcy5nZXROb2RlKGRpcmVjdGlvbiA9PT0gSERpcmVjdGlvbi5Gb3J3YXJkcykpKSB7XG4gICAgICAgIHJldHVybiBCcmVha1R5cGUuQnI7XG4gICAgICB9IGVsc2UgaWYgKGlzSW5TYW1lQmxvY2soY3VycmVudFBvcywgbmV4dFBvcykgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBCcmVha1R5cGUuQmxvY2s7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gQnJlYWtUeXBlLldyYXA7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBnZXRQb3NpdGlvbnNVbnRpbCA9IChwcmVkaWNhdGUsIGRpcmVjdGlvbiwgc2NvcGUsIHN0YXJ0KSA9PiB7XG4gICAgICBjb25zdCBjYXJldFdhbGtlciA9IENhcmV0V2Fsa2VyKHNjb3BlKTtcbiAgICAgIGxldCBjdXJyZW50UG9zID0gc3RhcnQ7XG4gICAgICBjb25zdCBwb3NpdGlvbnMgPSBbXTtcbiAgICAgIHdoaWxlIChjdXJyZW50UG9zKSB7XG4gICAgICAgIGNvbnN0IG5leHRQb3MgPSB3YWxrJDEoZGlyZWN0aW9uLCBjYXJldFdhbGtlciwgY3VycmVudFBvcyk7XG4gICAgICAgIGlmICghbmV4dFBvcykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0JyJDUobmV4dFBvcy5nZXROb2RlKGZhbHNlKSkpIHtcbiAgICAgICAgICBpZiAoZGlyZWN0aW9uID09PSBIRGlyZWN0aW9uLkZvcndhcmRzKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBwb3NpdGlvbnM6IGZsaXAoZGlyZWN0aW9uLCBwb3NpdGlvbnMpLmNvbmNhdChbbmV4dFBvc10pLFxuICAgICAgICAgICAgICBicmVha1R5cGU6IEJyZWFrVHlwZS5CcixcbiAgICAgICAgICAgICAgYnJlYWtBdDogT3B0aW9uYWwuc29tZShuZXh0UG9zKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgcG9zaXRpb25zOiBmbGlwKGRpcmVjdGlvbiwgcG9zaXRpb25zKSxcbiAgICAgICAgICAgICAgYnJlYWtUeXBlOiBCcmVha1R5cGUuQnIsXG4gICAgICAgICAgICAgIGJyZWFrQXQ6IE9wdGlvbmFsLnNvbWUobmV4dFBvcylcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbmV4dFBvcy5pc1Zpc2libGUoKSkge1xuICAgICAgICAgIGN1cnJlbnRQb3MgPSBuZXh0UG9zO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmVkaWNhdGUoY3VycmVudFBvcywgbmV4dFBvcykpIHtcbiAgICAgICAgICBjb25zdCBicmVha1R5cGUgPSBnZXRCcmVha1R5cGUoc2NvcGUsIGRpcmVjdGlvbiwgY3VycmVudFBvcywgbmV4dFBvcyk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBvc2l0aW9uczogZmxpcChkaXJlY3Rpb24sIHBvc2l0aW9ucyksXG4gICAgICAgICAgICBicmVha1R5cGUsXG4gICAgICAgICAgICBicmVha0F0OiBPcHRpb25hbC5zb21lKG5leHRQb3MpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBwb3NpdGlvbnMucHVzaChuZXh0UG9zKTtcbiAgICAgICAgY3VycmVudFBvcyA9IG5leHRQb3M7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwb3NpdGlvbnM6IGZsaXAoZGlyZWN0aW9uLCBwb3NpdGlvbnMpLFxuICAgICAgICBicmVha1R5cGU6IEJyZWFrVHlwZS5Fb2wsXG4gICAgICAgIGJyZWFrQXQ6IE9wdGlvbmFsLm5vbmUoKVxuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IGdldEFkamFjZW50TGluZVBvc2l0aW9ucyA9IChkaXJlY3Rpb24sIGdldFBvc2l0aW9uc1VudGlsQnJlYWssIHNjb3BlLCBzdGFydCkgPT4gZ2V0UG9zaXRpb25zVW50aWxCcmVhayhzY29wZSwgc3RhcnQpLmJyZWFrQXQubWFwKHBvcyA9PiB7XG4gICAgICBjb25zdCBwb3NpdGlvbnMgPSBnZXRQb3NpdGlvbnNVbnRpbEJyZWFrKHNjb3BlLCBwb3MpLnBvc2l0aW9ucztcbiAgICAgIHJldHVybiBkaXJlY3Rpb24gPT09IEhEaXJlY3Rpb24uQmFja3dhcmRzID8gcG9zaXRpb25zLmNvbmNhdChwb3MpIDogW3Bvc10uY29uY2F0KHBvc2l0aW9ucyk7XG4gICAgfSkuZ2V0T3IoW10pO1xuICAgIGNvbnN0IGZpbmRDbG9zZXN0SG9yaXpvbnRhbFBvc2l0aW9uRnJvbVBvaW50ID0gKHBvc2l0aW9ucywgeCkgPT4gZm9sZGwocG9zaXRpb25zLCAoYWNjLCBuZXdQb3MpID0+IGFjYy5mb2xkKCgpID0+IE9wdGlvbmFsLnNvbWUobmV3UG9zKSwgbGFzdFBvcyA9PiBsaWZ0MihoZWFkKGxhc3RQb3MuZ2V0Q2xpZW50UmVjdHMoKSksIGhlYWQobmV3UG9zLmdldENsaWVudFJlY3RzKCkpLCAobGFzdFJlY3QsIG5ld1JlY3QpID0+IHtcbiAgICAgIGNvbnN0IGxhc3REaXN0ID0gTWF0aC5hYnMoeCAtIGxhc3RSZWN0LmxlZnQpO1xuICAgICAgY29uc3QgbmV3RGlzdCA9IE1hdGguYWJzKHggLSBuZXdSZWN0LmxlZnQpO1xuICAgICAgcmV0dXJuIG5ld0Rpc3QgPD0gbGFzdERpc3QgPyBuZXdQb3MgOiBsYXN0UG9zO1xuICAgIH0pLm9yKGFjYykpLCBPcHRpb25hbC5ub25lKCkpO1xuICAgIGNvbnN0IGZpbmRDbG9zZXN0SG9yaXpvbnRhbFBvc2l0aW9uID0gKHBvc2l0aW9ucywgcG9zKSA9PiBoZWFkKHBvcy5nZXRDbGllbnRSZWN0cygpKS5iaW5kKHRhcmdldFJlY3QgPT4gZmluZENsb3Nlc3RIb3Jpem9udGFsUG9zaXRpb25Gcm9tUG9pbnQocG9zaXRpb25zLCB0YXJnZXRSZWN0LmxlZnQpKTtcbiAgICBjb25zdCBnZXRQb3NpdGlvbnNVbnRpbFByZXZpb3VzTGluZSA9IGN1cnJ5KGdldFBvc2l0aW9uc1VudGlsLCBDYXJldFBvc2l0aW9uLmlzQWJvdmUsIC0xKTtcbiAgICBjb25zdCBnZXRQb3NpdGlvbnNVbnRpbE5leHRMaW5lID0gY3VycnkoZ2V0UG9zaXRpb25zVW50aWwsIENhcmV0UG9zaXRpb24uaXNCZWxvdywgMSk7XG4gICAgY29uc3QgZ2V0UG9zaXRpb25zQWJvdmUgPSBjdXJyeShnZXRBZGphY2VudExpbmVQb3NpdGlvbnMsIC0xLCBnZXRQb3NpdGlvbnNVbnRpbFByZXZpb3VzTGluZSk7XG4gICAgY29uc3QgZ2V0UG9zaXRpb25zQmVsb3cgPSBjdXJyeShnZXRBZGphY2VudExpbmVQb3NpdGlvbnMsIDEsIGdldFBvc2l0aW9uc1VudGlsTmV4dExpbmUpO1xuICAgIGNvbnN0IGlzQXRGaXJzdExpbmUgPSAoc2NvcGUsIHBvcykgPT4gZ2V0UG9zaXRpb25zVW50aWxQcmV2aW91c0xpbmUoc2NvcGUsIHBvcykuYnJlYWtBdC5pc05vbmUoKTtcbiAgICBjb25zdCBpc0F0TGFzdExpbmUgPSAoc2NvcGUsIHBvcykgPT4gZ2V0UG9zaXRpb25zVW50aWxOZXh0TGluZShzY29wZSwgcG9zKS5icmVha0F0LmlzTm9uZSgpO1xuICAgIGNvbnN0IGdldEZpcnN0TGluZVBvc2l0aW9ucyA9IHNjb3BlID0+IGZpcnN0UG9zaXRpb25JbihzY29wZSkubWFwKHBvcyA9PiBbcG9zXS5jb25jYXQoZ2V0UG9zaXRpb25zVW50aWxOZXh0TGluZShzY29wZSwgcG9zKS5wb3NpdGlvbnMpKS5nZXRPcihbXSk7XG4gICAgY29uc3QgZ2V0TGFzdExpbmVQb3NpdGlvbnMgPSBzY29wZSA9PiBsYXN0UG9zaXRpb25JbihzY29wZSkubWFwKHBvcyA9PiBnZXRQb3NpdGlvbnNVbnRpbFByZXZpb3VzTGluZShzY29wZSwgcG9zKS5wb3NpdGlvbnMuY29uY2F0KHBvcykpLmdldE9yKFtdKTtcblxuICAgIGNvbnN0IGlzQ29udGVudEVkaXRhYmxlRmFsc2UkMyA9IGlzQ29udGVudEVkaXRhYmxlRmFsc2UkYTtcbiAgICBjb25zdCBkaXN0YW5jZVRvUmVjdExlZnQkMSA9IChjbGllbnRSZWN0LCBjbGllbnRYKSA9PiBNYXRoLmFicyhjbGllbnRSZWN0LmxlZnQgLSBjbGllbnRYKTtcbiAgICBjb25zdCBkaXN0YW5jZVRvUmVjdFJpZ2h0JDEgPSAoY2xpZW50UmVjdCwgY2xpZW50WCkgPT4gTWF0aC5hYnMoY2xpZW50UmVjdC5yaWdodCAtIGNsaWVudFgpO1xuICAgIGNvbnN0IGlzTm9kZUNsaWVudFJlY3QgPSByZWN0ID0+IGhhc05vbk51bGxhYmxlS2V5KHJlY3QsICdub2RlJyk7XG4gICAgY29uc3QgZmluZENsb3Nlc3RDbGllbnRSZWN0ID0gKGNsaWVudFJlY3RzLCBjbGllbnRYKSA9PiByZWR1Y2UoY2xpZW50UmVjdHMsIChvbGRDbGllbnRSZWN0LCBjbGllbnRSZWN0KSA9PiB7XG4gICAgICBjb25zdCBvbGREaXN0YW5jZSA9IE1hdGgubWluKGRpc3RhbmNlVG9SZWN0TGVmdCQxKG9sZENsaWVudFJlY3QsIGNsaWVudFgpLCBkaXN0YW5jZVRvUmVjdFJpZ2h0JDEob2xkQ2xpZW50UmVjdCwgY2xpZW50WCkpO1xuICAgICAgY29uc3QgbmV3RGlzdGFuY2UgPSBNYXRoLm1pbihkaXN0YW5jZVRvUmVjdExlZnQkMShjbGllbnRSZWN0LCBjbGllbnRYKSwgZGlzdGFuY2VUb1JlY3RSaWdodCQxKGNsaWVudFJlY3QsIGNsaWVudFgpKTtcbiAgICAgIGlmIChuZXdEaXN0YW5jZSA9PT0gb2xkRGlzdGFuY2UgJiYgaXNOb2RlQ2xpZW50UmVjdChjbGllbnRSZWN0KSAmJiBpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJDMoY2xpZW50UmVjdC5ub2RlKSkge1xuICAgICAgICByZXR1cm4gY2xpZW50UmVjdDtcbiAgICAgIH1cbiAgICAgIGlmIChuZXdEaXN0YW5jZSA8IG9sZERpc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiBjbGllbnRSZWN0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9sZENsaWVudFJlY3Q7XG4gICAgfSk7XG5cbiAgICBjb25zdCBnZXROb2RlQ2xpZW50UmVjdHMgPSBub2RlID0+IHtcbiAgICAgIGNvbnN0IHRvQXJyYXlXaXRoTm9kZSA9IGNsaWVudFJlY3RzID0+IHtcbiAgICAgICAgcmV0dXJuIG1hcCQzKGNsaWVudFJlY3RzLCByZWN0ID0+IHtcbiAgICAgICAgICBjb25zdCBjbGllbnRSZWN0ID0gY2xvbmUkMShyZWN0KTtcbiAgICAgICAgICBjbGllbnRSZWN0Lm5vZGUgPSBub2RlO1xuICAgICAgICAgIHJldHVybiBjbGllbnRSZWN0O1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBpZiAoaXNFbGVtZW50JDYobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIHRvQXJyYXlXaXRoTm9kZShub2RlLmdldENsaWVudFJlY3RzKCkpO1xuICAgICAgfSBlbHNlIGlmIChpc1RleHQkOChub2RlKSkge1xuICAgICAgICBjb25zdCBybmcgPSBub2RlLm93bmVyRG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgcm5nLnNldFN0YXJ0KG5vZGUsIDApO1xuICAgICAgICBybmcuc2V0RW5kKG5vZGUsIG5vZGUuZGF0YS5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gdG9BcnJheVdpdGhOb2RlKHJuZy5nZXRDbGllbnRSZWN0cygpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGdldENsaWVudFJlY3RzID0gbm9kZXMgPT4gYmluZCQzKG5vZGVzLCBnZXROb2RlQ2xpZW50UmVjdHMpO1xuXG4gICAgdmFyIFZEaXJlY3Rpb247XG4gICAgKGZ1bmN0aW9uIChWRGlyZWN0aW9uKSB7XG4gICAgICBWRGlyZWN0aW9uW1ZEaXJlY3Rpb25bJ1VwJ10gPSAtMV0gPSAnVXAnO1xuICAgICAgVkRpcmVjdGlvbltWRGlyZWN0aW9uWydEb3duJ10gPSAxXSA9ICdEb3duJztcbiAgICB9KFZEaXJlY3Rpb24gfHwgKFZEaXJlY3Rpb24gPSB7fSkpKTtcbiAgICBjb25zdCBmaW5kVW50aWwgPSAoZGlyZWN0aW9uLCByb290LCBwcmVkaWNhdGVGbiwgbm9kZSkgPT4ge1xuICAgICAgd2hpbGUgKG5vZGUgPSBmaW5kTm9kZShub2RlLCBkaXJlY3Rpb24sIGlzRWRpdGFibGVDYXJldENhbmRpZGF0ZSQxLCByb290KSkge1xuICAgICAgICBpZiAocHJlZGljYXRlRm4obm9kZSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHdhbGtVbnRpbCA9IChkaXJlY3Rpb24sIGlzQWJvdmVGbiwgaXNCZWZsb3dGbiwgcm9vdCwgcHJlZGljYXRlRm4sIGNhcmV0UG9zaXRpb24pID0+IHtcbiAgICAgIGxldCBsaW5lID0gMDtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgY29uc3QgYWRkID0gbm9kZSA9PiB7XG4gICAgICAgIGxldCBjbGllbnRSZWN0cyA9IGdldENsaWVudFJlY3RzKFtub2RlXSk7XG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT09IC0xKSB7XG4gICAgICAgICAgY2xpZW50UmVjdHMgPSBjbGllbnRSZWN0cy5yZXZlcnNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjbGllbnRSZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGNsaWVudFJlY3QgPSBjbGllbnRSZWN0c1tpXTtcbiAgICAgICAgICBpZiAoaXNCZWZsb3dGbihjbGllbnRSZWN0LCB0YXJnZXRDbGllbnRSZWN0KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCAmJiBpc0Fib3ZlRm4oY2xpZW50UmVjdCwgbGFzdCQyKHJlc3VsdCkpKSB7XG4gICAgICAgICAgICBsaW5lKys7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNsaWVudFJlY3QubGluZSA9IGxpbmU7XG4gICAgICAgICAgaWYgKHByZWRpY2F0ZUZuKGNsaWVudFJlY3QpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2goY2xpZW50UmVjdCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCB0YXJnZXRDbGllbnRSZWN0ID0gbGFzdCQyKGNhcmV0UG9zaXRpb24uZ2V0Q2xpZW50UmVjdHMoKSk7XG4gICAgICBpZiAoIXRhcmdldENsaWVudFJlY3QpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5vZGUgPSBjYXJldFBvc2l0aW9uLmdldE5vZGUoKTtcbiAgICAgIGFkZChub2RlKTtcbiAgICAgIGZpbmRVbnRpbChkaXJlY3Rpb24sIHJvb3QsIGFkZCwgbm9kZSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgY29uc3QgYWJvdmVMaW5lTnVtYmVyID0gKGxpbmVOdW1iZXIsIGNsaWVudFJlY3QpID0+IGNsaWVudFJlY3QubGluZSA+IGxpbmVOdW1iZXI7XG4gICAgY29uc3QgaXNMaW5lTnVtYmVyID0gKGxpbmVOdW1iZXIsIGNsaWVudFJlY3QpID0+IGNsaWVudFJlY3QubGluZSA9PT0gbGluZU51bWJlcjtcbiAgICBjb25zdCB1cFVudGlsID0gY3Vycnkod2Fsa1VudGlsLCBWRGlyZWN0aW9uLlVwLCBpc0Fib3ZlJDEsIGlzQmVsb3ckMSk7XG4gICAgY29uc3QgZG93blVudGlsID0gY3Vycnkod2Fsa1VudGlsLCBWRGlyZWN0aW9uLkRvd24sIGlzQmVsb3ckMSwgaXNBYm92ZSQxKTtcbiAgICBjb25zdCBwb3NpdGlvbnNVbnRpbCA9IChkaXJlY3Rpb24sIHJvb3QsIHByZWRpY2F0ZUZuLCBub2RlKSA9PiB7XG4gICAgICBjb25zdCBjYXJldFdhbGtlciA9IENhcmV0V2Fsa2VyKHJvb3QpO1xuICAgICAgbGV0IHdhbGtGbjtcbiAgICAgIGxldCBpc0JlbG93Rm47XG4gICAgICBsZXQgaXNBYm92ZUZuO1xuICAgICAgbGV0IGNhcmV0UG9zaXRpb247XG4gICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgIGxldCBsaW5lID0gMDtcbiAgICAgIGNvbnN0IGdldENsaWVudFJlY3QgPSBjYXJldFBvc2l0aW9uID0+IHtcbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gMSkge1xuICAgICAgICAgIHJldHVybiBsYXN0JDIoY2FyZXRQb3NpdGlvbi5nZXRDbGllbnRSZWN0cygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGFzdCQyKGNhcmV0UG9zaXRpb24uZ2V0Q2xpZW50UmVjdHMoKSk7XG4gICAgICB9O1xuICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gMSkge1xuICAgICAgICB3YWxrRm4gPSBjYXJldFdhbGtlci5uZXh0O1xuICAgICAgICBpc0JlbG93Rm4gPSBpc0JlbG93JDE7XG4gICAgICAgIGlzQWJvdmVGbiA9IGlzQWJvdmUkMTtcbiAgICAgICAgY2FyZXRQb3NpdGlvbiA9IENhcmV0UG9zaXRpb24uYWZ0ZXIobm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YWxrRm4gPSBjYXJldFdhbGtlci5wcmV2O1xuICAgICAgICBpc0JlbG93Rm4gPSBpc0Fib3ZlJDE7XG4gICAgICAgIGlzQWJvdmVGbiA9IGlzQmVsb3ckMTtcbiAgICAgICAgY2FyZXRQb3NpdGlvbiA9IENhcmV0UG9zaXRpb24uYmVmb3JlKG5vZGUpO1xuICAgICAgfVxuICAgICAgY29uc3QgdGFyZ2V0Q2xpZW50UmVjdCA9IGdldENsaWVudFJlY3QoY2FyZXRQb3NpdGlvbik7XG4gICAgICBkbyB7XG4gICAgICAgIGlmICghY2FyZXRQb3NpdGlvbi5pc1Zpc2libGUoKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlY3QgPSBnZXRDbGllbnRSZWN0KGNhcmV0UG9zaXRpb24pO1xuICAgICAgICBpZiAoaXNBYm92ZUZuKHJlY3QsIHRhcmdldENsaWVudFJlY3QpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiAwICYmIGlzQmVsb3dGbihyZWN0LCBsYXN0JDIocmVzdWx0KSkpIHtcbiAgICAgICAgICBsaW5lKys7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2xpZW50UmVjdCA9IGNsb25lJDEocmVjdCk7XG4gICAgICAgIGNsaWVudFJlY3QucG9zaXRpb24gPSBjYXJldFBvc2l0aW9uO1xuICAgICAgICBjbGllbnRSZWN0LmxpbmUgPSBsaW5lO1xuICAgICAgICBpZiAocHJlZGljYXRlRm4oY2xpZW50UmVjdCkpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKGNsaWVudFJlY3QpO1xuICAgICAgfSB3aGlsZSAoY2FyZXRQb3NpdGlvbiA9IHdhbGtGbihjYXJldFBvc2l0aW9uKSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgY29uc3QgaXNBYm92ZUxpbmUgPSBsaW5lTnVtYmVyID0+IGNsaWVudFJlY3QgPT4gYWJvdmVMaW5lTnVtYmVyKGxpbmVOdW1iZXIsIGNsaWVudFJlY3QpO1xuICAgIGNvbnN0IGlzTGluZSA9IGxpbmVOdW1iZXIgPT4gY2xpZW50UmVjdCA9PiBpc0xpbmVOdW1iZXIobGluZU51bWJlciwgY2xpZW50UmVjdCk7XG5cbiAgICBjb25zdCBtb3ZlVG9SYW5nZSA9IChlZGl0b3IsIHJuZykgPT4ge1xuICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZXRSbmcocm5nKTtcbiAgICAgIHNjcm9sbFJhbmdlSW50b1ZpZXcoZWRpdG9yLCBlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpKTtcbiAgICB9O1xuICAgIGNvbnN0IHJlbmRlclJhbmdlQ2FyZXRPcHQgPSAoZWRpdG9yLCByYW5nZSwgc2Nyb2xsSW50b1ZpZXcpID0+IE9wdGlvbmFsLnNvbWUocmVuZGVyUmFuZ2VDYXJldChlZGl0b3IsIHJhbmdlLCBzY3JvbGxJbnRvVmlldykpO1xuICAgIGNvbnN0IG1vdmVIb3Jpem9udGFsbHkgPSAoZWRpdG9yLCBkaXJlY3Rpb24sIHJhbmdlLCBpc0JlZm9yZSwgaXNBZnRlciwgaXNFbGVtZW50KSA9PiB7XG4gICAgICBjb25zdCBmb3J3YXJkcyA9IGRpcmVjdGlvbiA9PT0gSERpcmVjdGlvbi5Gb3J3YXJkcztcbiAgICAgIGNvbnN0IGNhcmV0V2Fsa2VyID0gQ2FyZXRXYWxrZXIoZWRpdG9yLmdldEJvZHkoKSk7XG4gICAgICBjb25zdCBnZXROZXh0UG9zRm4gPSBjdXJyeShnZXRWaXN1YWxDYXJldFBvc2l0aW9uLCBmb3J3YXJkcyA/IGNhcmV0V2Fsa2VyLm5leHQgOiBjYXJldFdhbGtlci5wcmV2KTtcbiAgICAgIGNvbnN0IGlzQmVmb3JlRm4gPSBmb3J3YXJkcyA/IGlzQmVmb3JlIDogaXNBZnRlcjtcbiAgICAgIGlmICghcmFuZ2UuY29sbGFwc2VkKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBnZXRTZWxlY3RlZE5vZGUocmFuZ2UpO1xuICAgICAgICBpZiAoaXNFbGVtZW50KG5vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIHNob3dDYXJldChkaXJlY3Rpb24sIGVkaXRvciwgbm9kZSwgZGlyZWN0aW9uID09PSBIRGlyZWN0aW9uLkJhY2t3YXJkcywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBjYXJldFBvc2l0aW9uID0gZ2V0Tm9ybWFsaXplZFJhbmdlRW5kUG9pbnQoZGlyZWN0aW9uLCBlZGl0b3IuZ2V0Qm9keSgpLCByYW5nZSk7XG4gICAgICBpZiAoaXNCZWZvcmVGbihjYXJldFBvc2l0aW9uKSkge1xuICAgICAgICByZXR1cm4gc2VsZWN0Tm9kZShlZGl0b3IsIGNhcmV0UG9zaXRpb24uZ2V0Tm9kZSghZm9yd2FyZHMpKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5leHRDYXJldFBvc2l0aW9uID0gbm9ybWFsaXplUG9zaXRpb24oZm9yd2FyZHMsIGdldE5leHRQb3NGbihjYXJldFBvc2l0aW9uKSk7XG4gICAgICBjb25zdCByYW5nZUlzSW5Db250YWluZXJCbG9jayA9IGlzUmFuZ2VJbkNhcmV0Q29udGFpbmVyQmxvY2socmFuZ2UpO1xuICAgICAgaWYgKCFuZXh0Q2FyZXRQb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gcmFuZ2VJc0luQ29udGFpbmVyQmxvY2sgPyBPcHRpb25hbC5zb21lKHJhbmdlKSA6IE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0JlZm9yZUZuKG5leHRDYXJldFBvc2l0aW9uKSkge1xuICAgICAgICByZXR1cm4gc2hvd0NhcmV0KGRpcmVjdGlvbiwgZWRpdG9yLCBuZXh0Q2FyZXRQb3NpdGlvbi5nZXROb2RlKCFmb3J3YXJkcyksIGZvcndhcmRzLCBmYWxzZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBwZWVrQ2FyZXRQb3NpdGlvbiA9IGdldE5leHRQb3NGbihuZXh0Q2FyZXRQb3NpdGlvbik7XG4gICAgICBpZiAocGVla0NhcmV0UG9zaXRpb24gJiYgaXNCZWZvcmVGbihwZWVrQ2FyZXRQb3NpdGlvbikpIHtcbiAgICAgICAgaWYgKGlzTW92ZUluc2lkZVNhbWVCbG9jayhuZXh0Q2FyZXRQb3NpdGlvbiwgcGVla0NhcmV0UG9zaXRpb24pKSB7XG4gICAgICAgICAgcmV0dXJuIHNob3dDYXJldChkaXJlY3Rpb24sIGVkaXRvciwgcGVla0NhcmV0UG9zaXRpb24uZ2V0Tm9kZSghZm9yd2FyZHMpLCBmb3J3YXJkcywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocmFuZ2VJc0luQ29udGFpbmVyQmxvY2spIHtcbiAgICAgICAgcmV0dXJuIHJlbmRlclJhbmdlQ2FyZXRPcHQoZWRpdG9yLCBuZXh0Q2FyZXRQb3NpdGlvbi50b1JhbmdlKCksIGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgfTtcbiAgICBjb25zdCBtb3ZlVmVydGljYWxseSA9IChlZGl0b3IsIGRpcmVjdGlvbiwgcmFuZ2UsIGlzQmVmb3JlLCBpc0FmdGVyLCBpc0VsZW1lbnQpID0+IHtcbiAgICAgIGNvbnN0IGNhcmV0UG9zaXRpb24gPSBnZXROb3JtYWxpemVkUmFuZ2VFbmRQb2ludChkaXJlY3Rpb24sIGVkaXRvci5nZXRCb2R5KCksIHJhbmdlKTtcbiAgICAgIGNvbnN0IGNhcmV0Q2xpZW50UmVjdCA9IGxhc3QkMihjYXJldFBvc2l0aW9uLmdldENsaWVudFJlY3RzKCkpO1xuICAgICAgY29uc3QgZm9yd2FyZHMgPSBkaXJlY3Rpb24gPT09IFZEaXJlY3Rpb24uRG93bjtcbiAgICAgIGlmICghY2FyZXRDbGllbnRSZWN0KSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9XG4gICAgICBjb25zdCB3YWxrZXJGbiA9IGZvcndhcmRzID8gZG93blVudGlsIDogdXBVbnRpbDtcbiAgICAgIGNvbnN0IGxpbmVQb3NpdGlvbnMgPSB3YWxrZXJGbihlZGl0b3IuZ2V0Qm9keSgpLCBpc0Fib3ZlTGluZSgxKSwgY2FyZXRQb3NpdGlvbik7XG4gICAgICBjb25zdCBuZXh0TGluZVBvc2l0aW9ucyA9IGZpbHRlciQ2KGxpbmVQb3NpdGlvbnMsIGlzTGluZSgxKSk7XG4gICAgICBjb25zdCBjbGllbnRYID0gY2FyZXRDbGllbnRSZWN0LmxlZnQ7XG4gICAgICBjb25zdCBuZXh0TGluZVJlY3QgPSBmaW5kQ2xvc2VzdENsaWVudFJlY3QobmV4dExpbmVQb3NpdGlvbnMsIGNsaWVudFgpO1xuICAgICAgaWYgKG5leHRMaW5lUmVjdCAmJiBpc0VsZW1lbnQobmV4dExpbmVSZWN0Lm5vZGUpKSB7XG4gICAgICAgIGNvbnN0IGRpc3QxID0gTWF0aC5hYnMoY2xpZW50WCAtIG5leHRMaW5lUmVjdC5sZWZ0KTtcbiAgICAgICAgY29uc3QgZGlzdDIgPSBNYXRoLmFicyhjbGllbnRYIC0gbmV4dExpbmVSZWN0LnJpZ2h0KTtcbiAgICAgICAgcmV0dXJuIHNob3dDYXJldChkaXJlY3Rpb24sIGVkaXRvciwgbmV4dExpbmVSZWN0Lm5vZGUsIGRpc3QxIDwgZGlzdDIsIGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIGxldCBjdXJyZW50Tm9kZTtcbiAgICAgIGlmIChpc0JlZm9yZShjYXJldFBvc2l0aW9uKSkge1xuICAgICAgICBjdXJyZW50Tm9kZSA9IGNhcmV0UG9zaXRpb24uZ2V0Tm9kZSgpO1xuICAgICAgfSBlbHNlIGlmIChpc0FmdGVyKGNhcmV0UG9zaXRpb24pKSB7XG4gICAgICAgIGN1cnJlbnROb2RlID0gY2FyZXRQb3NpdGlvbi5nZXROb2RlKHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudE5vZGUgPSBnZXRTZWxlY3RlZE5vZGUocmFuZ2UpO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnROb2RlKSB7XG4gICAgICAgIGNvbnN0IGNhcmV0UG9zaXRpb25zID0gcG9zaXRpb25zVW50aWwoZGlyZWN0aW9uLCBlZGl0b3IuZ2V0Qm9keSgpLCBpc0Fib3ZlTGluZSgxKSwgY3VycmVudE5vZGUpO1xuICAgICAgICBsZXQgY2xvc2VzdE5leHRMaW5lUmVjdCA9IGZpbmRDbG9zZXN0Q2xpZW50UmVjdChmaWx0ZXIkNihjYXJldFBvc2l0aW9ucywgaXNMaW5lKDEpKSwgY2xpZW50WCk7XG4gICAgICAgIGlmIChjbG9zZXN0TmV4dExpbmVSZWN0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlbmRlclJhbmdlQ2FyZXRPcHQoZWRpdG9yLCBjbG9zZXN0TmV4dExpbmVSZWN0LnBvc2l0aW9uLnRvUmFuZ2UoKSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGNsb3Nlc3ROZXh0TGluZVJlY3QgPSBsYXN0JDIoZmlsdGVyJDYoY2FyZXRQb3NpdGlvbnMsIGlzTGluZSgwKSkpO1xuICAgICAgICBpZiAoY2xvc2VzdE5leHRMaW5lUmVjdCkge1xuICAgICAgICAgIHJldHVybiByZW5kZXJSYW5nZUNhcmV0T3B0KGVkaXRvciwgY2xvc2VzdE5leHRMaW5lUmVjdC5wb3NpdGlvbi50b1JhbmdlKCksIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5leHRMaW5lUG9zaXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZ2V0TGluZUVuZFBvaW50KGVkaXRvciwgZm9yd2FyZHMpLmZpbHRlcihmb3J3YXJkcyA/IGlzQWZ0ZXIgOiBpc0JlZm9yZSkubWFwKHBvcyA9PiByZW5kZXJSYW5nZUNhcmV0KGVkaXRvciwgcG9zLnRvUmFuZ2UoKSwgZmFsc2UpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgfTtcbiAgICBjb25zdCBnZXRMaW5lRW5kUG9pbnQgPSAoZWRpdG9yLCBmb3J3YXJkKSA9PiB7XG4gICAgICBjb25zdCBybmcgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpO1xuICAgICAgY29uc3QgZnJvbSA9IGZvcndhcmQgPyBDYXJldFBvc2l0aW9uLmZyb21SYW5nZUVuZChybmcpIDogQ2FyZXRQb3NpdGlvbi5mcm9tUmFuZ2VTdGFydChybmcpO1xuICAgICAgY29uc3QgaG9zdCA9IGdldEVkaXRpbmdIb3N0KGZyb20uY29udGFpbmVyKCksIGVkaXRvci5nZXRCb2R5KCkpO1xuICAgICAgaWYgKGZvcndhcmQpIHtcbiAgICAgICAgY29uc3QgbGluZUluZm8gPSBnZXRQb3NpdGlvbnNVbnRpbE5leHRMaW5lKGhvc3QsIGZyb20pO1xuICAgICAgICByZXR1cm4gbGFzdCQzKGxpbmVJbmZvLnBvc2l0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBsaW5lSW5mbyA9IGdldFBvc2l0aW9uc1VudGlsUHJldmlvdXNMaW5lKGhvc3QsIGZyb20pO1xuICAgICAgICByZXR1cm4gaGVhZChsaW5lSW5mby5wb3NpdGlvbnMpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgbW92ZVRvTGluZUVuZFBvaW50JDMgPSAoZWRpdG9yLCBmb3J3YXJkLCBpc0VsZW1lbnRQb3NpdGlvbikgPT4gZ2V0TGluZUVuZFBvaW50KGVkaXRvciwgZm9yd2FyZCkuZmlsdGVyKGlzRWxlbWVudFBvc2l0aW9uKS5leGlzdHMocG9zID0+IHtcbiAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2V0Um5nKHBvcy50b1JhbmdlKCkpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG5cbiAgICBjb25zdCBzZXRDYXJldFBvc2l0aW9uID0gKGVkaXRvciwgcG9zKSA9PiB7XG4gICAgICBjb25zdCBybmcgPSBlZGl0b3IuZG9tLmNyZWF0ZVJuZygpO1xuICAgICAgcm5nLnNldFN0YXJ0KHBvcy5jb250YWluZXIoKSwgcG9zLm9mZnNldCgpKTtcbiAgICAgIHJuZy5zZXRFbmQocG9zLmNvbnRhaW5lcigpLCBwb3Mub2Zmc2V0KCkpO1xuICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZXRSbmcocm5nKTtcbiAgICB9O1xuICAgIGNvbnN0IHNldFNlbGVjdGVkID0gKHN0YXRlLCBlbG0pID0+IHtcbiAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICBlbG0uc2V0QXR0cmlidXRlKCdkYXRhLW1jZS1zZWxlY3RlZCcsICdpbmxpbmUtYm91bmRhcnknKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtbWNlLXNlbGVjdGVkJyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCByZW5kZXJDYXJldExvY2F0aW9uID0gKGVkaXRvciwgY2FyZXQsIGxvY2F0aW9uKSA9PiByZW5kZXJDYXJldChjYXJldCwgbG9jYXRpb24pLm1hcChwb3MgPT4ge1xuICAgICAgc2V0Q2FyZXRQb3NpdGlvbihlZGl0b3IsIHBvcyk7XG4gICAgICByZXR1cm4gbG9jYXRpb247XG4gICAgfSk7XG4gICAgY29uc3QgZmluZExvY2F0aW9uID0gKGVkaXRvciwgY2FyZXQsIGZvcndhcmQpID0+IHtcbiAgICAgIGNvbnN0IHJvb3ROb2RlID0gZWRpdG9yLmdldEJvZHkoKTtcbiAgICAgIGNvbnN0IGZyb20gPSBDYXJldFBvc2l0aW9uLmZyb21SYW5nZVN0YXJ0KGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCkpO1xuICAgICAgY29uc3QgaXNJbmxpbmVUYXJnZXQkMSA9IGN1cnJ5KGlzSW5saW5lVGFyZ2V0LCBlZGl0b3IpO1xuICAgICAgY29uc3QgbG9jYXRpb24gPSBmaW5kTG9jYXRpb24kMShmb3J3YXJkLCBpc0lubGluZVRhcmdldCQxLCByb290Tm9kZSwgZnJvbSk7XG4gICAgICByZXR1cm4gbG9jYXRpb24uYmluZChsb2NhdGlvbiA9PiByZW5kZXJDYXJldExvY2F0aW9uKGVkaXRvciwgY2FyZXQsIGxvY2F0aW9uKSk7XG4gICAgfTtcbiAgICBjb25zdCB0b2dnbGVJbmxpbmVzID0gKGlzSW5saW5lVGFyZ2V0LCBkb20sIGVsbXMpID0+IHtcbiAgICAgIGNvbnN0IGlubGluZUJvdW5kYXJpZXMgPSBtYXAkMyhkZXNjZW5kYW50cyhTdWdhckVsZW1lbnQuZnJvbURvbShkb20uZ2V0Um9vdCgpKSwgJypbZGF0YS1tY2Utc2VsZWN0ZWQ9XCJpbmxpbmUtYm91bmRhcnlcIl0nKSwgZSA9PiBlLmRvbSk7XG4gICAgICBjb25zdCBzZWxlY3RlZElubGluZXMgPSBmaWx0ZXIkNihpbmxpbmVCb3VuZGFyaWVzLCBpc0lubGluZVRhcmdldCk7XG4gICAgICBjb25zdCB0YXJnZXRJbmxpbmVzID0gZmlsdGVyJDYoZWxtcywgaXNJbmxpbmVUYXJnZXQpO1xuICAgICAgZWFjaCRnKGRpZmZlcmVuY2Uoc2VsZWN0ZWRJbmxpbmVzLCB0YXJnZXRJbmxpbmVzKSwgY3Vycnkoc2V0U2VsZWN0ZWQsIGZhbHNlKSk7XG4gICAgICBlYWNoJGcoZGlmZmVyZW5jZSh0YXJnZXRJbmxpbmVzLCBzZWxlY3RlZElubGluZXMpLCBjdXJyeShzZXRTZWxlY3RlZCwgdHJ1ZSkpO1xuICAgIH07XG4gICAgY29uc3Qgc2FmZVJlbW92ZUNhcmV0Q29udGFpbmVyID0gKGVkaXRvciwgY2FyZXQpID0+IHtcbiAgICAgIGlmIChlZGl0b3Iuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgJiYgZWRpdG9yLmNvbXBvc2luZyAhPT0gdHJ1ZSAmJiBjYXJldC5nZXQoKSkge1xuICAgICAgICBjb25zdCBwb3MgPSBDYXJldFBvc2l0aW9uLmZyb21SYW5nZVN0YXJ0KGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCkpO1xuICAgICAgICBpZiAoQ2FyZXRQb3NpdGlvbi5pc1RleHRQb3NpdGlvbihwb3MpICYmIGlzQXRad3NwKHBvcykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgc2V0Q2FyZXRQb3NpdGlvbihlZGl0b3IsIHJlbW92ZUFuZFJlcG9zaXRpb24oY2FyZXQuZ2V0KCksIHBvcykpO1xuICAgICAgICAgIGNhcmV0LnNldChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcmVuZGVySW5zaWRlSW5saW5lQ2FyZXQgPSAoaXNJbmxpbmVUYXJnZXQsIGVkaXRvciwgY2FyZXQsIGVsbXMpID0+IHtcbiAgICAgIGlmIChlZGl0b3Iuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgICAgY29uc3QgaW5saW5lcyA9IGZpbHRlciQ2KGVsbXMsIGlzSW5saW5lVGFyZ2V0KTtcbiAgICAgICAgZWFjaCRnKGlubGluZXMsIF9pbmxpbmUgPT4ge1xuICAgICAgICAgIGNvbnN0IHBvcyA9IENhcmV0UG9zaXRpb24uZnJvbVJhbmdlU3RhcnQoZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKSk7XG4gICAgICAgICAgcmVhZExvY2F0aW9uKGlzSW5saW5lVGFyZ2V0LCBlZGl0b3IuZ2V0Qm9keSgpLCBwb3MpLmJpbmQobG9jYXRpb24gPT4gcmVuZGVyQ2FyZXRMb2NhdGlvbihlZGl0b3IsIGNhcmV0LCBsb2NhdGlvbikpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG1vdmUkMiA9IChlZGl0b3IsIGNhcmV0LCBmb3J3YXJkKSA9PiBpc0lubGluZUJvdW5kYXJpZXNFbmFibGVkKGVkaXRvcikgPyBmaW5kTG9jYXRpb24oZWRpdG9yLCBjYXJldCwgZm9yd2FyZCkuaXNTb21lKCkgOiBmYWxzZTtcbiAgICBjb25zdCBtb3ZlV29yZCA9IChmb3J3YXJkLCBlZGl0b3IsIF9jYXJldCkgPT4gaXNJbmxpbmVCb3VuZGFyaWVzRW5hYmxlZChlZGl0b3IpID8gbW92ZUJ5V29yZChmb3J3YXJkLCBlZGl0b3IpIDogZmFsc2U7XG4gICAgY29uc3Qgc2V0dXBTZWxlY3RlZFN0YXRlID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IGNhcmV0ID0gQ2VsbChudWxsKTtcbiAgICAgIGNvbnN0IGlzSW5saW5lVGFyZ2V0JDEgPSBjdXJyeShpc0lubGluZVRhcmdldCwgZWRpdG9yKTtcbiAgICAgIGVkaXRvci5vbignTm9kZUNoYW5nZScsIGUgPT4ge1xuICAgICAgICBpZiAoaXNJbmxpbmVCb3VuZGFyaWVzRW5hYmxlZChlZGl0b3IpKSB7XG4gICAgICAgICAgdG9nZ2xlSW5saW5lcyhpc0lubGluZVRhcmdldCQxLCBlZGl0b3IuZG9tLCBlLnBhcmVudHMpO1xuICAgICAgICAgIHNhZmVSZW1vdmVDYXJldENvbnRhaW5lcihlZGl0b3IsIGNhcmV0KTtcbiAgICAgICAgICByZW5kZXJJbnNpZGVJbmxpbmVDYXJldChpc0lubGluZVRhcmdldCQxLCBlZGl0b3IsIGNhcmV0LCBlLnBhcmVudHMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjYXJldDtcbiAgICB9O1xuICAgIGNvbnN0IG1vdmVOZXh0V29yZCA9IGN1cnJ5KG1vdmVXb3JkLCB0cnVlKTtcbiAgICBjb25zdCBtb3ZlUHJldldvcmQgPSBjdXJyeShtb3ZlV29yZCwgZmFsc2UpO1xuICAgIGNvbnN0IG1vdmVUb0xpbmVFbmRQb2ludCQyID0gKGVkaXRvciwgZm9yd2FyZCwgY2FyZXQpID0+IHtcbiAgICAgIGlmIChpc0lubGluZUJvdW5kYXJpZXNFbmFibGVkKGVkaXRvcikpIHtcbiAgICAgICAgY29uc3QgbGluZVBvaW50ID0gZ2V0TGluZUVuZFBvaW50KGVkaXRvciwgZm9yd2FyZCkuZ2V0T3JUaHVuaygoKSA9PiB7XG4gICAgICAgICAgY29uc3Qgcm5nID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKTtcbiAgICAgICAgICByZXR1cm4gZm9yd2FyZCA/IENhcmV0UG9zaXRpb24uZnJvbVJhbmdlRW5kKHJuZykgOiBDYXJldFBvc2l0aW9uLmZyb21SYW5nZVN0YXJ0KHJuZyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVhZExvY2F0aW9uKGN1cnJ5KGlzSW5saW5lVGFyZ2V0LCBlZGl0b3IpLCBlZGl0b3IuZ2V0Qm9keSgpLCBsaW5lUG9pbnQpLmV4aXN0cyhsb2MgPT4ge1xuICAgICAgICAgIGNvbnN0IG91dHNpZGVMb2MgPSBvdXRzaWRlKGxvYyk7XG4gICAgICAgICAgcmV0dXJuIHJlbmRlckNhcmV0KGNhcmV0LCBvdXRzaWRlTG9jKS5leGlzdHMocG9zID0+IHtcbiAgICAgICAgICAgIHNldENhcmV0UG9zaXRpb24oZWRpdG9yLCBwb3MpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCByYW5nZUZyb21Qb3NpdGlvbnMgPSAoZnJvbSwgdG8pID0+IHtcbiAgICAgIGNvbnN0IHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgIHJhbmdlLnNldFN0YXJ0KGZyb20uY29udGFpbmVyKCksIGZyb20ub2Zmc2V0KCkpO1xuICAgICAgcmFuZ2Uuc2V0RW5kKHRvLmNvbnRhaW5lcigpLCB0by5vZmZzZXQoKSk7XG4gICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfTtcbiAgICBjb25zdCBoYXNPbmx5VHdvT3JMZXNzUG9zaXRpb25zTGVmdCA9IGVsbSA9PiBsaWZ0MihmaXJzdFBvc2l0aW9uSW4oZWxtKSwgbGFzdFBvc2l0aW9uSW4oZWxtKSwgKGZpcnN0UG9zLCBsYXN0UG9zKSA9PiB7XG4gICAgICBjb25zdCBub3JtYWxpemVkRmlyc3RQb3MgPSBub3JtYWxpemVQb3NpdGlvbih0cnVlLCBmaXJzdFBvcyk7XG4gICAgICBjb25zdCBub3JtYWxpemVkTGFzdFBvcyA9IG5vcm1hbGl6ZVBvc2l0aW9uKGZhbHNlLCBsYXN0UG9zKTtcbiAgICAgIHJldHVybiBuZXh0UG9zaXRpb24oZWxtLCBub3JtYWxpemVkRmlyc3RQb3MpLmZvcmFsbChwb3MgPT4gcG9zLmlzRXF1YWwobm9ybWFsaXplZExhc3RQb3MpKTtcbiAgICB9KS5nZXRPcih0cnVlKTtcbiAgICBjb25zdCBzZXRDYXJldExvY2F0aW9uID0gKGVkaXRvciwgY2FyZXQpID0+IGxvY2F0aW9uID0+IHJlbmRlckNhcmV0KGNhcmV0LCBsb2NhdGlvbikubWFwKHBvcyA9PiAoKSA9PiBzZXRDYXJldFBvc2l0aW9uKGVkaXRvciwgcG9zKSk7XG4gICAgY29uc3QgZGVsZXRlRnJvbVRvID0gKGVkaXRvciwgY2FyZXQsIGZyb20sIHRvKSA9PiB7XG4gICAgICBjb25zdCByb290Tm9kZSA9IGVkaXRvci5nZXRCb2R5KCk7XG4gICAgICBjb25zdCBpc0lubGluZVRhcmdldCQxID0gY3VycnkoaXNJbmxpbmVUYXJnZXQsIGVkaXRvcik7XG4gICAgICBlZGl0b3IudW5kb01hbmFnZXIuaWdub3JlKCgpID0+IHtcbiAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZXRSbmcocmFuZ2VGcm9tUG9zaXRpb25zKGZyb20sIHRvKSk7XG4gICAgICAgIGV4ZWNEZWxldGVDb21tYW5kKGVkaXRvcik7XG4gICAgICAgIHJlYWRMb2NhdGlvbihpc0lubGluZVRhcmdldCQxLCByb290Tm9kZSwgQ2FyZXRQb3NpdGlvbi5mcm9tUmFuZ2VTdGFydChlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpKSkubWFwKGluc2lkZSkuYmluZChzZXRDYXJldExvY2F0aW9uKGVkaXRvciwgY2FyZXQpKS5lYWNoKGNhbGwpO1xuICAgICAgfSk7XG4gICAgICBlZGl0b3Iubm9kZUNoYW5nZWQoKTtcbiAgICB9O1xuICAgIGNvbnN0IHJlc2NvcGUgPSAocm9vdE5vZGUsIG5vZGUpID0+IHtcbiAgICAgIGNvbnN0IHBhcmVudEJsb2NrID0gZ2V0UGFyZW50QmxvY2skMyhub2RlLCByb290Tm9kZSk7XG4gICAgICByZXR1cm4gcGFyZW50QmxvY2sgPyBwYXJlbnRCbG9jayA6IHJvb3ROb2RlO1xuICAgIH07XG4gICAgY29uc3QgYmFja3NwYWNlRGVsZXRlQ29sbGFwc2VkID0gKGVkaXRvciwgY2FyZXQsIGZvcndhcmQsIGZyb20pID0+IHtcbiAgICAgIGNvbnN0IHJvb3ROb2RlID0gcmVzY29wZShlZGl0b3IuZ2V0Qm9keSgpLCBmcm9tLmNvbnRhaW5lcigpKTtcbiAgICAgIGNvbnN0IGlzSW5saW5lVGFyZ2V0JDEgPSBjdXJyeShpc0lubGluZVRhcmdldCwgZWRpdG9yKTtcbiAgICAgIGNvbnN0IGZyb21Mb2NhdGlvbiA9IHJlYWRMb2NhdGlvbihpc0lubGluZVRhcmdldCQxLCByb290Tm9kZSwgZnJvbSk7XG4gICAgICBjb25zdCBsb2NhdGlvbiA9IGZyb21Mb2NhdGlvbi5iaW5kKGxvY2F0aW9uID0+IHtcbiAgICAgICAgaWYgKGZvcndhcmQpIHtcbiAgICAgICAgICByZXR1cm4gbG9jYXRpb24uZm9sZChjb25zdGFudChPcHRpb25hbC5zb21lKGluc2lkZShsb2NhdGlvbikpKSwgT3B0aW9uYWwubm9uZSwgY29uc3RhbnQoT3B0aW9uYWwuc29tZShvdXRzaWRlKGxvY2F0aW9uKSkpLCBPcHRpb25hbC5ub25lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbG9jYXRpb24uZm9sZChPcHRpb25hbC5ub25lLCBjb25zdGFudChPcHRpb25hbC5zb21lKG91dHNpZGUobG9jYXRpb24pKSksIE9wdGlvbmFsLm5vbmUsIGNvbnN0YW50KE9wdGlvbmFsLnNvbWUoaW5zaWRlKGxvY2F0aW9uKSkpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbG9jYXRpb24ubWFwKHNldENhcmV0TG9jYXRpb24oZWRpdG9yLCBjYXJldCkpLmdldE9yVGh1bmsoKCkgPT4ge1xuICAgICAgICBjb25zdCB0b1Bvc2l0aW9uID0gbmF2aWdhdGUoZm9yd2FyZCwgcm9vdE5vZGUsIGZyb20pO1xuICAgICAgICBjb25zdCB0b0xvY2F0aW9uID0gdG9Qb3NpdGlvbi5iaW5kKHBvcyA9PiByZWFkTG9jYXRpb24oaXNJbmxpbmVUYXJnZXQkMSwgcm9vdE5vZGUsIHBvcykpO1xuICAgICAgICByZXR1cm4gbGlmdDIoZnJvbUxvY2F0aW9uLCB0b0xvY2F0aW9uLCAoKSA9PiBmaW5kUm9vdElubGluZShpc0lubGluZVRhcmdldCQxLCByb290Tm9kZSwgZnJvbSkuYmluZChlbG0gPT4ge1xuICAgICAgICAgIGlmIChoYXNPbmx5VHdvT3JMZXNzUG9zaXRpb25zTGVmdChlbG0pKSB7XG4gICAgICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZSgoKSA9PiB7XG4gICAgICAgICAgICAgIGRlbGV0ZUVsZW1lbnQkMihlZGl0b3IsIGZvcndhcmQsIFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVsbSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSkuZ2V0T3JUaHVuaygoKSA9PiB0b0xvY2F0aW9uLmJpbmQoKCkgPT4gdG9Qb3NpdGlvbi5tYXAodG8gPT4ge1xuICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoZm9yd2FyZCkge1xuICAgICAgICAgICAgICBkZWxldGVGcm9tVG8oZWRpdG9yLCBjYXJldCwgZnJvbSwgdG8pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZGVsZXRlRnJvbVRvKGVkaXRvciwgY2FyZXQsIHRvLCBmcm9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9KSkpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBiYWNrc3BhY2VEZWxldGUkMyA9IChlZGl0b3IsIGNhcmV0LCBmb3J3YXJkKSA9PiB7XG4gICAgICBpZiAoZWRpdG9yLnNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpICYmIGlzSW5saW5lQm91bmRhcmllc0VuYWJsZWQoZWRpdG9yKSkge1xuICAgICAgICBjb25zdCBmcm9tID0gQ2FyZXRQb3NpdGlvbi5mcm9tUmFuZ2VTdGFydChlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpKTtcbiAgICAgICAgcmV0dXJuIGJhY2tzcGFjZURlbGV0ZUNvbGxhcHNlZChlZGl0b3IsIGNhcmV0LCBmb3J3YXJkLCBmcm9tKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgfTtcblxuICAgIGNvbnN0IGdldFBhcmVudElubGluZXMgPSAocm9vdEVsbSwgc3RhcnRFbG0pID0+IHtcbiAgICAgIGNvbnN0IHBhcmVudHMgPSBwYXJlbnRzQW5kU2VsZihzdGFydEVsbSwgcm9vdEVsbSk7XG4gICAgICByZXR1cm4gZmluZEluZGV4JDIocGFyZW50cywgaXNCbG9jayQyKS5mb2xkKGNvbnN0YW50KHBhcmVudHMpLCBpbmRleCA9PiBwYXJlbnRzLnNsaWNlKDAsIGluZGV4KSk7XG4gICAgfTtcbiAgICBjb25zdCBoYXNPbmx5T25lQ2hpbGQgPSBlbG0gPT4gY2hpbGROb2Rlc0NvdW50KGVsbSkgPT09IDE7XG4gICAgY29uc3QgZGVsZXRlTGFzdFBvc2l0aW9uID0gKGZvcndhcmQsIGVkaXRvciwgdGFyZ2V0LCBwYXJlbnRJbmxpbmVzKSA9PiB7XG4gICAgICBjb25zdCBpc0Zvcm1hdEVsZW1lbnQkMSA9IGN1cnJ5KGlzRm9ybWF0RWxlbWVudCwgZWRpdG9yKTtcbiAgICAgIGNvbnN0IGZvcm1hdE5vZGVzID0gbWFwJDMoZmlsdGVyJDYocGFyZW50SW5saW5lcywgaXNGb3JtYXRFbGVtZW50JDEpLCBlbG0gPT4gZWxtLmRvbSk7XG4gICAgICBpZiAoZm9ybWF0Tm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGRlbGV0ZUVsZW1lbnQkMihlZGl0b3IsIGZvcndhcmQsIHRhcmdldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBwb3MgPSByZXBsYWNlV2l0aENhcmV0Rm9ybWF0KHRhcmdldC5kb20sIGZvcm1hdE5vZGVzKTtcbiAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZXRSbmcocG9zLnRvUmFuZ2UoKSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBkZWxldGVDYXJldCQxID0gKGVkaXRvciwgZm9yd2FyZCkgPT4ge1xuICAgICAgY29uc3Qgcm9vdEVsbSA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVkaXRvci5nZXRCb2R5KCkpO1xuICAgICAgY29uc3Qgc3RhcnRFbG0gPSBTdWdhckVsZW1lbnQuZnJvbURvbShlZGl0b3Iuc2VsZWN0aW9uLmdldFN0YXJ0KCkpO1xuICAgICAgY29uc3QgcGFyZW50SW5saW5lcyA9IGZpbHRlciQ2KGdldFBhcmVudElubGluZXMocm9vdEVsbSwgc3RhcnRFbG0pLCBoYXNPbmx5T25lQ2hpbGQpO1xuICAgICAgcmV0dXJuIGxhc3QkMyhwYXJlbnRJbmxpbmVzKS5iaW5kKHRhcmdldCA9PiB7XG4gICAgICAgIGNvbnN0IGZyb21Qb3MgPSBDYXJldFBvc2l0aW9uLmZyb21SYW5nZVN0YXJ0KGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCkpO1xuICAgICAgICBpZiAod2lsbERlbGV0ZUxhc3RQb3NpdGlvbkluRWxlbWVudChmb3J3YXJkLCBmcm9tUG9zLCB0YXJnZXQuZG9tKSAmJiAhaXNFbXB0eUNhcmV0Rm9ybWF0RWxlbWVudCh0YXJnZXQpKSB7XG4gICAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoKCkgPT4gZGVsZXRlTGFzdFBvc2l0aW9uKGZvcndhcmQsIGVkaXRvciwgdGFyZ2V0LCBwYXJlbnRJbmxpbmVzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBiYWNrc3BhY2VEZWxldGUkMiA9IChlZGl0b3IsIGZvcndhcmQpID0+IGVkaXRvci5zZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSA/IGRlbGV0ZUNhcmV0JDEoZWRpdG9yLCBmb3J3YXJkKSA6IE9wdGlvbmFsLm5vbmUoKTtcblxuICAgIGNvbnN0IGRlbGV0ZUVsZW1lbnQgPSAoZWRpdG9yLCBmb3J3YXJkLCBlbGVtZW50KSA9PiB7XG4gICAgICByZXR1cm4gT3B0aW9uYWwuc29tZSgoKSA9PiB7XG4gICAgICAgIGVkaXRvci5fc2VsZWN0aW9uT3ZlcnJpZGVzLmhpZGVGYWtlQ2FyZXQoKTtcbiAgICAgICAgZGVsZXRlRWxlbWVudCQyKGVkaXRvciwgZm9yd2FyZCwgU3VnYXJFbGVtZW50LmZyb21Eb20oZWxlbWVudCkpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBkZWxldGVDYXJldCA9IChlZGl0b3IsIGZvcndhcmQpID0+IHtcbiAgICAgIGNvbnN0IGlzTmVhck1lZGlhID0gZm9yd2FyZCA/IGlzQmVmb3JlTWVkaWEgOiBpc0FmdGVyTWVkaWE7XG4gICAgICBjb25zdCBkaXJlY3Rpb24gPSBmb3J3YXJkID8gSERpcmVjdGlvbi5Gb3J3YXJkcyA6IEhEaXJlY3Rpb24uQmFja3dhcmRzO1xuICAgICAgY29uc3QgZnJvbVBvcyA9IGdldE5vcm1hbGl6ZWRSYW5nZUVuZFBvaW50KGRpcmVjdGlvbiwgZWRpdG9yLmdldEJvZHkoKSwgZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKSk7XG4gICAgICBpZiAoaXNOZWFyTWVkaWEoZnJvbVBvcykpIHtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZUVsZW1lbnQoZWRpdG9yLCBmb3J3YXJkLCBmcm9tUG9zLmdldE5vZGUoIWZvcndhcmQpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5mcm9tKG5vcm1hbGl6ZVBvc2l0aW9uKGZvcndhcmQsIGZyb21Qb3MpKS5maWx0ZXIocG9zID0+IGlzTmVhck1lZGlhKHBvcykgJiYgaXNNb3ZlSW5zaWRlU2FtZUJsb2NrKGZyb21Qb3MsIHBvcykpLm1hcChwb3MgPT4gKCkgPT4gZGVsZXRlRWxlbWVudChlZGl0b3IsIGZvcndhcmQsIHBvcy5nZXROb2RlKCFmb3J3YXJkKSkpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZGVsZXRlUmFuZ2UgPSAoZWRpdG9yLCBmb3J3YXJkKSA9PiB7XG4gICAgICBjb25zdCBzZWxlY3RlZE5vZGUgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldE5vZGUoKTtcbiAgICAgIHJldHVybiBpc01lZGlhJDIoc2VsZWN0ZWROb2RlKSA/IGRlbGV0ZUVsZW1lbnQoZWRpdG9yLCBmb3J3YXJkLCBzZWxlY3RlZE5vZGUpIDogT3B0aW9uYWwubm9uZSgpO1xuICAgIH07XG4gICAgY29uc3QgYmFja3NwYWNlRGVsZXRlJDEgPSAoZWRpdG9yLCBmb3J3YXJkKSA9PiBlZGl0b3Iuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgPyBkZWxldGVDYXJldChlZGl0b3IsIGZvcndhcmQpIDogZGVsZXRlUmFuZ2UoZWRpdG9yLCBmb3J3YXJkKTtcblxuICAgIGNvbnN0IGlzRWRpdGFibGUkMSA9IHRhcmdldCA9PiBjbG9zZXN0JDQodGFyZ2V0LCBlbG0gPT4gaXNDb250ZW50RWRpdGFibGVUcnVlJDQoZWxtLmRvbSkgfHwgaXNDb250ZW50RWRpdGFibGVGYWxzZSRhKGVsbS5kb20pKS5leGlzdHMoZWxtID0+IGlzQ29udGVudEVkaXRhYmxlVHJ1ZSQ0KGVsbS5kb20pKTtcbiAgICBjb25zdCBwYXJzZUluZGVudFZhbHVlID0gdmFsdWUgPT4ge1xuICAgICAgY29uc3QgbnVtYmVyID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICAgIHJldHVybiBpc05hTihudW1iZXIpID8gMCA6IG51bWJlcjtcbiAgICB9O1xuICAgIGNvbnN0IGdldEluZGVudFN0eWxlTmFtZSA9ICh1c2VNYXJnaW4sIGVsZW1lbnQpID0+IHtcbiAgICAgIGNvbnN0IGluZGVudFN0eWxlTmFtZSA9IHVzZU1hcmdpbiB8fCBpc1RhYmxlJDIoZWxlbWVudCkgPyAnbWFyZ2luJyA6ICdwYWRkaW5nJztcbiAgICAgIGNvbnN0IHN1ZmZpeCA9IGdldCQ3KGVsZW1lbnQsICdkaXJlY3Rpb24nKSA9PT0gJ3J0bCcgPyAnLXJpZ2h0JyA6ICctbGVmdCc7XG4gICAgICByZXR1cm4gaW5kZW50U3R5bGVOYW1lICsgc3VmZml4O1xuICAgIH07XG4gICAgY29uc3QgaW5kZW50RWxlbWVudCA9IChkb20sIGNvbW1hbmQsIHVzZU1hcmdpbiwgdmFsdWUsIHVuaXQsIGVsZW1lbnQpID0+IHtcbiAgICAgIGNvbnN0IGluZGVudFN0eWxlTmFtZSA9IGdldEluZGVudFN0eWxlTmFtZSh1c2VNYXJnaW4sIFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVsZW1lbnQpKTtcbiAgICAgIGlmIChjb21tYW5kID09PSAnb3V0ZGVudCcpIHtcbiAgICAgICAgY29uc3Qgc3R5bGVWYWx1ZSA9IE1hdGgubWF4KDAsIHBhcnNlSW5kZW50VmFsdWUoZWxlbWVudC5zdHlsZVtpbmRlbnRTdHlsZU5hbWVdKSAtIHZhbHVlKTtcbiAgICAgICAgZG9tLnNldFN0eWxlKGVsZW1lbnQsIGluZGVudFN0eWxlTmFtZSwgc3R5bGVWYWx1ZSA/IHN0eWxlVmFsdWUgKyB1bml0IDogJycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgc3R5bGVWYWx1ZSA9IHBhcnNlSW5kZW50VmFsdWUoZWxlbWVudC5zdHlsZVtpbmRlbnRTdHlsZU5hbWVdKSArIHZhbHVlICsgdW5pdDtcbiAgICAgICAgZG9tLnNldFN0eWxlKGVsZW1lbnQsIGluZGVudFN0eWxlTmFtZSwgc3R5bGVWYWx1ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCB2YWxpZGF0ZUJsb2NrcyA9IChlZGl0b3IsIGJsb2NrcykgPT4gZm9yYWxsKGJsb2NrcywgYmxvY2sgPT4ge1xuICAgICAgY29uc3QgaW5kZW50U3R5bGVOYW1lID0gZ2V0SW5kZW50U3R5bGVOYW1lKHNob3VsZEluZGVudFVzZU1hcmdpbihlZGl0b3IpLCBibG9jayk7XG4gICAgICBjb25zdCBpbnRlbnRWYWx1ZSA9IGdldFJhdyQxKGJsb2NrLCBpbmRlbnRTdHlsZU5hbWUpLm1hcChwYXJzZUluZGVudFZhbHVlKS5nZXRPcigwKTtcbiAgICAgIGNvbnN0IGNvbnRlbnRFZGl0YWJsZSA9IGVkaXRvci5kb20uZ2V0Q29udGVudEVkaXRhYmxlKGJsb2NrLmRvbSk7XG4gICAgICByZXR1cm4gY29udGVudEVkaXRhYmxlICE9PSAnZmFsc2UnICYmIGludGVudFZhbHVlID4gMDtcbiAgICB9KTtcbiAgICBjb25zdCBjYW5PdXRkZW50ID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IGJsb2NrcyA9IGdldEJsb2Nrc1RvSW5kZW50KGVkaXRvcik7XG4gICAgICByZXR1cm4gIWVkaXRvci5tb2RlLmlzUmVhZE9ubHkoKSAmJiAoYmxvY2tzLmxlbmd0aCA+IDEgfHwgdmFsaWRhdGVCbG9ja3MoZWRpdG9yLCBibG9ja3MpKTtcbiAgICB9O1xuICAgIGNvbnN0IGlzTGlzdENvbXBvbmVudCA9IGVsID0+IGlzTGlzdChlbCkgfHwgaXNMaXN0SXRlbShlbCk7XG4gICAgY29uc3QgcGFyZW50SXNMaXN0Q29tcG9uZW50ID0gZWwgPT4gcGFyZW50KGVsKS5leGlzdHMoaXNMaXN0Q29tcG9uZW50KTtcbiAgICBjb25zdCBnZXRCbG9ja3NUb0luZGVudCA9IGVkaXRvciA9PiBmaWx0ZXIkNihmcm9tRG9tJDEoZWRpdG9yLnNlbGVjdGlvbi5nZXRTZWxlY3RlZEJsb2NrcygpKSwgZWwgPT4gIWlzTGlzdENvbXBvbmVudChlbCkgJiYgIXBhcmVudElzTGlzdENvbXBvbmVudChlbCkgJiYgaXNFZGl0YWJsZSQxKGVsKSk7XG4gICAgY29uc3QgaGFuZGxlID0gKGVkaXRvciwgY29tbWFuZCkgPT4ge1xuICAgICAgY29uc3Qge2RvbX0gPSBlZGl0b3I7XG4gICAgICBjb25zdCBpbmRlbnRhdGlvbiA9IGdldEluZGVudGF0aW9uKGVkaXRvcik7XG4gICAgICBjb25zdCBpbmRlbnRVbml0ID0gL1thLXolXSskL2kuZXhlYyhpbmRlbnRhdGlvbilbMF07XG4gICAgICBjb25zdCBpbmRlbnRWYWx1ZSA9IHBhcnNlSW50KGluZGVudGF0aW9uLCAxMCk7XG4gICAgICBjb25zdCB1c2VNYXJnaW4gPSBzaG91bGRJbmRlbnRVc2VNYXJnaW4oZWRpdG9yKTtcbiAgICAgIGVhY2gkZyhnZXRCbG9ja3NUb0luZGVudChlZGl0b3IpLCBibG9jayA9PiB7XG4gICAgICAgIGluZGVudEVsZW1lbnQoZG9tLCBjb21tYW5kLCB1c2VNYXJnaW4sIGluZGVudFZhbHVlLCBpbmRlbnRVbml0LCBibG9jay5kb20pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBpbmRlbnQgPSBlZGl0b3IgPT4gaGFuZGxlKGVkaXRvciwgJ2luZGVudCcpO1xuICAgIGNvbnN0IG91dGRlbnQgPSBlZGl0b3IgPT4gaGFuZGxlKGVkaXRvciwgJ291dGRlbnQnKTtcblxuICAgIGNvbnN0IGJhY2tzcGFjZURlbGV0ZSA9IGVkaXRvciA9PiB7XG4gICAgICBpZiAoZWRpdG9yLnNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpICYmIGNhbk91dGRlbnQoZWRpdG9yKSkge1xuICAgICAgICBjb25zdCBkb20gPSBlZGl0b3IuZG9tO1xuICAgICAgICBjb25zdCBybmcgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpO1xuICAgICAgICBjb25zdCBwb3MgPSBDYXJldFBvc2l0aW9uLmZyb21SYW5nZVN0YXJ0KHJuZyk7XG4gICAgICAgIGNvbnN0IGJsb2NrID0gZG9tLmdldFBhcmVudChybmcuc3RhcnRDb250YWluZXIsIGRvbS5pc0Jsb2NrKTtcbiAgICAgICAgaWYgKGJsb2NrICE9PSBudWxsICYmIGlzQXRTdGFydE9mQmxvY2soU3VnYXJFbGVtZW50LmZyb21Eb20oYmxvY2spLCBwb3MpKSB7XG4gICAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoKCkgPT4gb3V0ZGVudChlZGl0b3IpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICB9O1xuXG4gICAgY29uc3QgZmluZEFjdGlvbiA9IChlZGl0b3IsIGNhcmV0LCBmb3J3YXJkKSA9PiBmaW5kTWFwKFtcbiAgICAgIGJhY2tzcGFjZURlbGV0ZSxcbiAgICAgIGJhY2tzcGFjZURlbGV0ZSQ1LFxuICAgICAgYmFja3NwYWNlRGVsZXRlJDYsXG4gICAgICAoZWRpdG9yLCBmb3J3YXJkKSA9PiBiYWNrc3BhY2VEZWxldGUkMyhlZGl0b3IsIGNhcmV0LCBmb3J3YXJkKSxcbiAgICAgIGJhY2tzcGFjZURlbGV0ZSQ4LFxuICAgICAgYmFja3NwYWNlRGVsZXRlJDksXG4gICAgICBiYWNrc3BhY2VEZWxldGUkNCxcbiAgICAgIGJhY2tzcGFjZURlbGV0ZSQxLFxuICAgICAgYmFja3NwYWNlRGVsZXRlJDcsXG4gICAgICBiYWNrc3BhY2VEZWxldGUkMlxuICAgIF0sIGl0ZW0gPT4gaXRlbShlZGl0b3IsIGZvcndhcmQpKTtcbiAgICBjb25zdCBkZWxldGVDb21tYW5kID0gKGVkaXRvciwgY2FyZXQpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGZpbmRBY3Rpb24oZWRpdG9yLCBjYXJldCwgZmFsc2UpO1xuICAgICAgcmVzdWx0LmZvbGQoKCkgPT4ge1xuICAgICAgICBleGVjRGVsZXRlQ29tbWFuZChlZGl0b3IpO1xuICAgICAgICBwYWRkRW1wdHlCb2R5KGVkaXRvcik7XG4gICAgICB9LCBjYWxsKTtcbiAgICB9O1xuICAgIGNvbnN0IGZvcndhcmREZWxldGVDb21tYW5kID0gKGVkaXRvciwgY2FyZXQpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGZpbmRBY3Rpb24oZWRpdG9yLCBjYXJldCwgdHJ1ZSk7XG4gICAgICByZXN1bHQuZm9sZCgoKSA9PiBleGVjRm9yd2FyZERlbGV0ZUNvbW1hbmQoZWRpdG9yKSwgY2FsbCk7XG4gICAgfTtcbiAgICBjb25zdCBzZXR1cCRwID0gKGVkaXRvciwgY2FyZXQpID0+IHtcbiAgICAgIGVkaXRvci5hZGRDb21tYW5kKCdkZWxldGUnLCAoKSA9PiB7XG4gICAgICAgIGRlbGV0ZUNvbW1hbmQoZWRpdG9yLCBjYXJldCk7XG4gICAgICB9KTtcbiAgICAgIGVkaXRvci5hZGRDb21tYW5kKCdmb3J3YXJkRGVsZXRlJywgKCkgPT4ge1xuICAgICAgICBmb3J3YXJkRGVsZXRlQ29tbWFuZChlZGl0b3IsIGNhcmV0KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCBTSUdOSUZJQ0FOVF9NT1ZFID0gNTtcbiAgICBjb25zdCBMT05HUFJFU1NfREVMQVkgPSA0MDA7XG4gICAgY29uc3QgZ2V0VG91Y2ggPSBldmVudCA9PiB7XG4gICAgICBpZiAoZXZlbnQudG91Y2hlcyA9PT0gdW5kZWZpbmVkIHx8IGV2ZW50LnRvdWNoZXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gT3B0aW9uYWwuc29tZShldmVudC50b3VjaGVzWzBdKTtcbiAgICB9O1xuICAgIGNvbnN0IGlzRmFyRW5vdWdoID0gKHRvdWNoLCBkYXRhKSA9PiB7XG4gICAgICBjb25zdCBkaXN0WCA9IE1hdGguYWJzKHRvdWNoLmNsaWVudFggLSBkYXRhLngpO1xuICAgICAgY29uc3QgZGlzdFkgPSBNYXRoLmFicyh0b3VjaC5jbGllbnRZIC0gZGF0YS55KTtcbiAgICAgIHJldHVybiBkaXN0WCA+IFNJR05JRklDQU5UX01PVkUgfHwgZGlzdFkgPiBTSUdOSUZJQ0FOVF9NT1ZFO1xuICAgIH07XG4gICAgY29uc3Qgc2V0dXAkbyA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBzdGFydERhdGEgPSB2YWx1ZSQyKCk7XG4gICAgICBjb25zdCBsb25ncHJlc3NGaXJlZCA9IENlbGwoZmFsc2UpO1xuICAgICAgY29uc3QgZGVib3VuY2VMb25ncHJlc3MgPSBsYXN0JDEoZSA9PiB7XG4gICAgICAgIGVkaXRvci5kaXNwYXRjaCgnbG9uZ3ByZXNzJywge1xuICAgICAgICAgIC4uLmUsXG4gICAgICAgICAgdHlwZTogJ2xvbmdwcmVzcydcbiAgICAgICAgfSk7XG4gICAgICAgIGxvbmdwcmVzc0ZpcmVkLnNldCh0cnVlKTtcbiAgICAgIH0sIExPTkdQUkVTU19ERUxBWSk7XG4gICAgICBlZGl0b3Iub24oJ3RvdWNoc3RhcnQnLCBlID0+IHtcbiAgICAgICAgZ2V0VG91Y2goZSkuZWFjaCh0b3VjaCA9PiB7XG4gICAgICAgICAgZGVib3VuY2VMb25ncHJlc3MuY2FuY2VsKCk7XG4gICAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIHg6IHRvdWNoLmNsaWVudFgsXG4gICAgICAgICAgICB5OiB0b3VjaC5jbGllbnRZLFxuICAgICAgICAgICAgdGFyZ2V0OiBlLnRhcmdldFxuICAgICAgICAgIH07XG4gICAgICAgICAgZGVib3VuY2VMb25ncHJlc3MudGhyb3R0bGUoZSk7XG4gICAgICAgICAgbG9uZ3ByZXNzRmlyZWQuc2V0KGZhbHNlKTtcbiAgICAgICAgICBzdGFydERhdGEuc2V0KGRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgIH0sIHRydWUpO1xuICAgICAgZWRpdG9yLm9uKCd0b3VjaG1vdmUnLCBlID0+IHtcbiAgICAgICAgZGVib3VuY2VMb25ncHJlc3MuY2FuY2VsKCk7XG4gICAgICAgIGdldFRvdWNoKGUpLmVhY2godG91Y2ggPT4ge1xuICAgICAgICAgIHN0YXJ0RGF0YS5vbihkYXRhID0+IHtcbiAgICAgICAgICAgIGlmIChpc0ZhckVub3VnaCh0b3VjaCwgZGF0YSkpIHtcbiAgICAgICAgICAgICAgc3RhcnREYXRhLmNsZWFyKCk7XG4gICAgICAgICAgICAgIGxvbmdwcmVzc0ZpcmVkLnNldChmYWxzZSk7XG4gICAgICAgICAgICAgIGVkaXRvci5kaXNwYXRjaCgnbG9uZ3ByZXNzY2FuY2VsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSwgdHJ1ZSk7XG4gICAgICBlZGl0b3Iub24oJ3RvdWNoZW5kIHRvdWNoY2FuY2VsJywgZSA9PiB7XG4gICAgICAgIGRlYm91bmNlTG9uZ3ByZXNzLmNhbmNlbCgpO1xuICAgICAgICBpZiAoZS50eXBlID09PSAndG91Y2hjYW5jZWwnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN0YXJ0RGF0YS5nZXQoKS5maWx0ZXIoZGF0YSA9PiBkYXRhLnRhcmdldC5pc0VxdWFsTm9kZShlLnRhcmdldCkpLmVhY2goKCkgPT4ge1xuICAgICAgICAgIGlmIChsb25ncHJlc3NGaXJlZC5nZXQoKSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlZGl0b3IuZGlzcGF0Y2goJ3RhcCcsIHtcbiAgICAgICAgICAgICAgLi4uZSxcbiAgICAgICAgICAgICAgdHlwZTogJ3RhcCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LCB0cnVlKTtcbiAgICB9O1xuXG4gICAgY29uc3QgaXNCbG9ja0VsZW1lbnQgPSAoYmxvY2tFbGVtZW50cywgbm9kZSkgPT4gaGFzJDIoYmxvY2tFbGVtZW50cywgbm9kZS5ub2RlTmFtZSk7XG4gICAgY29uc3QgaXNWYWxpZFRhcmdldCA9IChibG9ja0VsZW1lbnRzLCBub2RlKSA9PiB7XG4gICAgICBpZiAoaXNUZXh0JDgobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGlzRWxlbWVudCQ2KG5vZGUpKSB7XG4gICAgICAgIHJldHVybiAhaXNCbG9ja0VsZW1lbnQoYmxvY2tFbGVtZW50cywgbm9kZSkgJiYgIWlzQm9va21hcmtOb2RlJDEobm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBoYXNCbG9ja1BhcmVudCA9IChibG9ja0VsZW1lbnRzLCByb290LCBub2RlKSA9PiB7XG4gICAgICByZXR1cm4gZXhpc3RzKHBhcmVudHMoU3VnYXJFbGVtZW50LmZyb21Eb20obm9kZSksIFN1Z2FyRWxlbWVudC5mcm9tRG9tKHJvb3QpKSwgZWxtID0+IHtcbiAgICAgICAgcmV0dXJuIGlzQmxvY2tFbGVtZW50KGJsb2NrRWxlbWVudHMsIGVsbS5kb20pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBzaG91bGRSZW1vdmVUZXh0Tm9kZSA9IChibG9ja0VsZW1lbnRzLCBub2RlKSA9PiB7XG4gICAgICBpZiAoaXNUZXh0JDgobm9kZSkpIHtcbiAgICAgICAgaWYgKG5vZGUubm9kZVZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKC9eXFxzKyQvLnRlc3Qobm9kZS5ub2RlVmFsdWUpICYmICghbm9kZS5uZXh0U2libGluZyB8fCBpc0Jsb2NrRWxlbWVudChibG9ja0VsZW1lbnRzLCBub2RlLm5leHRTaWJsaW5nKSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgY29uc3QgYWRkUm9vdEJsb2NrcyA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBkb20gPSBlZGl0b3IuZG9tLCBzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uO1xuICAgICAgY29uc3Qgc2NoZW1hID0gZWRpdG9yLnNjaGVtYSwgYmxvY2tFbGVtZW50cyA9IHNjaGVtYS5nZXRCbG9ja0VsZW1lbnRzKCk7XG4gICAgICBsZXQgbm9kZSA9IHNlbGVjdGlvbi5nZXRTdGFydCgpO1xuICAgICAgY29uc3Qgcm9vdE5vZGUgPSBlZGl0b3IuZ2V0Qm9keSgpO1xuICAgICAgbGV0IHJvb3RCbG9ja05vZGUsIHRlbXBOb2RlLCB3cmFwcGVkO1xuICAgICAgY29uc3QgZm9yY2VkUm9vdEJsb2NrID0gZ2V0Rm9yY2VkUm9vdEJsb2NrKGVkaXRvcik7XG4gICAgICBpZiAoIW5vZGUgfHwgIWlzRWxlbWVudCQ2KG5vZGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJvb3ROb2RlTmFtZSA9IHJvb3ROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAoIXNjaGVtYS5pc1ZhbGlkQ2hpbGQocm9vdE5vZGVOYW1lLCBmb3JjZWRSb290QmxvY2sudG9Mb3dlckNhc2UoKSkgfHwgaGFzQmxvY2tQYXJlbnQoYmxvY2tFbGVtZW50cywgcm9vdE5vZGUsIG5vZGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJuZyA9IHNlbGVjdGlvbi5nZXRSbmcoKTtcbiAgICAgIGNvbnN0IHN0YXJ0Q29udGFpbmVyID0gcm5nLnN0YXJ0Q29udGFpbmVyO1xuICAgICAgY29uc3Qgc3RhcnRPZmZzZXQgPSBybmcuc3RhcnRPZmZzZXQ7XG4gICAgICBjb25zdCBlbmRDb250YWluZXIgPSBybmcuZW5kQ29udGFpbmVyO1xuICAgICAgY29uc3QgZW5kT2Zmc2V0ID0gcm5nLmVuZE9mZnNldDtcbiAgICAgIGNvbnN0IHJlc3RvcmVTZWxlY3Rpb24gPSBoYXNGb2N1cyhlZGl0b3IpO1xuICAgICAgbm9kZSA9IHJvb3ROb2RlLmZpcnN0Q2hpbGQ7XG4gICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICBpZiAoaXNWYWxpZFRhcmdldChibG9ja0VsZW1lbnRzLCBub2RlKSkge1xuICAgICAgICAgIGlmIChzaG91bGRSZW1vdmVUZXh0Tm9kZShibG9ja0VsZW1lbnRzLCBub2RlKSkge1xuICAgICAgICAgICAgdGVtcE5vZGUgPSBub2RlO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICBkb20ucmVtb3ZlKHRlbXBOb2RlKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXJvb3RCbG9ja05vZGUpIHtcbiAgICAgICAgICAgIHJvb3RCbG9ja05vZGUgPSBkb20uY3JlYXRlKGZvcmNlZFJvb3RCbG9jaywgZ2V0Rm9yY2VkUm9vdEJsb2NrQXR0cnMoZWRpdG9yKSk7XG4gICAgICAgICAgICBub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHJvb3RCbG9ja05vZGUsIG5vZGUpO1xuICAgICAgICAgICAgd3JhcHBlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRlbXBOb2RlID0gbm9kZTtcbiAgICAgICAgICBub2RlID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICByb290QmxvY2tOb2RlLmFwcGVuZENoaWxkKHRlbXBOb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByb290QmxvY2tOb2RlID0gbnVsbDtcbiAgICAgICAgICBub2RlID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHdyYXBwZWQgJiYgcmVzdG9yZVNlbGVjdGlvbikge1xuICAgICAgICBybmcuc2V0U3RhcnQoc3RhcnRDb250YWluZXIsIHN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgcm5nLnNldEVuZChlbmRDb250YWluZXIsIGVuZE9mZnNldCk7XG4gICAgICAgIHNlbGVjdGlvbi5zZXRSbmcocm5nKTtcbiAgICAgICAgZWRpdG9yLm5vZGVDaGFuZ2VkKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBzZXR1cCRuID0gZWRpdG9yID0+IHtcbiAgICAgIGVkaXRvci5vbignTm9kZUNoYW5nZScsIGN1cnJ5KGFkZFJvb3RCbG9ja3MsIGVkaXRvcikpO1xuICAgIH07XG5cbiAgICBjb25zdCBoYXNDbGFzcyA9IGNoZWNrQ2xhc3NOYW1lID0+IG5vZGUgPT4gKCcgJyArIG5vZGUuYXR0cignY2xhc3MnKSArICcgJykuaW5kZXhPZihjaGVja0NsYXNzTmFtZSkgIT09IC0xO1xuICAgIGNvbnN0IHJlcGxhY2VNYXRjaFdpdGhTcGFuID0gKGVkaXRvciwgY29udGVudCwgY2xzKSA9PiB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBhcmd1bWVudHMsIGluZGV4ID0gYXJnc1thcmdzLmxlbmd0aCAtIDJdO1xuICAgICAgICBjb25zdCBwcmV2Q2hhciA9IGluZGV4ID4gMCA/IGNvbnRlbnQuY2hhckF0KGluZGV4IC0gMSkgOiAnJztcbiAgICAgICAgaWYgKHByZXZDaGFyID09PSAnXCInKSB7XG4gICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2Q2hhciA9PT0gJz4nKSB7XG4gICAgICAgICAgY29uc3QgZmluZFN0YXJ0VGFnSW5kZXggPSBjb250ZW50Lmxhc3RJbmRleE9mKCc8JywgaW5kZXgpO1xuICAgICAgICAgIGlmIChmaW5kU3RhcnRUYWdJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZ0h0bWwgPSBjb250ZW50LnN1YnN0cmluZyhmaW5kU3RhcnRUYWdJbmRleCwgaW5kZXgpO1xuICAgICAgICAgICAgaWYgKHRhZ0h0bWwuaW5kZXhPZignY29udGVudGVkaXRhYmxlPVwiZmFsc2VcIicpICE9PSAtMSkge1xuICAgICAgICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnPHNwYW4gY2xhc3M9XCInICsgY2xzICsgJ1wiIGRhdGEtbWNlLWNvbnRlbnQ9XCInICsgZWRpdG9yLmRvbS5lbmNvZGUoYXJnc1swXSkgKyAnXCI+JyArIGVkaXRvci5kb20uZW5jb2RlKHR5cGVvZiBhcmdzWzFdID09PSAnc3RyaW5nJyA/IGFyZ3NbMV0gOiBhcmdzWzBdKSArICc8L3NwYW4+JztcbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBjb252ZXJ0UmVnRXhwc1RvTm9uRWRpdGFibGUgPSAoZWRpdG9yLCBub25FZGl0YWJsZVJlZ0V4cHMsIGUpID0+IHtcbiAgICAgIGxldCBpID0gbm9uRWRpdGFibGVSZWdFeHBzLmxlbmd0aCwgY29udGVudCA9IGUuY29udGVudDtcbiAgICAgIGlmIChlLmZvcm1hdCA9PT0gJ3JhdycpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKG5vbkVkaXRhYmxlUmVnRXhwc1tpXSwgcmVwbGFjZU1hdGNoV2l0aFNwYW4oZWRpdG9yLCBjb250ZW50LCBnZXROb25FZGl0YWJsZUNsYXNzKGVkaXRvcikpKTtcbiAgICAgIH1cbiAgICAgIGUuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgfTtcbiAgICBjb25zdCBzZXR1cCRtID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IGNvbnRlbnRFZGl0YWJsZUF0dHJOYW1lID0gJ2NvbnRlbnRlZGl0YWJsZSc7XG4gICAgICBjb25zdCBlZGl0Q2xhc3MgPSAnICcgKyBUb29scy50cmltKGdldEVkaXRhYmxlQ2xhc3MoZWRpdG9yKSkgKyAnICc7XG4gICAgICBjb25zdCBub25FZGl0Q2xhc3MgPSAnICcgKyBUb29scy50cmltKGdldE5vbkVkaXRhYmxlQ2xhc3MoZWRpdG9yKSkgKyAnICc7XG4gICAgICBjb25zdCBoYXNFZGl0Q2xhc3MgPSBoYXNDbGFzcyhlZGl0Q2xhc3MpO1xuICAgICAgY29uc3QgaGFzTm9uRWRpdENsYXNzID0gaGFzQ2xhc3Mobm9uRWRpdENsYXNzKTtcbiAgICAgIGNvbnN0IG5vbkVkaXRhYmxlUmVnRXhwcyA9IGdldE5vbkVkaXRhYmxlUmVnRXhwcyhlZGl0b3IpO1xuICAgICAgaWYgKG5vbkVkaXRhYmxlUmVnRXhwcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGVkaXRvci5vbignQmVmb3JlU2V0Q29udGVudCcsIGUgPT4ge1xuICAgICAgICAgIGNvbnZlcnRSZWdFeHBzVG9Ob25FZGl0YWJsZShlZGl0b3IsIG5vbkVkaXRhYmxlUmVnRXhwcywgZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZWRpdG9yLnBhcnNlci5hZGRBdHRyaWJ1dGVGaWx0ZXIoJ2NsYXNzJywgbm9kZXMgPT4ge1xuICAgICAgICBsZXQgaSA9IG5vZGVzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICBpZiAoaGFzRWRpdENsYXNzKG5vZGUpKSB7XG4gICAgICAgICAgICBub2RlLmF0dHIoY29udGVudEVkaXRhYmxlQXR0ck5hbWUsICd0cnVlJyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNOb25FZGl0Q2xhc3Mobm9kZSkpIHtcbiAgICAgICAgICAgIG5vZGUuYXR0cihjb250ZW50RWRpdGFibGVBdHRyTmFtZSwgJ2ZhbHNlJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGVkaXRvci5zZXJpYWxpemVyLmFkZEF0dHJpYnV0ZUZpbHRlcihjb250ZW50RWRpdGFibGVBdHRyTmFtZSwgbm9kZXMgPT4ge1xuICAgICAgICBsZXQgaSA9IG5vZGVzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICBpZiAoIWhhc0VkaXRDbGFzcyhub2RlKSAmJiAhaGFzTm9uRWRpdENsYXNzKG5vZGUpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5vbkVkaXRhYmxlUmVnRXhwcy5sZW5ndGggPiAwICYmIG5vZGUuYXR0cignZGF0YS1tY2UtY29udGVudCcpKSB7XG4gICAgICAgICAgICBub2RlLm5hbWUgPSAnI3RleHQnO1xuICAgICAgICAgICAgbm9kZS50eXBlID0gMztcbiAgICAgICAgICAgIG5vZGUucmF3ID0gdHJ1ZTtcbiAgICAgICAgICAgIG5vZGUudmFsdWUgPSBub2RlLmF0dHIoJ2RhdGEtbWNlLWNvbnRlbnQnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZS5hdHRyKGNvbnRlbnRFZGl0YWJsZUF0dHJOYW1lLCBudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCBmaW5kQmxvY2tDYXJldENvbnRhaW5lciA9IGVkaXRvciA9PiBkZXNjZW5kYW50KFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVkaXRvci5nZXRCb2R5KCkpLCAnKltkYXRhLW1jZS1jYXJldF0nKS5tYXAoZWxtID0+IGVsbS5kb20pLmdldE9yTnVsbCgpO1xuICAgIGNvbnN0IHNob3dCbG9ja0NhcmV0Q29udGFpbmVyID0gKGVkaXRvciwgYmxvY2tDYXJldENvbnRhaW5lcikgPT4ge1xuICAgICAgaWYgKGJsb2NrQ2FyZXRDb250YWluZXIuaGFzQXR0cmlidXRlKCdkYXRhLW1jZS1jYXJldCcpKSB7XG4gICAgICAgIHNob3dDYXJldENvbnRhaW5lckJsb2NrKGJsb2NrQ2FyZXRDb250YWluZXIpO1xuICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNldFJuZyhlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpKTtcbiAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zY3JvbGxJbnRvVmlldyhibG9ja0NhcmV0Q29udGFpbmVyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZUJsb2NrQ29udGFpbmVyID0gKGVkaXRvciwgZSkgPT4ge1xuICAgICAgY29uc3QgYmxvY2tDYXJldENvbnRhaW5lciA9IGZpbmRCbG9ja0NhcmV0Q29udGFpbmVyKGVkaXRvcik7XG4gICAgICBpZiAoIWJsb2NrQ2FyZXRDb250YWluZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGUudHlwZSA9PT0gJ2NvbXBvc2l0aW9uc3RhcnQnKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgc2hvd0Jsb2NrQ2FyZXRDb250YWluZXIoZWRpdG9yLCBibG9ja0NhcmV0Q29udGFpbmVyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGhhc0NvbnRlbnQoYmxvY2tDYXJldENvbnRhaW5lcikpIHtcbiAgICAgICAgc2hvd0Jsb2NrQ2FyZXRDb250YWluZXIoZWRpdG9yLCBibG9ja0NhcmV0Q29udGFpbmVyKTtcbiAgICAgICAgZWRpdG9yLnVuZG9NYW5hZ2VyLmFkZCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgc2V0dXAkbCA9IGVkaXRvciA9PiB7XG4gICAgICBlZGl0b3Iub24oJ2tleXVwIGNvbXBvc2l0aW9uc3RhcnQnLCBjdXJyeShoYW5kbGVCbG9ja0NvbnRhaW5lciwgZWRpdG9yKSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGlzQ29udGVudEVkaXRhYmxlRmFsc2UkMiA9IGlzQ29udGVudEVkaXRhYmxlRmFsc2UkYTtcbiAgICBjb25zdCBtb3ZlVG9DZUZhbHNlSG9yaXpvbnRhbGx5ID0gKGRpcmVjdGlvbiwgZWRpdG9yLCByYW5nZSkgPT4gbW92ZUhvcml6b250YWxseShlZGl0b3IsIGRpcmVjdGlvbiwgcmFuZ2UsIGlzQmVmb3JlQ29udGVudEVkaXRhYmxlRmFsc2UsIGlzQWZ0ZXJDb250ZW50RWRpdGFibGVGYWxzZSwgaXNDb250ZW50RWRpdGFibGVGYWxzZSQyKTtcbiAgICBjb25zdCBtb3ZlVG9DZUZhbHNlVmVydGljYWxseSA9IChkaXJlY3Rpb24sIGVkaXRvciwgcmFuZ2UpID0+IHtcbiAgICAgIGNvbnN0IGlzQmVmb3JlID0gY2FyZXRQb3NpdGlvbiA9PiBpc0JlZm9yZUNvbnRlbnRFZGl0YWJsZUZhbHNlKGNhcmV0UG9zaXRpb24pIHx8IGlzQmVmb3JlVGFibGUoY2FyZXRQb3NpdGlvbik7XG4gICAgICBjb25zdCBpc0FmdGVyID0gY2FyZXRQb3NpdGlvbiA9PiBpc0FmdGVyQ29udGVudEVkaXRhYmxlRmFsc2UoY2FyZXRQb3NpdGlvbikgfHwgaXNBZnRlclRhYmxlKGNhcmV0UG9zaXRpb24pO1xuICAgICAgcmV0dXJuIG1vdmVWZXJ0aWNhbGx5KGVkaXRvciwgZGlyZWN0aW9uLCByYW5nZSwgaXNCZWZvcmUsIGlzQWZ0ZXIsIGlzQ29udGVudEVkaXRhYmxlRmFsc2UkMik7XG4gICAgfTtcbiAgICBjb25zdCBjcmVhdGVUZXh0QmxvY2sgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgdGV4dEJsb2NrID0gZWRpdG9yLmRvbS5jcmVhdGUoZ2V0Rm9yY2VkUm9vdEJsb2NrKGVkaXRvcikpO1xuICAgICAgdGV4dEJsb2NrLmlubmVySFRNTCA9ICc8YnIgZGF0YS1tY2UtYm9ndXM9XCIxXCI+JztcbiAgICAgIHJldHVybiB0ZXh0QmxvY2s7XG4gICAgfTtcbiAgICBjb25zdCBleGl0UHJlQmxvY2sgPSAoZWRpdG9yLCBkaXJlY3Rpb24sIHJhbmdlKSA9PiB7XG4gICAgICBjb25zdCBjYXJldFdhbGtlciA9IENhcmV0V2Fsa2VyKGVkaXRvci5nZXRCb2R5KCkpO1xuICAgICAgY29uc3QgZ2V0VmlzdWFsQ2FyZXRQb3NpdGlvbiQxID0gY3VycnkoZ2V0VmlzdWFsQ2FyZXRQb3NpdGlvbiwgZGlyZWN0aW9uID09PSAxID8gY2FyZXRXYWxrZXIubmV4dCA6IGNhcmV0V2Fsa2VyLnByZXYpO1xuICAgICAgaWYgKHJhbmdlLmNvbGxhcHNlZCkge1xuICAgICAgICBjb25zdCBwcmUgPSBlZGl0b3IuZG9tLmdldFBhcmVudChyYW5nZS5zdGFydENvbnRhaW5lciwgJ1BSRScpO1xuICAgICAgICBpZiAoIXByZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYXJldFBvcyA9IGdldFZpc3VhbENhcmV0UG9zaXRpb24kMShDYXJldFBvc2l0aW9uLmZyb21SYW5nZVN0YXJ0KHJhbmdlKSk7XG4gICAgICAgIGlmICghY2FyZXRQb3MpIHtcbiAgICAgICAgICBjb25zdCBuZXdCbG9jayA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKGNyZWF0ZVRleHRCbG9jayhlZGl0b3IpKTtcbiAgICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAxKSB7XG4gICAgICAgICAgICBhZnRlciQ0KFN1Z2FyRWxlbWVudC5mcm9tRG9tKHByZSksIG5ld0Jsb2NrKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYmVmb3JlJDMoU3VnYXJFbGVtZW50LmZyb21Eb20ocHJlKSwgbmV3QmxvY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNlbGVjdChuZXdCbG9jay5kb20sIHRydWUpO1xuICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24uY29sbGFwc2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZ2V0SG9yaXpvbnRhbFJhbmdlID0gKGVkaXRvciwgZm9yd2FyZCkgPT4ge1xuICAgICAgY29uc3QgZGlyZWN0aW9uID0gZm9yd2FyZCA/IEhEaXJlY3Rpb24uRm9yd2FyZHMgOiBIRGlyZWN0aW9uLkJhY2t3YXJkcztcbiAgICAgIGNvbnN0IHJhbmdlID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKTtcbiAgICAgIHJldHVybiBtb3ZlVG9DZUZhbHNlSG9yaXpvbnRhbGx5KGRpcmVjdGlvbiwgZWRpdG9yLCByYW5nZSkub3JUaHVuaygoKSA9PiB7XG4gICAgICAgIGV4aXRQcmVCbG9jayhlZGl0b3IsIGRpcmVjdGlvbiwgcmFuZ2UpO1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBnZXRWZXJ0aWNhbFJhbmdlID0gKGVkaXRvciwgZG93bikgPT4ge1xuICAgICAgY29uc3QgZGlyZWN0aW9uID0gZG93biA/IDEgOiAtMTtcbiAgICAgIGNvbnN0IHJhbmdlID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKTtcbiAgICAgIHJldHVybiBtb3ZlVG9DZUZhbHNlVmVydGljYWxseShkaXJlY3Rpb24sIGVkaXRvciwgcmFuZ2UpLm9yVGh1bmsoKCkgPT4ge1xuICAgICAgICBleGl0UHJlQmxvY2soZWRpdG9yLCBkaXJlY3Rpb24sIHJhbmdlKTtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgbW92ZUgkMiA9IChlZGl0b3IsIGZvcndhcmQpID0+IGdldEhvcml6b250YWxSYW5nZShlZGl0b3IsIGZvcndhcmQpLmV4aXN0cyhuZXdSYW5nZSA9PiB7XG4gICAgICBtb3ZlVG9SYW5nZShlZGl0b3IsIG5ld1JhbmdlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICAgIGNvbnN0IG1vdmVWJDMgPSAoZWRpdG9yLCBkb3duKSA9PiBnZXRWZXJ0aWNhbFJhbmdlKGVkaXRvciwgZG93bikuZXhpc3RzKG5ld1JhbmdlID0+IHtcbiAgICAgIG1vdmVUb1JhbmdlKGVkaXRvciwgbmV3UmFuZ2UpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gICAgY29uc3QgbW92ZVRvTGluZUVuZFBvaW50JDEgPSAoZWRpdG9yLCBmb3J3YXJkKSA9PiB7XG4gICAgICBjb25zdCBpc0NlZlBvc2l0aW9uID0gZm9yd2FyZCA/IGlzQWZ0ZXJDb250ZW50RWRpdGFibGVGYWxzZSA6IGlzQmVmb3JlQ29udGVudEVkaXRhYmxlRmFsc2U7XG4gICAgICByZXR1cm4gbW92ZVRvTGluZUVuZFBvaW50JDMoZWRpdG9yLCBmb3J3YXJkLCBpc0NlZlBvc2l0aW9uKTtcbiAgICB9O1xuXG4gICAgY29uc3QgaXNUYXJnZXQgPSBub2RlID0+IGNvbnRhaW5zJDIoWydmaWdjYXB0aW9uJ10sIG5hbWUobm9kZSkpO1xuICAgIGNvbnN0IHJhbmdlQmVmb3JlID0gdGFyZ2V0ID0+IHtcbiAgICAgIGNvbnN0IHJuZyA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICBybmcuc2V0U3RhcnRCZWZvcmUodGFyZ2V0LmRvbSk7XG4gICAgICBybmcuc2V0RW5kQmVmb3JlKHRhcmdldC5kb20pO1xuICAgICAgcmV0dXJuIHJuZztcbiAgICB9O1xuICAgIGNvbnN0IGluc2VydEVsZW1lbnQgPSAocm9vdCwgZWxtLCBmb3J3YXJkKSA9PiB7XG4gICAgICBpZiAoZm9yd2FyZCkge1xuICAgICAgICBhcHBlbmQkMShyb290LCBlbG0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJlcGVuZChyb290LCBlbG0pO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaW5zZXJ0RW1wdHlMaW5lID0gKHJvb3QsIGZvcndhcmQsIGJsb2NrTmFtZSwgYXR0cnMpID0+IHtcbiAgICAgIGNvbnN0IGJsb2NrID0gU3VnYXJFbGVtZW50LmZyb21UYWcoYmxvY2tOYW1lKTtcbiAgICAgIGNvbnN0IGJyID0gU3VnYXJFbGVtZW50LmZyb21UYWcoJ2JyJyk7XG4gICAgICBzZXRBbGwkMShibG9jaywgYXR0cnMpO1xuICAgICAgYXBwZW5kJDEoYmxvY2ssIGJyKTtcbiAgICAgIGluc2VydEVsZW1lbnQocm9vdCwgYmxvY2ssIGZvcndhcmQpO1xuICAgICAgcmV0dXJuIHJhbmdlQmVmb3JlKGJyKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldENsb3Nlc3RUYXJnZXRCbG9jayA9IChwb3MsIHJvb3QpID0+IHtcbiAgICAgIGNvbnN0IGlzUm9vdCA9IGN1cnJ5KGVxLCByb290KTtcbiAgICAgIHJldHVybiBjbG9zZXN0JDQoU3VnYXJFbGVtZW50LmZyb21Eb20ocG9zLmNvbnRhaW5lcigpKSwgaXNCbG9jayQyLCBpc1Jvb3QpLmZpbHRlcihpc1RhcmdldCk7XG4gICAgfTtcbiAgICBjb25zdCBpc0F0Rmlyc3RPckxhc3RMaW5lID0gKHJvb3QsIGZvcndhcmQsIHBvcykgPT4gZm9yd2FyZCA/IGlzQXRMYXN0TGluZShyb290LmRvbSwgcG9zKSA6IGlzQXRGaXJzdExpbmUocm9vdC5kb20sIHBvcyk7XG4gICAgY29uc3QgbW92ZUNhcmV0VG9OZXdFbXB0eUxpbmUgPSAoZWRpdG9yLCBmb3J3YXJkKSA9PiB7XG4gICAgICBjb25zdCByb290ID0gU3VnYXJFbGVtZW50LmZyb21Eb20oZWRpdG9yLmdldEJvZHkoKSk7XG4gICAgICBjb25zdCBwb3MgPSBDYXJldFBvc2l0aW9uLmZyb21SYW5nZVN0YXJ0KGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCkpO1xuICAgICAgY29uc3Qgcm9vdEJsb2NrID0gZ2V0Rm9yY2VkUm9vdEJsb2NrKGVkaXRvcik7XG4gICAgICBjb25zdCByb290QmxvY2tBdHRycyA9IGdldEZvcmNlZFJvb3RCbG9ja0F0dHJzKGVkaXRvcik7XG4gICAgICByZXR1cm4gZ2V0Q2xvc2VzdFRhcmdldEJsb2NrKHBvcywgcm9vdCkuZXhpc3RzKCgpID0+IHtcbiAgICAgICAgaWYgKGlzQXRGaXJzdE9yTGFzdExpbmUocm9vdCwgZm9yd2FyZCwgcG9zKSkge1xuICAgICAgICAgIGNvbnN0IHJuZyA9IGluc2VydEVtcHR5TGluZShyb290LCBmb3J3YXJkLCByb290QmxvY2ssIHJvb3RCbG9ja0F0dHJzKTtcbiAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNldFJuZyhybmcpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBtb3ZlViQyID0gKGVkaXRvciwgZm9yd2FyZCkgPT4ge1xuICAgICAgaWYgKGVkaXRvci5zZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSkge1xuICAgICAgICByZXR1cm4gbW92ZUNhcmV0VG9OZXdFbXB0eUxpbmUoZWRpdG9yLCBmb3J3YXJkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgYmFzZUtleVBhdHRlcm4gPSB7XG4gICAgICBzaGlmdEtleTogZmFsc2UsXG4gICAgICBhbHRLZXk6IGZhbHNlLFxuICAgICAgY3RybEtleTogZmFsc2UsXG4gICAgICBtZXRhS2V5OiBmYWxzZSxcbiAgICAgIGtleUNvZGU6IDBcbiAgICB9O1xuICAgIGNvbnN0IGRlZmF1bHRQYXR0ZXJucyA9IHBhdHRlcm5zID0+IG1hcCQzKHBhdHRlcm5zLCBwYXR0ZXJuID0+ICh7XG4gICAgICAuLi5iYXNlS2V5UGF0dGVybixcbiAgICAgIGFjdGlvbjogbm9vcCxcbiAgICAgIC4uLnBhdHRlcm5cbiAgICB9KSk7XG4gICAgY29uc3QgZGVmYXVsdERlbGF5ZWRQYXR0ZXJucyA9IHBhdHRlcm5zID0+IG1hcCQzKHBhdHRlcm5zLCBwYXR0ZXJuID0+ICh7XG4gICAgICAuLi5iYXNlS2V5UGF0dGVybixcbiAgICAgIGFjdGlvbjogKCkgPT4gT3B0aW9uYWwubm9uZSgpLFxuICAgICAgLi4ucGF0dGVyblxuICAgIH0pKTtcbiAgICBjb25zdCBtYXRjaGVzRXZlbnQgPSAocGF0dGVybiwgZXZ0KSA9PiBldnQua2V5Q29kZSA9PT0gcGF0dGVybi5rZXlDb2RlICYmIGV2dC5zaGlmdEtleSA9PT0gcGF0dGVybi5zaGlmdEtleSAmJiBldnQuYWx0S2V5ID09PSBwYXR0ZXJuLmFsdEtleSAmJiBldnQuY3RybEtleSA9PT0gcGF0dGVybi5jdHJsS2V5ICYmIGV2dC5tZXRhS2V5ID09PSBwYXR0ZXJuLm1ldGFLZXk7XG4gICAgY29uc3QgbWF0Y2gkMSA9IChwYXR0ZXJucywgZXZ0KSA9PiBiaW5kJDMoZGVmYXVsdFBhdHRlcm5zKHBhdHRlcm5zKSwgcGF0dGVybiA9PiBtYXRjaGVzRXZlbnQocGF0dGVybiwgZXZ0KSA/IFtwYXR0ZXJuXSA6IFtdKTtcbiAgICBjb25zdCBtYXRjaERlbGF5ZWQgPSAocGF0dGVybnMsIGV2dCkgPT4gYmluZCQzKGRlZmF1bHREZWxheWVkUGF0dGVybnMocGF0dGVybnMpLCBwYXR0ZXJuID0+IG1hdGNoZXNFdmVudChwYXR0ZXJuLCBldnQpID8gW3BhdHRlcm5dIDogW10pO1xuICAgIGNvbnN0IGFjdGlvbiA9IChmLCAuLi54KSA9PiAoKSA9PiBmLmFwcGx5KG51bGwsIHgpO1xuICAgIGNvbnN0IGV4ZWN1dGUgPSAocGF0dGVybnMsIGV2dCkgPT4gZmluZCQyKG1hdGNoJDEocGF0dGVybnMsIGV2dCksIHBhdHRlcm4gPT4gcGF0dGVybi5hY3Rpb24oKSk7XG4gICAgY29uc3QgZXhlY3V0ZVdpdGhEZWxheWVkQWN0aW9uID0gKHBhdHRlcm5zLCBldnQpID0+IGZpbmRNYXAobWF0Y2hEZWxheWVkKHBhdHRlcm5zLCBldnQpLCBwYXR0ZXJuID0+IHBhdHRlcm4uYWN0aW9uKCkpO1xuXG4gICAgY29uc3QgbW92ZUgkMSA9IChlZGl0b3IsIGZvcndhcmQpID0+IHtcbiAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IGZvcndhcmQgPyBIRGlyZWN0aW9uLkZvcndhcmRzIDogSERpcmVjdGlvbi5CYWNrd2FyZHM7XG4gICAgICBjb25zdCByYW5nZSA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCk7XG4gICAgICByZXR1cm4gbW92ZUhvcml6b250YWxseShlZGl0b3IsIGRpcmVjdGlvbiwgcmFuZ2UsIGlzQmVmb3JlTWVkaWEsIGlzQWZ0ZXJNZWRpYSwgaXNNZWRpYSQyKS5leGlzdHMobmV3UmFuZ2UgPT4ge1xuICAgICAgICBtb3ZlVG9SYW5nZShlZGl0b3IsIG5ld1JhbmdlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IG1vdmVWJDEgPSAoZWRpdG9yLCBkb3duKSA9PiB7XG4gICAgICBjb25zdCBkaXJlY3Rpb24gPSBkb3duID8gMSA6IC0xO1xuICAgICAgY29uc3QgcmFuZ2UgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpO1xuICAgICAgcmV0dXJuIG1vdmVWZXJ0aWNhbGx5KGVkaXRvciwgZGlyZWN0aW9uLCByYW5nZSwgaXNCZWZvcmVNZWRpYSwgaXNBZnRlck1lZGlhLCBpc01lZGlhJDIpLmV4aXN0cyhuZXdSYW5nZSA9PiB7XG4gICAgICAgIG1vdmVUb1JhbmdlKGVkaXRvciwgbmV3UmFuZ2UpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgbW92ZVRvTGluZUVuZFBvaW50ID0gKGVkaXRvciwgZm9yd2FyZCkgPT4ge1xuICAgICAgY29uc3QgaXNOZWFyTWVkaWEgPSBmb3J3YXJkID8gaXNBZnRlck1lZGlhIDogaXNCZWZvcmVNZWRpYTtcbiAgICAgIHJldHVybiBtb3ZlVG9MaW5lRW5kUG9pbnQkMyhlZGl0b3IsIGZvcndhcmQsIGlzTmVhck1lZGlhKTtcbiAgICB9O1xuXG4gICAgY29uc3QgYWR0ID0gQWR0LmdlbmVyYXRlKFtcbiAgICAgIHsgbm9uZTogWydjdXJyZW50J10gfSxcbiAgICAgIHsgZmlyc3Q6IFsnY3VycmVudCddIH0sXG4gICAgICB7XG4gICAgICAgIG1pZGRsZTogW1xuICAgICAgICAgICdjdXJyZW50JyxcbiAgICAgICAgICAndGFyZ2V0J1xuICAgICAgICBdXG4gICAgICB9LFxuICAgICAgeyBsYXN0OiBbJ2N1cnJlbnQnXSB9XG4gICAgXSk7XG4gICAgY29uc3Qgbm9uZSA9IGN1cnJlbnQgPT4gYWR0Lm5vbmUoY3VycmVudCk7XG4gICAgY29uc3QgQ2VsbExvY2F0aW9uID0ge1xuICAgICAgLi4uYWR0LFxuICAgICAgbm9uZVxuICAgIH07XG5cbiAgICBjb25zdCBmaXJzdExheWVyID0gKHNjb3BlLCBzZWxlY3RvcikgPT4ge1xuICAgICAgcmV0dXJuIGZpbHRlckZpcnN0TGF5ZXIoc2NvcGUsIHNlbGVjdG9yLCBhbHdheXMpO1xuICAgIH07XG4gICAgY29uc3QgZmlsdGVyRmlyc3RMYXllciA9IChzY29wZSwgc2VsZWN0b3IsIHByZWRpY2F0ZSkgPT4ge1xuICAgICAgcmV0dXJuIGJpbmQkMyhjaGlsZHJlbihzY29wZSksIHggPT4ge1xuICAgICAgICBpZiAoaXMkMSh4LCBzZWxlY3RvcikpIHtcbiAgICAgICAgICByZXR1cm4gcHJlZGljYXRlKHgpID8gW3hdIDogW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZpbHRlckZpcnN0TGF5ZXIoeCwgc2VsZWN0b3IsIHByZWRpY2F0ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCBsb29rdXAkMSA9ICh0YWdzLCBlbGVtZW50LCBpc1Jvb3QgPSBuZXZlcikgPT4ge1xuICAgICAgaWYgKGlzUm9vdChlbGVtZW50KSkge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgfVxuICAgICAgaWYgKGNvbnRhaW5zJDIodGFncywgbmFtZShlbGVtZW50KSkpIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoZWxlbWVudCk7XG4gICAgICB9XG4gICAgICBjb25zdCBpc1Jvb3RPclVwcGVyVGFibGUgPSBlbG0gPT4gaXMkMShlbG0sICd0YWJsZScpIHx8IGlzUm9vdChlbG0pO1xuICAgICAgcmV0dXJuIGFuY2VzdG9yJDIoZWxlbWVudCwgdGFncy5qb2luKCcsJyksIGlzUm9vdE9yVXBwZXJUYWJsZSk7XG4gICAgfTtcbiAgICBjb25zdCBjZWxsID0gKGVsZW1lbnQsIGlzUm9vdCkgPT4gbG9va3VwJDEoW1xuICAgICAgJ3RkJyxcbiAgICAgICd0aCdcbiAgICBdLCBlbGVtZW50LCBpc1Jvb3QpO1xuICAgIGNvbnN0IGNlbGxzID0gYW5jZXN0b3IgPT4gZmlyc3RMYXllcihhbmNlc3RvciwgJ3RoLHRkJyk7XG4gICAgY29uc3QgdGFibGUgPSAoZWxlbWVudCwgaXNSb290KSA9PiBjbG9zZXN0JDMoZWxlbWVudCwgJ3RhYmxlJywgaXNSb290KTtcblxuICAgIGNvbnN0IHdhbGsgPSAoYWxsLCBjdXJyZW50LCBpbmRleCwgZGlyZWN0aW9uLCBpc0VsaWdpYmxlID0gYWx3YXlzKSA9PiB7XG4gICAgICBjb25zdCBmb3J3YXJkcyA9IGRpcmVjdGlvbiA9PT0gMTtcbiAgICAgIGlmICghZm9yd2FyZHMgJiYgaW5kZXggPD0gMCkge1xuICAgICAgICByZXR1cm4gQ2VsbExvY2F0aW9uLmZpcnN0KGFsbFswXSk7XG4gICAgICB9IGVsc2UgaWYgKGZvcndhcmRzICYmIGluZGV4ID49IGFsbC5sZW5ndGggLSAxKSB7XG4gICAgICAgIHJldHVybiBDZWxsTG9jYXRpb24ubGFzdChhbGxbYWxsLmxlbmd0aCAtIDFdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG5ld0luZGV4ID0gaW5kZXggKyBkaXJlY3Rpb247XG4gICAgICAgIGNvbnN0IGVsZW0gPSBhbGxbbmV3SW5kZXhdO1xuICAgICAgICByZXR1cm4gaXNFbGlnaWJsZShlbGVtKSA/IENlbGxMb2NhdGlvbi5taWRkbGUoY3VycmVudCwgZWxlbSkgOiB3YWxrKGFsbCwgY3VycmVudCwgbmV3SW5kZXgsIGRpcmVjdGlvbiwgaXNFbGlnaWJsZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBkZXRlY3QgPSAoY3VycmVudCwgaXNSb290KSA9PiB7XG4gICAgICByZXR1cm4gdGFibGUoY3VycmVudCwgaXNSb290KS5iaW5kKHRhYmxlID0+IHtcbiAgICAgICAgY29uc3QgYWxsID0gY2VsbHModGFibGUpO1xuICAgICAgICBjb25zdCBpbmRleCA9IGZpbmRJbmRleCQyKGFsbCwgeCA9PiBlcShjdXJyZW50LCB4KSk7XG4gICAgICAgIHJldHVybiBpbmRleC5tYXAoaW5kZXggPT4gKHtcbiAgICAgICAgICBpbmRleCxcbiAgICAgICAgICBhbGxcbiAgICAgICAgfSkpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBuZXh0ID0gKGN1cnJlbnQsIGlzRWxpZ2libGUsIGlzUm9vdCkgPT4ge1xuICAgICAgY29uc3QgZGV0ZWN0aW9uID0gZGV0ZWN0KGN1cnJlbnQsIGlzUm9vdCk7XG4gICAgICByZXR1cm4gZGV0ZWN0aW9uLmZvbGQoKCkgPT4ge1xuICAgICAgICByZXR1cm4gQ2VsbExvY2F0aW9uLm5vbmUoY3VycmVudCk7XG4gICAgICB9LCBpbmZvID0+IHtcbiAgICAgICAgcmV0dXJuIHdhbGsoaW5mby5hbGwsIGN1cnJlbnQsIGluZm8uaW5kZXgsIDEsIGlzRWxpZ2libGUpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBwcmV2ID0gKGN1cnJlbnQsIGlzRWxpZ2libGUsIGlzUm9vdCkgPT4ge1xuICAgICAgY29uc3QgZGV0ZWN0aW9uID0gZGV0ZWN0KGN1cnJlbnQsIGlzUm9vdCk7XG4gICAgICByZXR1cm4gZGV0ZWN0aW9uLmZvbGQoKCkgPT4ge1xuICAgICAgICByZXR1cm4gQ2VsbExvY2F0aW9uLm5vbmUoKTtcbiAgICAgIH0sIGluZm8gPT4ge1xuICAgICAgICByZXR1cm4gd2FsayhpbmZvLmFsbCwgY3VycmVudCwgaW5mby5pbmRleCwgLTEsIGlzRWxpZ2libGUpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGNsb3Nlc3QgPSB0YXJnZXQgPT4gY2xvc2VzdCQzKHRhcmdldCwgJ1tjb250ZW50ZWRpdGFibGVdJyk7XG4gICAgY29uc3QgaXNFZGl0YWJsZSA9IChlbGVtZW50LCBhc3N1bWVFZGl0YWJsZSA9IGZhbHNlKSA9PiB7XG4gICAgICBpZiAoaW5Cb2R5KGVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50LmRvbS5pc0NvbnRlbnRFZGl0YWJsZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjbG9zZXN0KGVsZW1lbnQpLmZvbGQoY29uc3RhbnQoYXNzdW1lRWRpdGFibGUpLCBlZGl0YWJsZSA9PiBnZXRSYXcoZWRpdGFibGUpID09PSAndHJ1ZScpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZ2V0UmF3ID0gZWxlbWVudCA9PiBlbGVtZW50LmRvbS5jb250ZW50RWRpdGFibGU7XG5cbiAgICBjb25zdCBkZWZsYXRlID0gKHJlY3QsIGRlbHRhKSA9PiAoe1xuICAgICAgbGVmdDogcmVjdC5sZWZ0IC0gZGVsdGEsXG4gICAgICB0b3A6IHJlY3QudG9wIC0gZGVsdGEsXG4gICAgICByaWdodDogcmVjdC5yaWdodCArIGRlbHRhICogMixcbiAgICAgIGJvdHRvbTogcmVjdC5ib3R0b20gKyBkZWx0YSAqIDIsXG4gICAgICB3aWR0aDogcmVjdC53aWR0aCArIGRlbHRhLFxuICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodCArIGRlbHRhXG4gICAgfSk7XG4gICAgY29uc3QgZ2V0Q29ybmVycyA9IChnZXRZQXhpc1ZhbHVlLCB0ZHMpID0+IGJpbmQkMyh0ZHMsIHRkID0+IHtcbiAgICAgIGNvbnN0IHJlY3QgPSBkZWZsYXRlKGNsb25lJDEodGQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpLCAtMSk7XG4gICAgICByZXR1cm4gW1xuICAgICAgICB7XG4gICAgICAgICAgeDogcmVjdC5sZWZ0LFxuICAgICAgICAgIHk6IGdldFlBeGlzVmFsdWUocmVjdCksXG4gICAgICAgICAgY2VsbDogdGRcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHg6IHJlY3QucmlnaHQsXG4gICAgICAgICAgeTogZ2V0WUF4aXNWYWx1ZShyZWN0KSxcbiAgICAgICAgICBjZWxsOiB0ZFxuICAgICAgICB9XG4gICAgICBdO1xuICAgIH0pO1xuICAgIGNvbnN0IGZpbmRDbG9zZXN0Q29ybmVyID0gKGNvcm5lcnMsIHgsIHkpID0+IGZvbGRsKGNvcm5lcnMsIChhY2MsIG5ld0Nvcm5lcikgPT4gYWNjLmZvbGQoKCkgPT4gT3B0aW9uYWwuc29tZShuZXdDb3JuZXIpLCBvbGRDb3JuZXIgPT4ge1xuICAgICAgY29uc3Qgb2xkRGlzdCA9IE1hdGguc3FydChNYXRoLmFicyhvbGRDb3JuZXIueCAtIHgpICsgTWF0aC5hYnMob2xkQ29ybmVyLnkgLSB5KSk7XG4gICAgICBjb25zdCBuZXdEaXN0ID0gTWF0aC5zcXJ0KE1hdGguYWJzKG5ld0Nvcm5lci54IC0geCkgKyBNYXRoLmFicyhuZXdDb3JuZXIueSAtIHkpKTtcbiAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKG5ld0Rpc3QgPCBvbGREaXN0ID8gbmV3Q29ybmVyIDogb2xkQ29ybmVyKTtcbiAgICB9KSwgT3B0aW9uYWwubm9uZSgpKTtcbiAgICBjb25zdCBnZXRDbG9zZXN0Q2VsbCA9IChnZXRZQXhpc1ZhbHVlLCBpc1RhcmdldENvcm5lciwgdGFibGUsIHgsIHkpID0+IHtcbiAgICAgIGNvbnN0IGNlbGxzID0gZGVzY2VuZGFudHMoU3VnYXJFbGVtZW50LmZyb21Eb20odGFibGUpLCAndGQsdGgsY2FwdGlvbicpLm1hcChlID0+IGUuZG9tKTtcbiAgICAgIGNvbnN0IGNvcm5lcnMgPSBmaWx0ZXIkNihnZXRDb3JuZXJzKGdldFlBeGlzVmFsdWUsIGNlbGxzKSwgY29ybmVyID0+IGlzVGFyZ2V0Q29ybmVyKGNvcm5lciwgeSkpO1xuICAgICAgcmV0dXJuIGZpbmRDbG9zZXN0Q29ybmVyKGNvcm5lcnMsIHgsIHkpLm1hcChjb3JuZXIgPT4gY29ybmVyLmNlbGwpO1xuICAgIH07XG4gICAgY29uc3QgZ2V0Qm90dG9tVmFsdWUgPSByZWN0ID0+IHJlY3QuYm90dG9tO1xuICAgIGNvbnN0IGdldFRvcFZhbHVlID0gcmVjdCA9PiByZWN0LnRvcDtcbiAgICBjb25zdCBpc0Fib3ZlID0gKGNvcm5lciwgeSkgPT4gY29ybmVyLnkgPCB5O1xuICAgIGNvbnN0IGlzQmVsb3cgPSAoY29ybmVyLCB5KSA9PiBjb3JuZXIueSA+IHk7XG4gICAgY29uc3QgZ2V0Q2xvc2VzdENlbGxBYm92ZSA9IGN1cnJ5KGdldENsb3Nlc3RDZWxsLCBnZXRCb3R0b21WYWx1ZSwgaXNBYm92ZSk7XG4gICAgY29uc3QgZ2V0Q2xvc2VzdENlbGxCZWxvdyA9IGN1cnJ5KGdldENsb3Nlc3RDZWxsLCBnZXRUb3BWYWx1ZSwgaXNCZWxvdyk7XG4gICAgY29uc3QgZmluZENsb3Nlc3RQb3NpdGlvbkluQWJvdmVDZWxsID0gKHRhYmxlLCBwb3MpID0+IGhlYWQocG9zLmdldENsaWVudFJlY3RzKCkpLmJpbmQocmVjdCA9PiBnZXRDbG9zZXN0Q2VsbEFib3ZlKHRhYmxlLCByZWN0LmxlZnQsIHJlY3QudG9wKSkuYmluZChjZWxsID0+IGZpbmRDbG9zZXN0SG9yaXpvbnRhbFBvc2l0aW9uKGdldExhc3RMaW5lUG9zaXRpb25zKGNlbGwpLCBwb3MpKTtcbiAgICBjb25zdCBmaW5kQ2xvc2VzdFBvc2l0aW9uSW5CZWxvd0NlbGwgPSAodGFibGUsIHBvcykgPT4gbGFzdCQzKHBvcy5nZXRDbGllbnRSZWN0cygpKS5iaW5kKHJlY3QgPT4gZ2V0Q2xvc2VzdENlbGxCZWxvdyh0YWJsZSwgcmVjdC5sZWZ0LCByZWN0LnRvcCkpLmJpbmQoY2VsbCA9PiBmaW5kQ2xvc2VzdEhvcml6b250YWxQb3NpdGlvbihnZXRGaXJzdExpbmVQb3NpdGlvbnMoY2VsbCksIHBvcykpO1xuXG4gICAgY29uc3QgaGFzTmV4dEJyZWFrID0gKGdldFBvc2l0aW9uc1VudGlsLCBzY29wZSwgbGluZUluZm8pID0+IGxpbmVJbmZvLmJyZWFrQXQuZXhpc3RzKGJyZWFrUG9zID0+IGdldFBvc2l0aW9uc1VudGlsKHNjb3BlLCBicmVha1BvcykuYnJlYWtBdC5pc1NvbWUoKSk7XG4gICAgY29uc3Qgc3RhcnRzV2l0aFdyYXBCcmVhayA9IGxpbmVJbmZvID0+IGxpbmVJbmZvLmJyZWFrVHlwZSA9PT0gQnJlYWtUeXBlLldyYXAgJiYgbGluZUluZm8ucG9zaXRpb25zLmxlbmd0aCA9PT0gMDtcbiAgICBjb25zdCBzdGFydHNXaXRoQnJCcmVhayA9IGxpbmVJbmZvID0+IGxpbmVJbmZvLmJyZWFrVHlwZSA9PT0gQnJlYWtUeXBlLkJyICYmIGxpbmVJbmZvLnBvc2l0aW9ucy5sZW5ndGggPT09IDE7XG4gICAgY29uc3QgaXNBdFRhYmxlQ2VsbExpbmUgPSAoZ2V0UG9zaXRpb25zVW50aWwsIHNjb3BlLCBwb3MpID0+IHtcbiAgICAgIGNvbnN0IGxpbmVJbmZvID0gZ2V0UG9zaXRpb25zVW50aWwoc2NvcGUsIHBvcyk7XG4gICAgICBpZiAoc3RhcnRzV2l0aFdyYXBCcmVhayhsaW5lSW5mbykgfHwgIWlzQnIkNShwb3MuZ2V0Tm9kZSgpKSAmJiBzdGFydHNXaXRoQnJCcmVhayhsaW5lSW5mbykpIHtcbiAgICAgICAgcmV0dXJuICFoYXNOZXh0QnJlYWsoZ2V0UG9zaXRpb25zVW50aWwsIHNjb3BlLCBsaW5lSW5mbyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbGluZUluZm8uYnJlYWtBdC5pc05vbmUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGlzQXRGaXJzdFRhYmxlQ2VsbExpbmUgPSBjdXJyeShpc0F0VGFibGVDZWxsTGluZSwgZ2V0UG9zaXRpb25zVW50aWxQcmV2aW91c0xpbmUpO1xuICAgIGNvbnN0IGlzQXRMYXN0VGFibGVDZWxsTGluZSA9IGN1cnJ5KGlzQXRUYWJsZUNlbGxMaW5lLCBnZXRQb3NpdGlvbnNVbnRpbE5leHRMaW5lKTtcbiAgICBjb25zdCBpc0NhcmV0QXRTdGFydE9yRW5kT2ZUYWJsZSA9IChmb3J3YXJkLCBybmcsIHRhYmxlKSA9PiB7XG4gICAgICBjb25zdCBjYXJldFBvcyA9IENhcmV0UG9zaXRpb24uZnJvbVJhbmdlU3RhcnQocm5nKTtcbiAgICAgIHJldHVybiBwb3NpdGlvbkluKCFmb3J3YXJkLCB0YWJsZSkuZXhpc3RzKHBvcyA9PiBwb3MuaXNFcXVhbChjYXJldFBvcykpO1xuICAgIH07XG4gICAgY29uc3QgbmF2aWdhdGVIb3Jpem9udGFsbHkgPSAoZWRpdG9yLCBmb3J3YXJkLCB0YWJsZSwgX3RkKSA9PiB7XG4gICAgICBjb25zdCBybmcgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpO1xuICAgICAgY29uc3QgZGlyZWN0aW9uID0gZm9yd2FyZCA/IDEgOiAtMTtcbiAgICAgIGlmIChpc0Zha2VDYXJldFRhYmxlQnJvd3NlcigpICYmIGlzQ2FyZXRBdFN0YXJ0T3JFbmRPZlRhYmxlKGZvcndhcmQsIHJuZywgdGFibGUpKSB7XG4gICAgICAgIHNob3dDYXJldChkaXJlY3Rpb24sIGVkaXRvciwgdGFibGUsICFmb3J3YXJkLCBmYWxzZSkuZWFjaChuZXdSbmcgPT4ge1xuICAgICAgICAgIG1vdmVUb1JhbmdlKGVkaXRvciwgbmV3Um5nKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgY29uc3QgZ2V0Q2xvc2VzdEFib3ZlUG9zaXRpb24gPSAocm9vdCwgdGFibGUsIHN0YXJ0KSA9PiBmaW5kQ2xvc2VzdFBvc2l0aW9uSW5BYm92ZUNlbGwodGFibGUsIHN0YXJ0KS5vclRodW5rKCgpID0+IGhlYWQoc3RhcnQuZ2V0Q2xpZW50UmVjdHMoKSkuYmluZChyZWN0ID0+IGZpbmRDbG9zZXN0SG9yaXpvbnRhbFBvc2l0aW9uRnJvbVBvaW50KGdldFBvc2l0aW9uc0Fib3ZlKHJvb3QsIENhcmV0UG9zaXRpb24uYmVmb3JlKHRhYmxlKSksIHJlY3QubGVmdCkpKS5nZXRPcihDYXJldFBvc2l0aW9uLmJlZm9yZSh0YWJsZSkpO1xuICAgIGNvbnN0IGdldENsb3Nlc3RCZWxvd1Bvc2l0aW9uID0gKHJvb3QsIHRhYmxlLCBzdGFydCkgPT4gZmluZENsb3Nlc3RQb3NpdGlvbkluQmVsb3dDZWxsKHRhYmxlLCBzdGFydCkub3JUaHVuaygoKSA9PiBoZWFkKHN0YXJ0LmdldENsaWVudFJlY3RzKCkpLmJpbmQocmVjdCA9PiBmaW5kQ2xvc2VzdEhvcml6b250YWxQb3NpdGlvbkZyb21Qb2ludChnZXRQb3NpdGlvbnNCZWxvdyhyb290LCBDYXJldFBvc2l0aW9uLmFmdGVyKHRhYmxlKSksIHJlY3QubGVmdCkpKS5nZXRPcihDYXJldFBvc2l0aW9uLmFmdGVyKHRhYmxlKSk7XG4gICAgY29uc3QgZ2V0VGFibGUgPSAocHJldmlvdXMsIHBvcykgPT4ge1xuICAgICAgY29uc3Qgbm9kZSA9IHBvcy5nZXROb2RlKHByZXZpb3VzKTtcbiAgICAgIHJldHVybiBpc0VsZW1lbnQkNihub2RlKSAmJiBub2RlLm5vZGVOYW1lID09PSAnVEFCTEUnID8gT3B0aW9uYWwuc29tZShub2RlKSA6IE9wdGlvbmFsLm5vbmUoKTtcbiAgICB9O1xuICAgIGNvbnN0IHJlbmRlckJsb2NrID0gKGRvd24sIGVkaXRvciwgdGFibGUpID0+IHtcbiAgICAgIGNvbnN0IGZvcmNlZFJvb3RCbG9jayA9IGdldEZvcmNlZFJvb3RCbG9jayhlZGl0b3IpO1xuICAgICAgZWRpdG9yLnVuZG9NYW5hZ2VyLnRyYW5zYWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IFN1Z2FyRWxlbWVudC5mcm9tVGFnKGZvcmNlZFJvb3RCbG9jayk7XG4gICAgICAgIHNldEFsbCQxKGVsZW1lbnQsIGdldEZvcmNlZFJvb3RCbG9ja0F0dHJzKGVkaXRvcikpO1xuICAgICAgICBhcHBlbmQkMShlbGVtZW50LCBTdWdhckVsZW1lbnQuZnJvbVRhZygnYnInKSk7XG4gICAgICAgIGlmIChkb3duKSB7XG4gICAgICAgICAgYWZ0ZXIkNChTdWdhckVsZW1lbnQuZnJvbURvbSh0YWJsZSksIGVsZW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJlZm9yZSQzKFN1Z2FyRWxlbWVudC5mcm9tRG9tKHRhYmxlKSwgZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm5nID0gZWRpdG9yLmRvbS5jcmVhdGVSbmcoKTtcbiAgICAgICAgcm5nLnNldFN0YXJ0KGVsZW1lbnQuZG9tLCAwKTtcbiAgICAgICAgcm5nLnNldEVuZChlbGVtZW50LmRvbSwgMCk7XG4gICAgICAgIG1vdmVUb1JhbmdlKGVkaXRvciwgcm5nKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgbW92ZUNhcmV0ID0gKGVkaXRvciwgZG93biwgcG9zKSA9PiB7XG4gICAgICBjb25zdCB0YWJsZSA9IGRvd24gPyBnZXRUYWJsZSh0cnVlLCBwb3MpIDogZ2V0VGFibGUoZmFsc2UsIHBvcyk7XG4gICAgICBjb25zdCBsYXN0ID0gZG93biA9PT0gZmFsc2U7XG4gICAgICB0YWJsZS5mb2xkKCgpID0+IG1vdmVUb1JhbmdlKGVkaXRvciwgcG9zLnRvUmFuZ2UoKSksIHRhYmxlID0+IHBvc2l0aW9uSW4obGFzdCwgZWRpdG9yLmdldEJvZHkoKSkuZmlsdGVyKGxhc3RQb3MgPT4gbGFzdFBvcy5pc0VxdWFsKHBvcykpLmZvbGQoKCkgPT4gbW92ZVRvUmFuZ2UoZWRpdG9yLCBwb3MudG9SYW5nZSgpKSwgXyA9PiByZW5kZXJCbG9jayhkb3duLCBlZGl0b3IsIHRhYmxlKSkpO1xuICAgIH07XG4gICAgY29uc3QgbmF2aWdhdGVWZXJ0aWNhbGx5ID0gKGVkaXRvciwgZG93biwgdGFibGUsIHRkKSA9PiB7XG4gICAgICBjb25zdCBybmcgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpO1xuICAgICAgY29uc3QgcG9zID0gQ2FyZXRQb3NpdGlvbi5mcm9tUmFuZ2VTdGFydChybmcpO1xuICAgICAgY29uc3Qgcm9vdCA9IGVkaXRvci5nZXRCb2R5KCk7XG4gICAgICBpZiAoIWRvd24gJiYgaXNBdEZpcnN0VGFibGVDZWxsTGluZSh0ZCwgcG9zKSkge1xuICAgICAgICBjb25zdCBuZXdQb3MgPSBnZXRDbG9zZXN0QWJvdmVQb3NpdGlvbihyb290LCB0YWJsZSwgcG9zKTtcbiAgICAgICAgbW92ZUNhcmV0KGVkaXRvciwgZG93biwgbmV3UG9zKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGRvd24gJiYgaXNBdExhc3RUYWJsZUNlbGxMaW5lKHRkLCBwb3MpKSB7XG4gICAgICAgIGNvbnN0IG5ld1BvcyA9IGdldENsb3Nlc3RCZWxvd1Bvc2l0aW9uKHJvb3QsIHRhYmxlLCBwb3MpO1xuICAgICAgICBtb3ZlQ2FyZXQoZWRpdG9yLCBkb3duLCBuZXdQb3MpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG1vdmUkMSA9IChlZGl0b3IsIGZvcndhcmQsIG1vdmVyKSA9PiBPcHRpb25hbC5mcm9tKGVkaXRvci5kb20uZ2V0UGFyZW50KGVkaXRvci5zZWxlY3Rpb24uZ2V0Tm9kZSgpLCAndGQsdGgnKSkuYmluZCh0ZCA9PiBPcHRpb25hbC5mcm9tKGVkaXRvci5kb20uZ2V0UGFyZW50KHRkLCAndGFibGUnKSkubWFwKHRhYmxlID0+IG1vdmVyKGVkaXRvciwgZm9yd2FyZCwgdGFibGUsIHRkKSkpLmdldE9yKGZhbHNlKTtcbiAgICBjb25zdCBtb3ZlSCA9IChlZGl0b3IsIGZvcndhcmQpID0+IG1vdmUkMShlZGl0b3IsIGZvcndhcmQsIG5hdmlnYXRlSG9yaXpvbnRhbGx5KTtcbiAgICBjb25zdCBtb3ZlViA9IChlZGl0b3IsIGZvcndhcmQpID0+IG1vdmUkMShlZGl0b3IsIGZvcndhcmQsIG5hdmlnYXRlVmVydGljYWxseSk7XG4gICAgY29uc3QgZ2V0Q2VsbEZpcnN0Q3Vyc29yUG9zaXRpb24gPSBjZWxsID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IFNpbVNlbGVjdGlvbi5leGFjdChjZWxsLCAwLCBjZWxsLCAwKTtcbiAgICAgIHJldHVybiB0b05hdGl2ZShzZWxlY3Rpb24pO1xuICAgIH07XG4gICAgY29uc3QgdGFiR28gPSAoZWRpdG9yLCBpc1Jvb3QsIGNlbGwpID0+IHtcbiAgICAgIHJldHVybiBjZWxsLmZvbGQoT3B0aW9uYWwubm9uZSwgT3B0aW9uYWwubm9uZSwgKF9jdXJyZW50LCBuZXh0KSA9PiB7XG4gICAgICAgIHJldHVybiBmaXJzdChuZXh0KS5tYXAoY2VsbCA9PiB7XG4gICAgICAgICAgcmV0dXJuIGdldENlbGxGaXJzdEN1cnNvclBvc2l0aW9uKGNlbGwpO1xuICAgICAgICB9KTtcbiAgICAgIH0sIGN1cnJlbnQgPT4ge1xuICAgICAgICBlZGl0b3IuZXhlY0NvbW1hbmQoJ21jZVRhYmxlSW5zZXJ0Um93QWZ0ZXInKTtcbiAgICAgICAgcmV0dXJuIHRhYkZvcndhcmQoZWRpdG9yLCBpc1Jvb3QsIGN1cnJlbnQpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCB0YWJGb3J3YXJkID0gKGVkaXRvciwgaXNSb290LCBjZWxsKSA9PiB0YWJHbyhlZGl0b3IsIGlzUm9vdCwgbmV4dChjZWxsLCBpc0VkaXRhYmxlKSk7XG4gICAgY29uc3QgdGFiQmFja3dhcmQgPSAoZWRpdG9yLCBpc1Jvb3QsIGNlbGwpID0+IHRhYkdvKGVkaXRvciwgaXNSb290LCBwcmV2KGNlbGwsIGlzRWRpdGFibGUpKTtcbiAgICBjb25zdCBoYW5kbGVUYWIgPSAoZWRpdG9yLCBmb3J3YXJkKSA9PiB7XG4gICAgICBjb25zdCByb290RWxlbWVudHMgPSBbXG4gICAgICAgICd0YWJsZScsXG4gICAgICAgICdsaScsXG4gICAgICAgICdkbCdcbiAgICAgIF07XG4gICAgICBjb25zdCBib2R5ID0gU3VnYXJFbGVtZW50LmZyb21Eb20oZWRpdG9yLmdldEJvZHkoKSk7XG4gICAgICBjb25zdCBpc1Jvb3QgPSBlbGVtZW50ID0+IHtcbiAgICAgICAgY29uc3QgbmFtZSQxID0gbmFtZShlbGVtZW50KTtcbiAgICAgICAgcmV0dXJuIGVxKGVsZW1lbnQsIGJvZHkpIHx8IGNvbnRhaW5zJDIocm9vdEVsZW1lbnRzLCBuYW1lJDEpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHJuZyA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCk7XG4gICAgICBjb25zdCBjb250YWluZXIgPSBTdWdhckVsZW1lbnQuZnJvbURvbSghZm9yd2FyZCA/IHJuZy5zdGFydENvbnRhaW5lciA6IHJuZy5lbmRDb250YWluZXIpO1xuICAgICAgcmV0dXJuIGNlbGwoY29udGFpbmVyLCBpc1Jvb3QpLm1hcChjZWxsID0+IHtcbiAgICAgICAgdGFibGUoY2VsbCwgaXNSb290KS5lYWNoKHRhYmxlID0+IHtcbiAgICAgICAgICBlZGl0b3IubW9kZWwudGFibGUuY2xlYXJTZWxlY3RlZENlbGxzKHRhYmxlLmRvbSk7XG4gICAgICAgIH0pO1xuICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLmNvbGxhcHNlKCFmb3J3YXJkKTtcbiAgICAgICAgY29uc3QgbmF2aWdhdGlvbiA9ICFmb3J3YXJkID8gdGFiQmFja3dhcmQgOiB0YWJGb3J3YXJkO1xuICAgICAgICBjb25zdCBybmcgPSBuYXZpZ2F0aW9uKGVkaXRvciwgaXNSb290LCBjZWxsKTtcbiAgICAgICAgcm5nLmVhY2gocmFuZ2UgPT4ge1xuICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2V0Um5nKHJhbmdlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSkuZ2V0T3IoZmFsc2UpO1xuICAgIH07XG5cbiAgICBjb25zdCBleGVjdXRlS2V5ZG93bk92ZXJyaWRlJDQgPSAoZWRpdG9yLCBjYXJldCwgZXZ0KSA9PiB7XG4gICAgICBjb25zdCBvcyA9IGRldGVjdCQyKCkub3M7XG4gICAgICBleGVjdXRlKFtcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLlJJR0hULFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKG1vdmVIJDIsIGVkaXRvciwgdHJ1ZSlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLkxFRlQsXG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24obW92ZUgkMiwgZWRpdG9yLCBmYWxzZSlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLlVQLFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKG1vdmVWJDMsIGVkaXRvciwgZmFsc2UpXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBrZXlDb2RlOiBWSy5ET1dOLFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKG1vdmVWJDMsIGVkaXRvciwgdHJ1ZSlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLlJJR0hULFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKG1vdmVILCBlZGl0b3IsIHRydWUpXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBrZXlDb2RlOiBWSy5MRUZULFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKG1vdmVILCBlZGl0b3IsIGZhbHNlKVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAga2V5Q29kZTogVksuVVAsXG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24obW92ZVYsIGVkaXRvciwgZmFsc2UpXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBrZXlDb2RlOiBWSy5ET1dOLFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKG1vdmVWLCBlZGl0b3IsIHRydWUpXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBrZXlDb2RlOiBWSy5SSUdIVCxcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbihtb3ZlSCQxLCBlZGl0b3IsIHRydWUpXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBrZXlDb2RlOiBWSy5MRUZULFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKG1vdmVIJDEsIGVkaXRvciwgZmFsc2UpXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBrZXlDb2RlOiBWSy5VUCxcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbihtb3ZlViQxLCBlZGl0b3IsIGZhbHNlKVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAga2V5Q29kZTogVksuRE9XTixcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbihtb3ZlViQxLCBlZGl0b3IsIHRydWUpXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBrZXlDb2RlOiBWSy5SSUdIVCxcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbihtb3ZlJDIsIGVkaXRvciwgY2FyZXQsIHRydWUpXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBrZXlDb2RlOiBWSy5MRUZULFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKG1vdmUkMiwgZWRpdG9yLCBjYXJldCwgZmFsc2UpXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBrZXlDb2RlOiBWSy5SSUdIVCxcbiAgICAgICAgICBjdHJsS2V5OiAhb3MuaXNNYWNPUygpLFxuICAgICAgICAgIGFsdEtleTogb3MuaXNNYWNPUygpLFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKG1vdmVOZXh0V29yZCwgZWRpdG9yLCBjYXJldClcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLkxFRlQsXG4gICAgICAgICAgY3RybEtleTogIW9zLmlzTWFjT1MoKSxcbiAgICAgICAgICBhbHRLZXk6IG9zLmlzTWFjT1MoKSxcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbihtb3ZlUHJldldvcmQsIGVkaXRvciwgY2FyZXQpXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBrZXlDb2RlOiBWSy5VUCxcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbihtb3ZlViQyLCBlZGl0b3IsIGZhbHNlKVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAga2V5Q29kZTogVksuRE9XTixcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbihtb3ZlViQyLCBlZGl0b3IsIHRydWUpXG4gICAgICAgIH1cbiAgICAgIF0sIGV2dCkuZWFjaChfID0+IHtcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHNldHVwJGsgPSAoZWRpdG9yLCBjYXJldCkgPT4ge1xuICAgICAgZWRpdG9yLm9uKCdrZXlkb3duJywgZXZ0ID0+IHtcbiAgICAgICAgaWYgKGV2dC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBleGVjdXRlS2V5ZG93bk92ZXJyaWRlJDQoZWRpdG9yLCBjYXJldCwgZXZ0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IHBvaW50ID0gKGNvbnRhaW5lciwgb2Zmc2V0KSA9PiAoe1xuICAgICAgY29udGFpbmVyLFxuICAgICAgb2Zmc2V0XG4gICAgfSk7XG5cbiAgICBjb25zdCBET00kNyA9IERPTVV0aWxzLkRPTTtcbiAgICBjb25zdCBhbHdheXNOZXh0ID0gc3RhcnROb2RlID0+IG5vZGUgPT4gc3RhcnROb2RlID09PSBub2RlID8gLTEgOiAwO1xuICAgIGNvbnN0IGlzQm91bmRhcnkgPSBkb20gPT4gbm9kZSA9PiBkb20uaXNCbG9jayhub2RlKSB8fCBjb250YWlucyQyKFtcbiAgICAgICdCUicsXG4gICAgICAnSU1HJyxcbiAgICAgICdIUicsXG4gICAgICAnSU5QVVQnXG4gICAgXSwgbm9kZS5ub2RlTmFtZSkgfHwgZG9tLmdldENvbnRlbnRFZGl0YWJsZShub2RlKSA9PT0gJ2ZhbHNlJztcbiAgICBjb25zdCB0ZXh0QmVmb3JlID0gKG5vZGUsIG9mZnNldCwgcm9vdE5vZGUpID0+IHtcbiAgICAgIGlmIChpc1RleHQkOChub2RlKSAmJiBvZmZzZXQgPj0gMCkge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZShwb2ludChub2RlLCBvZmZzZXQpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHRleHRTZWVrZXIgPSBUZXh0U2Vla2VyKERPTSQ3KTtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLmZyb20odGV4dFNlZWtlci5iYWNrd2FyZHMobm9kZSwgb2Zmc2V0LCBhbHdheXNOZXh0KG5vZGUpLCByb290Tm9kZSkpLm1hcChwcmV2ID0+IHBvaW50KHByZXYuY29udGFpbmVyLCBwcmV2LmNvbnRhaW5lci5kYXRhLmxlbmd0aCkpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgdGV4dEFmdGVyID0gKG5vZGUsIG9mZnNldCwgcm9vdE5vZGUpID0+IHtcbiAgICAgIGlmIChpc1RleHQkOChub2RlKSAmJiBvZmZzZXQgPj0gbm9kZS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUocG9pbnQobm9kZSwgb2Zmc2V0KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0ZXh0U2Vla2VyID0gVGV4dFNlZWtlcihET00kNyk7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5mcm9tKHRleHRTZWVrZXIuZm9yd2FyZHMobm9kZSwgb2Zmc2V0LCBhbHdheXNOZXh0KG5vZGUpLCByb290Tm9kZSkpLm1hcChwcmV2ID0+IHBvaW50KHByZXYuY29udGFpbmVyLCAwKSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBzY2FuTGVmdCA9IChub2RlLCBvZmZzZXQsIHJvb3ROb2RlKSA9PiB7XG4gICAgICBpZiAoIWlzVGV4dCQ4KG5vZGUpKSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9XG4gICAgICBjb25zdCB0ZXh0ID0gbm9kZS50ZXh0Q29udGVudDtcbiAgICAgIGlmIChvZmZzZXQgPj0gMCAmJiBvZmZzZXQgPD0gdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUocG9pbnQobm9kZSwgb2Zmc2V0KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0ZXh0U2Vla2VyID0gVGV4dFNlZWtlcihET00kNyk7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5mcm9tKHRleHRTZWVrZXIuYmFja3dhcmRzKG5vZGUsIG9mZnNldCwgYWx3YXlzTmV4dChub2RlKSwgcm9vdE5vZGUpKS5iaW5kKHByZXYgPT4ge1xuICAgICAgICAgIGNvbnN0IHByZXZUZXh0ID0gcHJldi5jb250YWluZXIuZGF0YTtcbiAgICAgICAgICByZXR1cm4gc2NhbkxlZnQocHJldi5jb250YWluZXIsIG9mZnNldCArIHByZXZUZXh0Lmxlbmd0aCwgcm9vdE5vZGUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHNjYW5SaWdodCA9IChub2RlLCBvZmZzZXQsIHJvb3ROb2RlKSA9PiB7XG4gICAgICBpZiAoIWlzVGV4dCQ4KG5vZGUpKSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9XG4gICAgICBjb25zdCB0ZXh0ID0gbm9kZS50ZXh0Q29udGVudDtcbiAgICAgIGlmIChvZmZzZXQgPD0gdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUocG9pbnQobm9kZSwgb2Zmc2V0KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0ZXh0U2Vla2VyID0gVGV4dFNlZWtlcihET00kNyk7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5mcm9tKHRleHRTZWVrZXIuZm9yd2FyZHMobm9kZSwgb2Zmc2V0LCBhbHdheXNOZXh0KG5vZGUpLCByb290Tm9kZSkpLmJpbmQobmV4dCA9PiBzY2FuUmlnaHQobmV4dC5jb250YWluZXIsIG9mZnNldCAtIHRleHQubGVuZ3RoLCByb290Tm9kZSkpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcmVwZWF0TGVmdCA9IChkb20sIG5vZGUsIG9mZnNldCwgcHJvY2Vzcywgcm9vdE5vZGUpID0+IHtcbiAgICAgIGNvbnN0IHNlYXJjaCA9IFRleHRTZWVrZXIoZG9tLCBpc0JvdW5kYXJ5KGRvbSkpO1xuICAgICAgcmV0dXJuIE9wdGlvbmFsLmZyb20oc2VhcmNoLmJhY2t3YXJkcyhub2RlLCBvZmZzZXQsIHByb2Nlc3MsIHJvb3ROb2RlKSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGlzVmFsaWRUZXh0UmFuZ2UgPSBybmcgPT4gcm5nLmNvbGxhcHNlZCAmJiBybmcuc3RhcnRDb250YWluZXIubm9kZVR5cGUgPT09IDM7XG4gICAgY29uc3QgZ2V0VGV4dCA9IHJuZyA9PiBybmcudG9TdHJpbmcoKS5yZXBsYWNlKC9cXHUwMEEwL2csICcgJykucmVwbGFjZSgvXFx1RkVGRi9nLCAnJyk7XG4gICAgY29uc3QgaXNXaGl0ZXNwYWNlID0gY2hyID0+IGNociAhPT0gJycgJiYgJyBcXHhBMFxcZlxcblxcclxcdFxceDBCJy5pbmRleE9mKGNocikgIT09IC0xO1xuXG4gICAgY29uc3Qgc3RyaXBUcmlnZ2VyQ2hhciA9ICh0ZXh0LCB0cmlnZ2VyQ2gpID0+IHRleHQuc3Vic3RyaW5nKHRyaWdnZXJDaC5sZW5ndGgpO1xuICAgIGNvbnN0IGZpbmRDaGFyID0gKHRleHQsIGluZGV4LCBjaCkgPT4ge1xuICAgICAgbGV0IGk7XG4gICAgICBmb3IgKGkgPSBpbmRleCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IGNoYXIgPSB0ZXh0LmNoYXJBdChpKTtcbiAgICAgICAgaWYgKGlzV2hpdGVzcGFjZShjaGFyKSkge1xuICAgICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXIgPT09IGNoKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKGkpO1xuICAgIH07XG4gICAgY29uc3QgZmluZFN0YXJ0ID0gKGRvbSwgaW5pdFJhbmdlLCBjaCwgbWluQ2hhcnMgPSAwKSA9PiB7XG4gICAgICBpZiAoIWlzVmFsaWRUZXh0UmFuZ2UoaW5pdFJhbmdlKSkge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgfVxuICAgICAgY29uc3QgZmluZFRyaWdnZXJDaEluZGV4ID0gKGVsZW1lbnQsIG9mZnNldCwgdGV4dCkgPT4gZmluZENoYXIodGV4dCwgb2Zmc2V0LCBjaCkuZ2V0T3Iob2Zmc2V0KTtcbiAgICAgIGNvbnN0IHJvb3QgPSBkb20uZ2V0UGFyZW50KGluaXRSYW5nZS5zdGFydENvbnRhaW5lciwgZG9tLmlzQmxvY2spIHx8IGRvbS5nZXRSb290KCk7XG4gICAgICByZXR1cm4gcmVwZWF0TGVmdChkb20sIGluaXRSYW5nZS5zdGFydENvbnRhaW5lciwgaW5pdFJhbmdlLnN0YXJ0T2Zmc2V0LCBmaW5kVHJpZ2dlckNoSW5kZXgsIHJvb3QpLmJpbmQoc3BvdCA9PiB7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gaW5pdFJhbmdlLmNsb25lUmFuZ2UoKTtcbiAgICAgICAgcmFuZ2Uuc2V0U3RhcnQoc3BvdC5jb250YWluZXIsIHNwb3Qub2Zmc2V0KTtcbiAgICAgICAgcmFuZ2Uuc2V0RW5kKGluaXRSYW5nZS5lbmRDb250YWluZXIsIGluaXRSYW5nZS5lbmRPZmZzZXQpO1xuICAgICAgICBpZiAocmFuZ2UuY29sbGFwc2VkKSB7XG4gICAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ZXh0ID0gZ2V0VGV4dChyYW5nZSk7XG4gICAgICAgIGNvbnN0IHRyaWdnZXJDaGFySW5kZXggPSB0ZXh0Lmxhc3RJbmRleE9mKGNoKTtcbiAgICAgICAgaWYgKHRyaWdnZXJDaGFySW5kZXggIT09IDAgfHwgc3RyaXBUcmlnZ2VyQ2hhcih0ZXh0LCBjaCkubGVuZ3RoIDwgbWluQ2hhcnMpIHtcbiAgICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKHtcbiAgICAgICAgICAgIHRleHQ6IHN0cmlwVHJpZ2dlckNoYXIodGV4dCwgY2gpLFxuICAgICAgICAgICAgcmFuZ2UsXG4gICAgICAgICAgICB0cmlnZ2VyQ2hhcjogY2hcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBnZXRDb250ZXh0ID0gKGRvbSwgaW5pdFJhbmdlLCBjaCwgbWluQ2hhcnMgPSAwKSA9PiBkZXRlY3QkMShTdWdhckVsZW1lbnQuZnJvbURvbShpbml0UmFuZ2Uuc3RhcnRDb250YWluZXIpKS5mb2xkKCgpID0+IGZpbmRTdGFydChkb20sIGluaXRSYW5nZSwgY2gsIG1pbkNoYXJzKSwgZWxtID0+IHtcbiAgICAgIGNvbnN0IHJhbmdlID0gZG9tLmNyZWF0ZVJuZygpO1xuICAgICAgcmFuZ2Uuc2VsZWN0Tm9kZShlbG0uZG9tKTtcbiAgICAgIGNvbnN0IHRleHQgPSBnZXRUZXh0KHJhbmdlKTtcbiAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKHtcbiAgICAgICAgcmFuZ2UsXG4gICAgICAgIHRleHQ6IHN0cmlwVHJpZ2dlckNoYXIodGV4dCwgY2gpLFxuICAgICAgICB0cmlnZ2VyQ2hhcjogY2hcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgY29uc3QgaXNUZXh0ID0gbm9kZSA9PiBub2RlLm5vZGVUeXBlID09PSBURVhUO1xuICAgIGNvbnN0IGlzRWxlbWVudCA9IG5vZGUgPT4gbm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVDtcbiAgICBjb25zdCB0b0xhc3QgPSBub2RlID0+IHtcbiAgICAgIGlmIChpc1RleHQobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIHBvaW50KG5vZGUsIG5vZGUuZGF0YS5sZW5ndGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmNoaWxkTm9kZXM7XG4gICAgICAgIHJldHVybiBjaGlsZHJlbi5sZW5ndGggPiAwID8gdG9MYXN0KGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdKSA6IHBvaW50KG5vZGUsIGNoaWxkcmVuLmxlbmd0aCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCB0b0xlYWYgPSAobm9kZSwgb2Zmc2V0KSA9PiB7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuY2hpbGROb2RlcztcbiAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAwICYmIG9mZnNldCA8IGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdG9MZWFmKGNoaWxkcmVuW29mZnNldF0sIDApO1xuICAgICAgfSBlbHNlIGlmIChjaGlsZHJlbi5sZW5ndGggPiAwICYmIGlzRWxlbWVudChub2RlKSAmJiBjaGlsZHJlbi5sZW5ndGggPT09IG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdG9MYXN0KGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwb2ludChub2RlLCBvZmZzZXQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBpc1ByZXZpb3VzQ2hhckNvbnRlbnQgPSAoZG9tLCBsZWFmKSA9PiByZXBlYXRMZWZ0KGRvbSwgbGVhZi5jb250YWluZXIsIGxlYWYub2Zmc2V0LCAoZWxlbWVudCwgb2Zmc2V0KSA9PiBvZmZzZXQgPT09IDAgPyAtMSA6IG9mZnNldCwgZG9tLmdldFJvb3QoKSkuZmlsdGVyKHNwb3QgPT4ge1xuICAgICAgY29uc3QgY2hhciA9IHNwb3QuY29udGFpbmVyLmRhdGEuY2hhckF0KHNwb3Qub2Zmc2V0IC0gMSk7XG4gICAgICByZXR1cm4gIWlzV2hpdGVzcGFjZShjaGFyKTtcbiAgICB9KS5pc1NvbWUoKTtcbiAgICBjb25zdCBpc1N0YXJ0T2ZXb3JkID0gZG9tID0+IHJuZyA9PiB7XG4gICAgICBjb25zdCBsZWFmID0gdG9MZWFmKHJuZy5zdGFydENvbnRhaW5lciwgcm5nLnN0YXJ0T2Zmc2V0KTtcbiAgICAgIHJldHVybiAhaXNQcmV2aW91c0NoYXJDb250ZW50KGRvbSwgbGVhZik7XG4gICAgfTtcbiAgICBjb25zdCBnZXRUcmlnZ2VyQ29udGV4dCA9IChkb20sIGluaXRSYW5nZSwgZGF0YWJhc2UpID0+IGZpbmRNYXAoZGF0YWJhc2UudHJpZ2dlckNoYXJzLCBjaCA9PiBnZXRDb250ZXh0KGRvbSwgaW5pdFJhbmdlLCBjaCkpO1xuICAgIGNvbnN0IGxvb2t1cCA9IChlZGl0b3IsIGdldERhdGFiYXNlKSA9PiB7XG4gICAgICBjb25zdCBkYXRhYmFzZSA9IGdldERhdGFiYXNlKCk7XG4gICAgICBjb25zdCBybmcgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpO1xuICAgICAgcmV0dXJuIGdldFRyaWdnZXJDb250ZXh0KGVkaXRvci5kb20sIHJuZywgZGF0YWJhc2UpLmJpbmQoY29udGV4dCA9PiBsb29rdXBXaXRoQ29udGV4dChlZGl0b3IsIGdldERhdGFiYXNlLCBjb250ZXh0KSk7XG4gICAgfTtcbiAgICBjb25zdCBsb29rdXBXaXRoQ29udGV4dCA9IChlZGl0b3IsIGdldERhdGFiYXNlLCBjb250ZXh0LCBmZXRjaE9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgY29uc3QgZGF0YWJhc2UgPSBnZXREYXRhYmFzZSgpO1xuICAgICAgY29uc3Qgcm5nID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKTtcbiAgICAgIGNvbnN0IHN0YXJ0VGV4dCA9IHJuZy5zdGFydENvbnRhaW5lci5ub2RlVmFsdWU7XG4gICAgICBjb25zdCBhdXRvY29tcGxldGVycyA9IGZpbHRlciQ2KGRhdGFiYXNlLmxvb2t1cEJ5Q2hhcihjb250ZXh0LnRyaWdnZXJDaGFyKSwgYXV0b2NvbXBsZXRlciA9PiBjb250ZXh0LnRleHQubGVuZ3RoID49IGF1dG9jb21wbGV0ZXIubWluQ2hhcnMgJiYgYXV0b2NvbXBsZXRlci5tYXRjaGVzLmdldE9yVGh1bmsoKCkgPT4gaXNTdGFydE9mV29yZChlZGl0b3IuZG9tKSkoY29udGV4dC5yYW5nZSwgc3RhcnRUZXh0LCBjb250ZXh0LnRleHQpKTtcbiAgICAgIGlmIChhdXRvY29tcGxldGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxvb2t1cERhdGEgPSBQcm9taXNlLmFsbChtYXAkMyhhdXRvY29tcGxldGVycywgYWMgPT4ge1xuICAgICAgICBjb25zdCBmZXRjaFJlc3VsdCA9IGFjLmZldGNoKGNvbnRleHQudGV4dCwgYWMubWF4UmVzdWx0cywgZmV0Y2hPcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIGZldGNoUmVzdWx0LnRoZW4ocmVzdWx0cyA9PiAoe1xuICAgICAgICAgIG1hdGNoVGV4dDogY29udGV4dC50ZXh0LFxuICAgICAgICAgIGl0ZW1zOiByZXN1bHRzLFxuICAgICAgICAgIGNvbHVtbnM6IGFjLmNvbHVtbnMsXG4gICAgICAgICAgb25BY3Rpb246IGFjLm9uQWN0aW9uLFxuICAgICAgICAgIGhpZ2hsaWdodE9uOiBhYy5oaWdobGlnaHRPblxuICAgICAgICB9KSk7XG4gICAgICB9KSk7XG4gICAgICByZXR1cm4gT3B0aW9uYWwuc29tZSh7XG4gICAgICAgIGxvb2t1cERhdGEsXG4gICAgICAgIGNvbnRleHRcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgU2ltcGxlUmVzdWx0VHlwZTtcbiAgICAoZnVuY3Rpb24gKFNpbXBsZVJlc3VsdFR5cGUpIHtcbiAgICAgIFNpbXBsZVJlc3VsdFR5cGVbU2ltcGxlUmVzdWx0VHlwZVsnRXJyb3InXSA9IDBdID0gJ0Vycm9yJztcbiAgICAgIFNpbXBsZVJlc3VsdFR5cGVbU2ltcGxlUmVzdWx0VHlwZVsnVmFsdWUnXSA9IDFdID0gJ1ZhbHVlJztcbiAgICB9KFNpbXBsZVJlc3VsdFR5cGUgfHwgKFNpbXBsZVJlc3VsdFR5cGUgPSB7fSkpKTtcbiAgICBjb25zdCBmb2xkJDEgPSAocmVzLCBvbkVycm9yLCBvblZhbHVlKSA9PiByZXMuc3R5cGUgPT09IFNpbXBsZVJlc3VsdFR5cGUuRXJyb3IgPyBvbkVycm9yKHJlcy5zZXJyb3IpIDogb25WYWx1ZShyZXMuc3ZhbHVlKTtcbiAgICBjb25zdCBwYXJ0aXRpb24gPSByZXN1bHRzID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgICBlYWNoJGcocmVzdWx0cywgb2JqID0+IHtcbiAgICAgICAgZm9sZCQxKG9iaiwgZXJyID0+IGVycm9ycy5wdXNoKGVyciksIHZhbCA9PiB2YWx1ZXMucHVzaCh2YWwpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWVzLFxuICAgICAgICBlcnJvcnNcbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBtYXBFcnJvciA9IChyZXMsIGYpID0+IHtcbiAgICAgIGlmIChyZXMuc3R5cGUgPT09IFNpbXBsZVJlc3VsdFR5cGUuRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdHlwZTogU2ltcGxlUmVzdWx0VHlwZS5FcnJvcixcbiAgICAgICAgICBzZXJyb3I6IGYocmVzLnNlcnJvcilcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBtYXAgPSAocmVzLCBmKSA9PiB7XG4gICAgICBpZiAocmVzLnN0eXBlID09PSBTaW1wbGVSZXN1bHRUeXBlLlZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3R5cGU6IFNpbXBsZVJlc3VsdFR5cGUuVmFsdWUsXG4gICAgICAgICAgc3ZhbHVlOiBmKHJlcy5zdmFsdWUpXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgYmluZCA9IChyZXMsIGYpID0+IHtcbiAgICAgIGlmIChyZXMuc3R5cGUgPT09IFNpbXBsZVJlc3VsdFR5cGUuVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGYocmVzLnN2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgYmluZEVycm9yID0gKHJlcywgZikgPT4ge1xuICAgICAgaWYgKHJlcy5zdHlwZSA9PT0gU2ltcGxlUmVzdWx0VHlwZS5FcnJvcikge1xuICAgICAgICByZXR1cm4gZihyZXMuc2Vycm9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBzdmFsdWUgPSB2ID0+ICh7XG4gICAgICBzdHlwZTogU2ltcGxlUmVzdWx0VHlwZS5WYWx1ZSxcbiAgICAgIHN2YWx1ZTogdlxuICAgIH0pO1xuICAgIGNvbnN0IHNlcnJvciA9IGUgPT4gKHtcbiAgICAgIHN0eXBlOiBTaW1wbGVSZXN1bHRUeXBlLkVycm9yLFxuICAgICAgc2Vycm9yOiBlXG4gICAgfSk7XG4gICAgY29uc3QgdG9SZXN1bHQgPSByZXMgPT4gZm9sZCQxKHJlcywgUmVzdWx0LmVycm9yLCBSZXN1bHQudmFsdWUpO1xuICAgIGNvbnN0IGZyb21SZXN1bHQgPSByZXMgPT4gcmVzLmZvbGQoc2Vycm9yLCBzdmFsdWUpO1xuICAgIGNvbnN0IFNpbXBsZVJlc3VsdCA9IHtcbiAgICAgIGZyb21SZXN1bHQsXG4gICAgICB0b1Jlc3VsdCxcbiAgICAgIHN2YWx1ZSxcbiAgICAgIHBhcnRpdGlvbixcbiAgICAgIHNlcnJvcixcbiAgICAgIGJpbmQsXG4gICAgICBiaW5kRXJyb3IsXG4gICAgICBtYXAsXG4gICAgICBtYXBFcnJvcixcbiAgICAgIGZvbGQ6IGZvbGQkMVxuICAgIH07XG5cbiAgICBjb25zdCBmb3JtYXRPYmogPSBpbnB1dCA9PiB7XG4gICAgICByZXR1cm4gaXNPYmplY3QoaW5wdXQpICYmIGtleXMoaW5wdXQpLmxlbmd0aCA+IDEwMCA/ICcgcmVtb3ZlZCBkdWUgdG8gc2l6ZScgOiBKU09OLnN0cmluZ2lmeShpbnB1dCwgbnVsbCwgMik7XG4gICAgfTtcbiAgICBjb25zdCBmb3JtYXRFcnJvcnMgPSBlcnJvcnMgPT4ge1xuICAgICAgY29uc3QgZXMgPSBlcnJvcnMubGVuZ3RoID4gMTAgPyBlcnJvcnMuc2xpY2UoMCwgMTApLmNvbmNhdChbe1xuICAgICAgICAgIHBhdGg6IFtdLFxuICAgICAgICAgIGdldEVycm9ySW5mbzogY29uc3RhbnQoJy4uLiAob25seSBzaG93aW5nIGZpcnN0IHRlbiBmYWlsdXJlcyknKVxuICAgICAgICB9XSkgOiBlcnJvcnM7XG4gICAgICByZXR1cm4gbWFwJDMoZXMsIGUgPT4ge1xuICAgICAgICByZXR1cm4gJ0ZhaWxlZCBwYXRoOiAoJyArIGUucGF0aC5qb2luKCcgPiAnKSArICcpXFxuJyArIGUuZ2V0RXJyb3JJbmZvKCk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3QgbnUgPSAocGF0aCwgZ2V0RXJyb3JJbmZvKSA9PiB7XG4gICAgICByZXR1cm4gU2ltcGxlUmVzdWx0LnNlcnJvcihbe1xuICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgZ2V0RXJyb3JJbmZvXG4gICAgICAgIH1dKTtcbiAgICB9O1xuICAgIGNvbnN0IG1pc3NpbmdSZXF1aXJlZCA9IChwYXRoLCBrZXksIG9iaikgPT4gbnUocGF0aCwgKCkgPT4gJ0NvdWxkIG5vdCBmaW5kIHZhbGlkICpyZXF1aXJlZCogdmFsdWUgZm9yIFwiJyArIGtleSArICdcIiBpbiAnICsgZm9ybWF0T2JqKG9iaikpO1xuICAgIGNvbnN0IG1pc3NpbmdLZXkgPSAocGF0aCwga2V5KSA9PiBudShwYXRoLCAoKSA9PiAnQ2hvaWNlIHNjaGVtYSBkaWQgbm90IGNvbnRhaW4gY2hvaWNlIGtleTogXCInICsga2V5ICsgJ1wiJyk7XG4gICAgY29uc3QgbWlzc2luZ0JyYW5jaCA9IChwYXRoLCBicmFuY2hlcywgYnJhbmNoKSA9PiBudShwYXRoLCAoKSA9PiAnVGhlIGNob3NlbiBzY2hlbWE6IFwiJyArIGJyYW5jaCArICdcIiBkaWQgbm90IGV4aXN0IGluIGJyYW5jaGVzOiAnICsgZm9ybWF0T2JqKGJyYW5jaGVzKSk7XG4gICAgY29uc3QgY3VzdG9tID0gKHBhdGgsIGVycikgPT4gbnUocGF0aCwgY29uc3RhbnQoZXJyKSk7XG5cbiAgICBjb25zdCBjaG9vc2VGcm9tID0gKHBhdGgsIGlucHV0LCBicmFuY2hlcywgY2gpID0+IHtcbiAgICAgIGNvbnN0IGZpZWxkcyA9IGdldCRhKGJyYW5jaGVzLCBjaCk7XG4gICAgICByZXR1cm4gZmllbGRzLmZvbGQoKCkgPT4gbWlzc2luZ0JyYW5jaChwYXRoLCBicmFuY2hlcywgY2gpLCB2cCA9PiB2cC5leHRyYWN0KHBhdGguY29uY2F0KFsnYnJhbmNoOiAnICsgY2hdKSwgaW5wdXQpKTtcbiAgICB9O1xuICAgIGNvbnN0IGNob29zZSQxID0gKGtleSwgYnJhbmNoZXMpID0+IHtcbiAgICAgIGNvbnN0IGV4dHJhY3QgPSAocGF0aCwgaW5wdXQpID0+IHtcbiAgICAgICAgY29uc3QgY2hvaWNlID0gZ2V0JGEoaW5wdXQsIGtleSk7XG4gICAgICAgIHJldHVybiBjaG9pY2UuZm9sZCgoKSA9PiBtaXNzaW5nS2V5KHBhdGgsIGtleSksIGNob3NlbiA9PiBjaG9vc2VGcm9tKHBhdGgsIGlucHV0LCBicmFuY2hlcywgY2hvc2VuKSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgdG9TdHJpbmcgPSAoKSA9PiAnY2hvb3NlT24oJyArIGtleSArICcpLiBQb3NzaWJsZSB2YWx1ZXM6ICcgKyBrZXlzKGJyYW5jaGVzKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGV4dHJhY3QsXG4gICAgICAgIHRvU3RyaW5nXG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCBzaGFsbG93ID0gKG9sZCwgbnUpID0+IHtcbiAgICAgIHJldHVybiBudTtcbiAgICB9O1xuICAgIGNvbnN0IGRlZXAgPSAob2xkLCBudSkgPT4ge1xuICAgICAgY29uc3QgYm90aE9iamVjdHMgPSBpc1BsYWluT2JqZWN0KG9sZCkgJiYgaXNQbGFpbk9iamVjdChudSk7XG4gICAgICByZXR1cm4gYm90aE9iamVjdHMgPyBkZWVwTWVyZ2Uob2xkLCBudSkgOiBudTtcbiAgICB9O1xuICAgIGNvbnN0IGJhc2VNZXJnZSA9IG1lcmdlciA9PiB7XG4gICAgICByZXR1cm4gKC4uLm9iamVjdHMpID0+IHtcbiAgICAgICAgaWYgKG9iamVjdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBtZXJnZSB6ZXJvIG9iamVjdHNgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXQgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBvYmplY3RzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgY29uc3QgY3VyT2JqZWN0ID0gb2JqZWN0c1tqXTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjdXJPYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChoYXMkMihjdXJPYmplY3QsIGtleSkpIHtcbiAgICAgICAgICAgICAgcmV0W2tleV0gPSBtZXJnZXIocmV0W2tleV0sIGN1ck9iamVjdFtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBkZWVwTWVyZ2UgPSBiYXNlTWVyZ2UoZGVlcCk7XG4gICAgY29uc3QgbWVyZ2UgPSBiYXNlTWVyZ2Uoc2hhbGxvdyk7XG5cbiAgICBjb25zdCByZXF1aXJlZCA9ICgpID0+ICh7XG4gICAgICB0YWc6ICdyZXF1aXJlZCcsXG4gICAgICBwcm9jZXNzOiB7fVxuICAgIH0pO1xuICAgIGNvbnN0IGRlZmF1bHRlZFRodW5rID0gZmFsbGJhY2tUaHVuayA9PiAoe1xuICAgICAgdGFnOiAnZGVmYXVsdGVkVGh1bmsnLFxuICAgICAgcHJvY2VzczogZmFsbGJhY2tUaHVua1xuICAgIH0pO1xuICAgIGNvbnN0IGRlZmF1bHRlZCQxID0gZmFsbGJhY2sgPT4gZGVmYXVsdGVkVGh1bmsoY29uc3RhbnQoZmFsbGJhY2spKTtcbiAgICBjb25zdCBhc09wdGlvbiA9ICgpID0+ICh7XG4gICAgICB0YWc6ICdvcHRpb24nLFxuICAgICAgcHJvY2Vzczoge31cbiAgICB9KTtcblxuICAgIGNvbnN0IG1lcmdlVmFsdWVzID0gKHZhbHVlcywgYmFzZSkgPT4gdmFsdWVzLmxlbmd0aCA+IDAgPyBTaW1wbGVSZXN1bHQuc3ZhbHVlKGRlZXBNZXJnZShiYXNlLCBtZXJnZS5hcHBseSh1bmRlZmluZWQsIHZhbHVlcykpKSA6IFNpbXBsZVJlc3VsdC5zdmFsdWUoYmFzZSk7XG4gICAgY29uc3QgbWVyZ2VFcnJvcnMgPSBlcnJvcnMgPT4gY29tcG9zZShTaW1wbGVSZXN1bHQuc2Vycm9yLCBmbGF0dGVuKShlcnJvcnMpO1xuICAgIGNvbnN0IGNvbnNvbGlkYXRlT2JqID0gKG9iamVjdHMsIGJhc2UpID0+IHtcbiAgICAgIGNvbnN0IHBhcnRpdGlvbiA9IFNpbXBsZVJlc3VsdC5wYXJ0aXRpb24ob2JqZWN0cyk7XG4gICAgICByZXR1cm4gcGFydGl0aW9uLmVycm9ycy5sZW5ndGggPiAwID8gbWVyZ2VFcnJvcnMocGFydGl0aW9uLmVycm9ycykgOiBtZXJnZVZhbHVlcyhwYXJ0aXRpb24udmFsdWVzLCBiYXNlKTtcbiAgICB9O1xuICAgIGNvbnN0IGNvbnNvbGlkYXRlQXJyID0gb2JqZWN0cyA9PiB7XG4gICAgICBjb25zdCBwYXJ0aXRpb25zID0gU2ltcGxlUmVzdWx0LnBhcnRpdGlvbihvYmplY3RzKTtcbiAgICAgIHJldHVybiBwYXJ0aXRpb25zLmVycm9ycy5sZW5ndGggPiAwID8gbWVyZ2VFcnJvcnMocGFydGl0aW9ucy5lcnJvcnMpIDogU2ltcGxlUmVzdWx0LnN2YWx1ZShwYXJ0aXRpb25zLnZhbHVlcyk7XG4gICAgfTtcbiAgICBjb25zdCBSZXN1bHRDb21iaW5lID0ge1xuICAgICAgY29uc29saWRhdGVPYmosXG4gICAgICBjb25zb2xpZGF0ZUFyclxuICAgIH07XG5cbiAgICBjb25zdCBmaWVsZCQxID0gKGtleSwgbmV3S2V5LCBwcmVzZW5jZSwgcHJvcCkgPT4gKHtcbiAgICAgIHRhZzogJ2ZpZWxkJyxcbiAgICAgIGtleSxcbiAgICAgIG5ld0tleSxcbiAgICAgIHByZXNlbmNlLFxuICAgICAgcHJvcFxuICAgIH0pO1xuICAgIGNvbnN0IGN1c3RvbUZpZWxkJDEgPSAobmV3S2V5LCBpbnN0YW50aWF0b3IpID0+ICh7XG4gICAgICB0YWc6ICdjdXN0b20nLFxuICAgICAgbmV3S2V5LFxuICAgICAgaW5zdGFudGlhdG9yXG4gICAgfSk7XG4gICAgY29uc3QgZm9sZCA9ICh2YWx1ZSwgaWZGaWVsZCwgaWZDdXN0b20pID0+IHtcbiAgICAgIHN3aXRjaCAodmFsdWUudGFnKSB7XG4gICAgICBjYXNlICdmaWVsZCc6XG4gICAgICAgIHJldHVybiBpZkZpZWxkKHZhbHVlLmtleSwgdmFsdWUubmV3S2V5LCB2YWx1ZS5wcmVzZW5jZSwgdmFsdWUucHJvcCk7XG4gICAgICBjYXNlICdjdXN0b20nOlxuICAgICAgICByZXR1cm4gaWZDdXN0b20odmFsdWUubmV3S2V5LCB2YWx1ZS5pbnN0YW50aWF0b3IpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCB2YWx1ZSA9IHZhbGlkYXRvciA9PiB7XG4gICAgICBjb25zdCBleHRyYWN0ID0gKHBhdGgsIHZhbCkgPT4ge1xuICAgICAgICByZXR1cm4gU2ltcGxlUmVzdWx0LmJpbmRFcnJvcih2YWxpZGF0b3IodmFsKSwgZXJyID0+IGN1c3RvbShwYXRoLCBlcnIpKTtcbiAgICAgIH07XG4gICAgICBjb25zdCB0b1N0cmluZyA9IGNvbnN0YW50KCd2YWwnKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGV4dHJhY3QsXG4gICAgICAgIHRvU3RyaW5nXG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgYW55VmFsdWUkMSA9IHZhbHVlKFNpbXBsZVJlc3VsdC5zdmFsdWUpO1xuXG4gICAgY29uc3QgcmVxdWlyZWRBY2Nlc3MgPSAocGF0aCwgb2JqLCBrZXksIGJ1bmRsZSkgPT4gZ2V0JGEob2JqLCBrZXkpLmZvbGQoKCkgPT4gbWlzc2luZ1JlcXVpcmVkKHBhdGgsIGtleSwgb2JqKSwgYnVuZGxlKTtcbiAgICBjb25zdCBmYWxsYmFja0FjY2VzcyA9IChvYmosIGtleSwgZmFsbGJhY2ssIGJ1bmRsZSkgPT4ge1xuICAgICAgY29uc3QgdiA9IGdldCRhKG9iaiwga2V5KS5nZXRPclRodW5rKCgpID0+IGZhbGxiYWNrKG9iaikpO1xuICAgICAgcmV0dXJuIGJ1bmRsZSh2KTtcbiAgICB9O1xuICAgIGNvbnN0IG9wdGlvbkFjY2VzcyA9IChvYmosIGtleSwgYnVuZGxlKSA9PiBidW5kbGUoZ2V0JGEob2JqLCBrZXkpKTtcbiAgICBjb25zdCBvcHRpb25EZWZhdWx0ZWRBY2Nlc3MgPSAob2JqLCBrZXksIGZhbGxiYWNrLCBidW5kbGUpID0+IHtcbiAgICAgIGNvbnN0IG9wdCA9IGdldCRhKG9iaiwga2V5KS5tYXAodmFsID0+IHZhbCA9PT0gdHJ1ZSA/IGZhbGxiYWNrKG9iaikgOiB2YWwpO1xuICAgICAgcmV0dXJuIGJ1bmRsZShvcHQpO1xuICAgIH07XG4gICAgY29uc3QgZXh0cmFjdEZpZWxkID0gKGZpZWxkLCBwYXRoLCBvYmosIGtleSwgcHJvcCkgPT4ge1xuICAgICAgY29uc3QgYnVuZGxlID0gYXYgPT4gcHJvcC5leHRyYWN0KHBhdGguY29uY2F0KFtrZXldKSwgYXYpO1xuICAgICAgY29uc3QgYnVuZGxlQXNPcHRpb24gPSBvcHRWYWx1ZSA9PiBvcHRWYWx1ZS5mb2xkKCgpID0+IFNpbXBsZVJlc3VsdC5zdmFsdWUoT3B0aW9uYWwubm9uZSgpKSwgb3YgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBwcm9wLmV4dHJhY3QocGF0aC5jb25jYXQoW2tleV0pLCBvdik7XG4gICAgICAgIHJldHVybiBTaW1wbGVSZXN1bHQubWFwKHJlc3VsdCwgT3B0aW9uYWwuc29tZSk7XG4gICAgICB9KTtcbiAgICAgIHN3aXRjaCAoZmllbGQudGFnKSB7XG4gICAgICBjYXNlICdyZXF1aXJlZCc6XG4gICAgICAgIHJldHVybiByZXF1aXJlZEFjY2VzcyhwYXRoLCBvYmosIGtleSwgYnVuZGxlKTtcbiAgICAgIGNhc2UgJ2RlZmF1bHRlZFRodW5rJzpcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrQWNjZXNzKG9iaiwga2V5LCBmaWVsZC5wcm9jZXNzLCBidW5kbGUpO1xuICAgICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgICAgcmV0dXJuIG9wdGlvbkFjY2VzcyhvYmosIGtleSwgYnVuZGxlQXNPcHRpb24pO1xuICAgICAgY2FzZSAnZGVmYXVsdGVkT3B0aW9uVGh1bmsnOlxuICAgICAgICByZXR1cm4gb3B0aW9uRGVmYXVsdGVkQWNjZXNzKG9iaiwga2V5LCBmaWVsZC5wcm9jZXNzLCBidW5kbGVBc09wdGlvbik7XG4gICAgICBjYXNlICdtZXJnZVdpdGhUaHVuayc6IHtcbiAgICAgICAgICByZXR1cm4gZmFsbGJhY2tBY2Nlc3Mob2JqLCBrZXksIGNvbnN0YW50KHt9KSwgdiA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBkZWVwTWVyZ2UoZmllbGQucHJvY2VzcyhvYmopLCB2KTtcbiAgICAgICAgICAgIHJldHVybiBidW5kbGUocmVzdWx0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZXh0cmFjdEZpZWxkcyA9IChwYXRoLCBvYmosIGZpZWxkcykgPT4ge1xuICAgICAgY29uc3Qgc3VjY2VzcyA9IHt9O1xuICAgICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIGZpZWxkcykge1xuICAgICAgICBmb2xkKGZpZWxkLCAoa2V5LCBuZXdLZXksIHByZXNlbmNlLCBwcm9wKSA9PiB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gZXh0cmFjdEZpZWxkKHByZXNlbmNlLCBwYXRoLCBvYmosIGtleSwgcHJvcCk7XG4gICAgICAgICAgU2ltcGxlUmVzdWx0LmZvbGQocmVzdWx0LCBlcnIgPT4ge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goLi4uZXJyKTtcbiAgICAgICAgICB9LCByZXMgPT4ge1xuICAgICAgICAgICAgc3VjY2Vzc1tuZXdLZXldID0gcmVzO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LCAobmV3S2V5LCBpbnN0YW50aWF0b3IpID0+IHtcbiAgICAgICAgICBzdWNjZXNzW25ld0tleV0gPSBpbnN0YW50aWF0b3Iob2JqKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZXJyb3JzLmxlbmd0aCA+IDAgPyBTaW1wbGVSZXN1bHQuc2Vycm9yKGVycm9ycykgOiBTaW1wbGVSZXN1bHQuc3ZhbHVlKHN1Y2Nlc3MpO1xuICAgIH07XG4gICAgY29uc3Qgb2JqT2YgPSB2YWx1ZXMgPT4ge1xuICAgICAgY29uc3QgZXh0cmFjdCA9IChwYXRoLCBvKSA9PiBleHRyYWN0RmllbGRzKHBhdGgsIG8sIHZhbHVlcyk7XG4gICAgICBjb25zdCB0b1N0cmluZyA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgZmllbGRTdHJpbmdzID0gbWFwJDModmFsdWVzLCB2YWx1ZSA9PiBmb2xkKHZhbHVlLCAoa2V5LCBfb2tleSwgX3ByZXNlbmNlLCBwcm9wKSA9PiBrZXkgKyAnIC0+ICcgKyBwcm9wLnRvU3RyaW5nKCksIChuZXdLZXksIF9pbnN0YW50aWF0b3IpID0+ICdzdGF0ZSgnICsgbmV3S2V5ICsgJyknKSk7XG4gICAgICAgIHJldHVybiAnb2Jqe1xcbicgKyBmaWVsZFN0cmluZ3Muam9pbignXFxuJykgKyAnfSc7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXh0cmFjdCxcbiAgICAgICAgdG9TdHJpbmdcbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBhcnJPZiA9IHByb3AgPT4ge1xuICAgICAgY29uc3QgZXh0cmFjdCA9IChwYXRoLCBhcnJheSkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHRzID0gbWFwJDMoYXJyYXksIChhLCBpKSA9PiBwcm9wLmV4dHJhY3QocGF0aC5jb25jYXQoWydbJyArIGkgKyAnXSddKSwgYSkpO1xuICAgICAgICByZXR1cm4gUmVzdWx0Q29tYmluZS5jb25zb2xpZGF0ZUFycihyZXN1bHRzKTtcbiAgICAgIH07XG4gICAgICBjb25zdCB0b1N0cmluZyA9ICgpID0+ICdhcnJheSgnICsgcHJvcC50b1N0cmluZygpICsgJyknO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXh0cmFjdCxcbiAgICAgICAgdG9TdHJpbmdcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IHZhbHVlT2YgPSB2YWxpZGF0b3IgPT4gdmFsdWUodiA9PiB2YWxpZGF0b3IodikuZm9sZChTaW1wbGVSZXN1bHQuc2Vycm9yLCBTaW1wbGVSZXN1bHQuc3ZhbHVlKSk7XG4gICAgY29uc3QgZXh0cmFjdFZhbHVlID0gKGxhYmVsLCBwcm9wLCBvYmopID0+IHtcbiAgICAgIGNvbnN0IHJlcyA9IHByb3AuZXh0cmFjdChbbGFiZWxdLCBvYmopO1xuICAgICAgcmV0dXJuIFNpbXBsZVJlc3VsdC5tYXBFcnJvcihyZXMsIGVycnMgPT4gKHtcbiAgICAgICAgaW5wdXQ6IG9iaixcbiAgICAgICAgZXJyb3JzOiBlcnJzXG4gICAgICB9KSk7XG4gICAgfTtcbiAgICBjb25zdCBhc1JhdyA9IChsYWJlbCwgcHJvcCwgb2JqKSA9PiBTaW1wbGVSZXN1bHQudG9SZXN1bHQoZXh0cmFjdFZhbHVlKGxhYmVsLCBwcm9wLCBvYmopKTtcbiAgICBjb25zdCBmb3JtYXRFcnJvciA9IGVyckluZm8gPT4ge1xuICAgICAgcmV0dXJuICdFcnJvcnM6IFxcbicgKyBmb3JtYXRFcnJvcnMoZXJySW5mby5lcnJvcnMpLmpvaW4oJ1xcbicpICsgJ1xcblxcbklucHV0IG9iamVjdDogJyArIGZvcm1hdE9iaihlcnJJbmZvLmlucHV0KTtcbiAgICB9O1xuICAgIGNvbnN0IGNob29zZSA9IChrZXksIGJyYW5jaGVzKSA9PiBjaG9vc2UkMShrZXksIG1hcCQyKGJyYW5jaGVzLCBvYmpPZikpO1xuXG4gICAgY29uc3QgYW55VmFsdWUgPSBjb25zdGFudChhbnlWYWx1ZSQxKTtcbiAgICBjb25zdCB0eXBlZFZhbHVlID0gKHZhbGlkYXRvciwgZXhwZWN0ZWRUeXBlKSA9PiB2YWx1ZShhID0+IHtcbiAgICAgIGNvbnN0IGFjdHVhbFR5cGUgPSB0eXBlb2YgYTtcbiAgICAgIHJldHVybiB2YWxpZGF0b3IoYSkgPyBTaW1wbGVSZXN1bHQuc3ZhbHVlKGEpIDogU2ltcGxlUmVzdWx0LnNlcnJvcihgRXhwZWN0ZWQgdHlwZTogJHsgZXhwZWN0ZWRUeXBlIH0gYnV0IGdvdDogJHsgYWN0dWFsVHlwZSB9YCk7XG4gICAgfSk7XG4gICAgY29uc3QgbnVtYmVyID0gdHlwZWRWYWx1ZShpc051bWJlciwgJ251bWJlcicpO1xuICAgIGNvbnN0IHN0cmluZyA9IHR5cGVkVmFsdWUoaXNTdHJpbmcsICdzdHJpbmcnKTtcbiAgICBjb25zdCBib29sZWFuID0gdHlwZWRWYWx1ZShpc0Jvb2xlYW4sICdib29sZWFuJyk7XG4gICAgY29uc3QgZnVuY3Rpb25Qcm9jZXNzb3IgPSB0eXBlZFZhbHVlKGlzRnVuY3Rpb24sICdmdW5jdGlvbicpO1xuXG4gICAgY29uc3QgZmllbGQgPSBmaWVsZCQxO1xuICAgIGNvbnN0IGN1c3RvbUZpZWxkID0gY3VzdG9tRmllbGQkMTtcbiAgICBjb25zdCB2YWxpZGF0ZUVudW0gPSB2YWx1ZXMgPT4gdmFsdWVPZih2YWx1ZSA9PiBjb250YWlucyQyKHZhbHVlcywgdmFsdWUpID8gUmVzdWx0LnZhbHVlKHZhbHVlKSA6IFJlc3VsdC5lcnJvcihgVW5zdXBwb3J0ZWQgdmFsdWU6IFwiJHsgdmFsdWUgfVwiLCBjaG9vc2Ugb25lIG9mIFwiJHsgdmFsdWVzLmpvaW4oJywgJykgfVwiLmApKTtcbiAgICBjb25zdCByZXF1aXJlZE9mID0gKGtleSwgc2NoZW1hKSA9PiBmaWVsZChrZXksIGtleSwgcmVxdWlyZWQoKSwgc2NoZW1hKTtcbiAgICBjb25zdCByZXF1aXJlZFN0cmluZyA9IGtleSA9PiByZXF1aXJlZE9mKGtleSwgc3RyaW5nKTtcbiAgICBjb25zdCByZXF1aXJlZEZ1bmN0aW9uID0ga2V5ID0+IHJlcXVpcmVkT2Yoa2V5LCBmdW5jdGlvblByb2Nlc3Nvcik7XG4gICAgY29uc3QgcmVxdWlyZWRBcnJheU9mID0gKGtleSwgc2NoZW1hKSA9PiBmaWVsZChrZXksIGtleSwgcmVxdWlyZWQoKSwgYXJyT2Yoc2NoZW1hKSk7XG4gICAgY29uc3Qgb3B0aW9uT2YgPSAoa2V5LCBzY2hlbWEpID0+IGZpZWxkKGtleSwga2V5LCBhc09wdGlvbigpLCBzY2hlbWEpO1xuICAgIGNvbnN0IG9wdGlvblN0cmluZyA9IGtleSA9PiBvcHRpb25PZihrZXksIHN0cmluZyk7XG4gICAgY29uc3Qgb3B0aW9uRnVuY3Rpb24gPSBrZXkgPT4gb3B0aW9uT2Yoa2V5LCBmdW5jdGlvblByb2Nlc3Nvcik7XG4gICAgY29uc3QgZGVmYXVsdGVkID0gKGtleSwgZmFsbGJhY2spID0+IGZpZWxkKGtleSwga2V5LCBkZWZhdWx0ZWQkMShmYWxsYmFjayksIGFueVZhbHVlKCkpO1xuICAgIGNvbnN0IGRlZmF1bHRlZE9mID0gKGtleSwgZmFsbGJhY2ssIHNjaGVtYSkgPT4gZmllbGQoa2V5LCBrZXksIGRlZmF1bHRlZCQxKGZhbGxiYWNrKSwgc2NoZW1hKTtcbiAgICBjb25zdCBkZWZhdWx0ZWROdW1iZXIgPSAoa2V5LCBmYWxsYmFjaykgPT4gZGVmYXVsdGVkT2Yoa2V5LCBmYWxsYmFjaywgbnVtYmVyKTtcbiAgICBjb25zdCBkZWZhdWx0ZWRTdHJpbmcgPSAoa2V5LCBmYWxsYmFjaykgPT4gZGVmYXVsdGVkT2Yoa2V5LCBmYWxsYmFjaywgc3RyaW5nKTtcbiAgICBjb25zdCBkZWZhdWx0ZWRTdHJpbmdFbnVtID0gKGtleSwgZmFsbGJhY2ssIHZhbHVlcykgPT4gZGVmYXVsdGVkT2Yoa2V5LCBmYWxsYmFjaywgdmFsaWRhdGVFbnVtKHZhbHVlcykpO1xuICAgIGNvbnN0IGRlZmF1bHRlZEJvb2xlYW4gPSAoa2V5LCBmYWxsYmFjaykgPT4gZGVmYXVsdGVkT2Yoa2V5LCBmYWxsYmFjaywgYm9vbGVhbik7XG4gICAgY29uc3QgZGVmYXVsdGVkRnVuY3Rpb24gPSAoa2V5LCBmYWxsYmFjaykgPT4gZGVmYXVsdGVkT2Yoa2V5LCBmYWxsYmFjaywgZnVuY3Rpb25Qcm9jZXNzb3IpO1xuICAgIGNvbnN0IGRlZmF1bHRlZEFycmF5T2YgPSAoa2V5LCBmYWxsYmFjaywgc2NoZW1hKSA9PiBkZWZhdWx0ZWRPZihrZXksIGZhbGxiYWNrLCBhcnJPZihzY2hlbWEpKTtcblxuICAgIGNvbnN0IHR5cGUgPSByZXF1aXJlZFN0cmluZygndHlwZScpO1xuICAgIGNvbnN0IGZldGNoID0gcmVxdWlyZWRGdW5jdGlvbignZmV0Y2gnKTtcbiAgICBjb25zdCBvbkFjdGlvbiA9IHJlcXVpcmVkRnVuY3Rpb24oJ29uQWN0aW9uJyk7XG4gICAgY29uc3Qgb25TZXR1cCA9IGRlZmF1bHRlZEZ1bmN0aW9uKCdvblNldHVwJywgKCkgPT4gbm9vcCk7XG4gICAgY29uc3Qgb3B0aW9uYWxUZXh0ID0gb3B0aW9uU3RyaW5nKCd0ZXh0Jyk7XG4gICAgY29uc3Qgb3B0aW9uYWxJY29uID0gb3B0aW9uU3RyaW5nKCdpY29uJyk7XG4gICAgY29uc3Qgb3B0aW9uYWxUb29sdGlwID0gb3B0aW9uU3RyaW5nKCd0b29sdGlwJyk7XG4gICAgY29uc3Qgb3B0aW9uYWxMYWJlbCA9IG9wdGlvblN0cmluZygnbGFiZWwnKTtcbiAgICBjb25zdCBhY3RpdmUgPSBkZWZhdWx0ZWRCb29sZWFuKCdhY3RpdmUnLCBmYWxzZSk7XG4gICAgY29uc3QgZW5hYmxlZCA9IGRlZmF1bHRlZEJvb2xlYW4oJ2VuYWJsZWQnLCB0cnVlKTtcbiAgICBjb25zdCBwcmltYXJ5ID0gZGVmYXVsdGVkQm9vbGVhbigncHJpbWFyeScsIGZhbHNlKTtcbiAgICBjb25zdCBkZWZhdWx0ZWRDb2x1bW5zID0gbnVtID0+IGRlZmF1bHRlZCgnY29sdW1ucycsIG51bSk7XG4gICAgY29uc3QgZGVmYXVsdGVkVHlwZSA9IHR5cGUgPT4gZGVmYXVsdGVkU3RyaW5nKCd0eXBlJywgdHlwZSk7XG5cbiAgICBjb25zdCBhdXRvY29tcGxldGVyU2NoZW1hID0gb2JqT2YoW1xuICAgICAgdHlwZSxcbiAgICAgIHJlcXVpcmVkU3RyaW5nKCdjaCcpLFxuICAgICAgZGVmYXVsdGVkTnVtYmVyKCdtaW5DaGFycycsIDEpLFxuICAgICAgZGVmYXVsdGVkQ29sdW1ucygxKSxcbiAgICAgIGRlZmF1bHRlZE51bWJlcignbWF4UmVzdWx0cycsIDEwKSxcbiAgICAgIG9wdGlvbkZ1bmN0aW9uKCdtYXRjaGVzJyksXG4gICAgICBmZXRjaCxcbiAgICAgIG9uQWN0aW9uLFxuICAgICAgZGVmYXVsdGVkQXJyYXlPZignaGlnaGxpZ2h0T24nLCBbXSwgc3RyaW5nKVxuICAgIF0pO1xuICAgIGNvbnN0IGNyZWF0ZUF1dG9jb21wbGV0ZXIgPSBzcGVjID0+IGFzUmF3KCdBdXRvY29tcGxldGVyJywgYXV0b2NvbXBsZXRlclNjaGVtYSwgc3BlYyk7XG5cbiAgICBjb25zdCBiYXNlVG9vbGJhckJ1dHRvbkZpZWxkcyA9IFtcbiAgICAgIGVuYWJsZWQsXG4gICAgICBvcHRpb25hbFRvb2x0aXAsXG4gICAgICBvcHRpb25hbEljb24sXG4gICAgICBvcHRpb25hbFRleHQsXG4gICAgICBvblNldHVwXG4gICAgXTtcblxuICAgIGNvbnN0IGJhc2VUb29sYmFyVG9nZ2xlQnV0dG9uRmllbGRzID0gW2FjdGl2ZV0uY29uY2F0KGJhc2VUb29sYmFyQnV0dG9uRmllbGRzKTtcblxuICAgIGNvbnN0IGNvbnRleHRCYXJGaWVsZHMgPSBbXG4gICAgICBkZWZhdWx0ZWRGdW5jdGlvbigncHJlZGljYXRlJywgbmV2ZXIpLFxuICAgICAgZGVmYXVsdGVkU3RyaW5nRW51bSgnc2NvcGUnLCAnbm9kZScsIFtcbiAgICAgICAgJ25vZGUnLFxuICAgICAgICAnZWRpdG9yJ1xuICAgICAgXSksXG4gICAgICBkZWZhdWx0ZWRTdHJpbmdFbnVtKCdwb3NpdGlvbicsICdzZWxlY3Rpb24nLCBbXG4gICAgICAgICdub2RlJyxcbiAgICAgICAgJ3NlbGVjdGlvbicsXG4gICAgICAgICdsaW5lJ1xuICAgICAgXSlcbiAgICBdO1xuXG4gICAgY29uc3QgY29udGV4dEJ1dHRvbkZpZWxkcyA9IGJhc2VUb29sYmFyQnV0dG9uRmllbGRzLmNvbmNhdChbXG4gICAgICBkZWZhdWx0ZWRUeXBlKCdjb250ZXh0Zm9ybWJ1dHRvbicpLFxuICAgICAgcHJpbWFyeSxcbiAgICAgIG9uQWN0aW9uLFxuICAgICAgY3VzdG9tRmllbGQoJ29yaWdpbmFsJywgaWRlbnRpdHkpXG4gICAgXSk7XG4gICAgY29uc3QgY29udGV4dFRvZ2dsZUJ1dHRvbkZpZWxkcyA9IGJhc2VUb29sYmFyVG9nZ2xlQnV0dG9uRmllbGRzLmNvbmNhdChbXG4gICAgICBkZWZhdWx0ZWRUeXBlKCdjb250ZXh0Zm9ybWJ1dHRvbicpLFxuICAgICAgcHJpbWFyeSxcbiAgICAgIG9uQWN0aW9uLFxuICAgICAgY3VzdG9tRmllbGQoJ29yaWdpbmFsJywgaWRlbnRpdHkpXG4gICAgXSk7XG4gICAgY29uc3QgbGF1bmNoQnV0dG9uRmllbGRzID0gYmFzZVRvb2xiYXJCdXR0b25GaWVsZHMuY29uY2F0KFtkZWZhdWx0ZWRUeXBlKCdjb250ZXh0Zm9ybWJ1dHRvbicpXSk7XG4gICAgY29uc3QgbGF1bmNoVG9nZ2xlQnV0dG9uRmllbGRzID0gYmFzZVRvb2xiYXJUb2dnbGVCdXR0b25GaWVsZHMuY29uY2F0KFtkZWZhdWx0ZWRUeXBlKCdjb250ZXh0Zm9ybXRvZ2dsZWJ1dHRvbicpXSk7XG4gICAgY29uc3QgdG9nZ2xlT3JOb3JtYWwgPSBjaG9vc2UoJ3R5cGUnLCB7XG4gICAgICBjb250ZXh0Zm9ybWJ1dHRvbjogY29udGV4dEJ1dHRvbkZpZWxkcyxcbiAgICAgIGNvbnRleHRmb3JtdG9nZ2xlYnV0dG9uOiBjb250ZXh0VG9nZ2xlQnV0dG9uRmllbGRzXG4gICAgfSk7XG4gICAgb2JqT2YoW1xuICAgICAgZGVmYXVsdGVkVHlwZSgnY29udGV4dGZvcm0nKSxcbiAgICAgIGRlZmF1bHRlZEZ1bmN0aW9uKCdpbml0VmFsdWUnLCBjb25zdGFudCgnJykpLFxuICAgICAgb3B0aW9uYWxMYWJlbCxcbiAgICAgIHJlcXVpcmVkQXJyYXlPZignY29tbWFuZHMnLCB0b2dnbGVPck5vcm1hbCksXG4gICAgICBvcHRpb25PZignbGF1bmNoJywgY2hvb3NlKCd0eXBlJywge1xuICAgICAgICBjb250ZXh0Zm9ybWJ1dHRvbjogbGF1bmNoQnV0dG9uRmllbGRzLFxuICAgICAgICBjb250ZXh0Zm9ybXRvZ2dsZWJ1dHRvbjogbGF1bmNoVG9nZ2xlQnV0dG9uRmllbGRzXG4gICAgICB9KSlcbiAgICBdLmNvbmNhdChjb250ZXh0QmFyRmllbGRzKSk7XG5cbiAgICBjb25zdCByZWdpc3RlciQyID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IHBvcHVwcyA9IGVkaXRvci51aS5yZWdpc3RyeS5nZXRBbGwoKS5wb3B1cHM7XG4gICAgICBjb25zdCBkYXRhc2V0ID0gbWFwJDIocG9wdXBzLCBwb3B1cCA9PiBjcmVhdGVBdXRvY29tcGxldGVyKHBvcHVwKS5mb2xkKGVyciA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihmb3JtYXRFcnJvcihlcnIpKTtcbiAgICAgIH0sIGlkZW50aXR5KSk7XG4gICAgICBjb25zdCB0cmlnZ2VyQ2hhcnMgPSBzdHJpbmdBcnJheShtYXBUb0FycmF5KGRhdGFzZXQsIHYgPT4gdi5jaCkpO1xuICAgICAgY29uc3QgZGF0YXNldFZhbHVlcyA9IHZhbHVlcyhkYXRhc2V0KTtcbiAgICAgIGNvbnN0IGxvb2t1cEJ5Q2hhciA9IGNoID0+IGZpbHRlciQ2KGRhdGFzZXRWYWx1ZXMsIGR2ID0+IGR2LmNoID09PSBjaCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhc2V0LFxuICAgICAgICB0cmlnZ2VyQ2hhcnMsXG4gICAgICAgIGxvb2t1cEJ5Q2hhclxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgY29uc3Qgc2V0dXBFZGl0b3JJbnB1dCA9IChlZGl0b3IsIGFwaSkgPT4ge1xuICAgICAgY29uc3QgdXBkYXRlID0gbGFzdCQxKGFwaS5sb2FkLCA1MCk7XG4gICAgICBlZGl0b3Iub24oJ2tleXByZXNzIGNvbXBvc2l0aW9uZW5kJywgZSA9PiB7XG4gICAgICAgIGlmIChlLndoaWNoID09PSAyNykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGUudGhyb3R0bGUoKTtcbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLm9uKCdrZXlkb3duJywgZSA9PiB7XG4gICAgICAgIGNvbnN0IGtleUNvZGUgPSBlLndoaWNoO1xuICAgICAgICBpZiAoa2V5Q29kZSA9PT0gOCkge1xuICAgICAgICAgIHVwZGF0ZS50aHJvdHRsZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKGtleUNvZGUgPT09IDI3KSB7XG4gICAgICAgICAgYXBpLmNhbmNlbElmTmVjZXNzYXJ5KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLm9uKCdyZW1vdmUnLCB1cGRhdGUuY2FuY2VsKTtcbiAgICB9O1xuICAgIGNvbnN0IHNldHVwJGogPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgYWN0aXZlQXV0b2NvbXBsZXRlciA9IHZhbHVlJDIoKTtcbiAgICAgIGNvbnN0IHVpQWN0aXZlID0gQ2VsbChmYWxzZSk7XG4gICAgICBjb25zdCBpc0FjdGl2ZSA9IGFjdGl2ZUF1dG9jb21wbGV0ZXIuaXNTZXQ7XG4gICAgICBjb25zdCBjYW5jZWxJZk5lY2Vzc2FyeSA9ICgpID0+IHtcbiAgICAgICAgaWYgKGlzQWN0aXZlKCkpIHtcbiAgICAgICAgICByZW1vdmVBdXRvY29tcGxldGVyRGVjb3JhdGlvbihlZGl0b3IpO1xuICAgICAgICAgIGZpcmVBdXRvY29tcGxldGVyRW5kKGVkaXRvcik7XG4gICAgICAgICAgdWlBY3RpdmUuc2V0KGZhbHNlKTtcbiAgICAgICAgICBhY3RpdmVBdXRvY29tcGxldGVyLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBjb21tZW5jZUlmTmVjZXNzYXJ5ID0gY29udGV4dCA9PiB7XG4gICAgICAgIGlmICghaXNBY3RpdmUoKSkge1xuICAgICAgICAgIGFkZEF1dG9jb21wbGV0ZXJEZWNvcmF0aW9uKGVkaXRvciwgY29udGV4dC5yYW5nZSk7XG4gICAgICAgICAgYWN0aXZlQXV0b2NvbXBsZXRlci5zZXQoe1xuICAgICAgICAgICAgdHJpZ2dlckNoYXI6IGNvbnRleHQudHJpZ2dlckNoYXIsXG4gICAgICAgICAgICBtYXRjaExlbmd0aDogY29udGV4dC50ZXh0Lmxlbmd0aFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgZ2V0QXV0b2NvbXBsZXRlcnMgPSBjYWNoZWQoKCkgPT4gcmVnaXN0ZXIkMihlZGl0b3IpKTtcbiAgICAgIGNvbnN0IGRvTG9va3VwID0gZmV0Y2hPcHRpb25zID0+IGFjdGl2ZUF1dG9jb21wbGV0ZXIuZ2V0KCkubWFwKGFjID0+IGdldENvbnRleHQoZWRpdG9yLmRvbSwgZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKSwgYWMudHJpZ2dlckNoYXIpLmJpbmQobmV3Q29udGV4dCA9PiBsb29rdXBXaXRoQ29udGV4dChlZGl0b3IsIGdldEF1dG9jb21wbGV0ZXJzLCBuZXdDb250ZXh0LCBmZXRjaE9wdGlvbnMpKSkuZ2V0T3JUaHVuaygoKSA9PiBsb29rdXAoZWRpdG9yLCBnZXRBdXRvY29tcGxldGVycykpO1xuICAgICAgY29uc3QgbG9hZCA9IGZldGNoT3B0aW9ucyA9PiB7XG4gICAgICAgIGRvTG9va3VwKGZldGNoT3B0aW9ucykuZm9sZChjYW5jZWxJZk5lY2Vzc2FyeSwgbG9va3VwSW5mbyA9PiB7XG4gICAgICAgICAgY29tbWVuY2VJZk5lY2Vzc2FyeShsb29rdXBJbmZvLmNvbnRleHQpO1xuICAgICAgICAgIGxvb2t1cEluZm8ubG9va3VwRGF0YS50aGVuKGxvb2t1cERhdGEgPT4ge1xuICAgICAgICAgICAgYWN0aXZlQXV0b2NvbXBsZXRlci5nZXQoKS5tYXAoYWMgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBjb250ZXh0ID0gbG9va3VwSW5mby5jb250ZXh0O1xuICAgICAgICAgICAgICBpZiAoYWMudHJpZ2dlckNoYXIgPT09IGNvbnRleHQudHJpZ2dlckNoYXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29udGV4dC50ZXh0Lmxlbmd0aCAtIGFjLm1hdGNoTGVuZ3RoID49IDEwKSB7XG4gICAgICAgICAgICAgICAgICBjYW5jZWxJZk5lY2Vzc2FyeSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBhY3RpdmVBdXRvY29tcGxldGVyLnNldCh7XG4gICAgICAgICAgICAgICAgICAgIC4uLmFjLFxuICAgICAgICAgICAgICAgICAgICBtYXRjaExlbmd0aDogY29udGV4dC50ZXh0Lmxlbmd0aFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBpZiAodWlBY3RpdmUuZ2V0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyZUF1dG9jb21wbGV0ZXJVcGRhdGUoZWRpdG9yLCB7IGxvb2t1cERhdGEgfSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1aUFjdGl2ZS5zZXQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGZpcmVBdXRvY29tcGxldGVyU3RhcnQoZWRpdG9yLCB7IGxvb2t1cERhdGEgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgZWRpdG9yLmFkZENvbW1hbmQoJ21jZUF1dG9jb21wbGV0ZXJSZWxvYWQnLCAoX3VpLCB2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCBmZXRjaE9wdGlvbnMgPSBpc09iamVjdCh2YWx1ZSkgPyB2YWx1ZS5mZXRjaE9wdGlvbnMgOiB7fTtcbiAgICAgICAgbG9hZChmZXRjaE9wdGlvbnMpO1xuICAgICAgfSk7XG4gICAgICBlZGl0b3IuYWRkQ29tbWFuZCgnbWNlQXV0b2NvbXBsZXRlckNsb3NlJywgY2FuY2VsSWZOZWNlc3NhcnkpO1xuICAgICAgc2V0dXBFZGl0b3JJbnB1dChlZGl0b3IsIHtcbiAgICAgICAgY2FuY2VsSWZOZWNlc3NhcnksXG4gICAgICAgIGxvYWRcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCBjcmVhdGVBbmRGaXJlSW5wdXRFdmVudCA9IGV2ZW50VHlwZSA9PiAoZWRpdG9yLCBpbnB1dFR5cGUsIHNwZWNpZmljcyA9IHt9KSA9PiB7XG4gICAgICBjb25zdCB0YXJnZXQgPSBlZGl0b3IuZ2V0Qm9keSgpO1xuICAgICAgY29uc3Qgb3ZlcnJpZGVzID0ge1xuICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICBjb21wb3NlZDogdHJ1ZSxcbiAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgaXNDb21wb3Npbmc6IGZhbHNlLFxuICAgICAgICBkZXRhaWw6IDAsXG4gICAgICAgIHZpZXc6IG51bGwsXG4gICAgICAgIHRhcmdldCxcbiAgICAgICAgY3VycmVudFRhcmdldDogdGFyZ2V0LFxuICAgICAgICBldmVudFBoYXNlOiBFdmVudC5BVF9UQVJHRVQsXG4gICAgICAgIG9yaWdpbmFsVGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgIGV4cGxpY2l0T3JpZ2luYWxUYXJnZXQ6IHRhcmdldCxcbiAgICAgICAgaXNUcnVzdGVkOiBmYWxzZSxcbiAgICAgICAgc3JjRWxlbWVudDogdGFyZ2V0LFxuICAgICAgICBjYW5jZWxhYmxlOiBmYWxzZSxcbiAgICAgICAgcHJldmVudERlZmF1bHQ6IG5vb3AsXG4gICAgICAgIGlucHV0VHlwZVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGlucHV0ID0gY2xvbmUkMyhuZXcgSW5wdXRFdmVudChldmVudFR5cGUpKTtcbiAgICAgIHJldHVybiBlZGl0b3IuZGlzcGF0Y2goZXZlbnRUeXBlLCB7XG4gICAgICAgIC4uLmlucHV0LFxuICAgICAgICAuLi5vdmVycmlkZXMsXG4gICAgICAgIC4uLnNwZWNpZmljc1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBmaXJlRmFrZUlucHV0RXZlbnQgPSBjcmVhdGVBbmRGaXJlSW5wdXRFdmVudCgnaW5wdXQnKTtcbiAgICBjb25zdCBmaXJlRmFrZUJlZm9yZUlucHV0RXZlbnQgPSBjcmVhdGVBbmRGaXJlSW5wdXRFdmVudCgnYmVmb3JlaW5wdXQnKTtcblxuICAgIGNvbnN0IGV4ZWN1dGVLZXlkb3duT3ZlcnJpZGUkMyA9IChlZGl0b3IsIGNhcmV0LCBldnQpID0+IHtcbiAgICAgIGNvbnN0IGlucHV0VHlwZSA9IGV2dC5rZXlDb2RlID09PSBWSy5CQUNLU1BBQ0UgPyAnZGVsZXRlQ29udGVudEJhY2t3YXJkJyA6ICdkZWxldGVDb250ZW50Rm9yd2FyZCc7XG4gICAgICBleGVjdXRlV2l0aERlbGF5ZWRBY3Rpb24oW1xuICAgICAgICB7XG4gICAgICAgICAga2V5Q29kZTogVksuQkFDS1NQQUNFLFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKGJhY2tzcGFjZURlbGV0ZSwgZWRpdG9yKVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAga2V5Q29kZTogVksuQkFDS1NQQUNFLFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKGJhY2tzcGFjZURlbGV0ZSQ1LCBlZGl0b3IsIGZhbHNlKVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAga2V5Q29kZTogVksuREVMRVRFLFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKGJhY2tzcGFjZURlbGV0ZSQ1LCBlZGl0b3IsIHRydWUpXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBrZXlDb2RlOiBWSy5CQUNLU1BBQ0UsXG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24oYmFja3NwYWNlRGVsZXRlJDYsIGVkaXRvciwgZmFsc2UpXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBrZXlDb2RlOiBWSy5ERUxFVEUsXG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24oYmFja3NwYWNlRGVsZXRlJDYsIGVkaXRvciwgdHJ1ZSlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLkJBQ0tTUEFDRSxcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbihiYWNrc3BhY2VEZWxldGUkMywgZWRpdG9yLCBjYXJldCwgZmFsc2UpXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBrZXlDb2RlOiBWSy5ERUxFVEUsXG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24oYmFja3NwYWNlRGVsZXRlJDMsIGVkaXRvciwgY2FyZXQsIHRydWUpXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBrZXlDb2RlOiBWSy5CQUNLU1BBQ0UsXG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24oYmFja3NwYWNlRGVsZXRlJDksIGVkaXRvciwgZmFsc2UpXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBrZXlDb2RlOiBWSy5ERUxFVEUsXG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24oYmFja3NwYWNlRGVsZXRlJDksIGVkaXRvciwgdHJ1ZSlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLkJBQ0tTUEFDRSxcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbihiYWNrc3BhY2VEZWxldGUkNCwgZWRpdG9yLCBmYWxzZSlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLkRFTEVURSxcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbihiYWNrc3BhY2VEZWxldGUkNCwgZWRpdG9yLCB0cnVlKVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAga2V5Q29kZTogVksuQkFDS1NQQUNFLFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKGJhY2tzcGFjZURlbGV0ZSQxLCBlZGl0b3IsIGZhbHNlKVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAga2V5Q29kZTogVksuREVMRVRFLFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKGJhY2tzcGFjZURlbGV0ZSQxLCBlZGl0b3IsIHRydWUpXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBrZXlDb2RlOiBWSy5CQUNLU1BBQ0UsXG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24oYmFja3NwYWNlRGVsZXRlJDcsIGVkaXRvciwgZmFsc2UpXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBrZXlDb2RlOiBWSy5ERUxFVEUsXG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24oYmFja3NwYWNlRGVsZXRlJDcsIGVkaXRvciwgdHJ1ZSlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLkJBQ0tTUEFDRSxcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbihiYWNrc3BhY2VEZWxldGUkOCwgZWRpdG9yLCBmYWxzZSlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLkRFTEVURSxcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbihiYWNrc3BhY2VEZWxldGUkOCwgZWRpdG9yLCB0cnVlKVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAga2V5Q29kZTogVksuQkFDS1NQQUNFLFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKGJhY2tzcGFjZURlbGV0ZSQyLCBlZGl0b3IsIGZhbHNlKVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAga2V5Q29kZTogVksuREVMRVRFLFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKGJhY2tzcGFjZURlbGV0ZSQyLCBlZGl0b3IsIHRydWUpXG4gICAgICAgIH1cbiAgICAgIF0sIGV2dCkuZWFjaChhcHBseUFjdGlvbiA9PiB7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBjb25zdCBiZWZvcmVJbnB1dCA9IGZpcmVGYWtlQmVmb3JlSW5wdXRFdmVudChlZGl0b3IsIGlucHV0VHlwZSk7XG4gICAgICAgIGlmICghYmVmb3JlSW5wdXQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgICBhcHBseUFjdGlvbigpO1xuICAgICAgICAgIGZpcmVGYWtlSW5wdXRFdmVudChlZGl0b3IsIGlucHV0VHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgZXhlY3V0ZUtleXVwT3ZlcnJpZGUgPSAoZWRpdG9yLCBldnQpID0+IHtcbiAgICAgIGV4ZWN1dGUoW1xuICAgICAgICB7XG4gICAgICAgICAga2V5Q29kZTogVksuQkFDS1NQQUNFLFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKHBhZGRFbXB0eUVsZW1lbnQsIGVkaXRvcilcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLkRFTEVURSxcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbihwYWRkRW1wdHlFbGVtZW50LCBlZGl0b3IpXG4gICAgICAgIH1cbiAgICAgIF0sIGV2dCk7XG4gICAgfTtcbiAgICBjb25zdCBzZXR1cCRpID0gKGVkaXRvciwgY2FyZXQpID0+IHtcbiAgICAgIGVkaXRvci5vbigna2V5ZG93bicsIGV2dCA9PiB7XG4gICAgICAgIGlmIChldnQuaXNEZWZhdWx0UHJldmVudGVkKCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgZXhlY3V0ZUtleWRvd25PdmVycmlkZSQzKGVkaXRvciwgY2FyZXQsIGV2dCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLm9uKCdrZXl1cCcsIGV2dCA9PiB7XG4gICAgICAgIGlmIChldnQuaXNEZWZhdWx0UHJldmVudGVkKCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgZXhlY3V0ZUtleXVwT3ZlcnJpZGUoZWRpdG9yLCBldnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3QgZmlyc3ROb25XaGl0ZVNwYWNlTm9kZVNpYmxpbmcgPSBub2RlID0+IHtcbiAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAxIHx8IG5vZGUubm9kZVR5cGUgPT09IDMgJiYgbm9kZS5kYXRhICYmIC9bXFxyXFxuXFxzXS8udGVzdChub2RlLmRhdGEpKSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBtb3ZlVG9DYXJldFBvc2l0aW9uID0gKGVkaXRvciwgcm9vdCkgPT4ge1xuICAgICAgbGV0IG5vZGUsIGxhc3ROb2RlID0gcm9vdDtcbiAgICAgIGNvbnN0IGRvbSA9IGVkaXRvci5kb207XG4gICAgICBjb25zdCBtb3ZlQ2FyZXRCZWZvcmVPbkVudGVyRWxlbWVudHNNYXAgPSBlZGl0b3Iuc2NoZW1hLmdldE1vdmVDYXJldEJlZm9yZU9uRW50ZXJFbGVtZW50cygpO1xuICAgICAgaWYgKCFyb290KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICgvXihMSXxEVHxERCkkLy50ZXN0KHJvb3Qubm9kZU5hbWUpKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSBmaXJzdE5vbldoaXRlU3BhY2VOb2RlU2libGluZyhyb290LmZpcnN0Q2hpbGQpO1xuICAgICAgICBpZiAoZmlyc3RDaGlsZCAmJiAvXihVTHxPTHxETCkkLy50ZXN0KGZpcnN0Q2hpbGQubm9kZU5hbWUpKSB7XG4gICAgICAgICAgcm9vdC5pbnNlcnRCZWZvcmUoZG9tLmRvYy5jcmVhdGVUZXh0Tm9kZShuYnNwKSwgcm9vdC5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qgcm5nID0gZG9tLmNyZWF0ZVJuZygpO1xuICAgICAgcm9vdC5ub3JtYWxpemUoKTtcbiAgICAgIGlmIChyb290Lmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICBjb25zdCB3YWxrZXIgPSBuZXcgRG9tVHJlZVdhbGtlcihyb290LCByb290KTtcbiAgICAgICAgd2hpbGUgKG5vZGUgPSB3YWxrZXIuY3VycmVudCgpKSB7XG4gICAgICAgICAgaWYgKGlzVGV4dCQ4KG5vZGUpKSB7XG4gICAgICAgICAgICBybmcuc2V0U3RhcnQobm9kZSwgMCk7XG4gICAgICAgICAgICBybmcuc2V0RW5kKG5vZGUsIDApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtb3ZlQ2FyZXRCZWZvcmVPbkVudGVyRWxlbWVudHNNYXBbbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpXSkge1xuICAgICAgICAgICAgcm5nLnNldFN0YXJ0QmVmb3JlKG5vZGUpO1xuICAgICAgICAgICAgcm5nLnNldEVuZEJlZm9yZShub2RlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsYXN0Tm9kZSA9IG5vZGU7XG4gICAgICAgICAgbm9kZSA9IHdhbGtlci5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgcm5nLnNldFN0YXJ0KGxhc3ROb2RlLCAwKTtcbiAgICAgICAgICBybmcuc2V0RW5kKGxhc3ROb2RlLCAwKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzQnIkNShyb290KSkge1xuICAgICAgICAgIGlmIChyb290Lm5leHRTaWJsaW5nICYmIGRvbS5pc0Jsb2NrKHJvb3QubmV4dFNpYmxpbmcpKSB7XG4gICAgICAgICAgICBybmcuc2V0U3RhcnRCZWZvcmUocm9vdCk7XG4gICAgICAgICAgICBybmcuc2V0RW5kQmVmb3JlKHJvb3QpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBybmcuc2V0U3RhcnRBZnRlcihyb290KTtcbiAgICAgICAgICAgIHJuZy5zZXRFbmRBZnRlcihyb290KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcm5nLnNldFN0YXJ0KHJvb3QsIDApO1xuICAgICAgICAgIHJuZy5zZXRFbmQocm9vdCwgMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2V0Um5nKHJuZyk7XG4gICAgICBzY3JvbGxSYW5nZUludG9WaWV3KGVkaXRvciwgcm5nKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldEVkaXRhYmxlUm9vdCQxID0gKGRvbSwgbm9kZSkgPT4ge1xuICAgICAgY29uc3Qgcm9vdCA9IGRvbS5nZXRSb290KCk7XG4gICAgICBsZXQgcGFyZW50LCBlZGl0YWJsZVJvb3Q7XG4gICAgICBwYXJlbnQgPSBub2RlO1xuICAgICAgd2hpbGUgKHBhcmVudCAhPT0gcm9vdCAmJiBkb20uZ2V0Q29udGVudEVkaXRhYmxlKHBhcmVudCkgIT09ICdmYWxzZScpIHtcbiAgICAgICAgaWYgKGRvbS5nZXRDb250ZW50RWRpdGFibGUocGFyZW50KSA9PT0gJ3RydWUnKSB7XG4gICAgICAgICAgZWRpdGFibGVSb290ID0gcGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcmVudCAhPT0gcm9vdCA/IGVkaXRhYmxlUm9vdCA6IHJvb3Q7XG4gICAgfTtcbiAgICBjb25zdCBnZXRQYXJlbnRCbG9jayQxID0gZWRpdG9yID0+IHtcbiAgICAgIHJldHVybiBPcHRpb25hbC5mcm9tKGVkaXRvci5kb20uZ2V0UGFyZW50KGVkaXRvci5zZWxlY3Rpb24uZ2V0U3RhcnQodHJ1ZSksIGVkaXRvci5kb20uaXNCbG9jaykpO1xuICAgIH07XG4gICAgY29uc3QgZ2V0UGFyZW50QmxvY2tOYW1lID0gZWRpdG9yID0+IHtcbiAgICAgIHJldHVybiBnZXRQYXJlbnRCbG9jayQxKGVkaXRvcikuZm9sZChjb25zdGFudCgnJyksIHBhcmVudEJsb2NrID0+IHtcbiAgICAgICAgcmV0dXJuIHBhcmVudEJsb2NrLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGlzTGlzdEl0ZW1QYXJlbnRCbG9jayA9IGVkaXRvciA9PiB7XG4gICAgICByZXR1cm4gZ2V0UGFyZW50QmxvY2skMShlZGl0b3IpLmZpbHRlcihlbG0gPT4ge1xuICAgICAgICByZXR1cm4gaXNMaXN0SXRlbShTdWdhckVsZW1lbnQuZnJvbURvbShlbG0pKTtcbiAgICAgIH0pLmlzU29tZSgpO1xuICAgIH07XG5cbiAgICBjb25zdCBoYXNGaXJzdENoaWxkID0gKGVsbSwgbmFtZSkgPT4ge1xuICAgICAgcmV0dXJuIGVsbS5maXJzdENoaWxkICYmIGVsbS5maXJzdENoaWxkLm5vZGVOYW1lID09PSBuYW1lO1xuICAgIH07XG4gICAgY29uc3QgaXNGaXJzdENoaWxkID0gZWxtID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHJldHVybiAoKF9hID0gZWxtLnBhcmVudE5vZGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5maXJzdENoaWxkKSA9PT0gZWxtO1xuICAgIH07XG4gICAgY29uc3QgaGFzUGFyZW50ID0gKGVsbSwgcGFyZW50TmFtZSkgPT4ge1xuICAgICAgcmV0dXJuIGVsbSAmJiBlbG0ucGFyZW50Tm9kZSAmJiBlbG0ucGFyZW50Tm9kZS5ub2RlTmFtZSA9PT0gcGFyZW50TmFtZTtcbiAgICB9O1xuICAgIGNvbnN0IGlzTGlzdEJsb2NrID0gZWxtID0+IHtcbiAgICAgIHJldHVybiBlbG0gJiYgL14oT0x8VUx8TEkpJC8udGVzdChlbG0ubm9kZU5hbWUpO1xuICAgIH07XG4gICAgY29uc3QgaXNOZXN0ZWRMaXN0ID0gZWxtID0+IHtcbiAgICAgIHJldHVybiBpc0xpc3RCbG9jayhlbG0pICYmIGlzTGlzdEJsb2NrKGVsbS5wYXJlbnROb2RlKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldENvbnRhaW5lckJsb2NrID0gY29udGFpbmVyQmxvY2sgPT4ge1xuICAgICAgY29uc3QgY29udGFpbmVyQmxvY2tQYXJlbnQgPSBjb250YWluZXJCbG9jay5wYXJlbnROb2RlO1xuICAgICAgaWYgKC9eKExJfERUfEREKSQvLnRlc3QoY29udGFpbmVyQmxvY2tQYXJlbnQubm9kZU5hbWUpKSB7XG4gICAgICAgIHJldHVybiBjb250YWluZXJCbG9ja1BhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb250YWluZXJCbG9jaztcbiAgICB9O1xuICAgIGNvbnN0IGlzRmlyc3RPckxhc3RMaSA9IChjb250YWluZXJCbG9jaywgcGFyZW50QmxvY2ssIGZpcnN0KSA9PiB7XG4gICAgICBsZXQgbm9kZSA9IGNvbnRhaW5lckJsb2NrW2ZpcnN0ID8gJ2ZpcnN0Q2hpbGQnIDogJ2xhc3RDaGlsZCddO1xuICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgaWYgKGlzRWxlbWVudCQ2KG5vZGUpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVbZmlyc3QgPyAnbmV4dFNpYmxpbmcnIDogJ3ByZXZpb3VzU2libGluZyddO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGUgPT09IHBhcmVudEJsb2NrO1xuICAgIH07XG4gICAgY29uc3QgaW5zZXJ0JDMgPSAoZWRpdG9yLCBjcmVhdGVOZXdCbG9jaywgY29udGFpbmVyQmxvY2ssIHBhcmVudEJsb2NrLCBuZXdCbG9ja05hbWUpID0+IHtcbiAgICAgIGNvbnN0IGRvbSA9IGVkaXRvci5kb207XG4gICAgICBjb25zdCBybmcgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpO1xuICAgICAgaWYgKGNvbnRhaW5lckJsb2NrID09PSBlZGl0b3IuZ2V0Qm9keSgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpc05lc3RlZExpc3QoY29udGFpbmVyQmxvY2spKSB7XG4gICAgICAgIG5ld0Jsb2NrTmFtZSA9ICdMSSc7XG4gICAgICB9XG4gICAgICBsZXQgbmV3QmxvY2sgPSBjcmVhdGVOZXdCbG9jayhuZXdCbG9ja05hbWUpO1xuICAgICAgaWYgKGlzRmlyc3RPckxhc3RMaShjb250YWluZXJCbG9jaywgcGFyZW50QmxvY2ssIHRydWUpICYmIGlzRmlyc3RPckxhc3RMaShjb250YWluZXJCbG9jaywgcGFyZW50QmxvY2ssIGZhbHNlKSkge1xuICAgICAgICBpZiAoaGFzUGFyZW50KGNvbnRhaW5lckJsb2NrLCAnTEknKSkge1xuICAgICAgICAgIGNvbnN0IGNvbnRhaW5lckJsb2NrUGFyZW50ID0gZ2V0Q29udGFpbmVyQmxvY2soY29udGFpbmVyQmxvY2spO1xuICAgICAgICAgIGRvbS5pbnNlcnRBZnRlcihuZXdCbG9jaywgY29udGFpbmVyQmxvY2tQYXJlbnQpO1xuICAgICAgICAgIGlmIChpc0ZpcnN0Q2hpbGQoY29udGFpbmVyQmxvY2spKSB7XG4gICAgICAgICAgICBkb20ucmVtb3ZlKGNvbnRhaW5lckJsb2NrUGFyZW50KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG9tLnJlbW92ZShjb250YWluZXJCbG9jayk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRvbS5yZXBsYWNlKG5ld0Jsb2NrLCBjb250YWluZXJCbG9jayk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNGaXJzdE9yTGFzdExpKGNvbnRhaW5lckJsb2NrLCBwYXJlbnRCbG9jaywgdHJ1ZSkpIHtcbiAgICAgICAgaWYgKGhhc1BhcmVudChjb250YWluZXJCbG9jaywgJ0xJJykpIHtcbiAgICAgICAgICBkb20uaW5zZXJ0QWZ0ZXIobmV3QmxvY2ssIGdldENvbnRhaW5lckJsb2NrKGNvbnRhaW5lckJsb2NrKSk7XG4gICAgICAgICAgbmV3QmxvY2suYXBwZW5kQ2hpbGQoZG9tLmRvYy5jcmVhdGVUZXh0Tm9kZSgnICcpKTtcbiAgICAgICAgICBuZXdCbG9jay5hcHBlbmRDaGlsZChjb250YWluZXJCbG9jayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGFpbmVyQmxvY2sucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3QmxvY2ssIGNvbnRhaW5lckJsb2NrKTtcbiAgICAgICAgfVxuICAgICAgICBkb20ucmVtb3ZlKHBhcmVudEJsb2NrKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNGaXJzdE9yTGFzdExpKGNvbnRhaW5lckJsb2NrLCBwYXJlbnRCbG9jaywgZmFsc2UpKSB7XG4gICAgICAgIGRvbS5pbnNlcnRBZnRlcihuZXdCbG9jaywgZ2V0Q29udGFpbmVyQmxvY2soY29udGFpbmVyQmxvY2spKTtcbiAgICAgICAgZG9tLnJlbW92ZShwYXJlbnRCbG9jayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250YWluZXJCbG9jayA9IGdldENvbnRhaW5lckJsb2NrKGNvbnRhaW5lckJsb2NrKTtcbiAgICAgICAgY29uc3QgdG1wUm5nID0gcm5nLmNsb25lUmFuZ2UoKTtcbiAgICAgICAgdG1wUm5nLnNldFN0YXJ0QWZ0ZXIocGFyZW50QmxvY2spO1xuICAgICAgICB0bXBSbmcuc2V0RW5kQWZ0ZXIoY29udGFpbmVyQmxvY2spO1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IHRtcFJuZy5leHRyYWN0Q29udGVudHMoKTtcbiAgICAgICAgaWYgKG5ld0Jsb2NrTmFtZSA9PT0gJ0xJJyAmJiBoYXNGaXJzdENoaWxkKGZyYWdtZW50LCAnTEknKSkge1xuICAgICAgICAgIG5ld0Jsb2NrID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgICBkb20uaW5zZXJ0QWZ0ZXIoZnJhZ21lbnQsIGNvbnRhaW5lckJsb2NrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkb20uaW5zZXJ0QWZ0ZXIoZnJhZ21lbnQsIGNvbnRhaW5lckJsb2NrKTtcbiAgICAgICAgICBkb20uaW5zZXJ0QWZ0ZXIobmV3QmxvY2ssIGNvbnRhaW5lckJsb2NrKTtcbiAgICAgICAgfVxuICAgICAgICBkb20ucmVtb3ZlKHBhcmVudEJsb2NrKTtcbiAgICAgIH1cbiAgICAgIG1vdmVUb0NhcmV0UG9zaXRpb24oZWRpdG9yLCBuZXdCbG9jayk7XG4gICAgfTtcblxuICAgIGNvbnN0IHRyaW1ad3NwID0gZnJhZ21lbnQgPT4ge1xuICAgICAgZWFjaCRnKGRlc2NlbmRhbnRzJDEoU3VnYXJFbGVtZW50LmZyb21Eb20oZnJhZ21lbnQpLCBpc1RleHQkOSksIHRleHQgPT4ge1xuICAgICAgICBjb25zdCByYXdOb2RlID0gdGV4dC5kb207XG4gICAgICAgIHJhd05vZGUubm9kZVZhbHVlID0gdHJpbSQxKHJhd05vZGUubm9kZVZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgaXNFbXB0eUFuY2hvciA9IChkb20sIGVsbSkgPT4ge1xuICAgICAgcmV0dXJuIGVsbSAmJiBlbG0ubm9kZU5hbWUgPT09ICdBJyAmJiBkb20uaXNFbXB0eShlbG0pO1xuICAgIH07XG4gICAgY29uc3QgaXNUYWJsZUNlbGwgPSBub2RlID0+IHtcbiAgICAgIHJldHVybiBub2RlICYmIC9eKFREfFRIfENBUFRJT04pJC8udGVzdChub2RlLm5vZGVOYW1lKTtcbiAgICB9O1xuICAgIGNvbnN0IGVtcHR5QmxvY2sgPSBlbG0gPT4ge1xuICAgICAgZWxtLmlubmVySFRNTCA9ICc8YnIgZGF0YS1tY2UtYm9ndXM9XCIxXCI+JztcbiAgICB9O1xuICAgIGNvbnN0IGNvbnRhaW5lckFuZFNpYmxpbmdOYW1lID0gKGNvbnRhaW5lciwgbm9kZU5hbWUpID0+IHtcbiAgICAgIHJldHVybiBjb250YWluZXIubm9kZU5hbWUgPT09IG5vZGVOYW1lIHx8IGNvbnRhaW5lci5wcmV2aW91c1NpYmxpbmcgJiYgY29udGFpbmVyLnByZXZpb3VzU2libGluZy5ub2RlTmFtZSA9PT0gbm9kZU5hbWU7XG4gICAgfTtcbiAgICBjb25zdCBjYW5TcGxpdEJsb2NrID0gKGRvbSwgbm9kZSkgPT4ge1xuICAgICAgcmV0dXJuIG5vZGUgJiYgZG9tLmlzQmxvY2sobm9kZSkgJiYgIS9eKFREfFRIfENBUFRJT058Rk9STSkkLy50ZXN0KG5vZGUubm9kZU5hbWUpICYmICEvXihmaXhlZHxhYnNvbHV0ZSkvaS50ZXN0KG5vZGUuc3R5bGUucG9zaXRpb24pICYmIGRvbS5nZXRDb250ZW50RWRpdGFibGUobm9kZSkgIT09ICd0cnVlJztcbiAgICB9O1xuICAgIGNvbnN0IHRyaW1JbmxpbmVFbGVtZW50c09uTGVmdFNpZGVPZkJsb2NrID0gKGRvbSwgbm9uRW1wdHlFbGVtZW50c01hcCwgYmxvY2spID0+IHtcbiAgICAgIGxldCBub2RlID0gYmxvY2s7XG4gICAgICBjb25zdCBmaXJzdENoaWxkcyA9IFtdO1xuICAgICAgbGV0IGk7XG4gICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgd2hpbGUgKG5vZGUgPSBub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgaWYgKGRvbS5pc0Jsb2NrKG5vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0VsZW1lbnQkNihub2RlKSAmJiAhbm9uRW1wdHlFbGVtZW50c01hcFtub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCldKSB7XG4gICAgICAgICAgZmlyc3RDaGlsZHMucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaSA9IGZpcnN0Q2hpbGRzLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgbm9kZSA9IGZpcnN0Q2hpbGRzW2ldO1xuICAgICAgICBpZiAoIW5vZGUuaGFzQ2hpbGROb2RlcygpIHx8IG5vZGUuZmlyc3RDaGlsZCA9PT0gbm9kZS5sYXN0Q2hpbGQgJiYgbm9kZS5maXJzdENoaWxkLm5vZGVWYWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICBkb20ucmVtb3ZlKG5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChpc0VtcHR5QW5jaG9yKGRvbSwgbm9kZSkpIHtcbiAgICAgICAgICAgIGRvbS5yZW1vdmUobm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBub3JtYWxpemVad3NwT2Zmc2V0ID0gKHN0YXJ0LCBjb250YWluZXIsIG9mZnNldCkgPT4ge1xuICAgICAgaWYgKGlzVGV4dCQ4KGNvbnRhaW5lcikgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgICB9IGVsc2UgaWYgKHN0YXJ0KSB7XG4gICAgICAgIHJldHVybiBvZmZzZXQgPT09IDEgJiYgY29udGFpbmVyLmRhdGEuY2hhckF0KG9mZnNldCAtIDEpID09PSBaV1NQJDEgPyAwIDogb2Zmc2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG9mZnNldCA9PT0gY29udGFpbmVyLmRhdGEubGVuZ3RoIC0gMSAmJiBjb250YWluZXIuZGF0YS5jaGFyQXQob2Zmc2V0KSA9PT0gWldTUCQxID8gY29udGFpbmVyLmRhdGEubGVuZ3RoIDogb2Zmc2V0O1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaW5jbHVkZVp3c3BJblJhbmdlID0gcm5nID0+IHtcbiAgICAgIGNvbnN0IG5ld1JuZyA9IHJuZy5jbG9uZVJhbmdlKCk7XG4gICAgICBuZXdSbmcuc2V0U3RhcnQocm5nLnN0YXJ0Q29udGFpbmVyLCBub3JtYWxpemVad3NwT2Zmc2V0KHRydWUsIHJuZy5zdGFydENvbnRhaW5lciwgcm5nLnN0YXJ0T2Zmc2V0KSk7XG4gICAgICBuZXdSbmcuc2V0RW5kKHJuZy5lbmRDb250YWluZXIsIG5vcm1hbGl6ZVp3c3BPZmZzZXQoZmFsc2UsIHJuZy5lbmRDb250YWluZXIsIHJuZy5lbmRPZmZzZXQpKTtcbiAgICAgIHJldHVybiBuZXdSbmc7XG4gICAgfTtcbiAgICBjb25zdCB0cmltTGVhZGluZ0xpbmVCcmVha3MgPSBub2RlID0+IHtcbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKGlzVGV4dCQ4KG5vZGUpKSB7XG4gICAgICAgICAgbm9kZS5ub2RlVmFsdWUgPSBub2RlLm5vZGVWYWx1ZS5yZXBsYWNlKC9eW1xcclxcbl0rLywgJycpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICB9IHdoaWxlIChub2RlKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldEVkaXRhYmxlUm9vdCA9IChkb20sIG5vZGUpID0+IHtcbiAgICAgIGNvbnN0IHJvb3QgPSBkb20uZ2V0Um9vdCgpO1xuICAgICAgbGV0IHBhcmVudCwgZWRpdGFibGVSb290O1xuICAgICAgcGFyZW50ID0gbm9kZTtcbiAgICAgIHdoaWxlIChwYXJlbnQgIT09IHJvb3QgJiYgZG9tLmdldENvbnRlbnRFZGl0YWJsZShwYXJlbnQpICE9PSAnZmFsc2UnKSB7XG4gICAgICAgIGlmIChkb20uZ2V0Q29udGVudEVkaXRhYmxlKHBhcmVudCkgPT09ICd0cnVlJykge1xuICAgICAgICAgIGVkaXRhYmxlUm9vdCA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJlbnQgIT09IHJvb3QgPyBlZGl0YWJsZVJvb3QgOiByb290O1xuICAgIH07XG4gICAgY29uc3QgYXBwbHlBdHRyaWJ1dGVzID0gKGVkaXRvciwgbm9kZSwgZm9yY2VkUm9vdEJsb2NrQXR0cnMpID0+IHtcbiAgICAgIGNvbnN0IGRvbSA9IGVkaXRvci5kb207XG4gICAgICBPcHRpb25hbC5mcm9tKGZvcmNlZFJvb3RCbG9ja0F0dHJzLnN0eWxlKS5tYXAoZG9tLnBhcnNlU3R5bGUpLmVhY2goYXR0clN0eWxlcyA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTdHlsZXMgPSBnZXRBbGxSYXcoU3VnYXJFbGVtZW50LmZyb21Eb20obm9kZSkpO1xuICAgICAgICBjb25zdCBuZXdTdHlsZXMgPSB7XG4gICAgICAgICAgLi4uY3VycmVudFN0eWxlcyxcbiAgICAgICAgICAuLi5hdHRyU3R5bGVzXG4gICAgICAgIH07XG4gICAgICAgIGRvbS5zZXRTdHlsZXMobm9kZSwgbmV3U3R5bGVzKTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgYXR0ckNsYXNzZXNPcHQgPSBPcHRpb25hbC5mcm9tKGZvcmNlZFJvb3RCbG9ja0F0dHJzLmNsYXNzKS5tYXAoYXR0ckNsYXNzZXMgPT4gYXR0ckNsYXNzZXMuc3BsaXQoL1xccysvKSk7XG4gICAgICBjb25zdCBjdXJyZW50Q2xhc3Nlc09wdCA9IE9wdGlvbmFsLmZyb20obm9kZS5jbGFzc05hbWUpLm1hcChjdXJyZW50Q2xhc3NlcyA9PiBmaWx0ZXIkNihjdXJyZW50Q2xhc3Nlcy5zcGxpdCgvXFxzKy8pLCBjbGF6eiA9PiBjbGF6eiAhPT0gJycpKTtcbiAgICAgIGxpZnQyKGF0dHJDbGFzc2VzT3B0LCBjdXJyZW50Q2xhc3Nlc09wdCwgKGF0dHJDbGFzc2VzLCBjdXJyZW50Q2xhc3NlcykgPT4ge1xuICAgICAgICBjb25zdCBmaWx0ZXJlZENsYXNzZXMgPSBmaWx0ZXIkNihjdXJyZW50Q2xhc3NlcywgY2xhenogPT4gIWNvbnRhaW5zJDIoYXR0ckNsYXNzZXMsIGNsYXp6KSk7XG4gICAgICAgIGNvbnN0IG5ld0NsYXNzZXMgPSBbXG4gICAgICAgICAgLi4uYXR0ckNsYXNzZXMsXG4gICAgICAgICAgLi4uZmlsdGVyZWRDbGFzc2VzXG4gICAgICAgIF07XG4gICAgICAgIGRvbS5zZXRBdHRyaWIobm9kZSwgJ2NsYXNzJywgbmV3Q2xhc3Nlcy5qb2luKCcgJykpO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBhcHBsaWVkQXR0cnMgPSBbXG4gICAgICAgICdzdHlsZScsXG4gICAgICAgICdjbGFzcydcbiAgICAgIF07XG4gICAgICBjb25zdCByZW1haW5pbmdBdHRycyA9IGZpbHRlciQ1KGZvcmNlZFJvb3RCbG9ja0F0dHJzLCAoXywgYXR0cnMpID0+ICFjb250YWlucyQyKGFwcGxpZWRBdHRycywgYXR0cnMpKTtcbiAgICAgIGRvbS5zZXRBdHRyaWJzKG5vZGUsIHJlbWFpbmluZ0F0dHJzKTtcbiAgICB9O1xuICAgIGNvbnN0IHNldEZvcmNlZEJsb2NrQXR0cnMgPSAoZWRpdG9yLCBub2RlKSA9PiB7XG4gICAgICBjb25zdCBmb3JjZWRSb290QmxvY2tOYW1lID0gZ2V0Rm9yY2VkUm9vdEJsb2NrKGVkaXRvcik7XG4gICAgICBpZiAoZm9yY2VkUm9vdEJsb2NrTmFtZS50b0xvd2VyQ2FzZSgpID09PSBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICBjb25zdCBmb3JjZWRSb290QmxvY2tBdHRycyA9IGdldEZvcmNlZFJvb3RCbG9ja0F0dHJzKGVkaXRvcik7XG4gICAgICAgIGFwcGx5QXR0cmlidXRlcyhlZGl0b3IsIG5vZGUsIGZvcmNlZFJvb3RCbG9ja0F0dHJzKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHdyYXBTZWxmQW5kU2libGluZ3NJbkRlZmF1bHRCbG9jayA9IChlZGl0b3IsIG5ld0Jsb2NrTmFtZSwgcm5nLCBjb250YWluZXIsIG9mZnNldCkgPT4ge1xuICAgICAgbGV0IG5ld0Jsb2NrLCBwYXJlbnRCbG9jaywgc3RhcnROb2RlLCBub2RlLCBuZXh0LCByb290QmxvY2tOYW1lO1xuICAgICAgY29uc3QgZG9tID0gZWRpdG9yLmRvbSwgZWRpdGFibGVSb290ID0gZ2V0RWRpdGFibGVSb290KGRvbSwgY29udGFpbmVyKTtcbiAgICAgIHBhcmVudEJsb2NrID0gZG9tLmdldFBhcmVudChjb250YWluZXIsIGRvbS5pc0Jsb2NrKTtcbiAgICAgIGlmICghcGFyZW50QmxvY2sgfHwgIWNhblNwbGl0QmxvY2soZG9tLCBwYXJlbnRCbG9jaykpIHtcbiAgICAgICAgcGFyZW50QmxvY2sgPSBwYXJlbnRCbG9jayB8fCBlZGl0YWJsZVJvb3Q7XG4gICAgICAgIGlmIChwYXJlbnRCbG9jayA9PT0gZWRpdG9yLmdldEJvZHkoKSB8fCBpc1RhYmxlQ2VsbChwYXJlbnRCbG9jaykpIHtcbiAgICAgICAgICByb290QmxvY2tOYW1lID0gcGFyZW50QmxvY2subm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByb290QmxvY2tOYW1lID0gcGFyZW50QmxvY2sucGFyZW50Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyZW50QmxvY2suaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgbmV3QmxvY2sgPSBkb20uY3JlYXRlKG5ld0Jsb2NrTmFtZSk7XG4gICAgICAgICAgc2V0Rm9yY2VkQmxvY2tBdHRycyhlZGl0b3IsIG5ld0Jsb2NrKTtcbiAgICAgICAgICBwYXJlbnRCbG9jay5hcHBlbmRDaGlsZChuZXdCbG9jayk7XG4gICAgICAgICAgcm5nLnNldFN0YXJ0KG5ld0Jsb2NrLCAwKTtcbiAgICAgICAgICBybmcuc2V0RW5kKG5ld0Jsb2NrLCAwKTtcbiAgICAgICAgICByZXR1cm4gbmV3QmxvY2s7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IGNvbnRhaW5lcjtcbiAgICAgICAgd2hpbGUgKG5vZGUucGFyZW50Tm9kZSAhPT0gcGFyZW50QmxvY2spIHtcbiAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChub2RlICYmICFkb20uaXNCbG9jayhub2RlKSkge1xuICAgICAgICAgIHN0YXJ0Tm9kZSA9IG5vZGU7XG4gICAgICAgICAgbm9kZSA9IG5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydE5vZGUgJiYgZWRpdG9yLnNjaGVtYS5pc1ZhbGlkQ2hpbGQocm9vdEJsb2NrTmFtZSwgbmV3QmxvY2tOYW1lLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgICAgbmV3QmxvY2sgPSBkb20uY3JlYXRlKG5ld0Jsb2NrTmFtZSk7XG4gICAgICAgICAgc2V0Rm9yY2VkQmxvY2tBdHRycyhlZGl0b3IsIG5ld0Jsb2NrKTtcbiAgICAgICAgICBzdGFydE5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3QmxvY2ssIHN0YXJ0Tm9kZSk7XG4gICAgICAgICAgbm9kZSA9IHN0YXJ0Tm9kZTtcbiAgICAgICAgICB3aGlsZSAobm9kZSAmJiAhZG9tLmlzQmxvY2sobm9kZSkpIHtcbiAgICAgICAgICAgIG5leHQgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgbmV3QmxvY2suYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICBub2RlID0gbmV4dDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcm5nLnNldFN0YXJ0KGNvbnRhaW5lciwgb2Zmc2V0KTtcbiAgICAgICAgICBybmcuc2V0RW5kKGNvbnRhaW5lciwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9O1xuICAgIGNvbnN0IGFkZEJyVG9CbG9ja0lmTmVlZGVkID0gKGRvbSwgYmxvY2spID0+IHtcbiAgICAgIGJsb2NrLm5vcm1hbGl6ZSgpO1xuICAgICAgY29uc3QgbGFzdENoaWxkID0gYmxvY2subGFzdENoaWxkO1xuICAgICAgaWYgKCFsYXN0Q2hpbGQgfHwgL14obGVmdHxyaWdodCkkL2dpLnRlc3QoZG9tLmdldFN0eWxlKGxhc3RDaGlsZCwgJ2Zsb2F0JywgdHJ1ZSkpKSB7XG4gICAgICAgIGRvbS5hZGQoYmxvY2ssICdicicpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaW5zZXJ0JDIgPSAoZWRpdG9yLCBldnQpID0+IHtcbiAgICAgIGxldCB0bXBSbmcsIGNvbnRhaW5lciwgb2Zmc2V0LCBwYXJlbnRCbG9jaztcbiAgICAgIGxldCBuZXdCbG9jaywgZnJhZ21lbnQsIGNvbnRhaW5lckJsb2NrLCBwYXJlbnRCbG9ja05hbWUsIGlzQWZ0ZXJMYXN0Tm9kZUluQ29udGFpbmVyO1xuICAgICAgY29uc3QgZG9tID0gZWRpdG9yLmRvbTtcbiAgICAgIGNvbnN0IHNjaGVtYSA9IGVkaXRvci5zY2hlbWEsIG5vbkVtcHR5RWxlbWVudHNNYXAgPSBzY2hlbWEuZ2V0Tm9uRW1wdHlFbGVtZW50cygpO1xuICAgICAgY29uc3Qgcm5nID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKTtcbiAgICAgIGNvbnN0IG5ld0Jsb2NrTmFtZSA9IGdldEZvcmNlZFJvb3RCbG9jayhlZGl0b3IpO1xuICAgICAgY29uc3QgY3JlYXRlTmV3QmxvY2sgPSBuYW1lID0+IHtcbiAgICAgICAgbGV0IG5vZGUgPSBjb250YWluZXIsIGJsb2NrLCBjbG9uZWROb2RlLCBjYXJldE5vZGU7XG4gICAgICAgIGNvbnN0IHRleHRJbmxpbmVFbGVtZW50cyA9IHNjaGVtYS5nZXRUZXh0SW5saW5lRWxlbWVudHMoKTtcbiAgICAgICAgaWYgKG5hbWUgfHwgcGFyZW50QmxvY2tOYW1lID09PSAnVEFCTEUnIHx8IHBhcmVudEJsb2NrTmFtZSA9PT0gJ0hSJykge1xuICAgICAgICAgIGJsb2NrID0gZG9tLmNyZWF0ZShuYW1lIHx8IG5ld0Jsb2NrTmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmxvY2sgPSBwYXJlbnRCbG9jay5jbG9uZU5vZGUoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGNhcmV0Tm9kZSA9IGJsb2NrO1xuICAgICAgICBpZiAoc2hvdWxkS2VlcFN0eWxlcyhlZGl0b3IpID09PSBmYWxzZSkge1xuICAgICAgICAgIGRvbS5zZXRBdHRyaWIoYmxvY2ssICdzdHlsZScsIG51bGwpO1xuICAgICAgICAgIGRvbS5zZXRBdHRyaWIoYmxvY2ssICdjbGFzcycsIG51bGwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmICh0ZXh0SW5saW5lRWxlbWVudHNbbm9kZS5ub2RlTmFtZV0pIHtcbiAgICAgICAgICAgICAgaWYgKGlzQ2FyZXROb2RlKG5vZGUpIHx8IGlzQm9va21hcmtOb2RlJDEobm9kZSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjbG9uZWROb2RlID0gbm9kZS5jbG9uZU5vZGUoZmFsc2UpO1xuICAgICAgICAgICAgICBkb20uc2V0QXR0cmliKGNsb25lZE5vZGUsICdpZCcsICcnKTtcbiAgICAgICAgICAgICAgaWYgKGJsb2NrLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgICAgICAgIGNsb25lZE5vZGUuYXBwZW5kQ2hpbGQoYmxvY2suZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQoY2xvbmVkTm9kZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FyZXROb2RlID0gY2xvbmVkTm9kZTtcbiAgICAgICAgICAgICAgICBibG9jay5hcHBlbmRDaGlsZChjbG9uZWROb2RlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gd2hpbGUgKChub2RlID0gbm9kZS5wYXJlbnROb2RlKSAmJiBub2RlICE9PSBlZGl0YWJsZVJvb3QpO1xuICAgICAgICB9XG4gICAgICAgIHNldEZvcmNlZEJsb2NrQXR0cnMoZWRpdG9yLCBibG9jayk7XG4gICAgICAgIGVtcHR5QmxvY2soY2FyZXROb2RlKTtcbiAgICAgICAgcmV0dXJuIGJsb2NrO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGlzQ2FyZXRBdFN0YXJ0T3JFbmRPZkJsb2NrID0gc3RhcnQgPT4ge1xuICAgICAgICBsZXQgbm9kZSwgbmFtZTtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZE9mZnNldCA9IG5vcm1hbGl6ZVp3c3BPZmZzZXQoc3RhcnQsIGNvbnRhaW5lciwgb2Zmc2V0KTtcbiAgICAgICAgaWYgKGlzVGV4dCQ4KGNvbnRhaW5lcikgJiYgKHN0YXJ0ID8gbm9ybWFsaXplZE9mZnNldCA+IDAgOiBub3JtYWxpemVkT2Zmc2V0IDwgY29udGFpbmVyLm5vZGVWYWx1ZS5sZW5ndGgpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250YWluZXIucGFyZW50Tm9kZSA9PT0gcGFyZW50QmxvY2sgJiYgaXNBZnRlckxhc3ROb2RlSW5Db250YWluZXIgJiYgIXN0YXJ0KSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0ICYmIGlzRWxlbWVudCQ2KGNvbnRhaW5lcikgJiYgY29udGFpbmVyID09PSBwYXJlbnRCbG9jay5maXJzdENoaWxkKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRhaW5lckFuZFNpYmxpbmdOYW1lKGNvbnRhaW5lciwgJ1RBQkxFJykgfHwgY29udGFpbmVyQW5kU2libGluZ05hbWUoY29udGFpbmVyLCAnSFInKSkge1xuICAgICAgICAgIHJldHVybiBpc0FmdGVyTGFzdE5vZGVJbkNvbnRhaW5lciAmJiAhc3RhcnQgfHwgIWlzQWZ0ZXJMYXN0Tm9kZUluQ29udGFpbmVyICYmIHN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdhbGtlciA9IG5ldyBEb21UcmVlV2Fsa2VyKGNvbnRhaW5lciwgcGFyZW50QmxvY2spO1xuICAgICAgICBpZiAoaXNUZXh0JDgoY29udGFpbmVyKSkge1xuICAgICAgICAgIGlmIChzdGFydCAmJiBub3JtYWxpemVkT2Zmc2V0ID09PSAwKSB7XG4gICAgICAgICAgICB3YWxrZXIucHJldigpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXN0YXJ0ICYmIG5vcm1hbGl6ZWRPZmZzZXQgPT09IGNvbnRhaW5lci5ub2RlVmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICB3YWxrZXIubmV4dCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAobm9kZSA9IHdhbGtlci5jdXJyZW50KCkpIHtcbiAgICAgICAgICBpZiAoaXNFbGVtZW50JDYobm9kZSkpIHtcbiAgICAgICAgICAgIGlmICghbm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtbWNlLWJvZ3VzJykpIHtcbiAgICAgICAgICAgICAgbmFtZSA9IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgaWYgKG5vbkVtcHR5RWxlbWVudHNNYXBbbmFtZV0gJiYgbmFtZSAhPT0gJ2JyJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNUZXh0JDgobm9kZSkgJiYgIWlzV2hpdGVzcGFjZVRleHQobm9kZS5ub2RlVmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGFydCkge1xuICAgICAgICAgICAgd2Fsa2VyLnByZXYoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2Fsa2VyLm5leHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuICAgICAgY29uc3QgaW5zZXJ0TmV3QmxvY2tBZnRlciA9ICgpID0+IHtcbiAgICAgICAgaWYgKC9eKEhbMS02XXxQUkV8RklHVVJFKSQvLnRlc3QocGFyZW50QmxvY2tOYW1lKSAmJiBjb250YWluZXJCbG9ja05hbWUgIT09ICdIR1JPVVAnKSB7XG4gICAgICAgICAgbmV3QmxvY2sgPSBjcmVhdGVOZXdCbG9jayhuZXdCbG9ja05hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0Jsb2NrID0gY3JlYXRlTmV3QmxvY2soKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkRW5kQ29udGFpbmVyT25FbXB0eUJsb2NrKGVkaXRvcikgJiYgY2FuU3BsaXRCbG9jayhkb20sIGNvbnRhaW5lckJsb2NrKSAmJiBkb20uaXNFbXB0eShwYXJlbnRCbG9jaykpIHtcbiAgICAgICAgICBuZXdCbG9jayA9IGRvbS5zcGxpdChjb250YWluZXJCbG9jaywgcGFyZW50QmxvY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRvbS5pbnNlcnRBZnRlcihuZXdCbG9jaywgcGFyZW50QmxvY2spO1xuICAgICAgICB9XG4gICAgICAgIG1vdmVUb0NhcmV0UG9zaXRpb24oZWRpdG9yLCBuZXdCbG9jayk7XG4gICAgICB9O1xuICAgICAgbm9ybWFsaXplJDIoZG9tLCBybmcpLmVhY2gobm9ybVJuZyA9PiB7XG4gICAgICAgIHJuZy5zZXRTdGFydChub3JtUm5nLnN0YXJ0Q29udGFpbmVyLCBub3JtUm5nLnN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgcm5nLnNldEVuZChub3JtUm5nLmVuZENvbnRhaW5lciwgbm9ybVJuZy5lbmRPZmZzZXQpO1xuICAgICAgfSk7XG4gICAgICBjb250YWluZXIgPSBybmcuc3RhcnRDb250YWluZXI7XG4gICAgICBvZmZzZXQgPSBybmcuc3RhcnRPZmZzZXQ7XG4gICAgICBjb25zdCBzaGlmdEtleSA9ICEhKGV2dCAmJiBldnQuc2hpZnRLZXkpO1xuICAgICAgY29uc3QgY3RybEtleSA9ICEhKGV2dCAmJiBldnQuY3RybEtleSk7XG4gICAgICBpZiAoaXNFbGVtZW50JDYoY29udGFpbmVyKSAmJiBjb250YWluZXIuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgIGlzQWZ0ZXJMYXN0Tm9kZUluQ29udGFpbmVyID0gb2Zmc2V0ID4gY29udGFpbmVyLmNoaWxkTm9kZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgY29udGFpbmVyID0gY29udGFpbmVyLmNoaWxkTm9kZXNbTWF0aC5taW4ob2Zmc2V0LCBjb250YWluZXIuY2hpbGROb2Rlcy5sZW5ndGggLSAxKV0gfHwgY29udGFpbmVyO1xuICAgICAgICBpZiAoaXNBZnRlckxhc3ROb2RlSW5Db250YWluZXIgJiYgaXNUZXh0JDgoY29udGFpbmVyKSkge1xuICAgICAgICAgIG9mZnNldCA9IGNvbnRhaW5lci5ub2RlVmFsdWUubGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGVkaXRhYmxlUm9vdCA9IGdldEVkaXRhYmxlUm9vdChkb20sIGNvbnRhaW5lcik7XG4gICAgICBpZiAoIWVkaXRhYmxlUm9vdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXNoaWZ0S2V5KSB7XG4gICAgICAgIGNvbnRhaW5lciA9IHdyYXBTZWxmQW5kU2libGluZ3NJbkRlZmF1bHRCbG9jayhlZGl0b3IsIG5ld0Jsb2NrTmFtZSwgcm5nLCBjb250YWluZXIsIG9mZnNldCk7XG4gICAgICB9XG4gICAgICBwYXJlbnRCbG9jayA9IGRvbS5nZXRQYXJlbnQoY29udGFpbmVyLCBkb20uaXNCbG9jayk7XG4gICAgICBjb250YWluZXJCbG9jayA9IHBhcmVudEJsb2NrID8gZG9tLmdldFBhcmVudChwYXJlbnRCbG9jay5wYXJlbnROb2RlLCBkb20uaXNCbG9jaykgOiBudWxsO1xuICAgICAgcGFyZW50QmxvY2tOYW1lID0gcGFyZW50QmxvY2sgPyBwYXJlbnRCbG9jay5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpIDogJyc7XG4gICAgICBjb25zdCBjb250YWluZXJCbG9ja05hbWUgPSBjb250YWluZXJCbG9jayA/IGNvbnRhaW5lckJsb2NrLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgOiAnJztcbiAgICAgIGlmIChjb250YWluZXJCbG9ja05hbWUgPT09ICdMSScgJiYgIWN0cmxLZXkpIHtcbiAgICAgICAgcGFyZW50QmxvY2sgPSBjb250YWluZXJCbG9jaztcbiAgICAgICAgY29udGFpbmVyQmxvY2sgPSBjb250YWluZXJCbG9jay5wYXJlbnROb2RlO1xuICAgICAgICBwYXJlbnRCbG9ja05hbWUgPSBjb250YWluZXJCbG9ja05hbWU7XG4gICAgICB9XG4gICAgICBpZiAoL14oTEl8RFR8REQpJC8udGVzdChwYXJlbnRCbG9ja05hbWUpKSB7XG4gICAgICAgIGlmIChkb20uaXNFbXB0eShwYXJlbnRCbG9jaykpIHtcbiAgICAgICAgICBpbnNlcnQkMyhlZGl0b3IsIGNyZWF0ZU5ld0Jsb2NrLCBjb250YWluZXJCbG9jaywgcGFyZW50QmxvY2ssIG5ld0Jsb2NrTmFtZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50QmxvY2sgPT09IGVkaXRvci5nZXRCb2R5KCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGlzQ2FyZXRDb250YWluZXJCbG9jayQxKHBhcmVudEJsb2NrKSkge1xuICAgICAgICBuZXdCbG9jayA9IHNob3dDYXJldENvbnRhaW5lckJsb2NrKHBhcmVudEJsb2NrKTtcbiAgICAgICAgaWYgKGRvbS5pc0VtcHR5KHBhcmVudEJsb2NrKSkge1xuICAgICAgICAgIGVtcHR5QmxvY2socGFyZW50QmxvY2spO1xuICAgICAgICB9XG4gICAgICAgIHNldEZvcmNlZEJsb2NrQXR0cnMoZWRpdG9yLCBuZXdCbG9jayk7XG4gICAgICAgIG1vdmVUb0NhcmV0UG9zaXRpb24oZWRpdG9yLCBuZXdCbG9jayk7XG4gICAgICB9IGVsc2UgaWYgKGlzQ2FyZXRBdFN0YXJ0T3JFbmRPZkJsb2NrKCkpIHtcbiAgICAgICAgaW5zZXJ0TmV3QmxvY2tBZnRlcigpO1xuICAgICAgfSBlbHNlIGlmIChpc0NhcmV0QXRTdGFydE9yRW5kT2ZCbG9jayh0cnVlKSkge1xuICAgICAgICBuZXdCbG9jayA9IHBhcmVudEJsb2NrLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNyZWF0ZU5ld0Jsb2NrKCksIHBhcmVudEJsb2NrKTtcbiAgICAgICAgbW92ZVRvQ2FyZXRQb3NpdGlvbihlZGl0b3IsIGNvbnRhaW5lckFuZFNpYmxpbmdOYW1lKHBhcmVudEJsb2NrLCAnSFInKSA/IG5ld0Jsb2NrIDogcGFyZW50QmxvY2spO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG1wUm5nID0gaW5jbHVkZVp3c3BJblJhbmdlKHJuZykuY2xvbmVSYW5nZSgpO1xuICAgICAgICB0bXBSbmcuc2V0RW5kQWZ0ZXIocGFyZW50QmxvY2spO1xuICAgICAgICBmcmFnbWVudCA9IHRtcFJuZy5leHRyYWN0Q29udGVudHMoKTtcbiAgICAgICAgdHJpbVp3c3AoZnJhZ21lbnQpO1xuICAgICAgICB0cmltTGVhZGluZ0xpbmVCcmVha3MoZnJhZ21lbnQpO1xuICAgICAgICBuZXdCbG9jayA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgIGRvbS5pbnNlcnRBZnRlcihmcmFnbWVudCwgcGFyZW50QmxvY2spO1xuICAgICAgICB0cmltSW5saW5lRWxlbWVudHNPbkxlZnRTaWRlT2ZCbG9jayhkb20sIG5vbkVtcHR5RWxlbWVudHNNYXAsIG5ld0Jsb2NrKTtcbiAgICAgICAgYWRkQnJUb0Jsb2NrSWZOZWVkZWQoZG9tLCBwYXJlbnRCbG9jayk7XG4gICAgICAgIGlmIChkb20uaXNFbXB0eShwYXJlbnRCbG9jaykpIHtcbiAgICAgICAgICBlbXB0eUJsb2NrKHBhcmVudEJsb2NrKTtcbiAgICAgICAgfVxuICAgICAgICBuZXdCbG9jay5ub3JtYWxpemUoKTtcbiAgICAgICAgaWYgKGRvbS5pc0VtcHR5KG5ld0Jsb2NrKSkge1xuICAgICAgICAgIGRvbS5yZW1vdmUobmV3QmxvY2spO1xuICAgICAgICAgIGluc2VydE5ld0Jsb2NrQWZ0ZXIoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRGb3JjZWRCbG9ja0F0dHJzKGVkaXRvciwgbmV3QmxvY2spO1xuICAgICAgICAgIG1vdmVUb0NhcmV0UG9zaXRpb24oZWRpdG9yLCBuZXdCbG9jayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRvbS5zZXRBdHRyaWIobmV3QmxvY2ssICdpZCcsICcnKTtcbiAgICAgIGVkaXRvci5kaXNwYXRjaCgnTmV3QmxvY2snLCB7IG5ld0Jsb2NrIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCBoYXNSaWdodFNpZGVDb250ZW50ID0gKHNjaGVtYSwgY29udGFpbmVyLCBwYXJlbnRCbG9jaykgPT4ge1xuICAgICAgY29uc3Qgd2Fsa2VyID0gbmV3IERvbVRyZWVXYWxrZXIoY29udGFpbmVyLCBwYXJlbnRCbG9jayk7XG4gICAgICBsZXQgbm9kZTtcbiAgICAgIGNvbnN0IG5vbkVtcHR5RWxlbWVudHNNYXAgPSBzY2hlbWEuZ2V0Tm9uRW1wdHlFbGVtZW50cygpO1xuICAgICAgd2hpbGUgKG5vZGUgPSB3YWxrZXIubmV4dCgpKSB7XG4gICAgICAgIGlmIChub25FbXB0eUVsZW1lbnRzTWFwW25vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKV0gfHwgbm9kZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG1vdmVTZWxlY3Rpb25Ub0JyID0gKGVkaXRvciwgYnJFbG0sIGV4dHJhQnIpID0+IHtcbiAgICAgIGNvbnN0IHJuZyA9IGVkaXRvci5kb20uY3JlYXRlUm5nKCk7XG4gICAgICBpZiAoIWV4dHJhQnIpIHtcbiAgICAgICAgcm5nLnNldFN0YXJ0QWZ0ZXIoYnJFbG0pO1xuICAgICAgICBybmcuc2V0RW5kQWZ0ZXIoYnJFbG0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm5nLnNldFN0YXJ0QmVmb3JlKGJyRWxtKTtcbiAgICAgICAgcm5nLnNldEVuZEJlZm9yZShickVsbSk7XG4gICAgICB9XG4gICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNldFJuZyhybmcpO1xuICAgICAgc2Nyb2xsUmFuZ2VJbnRvVmlldyhlZGl0b3IsIHJuZyk7XG4gICAgfTtcbiAgICBjb25zdCBpbnNlcnRCckF0Q2FyZXQgPSAoZWRpdG9yLCBldnQpID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb247XG4gICAgICBjb25zdCBkb20gPSBlZGl0b3IuZG9tO1xuICAgICAgY29uc3Qgcm5nID0gc2VsZWN0aW9uLmdldFJuZygpO1xuICAgICAgbGV0IGJyRWxtO1xuICAgICAgbGV0IGV4dHJhQnI7XG4gICAgICBub3JtYWxpemUkMihkb20sIHJuZykuZWFjaChub3JtUm5nID0+IHtcbiAgICAgICAgcm5nLnNldFN0YXJ0KG5vcm1Sbmcuc3RhcnRDb250YWluZXIsIG5vcm1Sbmcuc3RhcnRPZmZzZXQpO1xuICAgICAgICBybmcuc2V0RW5kKG5vcm1SbmcuZW5kQ29udGFpbmVyLCBub3JtUm5nLmVuZE9mZnNldCk7XG4gICAgICB9KTtcbiAgICAgIGxldCBvZmZzZXQgPSBybmcuc3RhcnRPZmZzZXQ7XG4gICAgICBsZXQgY29udGFpbmVyID0gcm5nLnN0YXJ0Q29udGFpbmVyO1xuICAgICAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gMSAmJiBjb250YWluZXIuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgIGNvbnN0IGlzQWZ0ZXJMYXN0Tm9kZUluQ29udGFpbmVyID0gb2Zmc2V0ID4gY29udGFpbmVyLmNoaWxkTm9kZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgY29udGFpbmVyID0gY29udGFpbmVyLmNoaWxkTm9kZXNbTWF0aC5taW4ob2Zmc2V0LCBjb250YWluZXIuY2hpbGROb2Rlcy5sZW5ndGggLSAxKV0gfHwgY29udGFpbmVyO1xuICAgICAgICBpZiAoaXNBZnRlckxhc3ROb2RlSW5Db250YWluZXIgJiYgY29udGFpbmVyLm5vZGVUeXBlID09PSAzKSB7XG4gICAgICAgICAgb2Zmc2V0ID0gY29udGFpbmVyLm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IHBhcmVudEJsb2NrID0gZG9tLmdldFBhcmVudChjb250YWluZXIsIGRvbS5pc0Jsb2NrKTtcbiAgICAgIGNvbnN0IGNvbnRhaW5lckJsb2NrID0gcGFyZW50QmxvY2sgPyBkb20uZ2V0UGFyZW50KHBhcmVudEJsb2NrLnBhcmVudE5vZGUsIGRvbS5pc0Jsb2NrKSA6IG51bGw7XG4gICAgICBjb25zdCBjb250YWluZXJCbG9ja05hbWUgPSBjb250YWluZXJCbG9jayA/IGNvbnRhaW5lckJsb2NrLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgOiAnJztcbiAgICAgIGNvbnN0IGlzQ29udHJvbEtleSA9ICEhKGV2dCAmJiBldnQuY3RybEtleSk7XG4gICAgICBpZiAoY29udGFpbmVyQmxvY2tOYW1lID09PSAnTEknICYmICFpc0NvbnRyb2xLZXkpIHtcbiAgICAgICAgcGFyZW50QmxvY2sgPSBjb250YWluZXJCbG9jaztcbiAgICAgIH1cbiAgICAgIGlmIChjb250YWluZXIgJiYgY29udGFpbmVyLm5vZGVUeXBlID09PSAzICYmIG9mZnNldCA+PSBjb250YWluZXIubm9kZVZhbHVlLmxlbmd0aCkge1xuICAgICAgICBpZiAoIWhhc1JpZ2h0U2lkZUNvbnRlbnQoZWRpdG9yLnNjaGVtYSwgY29udGFpbmVyLCBwYXJlbnRCbG9jaykpIHtcbiAgICAgICAgICBickVsbSA9IGRvbS5jcmVhdGUoJ2JyJyk7XG4gICAgICAgICAgcm5nLmluc2VydE5vZGUoYnJFbG0pO1xuICAgICAgICAgIHJuZy5zZXRTdGFydEFmdGVyKGJyRWxtKTtcbiAgICAgICAgICBybmcuc2V0RW5kQWZ0ZXIoYnJFbG0pO1xuICAgICAgICAgIGV4dHJhQnIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBickVsbSA9IGRvbS5jcmVhdGUoJ2JyJyk7XG4gICAgICByYW5nZUluc2VydE5vZGUoZG9tLCBybmcsIGJyRWxtKTtcbiAgICAgIG1vdmVTZWxlY3Rpb25Ub0JyKGVkaXRvciwgYnJFbG0sIGV4dHJhQnIpO1xuICAgICAgZWRpdG9yLnVuZG9NYW5hZ2VyLmFkZCgpO1xuICAgIH07XG4gICAgY29uc3QgaW5zZXJ0QnJCZWZvcmUgPSAoZWRpdG9yLCBpbmxpbmUpID0+IHtcbiAgICAgIGNvbnN0IGJyID0gU3VnYXJFbGVtZW50LmZyb21UYWcoJ2JyJyk7XG4gICAgICBiZWZvcmUkMyhTdWdhckVsZW1lbnQuZnJvbURvbShpbmxpbmUpLCBicik7XG4gICAgICBlZGl0b3IudW5kb01hbmFnZXIuYWRkKCk7XG4gICAgfTtcbiAgICBjb25zdCBpbnNlcnRCckFmdGVyID0gKGVkaXRvciwgaW5saW5lKSA9PiB7XG4gICAgICBpZiAoIWhhc0JyQWZ0ZXIoZWRpdG9yLmdldEJvZHkoKSwgaW5saW5lKSkge1xuICAgICAgICBhZnRlciQ0KFN1Z2FyRWxlbWVudC5mcm9tRG9tKGlubGluZSksIFN1Z2FyRWxlbWVudC5mcm9tVGFnKCdicicpKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJyID0gU3VnYXJFbGVtZW50LmZyb21UYWcoJ2JyJyk7XG4gICAgICBhZnRlciQ0KFN1Z2FyRWxlbWVudC5mcm9tRG9tKGlubGluZSksIGJyKTtcbiAgICAgIG1vdmVTZWxlY3Rpb25Ub0JyKGVkaXRvciwgYnIuZG9tLCBmYWxzZSk7XG4gICAgICBlZGl0b3IudW5kb01hbmFnZXIuYWRkKCk7XG4gICAgfTtcbiAgICBjb25zdCBpc0JlZm9yZUJyID0gcG9zID0+IHtcbiAgICAgIHJldHVybiBpc0JyJDUocG9zLmdldE5vZGUoKSk7XG4gICAgfTtcbiAgICBjb25zdCBoYXNCckFmdGVyID0gKHJvb3ROb2RlLCBzdGFydE5vZGUpID0+IHtcbiAgICAgIGlmIChpc0JlZm9yZUJyKENhcmV0UG9zaXRpb24uYWZ0ZXIoc3RhcnROb2RlKSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV4dFBvc2l0aW9uKHJvb3ROb2RlLCBDYXJldFBvc2l0aW9uLmFmdGVyKHN0YXJ0Tm9kZSkpLm1hcChwb3MgPT4ge1xuICAgICAgICAgIHJldHVybiBpc0JyJDUocG9zLmdldE5vZGUoKSk7XG4gICAgICAgIH0pLmdldE9yKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGlzQW5jaG9yTGluayA9IGVsbSA9PiB7XG4gICAgICByZXR1cm4gZWxtICYmIGVsbS5ub2RlTmFtZSA9PT0gJ0EnICYmICdocmVmJyBpbiBlbG07XG4gICAgfTtcbiAgICBjb25zdCBpc0luc2lkZUFuY2hvciA9IGxvY2F0aW9uID0+IHtcbiAgICAgIHJldHVybiBsb2NhdGlvbi5mb2xkKG5ldmVyLCBpc0FuY2hvckxpbmssIGlzQW5jaG9yTGluaywgbmV2ZXIpO1xuICAgIH07XG4gICAgY29uc3QgcmVhZElubGluZUFuY2hvckxvY2F0aW9uID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IGlzSW5saW5lVGFyZ2V0JDEgPSBjdXJyeShpc0lubGluZVRhcmdldCwgZWRpdG9yKTtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gQ2FyZXRQb3NpdGlvbi5mcm9tUmFuZ2VTdGFydChlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpKTtcbiAgICAgIHJldHVybiByZWFkTG9jYXRpb24oaXNJbmxpbmVUYXJnZXQkMSwgZWRpdG9yLmdldEJvZHkoKSwgcG9zaXRpb24pLmZpbHRlcihpc0luc2lkZUFuY2hvcik7XG4gICAgfTtcbiAgICBjb25zdCBpbnNlcnRCck91dHNpZGVBbmNob3IgPSAoZWRpdG9yLCBsb2NhdGlvbikgPT4ge1xuICAgICAgbG9jYXRpb24uZm9sZChub29wLCBjdXJyeShpbnNlcnRCckJlZm9yZSwgZWRpdG9yKSwgY3VycnkoaW5zZXJ0QnJBZnRlciwgZWRpdG9yKSwgbm9vcCk7XG4gICAgfTtcbiAgICBjb25zdCBpbnNlcnQkMSA9IChlZGl0b3IsIGV2dCkgPT4ge1xuICAgICAgY29uc3QgYW5jaG9yTG9jYXRpb24gPSByZWFkSW5saW5lQW5jaG9yTG9jYXRpb24oZWRpdG9yKTtcbiAgICAgIGlmIChhbmNob3JMb2NhdGlvbi5pc1NvbWUoKSkge1xuICAgICAgICBhbmNob3JMb2NhdGlvbi5lYWNoKGN1cnJ5KGluc2VydEJyT3V0c2lkZUFuY2hvciwgZWRpdG9yKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnNlcnRCckF0Q2FyZXQoZWRpdG9yLCBldnQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBtYXRjaGVzU2VsZWN0b3IgPSAoZWRpdG9yLCBzZWxlY3RvcikgPT4ge1xuICAgICAgcmV0dXJuIGdldFBhcmVudEJsb2NrJDEoZWRpdG9yKS5maWx0ZXIocGFyZW50QmxvY2sgPT4ge1xuICAgICAgICByZXR1cm4gc2VsZWN0b3IubGVuZ3RoID4gMCAmJiBpcyQxKFN1Z2FyRWxlbWVudC5mcm9tRG9tKHBhcmVudEJsb2NrKSwgc2VsZWN0b3IpO1xuICAgICAgfSkuaXNTb21lKCk7XG4gICAgfTtcbiAgICBjb25zdCBzaG91bGRJbnNlcnRCciA9IGVkaXRvciA9PiB7XG4gICAgICByZXR1cm4gbWF0Y2hlc1NlbGVjdG9yKGVkaXRvciwgZ2V0QnJOZXdMaW5lU2VsZWN0b3IoZWRpdG9yKSk7XG4gICAgfTtcbiAgICBjb25zdCBzaG91bGRCbG9ja05ld0xpbmUkMSA9IGVkaXRvciA9PiB7XG4gICAgICByZXR1cm4gbWF0Y2hlc1NlbGVjdG9yKGVkaXRvciwgZ2V0Tm9OZXdMaW5lU2VsZWN0b3IoZWRpdG9yKSk7XG4gICAgfTtcblxuICAgIGNvbnN0IG5ld0xpbmVBY3Rpb24gPSBBZHQuZ2VuZXJhdGUoW1xuICAgICAgeyBicjogW10gfSxcbiAgICAgIHsgYmxvY2s6IFtdIH0sXG4gICAgICB7IG5vbmU6IFtdIH1cbiAgICBdKTtcbiAgICBjb25zdCBzaG91bGRCbG9ja05ld0xpbmUgPSAoZWRpdG9yLCBfc2hpZnRLZXkpID0+IHtcbiAgICAgIHJldHVybiBzaG91bGRCbG9ja05ld0xpbmUkMShlZGl0b3IpO1xuICAgIH07XG4gICAgY29uc3QgaW5MaXN0QmxvY2sgPSByZXF1aXJlZFN0YXRlID0+IHtcbiAgICAgIHJldHVybiAoZWRpdG9yLCBfc2hpZnRLZXkpID0+IHtcbiAgICAgICAgcmV0dXJuIGlzTGlzdEl0ZW1QYXJlbnRCbG9jayhlZGl0b3IpID09PSByZXF1aXJlZFN0YXRlO1xuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IGluQmxvY2sgPSAoYmxvY2tOYW1lLCByZXF1aXJlZFN0YXRlKSA9PiAoZWRpdG9yLCBfc2hpZnRLZXkpID0+IHtcbiAgICAgIGNvbnN0IHN0YXRlID0gZ2V0UGFyZW50QmxvY2tOYW1lKGVkaXRvcikgPT09IGJsb2NrTmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgcmV0dXJuIHN0YXRlID09PSByZXF1aXJlZFN0YXRlO1xuICAgIH07XG4gICAgY29uc3QgaW5QcmVCbG9jayA9IHJlcXVpcmVkU3RhdGUgPT4gaW5CbG9jaygncHJlJywgcmVxdWlyZWRTdGF0ZSk7XG4gICAgY29uc3QgaW5TdW1tYXJ5QmxvY2sgPSAoKSA9PiBpbkJsb2NrKCdzdW1tYXJ5JywgdHJ1ZSk7XG4gICAgY29uc3Qgc2hvdWxkUHV0QnJJblByZSA9IHJlcXVpcmVkU3RhdGUgPT4ge1xuICAgICAgcmV0dXJuIChlZGl0b3IsIF9zaGlmdEtleSkgPT4ge1xuICAgICAgICByZXR1cm4gc2hvdWxkUHV0QnJJblByZSQxKGVkaXRvcikgPT09IHJlcXVpcmVkU3RhdGU7XG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgaW5CckNvbnRleHQgPSAoZWRpdG9yLCBfc2hpZnRLZXkpID0+IHtcbiAgICAgIHJldHVybiBzaG91bGRJbnNlcnRCcihlZGl0b3IpO1xuICAgIH07XG4gICAgY29uc3QgaGFzU2hpZnRLZXkgPSAoX2VkaXRvciwgc2hpZnRLZXkpID0+IHtcbiAgICAgIHJldHVybiBzaGlmdEtleTtcbiAgICB9O1xuICAgIGNvbnN0IGNhbkluc2VydEludG9FZGl0YWJsZVJvb3QgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgZm9yY2VkUm9vdEJsb2NrID0gZ2V0Rm9yY2VkUm9vdEJsb2NrKGVkaXRvcik7XG4gICAgICBjb25zdCByb290RWRpdGFibGUgPSBnZXRFZGl0YWJsZVJvb3QkMShlZGl0b3IuZG9tLCBlZGl0b3Iuc2VsZWN0aW9uLmdldFN0YXJ0KCkpO1xuICAgICAgcmV0dXJuIHJvb3RFZGl0YWJsZSAmJiBlZGl0b3Iuc2NoZW1hLmlzVmFsaWRDaGlsZChyb290RWRpdGFibGUubm9kZU5hbWUsIGZvcmNlZFJvb3RCbG9jayk7XG4gICAgfTtcbiAgICBjb25zdCBtYXRjaCA9IChwcmVkaWNhdGVzLCBhY3Rpb24pID0+IHtcbiAgICAgIHJldHVybiAoZWRpdG9yLCBzaGlmdEtleSkgPT4ge1xuICAgICAgICBjb25zdCBpc01hdGNoID0gZm9sZGwocHJlZGljYXRlcywgKHJlcywgcCkgPT4ge1xuICAgICAgICAgIHJldHVybiByZXMgJiYgcChlZGl0b3IsIHNoaWZ0S2V5KTtcbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBpc01hdGNoID8gT3B0aW9uYWwuc29tZShhY3Rpb24pIDogT3B0aW9uYWwubm9uZSgpO1xuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IGdldEFjdGlvbiA9IChlZGl0b3IsIGV2dCkgPT4ge1xuICAgICAgcmV0dXJuIGV2YWx1YXRlVW50aWwoW1xuICAgICAgICBtYXRjaChbc2hvdWxkQmxvY2tOZXdMaW5lXSwgbmV3TGluZUFjdGlvbi5ub25lKCkpLFxuICAgICAgICBtYXRjaChbaW5TdW1tYXJ5QmxvY2soKV0sIG5ld0xpbmVBY3Rpb24uYnIoKSksXG4gICAgICAgIG1hdGNoKFtcbiAgICAgICAgICBpblByZUJsb2NrKHRydWUpLFxuICAgICAgICAgIHNob3VsZFB1dEJySW5QcmUoZmFsc2UpLFxuICAgICAgICAgIGhhc1NoaWZ0S2V5XG4gICAgICAgIF0sIG5ld0xpbmVBY3Rpb24uYnIoKSksXG4gICAgICAgIG1hdGNoKFtcbiAgICAgICAgICBpblByZUJsb2NrKHRydWUpLFxuICAgICAgICAgIHNob3VsZFB1dEJySW5QcmUoZmFsc2UpXG4gICAgICAgIF0sIG5ld0xpbmVBY3Rpb24uYmxvY2soKSksXG4gICAgICAgIG1hdGNoKFtcbiAgICAgICAgICBpblByZUJsb2NrKHRydWUpLFxuICAgICAgICAgIHNob3VsZFB1dEJySW5QcmUodHJ1ZSksXG4gICAgICAgICAgaGFzU2hpZnRLZXlcbiAgICAgICAgXSwgbmV3TGluZUFjdGlvbi5ibG9jaygpKSxcbiAgICAgICAgbWF0Y2goW1xuICAgICAgICAgIGluUHJlQmxvY2sodHJ1ZSksXG4gICAgICAgICAgc2hvdWxkUHV0QnJJblByZSh0cnVlKVxuICAgICAgICBdLCBuZXdMaW5lQWN0aW9uLmJyKCkpLFxuICAgICAgICBtYXRjaChbXG4gICAgICAgICAgaW5MaXN0QmxvY2sodHJ1ZSksXG4gICAgICAgICAgaGFzU2hpZnRLZXlcbiAgICAgICAgXSwgbmV3TGluZUFjdGlvbi5icigpKSxcbiAgICAgICAgbWF0Y2goW2luTGlzdEJsb2NrKHRydWUpXSwgbmV3TGluZUFjdGlvbi5ibG9jaygpKSxcbiAgICAgICAgbWF0Y2goW2luQnJDb250ZXh0XSwgbmV3TGluZUFjdGlvbi5icigpKSxcbiAgICAgICAgbWF0Y2goW2hhc1NoaWZ0S2V5XSwgbmV3TGluZUFjdGlvbi5icigpKSxcbiAgICAgICAgbWF0Y2goW2Nhbkluc2VydEludG9FZGl0YWJsZVJvb3RdLCBuZXdMaW5lQWN0aW9uLmJsb2NrKCkpXG4gICAgICBdLCBbXG4gICAgICAgIGVkaXRvcixcbiAgICAgICAgISEoZXZ0ICYmIGV2dC5zaGlmdEtleSlcbiAgICAgIF0pLmdldE9yKG5ld0xpbmVBY3Rpb24ubm9uZSgpKTtcbiAgICB9O1xuXG4gICAgY29uc3QgaW5zZXJ0ID0gKGVkaXRvciwgZXZ0KSA9PiB7XG4gICAgICBnZXRBY3Rpb24oZWRpdG9yLCBldnQpLmZvbGQoKCkgPT4ge1xuICAgICAgICBpZiAoaXNOb25OdWxsYWJsZShldnQpKSB7XG4gICAgICAgICAgY29uc3QgZXZlbnQgPSBmaXJlRmFrZUJlZm9yZUlucHV0RXZlbnQoZWRpdG9yLCAnaW5zZXJ0TGluZUJyZWFrJyk7XG4gICAgICAgICAgaWYgKGV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGluc2VydCQxKGVkaXRvciwgZXZ0KTtcbiAgICAgICAgaWYgKGlzTm9uTnVsbGFibGUoZXZ0KSkge1xuICAgICAgICAgIGZpcmVGYWtlSW5wdXRFdmVudChlZGl0b3IsICdpbnNlcnRMaW5lQnJlYWsnKTtcbiAgICAgICAgfVxuICAgICAgfSwgKCkgPT4ge1xuICAgICAgICBpZiAoaXNOb25OdWxsYWJsZShldnQpKSB7XG4gICAgICAgICAgY29uc3QgZXZlbnQgPSBmaXJlRmFrZUJlZm9yZUlucHV0RXZlbnQoZWRpdG9yLCAnaW5zZXJ0UGFyYWdyYXBoJyk7XG4gICAgICAgICAgaWYgKGV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGluc2VydCQyKGVkaXRvciwgZXZ0KTtcbiAgICAgICAgaWYgKGlzTm9uTnVsbGFibGUoZXZ0KSkge1xuICAgICAgICAgIGZpcmVGYWtlSW5wdXRFdmVudChlZGl0b3IsICdpbnNlcnRQYXJhZ3JhcGgnKTtcbiAgICAgICAgfVxuICAgICAgfSwgbm9vcCk7XG4gICAgfTtcblxuICAgIGNvbnN0IGhhbmRsZUVudGVyS2V5RXZlbnQgPSAoZWRpdG9yLCBldmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBlbmRUeXBpbmdMZXZlbElnbm9yZUxvY2tzKGVkaXRvci51bmRvTWFuYWdlcik7XG4gICAgICBlZGl0b3IudW5kb01hbmFnZXIudHJhbnNhY3QoKCkgPT4ge1xuICAgICAgICBpZiAoZWRpdG9yLnNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpID09PSBmYWxzZSkge1xuICAgICAgICAgIGV4ZWNEZWxldGVDb21tYW5kKGVkaXRvcik7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0KGVkaXRvciwgZXZlbnQpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBzZXR1cCRoID0gZWRpdG9yID0+IHtcbiAgICAgIGVkaXRvci5vbigna2V5ZG93bicsIGV2ZW50ID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IFZLLkVOVEVSKSB7XG4gICAgICAgICAgaGFuZGxlRW50ZXJLZXlFdmVudChlZGl0b3IsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGV4ZWN1dGVLZXlkb3duT3ZlcnJpZGUkMiA9IChlZGl0b3IsIGNhcmV0LCBldnQpID0+IHtcbiAgICAgIGV4ZWN1dGUoW1xuICAgICAgICB7XG4gICAgICAgICAga2V5Q29kZTogVksuRU5ELFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKG1vdmVUb0xpbmVFbmRQb2ludCQxLCBlZGl0b3IsIHRydWUpXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBrZXlDb2RlOiBWSy5IT01FLFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKG1vdmVUb0xpbmVFbmRQb2ludCQxLCBlZGl0b3IsIGZhbHNlKVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAga2V5Q29kZTogVksuRU5ELFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKG1vdmVUb0xpbmVFbmRQb2ludCwgZWRpdG9yLCB0cnVlKVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAga2V5Q29kZTogVksuSE9NRSxcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbihtb3ZlVG9MaW5lRW5kUG9pbnQsIGVkaXRvciwgZmFsc2UpXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBrZXlDb2RlOiBWSy5FTkQsXG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24obW92ZVRvTGluZUVuZFBvaW50JDIsIGVkaXRvciwgdHJ1ZSwgY2FyZXQpXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBrZXlDb2RlOiBWSy5IT01FLFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKG1vdmVUb0xpbmVFbmRQb2ludCQyLCBlZGl0b3IsIGZhbHNlLCBjYXJldClcbiAgICAgICAgfVxuICAgICAgXSwgZXZ0KS5lYWNoKF8gPT4ge1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3Qgc2V0dXAkZyA9IChlZGl0b3IsIGNhcmV0KSA9PiB7XG4gICAgICBlZGl0b3Iub24oJ2tleWRvd24nLCBldnQgPT4ge1xuICAgICAgICBpZiAoZXZ0LmlzRGVmYXVsdFByZXZlbnRlZCgpID09PSBmYWxzZSkge1xuICAgICAgICAgIGV4ZWN1dGVLZXlkb3duT3ZlcnJpZGUkMihlZGl0b3IsIGNhcmV0LCBldnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3Qgc2V0dXAkZiA9IGVkaXRvciA9PiB7XG4gICAgICBlZGl0b3Iub24oJ2lucHV0JywgZSA9PiB7XG4gICAgICAgIGlmIChlLmlzQ29tcG9zaW5nID09PSBmYWxzZSkge1xuICAgICAgICAgIG5vcm1hbGl6ZU5ic3BzSW5FZGl0b3IoZWRpdG9yKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IHBsYXRmb3JtID0gZGV0ZWN0JDIoKTtcbiAgICBjb25zdCBleGVjdXRlS2V5dXBBY3Rpb24gPSAoZWRpdG9yLCBjYXJldCwgZXZ0KSA9PiB7XG4gICAgICBleGVjdXRlKFtcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLlBBR0VfVVAsXG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24obW92ZVRvTGluZUVuZFBvaW50JDIsIGVkaXRvciwgZmFsc2UsIGNhcmV0KVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAga2V5Q29kZTogVksuUEFHRV9ET1dOLFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKG1vdmVUb0xpbmVFbmRQb2ludCQyLCBlZGl0b3IsIHRydWUsIGNhcmV0KVxuICAgICAgICB9XG4gICAgICBdLCBldnQpO1xuICAgIH07XG4gICAgY29uc3Qgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uID0gZSA9PiBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgIGNvbnN0IGlzUGFnZVVwRG93biA9IGV2dCA9PiBldnQua2V5Q29kZSA9PT0gVksuUEFHRV9VUCB8fCBldnQua2V5Q29kZSA9PT0gVksuUEFHRV9ET1dOO1xuICAgIGNvbnN0IHNldE5vZGVDaGFuZ2VCbG9ja2VyID0gKGJsb2NrZWQsIGVkaXRvciwgYmxvY2spID0+IHtcbiAgICAgIGlmIChibG9jayAmJiAhYmxvY2tlZC5nZXQoKSkge1xuICAgICAgICBlZGl0b3Iub24oJ05vZGVDaGFuZ2UnLCBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24sIHRydWUpO1xuICAgICAgfSBlbHNlIGlmICghYmxvY2sgJiYgYmxvY2tlZC5nZXQoKSkge1xuICAgICAgICBlZGl0b3Iub2ZmKCdOb2RlQ2hhbmdlJywgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKTtcbiAgICAgIH1cbiAgICAgIGJsb2NrZWQuc2V0KGJsb2NrKTtcbiAgICB9O1xuICAgIGNvbnN0IHNldHVwJGUgPSAoZWRpdG9yLCBjYXJldCkgPT4ge1xuICAgICAgaWYgKHBsYXRmb3JtLm9zLmlzTWFjT1MoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBibG9ja2VkID0gQ2VsbChmYWxzZSk7XG4gICAgICBlZGl0b3Iub24oJ2tleWRvd24nLCBldnQgPT4ge1xuICAgICAgICBpZiAoaXNQYWdlVXBEb3duKGV2dCkpIHtcbiAgICAgICAgICBzZXROb2RlQ2hhbmdlQmxvY2tlcihibG9ja2VkLCBlZGl0b3IsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGVkaXRvci5vbigna2V5dXAnLCBldnQgPT4ge1xuICAgICAgICBpZiAoZXZ0LmlzRGVmYXVsdFByZXZlbnRlZCgpID09PSBmYWxzZSkge1xuICAgICAgICAgIGV4ZWN1dGVLZXl1cEFjdGlvbihlZGl0b3IsIGNhcmV0LCBldnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1BhZ2VVcERvd24oZXZ0KSAmJiBibG9ja2VkLmdldCgpKSB7XG4gICAgICAgICAgc2V0Tm9kZUNoYW5nZUJsb2NrZXIoYmxvY2tlZCwgZWRpdG9yLCBmYWxzZSk7XG4gICAgICAgICAgZWRpdG9yLm5vZGVDaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCBpbnNlcnRUZXh0QXRQb3NpdGlvbiA9ICh0ZXh0LCBwb3MpID0+IHtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHBvcy5jb250YWluZXIoKTtcbiAgICAgIGNvbnN0IG9mZnNldCA9IHBvcy5vZmZzZXQoKTtcbiAgICAgIGlmIChpc1RleHQkOChjb250YWluZXIpKSB7XG4gICAgICAgIGNvbnRhaW5lci5pbnNlcnREYXRhKG9mZnNldCwgdGV4dCk7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKENhcmV0UG9zaXRpb24oY29udGFpbmVyLCBvZmZzZXQgKyB0ZXh0Lmxlbmd0aCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGdldEVsZW1lbnRGcm9tUG9zaXRpb24ocG9zKS5tYXAoZWxtID0+IHtcbiAgICAgICAgICBjb25zdCB0ZXh0Tm9kZSA9IFN1Z2FyRWxlbWVudC5mcm9tVGV4dCh0ZXh0KTtcbiAgICAgICAgICBpZiAocG9zLmlzQXRFbmQoKSkge1xuICAgICAgICAgICAgYWZ0ZXIkNChlbG0sIHRleHROb2RlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYmVmb3JlJDMoZWxtLCB0ZXh0Tm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBDYXJldFBvc2l0aW9uKHRleHROb2RlLmRvbSwgdGV4dC5sZW5ndGgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGluc2VydE5ic3BBdFBvc2l0aW9uID0gY3VycnkoaW5zZXJ0VGV4dEF0UG9zaXRpb24sIG5ic3ApO1xuICAgIGNvbnN0IGluc2VydFNwYWNlQXRQb3NpdGlvbiA9IGN1cnJ5KGluc2VydFRleHRBdFBvc2l0aW9uLCAnICcpO1xuXG4gICAgY29uc3QgbG9jYXRpb25Ub0NhcmV0UG9zaXRpb24gPSByb290ID0+IGxvY2F0aW9uID0+IGxvY2F0aW9uLmZvbGQoZWxlbWVudCA9PiBwcmV2UG9zaXRpb24ocm9vdC5kb20sIENhcmV0UG9zaXRpb24uYmVmb3JlKGVsZW1lbnQpKSwgZWxlbWVudCA9PiBmaXJzdFBvc2l0aW9uSW4oZWxlbWVudCksIGVsZW1lbnQgPT4gbGFzdFBvc2l0aW9uSW4oZWxlbWVudCksIGVsZW1lbnQgPT4gbmV4dFBvc2l0aW9uKHJvb3QuZG9tLCBDYXJldFBvc2l0aW9uLmFmdGVyKGVsZW1lbnQpKSk7XG4gICAgY29uc3QgaW5zZXJ0SW5saW5lQm91bmRhcnlTcGFjZU9yTmJzcCA9IChyb290LCBwb3MpID0+IGNoZWNrUG9zID0+IG5lZWRzVG9IYXZlTmJzcChyb290LCBjaGVja1BvcykgPyBpbnNlcnROYnNwQXRQb3NpdGlvbihwb3MpIDogaW5zZXJ0U3BhY2VBdFBvc2l0aW9uKHBvcyk7XG4gICAgY29uc3Qgc2V0U2VsZWN0aW9uID0gZWRpdG9yID0+IHBvcyA9PiB7XG4gICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNldFJuZyhwb3MudG9SYW5nZSgpKTtcbiAgICAgIGVkaXRvci5ub2RlQ2hhbmdlZCgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBjb25zdCBpbnNlcnRTcGFjZU9yTmJzcEF0U2VsZWN0aW9uID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IHBvcyA9IENhcmV0UG9zaXRpb24uZnJvbVJhbmdlU3RhcnQoZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKSk7XG4gICAgICBjb25zdCByb290ID0gU3VnYXJFbGVtZW50LmZyb21Eb20oZWRpdG9yLmdldEJvZHkoKSk7XG4gICAgICBpZiAoZWRpdG9yLnNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpKSB7XG4gICAgICAgIGNvbnN0IGlzSW5saW5lVGFyZ2V0JDEgPSBjdXJyeShpc0lubGluZVRhcmdldCwgZWRpdG9yKTtcbiAgICAgICAgY29uc3QgY2FyZXRQb3NpdGlvbiA9IENhcmV0UG9zaXRpb24uZnJvbVJhbmdlU3RhcnQoZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKSk7XG4gICAgICAgIHJldHVybiByZWFkTG9jYXRpb24oaXNJbmxpbmVUYXJnZXQkMSwgZWRpdG9yLmdldEJvZHkoKSwgY2FyZXRQb3NpdGlvbikuYmluZChsb2NhdGlvblRvQ2FyZXRQb3NpdGlvbihyb290KSkubWFwKGNoZWNrUG9zID0+ICgpID0+IGluc2VydElubGluZUJvdW5kYXJ5U3BhY2VPck5ic3Aocm9vdCwgcG9zKShjaGVja1BvcykuZWFjaChzZXRTZWxlY3Rpb24oZWRpdG9yKSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgZXhlY3V0ZUtleWRvd25PdmVycmlkZSQxID0gKGVkaXRvciwgZXZ0KSA9PiB7XG4gICAgICBleGVjdXRlV2l0aERlbGF5ZWRBY3Rpb24oW3tcbiAgICAgICAgICBrZXlDb2RlOiBWSy5TUEFDRUJBUixcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbihpbnNlcnRTcGFjZU9yTmJzcEF0U2VsZWN0aW9uLCBlZGl0b3IpXG4gICAgICAgIH1dLCBldnQpLmVhY2goYXBwbHlBY3Rpb24gPT4ge1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBmaXJlRmFrZUJlZm9yZUlucHV0RXZlbnQoZWRpdG9yLCAnaW5zZXJ0VGV4dCcsIHsgZGF0YTogJyAnIH0pO1xuICAgICAgICBpZiAoIWV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgYXBwbHlBY3Rpb24oKTtcbiAgICAgICAgICBmaXJlRmFrZUlucHV0RXZlbnQoZWRpdG9yLCAnaW5zZXJ0VGV4dCcsIHsgZGF0YTogJyAnIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHNldHVwJGQgPSBlZGl0b3IgPT4ge1xuICAgICAgZWRpdG9yLm9uKCdrZXlkb3duJywgZXZ0ID0+IHtcbiAgICAgICAgaWYgKGV2dC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBleGVjdXRlS2V5ZG93bk92ZXJyaWRlJDEoZWRpdG9yLCBldnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3QgdGFibGVUYWJOYXZpZ2F0aW9uID0gZWRpdG9yID0+IHtcbiAgICAgIGlmIChoYXNUYWJsZVRhYk5hdmlnYXRpb24oZWRpdG9yKSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGtleUNvZGU6IFZLLlRBQixcbiAgICAgICAgICAgIGFjdGlvbjogYWN0aW9uKGhhbmRsZVRhYiwgZWRpdG9yLCB0cnVlKVxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAga2V5Q29kZTogVksuVEFCLFxuICAgICAgICAgICAgc2hpZnRLZXk6IHRydWUsXG4gICAgICAgICAgICBhY3Rpb246IGFjdGlvbihoYW5kbGVUYWIsIGVkaXRvciwgZmFsc2UpXG4gICAgICAgICAgfVxuICAgICAgICBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZXhlY3V0ZUtleWRvd25PdmVycmlkZSA9IChlZGl0b3IsIGV2dCkgPT4ge1xuICAgICAgZXhlY3V0ZShbLi4udGFibGVUYWJOYXZpZ2F0aW9uKGVkaXRvcildLCBldnQpLmVhY2goXyA9PiB7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBzZXR1cCRjID0gZWRpdG9yID0+IHtcbiAgICAgIGVkaXRvci5vbigna2V5ZG93bicsIGV2dCA9PiB7XG4gICAgICAgIGlmIChldnQuaXNEZWZhdWx0UHJldmVudGVkKCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgZXhlY3V0ZUtleWRvd25PdmVycmlkZShlZGl0b3IsIGV2dCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCBzZXR1cCRiID0gZWRpdG9yID0+IHtcbiAgICAgIGVkaXRvci5hZGRTaG9ydGN1dCgnTWV0YStQJywgJycsICdtY2VQcmludCcpO1xuICAgICAgc2V0dXAkaihlZGl0b3IpO1xuICAgICAgaWYgKGlzUnRjKGVkaXRvcikpIHtcbiAgICAgICAgcmV0dXJuIENlbGwobnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjYXJldCA9IHNldHVwU2VsZWN0ZWRTdGF0ZShlZGl0b3IpO1xuICAgICAgICBzZXR1cCRsKGVkaXRvcik7XG4gICAgICAgIHNldHVwJGsoZWRpdG9yLCBjYXJldCk7XG4gICAgICAgIHNldHVwJGkoZWRpdG9yLCBjYXJldCk7XG4gICAgICAgIHNldHVwJGgoZWRpdG9yKTtcbiAgICAgICAgc2V0dXAkZChlZGl0b3IpO1xuICAgICAgICBzZXR1cCRmKGVkaXRvcik7XG4gICAgICAgIHNldHVwJGMoZWRpdG9yKTtcbiAgICAgICAgc2V0dXAkZyhlZGl0b3IsIGNhcmV0KTtcbiAgICAgICAgc2V0dXAkZShlZGl0b3IsIGNhcmV0KTtcbiAgICAgICAgcmV0dXJuIGNhcmV0O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjbGFzcyBOb2RlQ2hhbmdlIHtcbiAgICAgIGNvbnN0cnVjdG9yKGVkaXRvcikge1xuICAgICAgICB0aGlzLmxhc3RQYXRoID0gW107XG4gICAgICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yO1xuICAgICAgICBsZXQgbGFzdFJuZztcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmICghKCdvbnNlbGVjdGlvbmNoYW5nZScgaW4gZWRpdG9yLmdldERvYygpKSkge1xuICAgICAgICAgIGVkaXRvci5vbignTm9kZUNoYW5nZSBjbGljayBtb3VzZXVwIGtleXVwIGZvY3VzJywgZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuYXRpdmVSbmcgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpO1xuICAgICAgICAgICAgY29uc3QgZmFrZVJuZyA9IHtcbiAgICAgICAgICAgICAgc3RhcnRDb250YWluZXI6IG5hdGl2ZVJuZy5zdGFydENvbnRhaW5lcixcbiAgICAgICAgICAgICAgc3RhcnRPZmZzZXQ6IG5hdGl2ZVJuZy5zdGFydE9mZnNldCxcbiAgICAgICAgICAgICAgZW5kQ29udGFpbmVyOiBuYXRpdmVSbmcuZW5kQ29udGFpbmVyLFxuICAgICAgICAgICAgICBlbmRPZmZzZXQ6IG5hdGl2ZVJuZy5lbmRPZmZzZXRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoZS50eXBlID09PSAnbm9kZWNoYW5nZScgfHwgIWlzRXEkNChmYWtlUm5nLCBsYXN0Um5nKSkge1xuICAgICAgICAgICAgICBlZGl0b3IuZGlzcGF0Y2goJ1NlbGVjdGlvbkNoYW5nZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdFJuZyA9IGZha2VSbmc7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWRpdG9yLm9uKCdjb250ZXh0bWVudScsICgpID0+IHtcbiAgICAgICAgICBlZGl0b3IuZGlzcGF0Y2goJ1NlbGVjdGlvbkNoYW5nZScpO1xuICAgICAgICB9KTtcbiAgICAgICAgZWRpdG9yLm9uKCdTZWxlY3Rpb25DaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3RhcnRFbG0gPSBlZGl0b3Iuc2VsZWN0aW9uLmdldFN0YXJ0KHRydWUpO1xuICAgICAgICAgIGlmICghc3RhcnRFbG0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhhc0FueVJhbmdlcyhlZGl0b3IpICYmICFzZWxmLmlzU2FtZUVsZW1lbnRQYXRoKHN0YXJ0RWxtKSAmJiBlZGl0b3IuZG9tLmlzQ2hpbGRPZihzdGFydEVsbSwgZWRpdG9yLmdldEJvZHkoKSkpIHtcbiAgICAgICAgICAgIGVkaXRvci5ub2RlQ2hhbmdlZCh7IHNlbGVjdGlvbkNoYW5nZTogdHJ1ZSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBlZGl0b3Iub24oJ21vdXNldXAnLCBlID0+IHtcbiAgICAgICAgICBpZiAoIWUuaXNEZWZhdWx0UHJldmVudGVkKCkgJiYgaGFzQW55UmFuZ2VzKGVkaXRvcikpIHtcbiAgICAgICAgICAgIGlmIChlZGl0b3Iuc2VsZWN0aW9uLmdldE5vZGUoKS5ub2RlTmFtZSA9PT0gJ0lNRycpIHtcbiAgICAgICAgICAgICAgRGVsYXkuc2V0RWRpdG9yVGltZW91dChlZGl0b3IsICgpID0+IHtcbiAgICAgICAgICAgICAgICBlZGl0b3Iubm9kZUNoYW5nZWQoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlZGl0b3Iubm9kZUNoYW5nZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgbm9kZUNoYW5nZWQoYXJncykge1xuICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSB0aGlzLmVkaXRvci5zZWxlY3Rpb247XG4gICAgICAgIGxldCBub2RlLCBwYXJlbnRzLCByb290O1xuICAgICAgICBpZiAodGhpcy5lZGl0b3IuaW5pdGlhbGl6ZWQgJiYgc2VsZWN0aW9uICYmICFzaG91bGREaXNhYmxlTm9kZUNoYW5nZSh0aGlzLmVkaXRvcikgJiYgIXRoaXMuZWRpdG9yLm1vZGUuaXNSZWFkT25seSgpKSB7XG4gICAgICAgICAgcm9vdCA9IHRoaXMuZWRpdG9yLmdldEJvZHkoKTtcbiAgICAgICAgICBub2RlID0gc2VsZWN0aW9uLmdldFN0YXJ0KHRydWUpIHx8IHJvb3Q7XG4gICAgICAgICAgaWYgKG5vZGUub3duZXJEb2N1bWVudCAhPT0gdGhpcy5lZGl0b3IuZ2V0RG9jKCkgfHwgIXRoaXMuZWRpdG9yLmRvbS5pc0NoaWxkT2Yobm9kZSwgcm9vdCkpIHtcbiAgICAgICAgICAgIG5vZGUgPSByb290O1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJlbnRzID0gW107XG4gICAgICAgICAgdGhpcy5lZGl0b3IuZG9tLmdldFBhcmVudChub2RlLCBub2RlID0+IHtcbiAgICAgICAgICAgIGlmIChub2RlID09PSByb290KSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyZW50cy5wdXNoKG5vZGUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGFyZ3MgPSBhcmdzIHx8IHt9O1xuICAgICAgICAgIGFyZ3MuZWxlbWVudCA9IG5vZGU7XG4gICAgICAgICAgYXJncy5wYXJlbnRzID0gcGFyZW50cztcbiAgICAgICAgICB0aGlzLmVkaXRvci5kaXNwYXRjaCgnTm9kZUNoYW5nZScsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpc1NhbWVFbGVtZW50UGF0aChzdGFydEVsbSkge1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgY29uc3QgZWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRQYXRoID0gcmV2ZXJzZShlZGl0b3IuZG9tLmdldFBhcmVudHMoc3RhcnRFbG0sIGFsd2F5cywgZWRpdG9yLmdldEJvZHkoKSkpO1xuICAgICAgICBpZiAoY3VycmVudFBhdGgubGVuZ3RoID09PSB0aGlzLmxhc3RQYXRoLmxlbmd0aCkge1xuICAgICAgICAgIGZvciAoaSA9IGN1cnJlbnRQYXRoLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UGF0aFtpXSAhPT0gdGhpcy5sYXN0UGF0aFtpXSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RQYXRoID0gY3VycmVudFBhdGg7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXN0UGF0aCA9IGN1cnJlbnRQYXRoO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgaW50ZXJuYWxNaW1lVHlwZSA9ICd4LXRpbnltY2UvaHRtbCc7XG4gICAgY29uc3QgaW50ZXJuYWxIdG1sTWltZSA9IGNvbnN0YW50KGludGVybmFsTWltZVR5cGUpO1xuICAgIGNvbnN0IGludGVybmFsTWFyayA9ICc8IS0tICcgKyBpbnRlcm5hbE1pbWVUeXBlICsgJyAtLT4nO1xuICAgIGNvbnN0IG1hcmsgPSBodG1sID0+IGludGVybmFsTWFyayArIGh0bWw7XG4gICAgY29uc3QgdW5tYXJrID0gaHRtbCA9PiBodG1sLnJlcGxhY2UoaW50ZXJuYWxNYXJrLCAnJyk7XG4gICAgY29uc3QgaXNNYXJrZWQgPSBodG1sID0+IGh0bWwuaW5kZXhPZihpbnRlcm5hbE1hcmspICE9PSAtMTtcblxuICAgIGNvbnN0IGlzUGxhaW5UZXh0ID0gdGV4dCA9PiB7XG4gICAgICByZXR1cm4gIS88KD86XFwvPyg/ISg/OmRpdnxwfGJyfHNwYW4pPilcXHcrfCg/Oig/ISg/OnNwYW4gc3R5bGU9XCJ3aGl0ZS1zcGFjZTpcXHM/cHJlOz9cIj4pfGJyXFxzP1xcLz4pKVxcdytcXHNbXj5dKyk+L2kudGVzdCh0ZXh0KTtcbiAgICB9O1xuICAgIGNvbnN0IG9wZW5Db250YWluZXIgPSAocm9vdFRhZywgcm9vdEF0dHJzKSA9PiB7XG4gICAgICBsZXQgdGFnID0gJzwnICsgcm9vdFRhZztcbiAgICAgIGNvbnN0IGF0dHJzID0gbWFwVG9BcnJheShyb290QXR0cnMsICh2YWx1ZSwga2V5KSA9PiBrZXkgKyAnPVwiJyArIEVudGl0aWVzLmVuY29kZUFsbFJhdyh2YWx1ZSkgKyAnXCInKTtcbiAgICAgIGlmIChhdHRycy5sZW5ndGgpIHtcbiAgICAgICAgdGFnICs9ICcgJyArIGF0dHJzLmpvaW4oJyAnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YWcgKyAnPic7XG4gICAgfTtcbiAgICBjb25zdCB0b0Jsb2NrRWxlbWVudHMgPSAodGV4dCwgcm9vdFRhZywgcm9vdEF0dHJzKSA9PiB7XG4gICAgICBjb25zdCBibG9ja3MgPSB0ZXh0LnNwbGl0KC9cXG5cXG4vKTtcbiAgICAgIGNvbnN0IHRhZ09wZW4gPSBvcGVuQ29udGFpbmVyKHJvb3RUYWcsIHJvb3RBdHRycyk7XG4gICAgICBjb25zdCB0YWdDbG9zZSA9ICc8LycgKyByb290VGFnICsgJz4nO1xuICAgICAgY29uc3QgcGFyYWdyYXBocyA9IG1hcCQzKGJsb2NrcywgcCA9PiB7XG4gICAgICAgIHJldHVybiBwLnNwbGl0KC9cXG4vKS5qb2luKCc8YnIgLz4nKTtcbiAgICAgIH0pO1xuICAgICAgY29uc3Qgc3RpdGNoID0gcCA9PiB7XG4gICAgICAgIHJldHVybiB0YWdPcGVuICsgcCArIHRhZ0Nsb3NlO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBwYXJhZ3JhcGhzLmxlbmd0aCA9PT0gMSA/IHBhcmFncmFwaHNbMF0gOiBtYXAkMyhwYXJhZ3JhcGhzLCBzdGl0Y2gpLmpvaW4oJycpO1xuICAgIH07XG5cbiAgICBjb25zdCBwYXN0ZUJpbkRlZmF1bHRDb250ZW50ID0gJyVNQ0VQQVNURUJJTiUnO1xuICAgIGNvbnN0IGNyZWF0ZSQ2ID0gKGVkaXRvciwgbGFzdFJuZ0NlbGwpID0+IHtcbiAgICAgIGNvbnN0IHtkb20sIHNlbGVjdGlvbn0gPSBlZGl0b3I7XG4gICAgICBjb25zdCBib2R5ID0gZWRpdG9yLmdldEJvZHkoKTtcbiAgICAgIGxhc3RSbmdDZWxsLnNldChzZWxlY3Rpb24uZ2V0Um5nKCkpO1xuICAgICAgY29uc3QgcGFzdGVCaW5FbG0gPSBkb20uYWRkKGVkaXRvci5nZXRCb2R5KCksICdkaXYnLCB7XG4gICAgICAgICdpZCc6ICdtY2VwYXN0ZWJpbicsXG4gICAgICAgICdjbGFzcyc6ICdtY2UtcGFzdGViaW4nLFxuICAgICAgICAnY29udGVudEVkaXRhYmxlJzogdHJ1ZSxcbiAgICAgICAgJ2RhdGEtbWNlLWJvZ3VzJzogJ2FsbCcsXG4gICAgICAgICdzdHlsZSc6ICdwb3NpdGlvbjogZml4ZWQ7IHRvcDogNTAlOyB3aWR0aDogMTBweDsgaGVpZ2h0OiAxMHB4OyBvdmVyZmxvdzogaGlkZGVuOyBvcGFjaXR5OiAwJ1xuICAgICAgfSwgcGFzdGVCaW5EZWZhdWx0Q29udGVudCk7XG4gICAgICBpZiAoRW52LmJyb3dzZXIuaXNGaXJlZm94KCkpIHtcbiAgICAgICAgZG9tLnNldFN0eWxlKHBhc3RlQmluRWxtLCAnbGVmdCcsIGRvbS5nZXRTdHlsZShib2R5LCAnZGlyZWN0aW9uJywgdHJ1ZSkgPT09ICdydGwnID8gNjU1MzUgOiAtNjU1MzUpO1xuICAgICAgfVxuICAgICAgZG9tLmJpbmQocGFzdGVCaW5FbG0sICdiZWZvcmVkZWFjdGl2YXRlIGZvY3VzaW4gZm9jdXNvdXQnLCBlID0+IHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH0pO1xuICAgICAgcGFzdGVCaW5FbG0uZm9jdXMoKTtcbiAgICAgIHNlbGVjdGlvbi5zZWxlY3QocGFzdGVCaW5FbG0sIHRydWUpO1xuICAgIH07XG4gICAgY29uc3QgcmVtb3ZlID0gKGVkaXRvciwgbGFzdFJuZ0NlbGwpID0+IHtcbiAgICAgIGNvbnN0IGRvbSA9IGVkaXRvci5kb207XG4gICAgICBpZiAoZ2V0RWwoZWRpdG9yKSkge1xuICAgICAgICBsZXQgcGFzdGVCaW5DbG9uZTtcbiAgICAgICAgY29uc3QgbGFzdFJuZyA9IGxhc3RSbmdDZWxsLmdldCgpO1xuICAgICAgICB3aGlsZSAocGFzdGVCaW5DbG9uZSA9IGdldEVsKGVkaXRvcikpIHtcbiAgICAgICAgICBkb20ucmVtb3ZlKHBhc3RlQmluQ2xvbmUpO1xuICAgICAgICAgIGRvbS51bmJpbmQocGFzdGVCaW5DbG9uZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RSbmcpIHtcbiAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNldFJuZyhsYXN0Um5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGFzdFJuZ0NlbGwuc2V0KG51bGwpO1xuICAgIH07XG4gICAgY29uc3QgZ2V0RWwgPSBlZGl0b3IgPT4gZWRpdG9yLmRvbS5nZXQoJ21jZXBhc3RlYmluJyk7XG4gICAgY29uc3QgaXNQYXN0ZUJpbiA9IGVsbSA9PiBlbG0gJiYgZWxtLmlkID09PSAnbWNlcGFzdGViaW4nO1xuICAgIGNvbnN0IGdldEh0bWwgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgZG9tID0gZWRpdG9yLmRvbTtcbiAgICAgIGNvbnN0IGNvcHlBbmRSZW1vdmUgPSAodG9FbG0sIGZyb21FbG0pID0+IHtcbiAgICAgICAgdG9FbG0uYXBwZW5kQ2hpbGQoZnJvbUVsbSk7XG4gICAgICAgIGRvbS5yZW1vdmUoZnJvbUVsbSwgdHJ1ZSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgW3Bhc3RlQmluRWxtLCAuLi5wYXN0ZUJpbkNsb25lc10gPSBmaWx0ZXIkNihlZGl0b3IuZ2V0Qm9keSgpLmNoaWxkTm9kZXMsIGlzUGFzdGVCaW4pO1xuICAgICAgZWFjaCRnKHBhc3RlQmluQ2xvbmVzLCBwYXN0ZUJpbkNsb25lID0+IHtcbiAgICAgICAgY29weUFuZFJlbW92ZShwYXN0ZUJpbkVsbSwgcGFzdGVCaW5DbG9uZSk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGRpcnR5V3JhcHBlcnMgPSBkb20uc2VsZWN0KCdkaXZbaWQ9bWNlcGFzdGViaW5dJywgcGFzdGVCaW5FbG0pO1xuICAgICAgZm9yIChsZXQgaSA9IGRpcnR5V3JhcHBlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3QgY2xlYW5XcmFwcGVyID0gZG9tLmNyZWF0ZSgnZGl2Jyk7XG4gICAgICAgIHBhc3RlQmluRWxtLmluc2VydEJlZm9yZShjbGVhbldyYXBwZXIsIGRpcnR5V3JhcHBlcnNbaV0pO1xuICAgICAgICBjb3B5QW5kUmVtb3ZlKGNsZWFuV3JhcHBlciwgZGlydHlXcmFwcGVyc1tpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFzdGVCaW5FbG0gPyBwYXN0ZUJpbkVsbS5pbm5lckhUTUwgOiAnJztcbiAgICB9O1xuICAgIGNvbnN0IGlzRGVmYXVsdFBhc3RlQmluQ29udGVudCA9IGNvbnRlbnQgPT4gY29udGVudCA9PT0gcGFzdGVCaW5EZWZhdWx0Q29udGVudDtcbiAgICBjb25zdCBQYXN0ZUJpbiA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBsYXN0Um5nID0gQ2VsbChudWxsKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNyZWF0ZTogKCkgPT4gY3JlYXRlJDYoZWRpdG9yLCBsYXN0Um5nKSxcbiAgICAgICAgcmVtb3ZlOiAoKSA9PiByZW1vdmUoZWRpdG9yLCBsYXN0Um5nKSxcbiAgICAgICAgZ2V0RWw6ICgpID0+IGdldEVsKGVkaXRvciksXG4gICAgICAgIGdldEh0bWw6ICgpID0+IGdldEh0bWwoZWRpdG9yKSxcbiAgICAgICAgZ2V0TGFzdFJuZzogbGFzdFJuZy5nZXRcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IGZpbHRlciA9IChjb250ZW50LCBpdGVtcykgPT4ge1xuICAgICAgVG9vbHMuZWFjaChpdGVtcywgdiA9PiB7XG4gICAgICAgIGlmIChpcyQ0KHYsIFJlZ0V4cCkpIHtcbiAgICAgICAgICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKHYsICcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKHZbMF0sIHZbMV0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH07XG4gICAgY29uc3QgaW5uZXJUZXh0ID0gaHRtbCA9PiB7XG4gICAgICBjb25zdCBzY2hlbWEgPSBTY2hlbWEoKTtcbiAgICAgIGNvbnN0IGRvbVBhcnNlciA9IERvbVBhcnNlcih7fSwgc2NoZW1hKTtcbiAgICAgIGxldCB0ZXh0ID0gJyc7XG4gICAgICBjb25zdCB2b2lkRWxlbWVudHMgPSBzY2hlbWEuZ2V0Vm9pZEVsZW1lbnRzKCk7XG4gICAgICBjb25zdCBpZ25vcmVFbGVtZW50cyA9IFRvb2xzLm1ha2VNYXAoJ3NjcmlwdCBub3NjcmlwdCBzdHlsZSB0ZXh0YXJlYSB2aWRlbyBhdWRpbyBpZnJhbWUgb2JqZWN0JywgJyAnKTtcbiAgICAgIGNvbnN0IGJsb2NrRWxlbWVudHMgPSBzY2hlbWEuZ2V0QmxvY2tFbGVtZW50cygpO1xuICAgICAgY29uc3Qgd2FsayA9IG5vZGUgPT4ge1xuICAgICAgICBjb25zdCBuYW1lID0gbm9kZS5uYW1lLCBjdXJyZW50Tm9kZSA9IG5vZGU7XG4gICAgICAgIGlmIChuYW1lID09PSAnYnInKSB7XG4gICAgICAgICAgdGV4dCArPSAnXFxuJztcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUgPT09ICd3YnInKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2b2lkRWxlbWVudHNbbmFtZV0pIHtcbiAgICAgICAgICB0ZXh0ICs9ICcgJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaWdub3JlRWxlbWVudHNbbmFtZV0pIHtcbiAgICAgICAgICB0ZXh0ICs9ICcgJztcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gMykge1xuICAgICAgICAgIHRleHQgKz0gbm9kZS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShub2RlLm5hbWUgaW4gc2NoZW1hLmdldFZvaWRFbGVtZW50cygpKSkge1xuICAgICAgICAgIGlmIChub2RlID0gbm9kZS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHdhbGsobm9kZSk7XG4gICAgICAgICAgICB9IHdoaWxlIChub2RlID0gbm9kZS5uZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJsb2NrRWxlbWVudHNbbmFtZV0gJiYgY3VycmVudE5vZGUubmV4dCkge1xuICAgICAgICAgIHRleHQgKz0gJ1xcbic7XG4gICAgICAgICAgaWYgKG5hbWUgPT09ICdwJykge1xuICAgICAgICAgICAgdGV4dCArPSAnXFxuJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBodG1sID0gZmlsdGVyKGh0bWwsIFsvPCFcXFtbXlxcXV0rXFxdPi9nXSk7XG4gICAgICB3YWxrKGRvbVBhcnNlci5wYXJzZShodG1sKSk7XG4gICAgICByZXR1cm4gdGV4dDtcbiAgICB9O1xuICAgIGNvbnN0IHRyaW1IdG1sID0gaHRtbCA9PiB7XG4gICAgICBjb25zdCB0cmltU3BhY2VzID0gKGFsbCwgczEsIHMyKSA9PiB7XG4gICAgICAgIGlmICghczEgJiYgIXMyKSB7XG4gICAgICAgICAgcmV0dXJuICcgJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmJzcDtcbiAgICAgIH07XG4gICAgICBodG1sID0gZmlsdGVyKGh0bWwsIFtcbiAgICAgICAgL15bXFxzXFxTXSo8Ym9keVtePl0qPlxccyp8XFxzKjxcXC9ib2R5W14+XSo+W1xcc1xcU10qJC9pZyxcbiAgICAgICAgLzwhLS1TdGFydEZyYWdtZW50LS0+fDwhLS1FbmRGcmFnbWVudC0tPi9nLFxuICAgICAgICBbXG4gICAgICAgICAgLyggPyk8c3BhbiBjbGFzcz1cIkFwcGxlLWNvbnZlcnRlZC1zcGFjZVwiPlxcdTAwYTA8XFwvc3Bhbj4oID8pL2csXG4gICAgICAgICAgdHJpbVNwYWNlc1xuICAgICAgICBdLFxuICAgICAgICAvPGJyIGNsYXNzPVwiQXBwbGUtaW50ZXJjaGFuZ2UtbmV3bGluZVwiPi9nLFxuICAgICAgICAvPGJyPiQvaVxuICAgICAgXSk7XG4gICAgICByZXR1cm4gaHRtbDtcbiAgICB9O1xuICAgIGNvbnN0IGNyZWF0ZUlkR2VuZXJhdG9yID0gcHJlZml4ID0+IHtcbiAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICByZXR1cm4gcHJlZml4ICsgY291bnQrKztcbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBnZXRJbWFnZU1pbWVUeXBlID0gZXh0ID0+IHtcbiAgICAgIGNvbnN0IGxvd2VyRXh0ID0gZXh0LnRvTG93ZXJDYXNlKCk7XG4gICAgICBjb25zdCBtaW1lT3ZlcnJpZGVzID0ge1xuICAgICAgICBqcGc6ICdqcGVnJyxcbiAgICAgICAganBlOiAnanBlZycsXG4gICAgICAgIGpmaTogJ2pwZWcnLFxuICAgICAgICBqaWY6ICdqcGVnJyxcbiAgICAgICAgamZpZjogJ2pwZWcnLFxuICAgICAgICBwanBlZzogJ2pwZWcnLFxuICAgICAgICBwanA6ICdqcGVnJyxcbiAgICAgICAgc3ZnOiAnc3ZnK3htbCdcbiAgICAgIH07XG4gICAgICByZXR1cm4gVG9vbHMuaGFzT3duKG1pbWVPdmVycmlkZXMsIGxvd2VyRXh0KSA/ICdpbWFnZS8nICsgbWltZU92ZXJyaWRlc1tsb3dlckV4dF0gOiAnaW1hZ2UvJyArIGxvd2VyRXh0O1xuICAgIH07XG5cbiAgICBjb25zdCBwcmVQcm9jZXNzID0gKGVkaXRvciwgaHRtbCkgPT4ge1xuICAgICAgY29uc3QgcGFyc2VyID0gRG9tUGFyc2VyKHt9LCBlZGl0b3Iuc2NoZW1hKTtcbiAgICAgIHBhcnNlci5hZGROb2RlRmlsdGVyKCdtZXRhJywgbm9kZXMgPT4ge1xuICAgICAgICBUb29scy5lYWNoKG5vZGVzLCBub2RlID0+IHtcbiAgICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgZnJhZ21lbnQgPSBwYXJzZXIucGFyc2UoaHRtbCwge1xuICAgICAgICBmb3JjZWRfcm9vdF9ibG9jazogZmFsc2UsXG4gICAgICAgIGlzUm9vdENvbnRlbnQ6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIEh0bWxTZXJpYWxpemVyKHsgdmFsaWRhdGU6IHRydWUgfSwgZWRpdG9yLnNjaGVtYSkuc2VyaWFsaXplKGZyYWdtZW50KTtcbiAgICB9O1xuICAgIGNvbnN0IHByb2Nlc3NSZXN1bHQgPSAoY29udGVudCwgY2FuY2VsbGVkKSA9PiAoe1xuICAgICAgY29udGVudCxcbiAgICAgIGNhbmNlbGxlZFxuICAgIH0pO1xuICAgIGNvbnN0IHBvc3RQcm9jZXNzRmlsdGVyID0gKGVkaXRvciwgaHRtbCwgaW50ZXJuYWwpID0+IHtcbiAgICAgIGNvbnN0IHRlbXBCb2R5ID0gZWRpdG9yLmRvbS5jcmVhdGUoJ2RpdicsIHsgc3R5bGU6ICdkaXNwbGF5Om5vbmUnIH0sIGh0bWwpO1xuICAgICAgY29uc3QgcG9zdFByb2Nlc3NBcmdzID0gZmlyZVBhc3RlUG9zdFByb2Nlc3MoZWRpdG9yLCB0ZW1wQm9keSwgaW50ZXJuYWwpO1xuICAgICAgcmV0dXJuIHByb2Nlc3NSZXN1bHQocG9zdFByb2Nlc3NBcmdzLm5vZGUuaW5uZXJIVE1MLCBwb3N0UHJvY2Vzc0FyZ3MuaXNEZWZhdWx0UHJldmVudGVkKCkpO1xuICAgIH07XG4gICAgY29uc3QgZmlsdGVyQ29udGVudCA9IChlZGl0b3IsIGNvbnRlbnQsIGludGVybmFsKSA9PiB7XG4gICAgICBjb25zdCBwcmVQcm9jZXNzQXJncyA9IGZpcmVQYXN0ZVByZVByb2Nlc3MoZWRpdG9yLCBjb250ZW50LCBpbnRlcm5hbCk7XG4gICAgICBjb25zdCBmaWx0ZXJlZENvbnRlbnQgPSBwcmVQcm9jZXNzKGVkaXRvciwgcHJlUHJvY2Vzc0FyZ3MuY29udGVudCk7XG4gICAgICBpZiAoZWRpdG9yLmhhc0V2ZW50TGlzdGVuZXJzKCdQYXN0ZVBvc3RQcm9jZXNzJykgJiYgIXByZVByb2Nlc3NBcmdzLmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgIHJldHVybiBwb3N0UHJvY2Vzc0ZpbHRlcihlZGl0b3IsIGZpbHRlcmVkQ29udGVudCwgaW50ZXJuYWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NSZXN1bHQoZmlsdGVyZWRDb250ZW50LCBwcmVQcm9jZXNzQXJncy5pc0RlZmF1bHRQcmV2ZW50ZWQoKSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBwcm9jZXNzID0gKGVkaXRvciwgaHRtbCwgaW50ZXJuYWwpID0+IHtcbiAgICAgIHJldHVybiBmaWx0ZXJDb250ZW50KGVkaXRvciwgaHRtbCwgaW50ZXJuYWwpO1xuICAgIH07XG5cbiAgICBjb25zdCBwYXN0ZUh0bWwkMSA9IChlZGl0b3IsIGh0bWwpID0+IHtcbiAgICAgIGVkaXRvci5pbnNlcnRDb250ZW50KGh0bWwsIHtcbiAgICAgICAgbWVyZ2U6IHNob3VsZFBhc3RlTWVyZ2VGb3JtYXRzKGVkaXRvciksXG4gICAgICAgIHBhc3RlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgY29uc3QgaXNBYnNvbHV0ZVVybCA9IHVybCA9PiAvXmh0dHBzPzpcXC9cXC9bXFx3XFw/XFwtXFwvKz0uJiVAfiNdKyQvaS50ZXN0KHVybCk7XG4gICAgY29uc3QgaXNJbWFnZVVybCA9IChlZGl0b3IsIHVybCkgPT4ge1xuICAgICAgcmV0dXJuIGlzQWJzb2x1dGVVcmwodXJsKSAmJiBleGlzdHMoZ2V0QWxsb3dlZEltYWdlRmlsZVR5cGVzKGVkaXRvciksIHR5cGUgPT4gZW5kc1dpdGgodXJsLnRvTG93ZXJDYXNlKCksIGAuJHsgdHlwZS50b0xvd2VyQ2FzZSgpIH1gKSk7XG4gICAgfTtcbiAgICBjb25zdCBjcmVhdGVJbWFnZSA9IChlZGl0b3IsIHVybCwgcGFzdGVIdG1sRm4pID0+IHtcbiAgICAgIGVkaXRvci51bmRvTWFuYWdlci5leHRyYSgoKSA9PiB7XG4gICAgICAgIHBhc3RlSHRtbEZuKGVkaXRvciwgdXJsKTtcbiAgICAgIH0sICgpID0+IHtcbiAgICAgICAgZWRpdG9yLmluc2VydENvbnRlbnQoJzxpbWcgc3JjPVwiJyArIHVybCArICdcIj4nKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBjb25zdCBjcmVhdGVMaW5rID0gKGVkaXRvciwgdXJsLCBwYXN0ZUh0bWxGbikgPT4ge1xuICAgICAgZWRpdG9yLnVuZG9NYW5hZ2VyLmV4dHJhKCgpID0+IHtcbiAgICAgICAgcGFzdGVIdG1sRm4oZWRpdG9yLCB1cmwpO1xuICAgICAgfSwgKCkgPT4ge1xuICAgICAgICBlZGl0b3IuZXhlY0NvbW1hbmQoJ21jZUluc2VydExpbmsnLCBmYWxzZSwgdXJsKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBjb25zdCBsaW5rU2VsZWN0aW9uID0gKGVkaXRvciwgaHRtbCwgcGFzdGVIdG1sRm4pID0+ICFlZGl0b3Iuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgJiYgaXNBYnNvbHV0ZVVybChodG1sKSA/IGNyZWF0ZUxpbmsoZWRpdG9yLCBodG1sLCBwYXN0ZUh0bWxGbikgOiBmYWxzZTtcbiAgICBjb25zdCBpbnNlcnRJbWFnZSA9IChlZGl0b3IsIGh0bWwsIHBhc3RlSHRtbEZuKSA9PiBpc0ltYWdlVXJsKGVkaXRvciwgaHRtbCkgPyBjcmVhdGVJbWFnZShlZGl0b3IsIGh0bWwsIHBhc3RlSHRtbEZuKSA6IGZhbHNlO1xuICAgIGNvbnN0IHNtYXJ0SW5zZXJ0Q29udGVudCA9IChlZGl0b3IsIGh0bWwpID0+IHtcbiAgICAgIFRvb2xzLmVhY2goW1xuICAgICAgICBsaW5rU2VsZWN0aW9uLFxuICAgICAgICBpbnNlcnRJbWFnZSxcbiAgICAgICAgcGFzdGVIdG1sJDFcbiAgICAgIF0sIGFjdGlvbiA9PiB7XG4gICAgICAgIHJldHVybiBhY3Rpb24oZWRpdG9yLCBodG1sLCBwYXN0ZUh0bWwkMSkgIT09IHRydWU7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGluc2VydENvbnRlbnQgPSAoZWRpdG9yLCBodG1sLCBwYXN0ZUFzVGV4dCkgPT4ge1xuICAgICAgaWYgKHBhc3RlQXNUZXh0IHx8ICFpc1NtYXJ0UGFzdGVFbmFibGVkKGVkaXRvcikpIHtcbiAgICAgICAgcGFzdGVIdG1sJDEoZWRpdG9yLCBodG1sKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNtYXJ0SW5zZXJ0Q29udGVudChlZGl0b3IsIGh0bWwpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCB1bmlxdWVJZCA9IGNyZWF0ZUlkR2VuZXJhdG9yKCdtY2VjbGlwJyk7XG4gICAgY29uc3QgZG9QYXN0ZSA9IChlZGl0b3IsIGNvbnRlbnQsIGludGVybmFsLCBwYXN0ZUFzVGV4dCkgPT4ge1xuICAgICAgY29uc3QgYXJncyA9IHByb2Nlc3MoZWRpdG9yLCBjb250ZW50LCBpbnRlcm5hbCk7XG4gICAgICBpZiAoYXJncy5jYW5jZWxsZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIGluc2VydENvbnRlbnQoZWRpdG9yLCBhcmdzLmNvbnRlbnQsIHBhc3RlQXNUZXh0KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHBhc3RlSHRtbCA9IChlZGl0b3IsIGh0bWwsIGludGVybmFsRmxhZykgPT4ge1xuICAgICAgY29uc3QgaW50ZXJuYWwgPSBpbnRlcm5hbEZsYWcgPyBpbnRlcm5hbEZsYWcgOiBpc01hcmtlZChodG1sKTtcbiAgICAgIGRvUGFzdGUoZWRpdG9yLCB1bm1hcmsoaHRtbCksIGludGVybmFsLCBmYWxzZSk7XG4gICAgfTtcbiAgICBjb25zdCBwYXN0ZVRleHQgPSAoZWRpdG9yLCB0ZXh0KSA9PiB7XG4gICAgICBjb25zdCBlbmNvZGVkVGV4dCA9IGVkaXRvci5kb20uZW5jb2RlKHRleHQpLnJlcGxhY2UoL1xcclxcbi9nLCAnXFxuJyk7XG4gICAgICBjb25zdCBub3JtYWxpemVkVGV4dCA9IG5vcm1hbGl6ZSQ0KGVuY29kZWRUZXh0LCBnZXRQYXN0ZVRhYlNwYWNlcyhlZGl0b3IpKTtcbiAgICAgIGNvbnN0IGh0bWwgPSB0b0Jsb2NrRWxlbWVudHMobm9ybWFsaXplZFRleHQsIGdldEZvcmNlZFJvb3RCbG9jayhlZGl0b3IpLCBnZXRGb3JjZWRSb290QmxvY2tBdHRycyhlZGl0b3IpKTtcbiAgICAgIGRvUGFzdGUoZWRpdG9yLCBodG1sLCBmYWxzZSwgdHJ1ZSk7XG4gICAgfTtcbiAgICBjb25zdCBnZXREYXRhVHJhbnNmZXJJdGVtcyA9IGRhdGFUcmFuc2ZlciA9PiB7XG4gICAgICBjb25zdCBpdGVtcyA9IHt9O1xuICAgICAgaWYgKGRhdGFUcmFuc2ZlciAmJiBkYXRhVHJhbnNmZXIudHlwZXMpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhVHJhbnNmZXIudHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IGRhdGFUcmFuc2Zlci50eXBlc1tpXTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaXRlbXNbY29udGVudFR5cGVdID0gZGF0YVRyYW5zZmVyLmdldERhdGEoY29udGVudFR5cGUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICBpdGVtc1tjb250ZW50VHlwZV0gPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpdGVtcztcbiAgICB9O1xuICAgIGNvbnN0IGhhc0NvbnRlbnRUeXBlID0gKGNsaXBib2FyZENvbnRlbnQsIG1pbWVUeXBlKSA9PiBtaW1lVHlwZSBpbiBjbGlwYm9hcmRDb250ZW50ICYmIGNsaXBib2FyZENvbnRlbnRbbWltZVR5cGVdLmxlbmd0aCA+IDA7XG4gICAgY29uc3QgaGFzSHRtbE9yVGV4dCA9IGNvbnRlbnQgPT4gaGFzQ29udGVudFR5cGUoY29udGVudCwgJ3RleHQvaHRtbCcpIHx8IGhhc0NvbnRlbnRUeXBlKGNvbnRlbnQsICd0ZXh0L3BsYWluJyk7XG4gICAgY29uc3QgZXh0cmFjdEZpbGVuYW1lID0gKGVkaXRvciwgc3RyKSA9PiB7XG4gICAgICBjb25zdCBtID0gc3RyLm1hdGNoKC8oW1xcc1xcU10rPykoPzpcXC5bYS16MC05Ll0rKSQvaSk7XG4gICAgICByZXR1cm4gaXNOb25OdWxsYWJsZShtKSA/IGVkaXRvci5kb20uZW5jb2RlKG1bMV0pIDogbnVsbDtcbiAgICB9O1xuICAgIGNvbnN0IGNyZWF0ZUJsb2JJbmZvID0gKGVkaXRvciwgYmxvYkNhY2hlLCBmaWxlLCBiYXNlNjQpID0+IHtcbiAgICAgIGNvbnN0IGlkID0gdW5pcXVlSWQoKTtcbiAgICAgIGNvbnN0IHVzZUZpbGVOYW1lID0gc2hvdWxkUmV1c2VGaWxlTmFtZShlZGl0b3IpICYmIGlzTm9uTnVsbGFibGUoZmlsZS5uYW1lKTtcbiAgICAgIGNvbnN0IG5hbWUgPSB1c2VGaWxlTmFtZSA/IGV4dHJhY3RGaWxlbmFtZShlZGl0b3IsIGZpbGUubmFtZSkgOiBpZDtcbiAgICAgIGNvbnN0IGZpbGVuYW1lID0gdXNlRmlsZU5hbWUgPyBmaWxlLm5hbWUgOiB1bmRlZmluZWQ7XG4gICAgICBjb25zdCBibG9iSW5mbyA9IGJsb2JDYWNoZS5jcmVhdGUoaWQsIGZpbGUsIGJhc2U2NCwgbmFtZSwgZmlsZW5hbWUpO1xuICAgICAgYmxvYkNhY2hlLmFkZChibG9iSW5mbyk7XG4gICAgICByZXR1cm4gYmxvYkluZm87XG4gICAgfTtcbiAgICBjb25zdCBwYXN0ZUltYWdlID0gKGVkaXRvciwgaW1hZ2VJdGVtKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRhdGE6IGJhc2U2NCxcbiAgICAgICAgdHlwZVxuICAgICAgfSA9IHBhcnNlRGF0YVVyaSQxKGltYWdlSXRlbS51cmkpO1xuICAgICAgY29uc3QgZmlsZSA9IGltYWdlSXRlbS5maWxlO1xuICAgICAgY29uc3QgYmxvYkNhY2hlID0gZWRpdG9yLmVkaXRvclVwbG9hZC5ibG9iQ2FjaGU7XG4gICAgICBjb25zdCBleGlzdGluZ0Jsb2JJbmZvID0gYmxvYkNhY2hlLmdldEJ5RGF0YShiYXNlNjQsIHR5cGUpO1xuICAgICAgY29uc3QgYmxvYkluZm8gPSBleGlzdGluZ0Jsb2JJbmZvICE9PSBudWxsICYmIGV4aXN0aW5nQmxvYkluZm8gIT09IHZvaWQgMCA/IGV4aXN0aW5nQmxvYkluZm8gOiBjcmVhdGVCbG9iSW5mbyhlZGl0b3IsIGJsb2JDYWNoZSwgZmlsZSwgYmFzZTY0KTtcbiAgICAgIHBhc3RlSHRtbChlZGl0b3IsIGA8aW1nIHNyYz1cIiR7IGJsb2JJbmZvLmJsb2JVcmkoKSB9XCI+YCwgZmFsc2UpO1xuICAgIH07XG4gICAgY29uc3QgaXNDbGlwYm9hcmRFdmVudCA9IGV2ZW50ID0+IGV2ZW50LnR5cGUgPT09ICdwYXN0ZSc7XG4gICAgY29uc3QgcmVhZEZpbGVzQXNEYXRhVXJpcyA9IGl0ZW1zID0+IFByb21pc2UuYWxsKG1hcCQzKGl0ZW1zLCBmaWxlID0+IHtcbiAgICAgIHJldHVybiBibG9iVG9EYXRhVXJpKGZpbGUpLnRoZW4odXJpID0+ICh7XG4gICAgICAgIGZpbGUsXG4gICAgICAgIHVyaVxuICAgICAgfSkpO1xuICAgIH0pKTtcbiAgICBjb25zdCBpc0ltYWdlID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IGFsbG93ZWRFeHRlbnNpb25zID0gZ2V0QWxsb3dlZEltYWdlRmlsZVR5cGVzKGVkaXRvcik7XG4gICAgICByZXR1cm4gZmlsZSA9PiBzdGFydHNXaXRoKGZpbGUudHlwZSwgJ2ltYWdlLycpICYmIGV4aXN0cyhhbGxvd2VkRXh0ZW5zaW9ucywgZXh0ZW5zaW9uID0+IHtcbiAgICAgICAgcmV0dXJuIGdldEltYWdlTWltZVR5cGUoZXh0ZW5zaW9uKSA9PT0gZmlsZS50eXBlO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBnZXRJbWFnZXNGcm9tRGF0YVRyYW5zZmVyID0gKGVkaXRvciwgZGF0YVRyYW5zZmVyKSA9PiB7XG4gICAgICBjb25zdCBpdGVtcyA9IGRhdGFUcmFuc2Zlci5pdGVtcyA/IGJpbmQkMyhmcm9tKGRhdGFUcmFuc2Zlci5pdGVtcyksIGl0ZW0gPT4ge1xuICAgICAgICByZXR1cm4gaXRlbS5raW5kID09PSAnZmlsZScgPyBbaXRlbS5nZXRBc0ZpbGUoKV0gOiBbXTtcbiAgICAgIH0pIDogW107XG4gICAgICBjb25zdCBmaWxlcyA9IGRhdGFUcmFuc2Zlci5maWxlcyA/IGZyb20oZGF0YVRyYW5zZmVyLmZpbGVzKSA6IFtdO1xuICAgICAgcmV0dXJuIGZpbHRlciQ2KGl0ZW1zLmxlbmd0aCA+IDAgPyBpdGVtcyA6IGZpbGVzLCBpc0ltYWdlKGVkaXRvcikpO1xuICAgIH07XG4gICAgY29uc3QgcGFzdGVJbWFnZURhdGEgPSAoZWRpdG9yLCBlLCBybmcpID0+IHtcbiAgICAgIGNvbnN0IGRhdGFUcmFuc2ZlciA9IGlzQ2xpcGJvYXJkRXZlbnQoZSkgPyBlLmNsaXBib2FyZERhdGEgOiBlLmRhdGFUcmFuc2ZlcjtcbiAgICAgIGlmIChzaG91bGRQYXN0ZURhdGFJbWFnZXMoZWRpdG9yKSAmJiBkYXRhVHJhbnNmZXIpIHtcbiAgICAgICAgY29uc3QgaW1hZ2VzID0gZ2V0SW1hZ2VzRnJvbURhdGFUcmFuc2ZlcihlZGl0b3IsIGRhdGFUcmFuc2Zlcik7XG4gICAgICAgIGlmIChpbWFnZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICByZWFkRmlsZXNBc0RhdGFVcmlzKGltYWdlcykudGhlbihmaWxlUmVzdWx0cyA9PiB7XG4gICAgICAgICAgICBpZiAocm5nKSB7XG4gICAgICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2V0Um5nKHJuZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlYWNoJGcoZmlsZVJlc3VsdHMsIHJlc3VsdCA9PiB7XG4gICAgICAgICAgICAgIHBhc3RlSW1hZ2UoZWRpdG9yLCByZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIGNvbnN0IGlzQnJva2VuQW5kcm9pZENsaXBib2FyZEV2ZW50ID0gZSA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgcmV0dXJuIEVudi5vcy5pc0FuZHJvaWQoKSAmJiAoKF9iID0gKF9hID0gZS5jbGlwYm9hcmREYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXRlbXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5sZW5ndGgpID09PSAwO1xuICAgIH07XG4gICAgY29uc3QgaXNLZXlib2FyZFBhc3RlRXZlbnQgPSBlID0+IFZLLm1ldGFLZXlQcmVzc2VkKGUpICYmIGUua2V5Q29kZSA9PT0gODYgfHwgZS5zaGlmdEtleSAmJiBlLmtleUNvZGUgPT09IDQ1O1xuICAgIGNvbnN0IGluc2VydENsaXBib2FyZENvbnRlbnQgPSAoZWRpdG9yLCBjbGlwYm9hcmRDb250ZW50LCBodG1sLCBwbGFpblRleHRNb2RlKSA9PiB7XG4gICAgICBsZXQgY29udGVudCA9IHRyaW1IdG1sKGh0bWwpO1xuICAgICAgY29uc3QgaXNJbnRlcm5hbCA9IGhhc0NvbnRlbnRUeXBlKGNsaXBib2FyZENvbnRlbnQsIGludGVybmFsSHRtbE1pbWUoKSkgfHwgaXNNYXJrZWQoaHRtbCk7XG4gICAgICBjb25zdCBpc1BsYWluVGV4dEh0bWwgPSAhaXNJbnRlcm5hbCAmJiBpc1BsYWluVGV4dChjb250ZW50KTtcbiAgICAgIGNvbnN0IGlzQWJzb2x1dGVVcmwkMSA9IGlzQWJzb2x1dGVVcmwoY29udGVudCk7XG4gICAgICBpZiAoaXNEZWZhdWx0UGFzdGVCaW5Db250ZW50KGNvbnRlbnQpIHx8ICFjb250ZW50Lmxlbmd0aCB8fCBpc1BsYWluVGV4dEh0bWwgJiYgIWlzQWJzb2x1dGVVcmwkMSkge1xuICAgICAgICBwbGFpblRleHRNb2RlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwbGFpblRleHRNb2RlIHx8IGlzQWJzb2x1dGVVcmwkMSkge1xuICAgICAgICBpZiAoaGFzQ29udGVudFR5cGUoY2xpcGJvYXJkQ29udGVudCwgJ3RleHQvcGxhaW4nKSAmJiBpc1BsYWluVGV4dEh0bWwpIHtcbiAgICAgICAgICBjb250ZW50ID0gY2xpcGJvYXJkQ29udGVudFsndGV4dC9wbGFpbiddO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRlbnQgPSBpbm5lclRleHQoY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZmF1bHRQYXN0ZUJpbkNvbnRlbnQoY29udGVudCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHBsYWluVGV4dE1vZGUpIHtcbiAgICAgICAgcGFzdGVUZXh0KGVkaXRvciwgY29udGVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXN0ZUh0bWwoZWRpdG9yLCBjb250ZW50LCBpc0ludGVybmFsKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlZ2lzdGVyRXZlbnRIYW5kbGVycyA9IChlZGl0b3IsIHBhc3RlQmluLCBwYXN0ZUZvcm1hdCkgPT4ge1xuICAgICAgbGV0IGtleWJvYXJkUGFzdGVQbGFpblRleHRTdGF0ZTtcbiAgICAgIGNvbnN0IGdldExhc3RSbmcgPSAoKSA9PiBwYXN0ZUJpbi5nZXRMYXN0Um5nKCkgfHwgZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKTtcbiAgICAgIGVkaXRvci5vbigna2V5ZG93bicsIGUgPT4ge1xuICAgICAgICBpZiAoaXNLZXlib2FyZFBhc3RlRXZlbnQoZSkgJiYgIWUuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgICBrZXlib2FyZFBhc3RlUGxhaW5UZXh0U3RhdGUgPSBlLnNoaWZ0S2V5ICYmIGUua2V5Q29kZSA9PT0gODY7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLm9uKCdwYXN0ZScsIGUgPT4ge1xuICAgICAgICBpZiAoZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSB8fCBpc0Jyb2tlbkFuZHJvaWRDbGlwYm9hcmRFdmVudChlKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwbGFpblRleHRNb2RlID0gcGFzdGVGb3JtYXQuZ2V0KCkgPT09ICd0ZXh0JyB8fCBrZXlib2FyZFBhc3RlUGxhaW5UZXh0U3RhdGU7XG4gICAgICAgIGtleWJvYXJkUGFzdGVQbGFpblRleHRTdGF0ZSA9IGZhbHNlO1xuICAgICAgICBjb25zdCBjbGlwYm9hcmRDb250ZW50ID0gZ2V0RGF0YVRyYW5zZmVySXRlbXMoZS5jbGlwYm9hcmREYXRhKTtcbiAgICAgICAgaWYgKCFoYXNIdG1sT3JUZXh0KGNsaXBib2FyZENvbnRlbnQpICYmIHBhc3RlSW1hZ2VEYXRhKGVkaXRvciwgZSwgZ2V0TGFzdFJuZygpKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzQ29udGVudFR5cGUoY2xpcGJvYXJkQ29udGVudCwgJ3RleHQvaHRtbCcpKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGluc2VydENsaXBib2FyZENvbnRlbnQoZWRpdG9yLCBjbGlwYm9hcmRDb250ZW50LCBjbGlwYm9hcmRDb250ZW50Wyd0ZXh0L2h0bWwnXSwgcGxhaW5UZXh0TW9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFzdGVCaW4uY3JlYXRlKCk7XG4gICAgICAgICAgRGVsYXkuc2V0RWRpdG9yVGltZW91dChlZGl0b3IsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGh0bWwgPSBwYXN0ZUJpbi5nZXRIdG1sKCk7XG4gICAgICAgICAgICBwYXN0ZUJpbi5yZW1vdmUoKTtcbiAgICAgICAgICAgIGluc2VydENsaXBib2FyZENvbnRlbnQoZWRpdG9yLCBjbGlwYm9hcmRDb250ZW50LCBodG1sLCBwbGFpblRleHRNb2RlKTtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCByZWdpc3RlckRhdGFJbWFnZUZpbHRlciA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBpc1dlYktpdEZha2VVcmwgPSBzcmMgPT4gc3RhcnRzV2l0aChzcmMsICd3ZWJraXQtZmFrZS11cmwnKTtcbiAgICAgIGNvbnN0IGlzRGF0YVVyaSA9IHNyYyA9PiBzdGFydHNXaXRoKHNyYywgJ2RhdGE6Jyk7XG4gICAgICBjb25zdCBpc1Bhc3RlSW5zZXJ0ID0gYXJncyA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSBhcmdzLmRhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXN0ZSkgPT09IHRydWU7XG4gICAgICB9O1xuICAgICAgZWRpdG9yLnBhcnNlci5hZGROb2RlRmlsdGVyKCdpbWcnLCAobm9kZXMsIG5hbWUsIGFyZ3MpID0+IHtcbiAgICAgICAgaWYgKCFzaG91bGRQYXN0ZURhdGFJbWFnZXMoZWRpdG9yKSAmJiBpc1Bhc3RlSW5zZXJ0KGFyZ3MpKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XG4gICAgICAgICAgICBjb25zdCBzcmMgPSBub2RlLmF0dHIoJ3NyYycpO1xuICAgICAgICAgICAgaWYgKGlzU3RyaW5nKHNyYykgJiYgIW5vZGUuYXR0cignZGF0YS1tY2Utb2JqZWN0JykgJiYgc3JjICE9PSBFbnYudHJhbnNwYXJlbnRTcmMpIHtcbiAgICAgICAgICAgICAgaWYgKGlzV2ViS2l0RmFrZVVybChzcmMpKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICghc2hvdWxkQWxsb3dIdG1sRGF0YVVybHMoZWRpdG9yKSAmJiBpc0RhdGFVcmkoc3JjKSkge1xuICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgcmVnaXN0ZXJFdmVudHNBbmRGaWx0ZXJzID0gKGVkaXRvciwgcGFzdGVCaW4sIHBhc3RlRm9ybWF0KSA9PiB7XG4gICAgICByZWdpc3RlckV2ZW50SGFuZGxlcnMoZWRpdG9yLCBwYXN0ZUJpbiwgcGFzdGVGb3JtYXQpO1xuICAgICAgcmVnaXN0ZXJEYXRhSW1hZ2VGaWx0ZXIoZWRpdG9yKTtcbiAgICB9O1xuXG4gICAgY29uc3QgdG9nZ2xlUGxhaW5UZXh0UGFzdGUgPSAoZWRpdG9yLCBwYXN0ZUZvcm1hdCkgPT4ge1xuICAgICAgaWYgKHBhc3RlRm9ybWF0LmdldCgpID09PSAndGV4dCcpIHtcbiAgICAgICAgcGFzdGVGb3JtYXQuc2V0KCdodG1sJyk7XG4gICAgICAgIGZpcmVQYXN0ZVBsYWluVGV4dFRvZ2dsZShlZGl0b3IsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhc3RlRm9ybWF0LnNldCgndGV4dCcpO1xuICAgICAgICBmaXJlUGFzdGVQbGFpblRleHRUb2dnbGUoZWRpdG9yLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGVkaXRvci5mb2N1cygpO1xuICAgIH07XG4gICAgY29uc3QgcmVnaXN0ZXIkMSA9IChlZGl0b3IsIHBhc3RlRm9ybWF0KSA9PiB7XG4gICAgICBlZGl0b3IuYWRkQ29tbWFuZCgnbWNlVG9nZ2xlUGxhaW5UZXh0UGFzdGUnLCAoKSA9PiB7XG4gICAgICAgIHRvZ2dsZVBsYWluVGV4dFBhc3RlKGVkaXRvciwgcGFzdGVGb3JtYXQpO1xuICAgICAgfSk7XG4gICAgICBlZGl0b3IuYWRkQ29tbWFuZCgnbWNlSW5zZXJ0Q2xpcGJvYXJkQ29udGVudCcsICh1aSwgdmFsdWUpID0+IHtcbiAgICAgICAgaWYgKHZhbHVlLmh0bWwpIHtcbiAgICAgICAgICBwYXN0ZUh0bWwoZWRpdG9yLCB2YWx1ZS5odG1sLCB2YWx1ZS5pbnRlcm5hbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlLnRleHQpIHtcbiAgICAgICAgICBwYXN0ZVRleHQoZWRpdG9yLCB2YWx1ZS50ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IHNldEh0bWw1Q2xpcGJvYXJkID0gKGNsaXBib2FyZERhdGEsIGh0bWwsIHRleHQpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNsaXBib2FyZERhdGEuY2xlYXJEYXRhKCk7XG4gICAgICAgIGNsaXBib2FyZERhdGEuc2V0RGF0YSgndGV4dC9odG1sJywgaHRtbCk7XG4gICAgICAgIGNsaXBib2FyZERhdGEuc2V0RGF0YSgndGV4dC9wbGFpbicsIHRleHQpO1xuICAgICAgICBjbGlwYm9hcmREYXRhLnNldERhdGEoaW50ZXJuYWxIdG1sTWltZSgpLCBodG1sKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHNldENsaXBib2FyZERhdGEgPSAoZXZ0LCBkYXRhLCBmYWxsYmFjaywgZG9uZSkgPT4ge1xuICAgICAgaWYgKHNldEh0bWw1Q2xpcGJvYXJkKGV2dC5jbGlwYm9hcmREYXRhLCBkYXRhLmh0bWwsIGRhdGEudGV4dCkpIHtcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZhbGxiYWNrKGRhdGEuaHRtbCwgZG9uZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBmYWxsYmFjayA9IGVkaXRvciA9PiAoaHRtbCwgZG9uZSkgPT4ge1xuICAgICAgY29uc3Qge2RvbSwgc2VsZWN0aW9ufSA9IGVkaXRvcjtcbiAgICAgIGNvbnN0IG91dGVyID0gZG9tLmNyZWF0ZSgnZGl2Jywge1xuICAgICAgICAnY29udGVudGVkaXRhYmxlJzogJ2ZhbHNlJyxcbiAgICAgICAgJ2RhdGEtbWNlLWJvZ3VzJzogJ2FsbCdcbiAgICAgIH0pO1xuICAgICAgY29uc3QgaW5uZXIgPSBkb20uY3JlYXRlKCdkaXYnLCB7IGNvbnRlbnRlZGl0YWJsZTogJ3RydWUnIH0sIGh0bWwpO1xuICAgICAgZG9tLnNldFN0eWxlcyhvdXRlciwge1xuICAgICAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICAgICAgdG9wOiAnMCcsXG4gICAgICAgIGxlZnQ6ICctMzAwMHB4JyxcbiAgICAgICAgd2lkdGg6ICcxMDAwcHgnLFxuICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbidcbiAgICAgIH0pO1xuICAgICAgb3V0ZXIuYXBwZW5kQ2hpbGQoaW5uZXIpO1xuICAgICAgZG9tLmFkZChlZGl0b3IuZ2V0Qm9keSgpLCBvdXRlcik7XG4gICAgICBjb25zdCByYW5nZSA9IHNlbGVjdGlvbi5nZXRSbmcoKTtcbiAgICAgIGlubmVyLmZvY3VzKCk7XG4gICAgICBjb25zdCBvZmZzY3JlZW5SYW5nZSA9IGRvbS5jcmVhdGVSbmcoKTtcbiAgICAgIG9mZnNjcmVlblJhbmdlLnNlbGVjdE5vZGVDb250ZW50cyhpbm5lcik7XG4gICAgICBzZWxlY3Rpb24uc2V0Um5nKG9mZnNjcmVlblJhbmdlKTtcbiAgICAgIERlbGF5LnNldEVkaXRvclRpbWVvdXQoZWRpdG9yLCAoKSA9PiB7XG4gICAgICAgIHNlbGVjdGlvbi5zZXRSbmcocmFuZ2UpO1xuICAgICAgICBkb20ucmVtb3ZlKG91dGVyKTtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSwgMCk7XG4gICAgfTtcbiAgICBjb25zdCBnZXREYXRhID0gZWRpdG9yID0+ICh7XG4gICAgICBodG1sOiBtYXJrKGVkaXRvci5zZWxlY3Rpb24uZ2V0Q29udGVudCh7IGNvbnRleHR1YWw6IHRydWUgfSkpLFxuICAgICAgdGV4dDogZWRpdG9yLnNlbGVjdGlvbi5nZXRDb250ZW50KHsgZm9ybWF0OiAndGV4dCcgfSlcbiAgICB9KTtcbiAgICBjb25zdCBpc1RhYmxlU2VsZWN0aW9uID0gZWRpdG9yID0+ICEhZWRpdG9yLmRvbS5nZXRQYXJlbnQoZWRpdG9yLnNlbGVjdGlvbi5nZXRTdGFydCgpLCAndGRbZGF0YS1tY2Utc2VsZWN0ZWRdLHRoW2RhdGEtbWNlLXNlbGVjdGVkXScsIGVkaXRvci5nZXRCb2R5KCkpO1xuICAgIGNvbnN0IGhhc1NlbGVjdGVkQ29udGVudCA9IGVkaXRvciA9PiAhZWRpdG9yLnNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpIHx8IGlzVGFibGVTZWxlY3Rpb24oZWRpdG9yKTtcbiAgICBjb25zdCBjdXQgPSBlZGl0b3IgPT4gZXZ0ID0+IHtcbiAgICAgIGlmICghZXZ0LmlzRGVmYXVsdFByZXZlbnRlZCgpICYmIGhhc1NlbGVjdGVkQ29udGVudChlZGl0b3IpKSB7XG4gICAgICAgIHNldENsaXBib2FyZERhdGEoZXZ0LCBnZXREYXRhKGVkaXRvciksIGZhbGxiYWNrKGVkaXRvciksICgpID0+IHtcbiAgICAgICAgICBpZiAoRW52LmJyb3dzZXIuaXNDaHJvbWl1bSgpIHx8IEVudi5icm93c2VyLmlzRmlyZWZveCgpKSB7XG4gICAgICAgICAgICBjb25zdCBybmcgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpO1xuICAgICAgICAgICAgRGVsYXkuc2V0RWRpdG9yVGltZW91dChlZGl0b3IsICgpID0+IHtcbiAgICAgICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZXRSbmcocm5nKTtcbiAgICAgICAgICAgICAgZWRpdG9yLmV4ZWNDb21tYW5kKCdEZWxldGUnKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlZGl0b3IuZXhlY0NvbW1hbmQoJ0RlbGV0ZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBjb3B5ID0gZWRpdG9yID0+IGV2dCA9PiB7XG4gICAgICBpZiAoIWV2dC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSAmJiBoYXNTZWxlY3RlZENvbnRlbnQoZWRpdG9yKSkge1xuICAgICAgICBzZXRDbGlwYm9hcmREYXRhKGV2dCwgZ2V0RGF0YShlZGl0b3IpLCBmYWxsYmFjayhlZGl0b3IpLCBub29wKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlZ2lzdGVyID0gZWRpdG9yID0+IHtcbiAgICAgIGVkaXRvci5vbignY3V0JywgY3V0KGVkaXRvcikpO1xuICAgICAgZWRpdG9yLm9uKCdjb3B5JywgY29weShlZGl0b3IpKTtcbiAgICB9O1xuXG4gICAgY29uc3QgZ2V0Q2FyZXRSYW5nZUZyb21FdmVudCA9IChlZGl0b3IsIGUpID0+IHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICByZXR1cm4gUmFuZ2VVdGlscy5nZXRDYXJldFJhbmdlRnJvbVBvaW50KChfYSA9IGUuY2xpZW50WCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCwgKF9iID0gZS5jbGllbnRZKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwLCBlZGl0b3IuZ2V0RG9jKCkpO1xuICAgIH07XG4gICAgY29uc3QgaXNQbGFpblRleHRGaWxlVXJsID0gY29udGVudCA9PiB7XG4gICAgICBjb25zdCBwbGFpblRleHRDb250ZW50ID0gY29udGVudFsndGV4dC9wbGFpbiddO1xuICAgICAgcmV0dXJuIHBsYWluVGV4dENvbnRlbnQgPyBwbGFpblRleHRDb250ZW50LmluZGV4T2YoJ2ZpbGU6Ly8nKSA9PT0gMCA6IGZhbHNlO1xuICAgIH07XG4gICAgY29uc3Qgc2V0Rm9jdXNlZFJhbmdlID0gKGVkaXRvciwgcm5nKSA9PiB7XG4gICAgICBlZGl0b3IuZm9jdXMoKTtcbiAgICAgIGlmIChybmcpIHtcbiAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZXRSbmcocm5nKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGhhc0ltYWdlID0gZGF0YVRyYW5zZmVyID0+IGV4aXN0cyhkYXRhVHJhbnNmZXIuZmlsZXMsIGZpbGUgPT4gL15pbWFnZVxcLy8udGVzdChmaWxlLnR5cGUpKTtcbiAgICBjb25zdCBzZXR1cCRhID0gKGVkaXRvciwgZHJhZ2dpbmdJbnRlcm5hbGx5U3RhdGUpID0+IHtcbiAgICAgIGlmIChzaG91bGRQYXN0ZUJsb2NrRHJvcChlZGl0b3IpKSB7XG4gICAgICAgIGVkaXRvci5vbignZHJhZ2VuZCBkcmFnb3ZlciBkcmFnZ2VzdHVyZSBkcmFnZHJvcCBkcm9wIGRyYWcnLCBlID0+IHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoIXNob3VsZFBhc3RlRGF0YUltYWdlcyhlZGl0b3IpKSB7XG4gICAgICAgIGVkaXRvci5vbignZHJvcCcsIGUgPT4ge1xuICAgICAgICAgIGNvbnN0IGRhdGFUcmFuc2ZlciA9IGUuZGF0YVRyYW5zZmVyO1xuICAgICAgICAgIGlmIChkYXRhVHJhbnNmZXIgJiYgaGFzSW1hZ2UoZGF0YVRyYW5zZmVyKSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBlZGl0b3Iub24oJ2Ryb3AnLCBlID0+IHtcbiAgICAgICAgaWYgKGUuaXNEZWZhdWx0UHJldmVudGVkKCkgfHwgZHJhZ2dpbmdJbnRlcm5hbGx5U3RhdGUuZ2V0KCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm5nID0gZ2V0Q2FyZXRSYW5nZUZyb21FdmVudChlZGl0b3IsIGUpO1xuICAgICAgICBpZiAoaXNOdWxsYWJsZShybmcpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRyb3BDb250ZW50ID0gZ2V0RGF0YVRyYW5zZmVySXRlbXMoZS5kYXRhVHJhbnNmZXIpO1xuICAgICAgICBjb25zdCBpbnRlcm5hbCA9IGhhc0NvbnRlbnRUeXBlKGRyb3BDb250ZW50LCBpbnRlcm5hbEh0bWxNaW1lKCkpO1xuICAgICAgICBpZiAoKCFoYXNIdG1sT3JUZXh0KGRyb3BDb250ZW50KSB8fCBpc1BsYWluVGV4dEZpbGVVcmwoZHJvcENvbnRlbnQpKSAmJiBwYXN0ZUltYWdlRGF0YShlZGl0b3IsIGUsIHJuZykpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW50ZXJuYWxDb250ZW50ID0gZHJvcENvbnRlbnRbaW50ZXJuYWxIdG1sTWltZSgpXTtcbiAgICAgICAgY29uc3QgY29udGVudCA9IGludGVybmFsQ29udGVudCB8fCBkcm9wQ29udGVudFsndGV4dC9odG1sJ10gfHwgZHJvcENvbnRlbnRbJ3RleHQvcGxhaW4nXTtcbiAgICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgRGVsYXkuc2V0RWRpdG9yVGltZW91dChlZGl0b3IsICgpID0+IHtcbiAgICAgICAgICAgIGVkaXRvci51bmRvTWFuYWdlci50cmFuc2FjdCgoKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChpbnRlcm5hbENvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICBlZGl0b3IuZXhlY0NvbW1hbmQoJ0RlbGV0ZScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHNldEZvY3VzZWRSYW5nZShlZGl0b3IsIHJuZyk7XG4gICAgICAgICAgICAgIGNvbnN0IHRyaW1tZWRDb250ZW50ID0gdHJpbUh0bWwoY29udGVudCk7XG4gICAgICAgICAgICAgIGlmIChkcm9wQ29udGVudFsndGV4dC9odG1sJ10pIHtcbiAgICAgICAgICAgICAgICBwYXN0ZUh0bWwoZWRpdG9yLCB0cmltbWVkQ29udGVudCwgaW50ZXJuYWwpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhc3RlVGV4dChlZGl0b3IsIHRyaW1tZWRDb250ZW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLm9uKCdkcmFnc3RhcnQnLCBfZSA9PiB7XG4gICAgICAgIGRyYWdnaW5nSW50ZXJuYWxseVN0YXRlLnNldCh0cnVlKTtcbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLm9uKCdkcmFnb3ZlciBkcmFnZW5kJywgZSA9PiB7XG4gICAgICAgIGlmIChzaG91bGRQYXN0ZURhdGFJbWFnZXMoZWRpdG9yKSAmJiBkcmFnZ2luZ0ludGVybmFsbHlTdGF0ZS5nZXQoKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgc2V0Rm9jdXNlZFJhbmdlKGVkaXRvciwgZ2V0Q2FyZXRSYW5nZUZyb21FdmVudChlZGl0b3IsIGUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZS50eXBlID09PSAnZHJhZ2VuZCcpIHtcbiAgICAgICAgICBkcmFnZ2luZ0ludGVybmFsbHlTdGF0ZS5zZXQoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3Qgc2V0dXAkOSA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBwcm9jZXNzRXZlbnQgPSBmID0+IGUgPT4ge1xuICAgICAgICBmKGVkaXRvciwgZSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgcHJlUHJvY2VzcyA9IGdldFBhc3RlUHJlUHJvY2VzcyhlZGl0b3IpO1xuICAgICAgaWYgKGlzRnVuY3Rpb24ocHJlUHJvY2VzcykpIHtcbiAgICAgICAgZWRpdG9yLm9uKCdQYXN0ZVByZVByb2Nlc3MnLCBwcm9jZXNzRXZlbnQocHJlUHJvY2VzcykpO1xuICAgICAgfVxuICAgICAgY29uc3QgcG9zdFByb2Nlc3MgPSBnZXRQYXN0ZVBvc3RQcm9jZXNzKGVkaXRvcik7XG4gICAgICBpZiAoaXNGdW5jdGlvbihwb3N0UHJvY2VzcykpIHtcbiAgICAgICAgZWRpdG9yLm9uKCdQYXN0ZVBvc3RQcm9jZXNzJywgcHJvY2Vzc0V2ZW50KHBvc3RQcm9jZXNzKSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGFkZFByZVByb2Nlc3NGaWx0ZXIgPSAoZWRpdG9yLCBmaWx0ZXJGdW5jKSA9PiB7XG4gICAgICBlZGl0b3Iub24oJ1Bhc3RlUHJlUHJvY2VzcycsIGUgPT4ge1xuICAgICAgICBlLmNvbnRlbnQgPSBmaWx0ZXJGdW5jKGVkaXRvciwgZS5jb250ZW50LCBlLmludGVybmFsKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgcmdiUmVnRXhwID0gL3JnYlxccypcXChcXHMqKFswLTldKylcXHMqLFxccyooWzAtOV0rKVxccyosXFxzKihbMC05XSspXFxzKlxcKS9naTtcbiAgICBjb25zdCByZ2JUb0hleCA9IHZhbHVlID0+IFRvb2xzLnRyaW0odmFsdWUpLnJlcGxhY2UocmdiUmVnRXhwLCByZ2JhVG9IZXhTdHJpbmcpLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgcmVtb3ZlV2ViS2l0U3R5bGVzID0gKGVkaXRvciwgY29udGVudCwgaW50ZXJuYWwpID0+IHtcbiAgICAgIGNvbnN0IHdlYktpdFN0eWxlc09wdGlvbiA9IGdldFBhc3RlV2Via2l0U3R5bGVzKGVkaXRvcik7XG4gICAgICBpZiAoaW50ZXJuYWwgfHwgd2ViS2l0U3R5bGVzT3B0aW9uID09PSAnYWxsJyB8fCAhc2hvdWxkUGFzdGVSZW1vdmVXZWJLaXRTdHlsZXMoZWRpdG9yKSkge1xuICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHdlYktpdFN0eWxlcyA9IHdlYktpdFN0eWxlc09wdGlvbiA/IHdlYktpdFN0eWxlc09wdGlvbi5zcGxpdCgvWywgXS8pIDogW107XG4gICAgICBpZiAod2ViS2l0U3R5bGVzICYmIHdlYktpdFN0eWxlc09wdGlvbiAhPT0gJ25vbmUnKSB7XG4gICAgICAgIGNvbnN0IGRvbSA9IGVkaXRvci5kb20sIG5vZGUgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldE5vZGUoKTtcbiAgICAgICAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZSgvKDxbXj5dKykgc3R5bGU9XCIoW15cIl0qKVwiKFtePl0qPikvZ2ksIChhbGwsIGJlZm9yZSwgdmFsdWUsIGFmdGVyKSA9PiB7XG4gICAgICAgICAgY29uc3QgaW5wdXRTdHlsZXMgPSBkb20ucGFyc2VTdHlsZShkb20uZGVjb2RlKHZhbHVlKSk7XG4gICAgICAgICAgY29uc3Qgb3V0cHV0U3R5bGVzID0ge307XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3ZWJLaXRTdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0VmFsdWUgPSBpbnB1dFN0eWxlc1t3ZWJLaXRTdHlsZXNbaV1dO1xuICAgICAgICAgICAgbGV0IGNvbXBhcmVJbnB1dCA9IGlucHV0VmFsdWU7XG4gICAgICAgICAgICBsZXQgY3VycmVudFZhbHVlID0gZG9tLmdldFN0eWxlKG5vZGUsIHdlYktpdFN0eWxlc1tpXSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoL2NvbG9yLy50ZXN0KHdlYktpdFN0eWxlc1tpXSkpIHtcbiAgICAgICAgICAgICAgY29tcGFyZUlucHV0ID0gcmdiVG9IZXgoY29tcGFyZUlucHV0KTtcbiAgICAgICAgICAgICAgY3VycmVudFZhbHVlID0gcmdiVG9IZXgoY3VycmVudFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJyZW50VmFsdWUgIT09IGNvbXBhcmVJbnB1dCkge1xuICAgICAgICAgICAgICBvdXRwdXRTdHlsZXNbd2ViS2l0U3R5bGVzW2ldXSA9IGlucHV0VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG91dHB1dFN0eWxlID0gZG9tLnNlcmlhbGl6ZVN0eWxlKG91dHB1dFN0eWxlcywgJ3NwYW4nKTtcbiAgICAgICAgICBpZiAob3V0cHV0U3R5bGUpIHtcbiAgICAgICAgICAgIHJldHVybiBiZWZvcmUgKyAnIHN0eWxlPVwiJyArIG91dHB1dFN0eWxlICsgJ1wiJyArIGFmdGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYmVmb3JlICsgYWZ0ZXI7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZSgvKDxbXj5dKykgc3R5bGU9XCIoW15cIl0qKVwiKFtePl0qPikvZ2ksICckMSQzJyk7XG4gICAgICB9XG4gICAgICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKC8oPFtePl0rKSBkYXRhLW1jZS1zdHlsZT1cIihbXlwiXSspXCIoW14+XSo+KS9naSwgKGFsbCwgYmVmb3JlLCB2YWx1ZSwgYWZ0ZXIpID0+IHtcbiAgICAgICAgcmV0dXJuIGJlZm9yZSArICcgc3R5bGU9XCInICsgdmFsdWUgKyAnXCInICsgYWZ0ZXI7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH07XG4gICAgY29uc3Qgc2V0dXAkOCA9IGVkaXRvciA9PiB7XG4gICAgICBpZiAoRW52LmJyb3dzZXIuaXNDaHJvbWl1bSgpIHx8IEVudi5icm93c2VyLmlzU2FmYXJpKCkpIHtcbiAgICAgICAgYWRkUHJlUHJvY2Vzc0ZpbHRlcihlZGl0b3IsIHJlbW92ZVdlYktpdFN0eWxlcyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IHNldHVwJDcgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgZHJhZ2dpbmdJbnRlcm5hbGx5U3RhdGUgPSBDZWxsKGZhbHNlKTtcbiAgICAgIGNvbnN0IHBhc3RlRm9ybWF0ID0gQ2VsbChpc1Bhc3RlQXNUZXh0RW5hYmxlZChlZGl0b3IpID8gJ3RleHQnIDogJ2h0bWwnKTtcbiAgICAgIGNvbnN0IHBhc3RlQmluID0gUGFzdGVCaW4oZWRpdG9yKTtcbiAgICAgIHNldHVwJDgoZWRpdG9yKTtcbiAgICAgIHJlZ2lzdGVyJDEoZWRpdG9yLCBwYXN0ZUZvcm1hdCk7XG4gICAgICBzZXR1cCQ5KGVkaXRvcik7XG4gICAgICBlZGl0b3Iub24oJ1ByZUluaXQnLCAoKSA9PiB7XG4gICAgICAgIHJlZ2lzdGVyKGVkaXRvcik7XG4gICAgICAgIHNldHVwJGEoZWRpdG9yLCBkcmFnZ2luZ0ludGVybmFsbHlTdGF0ZSk7XG4gICAgICAgIHJlZ2lzdGVyRXZlbnRzQW5kRmlsdGVycyhlZGl0b3IsIHBhc3RlQmluLCBwYXN0ZUZvcm1hdCk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3QgcHJldmVudFN1bW1hcnlUb2dnbGUgPSBlZGl0b3IgPT4ge1xuICAgICAgZWRpdG9yLm9uKCdjbGljaycsIGUgPT4ge1xuICAgICAgICBpZiAoZWRpdG9yLmRvbS5nZXRQYXJlbnQoZS50YXJnZXQsICdkZXRhaWxzJykpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgZmlsdGVyRGV0YWlscyA9IGVkaXRvciA9PiB7XG4gICAgICBlZGl0b3IucGFyc2VyLmFkZE5vZGVGaWx0ZXIoJ2RldGFpbHMnLCBlbG1zID0+IHtcbiAgICAgICAgZWFjaCRnKGVsbXMsIGRldGFpbHMgPT4ge1xuICAgICAgICAgIGRldGFpbHMuYXR0cignZGF0YS1tY2Utb3BlbicsIGRldGFpbHMuYXR0cignb3BlbicpKTtcbiAgICAgICAgICBkZXRhaWxzLmF0dHIoJ29wZW4nLCAnb3BlbicpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLnNlcmlhbGl6ZXIuYWRkTm9kZUZpbHRlcignZGV0YWlscycsIGVsbXMgPT4ge1xuICAgICAgICBlYWNoJGcoZWxtcywgZGV0YWlscyA9PiB7XG4gICAgICAgICAgY29uc3Qgb3BlbiA9IGRldGFpbHMuYXR0cignZGF0YS1tY2Utb3BlbicpO1xuICAgICAgICAgIGRldGFpbHMuYXR0cignb3BlbicsIGlzU3RyaW5nKG9wZW4pID8gb3BlbiA6IG51bGwpO1xuICAgICAgICAgIGRldGFpbHMuYXR0cignZGF0YS1tY2Utb3BlbicsIG51bGwpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3Qgc2V0dXAkNiA9IGVkaXRvciA9PiB7XG4gICAgICBwcmV2ZW50U3VtbWFyeVRvZ2dsZShlZGl0b3IpO1xuICAgICAgZmlsdGVyRGV0YWlscyhlZGl0b3IpO1xuICAgIH07XG5cbiAgICBjb25zdCBpc1RleHRCbG9ja05vZGUgPSBub2RlID0+IGlzRWxlbWVudCQ2KG5vZGUpICYmIGlzVGV4dEJsb2NrJDIoU3VnYXJFbGVtZW50LmZyb21Eb20obm9kZSkpO1xuICAgIGNvbnN0IG5vcm1hbGl6ZVNlbGVjdGlvbiA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBybmcgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpO1xuICAgICAgY29uc3Qgc3RhcnRQb3MgPSBDYXJldFBvc2l0aW9uLmZyb21SYW5nZVN0YXJ0KHJuZyk7XG4gICAgICBjb25zdCBlbmRQb3MgPSBDYXJldFBvc2l0aW9uLmZyb21SYW5nZUVuZChybmcpO1xuICAgICAgaWYgKENhcmV0UG9zaXRpb24uaXNFbGVtZW50UG9zaXRpb24oc3RhcnRQb3MpKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHN0YXJ0UG9zLmNvbnRhaW5lcigpO1xuICAgICAgICBpZiAoaXNUZXh0QmxvY2tOb2RlKGNvbnRhaW5lcikpIHtcbiAgICAgICAgICBmaXJzdFBvc2l0aW9uSW4oY29udGFpbmVyKS5lYWNoKHBvcyA9PiBybmcuc2V0U3RhcnQocG9zLmNvbnRhaW5lcigpLCBwb3Mub2Zmc2V0KCkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKENhcmV0UG9zaXRpb24uaXNFbGVtZW50UG9zaXRpb24oZW5kUG9zKSkge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSBzdGFydFBvcy5jb250YWluZXIoKTtcbiAgICAgICAgaWYgKGlzVGV4dEJsb2NrTm9kZShjb250YWluZXIpKSB7XG4gICAgICAgICAgbGFzdFBvc2l0aW9uSW4oY29udGFpbmVyKS5lYWNoKHBvcyA9PiBybmcuc2V0RW5kKHBvcy5jb250YWluZXIoKSwgcG9zLm9mZnNldCgpKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2V0Um5nKG5vcm1hbGl6ZShybmcpKTtcbiAgICB9O1xuICAgIGNvbnN0IHNldHVwJDUgPSBlZGl0b3IgPT4ge1xuICAgICAgZWRpdG9yLm9uKCdjbGljaycsIGUgPT4ge1xuICAgICAgICBpZiAoZS5kZXRhaWwgPj0gMykge1xuICAgICAgICAgIG5vcm1hbGl6ZVNlbGVjdGlvbihlZGl0b3IpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIEZha2VDYXJldFBvc2l0aW9uO1xuICAgIChmdW5jdGlvbiAoRmFrZUNhcmV0UG9zaXRpb24pIHtcbiAgICAgIEZha2VDYXJldFBvc2l0aW9uWydCZWZvcmUnXSA9ICdiZWZvcmUnO1xuICAgICAgRmFrZUNhcmV0UG9zaXRpb25bJ0FmdGVyJ10gPSAnYWZ0ZXInO1xuICAgIH0oRmFrZUNhcmV0UG9zaXRpb24gfHwgKEZha2VDYXJldFBvc2l0aW9uID0ge30pKSk7XG4gICAgY29uc3QgZGlzdGFuY2VUb1JlY3RMZWZ0ID0gKGNsaWVudFJlY3QsIGNsaWVudFgpID0+IE1hdGguYWJzKGNsaWVudFJlY3QubGVmdCAtIGNsaWVudFgpO1xuICAgIGNvbnN0IGRpc3RhbmNlVG9SZWN0UmlnaHQgPSAoY2xpZW50UmVjdCwgY2xpZW50WCkgPT4gTWF0aC5hYnMoY2xpZW50UmVjdC5yaWdodCAtIGNsaWVudFgpO1xuICAgIGNvbnN0IGlzSW5zaWRlWSA9IChjbGllbnRZLCBjbGllbnRSZWN0KSA9PiBjbGllbnRZID49IGNsaWVudFJlY3QudG9wICYmIGNsaWVudFkgPD0gY2xpZW50UmVjdC5ib3R0b207XG4gICAgY29uc3QgY29sbGlkZXNZID0gKHIxLCByMikgPT4gcjEudG9wIDwgcjIuYm90dG9tICYmIHIxLmJvdHRvbSA+IHIyLnRvcDtcbiAgICBjb25zdCBpc092ZXJsYXBwaW5nID0gKHIxLCByMikgPT4ge1xuICAgICAgY29uc3Qgb3ZlcmxhcCA9IG92ZXJsYXBZKHIxLCByMikgLyBNYXRoLm1pbihyMS5oZWlnaHQsIHIyLmhlaWdodCk7XG4gICAgICByZXR1cm4gY29sbGlkZXNZKHIxLCByMikgJiYgb3ZlcmxhcCA+IDAuNTtcbiAgICB9O1xuICAgIGNvbnN0IHNwbGl0UmVjdHNQZXJBeGlzID0gKHJlY3RzLCB5KSA9PiB7XG4gICAgICBjb25zdCBpbnRlcnNlY3RpbmdSZWN0cyA9IGZpbHRlciQ2KHJlY3RzLCByZWN0ID0+IGlzSW5zaWRlWSh5LCByZWN0KSk7XG4gICAgICByZXR1cm4gYm91bmRpbmdDbGllbnRSZWN0RnJvbVJlY3RzKGludGVyc2VjdGluZ1JlY3RzKS5mb2xkKCgpID0+IFtcbiAgICAgICAgW10sXG4gICAgICAgIHJlY3RzXG4gICAgICBdLCBib3VuZGluZ1JlY3QgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcGFzczogaG9yaXpvbnRhbCxcbiAgICAgICAgICBmYWlsOiB2ZXJ0aWNhbFxuICAgICAgICB9ID0gcGFydGl0aW9uJDIocmVjdHMsIHJlY3QgPT4gaXNPdmVybGFwcGluZyhyZWN0LCBib3VuZGluZ1JlY3QpKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBob3Jpem9udGFsLFxuICAgICAgICAgIHZlcnRpY2FsXG4gICAgICAgIF07XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGNsaWVudEluZm8gPSAocmVjdCwgY2xpZW50WCkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbm9kZTogcmVjdC5ub2RlLFxuICAgICAgICBwb3NpdGlvbjogZGlzdGFuY2VUb1JlY3RMZWZ0KHJlY3QsIGNsaWVudFgpIDwgZGlzdGFuY2VUb1JlY3RSaWdodChyZWN0LCBjbGllbnRYKSA/IEZha2VDYXJldFBvc2l0aW9uLkJlZm9yZSA6IEZha2VDYXJldFBvc2l0aW9uLkFmdGVyXG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgaG9yaXpvbnRhbERpc3RhbmNlID0gKHJlY3QsIHgsIF95KSA9PiB4ID4gcmVjdC5sZWZ0ICYmIHggPCByZWN0LnJpZ2h0ID8gMCA6IE1hdGgubWluKE1hdGguYWJzKHJlY3QubGVmdCAtIHgpLCBNYXRoLmFicyhyZWN0LnJpZ2h0IC0geCkpO1xuICAgIGNvbnN0IGNsb3Nlc3RDaGlsZENhcmV0Q2FuZGlkYXRlTm9kZVJlY3QgPSAoY2hpbGRyZW4sIGNsaWVudFgsIGNsaWVudFkpID0+IHtcbiAgICAgIGNvbnN0IGNhcmV0Q2FuZGlkYXRlUmVjdCA9IHJlY3QgPT4ge1xuICAgICAgICBpZiAoaXNDYXJldENhbmRpZGF0ZSQzKHJlY3Qubm9kZSkpIHtcbiAgICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZShyZWN0KTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0VsZW1lbnQkNihyZWN0Lm5vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIGNsb3Nlc3RDaGlsZENhcmV0Q2FuZGlkYXRlTm9kZVJlY3QoZnJvbShyZWN0Lm5vZGUuY2hpbGROb2RlcyksIGNsaWVudFgsIGNsaWVudFkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBnZXRDbG9zZXN0VGV4dE5vZGUgPSAocmVjdHMsIGRpc3RhbmNlKSA9PiB7XG4gICAgICAgIGlmIChyZWN0cy5sZW5ndGggPj0gMikge1xuICAgICAgICAgIGNvbnN0IHIxID0gY2FyZXRDYW5kaWRhdGVSZWN0KHJlY3RzWzBdKS5nZXRPcihyZWN0c1swXSk7XG4gICAgICAgICAgY29uc3QgcjIgPSBjYXJldENhbmRpZGF0ZVJlY3QocmVjdHNbMV0pLmdldE9yKHJlY3RzWzFdKTtcbiAgICAgICAgICBjb25zdCBkZWx0YURpc3RhbmNlID0gTWF0aC5hYnMoZGlzdGFuY2UocjEsIGNsaWVudFgsIGNsaWVudFkpIC0gZGlzdGFuY2UocjIsIGNsaWVudFgsIGNsaWVudFkpKTtcbiAgICAgICAgICBpZiAoZGVsdGFEaXN0YW5jZSA8IDIpIHtcbiAgICAgICAgICAgIGlmIChpc1RleHQkOChyMS5ub2RlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZShyMSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzVGV4dCQ4KHIyLm5vZGUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKHIyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBmaW5kQ2xvc2VzdENhcmV0Q2FuZGlkYXRlTm9kZVJlY3QgPSAocmVjdHMsIGRpc3RhbmNlKSA9PiB7XG4gICAgICAgIGNvbnN0IHNvcnRlZFJlY3RzID0gc29ydChyZWN0cywgKHIxLCByMikgPT4gZGlzdGFuY2UocjEsIGNsaWVudFgsIGNsaWVudFkpIC0gZGlzdGFuY2UocjIsIGNsaWVudFgsIGNsaWVudFkpKTtcbiAgICAgICAgcmV0dXJuIGdldENsb3Nlc3RUZXh0Tm9kZShzb3J0ZWRSZWN0cywgZGlzdGFuY2UpLm9yVGh1bmsoKCkgPT4gZmluZE1hcChzb3J0ZWRSZWN0cywgY2FyZXRDYW5kaWRhdGVSZWN0KSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgW2hvcml6b250YWxSZWN0cywgdmVydGljYWxSZWN0c10gPSBzcGxpdFJlY3RzUGVyQXhpcyhnZXRDbGllbnRSZWN0cyhjaGlsZHJlbiksIGNsaWVudFkpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBwYXNzOiBhYm92ZSxcbiAgICAgICAgZmFpbDogYmVsb3dcbiAgICAgIH0gPSBwYXJ0aXRpb24kMih2ZXJ0aWNhbFJlY3RzLCByZWN0ID0+IHJlY3QudG9wIDwgY2xpZW50WSk7XG4gICAgICByZXR1cm4gZmluZENsb3Nlc3RDYXJldENhbmRpZGF0ZU5vZGVSZWN0KGhvcml6b250YWxSZWN0cywgaG9yaXpvbnRhbERpc3RhbmNlKS5vclRodW5rKCgpID0+IGZpbmRDbG9zZXN0Q2FyZXRDYW5kaWRhdGVOb2RlUmVjdChiZWxvdywgZGlzdGFuY2VUb1JlY3RFZGdlRnJvbVhZKSkub3JUaHVuaygoKSA9PiBmaW5kQ2xvc2VzdENhcmV0Q2FuZGlkYXRlTm9kZVJlY3QoYWJvdmUsIGRpc3RhbmNlVG9SZWN0RWRnZUZyb21YWSkpO1xuICAgIH07XG4gICAgY29uc3QgdHJhdmVyc2VVcCA9IChyb290RWxtLCBzY29wZSwgY2xpZW50WCwgY2xpZW50WSkgPT4ge1xuICAgICAgY29uc3QgaGVscGVyID0gKHNjb3BlLCBwcmV2U2NvcGUpID0+IHtcbiAgICAgICAgcmV0dXJuIHByZXZTY29wZS5mb2xkKCgpID0+IGNsb3Nlc3RDaGlsZENhcmV0Q2FuZGlkYXRlTm9kZVJlY3QoZnJvbShzY29wZS5kb20uY2hpbGROb2RlcyksIGNsaWVudFgsIGNsaWVudFkpLCBwcmV2U2NvcGUgPT4ge1xuICAgICAgICAgIGNvbnN0IHVuY2hlY2tlZENoaWxkcmVuID0gZmlsdGVyJDYoZnJvbShzY29wZS5kb20uY2hpbGROb2RlcyksIG5vZGUgPT4gbm9kZSAhPT0gcHJldlNjb3BlLmRvbSk7XG4gICAgICAgICAgcmV0dXJuIGNsb3Nlc3RDaGlsZENhcmV0Q2FuZGlkYXRlTm9kZVJlY3QodW5jaGVja2VkQ2hpbGRyZW4sIGNsaWVudFgsIGNsaWVudFkpO1xuICAgICAgICB9KS5vclRodW5rKCgpID0+IHtcbiAgICAgICAgICBjb25zdCBwYXJlbnQgPSBlcShzY29wZSwgcm9vdEVsbSkgPyBPcHRpb25hbC5ub25lKCkgOiBwYXJlbnRFbGVtZW50KHNjb3BlKTtcbiAgICAgICAgICByZXR1cm4gcGFyZW50LmJpbmQobmV3U2NvcGUgPT4gaGVscGVyKG5ld1Njb3BlLCBPcHRpb25hbC5zb21lKHNjb3BlKSkpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gaGVscGVyKHNjb3BlLCBPcHRpb25hbC5ub25lKCkpO1xuICAgIH07XG4gICAgY29uc3QgY2xvc2VzdENhcmV0Q2FuZGlkYXRlTm9kZVJlY3QgPSAocm9vdCwgY2xpZW50WCwgY2xpZW50WSkgPT4ge1xuICAgICAgY29uc3Qgcm9vdEVsbSA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKHJvb3QpO1xuICAgICAgY29uc3Qgb3duZXJEb2MgPSBkb2N1bWVudE9yT3duZXIocm9vdEVsbSk7XG4gICAgICBjb25zdCBlbGVtZW50QXRQb2ludCA9IFN1Z2FyRWxlbWVudC5mcm9tUG9pbnQob3duZXJEb2MsIGNsaWVudFgsIGNsaWVudFkpLmZpbHRlcihlbG0gPT4gY29udGFpbnMocm9vdEVsbSwgZWxtKSk7XG4gICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudEF0UG9pbnQuZ2V0T3Iocm9vdEVsbSk7XG4gICAgICByZXR1cm4gdHJhdmVyc2VVcChyb290RWxtLCBlbGVtZW50LCBjbGllbnRYLCBjbGllbnRZKTtcbiAgICB9O1xuICAgIGNvbnN0IGNsb3Nlc3RGYWtlQ2FyZXRDYW5kaWRhdGUgPSAocm9vdCwgY2xpZW50WCwgY2xpZW50WSkgPT4gY2xvc2VzdENhcmV0Q2FuZGlkYXRlTm9kZVJlY3Qocm9vdCwgY2xpZW50WCwgY2xpZW50WSkuZmlsdGVyKHJlY3QgPT4gaXNGYWtlQ2FyZXRUYXJnZXQocmVjdC5ub2RlKSkubWFwKHJlY3QgPT4gY2xpZW50SW5mbyhyZWN0LCBjbGllbnRYKSk7XG5cbiAgICBjb25zdCBnZXRBYnNvbHV0ZVBvc2l0aW9uID0gZWxtID0+IHtcbiAgICAgIGNvbnN0IGNsaWVudFJlY3QgPSBlbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCBkb2MgPSBlbG0ub3duZXJEb2N1bWVudDtcbiAgICAgIGNvbnN0IGRvY0VsZW0gPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgY29uc3Qgd2luID0gZG9jLmRlZmF1bHRWaWV3O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiBjbGllbnRSZWN0LnRvcCArIHdpbi5wYWdlWU9mZnNldCAtIGRvY0VsZW0uY2xpZW50VG9wLFxuICAgICAgICBsZWZ0OiBjbGllbnRSZWN0LmxlZnQgKyB3aW4ucGFnZVhPZmZzZXQgLSBkb2NFbGVtLmNsaWVudExlZnRcbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBnZXRCb2R5UG9zaXRpb24gPSBlZGl0b3IgPT4gZWRpdG9yLmlubGluZSA/IGdldEFic29sdXRlUG9zaXRpb24oZWRpdG9yLmdldEJvZHkoKSkgOiB7XG4gICAgICBsZWZ0OiAwLFxuICAgICAgdG9wOiAwXG4gICAgfTtcbiAgICBjb25zdCBnZXRTY3JvbGxQb3NpdGlvbiA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBib2R5ID0gZWRpdG9yLmdldEJvZHkoKTtcbiAgICAgIHJldHVybiBlZGl0b3IuaW5saW5lID8ge1xuICAgICAgICBsZWZ0OiBib2R5LnNjcm9sbExlZnQsXG4gICAgICAgIHRvcDogYm9keS5zY3JvbGxUb3BcbiAgICAgIH0gOiB7XG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIHRvcDogMFxuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IGdldEJvZHlTY3JvbGwgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgYm9keSA9IGVkaXRvci5nZXRCb2R5KCksIGRvY0VsbSA9IGVkaXRvci5nZXREb2MoKS5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICBjb25zdCBpbmxpbmVTY3JvbGwgPSB7XG4gICAgICAgIGxlZnQ6IGJvZHkuc2Nyb2xsTGVmdCxcbiAgICAgICAgdG9wOiBib2R5LnNjcm9sbFRvcFxuICAgICAgfTtcbiAgICAgIGNvbnN0IGlmcmFtZVNjcm9sbCA9IHtcbiAgICAgICAgbGVmdDogYm9keS5zY3JvbGxMZWZ0IHx8IGRvY0VsbS5zY3JvbGxMZWZ0LFxuICAgICAgICB0b3A6IGJvZHkuc2Nyb2xsVG9wIHx8IGRvY0VsbS5zY3JvbGxUb3BcbiAgICAgIH07XG4gICAgICByZXR1cm4gZWRpdG9yLmlubGluZSA/IGlubGluZVNjcm9sbCA6IGlmcmFtZVNjcm9sbDtcbiAgICB9O1xuICAgIGNvbnN0IGdldE1vdXNlUG9zaXRpb24gPSAoZWRpdG9yLCBldmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LnRhcmdldC5vd25lckRvY3VtZW50ICE9PSBlZGl0b3IuZ2V0RG9jKCkpIHtcbiAgICAgICAgY29uc3QgaWZyYW1lUG9zaXRpb24gPSBnZXRBYnNvbHV0ZVBvc2l0aW9uKGVkaXRvci5nZXRDb250ZW50QXJlYUNvbnRhaW5lcigpKTtcbiAgICAgICAgY29uc3Qgc2Nyb2xsUG9zaXRpb24gPSBnZXRCb2R5U2Nyb2xsKGVkaXRvcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGVmdDogZXZlbnQucGFnZVggLSBpZnJhbWVQb3NpdGlvbi5sZWZ0ICsgc2Nyb2xsUG9zaXRpb24ubGVmdCxcbiAgICAgICAgICB0b3A6IGV2ZW50LnBhZ2VZIC0gaWZyYW1lUG9zaXRpb24udG9wICsgc2Nyb2xsUG9zaXRpb24udG9wXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiBldmVudC5wYWdlWCxcbiAgICAgICAgdG9wOiBldmVudC5wYWdlWVxuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IGNhbGN1bGF0ZVBvc2l0aW9uID0gKGJvZHlQb3NpdGlvbiwgc2Nyb2xsUG9zaXRpb24sIG1vdXNlUG9zaXRpb24pID0+ICh7XG4gICAgICBwYWdlWDogbW91c2VQb3NpdGlvbi5sZWZ0IC0gYm9keVBvc2l0aW9uLmxlZnQgKyBzY3JvbGxQb3NpdGlvbi5sZWZ0LFxuICAgICAgcGFnZVk6IG1vdXNlUG9zaXRpb24udG9wIC0gYm9keVBvc2l0aW9uLnRvcCArIHNjcm9sbFBvc2l0aW9uLnRvcFxuICAgIH0pO1xuICAgIGNvbnN0IGNhbGMgPSAoZWRpdG9yLCBldmVudCkgPT4gY2FsY3VsYXRlUG9zaXRpb24oZ2V0Qm9keVBvc2l0aW9uKGVkaXRvciksIGdldFNjcm9sbFBvc2l0aW9uKGVkaXRvciksIGdldE1vdXNlUG9zaXRpb24oZWRpdG9yLCBldmVudCkpO1xuXG4gICAgY29uc3QgaXNDb250ZW50RWRpdGFibGVGYWxzZSQxID0gaXNDb250ZW50RWRpdGFibGVGYWxzZSRhLCBpc0NvbnRlbnRFZGl0YWJsZVRydWUgPSBpc0NvbnRlbnRFZGl0YWJsZVRydWUkNDtcbiAgICBjb25zdCBpc0RyYWdnYWJsZSA9IChyb290RWxtLCBlbG0pID0+IGlzQ29udGVudEVkaXRhYmxlRmFsc2UkMShlbG0pICYmIGVsbSAhPT0gcm9vdEVsbTtcbiAgICBjb25zdCBpc1ZhbGlkRHJvcFRhcmdldCA9IChlZGl0b3IsIHRhcmdldEVsZW1lbnQsIGRyYWdFbGVtZW50KSA9PiB7XG4gICAgICBpZiAodGFyZ2V0RWxlbWVudCA9PT0gZHJhZ0VsZW1lbnQgfHwgZWRpdG9yLmRvbS5pc0NoaWxkT2YodGFyZ2V0RWxlbWVudCwgZHJhZ0VsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhaXNDb250ZW50RWRpdGFibGVGYWxzZSQxKHRhcmdldEVsZW1lbnQpO1xuICAgIH07XG4gICAgY29uc3QgY2xvbmVFbGVtZW50ID0gZWxtID0+IHtcbiAgICAgIGNvbnN0IGNsb25lRWxtID0gZWxtLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgIGNsb25lRWxtLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1tY2Utc2VsZWN0ZWQnKTtcbiAgICAgIHJldHVybiBjbG9uZUVsbTtcbiAgICB9O1xuICAgIGNvbnN0IGNyZWF0ZUdob3N0ID0gKGVkaXRvciwgZWxtLCB3aWR0aCwgaGVpZ2h0KSA9PiB7XG4gICAgICBjb25zdCBkb20gPSBlZGl0b3IuZG9tO1xuICAgICAgY29uc3QgY2xvbmVkRWxtID0gZWxtLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgIGRvbS5zZXRTdHlsZXMoY2xvbmVkRWxtLCB7XG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHRcbiAgICAgIH0pO1xuICAgICAgZG9tLnNldEF0dHJpYihjbG9uZWRFbG0sICdkYXRhLW1jZS1zZWxlY3RlZCcsIG51bGwpO1xuICAgICAgY29uc3QgZ2hvc3RFbG0gPSBkb20uY3JlYXRlKCdkaXYnLCB7XG4gICAgICAgICdjbGFzcyc6ICdtY2UtZHJhZy1jb250YWluZXInLFxuICAgICAgICAnZGF0YS1tY2UtYm9ndXMnOiAnYWxsJyxcbiAgICAgICAgJ3Vuc2VsZWN0YWJsZSc6ICdvbicsXG4gICAgICAgICdjb250ZW50ZWRpdGFibGUnOiAnZmFsc2UnXG4gICAgICB9KTtcbiAgICAgIGRvbS5zZXRTdHlsZXMoZ2hvc3RFbG0sIHtcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgIG9wYWNpdHk6IDAuNSxcbiAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgICBib3JkZXI6IDAsXG4gICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgIG1hcmdpbjogMCxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICAgfSk7XG4gICAgICBkb20uc2V0U3R5bGVzKGNsb25lZEVsbSwge1xuICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnXG4gICAgICB9KTtcbiAgICAgIGdob3N0RWxtLmFwcGVuZENoaWxkKGNsb25lZEVsbSk7XG4gICAgICByZXR1cm4gZ2hvc3RFbG07XG4gICAgfTtcbiAgICBjb25zdCBhcHBlbmRHaG9zdFRvQm9keSA9IChnaG9zdEVsbSwgYm9keUVsbSkgPT4ge1xuICAgICAgaWYgKGdob3N0RWxtLnBhcmVudE5vZGUgIT09IGJvZHlFbG0pIHtcbiAgICAgICAgYm9keUVsbS5hcHBlbmRDaGlsZChnaG9zdEVsbSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBtb3ZlR2hvc3QgPSAoZ2hvc3RFbG0sIHBvc2l0aW9uLCB3aWR0aCwgaGVpZ2h0LCBtYXhYLCBtYXhZKSA9PiB7XG4gICAgICBsZXQgb3ZlcmZsb3dYID0gMCwgb3ZlcmZsb3dZID0gMDtcbiAgICAgIGdob3N0RWxtLnN0eWxlLmxlZnQgPSBwb3NpdGlvbi5wYWdlWCArICdweCc7XG4gICAgICBnaG9zdEVsbS5zdHlsZS50b3AgPSBwb3NpdGlvbi5wYWdlWSArICdweCc7XG4gICAgICBpZiAocG9zaXRpb24ucGFnZVggKyB3aWR0aCA+IG1heFgpIHtcbiAgICAgICAgb3ZlcmZsb3dYID0gcG9zaXRpb24ucGFnZVggKyB3aWR0aCAtIG1heFg7XG4gICAgICB9XG4gICAgICBpZiAocG9zaXRpb24ucGFnZVkgKyBoZWlnaHQgPiBtYXhZKSB7XG4gICAgICAgIG92ZXJmbG93WSA9IHBvc2l0aW9uLnBhZ2VZICsgaGVpZ2h0IC0gbWF4WTtcbiAgICAgIH1cbiAgICAgIGdob3N0RWxtLnN0eWxlLndpZHRoID0gd2lkdGggLSBvdmVyZmxvd1ggKyAncHgnO1xuICAgICAgZ2hvc3RFbG0uc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0IC0gb3ZlcmZsb3dZICsgJ3B4JztcbiAgICB9O1xuICAgIGNvbnN0IHJlbW92ZUVsZW1lbnQgPSBlbG0gPT4ge1xuICAgICAgaWYgKGVsbSAmJiBlbG0ucGFyZW50Tm9kZSkge1xuICAgICAgICBlbG0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbG0pO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaXNMZWZ0TW91c2VCdXR0b25QcmVzc2VkID0gZSA9PiBlLmJ1dHRvbiA9PT0gMDtcbiAgICBjb25zdCBhcHBseVJlbFBvcyA9IChzdGF0ZSwgcG9zaXRpb24pID0+ICh7XG4gICAgICBwYWdlWDogcG9zaXRpb24ucGFnZVggLSBzdGF0ZS5yZWxYLFxuICAgICAgcGFnZVk6IHBvc2l0aW9uLnBhZ2VZICsgNVxuICAgIH0pO1xuICAgIGNvbnN0IHN0YXJ0ID0gKHN0YXRlLCBlZGl0b3IpID0+IGUgPT4ge1xuICAgICAgaWYgKGlzTGVmdE1vdXNlQnV0dG9uUHJlc3NlZChlKSkge1xuICAgICAgICBjb25zdCBjZUVsbSA9IGZpbmQkMihlZGl0b3IuZG9tLmdldFBhcmVudHMoZS50YXJnZXQpLCBvcihpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJDEsIGlzQ29udGVudEVkaXRhYmxlVHJ1ZSkpLmdldE9yKG51bGwpO1xuICAgICAgICBpZiAoaXNEcmFnZ2FibGUoZWRpdG9yLmdldEJvZHkoKSwgY2VFbG0pKSB7XG4gICAgICAgICAgY29uc3QgZWxtUG9zID0gZWRpdG9yLmRvbS5nZXRQb3MoY2VFbG0pO1xuICAgICAgICAgIGNvbnN0IGJvZHlFbG0gPSBlZGl0b3IuZ2V0Qm9keSgpO1xuICAgICAgICAgIGNvbnN0IGRvY0VsbSA9IGVkaXRvci5nZXREb2MoKS5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgICAgc3RhdGUuc2V0KHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IGNlRWxtLFxuICAgICAgICAgICAgZHJhZ2dpbmc6IGZhbHNlLFxuICAgICAgICAgICAgc2NyZWVuWDogZS5zY3JlZW5YLFxuICAgICAgICAgICAgc2NyZWVuWTogZS5zY3JlZW5ZLFxuICAgICAgICAgICAgbWF4WDogKGVkaXRvci5pbmxpbmUgPyBib2R5RWxtLnNjcm9sbFdpZHRoIDogZG9jRWxtLm9mZnNldFdpZHRoKSAtIDIsXG4gICAgICAgICAgICBtYXhZOiAoZWRpdG9yLmlubGluZSA/IGJvZHlFbG0uc2Nyb2xsSGVpZ2h0IDogZG9jRWxtLm9mZnNldEhlaWdodCkgLSAyLFxuICAgICAgICAgICAgcmVsWDogZS5wYWdlWCAtIGVsbVBvcy54LFxuICAgICAgICAgICAgcmVsWTogZS5wYWdlWSAtIGVsbVBvcy55LFxuICAgICAgICAgICAgd2lkdGg6IGNlRWxtLm9mZnNldFdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBjZUVsbS5vZmZzZXRIZWlnaHQsXG4gICAgICAgICAgICBnaG9zdDogY3JlYXRlR2hvc3QoZWRpdG9yLCBjZUVsbSwgY2VFbG0ub2Zmc2V0V2lkdGgsIGNlRWxtLm9mZnNldEhlaWdodClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgbW92ZSA9IChzdGF0ZSwgZWRpdG9yKSA9PiB7XG4gICAgICBjb25zdCB0aHJvdHRsZWRQbGFjZUNhcmV0QXQgPSBmaXJzdCQxKChjbGllbnRYLCBjbGllbnRZKSA9PiB7XG4gICAgICAgIGVkaXRvci5fc2VsZWN0aW9uT3ZlcnJpZGVzLmhpZGVGYWtlQ2FyZXQoKTtcbiAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5wbGFjZUNhcmV0QXQoY2xpZW50WCwgY2xpZW50WSk7XG4gICAgICB9LCAwKTtcbiAgICAgIGVkaXRvci5vbigncmVtb3ZlJywgdGhyb3R0bGVkUGxhY2VDYXJldEF0LmNhbmNlbCk7XG4gICAgICByZXR1cm4gZSA9PiBzdGF0ZS5vbihzdGF0ZSA9PiB7XG4gICAgICAgIGNvbnN0IG1vdmVtZW50ID0gTWF0aC5tYXgoTWF0aC5hYnMoZS5zY3JlZW5YIC0gc3RhdGUuc2NyZWVuWCksIE1hdGguYWJzKGUuc2NyZWVuWSAtIHN0YXRlLnNjcmVlblkpKTtcbiAgICAgICAgaWYgKCFzdGF0ZS5kcmFnZ2luZyAmJiBtb3ZlbWVudCA+IDEwKSB7XG4gICAgICAgICAgY29uc3QgYXJncyA9IGVkaXRvci5kaXNwYXRjaCgnZHJhZ3N0YXJ0JywgeyB0YXJnZXQ6IHN0YXRlLmVsZW1lbnQgfSk7XG4gICAgICAgICAgaWYgKGFyZ3MuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RhdGUuZHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgIGVkaXRvci5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5kcmFnZ2luZykge1xuICAgICAgICAgIGNvbnN0IHRhcmdldFBvcyA9IGFwcGx5UmVsUG9zKHN0YXRlLCBjYWxjKGVkaXRvciwgZSkpO1xuICAgICAgICAgIGFwcGVuZEdob3N0VG9Cb2R5KHN0YXRlLmdob3N0LCBlZGl0b3IuZ2V0Qm9keSgpKTtcbiAgICAgICAgICBtb3ZlR2hvc3Qoc3RhdGUuZ2hvc3QsIHRhcmdldFBvcywgc3RhdGUud2lkdGgsIHN0YXRlLmhlaWdodCwgc3RhdGUubWF4WCwgc3RhdGUubWF4WSk7XG4gICAgICAgICAgdGhyb3R0bGVkUGxhY2VDYXJldEF0LnRocm90dGxlKGUuY2xpZW50WCwgZS5jbGllbnRZKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBnZXRSYXdUYXJnZXQgPSBzZWxlY3Rpb24gPT4ge1xuICAgICAgY29uc3Qgcm5nID0gc2VsZWN0aW9uLmdldFNlbCgpLmdldFJhbmdlQXQoMCk7XG4gICAgICBjb25zdCBzdGFydENvbnRhaW5lciA9IHJuZy5zdGFydENvbnRhaW5lcjtcbiAgICAgIHJldHVybiBzdGFydENvbnRhaW5lci5ub2RlVHlwZSA9PT0gMyA/IHN0YXJ0Q29udGFpbmVyLnBhcmVudE5vZGUgOiBzdGFydENvbnRhaW5lcjtcbiAgICB9O1xuICAgIGNvbnN0IGRyb3AgPSAoc3RhdGUsIGVkaXRvcikgPT4gZSA9PiB7XG4gICAgICBzdGF0ZS5vbihzdGF0ZSA9PiB7XG4gICAgICAgIGlmIChzdGF0ZS5kcmFnZ2luZykge1xuICAgICAgICAgIGlmIChpc1ZhbGlkRHJvcFRhcmdldChlZGl0b3IsIGdldFJhd1RhcmdldChlZGl0b3Iuc2VsZWN0aW9uKSwgc3RhdGUuZWxlbWVudCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldENsb25lID0gY2xvbmVFbGVtZW50KHN0YXRlLmVsZW1lbnQpO1xuICAgICAgICAgICAgY29uc3QgYXJncyA9IGVkaXRvci5kaXNwYXRjaCgnZHJvcCcsIHtcbiAgICAgICAgICAgICAgY2xpZW50WDogZS5jbGllbnRYLFxuICAgICAgICAgICAgICBjbGllbnRZOiBlLmNsaWVudFlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFhcmdzLmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgICAgIGVkaXRvci51bmRvTWFuYWdlci50cmFuc2FjdCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlRWxlbWVudChzdGF0ZS5lbGVtZW50KTtcbiAgICAgICAgICAgICAgICBlZGl0b3IuaW5zZXJ0Q29udGVudChlZGl0b3IuZG9tLmdldE91dGVySFRNTCh0YXJnZXRDbG9uZSkpO1xuICAgICAgICAgICAgICAgIGVkaXRvci5fc2VsZWN0aW9uT3ZlcnJpZGVzLmhpZGVGYWtlQ2FyZXQoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVkaXRvci5kaXNwYXRjaCgnZHJhZ2VuZCcpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJlbW92ZURyYWdTdGF0ZShzdGF0ZSk7XG4gICAgfTtcbiAgICBjb25zdCBzdG9wID0gKHN0YXRlLCBlZGl0b3IpID0+ICgpID0+IHtcbiAgICAgIHN0YXRlLm9uKHN0YXRlID0+IHtcbiAgICAgICAgaWYgKHN0YXRlLmRyYWdnaW5nKSB7XG4gICAgICAgICAgZWRpdG9yLmRpc3BhdGNoKCdkcmFnZW5kJyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmVtb3ZlRHJhZ1N0YXRlKHN0YXRlKTtcbiAgICB9O1xuICAgIGNvbnN0IHJlbW92ZURyYWdTdGF0ZSA9IHN0YXRlID0+IHtcbiAgICAgIHN0YXRlLm9uKHN0YXRlID0+IHtcbiAgICAgICAgcmVtb3ZlRWxlbWVudChzdGF0ZS5naG9zdCk7XG4gICAgICB9KTtcbiAgICAgIHN0YXRlLmNsZWFyKCk7XG4gICAgfTtcbiAgICBjb25zdCBiaW5kRmFrZURyYWdFdmVudHMgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3Qgc3RhdGUgPSB2YWx1ZSQyKCk7XG4gICAgICBjb25zdCBwYWdlRG9tID0gRE9NVXRpbHMuRE9NO1xuICAgICAgY29uc3Qgcm9vdERvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgICBjb25zdCBkcmFnU3RhcnRIYW5kbGVyID0gc3RhcnQoc3RhdGUsIGVkaXRvcik7XG4gICAgICBjb25zdCBkcmFnSGFuZGxlciA9IG1vdmUoc3RhdGUsIGVkaXRvcik7XG4gICAgICBjb25zdCBkcm9wSGFuZGxlciA9IGRyb3Aoc3RhdGUsIGVkaXRvcik7XG4gICAgICBjb25zdCBkcmFnRW5kSGFuZGxlciA9IHN0b3Aoc3RhdGUsIGVkaXRvcik7XG4gICAgICBlZGl0b3Iub24oJ21vdXNlZG93bicsIGRyYWdTdGFydEhhbmRsZXIpO1xuICAgICAgZWRpdG9yLm9uKCdtb3VzZW1vdmUnLCBkcmFnSGFuZGxlcik7XG4gICAgICBlZGl0b3Iub24oJ21vdXNldXAnLCBkcm9wSGFuZGxlcik7XG4gICAgICBwYWdlRG9tLmJpbmQocm9vdERvY3VtZW50LCAnbW91c2Vtb3ZlJywgZHJhZ0hhbmRsZXIpO1xuICAgICAgcGFnZURvbS5iaW5kKHJvb3REb2N1bWVudCwgJ21vdXNldXAnLCBkcmFnRW5kSGFuZGxlcik7XG4gICAgICBlZGl0b3Iub24oJ3JlbW92ZScsICgpID0+IHtcbiAgICAgICAgcGFnZURvbS51bmJpbmQocm9vdERvY3VtZW50LCAnbW91c2Vtb3ZlJywgZHJhZ0hhbmRsZXIpO1xuICAgICAgICBwYWdlRG9tLnVuYmluZChyb290RG9jdW1lbnQsICdtb3VzZXVwJywgZHJhZ0VuZEhhbmRsZXIpO1xuICAgICAgfSk7XG4gICAgICBlZGl0b3Iub24oJ2tleWRvd24nLCBlID0+IHtcbiAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gVksuRVNDKSB7XG4gICAgICAgICAgZHJhZ0VuZEhhbmRsZXIoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBibG9ja1Vuc3VwcG9ydGVkRmlsZURyb3AgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgcHJldmVudEZpbGVEcm9wID0gZSA9PiB7XG4gICAgICAgIGlmICghZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICAgIGNvbnN0IGRhdGFUcmFuc2ZlciA9IGUuZGF0YVRyYW5zZmVyO1xuICAgICAgICAgIGlmIChkYXRhVHJhbnNmZXIgJiYgKGNvbnRhaW5zJDIoZGF0YVRyYW5zZmVyLnR5cGVzLCAnRmlsZXMnKSB8fCBkYXRhVHJhbnNmZXIuZmlsZXMubGVuZ3RoID4gMCkpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGlmIChlLnR5cGUgPT09ICdkcm9wJykge1xuICAgICAgICAgICAgICBkaXNwbGF5RXJyb3IoZWRpdG9yLCAnRHJvcHBlZCBmaWxlIHR5cGUgaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHByZXZlbnRGaWxlRHJvcElmVUlFbGVtZW50ID0gZSA9PiB7XG4gICAgICAgIGlmIChpc1VJRWxlbWVudChlZGl0b3IsIGUudGFyZ2V0KSkge1xuICAgICAgICAgIHByZXZlbnRGaWxlRHJvcChlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHNldHVwID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBwYWdlRG9tID0gRE9NVXRpbHMuRE9NO1xuICAgICAgICBjb25zdCBkb20gPSBlZGl0b3IuZG9tO1xuICAgICAgICBjb25zdCBkb2MgPSBkb2N1bWVudDtcbiAgICAgICAgY29uc3QgZWRpdG9yUm9vdCA9IGVkaXRvci5pbmxpbmUgPyBlZGl0b3IuZ2V0Qm9keSgpIDogZWRpdG9yLmdldERvYygpO1xuICAgICAgICBjb25zdCBldmVudE5hbWVzID0gW1xuICAgICAgICAgICdkcm9wJyxcbiAgICAgICAgICAnZHJhZ292ZXInXG4gICAgICAgIF07XG4gICAgICAgIGVhY2gkZyhldmVudE5hbWVzLCBuYW1lID0+IHtcbiAgICAgICAgICBwYWdlRG9tLmJpbmQoZG9jLCBuYW1lLCBwcmV2ZW50RmlsZURyb3BJZlVJRWxlbWVudCk7XG4gICAgICAgICAgZG9tLmJpbmQoZWRpdG9yUm9vdCwgbmFtZSwgcHJldmVudEZpbGVEcm9wKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVkaXRvci5vbigncmVtb3ZlJywgKCkgPT4ge1xuICAgICAgICAgIGVhY2gkZyhldmVudE5hbWVzLCBuYW1lID0+IHtcbiAgICAgICAgICAgIHBhZ2VEb20udW5iaW5kKGRvYywgbmFtZSwgcHJldmVudEZpbGVEcm9wSWZVSUVsZW1lbnQpO1xuICAgICAgICAgICAgZG9tLnVuYmluZChlZGl0b3JSb290LCBuYW1lLCBwcmV2ZW50RmlsZURyb3ApO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBlZGl0b3Iub24oJ2luaXQnLCAoKSA9PiB7XG4gICAgICAgIERlbGF5LnNldEVkaXRvclRpbWVvdXQoZWRpdG9yLCBzZXR1cCwgMCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGluaXQkMiA9IGVkaXRvciA9PiB7XG4gICAgICBiaW5kRmFrZURyYWdFdmVudHMoZWRpdG9yKTtcbiAgICAgIGlmIChzaG91bGRCbG9ja1Vuc3VwcG9ydGVkRHJvcChlZGl0b3IpKSB7XG4gICAgICAgIGJsb2NrVW5zdXBwb3J0ZWRGaWxlRHJvcChlZGl0b3IpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBzZXR1cCQ0ID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IHJlbmRlckZvY3VzQ2FyZXQgPSBmaXJzdCQxKCgpID0+IHtcbiAgICAgICAgaWYgKCFlZGl0b3IucmVtb3ZlZCAmJiBlZGl0b3IuZ2V0Qm9keSgpLmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICAgICAgY29uc3Qgcm5nID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKTtcbiAgICAgICAgICBpZiAocm5nLmNvbGxhcHNlZCkge1xuICAgICAgICAgICAgY29uc3QgY2FyZXRSYW5nZSA9IHJlbmRlclJhbmdlQ2FyZXQoZWRpdG9yLCBybmcsIGZhbHNlKTtcbiAgICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2V0Um5nKGNhcmV0UmFuZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgMCk7XG4gICAgICBlZGl0b3Iub24oJ2ZvY3VzJywgKCkgPT4ge1xuICAgICAgICByZW5kZXJGb2N1c0NhcmV0LnRocm90dGxlKCk7XG4gICAgICB9KTtcbiAgICAgIGVkaXRvci5vbignYmx1cicsICgpID0+IHtcbiAgICAgICAgcmVuZGVyRm9jdXNDYXJldC5jYW5jZWwoKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCBzZXR1cCQzID0gZWRpdG9yID0+IHtcbiAgICAgIGVkaXRvci5vbignaW5pdCcsICgpID0+IHtcbiAgICAgICAgZWRpdG9yLm9uKCdmb2N1c2luJywgZSA9PiB7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgICAgICAgaWYgKGlzTWVkaWEkMih0YXJnZXQpKSB7XG4gICAgICAgICAgICBjb25zdCBjZVJvb3QgPSBnZXRDb250ZW50RWRpdGFibGVSb290JDEoZWRpdG9yLmdldEJvZHkoKSwgdGFyZ2V0KTtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJGEoY2VSb290KSA/IGNlUm9vdCA6IHRhcmdldDtcbiAgICAgICAgICAgIGlmIChlZGl0b3Iuc2VsZWN0aW9uLmdldE5vZGUoKSAhPT0gbm9kZSkge1xuICAgICAgICAgICAgICBzZWxlY3ROb2RlKGVkaXRvciwgbm9kZSkuZWFjaChybmcgPT4gZWRpdG9yLnNlbGVjdGlvbi5zZXRSbmcocm5nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCBpc0NvbnRlbnRFZGl0YWJsZUZhbHNlID0gaXNDb250ZW50RWRpdGFibGVGYWxzZSRhO1xuICAgIGNvbnN0IGdldENvbnRlbnRFZGl0YWJsZVJvb3QgPSAoZWRpdG9yLCBub2RlKSA9PiBnZXRDb250ZW50RWRpdGFibGVSb290JDEoZWRpdG9yLmdldEJvZHkoKSwgbm9kZSk7XG4gICAgY29uc3QgU2VsZWN0aW9uT3ZlcnJpZGVzID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb24sIGRvbSA9IGVkaXRvci5kb207XG4gICAgICBjb25zdCBpc0Jsb2NrID0gZG9tLmlzQmxvY2s7XG4gICAgICBjb25zdCByb290Tm9kZSA9IGVkaXRvci5nZXRCb2R5KCk7XG4gICAgICBjb25zdCBmYWtlQ2FyZXQgPSBGYWtlQ2FyZXQoZWRpdG9yLCByb290Tm9kZSwgaXNCbG9jaywgKCkgPT4gaGFzRm9jdXMoZWRpdG9yKSk7XG4gICAgICBjb25zdCByZWFsU2VsZWN0aW9uSWQgPSAnc2VsLScgKyBkb20udW5pcXVlSWQoKTtcbiAgICAgIGNvbnN0IGVsZW1lbnRTZWxlY3Rpb25BdHRyID0gJ2RhdGEtbWNlLXNlbGVjdGVkJztcbiAgICAgIGxldCBzZWxlY3RlZEVsZW1lbnQ7XG4gICAgICBjb25zdCBpc0Zha2VTZWxlY3Rpb25FbGVtZW50ID0gbm9kZSA9PiBkb20uaGFzQ2xhc3Mobm9kZSwgJ21jZS1vZmZzY3JlZW4tc2VsZWN0aW9uJyk7XG4gICAgICBjb25zdCBpc0Zha2VTZWxlY3Rpb25UYXJnZXRFbGVtZW50ID0gbm9kZSA9PiBub2RlICE9PSByb290Tm9kZSAmJiAoaXNDb250ZW50RWRpdGFibGVGYWxzZShub2RlKSB8fCBpc01lZGlhJDIobm9kZSkpICYmIGRvbS5pc0NoaWxkT2Yobm9kZSwgcm9vdE5vZGUpO1xuICAgICAgY29uc3Qgc2V0UmFuZ2UgPSByYW5nZSA9PiB7XG4gICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgIHNlbGVjdGlvbi5zZXRSbmcocmFuZ2UpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3Qgc2hvd0NhcmV0ID0gKGRpcmVjdGlvbiwgbm9kZSwgYmVmb3JlLCBzY3JvbGxJbnRvVmlldyA9IHRydWUpID0+IHtcbiAgICAgICAgY29uc3QgZSA9IGVkaXRvci5kaXNwYXRjaCgnU2hvd0NhcmV0Jywge1xuICAgICAgICAgIHRhcmdldDogbm9kZSxcbiAgICAgICAgICBkaXJlY3Rpb24sXG4gICAgICAgICAgYmVmb3JlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY3JvbGxJbnRvVmlldykge1xuICAgICAgICAgIHNlbGVjdGlvbi5zY3JvbGxJbnRvVmlldyhub2RlLCBkaXJlY3Rpb24gPT09IC0xKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFrZUNhcmV0LnNob3coYmVmb3JlLCBub2RlKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBzaG93QmxvY2tDYXJldENvbnRhaW5lciA9IGJsb2NrQ2FyZXRDb250YWluZXIgPT4ge1xuICAgICAgICBpZiAoYmxvY2tDYXJldENvbnRhaW5lci5oYXNBdHRyaWJ1dGUoJ2RhdGEtbWNlLWNhcmV0JykpIHtcbiAgICAgICAgICBzaG93Q2FyZXRDb250YWluZXJCbG9jayhibG9ja0NhcmV0Q29udGFpbmVyKTtcbiAgICAgICAgICBzZWxlY3Rpb24uc2Nyb2xsSW50b1ZpZXcoYmxvY2tDYXJldENvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCByZWdpc3RlckV2ZW50cyA9ICgpID0+IHtcbiAgICAgICAgZWRpdG9yLm9uKCdjbGljaycsIGUgPT4ge1xuICAgICAgICAgIGNvbnN0IGNvbnRlbnRFZGl0YWJsZVJvb3QgPSBnZXRDb250ZW50RWRpdGFibGVSb290KGVkaXRvciwgZS50YXJnZXQpO1xuICAgICAgICAgIGlmIChjb250ZW50RWRpdGFibGVSb290KSB7XG4gICAgICAgICAgICBpZiAoaXNDb250ZW50RWRpdGFibGVGYWxzZShjb250ZW50RWRpdGFibGVSb290KSkge1xuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgIGVkaXRvci5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGVkaXRvci5vbignYmx1ciBOZXdCbG9jaycsIHJlbW92ZUVsZW1lbnRTZWxlY3Rpb24pO1xuICAgICAgICBlZGl0b3Iub24oJ1Jlc2l6ZVdpbmRvdyBGdWxsc2NyZWVuU3RhdGVDaGFuZ2VkJywgZmFrZUNhcmV0LnJlcG9zaXRpb24pO1xuICAgICAgICBlZGl0b3Iub24oJ3RhcCcsIGUgPT4ge1xuICAgICAgICAgIGNvbnN0IHRhcmdldEVsbSA9IGUudGFyZ2V0O1xuICAgICAgICAgIGNvbnN0IGNvbnRlbnRFZGl0YWJsZVJvb3QgPSBnZXRDb250ZW50RWRpdGFibGVSb290KGVkaXRvciwgdGFyZ2V0RWxtKTtcbiAgICAgICAgICBpZiAoaXNDb250ZW50RWRpdGFibGVGYWxzZShjb250ZW50RWRpdGFibGVSb290KSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgc2VsZWN0Tm9kZShlZGl0b3IsIGNvbnRlbnRFZGl0YWJsZVJvb3QpLmVhY2goc2V0RWxlbWVudFNlbGVjdGlvbik7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0Zha2VTZWxlY3Rpb25UYXJnZXRFbGVtZW50KHRhcmdldEVsbSkpIHtcbiAgICAgICAgICAgIHNlbGVjdE5vZGUoZWRpdG9yLCB0YXJnZXRFbG0pLmVhY2goc2V0RWxlbWVudFNlbGVjdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgZWRpdG9yLm9uKCdtb3VzZWRvd24nLCBlID0+IHtcbiAgICAgICAgICBjb25zdCB0YXJnZXRFbG0gPSBlLnRhcmdldDtcbiAgICAgICAgICBpZiAodGFyZ2V0RWxtICE9PSByb290Tm9kZSAmJiB0YXJnZXRFbG0ubm9kZU5hbWUgIT09ICdIVE1MJyAmJiAhZG9tLmlzQ2hpbGRPZih0YXJnZXRFbG0sIHJvb3ROb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNYWUluQ29udGVudEFyZWEoZWRpdG9yLCBlLmNsaWVudFgsIGUuY2xpZW50WSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlbW92ZUVsZW1lbnRTZWxlY3Rpb24oKTtcbiAgICAgICAgICBoaWRlRmFrZUNhcmV0KCk7XG4gICAgICAgICAgY29uc3QgY2xvc2VzdENvbnRlbnRFZGl0YWJsZSA9IGdldENvbnRlbnRFZGl0YWJsZVJvb3QoZWRpdG9yLCB0YXJnZXRFbG0pO1xuICAgICAgICAgIGlmIChpc0NvbnRlbnRFZGl0YWJsZUZhbHNlKGNsb3Nlc3RDb250ZW50RWRpdGFibGUpKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBzZWxlY3ROb2RlKGVkaXRvciwgY2xvc2VzdENvbnRlbnRFZGl0YWJsZSkuZWFjaChzZXRFbGVtZW50U2VsZWN0aW9uKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2xvc2VzdEZha2VDYXJldENhbmRpZGF0ZShyb290Tm9kZSwgZS5jbGllbnRYLCBlLmNsaWVudFkpLmVhY2goY2FyZXRJbmZvID0+IHtcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICBjb25zdCByYW5nZSA9IHNob3dDYXJldCgxLCBjYXJldEluZm8ubm9kZSwgY2FyZXRJbmZvLnBvc2l0aW9uID09PSBGYWtlQ2FyZXRQb3NpdGlvbi5CZWZvcmUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgc2V0UmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgICBpZiAoaXNFbGVtZW50JDYoY2xvc2VzdENvbnRlbnRFZGl0YWJsZSkpIHtcbiAgICAgICAgICAgICAgICBjbG9zZXN0Q29udGVudEVkaXRhYmxlLmZvY3VzKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZWRpdG9yLmdldEJvZHkoKS5mb2N1cygpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBlZGl0b3Iub24oJ2tleXByZXNzJywgZSA9PiB7XG4gICAgICAgICAgaWYgKFZLLm1vZGlmaWVyUHJlc3NlZChlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNDb250ZW50RWRpdGFibGVGYWxzZShzZWxlY3Rpb24uZ2V0Tm9kZSgpKSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGVkaXRvci5vbignR2V0U2VsZWN0aW9uUmFuZ2UnLCBlID0+IHtcbiAgICAgICAgICBsZXQgcm5nID0gZS5yYW5nZTtcbiAgICAgICAgICBpZiAoc2VsZWN0ZWRFbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoIXNlbGVjdGVkRWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgIHNlbGVjdGVkRWxlbWVudCA9IG51bGw7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJuZyA9IHJuZy5jbG9uZVJhbmdlKCk7XG4gICAgICAgICAgICBybmcuc2VsZWN0Tm9kZShzZWxlY3RlZEVsZW1lbnQpO1xuICAgICAgICAgICAgZS5yYW5nZSA9IHJuZztcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBlZGl0b3Iub24oJ1NldFNlbGVjdGlvblJhbmdlJywgZSA9PiB7XG4gICAgICAgICAgZS5yYW5nZSA9IG5vcm1hbGl6ZVZvaWRFbGVtZW50U2VsZWN0aW9uKGUucmFuZ2UpO1xuICAgICAgICAgIGNvbnN0IHJuZyA9IHNldEVsZW1lbnRTZWxlY3Rpb24oZS5yYW5nZSwgZS5mb3J3YXJkKTtcbiAgICAgICAgICBpZiAocm5nKSB7XG4gICAgICAgICAgICBlLnJhbmdlID0gcm5nO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGlzUGFzdGVCaW4gPSBub2RlID0+IG5vZGUuaWQgPT09ICdtY2VwYXN0ZWJpbic7XG4gICAgICAgIGVkaXRvci5vbignQWZ0ZXJTZXRTZWxlY3Rpb25SYW5nZScsIGUgPT4ge1xuICAgICAgICAgIGNvbnN0IHJuZyA9IGUucmFuZ2U7XG4gICAgICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IHJuZy5zdGFydENvbnRhaW5lci5wYXJlbnROb2RlO1xuICAgICAgICAgIGlmICghaXNSYW5nZUluQ2FyZXRDb250YWluZXIocm5nKSAmJiAhaXNQYXN0ZUJpbihwYXJlbnROb2RlKSkge1xuICAgICAgICAgICAgaGlkZUZha2VDYXJldCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWlzRmFrZVNlbGVjdGlvbkVsZW1lbnQocGFyZW50Tm9kZSkpIHtcbiAgICAgICAgICAgIHJlbW92ZUVsZW1lbnRTZWxlY3Rpb24oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpbml0JDIoZWRpdG9yKTtcbiAgICAgICAgc2V0dXAkNChlZGl0b3IpO1xuICAgICAgICBzZXR1cCQzKGVkaXRvcik7XG4gICAgICB9O1xuICAgICAgY29uc3QgaXNXaXRoaW5DYXJldENvbnRhaW5lciA9IG5vZGUgPT4gaXNDYXJldENvbnRhaW5lciQyKG5vZGUpIHx8IHN0YXJ0c1dpdGhDYXJldENvbnRhaW5lciQxKG5vZGUpIHx8IGVuZHNXaXRoQ2FyZXRDb250YWluZXIkMShub2RlKTtcbiAgICAgIGNvbnN0IGlzUmFuZ2VJbkNhcmV0Q29udGFpbmVyID0gcm5nID0+IGlzV2l0aGluQ2FyZXRDb250YWluZXIocm5nLnN0YXJ0Q29udGFpbmVyKSB8fCBpc1dpdGhpbkNhcmV0Q29udGFpbmVyKHJuZy5lbmRDb250YWluZXIpO1xuICAgICAgY29uc3Qgbm9ybWFsaXplVm9pZEVsZW1lbnRTZWxlY3Rpb24gPSBybmcgPT4ge1xuICAgICAgICBjb25zdCB2b2lkRWxlbWVudHMgPSBlZGl0b3Iuc2NoZW1hLmdldFZvaWRFbGVtZW50cygpO1xuICAgICAgICBjb25zdCBuZXdSbmcgPSBkb20uY3JlYXRlUm5nKCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0Q29udGFpbmVyID0gcm5nLnN0YXJ0Q29udGFpbmVyO1xuICAgICAgICBjb25zdCBzdGFydE9mZnNldCA9IHJuZy5zdGFydE9mZnNldDtcbiAgICAgICAgY29uc3QgZW5kQ29udGFpbmVyID0gcm5nLmVuZENvbnRhaW5lcjtcbiAgICAgICAgY29uc3QgZW5kT2Zmc2V0ID0gcm5nLmVuZE9mZnNldDtcbiAgICAgICAgaWYgKGhhcyQyKHZvaWRFbGVtZW50cywgc3RhcnRDb250YWluZXIubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgICBpZiAoc3RhcnRPZmZzZXQgPT09IDApIHtcbiAgICAgICAgICAgIG5ld1JuZy5zZXRTdGFydEJlZm9yZShzdGFydENvbnRhaW5lcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld1JuZy5zZXRTdGFydEFmdGVyKHN0YXJ0Q29udGFpbmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3Um5nLnNldFN0YXJ0KHN0YXJ0Q29udGFpbmVyLCBzdGFydE9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhcyQyKHZvaWRFbGVtZW50cywgZW5kQ29udGFpbmVyLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgICAgaWYgKGVuZE9mZnNldCA9PT0gMCkge1xuICAgICAgICAgICAgbmV3Um5nLnNldEVuZEJlZm9yZShlbmRDb250YWluZXIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdSbmcuc2V0RW5kQWZ0ZXIoZW5kQ29udGFpbmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3Um5nLnNldEVuZChlbmRDb250YWluZXIsIGVuZE9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1JuZztcbiAgICAgIH07XG4gICAgICBjb25zdCBzZXR1cE9mZnNjcmVlblNlbGVjdGlvbiA9IChub2RlLCB0YXJnZXRDbG9uZSkgPT4ge1xuICAgICAgICBjb25zdCBib2R5ID0gU3VnYXJFbGVtZW50LmZyb21Eb20oZWRpdG9yLmdldEJvZHkoKSk7XG4gICAgICAgIGNvbnN0IGRvYyA9IGVkaXRvci5nZXREb2MoKTtcbiAgICAgICAgY29uc3QgcmVhbFNlbGVjdGlvbkNvbnRhaW5lciA9IGRlc2NlbmRhbnQoYm9keSwgJyMnICsgcmVhbFNlbGVjdGlvbklkKS5nZXRPclRodW5rKCgpID0+IHtcbiAgICAgICAgICBjb25zdCBuZXdDb250YWluZXIgPSBTdWdhckVsZW1lbnQuZnJvbUh0bWwoJzxkaXYgZGF0YS1tY2UtYm9ndXM9XCJhbGxcIiBjbGFzcz1cIm1jZS1vZmZzY3JlZW4tc2VsZWN0aW9uXCI+PC9kaXY+JywgZG9jKTtcbiAgICAgICAgICBzZXQkMihuZXdDb250YWluZXIsICdpZCcsIHJlYWxTZWxlY3Rpb25JZCk7XG4gICAgICAgICAgYXBwZW5kJDEoYm9keSwgbmV3Q29udGFpbmVyKTtcbiAgICAgICAgICByZXR1cm4gbmV3Q29udGFpbmVyO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgbmV3UmFuZ2UgPSBkb20uY3JlYXRlUm5nKCk7XG4gICAgICAgIGVtcHR5KHJlYWxTZWxlY3Rpb25Db250YWluZXIpO1xuICAgICAgICBhcHBlbmQocmVhbFNlbGVjdGlvbkNvbnRhaW5lciwgW1xuICAgICAgICAgIFN1Z2FyRWxlbWVudC5mcm9tVGV4dChuYnNwLCBkb2MpLFxuICAgICAgICAgIFN1Z2FyRWxlbWVudC5mcm9tRG9tKHRhcmdldENsb25lKSxcbiAgICAgICAgICBTdWdhckVsZW1lbnQuZnJvbVRleHQobmJzcCwgZG9jKVxuICAgICAgICBdKTtcbiAgICAgICAgbmV3UmFuZ2Uuc2V0U3RhcnQocmVhbFNlbGVjdGlvbkNvbnRhaW5lci5kb20uZmlyc3RDaGlsZCwgMSk7XG4gICAgICAgIG5ld1JhbmdlLnNldEVuZChyZWFsU2VsZWN0aW9uQ29udGFpbmVyLmRvbS5sYXN0Q2hpbGQsIDApO1xuICAgICAgICBzZXRBbGwocmVhbFNlbGVjdGlvbkNvbnRhaW5lciwgeyB0b3A6IGRvbS5nZXRQb3Mobm9kZSwgZWRpdG9yLmdldEJvZHkoKSkueSArICdweCcgfSk7XG4gICAgICAgIGZvY3VzJDEocmVhbFNlbGVjdGlvbkNvbnRhaW5lcik7XG4gICAgICAgIGNvbnN0IHNlbCA9IHNlbGVjdGlvbi5nZXRTZWwoKTtcbiAgICAgICAgc2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICBzZWwuYWRkUmFuZ2UobmV3UmFuZ2UpO1xuICAgICAgICByZXR1cm4gbmV3UmFuZ2U7XG4gICAgICB9O1xuICAgICAgY29uc3Qgc2VsZWN0RWxlbWVudCA9IGVsbSA9PiB7XG4gICAgICAgIGNvbnN0IHRhcmdldENsb25lID0gZWxtLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgICAgY29uc3QgZSA9IGVkaXRvci5kaXNwYXRjaCgnT2JqZWN0U2VsZWN0ZWQnLCB7XG4gICAgICAgICAgdGFyZ2V0OiBlbG0sXG4gICAgICAgICAgdGFyZ2V0Q2xvbmVcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChlLmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmFuZ2UgPSBzZXR1cE9mZnNjcmVlblNlbGVjdGlvbihlbG0sIGUudGFyZ2V0Q2xvbmUpO1xuICAgICAgICBjb25zdCBub2RlRWxtID0gU3VnYXJFbGVtZW50LmZyb21Eb20oZWxtKTtcbiAgICAgICAgZWFjaCRnKGRlc2NlbmRhbnRzKFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVkaXRvci5nZXRCb2R5KCkpLCAnKltkYXRhLW1jZS1zZWxlY3RlZF0nKSwgZWxtID0+IHtcbiAgICAgICAgICBpZiAoIWVxKG5vZGVFbG0sIGVsbSkpIHtcbiAgICAgICAgICAgIHJlbW92ZSRhKGVsbSwgZWxlbWVudFNlbGVjdGlvbkF0dHIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghZG9tLmdldEF0dHJpYihlbG0sIGVsZW1lbnRTZWxlY3Rpb25BdHRyKSkge1xuICAgICAgICAgIGVsbS5zZXRBdHRyaWJ1dGUoZWxlbWVudFNlbGVjdGlvbkF0dHIsICcxJyk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZWN0ZWRFbGVtZW50ID0gZWxtO1xuICAgICAgICBoaWRlRmFrZUNhcmV0KCk7XG4gICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgIH07XG4gICAgICBjb25zdCBzZXRFbGVtZW50U2VsZWN0aW9uID0gKHJhbmdlLCBmb3J3YXJkKSA9PiB7XG4gICAgICAgIGlmICghcmFuZ2UpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmFuZ2UuY29sbGFwc2VkKSB7XG4gICAgICAgICAgaWYgKCFpc1JhbmdlSW5DYXJldENvbnRhaW5lcihyYW5nZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpciA9IGZvcndhcmQgPyAxIDogLTE7XG4gICAgICAgICAgICBjb25zdCBjYXJldFBvc2l0aW9uID0gZ2V0Tm9ybWFsaXplZFJhbmdlRW5kUG9pbnQoZGlyLCByb290Tm9kZSwgcmFuZ2UpO1xuICAgICAgICAgICAgY29uc3QgYmVmb3JlTm9kZSA9IGNhcmV0UG9zaXRpb24uZ2V0Tm9kZSghZm9yd2FyZCk7XG4gICAgICAgICAgICBpZiAoaXNGYWtlQ2FyZXRUYXJnZXQoYmVmb3JlTm9kZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNob3dDYXJldChkaXIsIGJlZm9yZU5vZGUsIGZvcndhcmQgPyAhY2FyZXRQb3NpdGlvbi5pc0F0RW5kKCkgOiBmYWxzZSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYWZ0ZXJOb2RlID0gY2FyZXRQb3NpdGlvbi5nZXROb2RlKGZvcndhcmQpO1xuICAgICAgICAgICAgaWYgKGlzRmFrZUNhcmV0VGFyZ2V0KGFmdGVyTm9kZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNob3dDYXJldChkaXIsIGFmdGVyTm9kZSwgZm9yd2FyZCA/IGZhbHNlIDogIWNhcmV0UG9zaXRpb24uaXNBdEVuZCgpLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGFydENvbnRhaW5lciA9IHJhbmdlLnN0YXJ0Q29udGFpbmVyO1xuICAgICAgICBsZXQgc3RhcnRPZmZzZXQgPSByYW5nZS5zdGFydE9mZnNldDtcbiAgICAgICAgY29uc3QgZW5kT2Zmc2V0ID0gcmFuZ2UuZW5kT2Zmc2V0O1xuICAgICAgICBpZiAoc3RhcnRDb250YWluZXIubm9kZVR5cGUgPT09IDMgJiYgc3RhcnRPZmZzZXQgPT09IDAgJiYgaXNDb250ZW50RWRpdGFibGVGYWxzZShzdGFydENvbnRhaW5lci5wYXJlbnROb2RlKSkge1xuICAgICAgICAgIHN0YXJ0Q29udGFpbmVyID0gc3RhcnRDb250YWluZXIucGFyZW50Tm9kZTtcbiAgICAgICAgICBzdGFydE9mZnNldCA9IGRvbS5ub2RlSW5kZXgoc3RhcnRDb250YWluZXIpO1xuICAgICAgICAgIHN0YXJ0Q29udGFpbmVyID0gc3RhcnRDb250YWluZXIucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnRDb250YWluZXIubm9kZVR5cGUgIT09IDEpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kT2Zmc2V0ID09PSBzdGFydE9mZnNldCArIDEgJiYgc3RhcnRDb250YWluZXIgPT09IHJhbmdlLmVuZENvbnRhaW5lcikge1xuICAgICAgICAgIGNvbnN0IG5vZGUgPSBzdGFydENvbnRhaW5lci5jaGlsZE5vZGVzW3N0YXJ0T2Zmc2V0XTtcbiAgICAgICAgICBpZiAoaXNGYWtlU2VsZWN0aW9uVGFyZ2V0RWxlbWVudChub2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdEVsZW1lbnQobm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlbW92ZUVsZW1lbnRTZWxlY3Rpb24gPSAoKSA9PiB7XG4gICAgICAgIGlmIChzZWxlY3RlZEVsZW1lbnQpIHtcbiAgICAgICAgICBzZWxlY3RlZEVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGVsZW1lbnRTZWxlY3Rpb25BdHRyKTtcbiAgICAgICAgfVxuICAgICAgICBkZXNjZW5kYW50KFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVkaXRvci5nZXRCb2R5KCkpLCAnIycgKyByZWFsU2VsZWN0aW9uSWQpLmVhY2gocmVtb3ZlJDUpO1xuICAgICAgICBzZWxlY3RlZEVsZW1lbnQgPSBudWxsO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGRlc3Ryb3kgPSAoKSA9PiB7XG4gICAgICAgIGZha2VDYXJldC5kZXN0cm95KCk7XG4gICAgICAgIHNlbGVjdGVkRWxlbWVudCA9IG51bGw7XG4gICAgICB9O1xuICAgICAgY29uc3QgaGlkZUZha2VDYXJldCA9ICgpID0+IHtcbiAgICAgICAgZmFrZUNhcmV0LmhpZGUoKTtcbiAgICAgIH07XG4gICAgICBpZiAoIWlzUnRjKGVkaXRvcikpIHtcbiAgICAgICAgcmVnaXN0ZXJFdmVudHMoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNob3dDYXJldCxcbiAgICAgICAgc2hvd0Jsb2NrQ2FyZXRDb250YWluZXIsXG4gICAgICAgIGhpZGVGYWtlQ2FyZXQsXG4gICAgICAgIGRlc3Ryb3lcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IGdlbmVyYXRlUGF0aCA9IChyb290LCBub2RlLCBvZmZzZXQpID0+IHtcbiAgICAgIGlmIChpc1RleHQkOChub2RlKSAmJiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgPiBub2RlLmRhdGEubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBjb25zdCBwID0gW29mZnNldF07XG4gICAgICBsZXQgY3VycmVudCA9IG5vZGU7XG4gICAgICB3aGlsZSAoY3VycmVudCAhPT0gcm9vdCAmJiBjdXJyZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gY3VycmVudC5wYXJlbnROb2RlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHBhcmVudC5jaGlsZE5vZGVzW2ldID09PSBjdXJyZW50KSB7XG4gICAgICAgICAgICBwLnB1c2goaSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudCA9IHBhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjdXJyZW50ID09PSByb290ID8gcC5yZXZlcnNlKCkgOiBbXTtcbiAgICB9O1xuICAgIGNvbnN0IGdlbmVyYXRlUGF0aFJhbmdlID0gKHJvb3QsIHN0YXJ0Tm9kZSwgc3RhcnRPZmZzZXQsIGVuZE5vZGUsIGVuZE9mZnNldCkgPT4ge1xuICAgICAgY29uc3Qgc3RhcnQgPSBnZW5lcmF0ZVBhdGgocm9vdCwgc3RhcnROb2RlLCBzdGFydE9mZnNldCk7XG4gICAgICBjb25zdCBlbmQgPSBnZW5lcmF0ZVBhdGgocm9vdCwgZW5kTm9kZSwgZW5kT2Zmc2V0KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0LFxuICAgICAgICBlbmRcbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCByZXNvbHZlUGF0aCA9IChyb290LCBwYXRoKSA9PiB7XG4gICAgICBjb25zdCBub2RlUGF0aCA9IHBhdGguc2xpY2UoKTtcbiAgICAgIGNvbnN0IG9mZnNldCA9IG5vZGVQYXRoLnBvcCgpO1xuICAgICAgY29uc3QgcmVzb2x2ZWROb2RlID0gZm9sZGwobm9kZVBhdGgsIChvcHROb2RlLCBpbmRleCkgPT4gb3B0Tm9kZS5iaW5kKG5vZGUgPT4gT3B0aW9uYWwuZnJvbShub2RlLmNoaWxkTm9kZXNbaW5kZXhdKSksIE9wdGlvbmFsLnNvbWUocm9vdCkpO1xuICAgICAgcmV0dXJuIHJlc29sdmVkTm9kZS5iaW5kKG5vZGUgPT4ge1xuICAgICAgICBpZiAoaXNUZXh0JDgobm9kZSkgJiYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ID4gbm9kZS5kYXRhLmxlbmd0aCkpIHtcbiAgICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKHtcbiAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICBvZmZzZXRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCByZXNvbHZlUGF0aFJhbmdlID0gKHJvb3QsIHJhbmdlKSA9PiByZXNvbHZlUGF0aChyb290LCByYW5nZS5zdGFydCkuYmluZCgoe1xuICAgICAgbm9kZTogc3RhcnROb2RlLFxuICAgICAgb2Zmc2V0OiBzdGFydE9mZnNldFxuICAgIH0pID0+IHJlc29sdmVQYXRoKHJvb3QsIHJhbmdlLmVuZCkubWFwKCh7XG4gICAgICBub2RlOiBlbmROb2RlLFxuICAgICAgb2Zmc2V0OiBlbmRPZmZzZXRcbiAgICB9KSA9PiB7XG4gICAgICBjb25zdCBybmcgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgcm5nLnNldFN0YXJ0KHN0YXJ0Tm9kZSwgc3RhcnRPZmZzZXQpO1xuICAgICAgcm5nLnNldEVuZChlbmROb2RlLCBlbmRPZmZzZXQpO1xuICAgICAgcmV0dXJuIHJuZztcbiAgICB9KSk7XG4gICAgY29uc3QgZ2VuZXJhdGVQYXRoUmFuZ2VGcm9tUmFuZ2UgPSAocm9vdCwgcmFuZ2UpID0+IGdlbmVyYXRlUGF0aFJhbmdlKHJvb3QsIHJhbmdlLnN0YXJ0Q29udGFpbmVyLCByYW5nZS5zdGFydE9mZnNldCwgcmFuZ2UuZW5kQ29udGFpbmVyLCByYW5nZS5lbmRPZmZzZXQpO1xuXG4gICAgY29uc3QgY2xlYW5FbXB0eU5vZGVzID0gKGRvbSwgbm9kZSwgaXNSb290KSA9PiB7XG4gICAgICBpZiAobm9kZSAmJiBkb20uaXNFbXB0eShub2RlKSAmJiAhaXNSb290KG5vZGUpKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgZG9tLnJlbW92ZShub2RlKTtcbiAgICAgICAgY2xlYW5FbXB0eU5vZGVzKGRvbSwgcGFyZW50LCBpc1Jvb3QpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZGVsZXRlUm5nID0gKGRvbSwgcm5nLCBpc1Jvb3QsIGNsZWFuID0gdHJ1ZSkgPT4ge1xuICAgICAgY29uc3Qgc3RhcnRQYXJlbnQgPSBybmcuc3RhcnRDb250YWluZXIucGFyZW50Tm9kZTtcbiAgICAgIGNvbnN0IGVuZFBhcmVudCA9IHJuZy5lbmRDb250YWluZXIucGFyZW50Tm9kZTtcbiAgICAgIHJuZy5kZWxldGVDb250ZW50cygpO1xuICAgICAgaWYgKGNsZWFuICYmICFpc1Jvb3Qocm5nLnN0YXJ0Q29udGFpbmVyKSkge1xuICAgICAgICBpZiAoaXNUZXh0JDgocm5nLnN0YXJ0Q29udGFpbmVyKSAmJiBybmcuc3RhcnRDb250YWluZXIuZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBkb20ucmVtb3ZlKHJuZy5zdGFydENvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVGV4dCQ4KHJuZy5lbmRDb250YWluZXIpICYmIHJuZy5lbmRDb250YWluZXIuZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBkb20ucmVtb3ZlKHJuZy5lbmRDb250YWluZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFuRW1wdHlOb2Rlcyhkb20sIHN0YXJ0UGFyZW50LCBpc1Jvb3QpO1xuICAgICAgICBpZiAoc3RhcnRQYXJlbnQgIT09IGVuZFBhcmVudCkge1xuICAgICAgICAgIGNsZWFuRW1wdHlOb2Rlcyhkb20sIGVuZFBhcmVudCwgaXNSb290KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZ2V0UGFyZW50QmxvY2sgPSAoZWRpdG9yLCBybmcpID0+IE9wdGlvbmFsLmZyb20oZWRpdG9yLmRvbS5nZXRQYXJlbnQocm5nLnN0YXJ0Q29udGFpbmVyLCBlZGl0b3IuZG9tLmlzQmxvY2spKTtcblxuICAgIGNvbnN0IHN0cmlwUGF0dGVybiA9IChkb20sIGJsb2NrLCBwYXR0ZXJuKSA9PiB7XG4gICAgICBjb25zdCBmaXJzdFRleHROb2RlID0gdGV4dEFmdGVyKGJsb2NrLCAwLCBibG9jayk7XG4gICAgICBmaXJzdFRleHROb2RlLmVhY2goc3BvdCA9PiB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBzcG90LmNvbnRhaW5lcjtcbiAgICAgICAgc2NhblJpZ2h0KG5vZGUsIHBhdHRlcm4uc3RhcnQubGVuZ3RoLCBibG9jaykuZWFjaChlbmQgPT4ge1xuICAgICAgICAgIGNvbnN0IHJuZyA9IGRvbS5jcmVhdGVSbmcoKTtcbiAgICAgICAgICBybmcuc2V0U3RhcnQobm9kZSwgMCk7XG4gICAgICAgICAgcm5nLnNldEVuZChlbmQuY29udGFpbmVyLCBlbmQub2Zmc2V0KTtcbiAgICAgICAgICBkZWxldGVSbmcoZG9tLCBybmcsIGUgPT4gZSA9PT0gYmxvY2spO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgYXBwbHlQYXR0ZXJuJDEgPSAoZWRpdG9yLCBtYXRjaCkgPT4ge1xuICAgICAgY29uc3QgZG9tID0gZWRpdG9yLmRvbTtcbiAgICAgIGNvbnN0IHBhdHRlcm4gPSBtYXRjaC5wYXR0ZXJuO1xuICAgICAgY29uc3Qgcm5nID0gcmVzb2x2ZVBhdGhSYW5nZShkb20uZ2V0Um9vdCgpLCBtYXRjaC5yYW5nZSkuZ2V0T3JEaWUoJ1VuYWJsZSB0byByZXNvbHZlIHBhdGggcmFuZ2UnKTtcbiAgICAgIGNvbnN0IGlzQmxvY2tGb3JtYXROYW1lID0gKG5hbWUsIGZvcm1hdHRlcikgPT4ge1xuICAgICAgICBjb25zdCBmb3JtYXRTZXQgPSBmb3JtYXR0ZXIuZ2V0KG5hbWUpO1xuICAgICAgICByZXR1cm4gaXNBcnJheSQxKGZvcm1hdFNldCkgJiYgaGVhZChmb3JtYXRTZXQpLmV4aXN0cyhmb3JtYXQgPT4gaGFzJDIoZm9ybWF0LCAnYmxvY2snKSk7XG4gICAgICB9O1xuICAgICAgZ2V0UGFyZW50QmxvY2soZWRpdG9yLCBybmcpLmVhY2goYmxvY2sgPT4ge1xuICAgICAgICBpZiAocGF0dGVybi50eXBlID09PSAnYmxvY2stZm9ybWF0Jykge1xuICAgICAgICAgIGlmIChpc0Jsb2NrRm9ybWF0TmFtZShwYXR0ZXJuLmZvcm1hdCwgZWRpdG9yLmZvcm1hdHRlcikpIHtcbiAgICAgICAgICAgIGVkaXRvci51bmRvTWFuYWdlci50cmFuc2FjdCgoKSA9PiB7XG4gICAgICAgICAgICAgIHN0cmlwUGF0dGVybihlZGl0b3IuZG9tLCBibG9jaywgcGF0dGVybik7XG4gICAgICAgICAgICAgIGVkaXRvci5mb3JtYXR0ZXIuYXBwbHkocGF0dGVybi5mb3JtYXQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHBhdHRlcm4udHlwZSA9PT0gJ2Jsb2NrLWNvbW1hbmQnKSB7XG4gICAgICAgICAgZWRpdG9yLnVuZG9NYW5hZ2VyLnRyYW5zYWN0KCgpID0+IHtcbiAgICAgICAgICAgIHN0cmlwUGF0dGVybihlZGl0b3IuZG9tLCBibG9jaywgcGF0dGVybik7XG4gICAgICAgICAgICBlZGl0b3IuZXhlY0NvbW1hbmQocGF0dGVybi5jbWQsIGZhbHNlLCBwYXR0ZXJuLnZhbHVlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIGNvbnN0IGZpbmRQYXR0ZXJuJDEgPSAocGF0dGVybnMsIHRleHQpID0+IHtcbiAgICAgIGNvbnN0IG51VGV4dCA9IHRleHQucmVwbGFjZShuYnNwLCAnICcpO1xuICAgICAgcmV0dXJuIGZpbmQkMihwYXR0ZXJucywgcGF0dGVybiA9PiB0ZXh0LmluZGV4T2YocGF0dGVybi5zdGFydCkgPT09IDAgfHwgbnVUZXh0LmluZGV4T2YocGF0dGVybi5zdGFydCkgPT09IDApO1xuICAgIH07XG4gICAgY29uc3QgZmluZFBhdHRlcm5zJDEgPSAoZWRpdG9yLCBwYXR0ZXJucykgPT4ge1xuICAgICAgY29uc3QgZG9tID0gZWRpdG9yLmRvbTtcbiAgICAgIGNvbnN0IHJuZyA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCk7XG4gICAgICByZXR1cm4gZ2V0UGFyZW50QmxvY2soZWRpdG9yLCBybmcpLmZpbHRlcihibG9jayA9PiB7XG4gICAgICAgIGNvbnN0IGZvcmNlZFJvb3RCbG9jayA9IGdldEZvcmNlZFJvb3RCbG9jayhlZGl0b3IpO1xuICAgICAgICBjb25zdCBtYXRjaGVzRm9yY2VkUm9vdEJsb2NrID0gZG9tLmlzKGJsb2NrLCBmb3JjZWRSb290QmxvY2spO1xuICAgICAgICByZXR1cm4gYmxvY2sgIT09IG51bGwgJiYgbWF0Y2hlc0ZvcmNlZFJvb3RCbG9jaztcbiAgICAgIH0pLmJpbmQoYmxvY2sgPT4ge1xuICAgICAgICBjb25zdCBibG9ja1RleHQgPSBibG9jay50ZXh0Q29udGVudDtcbiAgICAgICAgY29uc3QgbWF0Y2hlZFBhdHRlcm4gPSBmaW5kUGF0dGVybiQxKHBhdHRlcm5zLCBibG9ja1RleHQpO1xuICAgICAgICByZXR1cm4gbWF0Y2hlZFBhdHRlcm4ubWFwKHBhdHRlcm4gPT4ge1xuICAgICAgICAgIGlmIChUb29scy50cmltKGJsb2NrVGV4dCkubGVuZ3RoID09PSBwYXR0ZXJuLnN0YXJ0Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICAgICAgcGF0dGVybixcbiAgICAgICAgICAgICAgcmFuZ2U6IGdlbmVyYXRlUGF0aFJhbmdlKGRvbS5nZXRSb290KCksIGJsb2NrLCAwLCBibG9jaywgMClcbiAgICAgICAgICAgIH1dO1xuICAgICAgICB9KTtcbiAgICAgIH0pLmdldE9yKFtdKTtcbiAgICB9O1xuICAgIGNvbnN0IGFwcGx5TWF0Y2hlcyQxID0gKGVkaXRvciwgbWF0Y2hlcykgPT4ge1xuICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJvb2ttYXJrID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRCb29rbWFyaygpO1xuICAgICAgZWFjaCRnKG1hdGNoZXMsIG1hdGNoID0+IGFwcGx5UGF0dGVybiQxKGVkaXRvciwgbWF0Y2gpKTtcbiAgICAgIGVkaXRvci5zZWxlY3Rpb24ubW92ZVRvQm9va21hcmsoYm9va21hcmspO1xuICAgIH07XG5cbiAgICBjb25zdCBuZXdNYXJrZXIgPSAoZG9tLCBpZCkgPT4gZG9tLmNyZWF0ZSgnc3BhbicsIHtcbiAgICAgICdkYXRhLW1jZS10eXBlJzogJ2Jvb2ttYXJrJyxcbiAgICAgIGlkXG4gICAgfSk7XG4gICAgY29uc3QgcmFuZ2VGcm9tTWFya2VyID0gKGRvbSwgbWFya2VyKSA9PiB7XG4gICAgICBjb25zdCBybmcgPSBkb20uY3JlYXRlUm5nKCk7XG4gICAgICBybmcuc2V0U3RhcnRBZnRlcihtYXJrZXIuc3RhcnQpO1xuICAgICAgcm5nLnNldEVuZEJlZm9yZShtYXJrZXIuZW5kKTtcbiAgICAgIHJldHVybiBybmc7XG4gICAgfTtcbiAgICBjb25zdCBjcmVhdGVNYXJrZXIgPSAoZG9tLCBtYXJrZXJQcmVmaXgsIHBhdGhSYW5nZSkgPT4ge1xuICAgICAgY29uc3Qgcm5nID0gcmVzb2x2ZVBhdGhSYW5nZShkb20uZ2V0Um9vdCgpLCBwYXRoUmFuZ2UpLmdldE9yRGllKCdVbmFibGUgdG8gcmVzb2x2ZSBwYXRoIHJhbmdlJyk7XG4gICAgICBjb25zdCBzdGFydE5vZGUgPSBybmcuc3RhcnRDb250YWluZXI7XG4gICAgICBjb25zdCBlbmROb2RlID0gcm5nLmVuZENvbnRhaW5lcjtcbiAgICAgIGNvbnN0IHRleHRFbmQgPSBybmcuZW5kT2Zmc2V0ID09PSAwID8gZW5kTm9kZSA6IGVuZE5vZGUuc3BsaXRUZXh0KHJuZy5lbmRPZmZzZXQpO1xuICAgICAgY29uc3QgdGV4dFN0YXJ0ID0gcm5nLnN0YXJ0T2Zmc2V0ID09PSAwID8gc3RhcnROb2RlIDogc3RhcnROb2RlLnNwbGl0VGV4dChybmcuc3RhcnRPZmZzZXQpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJlZml4OiBtYXJrZXJQcmVmaXgsXG4gICAgICAgIGVuZDogdGV4dEVuZC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdNYXJrZXIoZG9tLCBtYXJrZXJQcmVmaXggKyAnLWVuZCcpLCB0ZXh0RW5kKSxcbiAgICAgICAgc3RhcnQ6IHRleHRTdGFydC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdNYXJrZXIoZG9tLCBtYXJrZXJQcmVmaXggKyAnLXN0YXJ0JyksIHRleHRTdGFydClcbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCByZW1vdmVNYXJrZXIgPSAoZG9tLCBtYXJrZXIsIGlzUm9vdCkgPT4ge1xuICAgICAgY2xlYW5FbXB0eU5vZGVzKGRvbSwgZG9tLmdldChtYXJrZXIucHJlZml4ICsgJy1lbmQnKSwgaXNSb290KTtcbiAgICAgIGNsZWFuRW1wdHlOb2Rlcyhkb20sIGRvbS5nZXQobWFya2VyLnByZWZpeCArICctc3RhcnQnKSwgaXNSb290KTtcbiAgICB9O1xuXG4gICAgY29uc3QgaXNSZXBsYWNlbWVudFBhdHRlcm4gPSBwYXR0ZXJuID0+IHBhdHRlcm4uc3RhcnQubGVuZ3RoID09PSAwO1xuICAgIGNvbnN0IG1hdGNoZXNQYXR0ZXJuID0gcGF0dGVybkNvbnRlbnQgPT4gKGVsZW1lbnQsIG9mZnNldCkgPT4ge1xuICAgICAgY29uc3QgdGV4dCA9IGVsZW1lbnQuZGF0YTtcbiAgICAgIGNvbnN0IHNlYXJjaFRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBvZmZzZXQpO1xuICAgICAgY29uc3Qgc3RhcnRFbmRJbmRleCA9IHNlYXJjaFRleHQubGFzdEluZGV4T2YocGF0dGVybkNvbnRlbnQuY2hhckF0KHBhdHRlcm5Db250ZW50Lmxlbmd0aCAtIDEpKTtcbiAgICAgIGNvbnN0IHN0YXJ0SW5kZXggPSBzZWFyY2hUZXh0Lmxhc3RJbmRleE9mKHBhdHRlcm5Db250ZW50KTtcbiAgICAgIGlmIChzdGFydEluZGV4ICE9PSAtMSkge1xuICAgICAgICByZXR1cm4gc3RhcnRJbmRleCArIHBhdHRlcm5Db250ZW50Lmxlbmd0aDtcbiAgICAgIH0gZWxzZSBpZiAoc3RhcnRFbmRJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHN0YXJ0RW5kSW5kZXggKyAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZmluZFBhdHRlcm5TdGFydEZyb21TcG90ID0gKGRvbSwgcGF0dGVybiwgYmxvY2ssIHNwb3QpID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0UGF0dGVybiA9IHBhdHRlcm4uc3RhcnQ7XG4gICAgICBjb25zdCBzdGFydFNwb3QgPSByZXBlYXRMZWZ0KGRvbSwgc3BvdC5jb250YWluZXIsIHNwb3Qub2Zmc2V0LCBtYXRjaGVzUGF0dGVybihzdGFydFBhdHRlcm4pLCBibG9jayk7XG4gICAgICByZXR1cm4gc3RhcnRTcG90LmJpbmQoc3BvdCA9PiB7XG4gICAgICAgIGlmIChzcG90Lm9mZnNldCA+PSBzdGFydFBhdHRlcm4ubGVuZ3RoKSB7XG4gICAgICAgICAgY29uc3Qgcm5nID0gZG9tLmNyZWF0ZVJuZygpO1xuICAgICAgICAgIHJuZy5zZXRTdGFydChzcG90LmNvbnRhaW5lciwgc3BvdC5vZmZzZXQgLSBzdGFydFBhdHRlcm4ubGVuZ3RoKTtcbiAgICAgICAgICBybmcuc2V0RW5kKHNwb3QuY29udGFpbmVyLCBzcG90Lm9mZnNldCk7XG4gICAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUocm5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBvZmZzZXQgPSBzcG90Lm9mZnNldCAtIHN0YXJ0UGF0dGVybi5sZW5ndGg7XG4gICAgICAgICAgcmV0dXJuIHNjYW5MZWZ0KHNwb3QuY29udGFpbmVyLCBvZmZzZXQsIGJsb2NrKS5tYXAobmV4dFNwb3QgPT4ge1xuICAgICAgICAgICAgY29uc3Qgcm5nID0gZG9tLmNyZWF0ZVJuZygpO1xuICAgICAgICAgICAgcm5nLnNldFN0YXJ0KG5leHRTcG90LmNvbnRhaW5lciwgbmV4dFNwb3Qub2Zmc2V0KTtcbiAgICAgICAgICAgIHJuZy5zZXRFbmQoc3BvdC5jb250YWluZXIsIHNwb3Qub2Zmc2V0KTtcbiAgICAgICAgICAgIHJldHVybiBybmc7XG4gICAgICAgICAgfSkuZmlsdGVyKHJuZyA9PiBybmcudG9TdHJpbmcoKSA9PT0gc3RhcnRQYXR0ZXJuKS5vclRodW5rKCgpID0+IGZpbmRQYXR0ZXJuU3RhcnRGcm9tU3BvdChkb20sIHBhdHRlcm4sIGJsb2NrLCBwb2ludChzcG90LmNvbnRhaW5lciwgMCkpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBmaW5kUGF0dGVyblN0YXJ0ID0gKGRvbSwgcGF0dGVybiwgbm9kZSwgb2Zmc2V0LCBibG9jaywgcmVxdWlyZUdhcCA9IGZhbHNlKSA9PiB7XG4gICAgICBpZiAocGF0dGVybi5zdGFydC5sZW5ndGggPT09IDAgJiYgIXJlcXVpcmVHYXApIHtcbiAgICAgICAgY29uc3Qgcm5nID0gZG9tLmNyZWF0ZVJuZygpO1xuICAgICAgICBybmcuc2V0U3RhcnQobm9kZSwgb2Zmc2V0KTtcbiAgICAgICAgcm5nLnNldEVuZChub2RlLCBvZmZzZXQpO1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZShybmcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRleHRCZWZvcmUobm9kZSwgb2Zmc2V0LCBibG9jaykuYmluZChzcG90ID0+IHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBmaW5kUGF0dGVyblN0YXJ0RnJvbVNwb3QoZG9tLCBwYXR0ZXJuLCBibG9jaywgc3BvdCk7XG4gICAgICAgIHJldHVybiBzdGFydC5iaW5kKHN0YXJ0UmFuZ2UgPT4ge1xuICAgICAgICAgIGlmIChyZXF1aXJlR2FwKSB7XG4gICAgICAgICAgICBpZiAoc3RhcnRSYW5nZS5lbmRDb250YWluZXIgPT09IHNwb3QuY29udGFpbmVyICYmIHN0YXJ0UmFuZ2UuZW5kT2Zmc2V0ID09PSBzcG90Lm9mZnNldCkge1xuICAgICAgICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzcG90Lm9mZnNldCA9PT0gMCAmJiBzdGFydFJhbmdlLmVuZENvbnRhaW5lci50ZXh0Q29udGVudC5sZW5ndGggPT09IHN0YXJ0UmFuZ2UuZW5kT2Zmc2V0KSB7XG4gICAgICAgICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKHN0YXJ0UmFuZ2UpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgZmluZFBhdHRlcm4gPSAoZWRpdG9yLCBibG9jaywgZGV0YWlscykgPT4ge1xuICAgICAgY29uc3QgZG9tID0gZWRpdG9yLmRvbTtcbiAgICAgIGNvbnN0IHJvb3QgPSBkb20uZ2V0Um9vdCgpO1xuICAgICAgY29uc3QgcGF0dGVybiA9IGRldGFpbHMucGF0dGVybjtcbiAgICAgIGNvbnN0IGVuZE5vZGUgPSBkZXRhaWxzLnBvc2l0aW9uLmNvbnRhaW5lcjtcbiAgICAgIGNvbnN0IGVuZE9mZnNldCA9IGRldGFpbHMucG9zaXRpb24ub2Zmc2V0O1xuICAgICAgcmV0dXJuIHNjYW5MZWZ0KGVuZE5vZGUsIGVuZE9mZnNldCAtIGRldGFpbHMucGF0dGVybi5lbmQubGVuZ3RoLCBibG9jaykuYmluZChzcG90ID0+IHtcbiAgICAgICAgY29uc3QgZW5kUGF0aFJuZyA9IGdlbmVyYXRlUGF0aFJhbmdlKHJvb3QsIHNwb3QuY29udGFpbmVyLCBzcG90Lm9mZnNldCwgZW5kTm9kZSwgZW5kT2Zmc2V0KTtcbiAgICAgICAgaWYgKGlzUmVwbGFjZW1lbnRQYXR0ZXJuKHBhdHRlcm4pKSB7XG4gICAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoe1xuICAgICAgICAgICAgbWF0Y2hlczogW3tcbiAgICAgICAgICAgICAgICBwYXR0ZXJuLFxuICAgICAgICAgICAgICAgIHN0YXJ0Um5nOiBlbmRQYXRoUm5nLFxuICAgICAgICAgICAgICAgIGVuZFJuZzogZW5kUGF0aFJuZ1xuICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBzcG90XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0c09wdCA9IGZpbmRQYXR0ZXJuc1JlYyhlZGl0b3IsIGRldGFpbHMucmVtYWluaW5nUGF0dGVybnMsIHNwb3QuY29udGFpbmVyLCBzcG90Lm9mZnNldCwgYmxvY2spO1xuICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSByZXN1bHRzT3B0LmdldE9yKHtcbiAgICAgICAgICAgIG1hdGNoZXM6IFtdLFxuICAgICAgICAgICAgcG9zaXRpb246IHNwb3RcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCBwb3MgPSByZXN1bHRzLnBvc2l0aW9uO1xuICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gZmluZFBhdHRlcm5TdGFydChkb20sIHBhdHRlcm4sIHBvcy5jb250YWluZXIsIHBvcy5vZmZzZXQsIGJsb2NrLCByZXN1bHRzT3B0LmlzTm9uZSgpKTtcbiAgICAgICAgICByZXR1cm4gc3RhcnQubWFwKHN0YXJ0Um5nID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0UGF0aFJuZyA9IGdlbmVyYXRlUGF0aFJhbmdlRnJvbVJhbmdlKHJvb3QsIHN0YXJ0Um5nKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIG1hdGNoZXM6IHJlc3VsdHMubWF0Y2hlcy5jb25jYXQoW3tcbiAgICAgICAgICAgICAgICAgIHBhdHRlcm4sXG4gICAgICAgICAgICAgICAgICBzdGFydFJuZzogc3RhcnRQYXRoUm5nLFxuICAgICAgICAgICAgICAgICAgZW5kUm5nOiBlbmRQYXRoUm5nXG4gICAgICAgICAgICAgICAgfV0pLFxuICAgICAgICAgICAgICBwb3NpdGlvbjogcG9pbnQoc3RhcnRSbmcuc3RhcnRDb250YWluZXIsIHN0YXJ0Um5nLnN0YXJ0T2Zmc2V0KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBmaW5kUGF0dGVybnNSZWMgPSAoZWRpdG9yLCBwYXR0ZXJucywgbm9kZSwgb2Zmc2V0LCBibG9jaykgPT4ge1xuICAgICAgY29uc3QgZG9tID0gZWRpdG9yLmRvbTtcbiAgICAgIHJldHVybiB0ZXh0QmVmb3JlKG5vZGUsIG9mZnNldCwgZG9tLmdldFJvb3QoKSkuYmluZChlbmRTcG90ID0+IHtcbiAgICAgICAgY29uc3Qgcm5nID0gZG9tLmNyZWF0ZVJuZygpO1xuICAgICAgICBybmcuc2V0U3RhcnQoYmxvY2ssIDApO1xuICAgICAgICBybmcuc2V0RW5kKG5vZGUsIG9mZnNldCk7XG4gICAgICAgIGNvbnN0IHRleHQgPSBybmcudG9TdHJpbmcoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXR0ZXJucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHBhdHRlcm4gPSBwYXR0ZXJuc1tpXTtcbiAgICAgICAgICBpZiAoIWVuZHNXaXRoKHRleHQsIHBhdHRlcm4uZW5kKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHBhdHRlcm5zV2l0aG91dEN1cnJlbnQgPSBwYXR0ZXJucy5zbGljZSgpO1xuICAgICAgICAgIHBhdHRlcm5zV2l0aG91dEN1cnJlbnQuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGZpbmRQYXR0ZXJuKGVkaXRvciwgYmxvY2ssIHtcbiAgICAgICAgICAgIHBhdHRlcm4sXG4gICAgICAgICAgICByZW1haW5pbmdQYXR0ZXJuczogcGF0dGVybnNXaXRob3V0Q3VycmVudCxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBlbmRTcG90XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHJlc3VsdC5pc1NvbWUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgYXBwbHlQYXR0ZXJuID0gKGVkaXRvciwgcGF0dGVybiwgcGF0dGVyblJhbmdlKSA9PiB7XG4gICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNldFJuZyhwYXR0ZXJuUmFuZ2UpO1xuICAgICAgaWYgKHBhdHRlcm4udHlwZSA9PT0gJ2lubGluZS1mb3JtYXQnKSB7XG4gICAgICAgIGVhY2gkZyhwYXR0ZXJuLmZvcm1hdCwgZm9ybWF0ID0+IHtcbiAgICAgICAgICBlZGl0b3IuZm9ybWF0dGVyLmFwcGx5KGZvcm1hdCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWRpdG9yLmV4ZWNDb21tYW5kKHBhdHRlcm4uY21kLCBmYWxzZSwgcGF0dGVybi52YWx1ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBhcHBseVJlcGxhY2VtZW50UGF0dGVybiA9IChlZGl0b3IsIHBhdHRlcm4sIG1hcmtlciwgaXNSb290KSA9PiB7XG4gICAgICBjb25zdCBtYXJrZXJSYW5nZSA9IHJhbmdlRnJvbU1hcmtlcihlZGl0b3IuZG9tLCBtYXJrZXIpO1xuICAgICAgZGVsZXRlUm5nKGVkaXRvci5kb20sIG1hcmtlclJhbmdlLCBpc1Jvb3QpO1xuICAgICAgYXBwbHlQYXR0ZXJuKGVkaXRvciwgcGF0dGVybiwgbWFya2VyUmFuZ2UpO1xuICAgIH07XG4gICAgY29uc3QgYXBwbHlQYXR0ZXJuV2l0aENvbnRlbnQgPSAoZWRpdG9yLCBwYXR0ZXJuLCBzdGFydE1hcmtlciwgZW5kTWFya2VyLCBpc1Jvb3QpID0+IHtcbiAgICAgIGNvbnN0IGRvbSA9IGVkaXRvci5kb207XG4gICAgICBjb25zdCBtYXJrZXJFbmRSYW5nZSA9IHJhbmdlRnJvbU1hcmtlcihkb20sIGVuZE1hcmtlcik7XG4gICAgICBjb25zdCBtYXJrZXJTdGFydFJhbmdlID0gcmFuZ2VGcm9tTWFya2VyKGRvbSwgc3RhcnRNYXJrZXIpO1xuICAgICAgZGVsZXRlUm5nKGRvbSwgbWFya2VyU3RhcnRSYW5nZSwgaXNSb290KTtcbiAgICAgIGRlbGV0ZVJuZyhkb20sIG1hcmtlckVuZFJhbmdlLCBpc1Jvb3QpO1xuICAgICAgY29uc3QgcGF0dGVybk1hcmtlciA9IHtcbiAgICAgICAgcHJlZml4OiBzdGFydE1hcmtlci5wcmVmaXgsXG4gICAgICAgIHN0YXJ0OiBzdGFydE1hcmtlci5lbmQsXG4gICAgICAgIGVuZDogZW5kTWFya2VyLnN0YXJ0XG4gICAgICB9O1xuICAgICAgY29uc3QgcGF0dGVyblJhbmdlID0gcmFuZ2VGcm9tTWFya2VyKGRvbSwgcGF0dGVybk1hcmtlcik7XG4gICAgICBhcHBseVBhdHRlcm4oZWRpdG9yLCBwYXR0ZXJuLCBwYXR0ZXJuUmFuZ2UpO1xuICAgIH07XG4gICAgY29uc3QgYWRkTWFya2VycyA9IChkb20sIG1hdGNoZXMpID0+IHtcbiAgICAgIGNvbnN0IG1hcmtlclByZWZpeCA9IGdlbmVyYXRlJDEoJ21jZV90ZXh0cGF0dGVybicpO1xuICAgICAgY29uc3QgbWF0Y2hlc1dpdGhFbmRzID0gZm9sZHIobWF0Y2hlcywgKGFjYywgbWF0Y2gpID0+IHtcbiAgICAgICAgY29uc3QgZW5kTWFya2VyID0gY3JlYXRlTWFya2VyKGRvbSwgbWFya2VyUHJlZml4ICsgYF9lbmQkeyBhY2MubGVuZ3RoIH1gLCBtYXRjaC5lbmRSbmcpO1xuICAgICAgICByZXR1cm4gYWNjLmNvbmNhdChbe1xuICAgICAgICAgICAgLi4ubWF0Y2gsXG4gICAgICAgICAgICBlbmRNYXJrZXJcbiAgICAgICAgICB9XSk7XG4gICAgICB9LCBbXSk7XG4gICAgICByZXR1cm4gZm9sZHIobWF0Y2hlc1dpdGhFbmRzLCAoYWNjLCBtYXRjaCkgPT4ge1xuICAgICAgICBjb25zdCBpZHggPSBtYXRjaGVzV2l0aEVuZHMubGVuZ3RoIC0gYWNjLmxlbmd0aCAtIDE7XG4gICAgICAgIGNvbnN0IHN0YXJ0TWFya2VyID0gaXNSZXBsYWNlbWVudFBhdHRlcm4obWF0Y2gucGF0dGVybikgPyBtYXRjaC5lbmRNYXJrZXIgOiBjcmVhdGVNYXJrZXIoZG9tLCBtYXJrZXJQcmVmaXggKyBgX3N0YXJ0JHsgaWR4IH1gLCBtYXRjaC5zdGFydFJuZyk7XG4gICAgICAgIHJldHVybiBhY2MuY29uY2F0KFt7XG4gICAgICAgICAgICAuLi5tYXRjaCxcbiAgICAgICAgICAgIHN0YXJ0TWFya2VyXG4gICAgICAgICAgfV0pO1xuICAgICAgfSwgW10pO1xuICAgIH07XG4gICAgY29uc3QgZmluZFBhdHRlcm5zID0gKGVkaXRvciwgcGF0dGVybnMsIHNwYWNlKSA9PiB7XG4gICAgICBjb25zdCBybmcgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpO1xuICAgICAgaWYgKHJuZy5jb2xsYXBzZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRQYXJlbnRCbG9jayhlZGl0b3IsIHJuZykuYmluZChibG9jayA9PiB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IE1hdGgubWF4KDAsIHJuZy5zdGFydE9mZnNldCAtIChzcGFjZSA/IDEgOiAwKSk7XG4gICAgICAgIHJldHVybiBmaW5kUGF0dGVybnNSZWMoZWRpdG9yLCBwYXR0ZXJucywgcm5nLnN0YXJ0Q29udGFpbmVyLCBvZmZzZXQsIGJsb2NrKTtcbiAgICAgIH0pLmZvbGQoKCkgPT4gW10sIHJlc3VsdCA9PiByZXN1bHQubWF0Y2hlcyk7XG4gICAgfTtcbiAgICBjb25zdCBhcHBseU1hdGNoZXMgPSAoZWRpdG9yLCBtYXRjaGVzKSA9PiB7XG4gICAgICBpZiAobWF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZG9tID0gZWRpdG9yLmRvbTtcbiAgICAgIGNvbnN0IGJvb2ttYXJrID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRCb29rbWFyaygpO1xuICAgICAgY29uc3QgbWF0Y2hlc1dpdGhNYXJrZXJzID0gYWRkTWFya2Vycyhkb20sIG1hdGNoZXMpO1xuICAgICAgZWFjaCRnKG1hdGNoZXNXaXRoTWFya2VycywgbWF0Y2ggPT4ge1xuICAgICAgICBjb25zdCBibG9jayA9IGRvbS5nZXRQYXJlbnQobWF0Y2guc3RhcnRNYXJrZXIuc3RhcnQsIGRvbS5pc0Jsb2NrKTtcbiAgICAgICAgY29uc3QgaXNSb290ID0gbm9kZSA9PiBub2RlID09PSBibG9jaztcbiAgICAgICAgaWYgKGlzUmVwbGFjZW1lbnRQYXR0ZXJuKG1hdGNoLnBhdHRlcm4pKSB7XG4gICAgICAgICAgYXBwbHlSZXBsYWNlbWVudFBhdHRlcm4oZWRpdG9yLCBtYXRjaC5wYXR0ZXJuLCBtYXRjaC5lbmRNYXJrZXIsIGlzUm9vdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXBwbHlQYXR0ZXJuV2l0aENvbnRlbnQoZWRpdG9yLCBtYXRjaC5wYXR0ZXJuLCBtYXRjaC5zdGFydE1hcmtlciwgbWF0Y2guZW5kTWFya2VyLCBpc1Jvb3QpO1xuICAgICAgICB9XG4gICAgICAgIHJlbW92ZU1hcmtlcihkb20sIG1hdGNoLmVuZE1hcmtlciwgaXNSb290KTtcbiAgICAgICAgcmVtb3ZlTWFya2VyKGRvbSwgbWF0Y2guc3RhcnRNYXJrZXIsIGlzUm9vdCk7XG4gICAgICB9KTtcbiAgICAgIGVkaXRvci5zZWxlY3Rpb24ubW92ZVRvQm9va21hcmsoYm9va21hcmspO1xuICAgIH07XG5cbiAgICBjb25zdCBoYXNQYXR0ZXJucyA9IHBhdHRlcm5TZXQgPT4gcGF0dGVyblNldC5pbmxpbmVQYXR0ZXJucy5sZW5ndGggPiAwIHx8IHBhdHRlcm5TZXQuYmxvY2tQYXR0ZXJucy5sZW5ndGggPiAwO1xuICAgIGNvbnN0IGhhbmRsZUVudGVyID0gKGVkaXRvciwgcGF0dGVyblNldCkgPT4ge1xuICAgICAgaWYgKCFlZGl0b3Iuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgfHwgIWhhc1BhdHRlcm5zKHBhdHRlcm5TZXQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlubGluZU1hdGNoZXMgPSBmaW5kUGF0dGVybnMoZWRpdG9yLCBwYXR0ZXJuU2V0LmlubGluZVBhdHRlcm5zLCBmYWxzZSk7XG4gICAgICBjb25zdCBibG9ja01hdGNoZXMgPSBmaW5kUGF0dGVybnMkMShlZGl0b3IsIHBhdHRlcm5TZXQuYmxvY2tQYXR0ZXJucyk7XG4gICAgICBpZiAoYmxvY2tNYXRjaGVzLmxlbmd0aCA+IDAgfHwgaW5saW5lTWF0Y2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGVkaXRvci51bmRvTWFuYWdlci5hZGQoKTtcbiAgICAgICAgZWRpdG9yLnVuZG9NYW5hZ2VyLmV4dHJhKCgpID0+IHtcbiAgICAgICAgICBlZGl0b3IuZXhlY0NvbW1hbmQoJ21jZUluc2VydE5ld0xpbmUnKTtcbiAgICAgICAgfSwgKCkgPT4ge1xuICAgICAgICAgIGVkaXRvci5pbnNlcnRDb250ZW50KHplcm9XaWR0aCk7XG4gICAgICAgICAgYXBwbHlNYXRjaGVzKGVkaXRvciwgaW5saW5lTWF0Y2hlcyk7XG4gICAgICAgICAgYXBwbHlNYXRjaGVzJDEoZWRpdG9yLCBibG9ja01hdGNoZXMpO1xuICAgICAgICAgIGNvbnN0IHJhbmdlID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKTtcbiAgICAgICAgICBjb25zdCBzcG90ID0gdGV4dEJlZm9yZShyYW5nZS5zdGFydENvbnRhaW5lciwgcmFuZ2Uuc3RhcnRPZmZzZXQsIGVkaXRvci5kb20uZ2V0Um9vdCgpKTtcbiAgICAgICAgICBlZGl0b3IuZXhlY0NvbW1hbmQoJ21jZUluc2VydE5ld0xpbmUnKTtcbiAgICAgICAgICBzcG90LmVhY2gocyA9PiB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gcy5jb250YWluZXI7XG4gICAgICAgICAgICBpZiAobm9kZS5kYXRhLmNoYXJBdChzLm9mZnNldCAtIDEpID09PSB6ZXJvV2lkdGgpIHtcbiAgICAgICAgICAgICAgbm9kZS5kZWxldGVEYXRhKHMub2Zmc2V0IC0gMSwgMSk7XG4gICAgICAgICAgICAgIGNsZWFuRW1wdHlOb2RlcyhlZGl0b3IuZG9tLCBub2RlLnBhcmVudE5vZGUsIGUgPT4gZSA9PT0gZWRpdG9yLmRvbS5nZXRSb290KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVJbmxpbmVLZXkgPSAoZWRpdG9yLCBpbmxpbmVQYXR0ZXJucykgPT4ge1xuICAgICAgaWYgKGlubGluZVBhdHRlcm5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgaW5saW5lTWF0Y2hlcyA9IGZpbmRQYXR0ZXJucyhlZGl0b3IsIGlubGluZVBhdHRlcm5zLCB0cnVlKTtcbiAgICAgICAgaWYgKGlubGluZU1hdGNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGVkaXRvci51bmRvTWFuYWdlci50cmFuc2FjdCgoKSA9PiB7XG4gICAgICAgICAgICBhcHBseU1hdGNoZXMoZWRpdG9yLCBpbmxpbmVNYXRjaGVzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgY2hlY2tLZXlFdmVudCA9IChjb2RlcywgZXZlbnQsIHByZWRpY2F0ZSkgPT4ge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocHJlZGljYXRlKGNvZGVzW2ldLCBldmVudCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgY29uc3QgY2hlY2tLZXlDb2RlID0gKGNvZGVzLCBldmVudCkgPT4gY2hlY2tLZXlFdmVudChjb2RlcywgZXZlbnQsIChjb2RlLCBldmVudCkgPT4ge1xuICAgICAgcmV0dXJuIGNvZGUgPT09IGV2ZW50LmtleUNvZGUgJiYgVksubW9kaWZpZXJQcmVzc2VkKGV2ZW50KSA9PT0gZmFsc2U7XG4gICAgfSk7XG4gICAgY29uc3QgY2hlY2tDaGFyQ29kZSA9IChjaGFycywgZXZlbnQpID0+IGNoZWNrS2V5RXZlbnQoY2hhcnMsIGV2ZW50LCAoY2hyLCBldmVudCkgPT4ge1xuICAgICAgcmV0dXJuIGNoci5jaGFyQ29kZUF0KDApID09PSBldmVudC5jaGFyQ29kZTtcbiAgICB9KTtcblxuICAgIGNvbnN0IHNldHVwJDIgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgY2hhckNvZGVzID0gW1xuICAgICAgICAnLCcsXG4gICAgICAgICcuJyxcbiAgICAgICAgJzsnLFxuICAgICAgICAnOicsXG4gICAgICAgICchJyxcbiAgICAgICAgJz8nXG4gICAgICBdO1xuICAgICAgY29uc3Qga2V5Q29kZXMgPSBbMzJdO1xuICAgICAgY29uc3QgZ2V0UGF0dGVyblNldCA9ICgpID0+IGNyZWF0ZVBhdHRlcm5TZXQoZ2V0VGV4dFBhdHRlcm5zKGVkaXRvcikpO1xuICAgICAgY29uc3QgZ2V0SW5saW5lUGF0dGVybnMkMSA9ICgpID0+IGdldElubGluZVBhdHRlcm5zKGdldFRleHRQYXR0ZXJucyhlZGl0b3IpKTtcbiAgICAgIGVkaXRvci5vbigna2V5ZG93bicsIGUgPT4ge1xuICAgICAgICBpZiAoZS5rZXlDb2RlID09PSAxMyAmJiAhVksubW9kaWZpZXJQcmVzc2VkKGUpKSB7XG4gICAgICAgICAgaWYgKGhhbmRsZUVudGVyKGVkaXRvciwgZ2V0UGF0dGVyblNldCgpKSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgdHJ1ZSk7XG4gICAgICBlZGl0b3Iub24oJ2tleXVwJywgZSA9PiB7XG4gICAgICAgIGlmIChjaGVja0tleUNvZGUoa2V5Q29kZXMsIGUpKSB7XG4gICAgICAgICAgaGFuZGxlSW5saW5lS2V5KGVkaXRvciwgZ2V0SW5saW5lUGF0dGVybnMkMSgpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBlZGl0b3Iub24oJ2tleXByZXNzJywgZSA9PiB7XG4gICAgICAgIGlmIChjaGVja0NoYXJDb2RlKGNoYXJDb2RlcywgZSkpIHtcbiAgICAgICAgICBEZWxheS5zZXRFZGl0b3JUaW1lb3V0KGVkaXRvciwgKCkgPT4ge1xuICAgICAgICAgICAgaGFuZGxlSW5saW5lS2V5KGVkaXRvciwgZ2V0SW5saW5lUGF0dGVybnMkMSgpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IHNldHVwJDEgPSBlZGl0b3IgPT4ge1xuICAgICAgc2V0dXAkMihlZGl0b3IpO1xuICAgIH07XG5cbiAgICBjb25zdCBRdWlya3MgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgZWFjaCA9IFRvb2xzLmVhY2g7XG4gICAgICBjb25zdCBCQUNLU1BBQ0UgPSBWSy5CQUNLU1BBQ0UsIERFTEVURSA9IFZLLkRFTEVURSwgZG9tID0gZWRpdG9yLmRvbSwgc2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbiwgcGFyc2VyID0gZWRpdG9yLnBhcnNlcjtcbiAgICAgIGNvbnN0IGJyb3dzZXIgPSBFbnYuYnJvd3NlcjtcbiAgICAgIGNvbnN0IGlzR2Vja28gPSBicm93c2VyLmlzRmlyZWZveCgpO1xuICAgICAgY29uc3QgaXNXZWJLaXQgPSBicm93c2VyLmlzQ2hyb21pdW0oKSB8fCBicm93c2VyLmlzU2FmYXJpKCk7XG4gICAgICBjb25zdCBpc2lPUyA9IEVudi5kZXZpY2VUeXBlLmlzaVBob25lKCkgfHwgRW52LmRldmljZVR5cGUuaXNpUGFkKCk7XG4gICAgICBjb25zdCBpc01hYyA9IEVudi5vcy5pc01hY09TKCkgfHwgRW52Lm9zLmlzaU9TKCk7XG4gICAgICBjb25zdCBzZXRFZGl0b3JDb21tYW5kU3RhdGUgPSAoY21kLCBzdGF0ZSkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGVkaXRvci5nZXREb2MoKS5leGVjQ29tbWFuZChjbWQsIGZhbHNlLCBzdGF0ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBpc0RlZmF1bHRQcmV2ZW50ZWQgPSBlID0+IHtcbiAgICAgICAgcmV0dXJuIGUuaXNEZWZhdWx0UHJldmVudGVkKCk7XG4gICAgICB9O1xuICAgICAgY29uc3QgZW1wdHlFZGl0b3JXaGVuRGVsZXRpbmcgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHNlcmlhbGl6ZVJuZyA9IHJuZyA9PiB7XG4gICAgICAgICAgY29uc3QgYm9keSA9IGRvbS5jcmVhdGUoJ2JvZHknKTtcbiAgICAgICAgICBjb25zdCBjb250ZW50cyA9IHJuZy5jbG9uZUNvbnRlbnRzKCk7XG4gICAgICAgICAgYm9keS5hcHBlbmRDaGlsZChjb250ZW50cyk7XG4gICAgICAgICAgcmV0dXJuIHNlbGVjdGlvbi5zZXJpYWxpemVyLnNlcmlhbGl6ZShib2R5LCB7IGZvcm1hdDogJ2h0bWwnIH0pO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBhbGxDb250ZW50c1NlbGVjdGVkID0gcm5nID0+IHtcbiAgICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBzZXJpYWxpemVSbmcocm5nKTtcbiAgICAgICAgICBjb25zdCBhbGxSbmcgPSBkb20uY3JlYXRlUm5nKCk7XG4gICAgICAgICAgYWxsUm5nLnNlbGVjdE5vZGUoZWRpdG9yLmdldEJvZHkoKSk7XG4gICAgICAgICAgY29uc3QgYWxsU2VsZWN0aW9uID0gc2VyaWFsaXplUm5nKGFsbFJuZyk7XG4gICAgICAgICAgcmV0dXJuIHNlbGVjdGlvbiA9PT0gYWxsU2VsZWN0aW9uO1xuICAgICAgICB9O1xuICAgICAgICBlZGl0b3Iub24oJ2tleWRvd24nLCBlID0+IHtcbiAgICAgICAgICBjb25zdCBrZXlDb2RlID0gZS5rZXlDb2RlO1xuICAgICAgICAgIGxldCBpc0NvbGxhcHNlZCwgYm9keTtcbiAgICAgICAgICBpZiAoIWlzRGVmYXVsdFByZXZlbnRlZChlKSAmJiAoa2V5Q29kZSA9PT0gREVMRVRFIHx8IGtleUNvZGUgPT09IEJBQ0tTUEFDRSkpIHtcbiAgICAgICAgICAgIGlzQ29sbGFwc2VkID0gZWRpdG9yLnNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpO1xuICAgICAgICAgICAgYm9keSA9IGVkaXRvci5nZXRCb2R5KCk7XG4gICAgICAgICAgICBpZiAoaXNDb2xsYXBzZWQgJiYgIWRvbS5pc0VtcHR5KGJvZHkpKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNDb2xsYXBzZWQgJiYgIWFsbENvbnRlbnRzU2VsZWN0ZWQoZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZWRpdG9yLnNldENvbnRlbnQoJycpO1xuICAgICAgICAgICAgaWYgKGJvZHkuZmlyc3RDaGlsZCAmJiBkb20uaXNCbG9jayhib2R5LmZpcnN0Q2hpbGQpKSB7XG4gICAgICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2V0Q3Vyc29yTG9jYXRpb24oYm9keS5maXJzdENoaWxkLCAwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2V0Q3Vyc29yTG9jYXRpb24oYm9keSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlZGl0b3Iubm9kZUNoYW5nZWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHNlbGVjdEFsbCA9ICgpID0+IHtcbiAgICAgICAgZWRpdG9yLnNob3J0Y3V0cy5hZGQoJ21ldGErYScsIG51bGwsICdTZWxlY3RBbGwnKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBkb2N1bWVudEVsZW1lbnRFZGl0aW5nRm9jdXMgPSAoKSA9PiB7XG4gICAgICAgIGlmICghZWRpdG9yLmlubGluZSkge1xuICAgICAgICAgIGRvbS5iaW5kKGVkaXRvci5nZXREb2MoKSwgJ21vdXNlZG93biBtb3VzZXVwJywgZSA9PiB7XG4gICAgICAgICAgICBsZXQgcm5nO1xuICAgICAgICAgICAgaWYgKGUudGFyZ2V0ID09PSBlZGl0b3IuZ2V0RG9jKCkuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICAgICAgICAgIHJuZyA9IHNlbGVjdGlvbi5nZXRSbmcoKTtcbiAgICAgICAgICAgICAgZWRpdG9yLmdldEJvZHkoKS5mb2N1cygpO1xuICAgICAgICAgICAgICBpZiAoZS50eXBlID09PSAnbW91c2Vkb3duJykge1xuICAgICAgICAgICAgICAgIGlmIChpc0NhcmV0Q29udGFpbmVyJDIocm5nLnN0YXJ0Q29udGFpbmVyKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24ucGxhY2VDYXJldEF0KGUuY2xpZW50WCwgZS5jbGllbnRZKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24uc2V0Um5nKHJuZyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlbW92ZUhyT25CYWNrc3BhY2UgPSAoKSA9PiB7XG4gICAgICAgIGVkaXRvci5vbigna2V5ZG93bicsIGUgPT4ge1xuICAgICAgICAgIGlmICghaXNEZWZhdWx0UHJldmVudGVkKGUpICYmIGUua2V5Q29kZSA9PT0gQkFDS1NQQUNFKSB7XG4gICAgICAgICAgICBpZiAoIWVkaXRvci5nZXRCb2R5KCkuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hyJykubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSAmJiBzZWxlY3Rpb24uZ2V0Um5nKCkuc3RhcnRPZmZzZXQgPT09IDApIHtcbiAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHNlbGVjdGlvbi5nZXROb2RlKCk7XG4gICAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzU2libGluZyA9IG5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgICBpZiAobm9kZS5ub2RlTmFtZSA9PT0gJ0hSJykge1xuICAgICAgICAgICAgICAgIGRvbS5yZW1vdmUobm9kZSk7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocHJldmlvdXNTaWJsaW5nICYmIHByZXZpb3VzU2libGluZy5ub2RlTmFtZSAmJiBwcmV2aW91c1NpYmxpbmcubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2hyJykge1xuICAgICAgICAgICAgICAgIGRvbS5yZW1vdmUocHJldmlvdXNTaWJsaW5nKTtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGZvY3VzQm9keSA9ICgpID0+IHtcbiAgICAgICAgaWYgKCFSYW5nZS5wcm90b3R5cGUuZ2V0Q2xpZW50UmVjdHMpIHtcbiAgICAgICAgICBlZGl0b3Iub24oJ21vdXNlZG93bicsIGUgPT4ge1xuICAgICAgICAgICAgaWYgKCFpc0RlZmF1bHRQcmV2ZW50ZWQoZSkgJiYgZS50YXJnZXQubm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgICAgICAgICAgICBjb25zdCBib2R5ID0gZWRpdG9yLmdldEJvZHkoKTtcbiAgICAgICAgICAgICAgYm9keS5ibHVyKCk7XG4gICAgICAgICAgICAgIERlbGF5LnNldEVkaXRvclRpbWVvdXQoZWRpdG9yLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgYm9keS5mb2N1cygpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHNlbGVjdENvbnRyb2xFbGVtZW50cyA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgdmlzdWFsQWlkc0FuY2hvckNsYXNzID0gZ2V0VmlzdWFsQWlkc0FuY2hvckNsYXNzKGVkaXRvcik7XG4gICAgICAgIGVkaXRvci5vbignY2xpY2snLCBlID0+IHtcbiAgICAgICAgICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldDtcbiAgICAgICAgICBpZiAoL14oSU1HfEhSKSQvLnRlc3QodGFyZ2V0Lm5vZGVOYW1lKSAmJiBkb20uZ2V0Q29udGVudEVkaXRhYmxlUGFyZW50KHRhcmdldCkgIT09ICdmYWxzZScpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2VsZWN0KHRhcmdldCk7XG4gICAgICAgICAgICBlZGl0b3Iubm9kZUNoYW5nZWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRhcmdldC5ub2RlTmFtZSA9PT0gJ0EnICYmIGRvbS5oYXNDbGFzcyh0YXJnZXQsIHZpc3VhbEFpZHNBbmNob3JDbGFzcykgJiYgdGFyZ2V0LmNoaWxkTm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBzZWxlY3Rpb24uc2VsZWN0KHRhcmdldCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBjb25zdCByZW1vdmVTdHlsZXNXaGVuRGVsZXRpbmdBY3Jvc3NCbG9ja0VsZW1lbnRzID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBnZXRBdHRyaWJ1dGVBcHBseUZ1bmN0aW9uID0gKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHRlbXBsYXRlID0gZG9tLmdldEF0dHJpYnMoc2VsZWN0aW9uLmdldFN0YXJ0KCkuY2xvbmVOb2RlKGZhbHNlKSk7XG4gICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHNlbGVjdGlvbi5nZXRTdGFydCgpO1xuICAgICAgICAgICAgaWYgKHRhcmdldCAhPT0gZWRpdG9yLmdldEJvZHkoKSkge1xuICAgICAgICAgICAgICBkb20uc2V0QXR0cmliKHRhcmdldCwgJ3N0eWxlJywgbnVsbCk7XG4gICAgICAgICAgICAgIGVhY2godGVtcGxhdGUsIGF0dHIgPT4ge1xuICAgICAgICAgICAgICAgIHRhcmdldC5zZXRBdHRyaWJ1dGVOb2RlKGF0dHIuY2xvbmVOb2RlKHRydWUpKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgaXNTZWxlY3Rpb25BY3Jvc3NFbGVtZW50cyA9ICgpID0+IHtcbiAgICAgICAgICByZXR1cm4gIXNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpICYmIGRvbS5nZXRQYXJlbnQoc2VsZWN0aW9uLmdldFN0YXJ0KCksIGRvbS5pc0Jsb2NrKSAhPT0gZG9tLmdldFBhcmVudChzZWxlY3Rpb24uZ2V0RW5kKCksIGRvbS5pc0Jsb2NrKTtcbiAgICAgICAgfTtcbiAgICAgICAgZWRpdG9yLm9uKCdrZXlwcmVzcycsIGUgPT4ge1xuICAgICAgICAgIGxldCBhcHBseUF0dHJpYnV0ZXM7XG4gICAgICAgICAgaWYgKCFpc0RlZmF1bHRQcmV2ZW50ZWQoZSkgJiYgKGUua2V5Q29kZSA9PT0gOCB8fCBlLmtleUNvZGUgPT09IDQ2KSAmJiBpc1NlbGVjdGlvbkFjcm9zc0VsZW1lbnRzKCkpIHtcbiAgICAgICAgICAgIGFwcGx5QXR0cmlidXRlcyA9IGdldEF0dHJpYnV0ZUFwcGx5RnVuY3Rpb24oKTtcbiAgICAgICAgICAgIGVkaXRvci5nZXREb2MoKS5leGVjQ29tbWFuZCgnZGVsZXRlJywgZmFsc2UsIG51bGwpO1xuICAgICAgICAgICAgYXBwbHlBdHRyaWJ1dGVzKCk7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZG9tLmJpbmQoZWRpdG9yLmdldERvYygpLCAnY3V0JywgZSA9PiB7XG4gICAgICAgICAgbGV0IGFwcGx5QXR0cmlidXRlcztcbiAgICAgICAgICBpZiAoIWlzRGVmYXVsdFByZXZlbnRlZChlKSAmJiBpc1NlbGVjdGlvbkFjcm9zc0VsZW1lbnRzKCkpIHtcbiAgICAgICAgICAgIGFwcGx5QXR0cmlidXRlcyA9IGdldEF0dHJpYnV0ZUFwcGx5RnVuY3Rpb24oKTtcbiAgICAgICAgICAgIERlbGF5LnNldEVkaXRvclRpbWVvdXQoZWRpdG9yLCAoKSA9PiB7XG4gICAgICAgICAgICAgIGFwcGx5QXR0cmlidXRlcygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBjb25zdCBkaXNhYmxlQmFja3NwYWNlSW50b0FUYWJsZSA9ICgpID0+IHtcbiAgICAgICAgZWRpdG9yLm9uKCdrZXlkb3duJywgZSA9PiB7XG4gICAgICAgICAgaWYgKCFpc0RlZmF1bHRQcmV2ZW50ZWQoZSkgJiYgZS5rZXlDb2RlID09PSBCQUNLU1BBQ0UpIHtcbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSAmJiBzZWxlY3Rpb24uZ2V0Um5nKCkuc3RhcnRPZmZzZXQgPT09IDApIHtcbiAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXNTaWJsaW5nID0gc2VsZWN0aW9uLmdldE5vZGUoKS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICAgIGlmIChwcmV2aW91c1NpYmxpbmcgJiYgcHJldmlvdXNTaWJsaW5nLm5vZGVOYW1lICYmIHByZXZpb3VzU2libGluZy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAndGFibGUnKSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgcmVtb3ZlQmxvY2tRdW90ZU9uQmFja1NwYWNlID0gKCkgPT4ge1xuICAgICAgICBlZGl0b3Iub24oJ2tleWRvd24nLCBlID0+IHtcbiAgICAgICAgICBsZXQgcm5nLCBwYXJlbnQ7XG4gICAgICAgICAgaWYgKGlzRGVmYXVsdFByZXZlbnRlZChlKSB8fCBlLmtleUNvZGUgIT09IFZLLkJBQ0tTUEFDRSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBybmcgPSBzZWxlY3Rpb24uZ2V0Um5nKCk7XG4gICAgICAgICAgY29uc3QgY29udGFpbmVyID0gcm5nLnN0YXJ0Q29udGFpbmVyO1xuICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHJuZy5zdGFydE9mZnNldDtcbiAgICAgICAgICBjb25zdCByb290ID0gZG9tLmdldFJvb3QoKTtcbiAgICAgICAgICBwYXJlbnQgPSBjb250YWluZXI7XG4gICAgICAgICAgaWYgKCFybmcuY29sbGFwc2VkIHx8IG9mZnNldCAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAocGFyZW50ICYmIHBhcmVudC5wYXJlbnROb2RlICYmIHBhcmVudC5wYXJlbnROb2RlLmZpcnN0Q2hpbGQgPT09IHBhcmVudCAmJiBwYXJlbnQucGFyZW50Tm9kZSAhPT0gcm9vdCkge1xuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwYXJlbnQudGFnTmFtZSA9PT0gJ0JMT0NLUVVPVEUnKSB7XG4gICAgICAgICAgICBlZGl0b3IuZm9ybWF0dGVyLnRvZ2dsZSgnYmxvY2txdW90ZScsIG51bGwsIHBhcmVudCk7XG4gICAgICAgICAgICBybmcgPSBkb20uY3JlYXRlUm5nKCk7XG4gICAgICAgICAgICBybmcuc2V0U3RhcnQoY29udGFpbmVyLCAwKTtcbiAgICAgICAgICAgIHJuZy5zZXRFbmQoY29udGFpbmVyLCAwKTtcbiAgICAgICAgICAgIHNlbGVjdGlvbi5zZXRSbmcocm5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHNldEdlY2tvRWRpdGluZ09wdGlvbnMgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHNldE9wdHMgPSAoKSA9PiB7XG4gICAgICAgICAgc2V0RWRpdG9yQ29tbWFuZFN0YXRlKCdTdHlsZVdpdGhDU1MnLCBmYWxzZSk7XG4gICAgICAgICAgc2V0RWRpdG9yQ29tbWFuZFN0YXRlKCdlbmFibGVJbmxpbmVUYWJsZUVkaXRpbmcnLCBmYWxzZSk7XG4gICAgICAgICAgaWYgKCFnZXRPYmplY3RSZXNpemluZyhlZGl0b3IpKSB7XG4gICAgICAgICAgICBzZXRFZGl0b3JDb21tYW5kU3RhdGUoJ2VuYWJsZU9iamVjdFJlc2l6aW5nJywgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFpc1JlYWRPbmx5JDEoZWRpdG9yKSkge1xuICAgICAgICAgIGVkaXRvci5vbignQmVmb3JlRXhlY0NvbW1hbmQgbW91c2Vkb3duJywgc2V0T3B0cyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBhZGRCckFmdGVyTGFzdExpbmtzID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBmaXhMaW5rcyA9ICgpID0+IHtcbiAgICAgICAgICBlYWNoKGRvbS5zZWxlY3QoJ2EnKSwgbm9kZSA9PiB7XG4gICAgICAgICAgICBsZXQgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBkb20uZ2V0Um9vdCgpO1xuICAgICAgICAgICAgaWYgKHBhcmVudE5vZGUubGFzdENoaWxkID09PSBub2RlKSB7XG4gICAgICAgICAgICAgIHdoaWxlIChwYXJlbnROb2RlICYmICFkb20uaXNCbG9jayhwYXJlbnROb2RlKSkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnROb2RlLnBhcmVudE5vZGUubGFzdENoaWxkICE9PSBwYXJlbnROb2RlIHx8IHBhcmVudE5vZGUgPT09IHJvb3QpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkb20uYWRkKHBhcmVudE5vZGUsICdicicsIHsgJ2RhdGEtbWNlLWJvZ3VzJzogMSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgZWRpdG9yLm9uKCdTZXRDb250ZW50IEV4ZWNDb21tYW5kJywgZSA9PiB7XG4gICAgICAgICAgaWYgKGUudHlwZSA9PT0gJ3NldGNvbnRlbnQnIHx8IGUuY29tbWFuZCA9PT0gJ21jZUluc2VydExpbmsnKSB7XG4gICAgICAgICAgICBmaXhMaW5rcygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3Qgc2V0RGVmYXVsdEJsb2NrVHlwZSA9ICgpID0+IHtcbiAgICAgICAgZWRpdG9yLm9uKCdpbml0JywgKCkgPT4ge1xuICAgICAgICAgIHNldEVkaXRvckNvbW1hbmRTdGF0ZSgnRGVmYXVsdFBhcmFncmFwaFNlcGFyYXRvcicsIGdldEZvcmNlZFJvb3RCbG9jayhlZGl0b3IpKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3Qgbm9ybWFsaXplU2VsZWN0aW9uID0gKCkgPT4ge1xuICAgICAgICBlZGl0b3Iub24oJ2tleXVwIGZvY3VzaW4gbW91c2V1cCcsIGUgPT4ge1xuICAgICAgICAgIGlmICghVksubW9kaWZpZXJQcmVzc2VkKGUpKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb24ubm9ybWFsaXplKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB0cnVlKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBzaG93QnJva2VuSW1hZ2VJY29uID0gKCkgPT4ge1xuICAgICAgICBlZGl0b3IuY29udGVudFN0eWxlcy5wdXNoKCdpbWc6LW1vei1icm9rZW4geycgKyAnLW1vei1mb3JjZS1icm9rZW4taW1hZ2UtaWNvbjoxOycgKyAnbWluLXdpZHRoOjI0cHg7JyArICdtaW4taGVpZ2h0OjI0cHgnICsgJ30nKTtcbiAgICAgIH07XG4gICAgICBjb25zdCByZXN0b3JlRm9jdXNPbktleURvd24gPSAoKSA9PiB7XG4gICAgICAgIGlmICghZWRpdG9yLmlubGluZSkge1xuICAgICAgICAgIGVkaXRvci5vbigna2V5ZG93bicsICgpID0+IHtcbiAgICAgICAgICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgICAgIGVkaXRvci5nZXRXaW4oKS5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgYm9keUhlaWdodCA9ICgpID0+IHtcbiAgICAgICAgaWYgKCFlZGl0b3IuaW5saW5lKSB7XG4gICAgICAgICAgZWRpdG9yLmNvbnRlbnRTdHlsZXMucHVzaCgnYm9keSB7bWluLWhlaWdodDogMTUwcHh9Jyk7XG4gICAgICAgICAgZWRpdG9yLm9uKCdjbGljaycsIGUgPT4ge1xuICAgICAgICAgICAgbGV0IHJuZztcbiAgICAgICAgICAgIGlmIChlLnRhcmdldC5ub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgICAgICAgICAgIHJuZyA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCk7XG4gICAgICAgICAgICAgIGVkaXRvci5nZXRCb2R5KCkuZm9jdXMoKTtcbiAgICAgICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZXRSbmcocm5nKTtcbiAgICAgICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgICAgZWRpdG9yLm5vZGVDaGFuZ2VkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBibG9ja0NtZEFycm93TmF2aWdhdGlvbiA9ICgpID0+IHtcbiAgICAgICAgaWYgKGlzTWFjKSB7XG4gICAgICAgICAgZWRpdG9yLm9uKCdrZXlkb3duJywgZSA9PiB7XG4gICAgICAgICAgICBpZiAoVksubWV0YUtleVByZXNzZWQoZSkgJiYgIWUuc2hpZnRLZXkgJiYgKGUua2V5Q29kZSA9PT0gMzcgfHwgZS5rZXlDb2RlID09PSAzOSkpIHtcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uLmdldFNlbCgpO1xuICAgICAgICAgICAgICBzZWxlY3Rpb24ubW9kaWZ5KCdtb3ZlJywgZS5rZXlDb2RlID09PSAzNyA/ICdiYWNrd2FyZCcgOiAnZm9yd2FyZCcsICdsaW5lYm91bmRhcnknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHRhcExpbmtzQW5kSW1hZ2VzID0gKCkgPT4ge1xuICAgICAgICBlZGl0b3Iub24oJ2NsaWNrJywgZSA9PiB7XG4gICAgICAgICAgbGV0IGVsbSA9IGUudGFyZ2V0O1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmIChlbG0udGFnTmFtZSA9PT0gJ0EnKSB7XG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gd2hpbGUgKGVsbSA9IGVsbS5wYXJlbnROb2RlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVkaXRvci5jb250ZW50U3R5bGVzLnB1c2goJy5tY2UtY29udGVudC1ib2R5IHstd2Via2l0LXRvdWNoLWNhbGxvdXQ6IG5vbmV9Jyk7XG4gICAgICB9O1xuICAgICAgY29uc3QgYmxvY2tGb3JtU3VibWl0SW5zaWRlRWRpdG9yID0gKCkgPT4ge1xuICAgICAgICBlZGl0b3Iub24oJ2luaXQnLCAoKSA9PiB7XG4gICAgICAgICAgZWRpdG9yLmRvbS5iaW5kKGVkaXRvci5nZXRCb2R5KCksICdzdWJtaXQnLCBlID0+IHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgcmVtb3ZlQXBwbGVJbnRlcmNoYW5nZUJycyA9ICgpID0+IHtcbiAgICAgICAgcGFyc2VyLmFkZE5vZGVGaWx0ZXIoJ2JyJywgbm9kZXMgPT4ge1xuICAgICAgICAgIGxldCBpID0gbm9kZXMubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIGlmIChub2Rlc1tpXS5hdHRyKCdjbGFzcycpID09PSAnQXBwbGUtaW50ZXJjaGFuZ2UtbmV3bGluZScpIHtcbiAgICAgICAgICAgICAgbm9kZXNbaV0ucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBjb25zdCByZWZyZXNoQ29udGVudEVkaXRhYmxlID0gbm9vcDtcbiAgICAgIGNvbnN0IGlzSGlkZGVuID0gKCkgPT4ge1xuICAgICAgICBpZiAoIWlzR2Vja28gfHwgZWRpdG9yLnJlbW92ZWQpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VsID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRTZWwoKTtcbiAgICAgICAgcmV0dXJuICFzZWwgfHwgIXNlbC5yYW5nZUNvdW50IHx8IHNlbC5yYW5nZUNvdW50ID09PSAwO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHNldHVwUnRjID0gKCkgPT4ge1xuICAgICAgICBpZiAoaXNXZWJLaXQpIHtcbiAgICAgICAgICBkb2N1bWVudEVsZW1lbnRFZGl0aW5nRm9jdXMoKTtcbiAgICAgICAgICBzZWxlY3RDb250cm9sRWxlbWVudHMoKTtcbiAgICAgICAgICBibG9ja0Zvcm1TdWJtaXRJbnNpZGVFZGl0b3IoKTtcbiAgICAgICAgICBzZWxlY3RBbGwoKTtcbiAgICAgICAgICBpZiAoaXNpT1MpIHtcbiAgICAgICAgICAgIHJlc3RvcmVGb2N1c09uS2V5RG93bigpO1xuICAgICAgICAgICAgYm9keUhlaWdodCgpO1xuICAgICAgICAgICAgdGFwTGlua3NBbmRJbWFnZXMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzR2Vja28pIHtcbiAgICAgICAgICBmb2N1c0JvZHkoKTtcbiAgICAgICAgICBzZXRHZWNrb0VkaXRpbmdPcHRpb25zKCk7XG4gICAgICAgICAgc2hvd0Jyb2tlbkltYWdlSWNvbigpO1xuICAgICAgICAgIGJsb2NrQ21kQXJyb3dOYXZpZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBzZXR1cCA9ICgpID0+IHtcbiAgICAgICAgcmVtb3ZlQmxvY2tRdW90ZU9uQmFja1NwYWNlKCk7XG4gICAgICAgIGVtcHR5RWRpdG9yV2hlbkRlbGV0aW5nKCk7XG4gICAgICAgIGlmICghRW52LndpbmRvd3NQaG9uZSkge1xuICAgICAgICAgIG5vcm1hbGl6ZVNlbGVjdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1dlYktpdCkge1xuICAgICAgICAgIGRvY3VtZW50RWxlbWVudEVkaXRpbmdGb2N1cygpO1xuICAgICAgICAgIHNlbGVjdENvbnRyb2xFbGVtZW50cygpO1xuICAgICAgICAgIHNldERlZmF1bHRCbG9ja1R5cGUoKTtcbiAgICAgICAgICBibG9ja0Zvcm1TdWJtaXRJbnNpZGVFZGl0b3IoKTtcbiAgICAgICAgICBkaXNhYmxlQmFja3NwYWNlSW50b0FUYWJsZSgpO1xuICAgICAgICAgIHJlbW92ZUFwcGxlSW50ZXJjaGFuZ2VCcnMoKTtcbiAgICAgICAgICBpZiAoaXNpT1MpIHtcbiAgICAgICAgICAgIHJlc3RvcmVGb2N1c09uS2V5RG93bigpO1xuICAgICAgICAgICAgYm9keUhlaWdodCgpO1xuICAgICAgICAgICAgdGFwTGlua3NBbmRJbWFnZXMoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZWN0QWxsKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc0dlY2tvKSB7XG4gICAgICAgICAgcmVtb3ZlSHJPbkJhY2tzcGFjZSgpO1xuICAgICAgICAgIGZvY3VzQm9keSgpO1xuICAgICAgICAgIHJlbW92ZVN0eWxlc1doZW5EZWxldGluZ0Fjcm9zc0Jsb2NrRWxlbWVudHMoKTtcbiAgICAgICAgICBzZXRHZWNrb0VkaXRpbmdPcHRpb25zKCk7XG4gICAgICAgICAgYWRkQnJBZnRlckxhc3RMaW5rcygpO1xuICAgICAgICAgIHNob3dCcm9rZW5JbWFnZUljb24oKTtcbiAgICAgICAgICBibG9ja0NtZEFycm93TmF2aWdhdGlvbigpO1xuICAgICAgICAgIGRpc2FibGVCYWNrc3BhY2VJbnRvQVRhYmxlKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAoaXNSdGMoZWRpdG9yKSkge1xuICAgICAgICBzZXR1cFJ0YygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0dXAoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlZnJlc2hDb250ZW50RWRpdGFibGUsXG4gICAgICAgIGlzSGlkZGVuXG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCBET00kNiA9IERPTVV0aWxzLkRPTTtcbiAgICBjb25zdCBhcHBlbmRTdHlsZSA9IChlZGl0b3IsIHRleHQpID0+IHtcbiAgICAgIGNvbnN0IGJvZHkgPSBTdWdhckVsZW1lbnQuZnJvbURvbShlZGl0b3IuZ2V0Qm9keSgpKTtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGdldFN0eWxlQ29udGFpbmVyKGdldFJvb3ROb2RlKGJvZHkpKTtcbiAgICAgIGNvbnN0IHN0eWxlID0gU3VnYXJFbGVtZW50LmZyb21UYWcoJ3N0eWxlJyk7XG4gICAgICBzZXQkMihzdHlsZSwgJ3R5cGUnLCAndGV4dC9jc3MnKTtcbiAgICAgIGFwcGVuZCQxKHN0eWxlLCBTdWdhckVsZW1lbnQuZnJvbVRleHQodGV4dCkpO1xuICAgICAgYXBwZW5kJDEoY29udGFpbmVyLCBzdHlsZSk7XG4gICAgICBlZGl0b3Iub24oJ3JlbW92ZScsICgpID0+IHtcbiAgICAgICAgcmVtb3ZlJDUoc3R5bGUpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBnZXRSb290TmFtZSA9IGVkaXRvciA9PiBlZGl0b3IuaW5saW5lID8gZWRpdG9yLmdldEVsZW1lbnQoKS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IHJlbW92ZVVuZGVmaW5lZCA9IG9iaiA9PiBmaWx0ZXIkNShvYmosIHYgPT4gaXNVbmRlZmluZWQodikgPT09IGZhbHNlKTtcbiAgICBjb25zdCBta1BhcnNlclNldHRpbmdzID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IGdldE9wdGlvbiA9IGVkaXRvci5vcHRpb25zLmdldDtcbiAgICAgIGNvbnN0IGJsb2JDYWNoZSA9IGVkaXRvci5lZGl0b3JVcGxvYWQuYmxvYkNhY2hlO1xuICAgICAgcmV0dXJuIHJlbW92ZVVuZGVmaW5lZCh7XG4gICAgICAgIGFsbG93X2NvbmRpdGlvbmFsX2NvbW1lbnRzOiBnZXRPcHRpb24oJ2FsbG93X2NvbmRpdGlvbmFsX2NvbW1lbnRzJyksXG4gICAgICAgIGFsbG93X2h0bWxfZGF0YV91cmxzOiBnZXRPcHRpb24oJ2FsbG93X2h0bWxfZGF0YV91cmxzJyksXG4gICAgICAgIGFsbG93X3N2Z19kYXRhX3VybHM6IGdldE9wdGlvbignYWxsb3dfc3ZnX2RhdGFfdXJscycpLFxuICAgICAgICBhbGxvd19odG1sX2luX25hbWVkX2FuY2hvcjogZ2V0T3B0aW9uKCdhbGxvd19odG1sX2luX25hbWVkX2FuY2hvcicpLFxuICAgICAgICBhbGxvd19zY3JpcHRfdXJsczogZ2V0T3B0aW9uKCdhbGxvd19zY3JpcHRfdXJscycpLFxuICAgICAgICBhbGxvd191bnNhZmVfbGlua190YXJnZXQ6IGdldE9wdGlvbignYWxsb3dfdW5zYWZlX2xpbmtfdGFyZ2V0JyksXG4gICAgICAgIGNvbnZlcnRfZm9udHNfdG9fc3BhbnM6IGdldE9wdGlvbignY29udmVydF9mb250c190b19zcGFucycpLFxuICAgICAgICBmaXhfbGlzdF9lbGVtZW50czogZ2V0T3B0aW9uKCdmaXhfbGlzdF9lbGVtZW50cycpLFxuICAgICAgICBmb250X3NpemVfbGVnYWN5X3ZhbHVlczogZ2V0T3B0aW9uKCdmb250X3NpemVfbGVnYWN5X3ZhbHVlcycpLFxuICAgICAgICBmb3JjZWRfcm9vdF9ibG9jazogZ2V0T3B0aW9uKCdmb3JjZWRfcm9vdF9ibG9jaycpLFxuICAgICAgICBmb3JjZWRfcm9vdF9ibG9ja19hdHRyczogZ2V0T3B0aW9uKCdmb3JjZWRfcm9vdF9ibG9ja19hdHRycycpLFxuICAgICAgICBwcmVzZXJ2ZV9jZGF0YTogZ2V0T3B0aW9uKCdwcmVzZXJ2ZV9jZGF0YScpLFxuICAgICAgICByZW1vdmVfdHJhaWxpbmdfYnJzOiBnZXRPcHRpb24oJ3JlbW92ZV90cmFpbGluZ19icnMnKSxcbiAgICAgICAgaW5saW5lX3N0eWxlczogZ2V0T3B0aW9uKCdpbmxpbmVfc3R5bGVzJyksXG4gICAgICAgIHJvb3RfbmFtZTogZ2V0Um9vdE5hbWUoZWRpdG9yKSxcbiAgICAgICAgdmFsaWRhdGU6IHRydWUsXG4gICAgICAgIGJsb2JfY2FjaGU6IGJsb2JDYWNoZSxcbiAgICAgICAgZG9jdW1lbnQ6IGVkaXRvci5nZXREb2MoKVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBta1NjaGVtYVNldHRpbmdzID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IGdldE9wdGlvbiA9IGVkaXRvci5vcHRpb25zLmdldDtcbiAgICAgIHJldHVybiByZW1vdmVVbmRlZmluZWQoe1xuICAgICAgICBjdXN0b21fZWxlbWVudHM6IGdldE9wdGlvbignY3VzdG9tX2VsZW1lbnRzJyksXG4gICAgICAgIGV4dGVuZGVkX3ZhbGlkX2VsZW1lbnRzOiBnZXRPcHRpb24oJ2V4dGVuZGVkX3ZhbGlkX2VsZW1lbnRzJyksXG4gICAgICAgIGludmFsaWRfZWxlbWVudHM6IGdldE9wdGlvbignaW52YWxpZF9lbGVtZW50cycpLFxuICAgICAgICBpbnZhbGlkX3N0eWxlczogZ2V0T3B0aW9uKCdpbnZhbGlkX3N0eWxlcycpLFxuICAgICAgICBzY2hlbWE6IGdldE9wdGlvbignc2NoZW1hJyksXG4gICAgICAgIHZhbGlkX2NoaWxkcmVuOiBnZXRPcHRpb24oJ3ZhbGlkX2NoaWxkcmVuJyksXG4gICAgICAgIHZhbGlkX2NsYXNzZXM6IGdldE9wdGlvbigndmFsaWRfY2xhc3NlcycpLFxuICAgICAgICB2YWxpZF9lbGVtZW50czogZ2V0T3B0aW9uKCd2YWxpZF9lbGVtZW50cycpLFxuICAgICAgICB2YWxpZF9zdHlsZXM6IGdldE9wdGlvbigndmFsaWRfc3R5bGVzJyksXG4gICAgICAgIHZlcmlmeV9odG1sOiBnZXRPcHRpb24oJ3ZlcmlmeV9odG1sJyksXG4gICAgICAgIHBhZGRfZW1wdHlfYmxvY2tfaW5saW5lX2NoaWxkcmVuOiBnZXRPcHRpb24oJ2Zvcm1hdF9lbXB0eV9saW5lcycpXG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IG1rU2VyaWFsaXplclNldHRpbmdzID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IGdldE9wdGlvbiA9IGVkaXRvci5vcHRpb25zLmdldDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm1rUGFyc2VyU2V0dGluZ3MoZWRpdG9yKSxcbiAgICAgICAgLi4ubWtTY2hlbWFTZXR0aW5ncyhlZGl0b3IpLFxuICAgICAgICAuLi5yZW1vdmVVbmRlZmluZWQoe1xuICAgICAgICAgIHVybF9jb252ZXJ0ZXI6IGdldE9wdGlvbigndXJsX2NvbnZlcnRlcicpLFxuICAgICAgICAgIHVybF9jb252ZXJ0ZXJfc2NvcGU6IGdldE9wdGlvbigndXJsX2NvbnZlcnRlcl9zY29wZScpLFxuICAgICAgICAgIGVsZW1lbnRfZm9ybWF0OiBnZXRPcHRpb24oJ2VsZW1lbnRfZm9ybWF0JyksXG4gICAgICAgICAgZW50aXRpZXM6IGdldE9wdGlvbignZW50aXRpZXMnKSxcbiAgICAgICAgICBlbnRpdHlfZW5jb2Rpbmc6IGdldE9wdGlvbignZW50aXR5X2VuY29kaW5nJyksXG4gICAgICAgICAgaW5kZW50OiBnZXRPcHRpb24oJ2luZGVudCcpLFxuICAgICAgICAgIGluZGVudF9hZnRlcjogZ2V0T3B0aW9uKCdpbmRlbnRfYWZ0ZXInKSxcbiAgICAgICAgICBpbmRlbnRfYmVmb3JlOiBnZXRPcHRpb24oJ2luZGVudF9iZWZvcmUnKVxuICAgICAgICB9KVxuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IGNyZWF0ZVBhcnNlciA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBwYXJzZXIgPSBEb21QYXJzZXIobWtQYXJzZXJTZXR0aW5ncyhlZGl0b3IpLCBlZGl0b3Iuc2NoZW1hKTtcbiAgICAgIHBhcnNlci5hZGRBdHRyaWJ1dGVGaWx0ZXIoJ3NyYyxocmVmLHN0eWxlLHRhYmluZGV4JywgKG5vZGVzLCBuYW1lKSA9PiB7XG4gICAgICAgIGxldCBpID0gbm9kZXMubGVuZ3RoLCBub2RlLCB2YWx1ZTtcbiAgICAgICAgY29uc3QgZG9tID0gZWRpdG9yLmRvbTtcbiAgICAgICAgY29uc3QgaW50ZXJuYWxOYW1lID0gJ2RhdGEtbWNlLScgKyBuYW1lO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgIHZhbHVlID0gbm9kZS5hdHRyKG5hbWUpO1xuICAgICAgICAgIGlmICh2YWx1ZSAmJiAhbm9kZS5hdHRyKGludGVybmFsTmFtZSkpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5pbmRleE9mKCdkYXRhOicpID09PSAwIHx8IHZhbHVlLmluZGV4T2YoJ2Jsb2I6JykgPT09IDApIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ3N0eWxlJykge1xuICAgICAgICAgICAgICB2YWx1ZSA9IGRvbS5zZXJpYWxpemVTdHlsZShkb20ucGFyc2VTdHlsZSh2YWx1ZSksIG5vZGUubmFtZSk7XG4gICAgICAgICAgICAgIGlmICghdmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG5vZGUuYXR0cihpbnRlcm5hbE5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgbm9kZS5hdHRyKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3RhYmluZGV4Jykge1xuICAgICAgICAgICAgICBub2RlLmF0dHIoaW50ZXJuYWxOYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIG5vZGUuYXR0cihuYW1lLCBudWxsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5vZGUuYXR0cihpbnRlcm5hbE5hbWUsIGVkaXRvci5jb252ZXJ0VVJMKHZhbHVlLCBuYW1lLCBub2RlLm5hbWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcGFyc2VyLmFkZE5vZGVGaWx0ZXIoJ3NjcmlwdCcsIG5vZGVzID0+IHtcbiAgICAgICAgbGV0IGkgPSBub2Rlcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgY29uc3QgdHlwZSA9IG5vZGUuYXR0cigndHlwZScpIHx8ICduby90eXBlJztcbiAgICAgICAgICBpZiAodHlwZS5pbmRleE9mKCdtY2UtJykgIT09IDApIHtcbiAgICAgICAgICAgIG5vZGUuYXR0cigndHlwZScsICdtY2UtJyArIHR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoZWRpdG9yLm9wdGlvbnMuZ2V0KCdwcmVzZXJ2ZV9jZGF0YScpKSB7XG4gICAgICAgIHBhcnNlci5hZGROb2RlRmlsdGVyKCcjY2RhdGEnLCBub2RlcyA9PiB7XG4gICAgICAgICAgbGV0IGkgPSBub2Rlcy5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgICAgbm9kZS50eXBlID0gODtcbiAgICAgICAgICAgIG5vZGUubmFtZSA9ICcjY29tbWVudCc7XG4gICAgICAgICAgICBub2RlLnZhbHVlID0gJ1tDREFUQVsnICsgZWRpdG9yLmRvbS5lbmNvZGUobm9kZS52YWx1ZSkgKyAnXV0nO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBwYXJzZXIuYWRkTm9kZUZpbHRlcigncCxoMSxoMixoMyxoNCxoNSxoNixkaXYnLCBub2RlcyA9PiB7XG4gICAgICAgIGxldCBpID0gbm9kZXMubGVuZ3RoO1xuICAgICAgICBjb25zdCBub25FbXB0eUVsZW1lbnRzID0gZWRpdG9yLnNjaGVtYS5nZXROb25FbXB0eUVsZW1lbnRzKCk7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgaWYgKG5vZGUuaXNFbXB0eShub25FbXB0eUVsZW1lbnRzKSAmJiBub2RlLmdldEFsbCgnYnInKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIG5vZGUuYXBwZW5kKG5ldyBBc3ROb2RlKCdicicsIDEpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHBhcnNlcjtcbiAgICB9O1xuICAgIGNvbnN0IGF1dG9Gb2N1cyA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBhdXRvRm9jdXMgPSBnZXRBdXRvRm9jdXMoZWRpdG9yKTtcbiAgICAgIGlmIChhdXRvRm9jdXMpIHtcbiAgICAgICAgRGVsYXkuc2V0RWRpdG9yVGltZW91dChlZGl0b3IsICgpID0+IHtcbiAgICAgICAgICBsZXQgZm9jdXNFZGl0b3I7XG4gICAgICAgICAgaWYgKGF1dG9Gb2N1cyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgZm9jdXNFZGl0b3IgPSBlZGl0b3I7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvY3VzRWRpdG9yID0gZWRpdG9yLmVkaXRvck1hbmFnZXIuZ2V0KGF1dG9Gb2N1cyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZm9jdXNFZGl0b3IuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICBmb2N1c0VkaXRvci5mb2N1cygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMTAwKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG1vdmVTZWxlY3Rpb25Ub0ZpcnN0Q2FyZXRQb3NpdGlvbiA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCByb290ID0gZWRpdG9yLmRvbS5nZXRSb290KCk7XG4gICAgICBpZiAoIWVkaXRvci5pbmxpbmUgJiYgKCFoYXNBbnlSYW5nZXMoZWRpdG9yKSB8fCBlZGl0b3Iuc2VsZWN0aW9uLmdldFN0YXJ0KHRydWUpID09PSByb290KSkge1xuICAgICAgICBmaXJzdFBvc2l0aW9uSW4ocm9vdCkuZWFjaChwb3MgPT4ge1xuICAgICAgICAgIGNvbnN0IG5vZGUgPSBwb3MuZ2V0Tm9kZSgpO1xuICAgICAgICAgIGNvbnN0IGNhcmV0UG9zID0gaXNUYWJsZSQzKG5vZGUpID8gZmlyc3RQb3NpdGlvbkluKG5vZGUpLmdldE9yKHBvcykgOiBwb3M7XG4gICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZXRSbmcoY2FyZXRQb3MudG9SYW5nZSgpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBpbml0RWRpdG9yID0gZWRpdG9yID0+IHtcbiAgICAgIGVkaXRvci5iaW5kUGVuZGluZ0V2ZW50RGVsZWdhdGVzKCk7XG4gICAgICBlZGl0b3IuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgZmlyZUluaXQoZWRpdG9yKTtcbiAgICAgIGVkaXRvci5mb2N1cyh0cnVlKTtcbiAgICAgIG1vdmVTZWxlY3Rpb25Ub0ZpcnN0Q2FyZXRQb3NpdGlvbihlZGl0b3IpO1xuICAgICAgZWRpdG9yLm5vZGVDaGFuZ2VkKHsgaW5pdGlhbDogdHJ1ZSB9KTtcbiAgICAgIGNvbnN0IGluaXRJbnN0YW5jZUNhbGxiYWNrID0gZ2V0SW5pdEluc3RhbmNlQ2FsbGJhY2soZWRpdG9yKTtcbiAgICAgIGlmIChpc0Z1bmN0aW9uKGluaXRJbnN0YW5jZUNhbGxiYWNrKSkge1xuICAgICAgICBpbml0SW5zdGFuY2VDYWxsYmFjay5jYWxsKGVkaXRvciwgZWRpdG9yKTtcbiAgICAgIH1cbiAgICAgIGF1dG9Gb2N1cyhlZGl0b3IpO1xuICAgIH07XG4gICAgY29uc3QgZ2V0U3R5bGVTaGVldExvYWRlciQxID0gZWRpdG9yID0+IGVkaXRvci5pbmxpbmUgPyBlZGl0b3IudWkuc3R5bGVTaGVldExvYWRlciA6IGVkaXRvci5kb20uc3R5bGVTaGVldExvYWRlcjtcbiAgICBjb25zdCBtYWtlU3R5bGVzaGVldExvYWRpbmdQcm9taXNlcyA9IChlZGl0b3IsIGNzcywgZnJhbWVkRm9udHMpID0+IHtcbiAgICAgIGNvbnN0IHByb21pc2VzID0gW2dldFN0eWxlU2hlZXRMb2FkZXIkMShlZGl0b3IpLmxvYWRBbGwoY3NzKV07XG4gICAgICBpZiAoZWRpdG9yLmlubGluZSkge1xuICAgICAgICByZXR1cm4gcHJvbWlzZXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcHJvbWlzZXMuY29uY2F0KFtlZGl0b3IudWkuc3R5bGVTaGVldExvYWRlci5sb2FkQWxsKGZyYW1lZEZvbnRzKV0pO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgbG9hZENvbnRlbnRDc3MgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3Qgc3R5bGVTaGVldExvYWRlciA9IGdldFN0eWxlU2hlZXRMb2FkZXIkMShlZGl0b3IpO1xuICAgICAgY29uc3QgZm9udENzcyA9IGdldEZvbnRDc3MoZWRpdG9yKTtcbiAgICAgIGNvbnN0IGNzcyA9IGVkaXRvci5jb250ZW50Q1NTO1xuICAgICAgY29uc3QgcmVtb3ZlQ3NzID0gKCkgPT4ge1xuICAgICAgICBzdHlsZVNoZWV0TG9hZGVyLnVubG9hZEFsbChjc3MpO1xuICAgICAgICBpZiAoIWVkaXRvci5pbmxpbmUpIHtcbiAgICAgICAgICBlZGl0b3IudWkuc3R5bGVTaGVldExvYWRlci51bmxvYWRBbGwoZm9udENzcyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBsb2FkZWQgPSAoKSA9PiB7XG4gICAgICAgIGlmIChlZGl0b3IucmVtb3ZlZCkge1xuICAgICAgICAgIHJlbW92ZUNzcygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVkaXRvci5vbigncmVtb3ZlJywgcmVtb3ZlQ3NzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmIChlZGl0b3IuY29udGVudFN0eWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGxldCBjb250ZW50Q3NzVGV4dCA9ICcnO1xuICAgICAgICBUb29scy5lYWNoKGVkaXRvci5jb250ZW50U3R5bGVzLCBzdHlsZSA9PiB7XG4gICAgICAgICAgY29udGVudENzc1RleHQgKz0gc3R5bGUgKyAnXFxyXFxuJztcbiAgICAgICAgfSk7XG4gICAgICAgIGVkaXRvci5kb20uYWRkU3R5bGUoY29udGVudENzc1RleHQpO1xuICAgICAgfVxuICAgICAgY29uc3QgYWxsU3R5bGVzaGVldHMgPSBQcm9taXNlLmFsbChtYWtlU3R5bGVzaGVldExvYWRpbmdQcm9taXNlcyhlZGl0b3IsIGNzcywgZm9udENzcykpLnRoZW4obG9hZGVkKS5jYXRjaChsb2FkZWQpO1xuICAgICAgY29uc3QgY29udGVudFN0eWxlID0gZ2V0Q29udGVudFN0eWxlKGVkaXRvcik7XG4gICAgICBpZiAoY29udGVudFN0eWxlKSB7XG4gICAgICAgIGFwcGVuZFN0eWxlKGVkaXRvciwgY29udGVudFN0eWxlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhbGxTdHlsZXNoZWV0cztcbiAgICB9O1xuICAgIGNvbnN0IHByZUluaXQgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgZG9jID0gZWRpdG9yLmdldERvYygpLCBib2R5ID0gZWRpdG9yLmdldEJvZHkoKTtcbiAgICAgIGZpcmVQcmVJbml0KGVkaXRvcik7XG4gICAgICBpZiAoIXNob3VsZEJyb3dzZXJTcGVsbGNoZWNrKGVkaXRvcikpIHtcbiAgICAgICAgZG9jLmJvZHkuc3BlbGxjaGVjayA9IGZhbHNlO1xuICAgICAgICBET00kNi5zZXRBdHRyaWIoYm9keSwgJ3NwZWxsY2hlY2snLCAnZmFsc2UnKTtcbiAgICAgIH1cbiAgICAgIGVkaXRvci5xdWlya3MgPSBRdWlya3MoZWRpdG9yKTtcbiAgICAgIGZpcmVQb3N0UmVuZGVyKGVkaXRvcik7XG4gICAgICBjb25zdCBkaXJlY3Rpb25hbGl0eSA9IGdldERpcmVjdGlvbmFsaXR5KGVkaXRvcik7XG4gICAgICBpZiAoZGlyZWN0aW9uYWxpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBib2R5LmRpciA9IGRpcmVjdGlvbmFsaXR5O1xuICAgICAgfVxuICAgICAgY29uc3QgcHJvdGVjdCA9IGdldFByb3RlY3QoZWRpdG9yKTtcbiAgICAgIGlmIChwcm90ZWN0KSB7XG4gICAgICAgIGVkaXRvci5vbignQmVmb3JlU2V0Q29udGVudCcsIGUgPT4ge1xuICAgICAgICAgIFRvb2xzLmVhY2gocHJvdGVjdCwgcGF0dGVybiA9PiB7XG4gICAgICAgICAgICBlLmNvbnRlbnQgPSBlLmNvbnRlbnQucmVwbGFjZShwYXR0ZXJuLCBzdHIgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gJzwhLS1tY2U6cHJvdGVjdGVkICcgKyBlc2NhcGUoc3RyKSArICctLT4nO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZWRpdG9yLm9uKCdTZXRDb250ZW50JywgKCkgPT4ge1xuICAgICAgICBlZGl0b3IuYWRkVmlzdWFsKGVkaXRvci5nZXRCb2R5KCkpO1xuICAgICAgfSk7XG4gICAgICBlZGl0b3Iub24oJ2NvbXBvc2l0aW9uc3RhcnQgY29tcG9zaXRpb25lbmQnLCBlID0+IHtcbiAgICAgICAgZWRpdG9yLmNvbXBvc2luZyA9IGUudHlwZSA9PT0gJ2NvbXBvc2l0aW9uc3RhcnQnO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBsb2FkSW5pdGlhbENvbnRlbnQgPSBlZGl0b3IgPT4ge1xuICAgICAgaWYgKCFpc1J0YyhlZGl0b3IpKSB7XG4gICAgICAgIGVkaXRvci5sb2FkKHtcbiAgICAgICAgICBpbml0aWFsOiB0cnVlLFxuICAgICAgICAgIGZvcm1hdDogJ2h0bWwnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZWRpdG9yLnN0YXJ0Q29udGVudCA9IGVkaXRvci5nZXRDb250ZW50KHsgZm9ybWF0OiAncmF3JyB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGluaXRFZGl0b3JXaXRoSW5pdGlhbENvbnRlbnQgPSBlZGl0b3IgPT4ge1xuICAgICAgaWYgKGVkaXRvci5yZW1vdmVkICE9PSB0cnVlKSB7XG4gICAgICAgIGxvYWRJbml0aWFsQ29udGVudChlZGl0b3IpO1xuICAgICAgICBpbml0RWRpdG9yKGVkaXRvcik7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBjb250ZW50Qm9keUxvYWRlZCA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCB0YXJnZXRFbG0gPSBlZGl0b3IuZ2V0RWxlbWVudCgpO1xuICAgICAgbGV0IGRvYyA9IGVkaXRvci5nZXREb2MoKTtcbiAgICAgIGlmIChlZGl0b3IuaW5saW5lKSB7XG4gICAgICAgIERPTSQ2LmFkZENsYXNzKHRhcmdldEVsbSwgJ21jZS1jb250ZW50LWJvZHknKTtcbiAgICAgICAgZWRpdG9yLmNvbnRlbnREb2N1bWVudCA9IGRvYyA9IGRvY3VtZW50O1xuICAgICAgICBlZGl0b3IuY29udGVudFdpbmRvdyA9IHdpbmRvdztcbiAgICAgICAgZWRpdG9yLmJvZHlFbGVtZW50ID0gdGFyZ2V0RWxtO1xuICAgICAgICBlZGl0b3IuY29udGVudEFyZWFDb250YWluZXIgPSB0YXJnZXRFbG07XG4gICAgICB9XG4gICAgICBjb25zdCBib2R5ID0gZWRpdG9yLmdldEJvZHkoKTtcbiAgICAgIGJvZHkuZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgZWRpdG9yLnJlYWRvbmx5ID0gaXNSZWFkT25seSQxKGVkaXRvcik7XG4gICAgICBpZiAoIWVkaXRvci5yZWFkb25seSkge1xuICAgICAgICBpZiAoZWRpdG9yLmlubGluZSAmJiBET00kNi5nZXRTdHlsZShib2R5LCAncG9zaXRpb24nLCB0cnVlKSA9PT0gJ3N0YXRpYycpIHtcbiAgICAgICAgICBib2R5LnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICAgICAgfVxuICAgICAgICBib2R5LmNvbnRlbnRFZGl0YWJsZSA9ICd0cnVlJztcbiAgICAgIH1cbiAgICAgIGJvZHkuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgIGVkaXRvci5lZGl0b3JVcGxvYWQgPSBFZGl0b3JVcGxvYWQoZWRpdG9yKTtcbiAgICAgIGVkaXRvci5zY2hlbWEgPSBTY2hlbWEobWtTY2hlbWFTZXR0aW5ncyhlZGl0b3IpKTtcbiAgICAgIGVkaXRvci5kb20gPSBET01VdGlscyhkb2MsIHtcbiAgICAgICAga2VlcF92YWx1ZXM6IHRydWUsXG4gICAgICAgIHVybF9jb252ZXJ0ZXI6IGVkaXRvci5jb252ZXJ0VVJMLFxuICAgICAgICB1cmxfY29udmVydGVyX3Njb3BlOiBlZGl0b3IsXG4gICAgICAgIHVwZGF0ZV9zdHlsZXM6IHRydWUsXG4gICAgICAgIHJvb3RfZWxlbWVudDogZWRpdG9yLmlubGluZSA/IGVkaXRvci5nZXRCb2R5KCkgOiBudWxsLFxuICAgICAgICBjb2xsZWN0OiAoKSA9PiBlZGl0b3IuaW5saW5lLFxuICAgICAgICBzY2hlbWE6IGVkaXRvci5zY2hlbWEsXG4gICAgICAgIGNvbnRlbnRDc3NDb3JzOiBzaG91bGRVc2VDb250ZW50Q3NzQ29ycyhlZGl0b3IpLFxuICAgICAgICByZWZlcnJlclBvbGljeTogZ2V0UmVmZXJyZXJQb2xpY3koZWRpdG9yKSxcbiAgICAgICAgb25TZXRBdHRyaWI6IGUgPT4ge1xuICAgICAgICAgIGVkaXRvci5kaXNwYXRjaCgnU2V0QXR0cmliJywgZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLnBhcnNlciA9IGNyZWF0ZVBhcnNlcihlZGl0b3IpO1xuICAgICAgZWRpdG9yLnNlcmlhbGl6ZXIgPSBEb21TZXJpYWxpemVyKG1rU2VyaWFsaXplclNldHRpbmdzKGVkaXRvciksIGVkaXRvcik7XG4gICAgICBlZGl0b3Iuc2VsZWN0aW9uID0gRWRpdG9yU2VsZWN0aW9uKGVkaXRvci5kb20sIGVkaXRvci5nZXRXaW4oKSwgZWRpdG9yLnNlcmlhbGl6ZXIsIGVkaXRvcik7XG4gICAgICBlZGl0b3IuYW5ub3RhdG9yID0gQW5ub3RhdG9yKGVkaXRvcik7XG4gICAgICBlZGl0b3IuZm9ybWF0dGVyID0gRm9ybWF0dGVyKGVkaXRvcik7XG4gICAgICBlZGl0b3IudW5kb01hbmFnZXIgPSBVbmRvTWFuYWdlcihlZGl0b3IpO1xuICAgICAgZWRpdG9yLl9ub2RlQ2hhbmdlRGlzcGF0Y2hlciA9IG5ldyBOb2RlQ2hhbmdlKGVkaXRvcik7XG4gICAgICBlZGl0b3IuX3NlbGVjdGlvbk92ZXJyaWRlcyA9IFNlbGVjdGlvbk92ZXJyaWRlcyhlZGl0b3IpO1xuICAgICAgc2V0dXAkbyhlZGl0b3IpO1xuICAgICAgc2V0dXAkNihlZGl0b3IpO1xuICAgICAgc2V0dXAkbShlZGl0b3IpO1xuICAgICAgaWYgKCFpc1J0YyhlZGl0b3IpKSB7XG4gICAgICAgIHNldHVwJDUoZWRpdG9yKTtcbiAgICAgICAgc2V0dXAkMShlZGl0b3IpO1xuICAgICAgfVxuICAgICAgY29uc3QgY2FyZXQgPSBzZXR1cCRiKGVkaXRvcik7XG4gICAgICBzZXR1cCRwKGVkaXRvciwgY2FyZXQpO1xuICAgICAgc2V0dXAkbihlZGl0b3IpO1xuICAgICAgc2V0dXAkcShlZGl0b3IpO1xuICAgICAgc2V0dXAkNyhlZGl0b3IpO1xuICAgICAgY29uc3Qgc2V0dXBSdGNUaHVuayA9IHNldHVwJHMoZWRpdG9yKTtcbiAgICAgIHByZUluaXQoZWRpdG9yKTtcbiAgICAgIHNldHVwUnRjVGh1bmsuZm9sZCgoKSA9PiB7XG4gICAgICAgIGxvYWRDb250ZW50Q3NzKGVkaXRvcikudGhlbigoKSA9PiBpbml0RWRpdG9yV2l0aEluaXRpYWxDb250ZW50KGVkaXRvcikpO1xuICAgICAgfSwgc2V0dXBSdGMgPT4ge1xuICAgICAgICBlZGl0b3Iuc2V0UHJvZ3Jlc3NTdGF0ZSh0cnVlKTtcbiAgICAgICAgbG9hZENvbnRlbnRDc3MoZWRpdG9yKS50aGVuKCgpID0+IHtcbiAgICAgICAgICBzZXR1cFJ0YygpLnRoZW4oX3J0Y01vZGUgPT4ge1xuICAgICAgICAgICAgZWRpdG9yLnNldFByb2dyZXNzU3RhdGUoZmFsc2UpO1xuICAgICAgICAgICAgaW5pdEVkaXRvcldpdGhJbml0aWFsQ29udGVudChlZGl0b3IpO1xuICAgICAgICAgICAgYmluZEV2ZW50cyhlZGl0b3IpO1xuICAgICAgICAgIH0sIGVyciA9PiB7XG4gICAgICAgICAgICBlZGl0b3Iubm90aWZpY2F0aW9uTWFuYWdlci5vcGVuKHtcbiAgICAgICAgICAgICAgdHlwZTogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgdGV4dDogU3RyaW5nKGVycilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaW5pdEVkaXRvcldpdGhJbml0aWFsQ29udGVudChlZGl0b3IpO1xuICAgICAgICAgICAgYmluZEV2ZW50cyhlZGl0b3IpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgaW5pdENvbnRlbnRCb2R5ID0gKGVkaXRvciwgc2tpcFdyaXRlKSA9PiB7XG4gICAgICBpZiAoIWVkaXRvci5pbmxpbmUpIHtcbiAgICAgICAgZWRpdG9yLmdldEVsZW1lbnQoKS5zdHlsZS52aXNpYmlsaXR5ID0gZWRpdG9yLm9yZ1Zpc2liaWxpdHk7XG4gICAgICB9XG4gICAgICBpZiAoIXNraXBXcml0ZSAmJiAhZWRpdG9yLmlubGluZSkge1xuICAgICAgICBjb25zdCBpZnJhbWUgPSBlZGl0b3IuaWZyYW1lRWxlbWVudDtcbiAgICAgICAgY29uc3QgYmluZGVyID0gYmluZCQxKFN1Z2FyRWxlbWVudC5mcm9tRG9tKGlmcmFtZSksICdsb2FkJywgKCkgPT4ge1xuICAgICAgICAgIGJpbmRlci51bmJpbmQoKTtcbiAgICAgICAgICBlZGl0b3IuY29udGVudERvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnREb2N1bWVudDtcbiAgICAgICAgICBjb250ZW50Qm9keUxvYWRlZChlZGl0b3IpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWZyYW1lLnNyY2RvYyA9IGVkaXRvci5pZnJhbWVIVE1MO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGVudEJvZHlMb2FkZWQoZWRpdG9yKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgRE9NJDUgPSBET01VdGlscy5ET007XG4gICAgY29uc3QgY3JlYXRlSWZyYW1lRWxlbWVudCA9IChpZCwgdGl0bGUsIGN1c3RvbUF0dHJzLCB0YWJpbmRleCkgPT4ge1xuICAgICAgY29uc3QgaWZyYW1lID0gU3VnYXJFbGVtZW50LmZyb21UYWcoJ2lmcmFtZScpO1xuICAgICAgdGFiaW5kZXguZWFjaCh0ID0+IHNldCQyKGlmcmFtZSwgJ3RhYmluZGV4JywgdCkpO1xuICAgICAgc2V0QWxsJDEoaWZyYW1lLCBjdXN0b21BdHRycyk7XG4gICAgICBzZXRBbGwkMShpZnJhbWUsIHtcbiAgICAgICAgaWQ6IGlkICsgJ19pZnInLFxuICAgICAgICBmcmFtZUJvcmRlcjogJzAnLFxuICAgICAgICBhbGxvd1RyYW5zcGFyZW5jeTogJ3RydWUnLFxuICAgICAgICB0aXRsZVxuICAgICAgfSk7XG4gICAgICBhZGQkMihpZnJhbWUsICd0b3gtZWRpdC1hcmVhX19pZnJhbWUnKTtcbiAgICAgIHJldHVybiBpZnJhbWU7XG4gICAgfTtcbiAgICBjb25zdCBnZXRJZnJhbWVIdG1sID0gZWRpdG9yID0+IHtcbiAgICAgIGxldCBpZnJhbWVIVE1MID0gZ2V0RG9jVHlwZShlZGl0b3IpICsgJzxodG1sPjxoZWFkPic7XG4gICAgICBpZiAoZ2V0RG9jdW1lbnRCYXNlVXJsKGVkaXRvcikgIT09IGVkaXRvci5kb2N1bWVudEJhc2VVcmwpIHtcbiAgICAgICAgaWZyYW1lSFRNTCArPSAnPGJhc2UgaHJlZj1cIicgKyBlZGl0b3IuZG9jdW1lbnRCYXNlVVJJLmdldFVSSSgpICsgJ1wiIC8+JztcbiAgICAgIH1cbiAgICAgIGlmcmFtZUhUTUwgKz0gJzxtZXRhIGh0dHAtZXF1aXY9XCJDb250ZW50LVR5cGVcIiBjb250ZW50PVwidGV4dC9odG1sOyBjaGFyc2V0PVVURi04XCIgLz4nO1xuICAgICAgY29uc3QgYm9keUlkID0gZ2V0Qm9keUlkKGVkaXRvcik7XG4gICAgICBjb25zdCBib2R5Q2xhc3MgPSBnZXRCb2R5Q2xhc3MoZWRpdG9yKTtcbiAgICAgIGNvbnN0IHRyYW5zbGF0ZWRBcmlhVGV4dCA9IGVkaXRvci50cmFuc2xhdGUoZ2V0SWZyYW1lQXJpYVRleHQoZWRpdG9yKSk7XG4gICAgICBpZiAoZ2V0Q29udGVudFNlY3VyaXR5UG9saWN5KGVkaXRvcikpIHtcbiAgICAgICAgaWZyYW1lSFRNTCArPSAnPG1ldGEgaHR0cC1lcXVpdj1cIkNvbnRlbnQtU2VjdXJpdHktUG9saWN5XCIgY29udGVudD1cIicgKyBnZXRDb250ZW50U2VjdXJpdHlQb2xpY3koZWRpdG9yKSArICdcIiAvPic7XG4gICAgICB9XG4gICAgICBpZnJhbWVIVE1MICs9ICc8L2hlYWQ+JyArIGA8Ym9keSBpZD1cIiR7IGJvZHlJZCB9XCIgY2xhc3M9XCJtY2UtY29udGVudC1ib2R5ICR7IGJvZHlDbGFzcyB9XCIgZGF0YS1pZD1cIiR7IGVkaXRvci5pZCB9XCIgYXJpYS1sYWJlbD1cIiR7IHRyYW5zbGF0ZWRBcmlhVGV4dCB9XCI+YCArICc8YnI+JyArICc8L2JvZHk+PC9odG1sPic7XG4gICAgICByZXR1cm4gaWZyYW1lSFRNTDtcbiAgICB9O1xuICAgIGNvbnN0IGNyZWF0ZUlmcmFtZSA9IChlZGl0b3IsIGJveEluZm8pID0+IHtcbiAgICAgIGNvbnN0IGlmcmFtZVRpdGxlID0gZWRpdG9yLnRyYW5zbGF0ZSgnUmljaCBUZXh0IEFyZWEnKTtcbiAgICAgIGNvbnN0IHRhYmluZGV4ID0gZ2V0T3B0KFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVkaXRvci5nZXRFbGVtZW50KCkpLCAndGFiaW5kZXgnKS5iaW5kKHRvSW50KTtcbiAgICAgIGNvbnN0IGlmciA9IGNyZWF0ZUlmcmFtZUVsZW1lbnQoZWRpdG9yLmlkLCBpZnJhbWVUaXRsZSwgZ2V0SWZyYW1lQXR0cnMoZWRpdG9yKSwgdGFiaW5kZXgpLmRvbTtcbiAgICAgIGlmci5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgIGlmci5vbmxvYWQgPSBudWxsO1xuICAgICAgICBlZGl0b3IuZGlzcGF0Y2goJ2xvYWQnKTtcbiAgICAgIH07XG4gICAgICBlZGl0b3IuY29udGVudEFyZWFDb250YWluZXIgPSBib3hJbmZvLmlmcmFtZUNvbnRhaW5lcjtcbiAgICAgIGVkaXRvci5pZnJhbWVFbGVtZW50ID0gaWZyO1xuICAgICAgZWRpdG9yLmlmcmFtZUhUTUwgPSBnZXRJZnJhbWVIdG1sKGVkaXRvcik7XG4gICAgICBET00kNS5hZGQoYm94SW5mby5pZnJhbWVDb250YWluZXIsIGlmcik7XG4gICAgfTtcbiAgICBjb25zdCBpbml0JDEgPSAoZWRpdG9yLCBib3hJbmZvKSA9PiB7XG4gICAgICBjcmVhdGVJZnJhbWUoZWRpdG9yLCBib3hJbmZvKTtcbiAgICAgIGlmIChib3hJbmZvLmVkaXRvckNvbnRhaW5lcikge1xuICAgICAgICBET00kNS5nZXQoYm94SW5mby5lZGl0b3JDb250YWluZXIpLnN0eWxlLmRpc3BsYXkgPSBlZGl0b3Iub3JnRGlzcGxheTtcbiAgICAgICAgZWRpdG9yLmhpZGRlbiA9IERPTSQ1LmlzSGlkZGVuKGJveEluZm8uZWRpdG9yQ29udGFpbmVyKTtcbiAgICAgIH1cbiAgICAgIGVkaXRvci5nZXRFbGVtZW50KCkuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIERPTSQ1LnNldEF0dHJpYihlZGl0b3IuaWQsICdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG4gICAgICBpbml0Q29udGVudEJvZHkoZWRpdG9yKTtcbiAgICB9O1xuXG4gICAgY29uc3QgRE9NJDQgPSBET01VdGlscy5ET007XG4gICAgY29uc3QgaW5pdFBsdWdpbiA9IChlZGl0b3IsIGluaXRpYWxpemVkUGx1Z2lucywgcGx1Z2luKSA9PiB7XG4gICAgICBjb25zdCBQbHVnaW4gPSBQbHVnaW5NYW5hZ2VyLmdldChwbHVnaW4pO1xuICAgICAgY29uc3QgcGx1Z2luVXJsID0gUGx1Z2luTWFuYWdlci51cmxzW3BsdWdpbl0gfHwgZWRpdG9yLmRvY3VtZW50QmFzZVVybC5yZXBsYWNlKC9cXC8kLywgJycpO1xuICAgICAgcGx1Z2luID0gVG9vbHMudHJpbShwbHVnaW4pO1xuICAgICAgaWYgKFBsdWdpbiAmJiBUb29scy5pbkFycmF5KGluaXRpYWxpemVkUGx1Z2lucywgcGx1Z2luKSA9PT0gLTEpIHtcbiAgICAgICAgaWYgKGVkaXRvci5wbHVnaW5zW3BsdWdpbl0pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBwbHVnaW5JbnN0YW5jZSA9IFBsdWdpbihlZGl0b3IsIHBsdWdpblVybCkgfHwge307XG4gICAgICAgICAgZWRpdG9yLnBsdWdpbnNbcGx1Z2luXSA9IHBsdWdpbkluc3RhbmNlO1xuICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHBsdWdpbkluc3RhbmNlLmluaXQpKSB7XG4gICAgICAgICAgICBwbHVnaW5JbnN0YW5jZS5pbml0KGVkaXRvciwgcGx1Z2luVXJsKTtcbiAgICAgICAgICAgIGluaXRpYWxpemVkUGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcGx1Z2luSW5pdEVycm9yKGVkaXRvciwgcGx1Z2luLCBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgdHJpbUxlZ2FjeVByZWZpeCA9IG5hbWUgPT4ge1xuICAgICAgcmV0dXJuIG5hbWUucmVwbGFjZSgvXlxcLS8sICcnKTtcbiAgICB9O1xuICAgIGNvbnN0IGluaXRQbHVnaW5zID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IGluaXRpYWxpemVkUGx1Z2lucyA9IFtdO1xuICAgICAgZWFjaCRnKGdldFBsdWdpbnMoZWRpdG9yKSwgbmFtZSA9PiB7XG4gICAgICAgIGluaXRQbHVnaW4oZWRpdG9yLCBpbml0aWFsaXplZFBsdWdpbnMsIHRyaW1MZWdhY3lQcmVmaXgobmFtZSkpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBpbml0SWNvbnMgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgaWNvblBhY2tOYW1lID0gVG9vbHMudHJpbShnZXRJY29uUGFja05hbWUoZWRpdG9yKSk7XG4gICAgICBjb25zdCBjdXJyZW50SWNvbnMgPSBlZGl0b3IudWkucmVnaXN0cnkuZ2V0QWxsKCkuaWNvbnM7XG4gICAgICBjb25zdCBsb2FkSWNvbnMgPSB7XG4gICAgICAgIC4uLkljb25NYW5hZ2VyLmdldCgnZGVmYXVsdCcpLmljb25zLFxuICAgICAgICAuLi5JY29uTWFuYWdlci5nZXQoaWNvblBhY2tOYW1lKS5pY29uc1xuICAgICAgfTtcbiAgICAgIGVhY2gkZihsb2FkSWNvbnMsIChzdmdEYXRhLCBpY29uKSA9PiB7XG4gICAgICAgIGlmICghaGFzJDIoY3VycmVudEljb25zLCBpY29uKSkge1xuICAgICAgICAgIGVkaXRvci51aS5yZWdpc3RyeS5hZGRJY29uKGljb24sIHN2Z0RhdGEpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGluaXRUaGVtZSA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCB0aGVtZSA9IGdldFRoZW1lKGVkaXRvcik7XG4gICAgICBpZiAoaXNTdHJpbmcodGhlbWUpKSB7XG4gICAgICAgIGNvbnN0IFRoZW1lID0gVGhlbWVNYW5hZ2VyLmdldCh0aGVtZSk7XG4gICAgICAgIGVkaXRvci50aGVtZSA9IFRoZW1lKGVkaXRvciwgVGhlbWVNYW5hZ2VyLnVybHNbdGhlbWVdKSB8fCB7fTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oZWRpdG9yLnRoZW1lLmluaXQpKSB7XG4gICAgICAgICAgZWRpdG9yLnRoZW1lLmluaXQoZWRpdG9yLCBUaGVtZU1hbmFnZXIudXJsc1t0aGVtZV0gfHwgZWRpdG9yLmRvY3VtZW50QmFzZVVybC5yZXBsYWNlKC9cXC8kLywgJycpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWRpdG9yLnRoZW1lID0ge307XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBpbml0TW9kZWwgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgbW9kZWwgPSBnZXRNb2RlbChlZGl0b3IpO1xuICAgICAgY29uc3QgTW9kZWwgPSBNb2RlbE1hbmFnZXIuZ2V0KG1vZGVsKTtcbiAgICAgIGVkaXRvci5tb2RlbCA9IE1vZGVsKGVkaXRvciwgTW9kZWxNYW5hZ2VyLnVybHNbbW9kZWxdKTtcbiAgICB9O1xuICAgIGNvbnN0IHJlbmRlckZyb21Mb2FkZWRUaGVtZSA9IGVkaXRvciA9PiB7XG4gICAgICByZXR1cm4gZWRpdG9yLnRoZW1lLnJlbmRlclVJKCk7XG4gICAgfTtcbiAgICBjb25zdCByZW5kZXJGcm9tVGhlbWVGdW5jID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IGVsbSA9IGVkaXRvci5nZXRFbGVtZW50KCk7XG4gICAgICBjb25zdCB0aGVtZSA9IGdldFRoZW1lKGVkaXRvcik7XG4gICAgICBjb25zdCBpbmZvID0gdGhlbWUoZWRpdG9yLCBlbG0pO1xuICAgICAgaWYgKGluZm8uZWRpdG9yQ29udGFpbmVyLm5vZGVUeXBlKSB7XG4gICAgICAgIGluZm8uZWRpdG9yQ29udGFpbmVyLmlkID0gaW5mby5lZGl0b3JDb250YWluZXIuaWQgfHwgZWRpdG9yLmlkICsgJ19wYXJlbnQnO1xuICAgICAgfVxuICAgICAgaWYgKGluZm8uaWZyYW1lQ29udGFpbmVyICYmIGluZm8uaWZyYW1lQ29udGFpbmVyLm5vZGVUeXBlKSB7XG4gICAgICAgIGluZm8uaWZyYW1lQ29udGFpbmVyLmlkID0gaW5mby5pZnJhbWVDb250YWluZXIuaWQgfHwgZWRpdG9yLmlkICsgJ19pZnJhbWVjb250YWluZXInO1xuICAgICAgfVxuICAgICAgaW5mby5oZWlnaHQgPSBpbmZvLmlmcmFtZUhlaWdodCA/IGluZm8uaWZyYW1lSGVpZ2h0IDogZWxtLm9mZnNldEhlaWdodDtcbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH07XG4gICAgY29uc3QgY3JlYXRlVGhlbWVGYWxzZVJlc3VsdCA9IGVsZW1lbnQgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZWRpdG9yQ29udGFpbmVyOiBlbGVtZW50LFxuICAgICAgICBpZnJhbWVDb250YWluZXI6IGVsZW1lbnQsXG4gICAgICAgIGFwaToge31cbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCByZW5kZXJUaGVtZUZhbHNlSWZyYW1lID0gdGFyZ2V0RWxlbWVudCA9PiB7XG4gICAgICBjb25zdCBpZnJhbWVDb250YWluZXIgPSBET00kNC5jcmVhdGUoJ2RpdicpO1xuICAgICAgRE9NJDQuaW5zZXJ0QWZ0ZXIoaWZyYW1lQ29udGFpbmVyLCB0YXJnZXRFbGVtZW50KTtcbiAgICAgIHJldHVybiBjcmVhdGVUaGVtZUZhbHNlUmVzdWx0KGlmcmFtZUNvbnRhaW5lcik7XG4gICAgfTtcbiAgICBjb25zdCByZW5kZXJUaGVtZUZhbHNlID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IHRhcmdldEVsZW1lbnQgPSBlZGl0b3IuZ2V0RWxlbWVudCgpO1xuICAgICAgcmV0dXJuIGVkaXRvci5pbmxpbmUgPyBjcmVhdGVUaGVtZUZhbHNlUmVzdWx0KG51bGwpIDogcmVuZGVyVGhlbWVGYWxzZUlmcmFtZSh0YXJnZXRFbGVtZW50KTtcbiAgICB9O1xuICAgIGNvbnN0IHJlbmRlclRoZW1lVWkgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgZWxtID0gZWRpdG9yLmdldEVsZW1lbnQoKTtcbiAgICAgIGVkaXRvci5vcmdEaXNwbGF5ID0gZWxtLnN0eWxlLmRpc3BsYXk7XG4gICAgICBpZiAoaXNTdHJpbmcoZ2V0VGhlbWUoZWRpdG9yKSkpIHtcbiAgICAgICAgcmV0dXJuIHJlbmRlckZyb21Mb2FkZWRUaGVtZShlZGl0b3IpO1xuICAgICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKGdldFRoZW1lKGVkaXRvcikpKSB7XG4gICAgICAgIHJldHVybiByZW5kZXJGcm9tVGhlbWVGdW5jKGVkaXRvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVuZGVyVGhlbWVGYWxzZShlZGl0b3IpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgYXVnbWVudEVkaXRvclVpQXBpID0gKGVkaXRvciwgYXBpKSA9PiB7XG4gICAgICBjb25zdCB1aUFwaUZhY2FkZSA9IHtcbiAgICAgICAgc2hvdzogT3B0aW9uYWwuZnJvbShhcGkuc2hvdykuZ2V0T3Iobm9vcCksXG4gICAgICAgIGhpZGU6IE9wdGlvbmFsLmZyb20oYXBpLmhpZGUpLmdldE9yKG5vb3ApLFxuICAgICAgICBpc0VuYWJsZWQ6IE9wdGlvbmFsLmZyb20oYXBpLmlzRW5hYmxlZCkuZ2V0T3IoYWx3YXlzKSxcbiAgICAgICAgc2V0RW5hYmxlZDogc3RhdGUgPT4ge1xuICAgICAgICAgIGlmICghZWRpdG9yLm1vZGUuaXNSZWFkT25seSgpKSB7XG4gICAgICAgICAgICBPcHRpb25hbC5mcm9tKGFwaS5zZXRFbmFibGVkKS5lYWNoKGYgPT4gZihzdGF0ZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGVkaXRvci51aSA9IHtcbiAgICAgICAgLi4uZWRpdG9yLnVpLFxuICAgICAgICAuLi51aUFwaUZhY2FkZVxuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IGluaXQgPSBlZGl0b3IgPT4ge1xuICAgICAgZWRpdG9yLmRpc3BhdGNoKCdTY3JpcHRzTG9hZGVkJyk7XG4gICAgICBpbml0SWNvbnMoZWRpdG9yKTtcbiAgICAgIGluaXRUaGVtZShlZGl0b3IpO1xuICAgICAgaW5pdE1vZGVsKGVkaXRvcik7XG4gICAgICBpbml0UGx1Z2lucyhlZGl0b3IpO1xuICAgICAgY29uc3QgcmVuZGVySW5mbyA9IHJlbmRlclRoZW1lVWkoZWRpdG9yKTtcbiAgICAgIGF1Z21lbnRFZGl0b3JVaUFwaShlZGl0b3IsIE9wdGlvbmFsLmZyb20ocmVuZGVySW5mby5hcGkpLmdldE9yKHt9KSk7XG4gICAgICBjb25zdCBib3hJbmZvID0ge1xuICAgICAgICBlZGl0b3JDb250YWluZXI6IHJlbmRlckluZm8uZWRpdG9yQ29udGFpbmVyLFxuICAgICAgICBpZnJhbWVDb250YWluZXI6IHJlbmRlckluZm8uaWZyYW1lQ29udGFpbmVyXG4gICAgICB9O1xuICAgICAgZWRpdG9yLmVkaXRvckNvbnRhaW5lciA9IGJveEluZm8uZWRpdG9yQ29udGFpbmVyID8gYm94SW5mby5lZGl0b3JDb250YWluZXIgOiBudWxsO1xuICAgICAgYXBwZW5kQ29udGVudENzc0Zyb21TZXR0aW5ncyhlZGl0b3IpO1xuICAgICAgaWYgKGVkaXRvci5pbmxpbmUpIHtcbiAgICAgICAgcmV0dXJuIGluaXRDb250ZW50Qm9keShlZGl0b3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGluaXQkMShlZGl0b3IsIGJveEluZm8pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBET00kMyA9IERPTVV0aWxzLkRPTTtcbiAgICBjb25zdCBoYXNTa2lwTG9hZFByZWZpeCA9IG5hbWUgPT4gbmFtZS5jaGFyQXQoMCkgPT09ICctJztcbiAgICBjb25zdCBsb2FkTGFuZ3VhZ2UgPSAoc2NyaXB0TG9hZGVyLCBlZGl0b3IpID0+IHtcbiAgICAgIGNvbnN0IGxhbmd1YWdlQ29kZSA9IGdldExhbmd1YWdlQ29kZShlZGl0b3IpO1xuICAgICAgY29uc3QgbGFuZ3VhZ2VVcmwgPSBnZXRMYW5ndWFnZVVybChlZGl0b3IpO1xuICAgICAgaWYgKEkxOG4uaGFzQ29kZShsYW5ndWFnZUNvZGUpID09PSBmYWxzZSAmJiBsYW5ndWFnZUNvZGUgIT09ICdlbicpIHtcbiAgICAgICAgY29uc3QgdXJsID0gaXNOb3RFbXB0eShsYW5ndWFnZVVybCkgPyBsYW5ndWFnZVVybCA6IGAkeyBlZGl0b3IuZWRpdG9yTWFuYWdlci5iYXNlVVJMIH0vbGFuZ3MvJHsgbGFuZ3VhZ2VDb2RlIH0uanNgO1xuICAgICAgICBzY3JpcHRMb2FkZXIuYWRkKHVybCkuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgIGxhbmd1YWdlTG9hZEVycm9yKGVkaXRvciwgdXJsLCBsYW5ndWFnZUNvZGUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGxvYWRUaGVtZSA9IChlZGl0b3IsIHN1ZmZpeCkgPT4ge1xuICAgICAgY29uc3QgdGhlbWUgPSBnZXRUaGVtZShlZGl0b3IpO1xuICAgICAgaWYgKGlzU3RyaW5nKHRoZW1lKSAmJiAhaGFzU2tpcExvYWRQcmVmaXgodGhlbWUpICYmICFoYXMkMihUaGVtZU1hbmFnZXIudXJscywgdGhlbWUpKSB7XG4gICAgICAgIGNvbnN0IHRoZW1lVXJsID0gZ2V0VGhlbWVVcmwoZWRpdG9yKTtcbiAgICAgICAgY29uc3QgdXJsID0gdGhlbWVVcmwgPyBlZGl0b3IuZG9jdW1lbnRCYXNlVVJJLnRvQWJzb2x1dGUodGhlbWVVcmwpIDogYHRoZW1lcy8keyB0aGVtZSB9L3RoZW1lJHsgc3VmZml4IH0uanNgO1xuICAgICAgICBUaGVtZU1hbmFnZXIubG9hZCh0aGVtZSwgdXJsKS5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgdGhlbWVMb2FkRXJyb3IoZWRpdG9yLCB1cmwsIHRoZW1lKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBsb2FkTW9kZWwgPSAoZWRpdG9yLCBzdWZmaXgpID0+IHtcbiAgICAgIGNvbnN0IG1vZGVsID0gZ2V0TW9kZWwoZWRpdG9yKTtcbiAgICAgIGlmIChtb2RlbCAhPT0gJ3BsdWdpbicgJiYgIWhhcyQyKE1vZGVsTWFuYWdlci51cmxzLCBtb2RlbCkpIHtcbiAgICAgICAgY29uc3QgbW9kZWxVcmwgPSBnZXRNb2RlbFVybChlZGl0b3IpO1xuICAgICAgICBjb25zdCB1cmwgPSBpc1N0cmluZyhtb2RlbFVybCkgPyBlZGl0b3IuZG9jdW1lbnRCYXNlVVJJLnRvQWJzb2x1dGUobW9kZWxVcmwpIDogYG1vZGVscy8keyBtb2RlbCB9L21vZGVsJHsgc3VmZml4IH0uanNgO1xuICAgICAgICBNb2RlbE1hbmFnZXIubG9hZChtb2RlbCwgdXJsKS5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgbW9kZWxMb2FkRXJyb3IoZWRpdG9yLCB1cmwsIG1vZGVsKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBnZXRJY29uc1VybE1ldGFGcm9tVXJsID0gZWRpdG9yID0+IE9wdGlvbmFsLmZyb20oZ2V0SWNvbnNVcmwoZWRpdG9yKSkuZmlsdGVyKGlzTm90RW1wdHkpLm1hcCh1cmwgPT4gKHtcbiAgICAgIHVybCxcbiAgICAgIG5hbWU6IE9wdGlvbmFsLm5vbmUoKVxuICAgIH0pKTtcbiAgICBjb25zdCBnZXRJY29uc1VybE1ldGFGcm9tTmFtZSA9IChlZGl0b3IsIG5hbWUsIHN1ZmZpeCkgPT4gT3B0aW9uYWwuZnJvbShuYW1lKS5maWx0ZXIobmFtZSA9PiBpc05vdEVtcHR5KG5hbWUpICYmICFJY29uTWFuYWdlci5oYXMobmFtZSkpLm1hcChuYW1lID0+ICh7XG4gICAgICB1cmw6IGAkeyBlZGl0b3IuZWRpdG9yTWFuYWdlci5iYXNlVVJMIH0vaWNvbnMvJHsgbmFtZSB9L2ljb25zJHsgc3VmZml4IH0uanNgLFxuICAgICAgbmFtZTogT3B0aW9uYWwuc29tZShuYW1lKVxuICAgIH0pKTtcbiAgICBjb25zdCBsb2FkSWNvbnMgPSAoc2NyaXB0TG9hZGVyLCBlZGl0b3IsIHN1ZmZpeCkgPT4ge1xuICAgICAgY29uc3QgZGVmYXVsdEljb25zVXJsID0gZ2V0SWNvbnNVcmxNZXRhRnJvbU5hbWUoZWRpdG9yLCAnZGVmYXVsdCcsIHN1ZmZpeCk7XG4gICAgICBjb25zdCBjdXN0b21JY29uc1VybCA9IGdldEljb25zVXJsTWV0YUZyb21VcmwoZWRpdG9yKS5vclRodW5rKCgpID0+IGdldEljb25zVXJsTWV0YUZyb21OYW1lKGVkaXRvciwgZ2V0SWNvblBhY2tOYW1lKGVkaXRvciksICcnKSk7XG4gICAgICBlYWNoJGcoY2F0KFtcbiAgICAgICAgZGVmYXVsdEljb25zVXJsLFxuICAgICAgICBjdXN0b21JY29uc1VybFxuICAgICAgXSksIHVybE1ldGEgPT4ge1xuICAgICAgICBzY3JpcHRMb2FkZXIuYWRkKHVybE1ldGEudXJsKS5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgaWNvbnNMb2FkRXJyb3IoZWRpdG9yLCB1cmxNZXRhLnVybCwgdXJsTWV0YS5uYW1lLmdldE9yVW5kZWZpbmVkKCkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgbG9hZFBsdWdpbnMgPSAoZWRpdG9yLCBzdWZmaXgpID0+IHtcbiAgICAgIGNvbnN0IGxvYWRQbHVnaW4gPSAobmFtZSwgdXJsKSA9PiB7XG4gICAgICAgIFBsdWdpbk1hbmFnZXIubG9hZChuYW1lLCB1cmwpLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICBwbHVnaW5Mb2FkRXJyb3IoZWRpdG9yLCB1cmwsIG5hbWUpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBlYWNoJGYoZ2V0RXh0ZXJuYWxQbHVnaW5zJDEoZWRpdG9yKSwgKHVybCwgbmFtZSkgPT4ge1xuICAgICAgICBsb2FkUGx1Z2luKG5hbWUsIHVybCk7XG4gICAgICAgIGVkaXRvci5vcHRpb25zLnNldCgncGx1Z2lucycsIGdldFBsdWdpbnMoZWRpdG9yKS5jb25jYXQobmFtZSkpO1xuICAgICAgfSk7XG4gICAgICBlYWNoJGcoZ2V0UGx1Z2lucyhlZGl0b3IpLCBwbHVnaW4gPT4ge1xuICAgICAgICBwbHVnaW4gPSBUb29scy50cmltKHBsdWdpbik7XG4gICAgICAgIGlmIChwbHVnaW4gJiYgIVBsdWdpbk1hbmFnZXIudXJsc1twbHVnaW5dICYmICFoYXNTa2lwTG9hZFByZWZpeChwbHVnaW4pKSB7XG4gICAgICAgICAgbG9hZFBsdWdpbihwbHVnaW4sIGBwbHVnaW5zLyR7IHBsdWdpbiB9L3BsdWdpbiR7IHN1ZmZpeCB9LmpzYCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgaXNUaGVtZUxvYWRlZCA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCB0aGVtZSA9IGdldFRoZW1lKGVkaXRvcik7XG4gICAgICByZXR1cm4gIWlzU3RyaW5nKHRoZW1lKSB8fCBpc05vbk51bGxhYmxlKFRoZW1lTWFuYWdlci5nZXQodGhlbWUpKTtcbiAgICB9O1xuICAgIGNvbnN0IGlzTW9kZWxMb2FkZWQgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgbW9kZWwgPSBnZXRNb2RlbChlZGl0b3IpO1xuICAgICAgcmV0dXJuIGlzTm9uTnVsbGFibGUoTW9kZWxNYW5hZ2VyLmdldChtb2RlbCkpO1xuICAgIH07XG4gICAgY29uc3QgbG9hZFNjcmlwdHMgPSAoZWRpdG9yLCBzdWZmaXgpID0+IHtcbiAgICAgIGNvbnN0IHNjcmlwdExvYWRlciA9IFNjcmlwdExvYWRlci5TY3JpcHRMb2FkZXI7XG4gICAgICBjb25zdCBpbml0RWRpdG9yID0gKCkgPT4ge1xuICAgICAgICBpZiAoIWVkaXRvci5yZW1vdmVkICYmIGlzVGhlbWVMb2FkZWQoZWRpdG9yKSAmJiBpc01vZGVsTG9hZGVkKGVkaXRvcikpIHtcbiAgICAgICAgICBpbml0KGVkaXRvcik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBsb2FkVGhlbWUoZWRpdG9yLCBzdWZmaXgpO1xuICAgICAgbG9hZE1vZGVsKGVkaXRvciwgc3VmZml4KTtcbiAgICAgIGxvYWRMYW5ndWFnZShzY3JpcHRMb2FkZXIsIGVkaXRvcik7XG4gICAgICBsb2FkSWNvbnMoc2NyaXB0TG9hZGVyLCBlZGl0b3IsIHN1ZmZpeCk7XG4gICAgICBsb2FkUGx1Z2lucyhlZGl0b3IsIHN1ZmZpeCk7XG4gICAgICBzY3JpcHRMb2FkZXIubG9hZFF1ZXVlKCkudGhlbihpbml0RWRpdG9yLCBpbml0RWRpdG9yKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldFN0eWxlU2hlZXRMb2FkZXIgPSAoZWxlbWVudCwgZWRpdG9yKSA9PiBpbnN0YW5jZS5mb3JFbGVtZW50KGVsZW1lbnQsIHtcbiAgICAgIGNvbnRlbnRDc3NDb3JzOiBoYXNDb250ZW50Q3NzQ29ycyhlZGl0b3IpLFxuICAgICAgcmVmZXJyZXJQb2xpY3k6IGdldFJlZmVycmVyUG9saWN5KGVkaXRvcilcbiAgICB9KTtcbiAgICBjb25zdCByZW5kZXIgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgaWQgPSBlZGl0b3IuaWQ7XG4gICAgICBJMThuLnNldENvZGUoZ2V0TGFuZ3VhZ2VDb2RlKGVkaXRvcikpO1xuICAgICAgY29uc3QgcmVhZHlIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICBET00kMy51bmJpbmQod2luZG93LCAncmVhZHknLCByZWFkeUhhbmRsZXIpO1xuICAgICAgICBlZGl0b3IucmVuZGVyKCk7XG4gICAgICB9O1xuICAgICAgaWYgKCFFdmVudFV0aWxzLkV2ZW50LmRvbUxvYWRlZCkge1xuICAgICAgICBET00kMy5iaW5kKHdpbmRvdywgJ3JlYWR5JywgcmVhZHlIYW5kbGVyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFlZGl0b3IuZ2V0RWxlbWVudCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBTdWdhckVsZW1lbnQuZnJvbURvbShlZGl0b3IuZ2V0RWxlbWVudCgpKTtcbiAgICAgIGNvbnN0IHNuYXBzaG90ID0gY2xvbmUkNChlbGVtZW50KTtcbiAgICAgIGVkaXRvci5vbigncmVtb3ZlJywgKCkgPT4ge1xuICAgICAgICBlYWNocihlbGVtZW50LmRvbS5hdHRyaWJ1dGVzLCBhdHRyID0+IHJlbW92ZSRhKGVsZW1lbnQsIGF0dHIubmFtZSkpO1xuICAgICAgICBzZXRBbGwkMShlbGVtZW50LCBzbmFwc2hvdCk7XG4gICAgICB9KTtcbiAgICAgIGVkaXRvci51aS5zdHlsZVNoZWV0TG9hZGVyID0gZ2V0U3R5bGVTaGVldExvYWRlcihlbGVtZW50LCBlZGl0b3IpO1xuICAgICAgaWYgKCFpc0lubGluZShlZGl0b3IpKSB7XG4gICAgICAgIGVkaXRvci5vcmdWaXNpYmlsaXR5ID0gZWRpdG9yLmdldEVsZW1lbnQoKS5zdHlsZS52aXNpYmlsaXR5O1xuICAgICAgICBlZGl0b3IuZ2V0RWxlbWVudCgpLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVkaXRvci5pbmxpbmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgZm9ybSA9IGVkaXRvci5nZXRFbGVtZW50KCkuZm9ybSB8fCBET00kMy5nZXRQYXJlbnQoaWQsICdmb3JtJyk7XG4gICAgICBpZiAoZm9ybSkge1xuICAgICAgICBlZGl0b3IuZm9ybUVsZW1lbnQgPSBmb3JtO1xuICAgICAgICBpZiAoaGFzSGlkZGVuSW5wdXQoZWRpdG9yKSAmJiAhaXNUZXh0YXJlYU9ySW5wdXQoZWRpdG9yLmdldEVsZW1lbnQoKSkpIHtcbiAgICAgICAgICBET00kMy5pbnNlcnRBZnRlcihET00kMy5jcmVhdGUoJ2lucHV0Jywge1xuICAgICAgICAgICAgdHlwZTogJ2hpZGRlbicsXG4gICAgICAgICAgICBuYW1lOiBpZFxuICAgICAgICAgIH0pLCBpZCk7XG4gICAgICAgICAgZWRpdG9yLmhhc0hpZGRlbklucHV0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlZGl0b3IuZm9ybUV2ZW50RGVsZWdhdGUgPSBlID0+IHtcbiAgICAgICAgICBlZGl0b3IuZGlzcGF0Y2goZS50eXBlLCBlKTtcbiAgICAgICAgfTtcbiAgICAgICAgRE9NJDMuYmluZChmb3JtLCAnc3VibWl0IHJlc2V0JywgZWRpdG9yLmZvcm1FdmVudERlbGVnYXRlKTtcbiAgICAgICAgZWRpdG9yLm9uKCdyZXNldCcsICgpID0+IHtcbiAgICAgICAgICBlZGl0b3IucmVzZXRDb250ZW50KCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc2hvdWxkUGF0Y2hTdWJtaXQoZWRpdG9yKSAmJiAhZm9ybS5zdWJtaXQubm9kZVR5cGUgJiYgIWZvcm0uc3VibWl0Lmxlbmd0aCAmJiAhZm9ybS5fbWNlT2xkU3VibWl0KSB7XG4gICAgICAgICAgZm9ybS5fbWNlT2xkU3VibWl0ID0gZm9ybS5zdWJtaXQ7XG4gICAgICAgICAgZm9ybS5zdWJtaXQgPSAoKSA9PiB7XG4gICAgICAgICAgICBlZGl0b3IuZWRpdG9yTWFuYWdlci50cmlnZ2VyU2F2ZSgpO1xuICAgICAgICAgICAgZWRpdG9yLnNldERpcnR5KGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiBmb3JtLl9tY2VPbGRTdWJtaXQoZm9ybSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWRpdG9yLndpbmRvd01hbmFnZXIgPSBXaW5kb3dNYW5hZ2VyKGVkaXRvcik7XG4gICAgICBlZGl0b3Iubm90aWZpY2F0aW9uTWFuYWdlciA9IE5vdGlmaWNhdGlvbk1hbmFnZXIoZWRpdG9yKTtcbiAgICAgIGlmIChpc0VuY29kaW5nWG1sKGVkaXRvcikpIHtcbiAgICAgICAgZWRpdG9yLm9uKCdHZXRDb250ZW50JywgZSA9PiB7XG4gICAgICAgICAgaWYgKGUuc2F2ZSkge1xuICAgICAgICAgICAgZS5jb250ZW50ID0gRE9NJDMuZW5jb2RlKGUuY29udGVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRBZGRGb3JtU3VibWl0VHJpZ2dlcihlZGl0b3IpKSB7XG4gICAgICAgIGVkaXRvci5vbignc3VibWl0JywgKCkgPT4ge1xuICAgICAgICAgIGlmIChlZGl0b3IuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIGVkaXRvci5zYXZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRBZGRVbmxvYWRUcmlnZ2VyKGVkaXRvcikpIHtcbiAgICAgICAgZWRpdG9yLl9iZWZvcmVVbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgaWYgKGVkaXRvci5pbml0aWFsaXplZCAmJiAhZWRpdG9yLmRlc3Ryb3llZCAmJiAhZWRpdG9yLmlzSGlkZGVuKCkpIHtcbiAgICAgICAgICAgIGVkaXRvci5zYXZlKHtcbiAgICAgICAgICAgICAgZm9ybWF0OiAncmF3JyxcbiAgICAgICAgICAgICAgbm9fZXZlbnRzOiB0cnVlLFxuICAgICAgICAgICAgICBzZXRfZGlydHk6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGVkaXRvci5lZGl0b3JNYW5hZ2VyLm9uKCdCZWZvcmVVbmxvYWQnLCBlZGl0b3IuX2JlZm9yZVVubG9hZCk7XG4gICAgICB9XG4gICAgICBlZGl0b3IuZWRpdG9yTWFuYWdlci5hZGQoZWRpdG9yKTtcbiAgICAgIGxvYWRTY3JpcHRzKGVkaXRvciwgZWRpdG9yLnN1ZmZpeCk7XG4gICAgfTtcblxuICAgIGNvbnN0IHNlY3Rpb25SZXN1bHQgPSAoc2VjdGlvbnMsIHNldHRpbmdzKSA9PiAoe1xuICAgICAgc2VjdGlvbnM6IGNvbnN0YW50KHNlY3Rpb25zKSxcbiAgICAgIG9wdGlvbnM6IGNvbnN0YW50KHNldHRpbmdzKVxuICAgIH0pO1xuICAgIGNvbnN0IGRldmljZURldGVjdGlvbiA9IGRldGVjdCQyKCkuZGV2aWNlVHlwZTtcbiAgICBjb25zdCBpc1Bob25lID0gZGV2aWNlRGV0ZWN0aW9uLmlzUGhvbmUoKTtcbiAgICBjb25zdCBpc1RhYmxldCA9IGRldmljZURldGVjdGlvbi5pc1RhYmxldCgpO1xuICAgIGNvbnN0IG5vcm1hbGl6ZVBsdWdpbnMgPSBwbHVnaW5zID0+IHtcbiAgICAgIGlmIChpc051bGxhYmxlKHBsdWdpbnMpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHBsdWdpbk5hbWVzID0gaXNBcnJheSQxKHBsdWdpbnMpID8gcGx1Z2lucyA6IHBsdWdpbnMuc3BsaXQoL1sgLF0vKTtcbiAgICAgICAgY29uc3QgdHJpbW1lZFBsdWdpbnMgPSBtYXAkMyhwbHVnaW5OYW1lcywgdHJpbSQzKTtcbiAgICAgICAgcmV0dXJuIGZpbHRlciQ2KHRyaW1tZWRQbHVnaW5zLCBpc05vdEVtcHR5KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGV4dHJhY3RTZWN0aW9ucyA9IChrZXlzLCBvcHRpb25zKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBiaWZpbHRlcihvcHRpb25zLCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICByZXR1cm4gY29udGFpbnMkMihrZXlzLCBrZXkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gc2VjdGlvblJlc3VsdChyZXN1bHQudCwgcmVzdWx0LmYpO1xuICAgIH07XG4gICAgY29uc3QgZ2V0U2VjdGlvbiA9IChzZWN0aW9uUmVzdWx0LCBuYW1lLCBkZWZhdWx0cyA9IHt9KSA9PiB7XG4gICAgICBjb25zdCBzZWN0aW9ucyA9IHNlY3Rpb25SZXN1bHQuc2VjdGlvbnMoKTtcbiAgICAgIGNvbnN0IHNlY3Rpb25PcHRpb25zID0gZ2V0JGEoc2VjdGlvbnMsIG5hbWUpLmdldE9yKHt9KTtcbiAgICAgIHJldHVybiBUb29scy5leHRlbmQoe30sIGRlZmF1bHRzLCBzZWN0aW9uT3B0aW9ucyk7XG4gICAgfTtcbiAgICBjb25zdCBoYXNTZWN0aW9uID0gKHNlY3Rpb25SZXN1bHQsIG5hbWUpID0+IHtcbiAgICAgIHJldHVybiBoYXMkMihzZWN0aW9uUmVzdWx0LnNlY3Rpb25zKCksIG5hbWUpO1xuICAgIH07XG4gICAgY29uc3QgZ2V0U2VjdGlvbkNvbmZpZyA9IChzZWN0aW9uUmVzdWx0LCBuYW1lKSA9PiB7XG4gICAgICByZXR1cm4gaGFzU2VjdGlvbihzZWN0aW9uUmVzdWx0LCBuYW1lKSA/IHNlY3Rpb25SZXN1bHQuc2VjdGlvbnMoKVtuYW1lXSA6IHt9O1xuICAgIH07XG4gICAgY29uc3QgZ2V0TW9iaWxlT3ZlcnJpZGVPcHRpb25zID0gKG1vYmlsZU9wdGlvbnMsIGlzUGhvbmUpID0+IHtcbiAgICAgIGNvbnN0IGRlZmF1bHRNb2JpbGVPcHRpb25zID0ge1xuICAgICAgICB0YWJsZV9ncmlkOiBmYWxzZSxcbiAgICAgICAgb2JqZWN0X3Jlc2l6aW5nOiBmYWxzZSxcbiAgICAgICAgcmVzaXplOiBmYWxzZSxcbiAgICAgICAgdG9vbGJhcl9tb2RlOiBnZXQkYShtb2JpbGVPcHRpb25zLCAndG9vbGJhcl9tb2RlJykuZ2V0T3IoJ3Njcm9sbGluZycpLFxuICAgICAgICB0b29sYmFyX3N0aWNreTogZmFsc2VcbiAgICAgIH07XG4gICAgICBjb25zdCBkZWZhdWx0UGhvbmVPcHRpb25zID0geyBtZW51YmFyOiBmYWxzZSB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uZGVmYXVsdE1vYmlsZU9wdGlvbnMsXG4gICAgICAgIC4uLmlzUGhvbmUgPyBkZWZhdWx0UGhvbmVPcHRpb25zIDoge31cbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBnZXRFeHRlcm5hbFBsdWdpbnMgPSAob3ZlcnJpZGVPcHRpb25zLCBvcHRpb25zKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCB1c2VyRGVmaW5lZEV4dGVybmFsUGx1Z2lucyA9IChfYSA9IG9wdGlvbnMuZXh0ZXJuYWxfcGx1Z2lucykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge307XG4gICAgICBpZiAob3ZlcnJpZGVPcHRpb25zICYmIG92ZXJyaWRlT3B0aW9ucy5leHRlcm5hbF9wbHVnaW5zKSB7XG4gICAgICAgIHJldHVybiBUb29scy5leHRlbmQoe30sIG92ZXJyaWRlT3B0aW9ucy5leHRlcm5hbF9wbHVnaW5zLCB1c2VyRGVmaW5lZEV4dGVybmFsUGx1Z2lucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdXNlckRlZmluZWRFeHRlcm5hbFBsdWdpbnM7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBjb21iaW5lUGx1Z2lucyA9IChmb3JjZWRQbHVnaW5zLCBwbHVnaW5zKSA9PiB7XG4gICAgICByZXR1cm4gW10uY29uY2F0KG5vcm1hbGl6ZVBsdWdpbnMoZm9yY2VkUGx1Z2lucykpLmNvbmNhdChub3JtYWxpemVQbHVnaW5zKHBsdWdpbnMpKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldFBsYXRmb3JtUGx1Z2lucyA9IChpc01vYmlsZURldmljZSwgc2VjdGlvblJlc3VsdCwgZGVza3RvcFBsdWdpbnMsIG1vYmlsZVBsdWdpbnMpID0+IHtcbiAgICAgIGlmIChpc01vYmlsZURldmljZSAmJiBoYXNTZWN0aW9uKHNlY3Rpb25SZXN1bHQsICdtb2JpbGUnKSkge1xuICAgICAgICByZXR1cm4gbW9iaWxlUGx1Z2lucztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkZXNrdG9wUGx1Z2lucztcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHByb2Nlc3NQbHVnaW5zID0gKGlzTW9iaWxlRGV2aWNlLCBzZWN0aW9uUmVzdWx0LCBkZWZhdWx0T3ZlcnJpZGVPcHRpb25zLCBvcHRpb25zKSA9PiB7XG4gICAgICBjb25zdCBmb3JjZWRQbHVnaW5zID0gbm9ybWFsaXplUGx1Z2lucyhkZWZhdWx0T3ZlcnJpZGVPcHRpb25zLmZvcmNlZF9wbHVnaW5zKTtcbiAgICAgIGNvbnN0IGRlc2t0b3BQbHVnaW5zID0gbm9ybWFsaXplUGx1Z2lucyhvcHRpb25zLnBsdWdpbnMpO1xuICAgICAgY29uc3QgbW9iaWxlQ29uZmlnID0gZ2V0U2VjdGlvbkNvbmZpZyhzZWN0aW9uUmVzdWx0LCAnbW9iaWxlJyk7XG4gICAgICBjb25zdCBtb2JpbGVQbHVnaW5zID0gbW9iaWxlQ29uZmlnLnBsdWdpbnMgPyBub3JtYWxpemVQbHVnaW5zKG1vYmlsZUNvbmZpZy5wbHVnaW5zKSA6IGRlc2t0b3BQbHVnaW5zO1xuICAgICAgY29uc3QgcGxhdGZvcm1QbHVnaW5zID0gZ2V0UGxhdGZvcm1QbHVnaW5zKGlzTW9iaWxlRGV2aWNlLCBzZWN0aW9uUmVzdWx0LCBkZXNrdG9wUGx1Z2lucywgbW9iaWxlUGx1Z2lucyk7XG4gICAgICBjb25zdCBjb21iaW5lZFBsdWdpbnMgPSBjb21iaW5lUGx1Z2lucyhmb3JjZWRQbHVnaW5zLCBwbGF0Zm9ybVBsdWdpbnMpO1xuICAgICAgcmV0dXJuIFRvb2xzLmV4dGVuZChvcHRpb25zLCB7XG4gICAgICAgIGZvcmNlZF9wbHVnaW5zOiBmb3JjZWRQbHVnaW5zLFxuICAgICAgICBwbHVnaW5zOiBjb21iaW5lZFBsdWdpbnNcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgaXNPbk1vYmlsZSA9IChpc01vYmlsZURldmljZSwgc2VjdGlvblJlc3VsdCkgPT4ge1xuICAgICAgcmV0dXJuIGlzTW9iaWxlRGV2aWNlICYmIGhhc1NlY3Rpb24oc2VjdGlvblJlc3VsdCwgJ21vYmlsZScpO1xuICAgIH07XG4gICAgY29uc3QgY29tYmluZU9wdGlvbnMgPSAoaXNNb2JpbGVEZXZpY2UsIGlzUGhvbmUsIGRlZmF1bHRPcHRpb25zLCBkZWZhdWx0T3ZlcnJpZGVPcHRpb25zLCBvcHRpb25zKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBkZXZpY2VPdmVycmlkZU9wdGlvbnMgPSBpc01vYmlsZURldmljZSA/IHsgbW9iaWxlOiBnZXRNb2JpbGVPdmVycmlkZU9wdGlvbnMoKF9hID0gb3B0aW9ucy5tb2JpbGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9LCBpc1Bob25lKSB9IDoge307XG4gICAgICBjb25zdCBzZWN0aW9uUmVzdWx0ID0gZXh0cmFjdFNlY3Rpb25zKFsnbW9iaWxlJ10sIGRlZXBNZXJnZShkZXZpY2VPdmVycmlkZU9wdGlvbnMsIG9wdGlvbnMpKTtcbiAgICAgIGNvbnN0IGV4dGVuZGVkT3B0aW9ucyA9IFRvb2xzLmV4dGVuZChkZWZhdWx0T3B0aW9ucywgZGVmYXVsdE92ZXJyaWRlT3B0aW9ucywgc2VjdGlvblJlc3VsdC5vcHRpb25zKCksIGlzT25Nb2JpbGUoaXNNb2JpbGVEZXZpY2UsIHNlY3Rpb25SZXN1bHQpID8gZ2V0U2VjdGlvbihzZWN0aW9uUmVzdWx0LCAnbW9iaWxlJykgOiB7fSwgeyBleHRlcm5hbF9wbHVnaW5zOiBnZXRFeHRlcm5hbFBsdWdpbnMoZGVmYXVsdE92ZXJyaWRlT3B0aW9ucywgc2VjdGlvblJlc3VsdC5vcHRpb25zKCkpIH0pO1xuICAgICAgcmV0dXJuIHByb2Nlc3NQbHVnaW5zKGlzTW9iaWxlRGV2aWNlLCBzZWN0aW9uUmVzdWx0LCBkZWZhdWx0T3ZlcnJpZGVPcHRpb25zLCBleHRlbmRlZE9wdGlvbnMpO1xuICAgIH07XG4gICAgY29uc3Qgbm9ybWFsaXplT3B0aW9ucyA9IChkZWZhdWx0T3ZlcnJpZGVPcHRpb25zLCBvcHRpb25zKSA9PiBjb21iaW5lT3B0aW9ucyhpc1Bob25lIHx8IGlzVGFibGV0LCBpc1Bob25lLCBvcHRpb25zLCBkZWZhdWx0T3ZlcnJpZGVPcHRpb25zLCBvcHRpb25zKTtcblxuICAgIGNvbnN0IGFkZFZpc3VhbCA9IChlZGl0b3IsIGVsbSkgPT4gYWRkVmlzdWFsJDEoZWRpdG9yLCBlbG0pO1xuXG4gICAgY29uc3QgcmVnaXN0ZXJFeGVjQ29tbWFuZHMkMyA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCB0b2dnbGVGb3JtYXQgPSAobmFtZSwgdmFsdWUpID0+IHtcbiAgICAgICAgZWRpdG9yLmZvcm1hdHRlci50b2dnbGUobmFtZSwgdmFsdWUpO1xuICAgICAgICBlZGl0b3Iubm9kZUNoYW5nZWQoKTtcbiAgICAgIH07XG4gICAgICBjb25zdCB0b2dnbGVBbGlnbiA9IGFsaWduID0+ICgpID0+IHtcbiAgICAgICAgZWFjaCRnKCdsZWZ0LGNlbnRlcixyaWdodCxqdXN0aWZ5Jy5zcGxpdCgnLCcpLCBuYW1lID0+IHtcbiAgICAgICAgICBpZiAoYWxpZ24gIT09IG5hbWUpIHtcbiAgICAgICAgICAgIGVkaXRvci5mb3JtYXR0ZXIucmVtb3ZlKCdhbGlnbicgKyBuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoYWxpZ24gIT09ICdub25lJykge1xuICAgICAgICAgIHRvZ2dsZUZvcm1hdCgnYWxpZ24nICsgYWxpZ24pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZWRpdG9yLmVkaXRvckNvbW1hbmRzLmFkZENvbW1hbmRzKHtcbiAgICAgICAgSnVzdGlmeUxlZnQ6IHRvZ2dsZUFsaWduKCdsZWZ0JyksXG4gICAgICAgIEp1c3RpZnlDZW50ZXI6IHRvZ2dsZUFsaWduKCdjZW50ZXInKSxcbiAgICAgICAgSnVzdGlmeVJpZ2h0OiB0b2dnbGVBbGlnbigncmlnaHQnKSxcbiAgICAgICAgSnVzdGlmeUZ1bGw6IHRvZ2dsZUFsaWduKCdqdXN0aWZ5JyksXG4gICAgICAgIEp1c3RpZnlOb25lOiB0b2dnbGVBbGlnbignbm9uZScpXG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHJlZ2lzdGVyUXVlcnlTdGF0ZUNvbW1hbmRzJDEgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgYWxpZ25TdGF0ZXMgPSBuYW1lID0+ICgpID0+IHtcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbjtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSBzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSA/IFtlZGl0b3IuZG9tLmdldFBhcmVudChzZWxlY3Rpb24uZ2V0Tm9kZSgpLCBlZGl0b3IuZG9tLmlzQmxvY2spXSA6IHNlbGVjdGlvbi5nZXRTZWxlY3RlZEJsb2NrcygpO1xuICAgICAgICByZXR1cm4gZXhpc3RzKG5vZGVzLCBub2RlID0+IGlzTm9uTnVsbGFibGUoZWRpdG9yLmZvcm1hdHRlci5tYXRjaE5vZGUobm9kZSwgbmFtZSkpKTtcbiAgICAgIH07XG4gICAgICBlZGl0b3IuZWRpdG9yQ29tbWFuZHMuYWRkQ29tbWFuZHMoe1xuICAgICAgICBKdXN0aWZ5TGVmdDogYWxpZ25TdGF0ZXMoJ2FsaWdubGVmdCcpLFxuICAgICAgICBKdXN0aWZ5Q2VudGVyOiBhbGlnblN0YXRlcygnYWxpZ25jZW50ZXInKSxcbiAgICAgICAgSnVzdGlmeVJpZ2h0OiBhbGlnblN0YXRlcygnYWxpZ25yaWdodCcpLFxuICAgICAgICBKdXN0aWZ5RnVsbDogYWxpZ25TdGF0ZXMoJ2FsaWduanVzdGlmeScpXG4gICAgICB9LCAnc3RhdGUnKTtcbiAgICB9O1xuICAgIGNvbnN0IHJlZ2lzdGVyQ29tbWFuZHMkYSA9IGVkaXRvciA9PiB7XG4gICAgICByZWdpc3RlckV4ZWNDb21tYW5kcyQzKGVkaXRvcik7XG4gICAgICByZWdpc3RlclF1ZXJ5U3RhdGVDb21tYW5kcyQxKGVkaXRvcik7XG4gICAgfTtcblxuICAgIGNvbnN0IHJlZ2lzdGVyQ29tbWFuZHMkOSA9IGVkaXRvciA9PiB7XG4gICAgICBlZGl0b3IuZWRpdG9yQ29tbWFuZHMuYWRkQ29tbWFuZHMoe1xuICAgICAgICAnQ3V0LENvcHksUGFzdGUnOiBjb21tYW5kID0+IHtcbiAgICAgICAgICBjb25zdCBkb2MgPSBlZGl0b3IuZ2V0RG9jKCk7XG4gICAgICAgICAgbGV0IGZhaWxlZDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZG9jLmV4ZWNDb21tYW5kKGNvbW1hbmQpO1xuICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICBmYWlsZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29tbWFuZCA9PT0gJ3Bhc3RlJyAmJiAhZG9jLnF1ZXJ5Q29tbWFuZEVuYWJsZWQoY29tbWFuZCkpIHtcbiAgICAgICAgICAgIGZhaWxlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmYWlsZWQgfHwgIWRvYy5xdWVyeUNvbW1hbmRTdXBwb3J0ZWQoY29tbWFuZCkpIHtcbiAgICAgICAgICAgIGxldCBtc2cgPSBlZGl0b3IudHJhbnNsYXRlKGBZb3VyIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IGRpcmVjdCBhY2Nlc3MgdG8gdGhlIGNsaXBib2FyZC4gYCArICdQbGVhc2UgdXNlIHRoZSBDdHJsK1gvQy9WIGtleWJvYXJkIHNob3J0Y3V0cyBpbnN0ZWFkLicpO1xuICAgICAgICAgICAgaWYgKEVudi5vcy5pc01hY09TKCkgfHwgRW52Lm9zLmlzaU9TKCkpIHtcbiAgICAgICAgICAgICAgbXNnID0gbXNnLnJlcGxhY2UoL0N0cmxcXCsvZywgJ1xcdTIzMTgrJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlZGl0b3Iubm90aWZpY2F0aW9uTWFuYWdlci5vcGVuKHtcbiAgICAgICAgICAgICAgdGV4dDogbXNnLFxuICAgICAgICAgICAgICB0eXBlOiAnZXJyb3InXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCB0cmltT3JQYWRMZWZ0UmlnaHQgPSAoZG9tLCBybmcsIGh0bWwpID0+IHtcbiAgICAgIGNvbnN0IHJvb3QgPSBTdWdhckVsZW1lbnQuZnJvbURvbShkb20uZ2V0Um9vdCgpKTtcbiAgICAgIGlmIChuZWVkc1RvQmVOYnNwTGVmdChyb290LCBDYXJldFBvc2l0aW9uLmZyb21SYW5nZVN0YXJ0KHJuZykpKSB7XG4gICAgICAgIGh0bWwgPSBodG1sLnJlcGxhY2UoL14gLywgJyZuYnNwOycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaHRtbCA9IGh0bWwucmVwbGFjZSgvXiZuYnNwOy8sICcgJyk7XG4gICAgICB9XG4gICAgICBpZiAobmVlZHNUb0JlTmJzcFJpZ2h0KHJvb3QsIENhcmV0UG9zaXRpb24uZnJvbVJhbmdlRW5kKHJuZykpKSB7XG4gICAgICAgIGh0bWwgPSBodG1sLnJlcGxhY2UoLygmbmJzcDt8ICkoPGJyKCBcXC8pPik/JC8sICcmbmJzcDsnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGh0bWwgPSBodG1sLnJlcGxhY2UoLyZuYnNwOyg8YnIoIFxcLyk/Pik/JC8sICcgJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaHRtbDtcbiAgICB9O1xuXG4gICAgY29uc3QgcHJvY2Vzc1ZhbHVlJDEgPSB2YWx1ZSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCBkZXRhaWxzID0gVG9vbHMuZXh0ZW5kKHtcbiAgICAgICAgICBwYXN0ZTogdmFsdWUucGFzdGUsXG4gICAgICAgICAgZGF0YTogeyBwYXN0ZTogdmFsdWUucGFzdGUgfVxuICAgICAgICB9LCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY29udGVudDogdmFsdWUuY29udGVudCxcbiAgICAgICAgICBkZXRhaWxzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb250ZW50OiB2YWx1ZSxcbiAgICAgICAgZGV0YWlsczoge31cbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCB0cmltT3JQYWQgPSAoZWRpdG9yLCB2YWx1ZSkgPT4ge1xuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbjtcbiAgICAgIGNvbnN0IGRvbSA9IGVkaXRvci5kb207XG4gICAgICBpZiAoL14gfCAkLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdHJpbU9yUGFkTGVmdFJpZ2h0KGRvbSwgc2VsZWN0aW9uLmdldFJuZygpLCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBpbnNlcnRBdENhcmV0ID0gKGVkaXRvciwgdmFsdWUpID0+IHtcbiAgICAgIGNvbnN0IHtjb250ZW50LCBkZXRhaWxzfSA9IHByb2Nlc3NWYWx1ZSQxKHZhbHVlKTtcbiAgICAgIHByZVByb2Nlc3NTZXRDb250ZW50KGVkaXRvciwge1xuICAgICAgICBjb250ZW50OiB0cmltT3JQYWQoZWRpdG9yLCBjb250ZW50KSxcbiAgICAgICAgZm9ybWF0OiAnaHRtbCcsXG4gICAgICAgIHNldDogZmFsc2UsXG4gICAgICAgIHNlbGVjdGlvbjogdHJ1ZSxcbiAgICAgICAgcGFzdGU6IGRldGFpbHMucGFzdGVcbiAgICAgIH0pLmVhY2goYXJncyA9PiB7XG4gICAgICAgIGNvbnN0IGluc2VydGVkQ29udGVudCA9IGluc2VydENvbnRlbnQkMShlZGl0b3IsIGFyZ3MuY29udGVudCwgZGV0YWlscyk7XG4gICAgICAgIHBvc3RQcm9jZXNzU2V0Q29udGVudChlZGl0b3IsIGluc2VydGVkQ29udGVudCwgYXJncyk7XG4gICAgICAgIGVkaXRvci5hZGRWaXN1YWwoKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCByZWdpc3RlckNvbW1hbmRzJDggPSBlZGl0b3IgPT4ge1xuICAgICAgZWRpdG9yLmVkaXRvckNvbW1hbmRzLmFkZENvbW1hbmRzKHtcbiAgICAgICAgbWNlQ2xlYW51cDogKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGJtID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRCb29rbWFyaygpO1xuICAgICAgICAgIGVkaXRvci5zZXRDb250ZW50KGVkaXRvci5nZXRDb250ZW50KCkpO1xuICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24ubW92ZVRvQm9va21hcmsoYm0pO1xuICAgICAgICB9LFxuICAgICAgICBpbnNlcnRJbWFnZTogKF9jb21tYW5kLCBfdWksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgaW5zZXJ0QXRDYXJldChlZGl0b3IsIGVkaXRvci5kb20uY3JlYXRlSFRNTCgnaW1nJywgeyBzcmM6IHZhbHVlIH0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgaW5zZXJ0SG9yaXpvbnRhbFJ1bGU6ICgpID0+IHtcbiAgICAgICAgICBlZGl0b3IuZXhlY0NvbW1hbmQoJ21jZUluc2VydENvbnRlbnQnLCBmYWxzZSwgJzxocj4nKTtcbiAgICAgICAgfSxcbiAgICAgICAgaW5zZXJ0VGV4dDogKF9jb21tYW5kLCBfdWksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgaW5zZXJ0QXRDYXJldChlZGl0b3IsIGVkaXRvci5kb20uZW5jb2RlKHZhbHVlKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGluc2VydEhUTUw6IChfY29tbWFuZCwgX3VpLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgIGluc2VydEF0Q2FyZXQoZWRpdG9yLCB2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIG1jZUluc2VydENvbnRlbnQ6IChfY29tbWFuZCwgX3VpLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgIGluc2VydEF0Q2FyZXQoZWRpdG9yLCB2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIG1jZVNldENvbnRlbnQ6IChfY29tbWFuZCwgX3VpLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgIGVkaXRvci5zZXRDb250ZW50KHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgbWNlUmVwbGFjZUNvbnRlbnQ6IChfY29tbWFuZCwgX3VpLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgIGVkaXRvci5leGVjQ29tbWFuZCgnbWNlSW5zZXJ0Q29udGVudCcsIGZhbHNlLCB2YWx1ZS5yZXBsYWNlKC9cXHtcXCRzZWxlY3Rpb25cXH0vZywgZWRpdG9yLnNlbGVjdGlvbi5nZXRDb250ZW50KHsgZm9ybWF0OiAndGV4dCcgfSkpKTtcbiAgICAgICAgfSxcbiAgICAgICAgbWNlTmV3RG9jdW1lbnQ6ICgpID0+IHtcbiAgICAgICAgICBlZGl0b3Iuc2V0Q29udGVudCgnJyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCBsZWdhY3lQcm9wTmFtZXMgPSB7XG4gICAgICAnZm9udC1zaXplJzogJ3NpemUnLFxuICAgICAgJ2ZvbnQtZmFtaWx5JzogJ2ZhY2UnXG4gICAgfTtcbiAgICBjb25zdCBnZXRTcGVjaWZpZWRGb250UHJvcCA9IChwcm9wTmFtZSwgcm9vdEVsbSwgZWxtKSA9PiB7XG4gICAgICBjb25zdCBnZXRQcm9wZXJ0eSA9IGVsbSA9PiBnZXRSYXckMShlbG0sIHByb3BOYW1lKS5vclRodW5rKCgpID0+IHtcbiAgICAgICAgaWYgKG5hbWUoZWxtKSA9PT0gJ2ZvbnQnKSB7XG4gICAgICAgICAgcmV0dXJuIGdldCRhKGxlZ2FjeVByb3BOYW1lcywgcHJvcE5hbWUpLmJpbmQobGVnYWN5UHJvcE5hbWUgPT4gZ2V0T3B0KGVsbSwgbGVnYWN5UHJvcE5hbWUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGlzUm9vdCA9IGVsbSA9PiBlcShTdWdhckVsZW1lbnQuZnJvbURvbShyb290RWxtKSwgZWxtKTtcbiAgICAgIHJldHVybiBjbG9zZXN0JDIoU3VnYXJFbGVtZW50LmZyb21Eb20oZWxtKSwgZWxtID0+IGdldFByb3BlcnR5KGVsbSksIGlzUm9vdCk7XG4gICAgfTtcbiAgICBjb25zdCBub3JtYWxpemVGb250RmFtaWx5ID0gZm9udEZhbWlseSA9PiBmb250RmFtaWx5LnJlcGxhY2UoL1tcXCdcXFwiXFxcXF0vZywgJycpLnJlcGxhY2UoLyxcXHMrL2csICcsJyk7XG4gICAgY29uc3QgZ2V0Q29tcHV0ZWRGb250UHJvcCA9IChwcm9wTmFtZSwgZWxtKSA9PiBPcHRpb25hbC5mcm9tKERPTVV0aWxzLkRPTS5nZXRTdHlsZShlbG0sIHByb3BOYW1lLCB0cnVlKSk7XG4gICAgY29uc3QgZ2V0Rm9udFByb3AgPSBwcm9wTmFtZSA9PiAocm9vdEVsbSwgZWxtKSA9PiBPcHRpb25hbC5mcm9tKGVsbSkubWFwKFN1Z2FyRWxlbWVudC5mcm9tRG9tKS5maWx0ZXIoaXNFbGVtZW50JDcpLmJpbmQoZWxlbWVudCA9PiBnZXRTcGVjaWZpZWRGb250UHJvcChwcm9wTmFtZSwgcm9vdEVsbSwgZWxlbWVudC5kb20pLm9yKGdldENvbXB1dGVkRm9udFByb3AocHJvcE5hbWUsIGVsZW1lbnQuZG9tKSkpLmdldE9yKCcnKTtcbiAgICBjb25zdCBnZXRGb250U2l6ZSA9IGdldEZvbnRQcm9wKCdmb250LXNpemUnKTtcbiAgICBjb25zdCBnZXRGb250RmFtaWx5ID0gY29tcG9zZShub3JtYWxpemVGb250RmFtaWx5LCBnZXRGb250UHJvcCgnZm9udC1mYW1pbHknKSk7XG5cbiAgICBjb25zdCBmaW5kRmlyc3RDYXJldEVsZW1lbnQgPSBlZGl0b3IgPT4gZmlyc3RQb3NpdGlvbkluKGVkaXRvci5nZXRCb2R5KCkpLm1hcChjYXJldCA9PiB7XG4gICAgICBjb25zdCBjb250YWluZXIgPSBjYXJldC5jb250YWluZXIoKTtcbiAgICAgIHJldHVybiBpc1RleHQkOChjb250YWluZXIpID8gY29udGFpbmVyLnBhcmVudE5vZGUgOiBjb250YWluZXI7XG4gICAgfSk7XG4gICAgY29uc3QgZ2V0Q2FyZXRFbGVtZW50ID0gZWRpdG9yID0+IE9wdGlvbmFsLmZyb20oZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKSkuYmluZChybmcgPT4ge1xuICAgICAgY29uc3Qgcm9vdCA9IGVkaXRvci5nZXRCb2R5KCk7XG4gICAgICBjb25zdCBhdFN0YXJ0T2ZOb2RlID0gcm5nLnN0YXJ0Q29udGFpbmVyID09PSByb290ICYmIHJuZy5zdGFydE9mZnNldCA9PT0gMDtcbiAgICAgIHJldHVybiBhdFN0YXJ0T2ZOb2RlID8gT3B0aW9uYWwubm9uZSgpIDogT3B0aW9uYWwuZnJvbShlZGl0b3Iuc2VsZWN0aW9uLmdldFN0YXJ0KHRydWUpKTtcbiAgICB9KTtcbiAgICBjb25zdCBiaW5kUmFuZ2UgPSAoZWRpdG9yLCBiaW5kZXIpID0+IGdldENhcmV0RWxlbWVudChlZGl0b3IpLm9yVGh1bmsoY3VycnkoZmluZEZpcnN0Q2FyZXRFbGVtZW50LCBlZGl0b3IpKS5tYXAoU3VnYXJFbGVtZW50LmZyb21Eb20pLmZpbHRlcihpc0VsZW1lbnQkNykuYmluZChiaW5kZXIpO1xuICAgIGNvbnN0IG1hcFJhbmdlID0gKGVkaXRvciwgbWFwcGVyKSA9PiBiaW5kUmFuZ2UoZWRpdG9yLCBjb21wb3NlMShPcHRpb25hbC5zb21lLCBtYXBwZXIpKTtcblxuICAgIGNvbnN0IGZyb21Gb250U2l6ZU51bWJlciA9IChlZGl0b3IsIHZhbHVlKSA9PiB7XG4gICAgICBpZiAoL15bMC05Ll0rJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgY29uc3QgZm9udFNpemVOdW1iZXIgPSBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgICAgICBpZiAoZm9udFNpemVOdW1iZXIgPj0gMSAmJiBmb250U2l6ZU51bWJlciA8PSA3KSB7XG4gICAgICAgICAgY29uc3QgZm9udFNpemVzID0gZ2V0Rm9udFN0eWxlVmFsdWVzKGVkaXRvcik7XG4gICAgICAgICAgY29uc3QgZm9udENsYXNzZXMgPSBnZXRGb250U2l6ZUNsYXNzZXMoZWRpdG9yKTtcbiAgICAgICAgICBpZiAoZm9udENsYXNzZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmb250Q2xhc3Nlc1tmb250U2l6ZU51bWJlciAtIDFdIHx8IHZhbHVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZm9udFNpemVzW2ZvbnRTaXplTnVtYmVyIC0gMV0gfHwgdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgbm9ybWFsaXplRm9udE5hbWVzID0gZm9udCA9PiB7XG4gICAgICBjb25zdCBmb250cyA9IGZvbnQuc3BsaXQoL1xccyosXFxzKi8pO1xuICAgICAgcmV0dXJuIG1hcCQzKGZvbnRzLCBmb250ID0+IHtcbiAgICAgICAgaWYgKGZvbnQuaW5kZXhPZignICcpICE9PSAtMSAmJiAhKHN0YXJ0c1dpdGgoZm9udCwgJ1wiJykgfHwgc3RhcnRzV2l0aChmb250LCBgJ2ApKSkge1xuICAgICAgICAgIHJldHVybiBgJyR7IGZvbnQgfSdgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmb250O1xuICAgICAgICB9XG4gICAgICB9KS5qb2luKCcsJyk7XG4gICAgfTtcbiAgICBjb25zdCBmb250TmFtZUFjdGlvbiA9IChlZGl0b3IsIHZhbHVlKSA9PiB7XG4gICAgICBjb25zdCBmb250ID0gZnJvbUZvbnRTaXplTnVtYmVyKGVkaXRvciwgdmFsdWUpO1xuICAgICAgZWRpdG9yLmZvcm1hdHRlci50b2dnbGUoJ2ZvbnRuYW1lJywgeyB2YWx1ZTogbm9ybWFsaXplRm9udE5hbWVzKGZvbnQpIH0pO1xuICAgICAgZWRpdG9yLm5vZGVDaGFuZ2VkKCk7XG4gICAgfTtcbiAgICBjb25zdCBmb250TmFtZVF1ZXJ5ID0gZWRpdG9yID0+IG1hcFJhbmdlKGVkaXRvciwgZWxtID0+IGdldEZvbnRGYW1pbHkoZWRpdG9yLmdldEJvZHkoKSwgZWxtLmRvbSkpLmdldE9yKCcnKTtcbiAgICBjb25zdCBmb250U2l6ZUFjdGlvbiA9IChlZGl0b3IsIHZhbHVlKSA9PiB7XG4gICAgICBlZGl0b3IuZm9ybWF0dGVyLnRvZ2dsZSgnZm9udHNpemUnLCB7IHZhbHVlOiBmcm9tRm9udFNpemVOdW1iZXIoZWRpdG9yLCB2YWx1ZSkgfSk7XG4gICAgICBlZGl0b3Iubm9kZUNoYW5nZWQoKTtcbiAgICB9O1xuICAgIGNvbnN0IGZvbnRTaXplUXVlcnkgPSBlZGl0b3IgPT4gbWFwUmFuZ2UoZWRpdG9yLCBlbG0gPT4gZ2V0Rm9udFNpemUoZWRpdG9yLmdldEJvZHkoKSwgZWxtLmRvbSkpLmdldE9yKCcnKTtcblxuICAgIGNvbnN0IGxpbmVIZWlnaHRRdWVyeSA9IGVkaXRvciA9PiBtYXBSYW5nZShlZGl0b3IsIGVsbSA9PiB7XG4gICAgICBjb25zdCByb290ID0gU3VnYXJFbGVtZW50LmZyb21Eb20oZWRpdG9yLmdldEJvZHkoKSk7XG4gICAgICBjb25zdCBzcGVjaWZpZWRTdHlsZSA9IGNsb3Nlc3QkMihlbG0sIGVsbSA9PiBnZXRSYXckMShlbG0sICdsaW5lLWhlaWdodCcpLCBjdXJyeShlcSwgcm9vdCkpO1xuICAgICAgY29uc3QgY29tcHV0ZWRTdHlsZSA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgbGluZUhlaWdodCA9IHBhcnNlRmxvYXQoZ2V0JDcoZWxtLCAnbGluZS1oZWlnaHQnKSk7XG4gICAgICAgIGNvbnN0IGZvbnRTaXplID0gcGFyc2VGbG9hdChnZXQkNyhlbG0sICdmb250LXNpemUnKSk7XG4gICAgICAgIHJldHVybiBTdHJpbmcobGluZUhlaWdodCAvIGZvbnRTaXplKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gc3BlY2lmaWVkU3R5bGUuZ2V0T3JUaHVuayhjb21wdXRlZFN0eWxlKTtcbiAgICB9KS5nZXRPcignJyk7XG4gICAgY29uc3QgbGluZUhlaWdodEFjdGlvbiA9IChlZGl0b3IsIGxpbmVIZWlnaHQpID0+IHtcbiAgICAgIGVkaXRvci5mb3JtYXR0ZXIudG9nZ2xlKCdsaW5laGVpZ2h0JywgeyB2YWx1ZTogU3RyaW5nKGxpbmVIZWlnaHQpIH0pO1xuICAgICAgZWRpdG9yLm5vZGVDaGFuZ2VkKCk7XG4gICAgfTtcblxuICAgIGNvbnN0IHJlZ2lzdGVyRXhlY0NvbW1hbmRzJDIgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgdG9nZ2xlRm9ybWF0ID0gKG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICAgIGVkaXRvci5mb3JtYXR0ZXIudG9nZ2xlKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgZWRpdG9yLm5vZGVDaGFuZ2VkKCk7XG4gICAgICB9O1xuICAgICAgZWRpdG9yLmVkaXRvckNvbW1hbmRzLmFkZENvbW1hbmRzKHtcbiAgICAgICAgJ0JvbGQsSXRhbGljLFVuZGVybGluZSxTdHJpa2V0aHJvdWdoLFN1cGVyc2NyaXB0LFN1YnNjcmlwdCc6IGNvbW1hbmQgPT4ge1xuICAgICAgICAgIHRvZ2dsZUZvcm1hdChjb21tYW5kKTtcbiAgICAgICAgfSxcbiAgICAgICAgJ0ZvcmVDb2xvcixIaWxpdGVDb2xvcic6IChjb21tYW5kLCBfdWksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgdG9nZ2xlRm9ybWF0KGNvbW1hbmQsIHsgdmFsdWUgfSk7XG4gICAgICAgIH0sXG4gICAgICAgICdCYWNrQ29sb3InOiAoX2NvbW1hbmQsIF91aSwgdmFsdWUpID0+IHtcbiAgICAgICAgICB0b2dnbGVGb3JtYXQoJ2hpbGl0ZWNvbG9yJywgeyB2YWx1ZSB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgJ0ZvbnROYW1lJzogKF9jb21tYW5kLCBfdWksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgZm9udE5hbWVBY3Rpb24oZWRpdG9yLCB2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgICdGb250U2l6ZSc6IChfY29tbWFuZCwgX3VpLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgIGZvbnRTaXplQWN0aW9uKGVkaXRvciwgdmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICAnTGluZUhlaWdodCc6IChfY29tbWFuZCwgX3VpLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgIGxpbmVIZWlnaHRBY3Rpb24oZWRpdG9yLCB2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgICdMYW5nJzogKGNvbW1hbmQsIF91aSwgbGFuZykgPT4ge1xuICAgICAgICAgIHRvZ2dsZUZvcm1hdChjb21tYW5kLCB7XG4gICAgICAgICAgICB2YWx1ZTogbGFuZy5jb2RlLFxuICAgICAgICAgICAgY3VzdG9tVmFsdWU6IGxhbmcuY3VzdG9tQ29kZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICAnUmVtb3ZlRm9ybWF0JzogY29tbWFuZCA9PiB7XG4gICAgICAgICAgZWRpdG9yLmZvcm1hdHRlci5yZW1vdmUoY29tbWFuZCk7XG4gICAgICAgIH0sXG4gICAgICAgICdtY2VCbG9ja1F1b3RlJzogKCkgPT4ge1xuICAgICAgICAgIHRvZ2dsZUZvcm1hdCgnYmxvY2txdW90ZScpO1xuICAgICAgICB9LFxuICAgICAgICAnRm9ybWF0QmxvY2snOiAoX2NvbW1hbmQsIF91aSwgdmFsdWUpID0+IHtcbiAgICAgICAgICB0b2dnbGVGb3JtYXQoaXNTdHJpbmcodmFsdWUpID8gdmFsdWUgOiAncCcpO1xuICAgICAgICB9LFxuICAgICAgICAnbWNlVG9nZ2xlRm9ybWF0JzogKF9jb21tYW5kLCBfdWksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgdG9nZ2xlRm9ybWF0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCByZWdpc3RlclF1ZXJ5VmFsdWVDb21tYW5kcyA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBpc0Zvcm1hdE1hdGNoID0gbmFtZSA9PiBlZGl0b3IuZm9ybWF0dGVyLm1hdGNoKG5hbWUpO1xuICAgICAgZWRpdG9yLmVkaXRvckNvbW1hbmRzLmFkZENvbW1hbmRzKHtcbiAgICAgICAgJ0JvbGQsSXRhbGljLFVuZGVybGluZSxTdHJpa2V0aHJvdWdoLFN1cGVyc2NyaXB0LFN1YnNjcmlwdCc6IGNvbW1hbmQgPT4gaXNGb3JtYXRNYXRjaChjb21tYW5kKSxcbiAgICAgICAgJ21jZUJsb2NrUXVvdGUnOiAoKSA9PiBpc0Zvcm1hdE1hdGNoKCdibG9ja3F1b3RlJylcbiAgICAgIH0sICdzdGF0ZScpO1xuICAgICAgZWRpdG9yLmVkaXRvckNvbW1hbmRzLmFkZFF1ZXJ5VmFsdWVIYW5kbGVyKCdGb250TmFtZScsICgpID0+IGZvbnROYW1lUXVlcnkoZWRpdG9yKSk7XG4gICAgICBlZGl0b3IuZWRpdG9yQ29tbWFuZHMuYWRkUXVlcnlWYWx1ZUhhbmRsZXIoJ0ZvbnRTaXplJywgKCkgPT4gZm9udFNpemVRdWVyeShlZGl0b3IpKTtcbiAgICAgIGVkaXRvci5lZGl0b3JDb21tYW5kcy5hZGRRdWVyeVZhbHVlSGFuZGxlcignTGluZUhlaWdodCcsICgpID0+IGxpbmVIZWlnaHRRdWVyeShlZGl0b3IpKTtcbiAgICB9O1xuICAgIGNvbnN0IHJlZ2lzdGVyQ29tbWFuZHMkNyA9IGVkaXRvciA9PiB7XG4gICAgICByZWdpc3RlckV4ZWNDb21tYW5kcyQyKGVkaXRvcik7XG4gICAgICByZWdpc3RlclF1ZXJ5VmFsdWVDb21tYW5kcyhlZGl0b3IpO1xuICAgIH07XG5cbiAgICBjb25zdCByZWdpc3RlckNvbW1hbmRzJDYgPSBlZGl0b3IgPT4ge1xuICAgICAgZWRpdG9yLmVkaXRvckNvbW1hbmRzLmFkZENvbW1hbmRzKHtcbiAgICAgICAgbWNlQWRkVW5kb0xldmVsOiAoKSA9PiB7XG4gICAgICAgICAgZWRpdG9yLnVuZG9NYW5hZ2VyLmFkZCgpO1xuICAgICAgICB9LFxuICAgICAgICBtY2VFbmRVbmRvTGV2ZWw6ICgpID0+IHtcbiAgICAgICAgICBlZGl0b3IudW5kb01hbmFnZXIuYWRkKCk7XG4gICAgICAgIH0sXG4gICAgICAgIFVuZG86ICgpID0+IHtcbiAgICAgICAgICBlZGl0b3IudW5kb01hbmFnZXIudW5kbygpO1xuICAgICAgICB9LFxuICAgICAgICBSZWRvOiAoKSA9PiB7XG4gICAgICAgICAgZWRpdG9yLnVuZG9NYW5hZ2VyLnJlZG8oKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IHJlZ2lzdGVyQ29tbWFuZHMkNSA9IGVkaXRvciA9PiB7XG4gICAgICBlZGl0b3IuZWRpdG9yQ29tbWFuZHMuYWRkQ29tbWFuZHMoe1xuICAgICAgICBJbmRlbnQ6ICgpID0+IHtcbiAgICAgICAgICBpbmRlbnQoZWRpdG9yKTtcbiAgICAgICAgfSxcbiAgICAgICAgT3V0ZGVudDogKCkgPT4ge1xuICAgICAgICAgIG91dGRlbnQoZWRpdG9yKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBlZGl0b3IuZWRpdG9yQ29tbWFuZHMuYWRkQ29tbWFuZHMoeyBPdXRkZW50OiAoKSA9PiBjYW5PdXRkZW50KGVkaXRvcikgfSwgJ3N0YXRlJyk7XG4gICAgfTtcblxuICAgIGNvbnN0IHJlZ2lzdGVyQ29tbWFuZHMkNCA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBhcHBseUxpbmtUb1NlbGVjdGlvbiA9IChfY29tbWFuZCwgX3VpLCB2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCBsaW5rRGV0YWlscyA9IGlzU3RyaW5nKHZhbHVlKSA/IHsgaHJlZjogdmFsdWUgfSA6IHZhbHVlO1xuICAgICAgICBjb25zdCBhbmNob3IgPSBlZGl0b3IuZG9tLmdldFBhcmVudChlZGl0b3Iuc2VsZWN0aW9uLmdldE5vZGUoKSwgJ2EnKTtcbiAgICAgICAgaWYgKGlzT2JqZWN0KGxpbmtEZXRhaWxzKSAmJiBpc1N0cmluZyhsaW5rRGV0YWlscy5ocmVmKSkge1xuICAgICAgICAgIGxpbmtEZXRhaWxzLmhyZWYgPSBsaW5rRGV0YWlscy5ocmVmLnJlcGxhY2UoLyAvZywgJyUyMCcpO1xuICAgICAgICAgIGlmICghYW5jaG9yIHx8ICFsaW5rRGV0YWlscy5ocmVmKSB7XG4gICAgICAgICAgICBlZGl0b3IuZm9ybWF0dGVyLnJlbW92ZSgnbGluaycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobGlua0RldGFpbHMuaHJlZikge1xuICAgICAgICAgICAgZWRpdG9yLmZvcm1hdHRlci5hcHBseSgnbGluaycsIGxpbmtEZXRhaWxzLCBhbmNob3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGVkaXRvci5lZGl0b3JDb21tYW5kcy5hZGRDb21tYW5kcyh7XG4gICAgICAgIHVubGluazogKCkgPT4ge1xuICAgICAgICAgIGlmIChlZGl0b3Iuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGVsbSA9IGVkaXRvci5kb20uZ2V0UGFyZW50KGVkaXRvci5zZWxlY3Rpb24uZ2V0U3RhcnQoKSwgJ2EnKTtcbiAgICAgICAgICAgIGlmIChlbG0pIHtcbiAgICAgICAgICAgICAgZWRpdG9yLmRvbS5yZW1vdmUoZWxtLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWRpdG9yLmZvcm1hdHRlci5yZW1vdmUoJ2xpbmsnKTtcbiAgICAgICAgfSxcbiAgICAgICAgbWNlSW5zZXJ0TGluazogYXBwbHlMaW5rVG9TZWxlY3Rpb24sXG4gICAgICAgIGNyZWF0ZUxpbms6IGFwcGx5TGlua1RvU2VsZWN0aW9uXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3QgcmVnaXN0ZXJFeGVjQ29tbWFuZHMkMSA9IGVkaXRvciA9PiB7XG4gICAgICBlZGl0b3IuZWRpdG9yQ29tbWFuZHMuYWRkQ29tbWFuZHMoe1xuICAgICAgICAnSW5zZXJ0VW5vcmRlcmVkTGlzdCxJbnNlcnRPcmRlcmVkTGlzdCc6IGNvbW1hbmQgPT4ge1xuICAgICAgICAgIGVkaXRvci5nZXREb2MoKS5leGVjQ29tbWFuZChjb21tYW5kKTtcbiAgICAgICAgICBjb25zdCBsaXN0RWxtID0gZWRpdG9yLmRvbS5nZXRQYXJlbnQoZWRpdG9yLnNlbGVjdGlvbi5nZXROb2RlKCksICdvbCx1bCcpO1xuICAgICAgICAgIGlmIChsaXN0RWxtKSB7XG4gICAgICAgICAgICBjb25zdCBsaXN0UGFyZW50ID0gbGlzdEVsbS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgaWYgKC9eKEhbMS02XXxQfEFERFJFU1N8UFJFKSQvLnRlc3QobGlzdFBhcmVudC5ub2RlTmFtZSkpIHtcbiAgICAgICAgICAgICAgY29uc3QgYm0gPSBlZGl0b3Iuc2VsZWN0aW9uLmdldEJvb2ttYXJrKCk7XG4gICAgICAgICAgICAgIGVkaXRvci5kb20uc3BsaXQobGlzdFBhcmVudCwgbGlzdEVsbSk7XG4gICAgICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24ubW92ZVRvQm9va21hcmsoYm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCByZWdpc3RlclF1ZXJ5U3RhdGVDb21tYW5kcyA9IGVkaXRvciA9PiB7XG4gICAgICBlZGl0b3IuZWRpdG9yQ29tbWFuZHMuYWRkQ29tbWFuZHMoe1xuICAgICAgICAnSW5zZXJ0VW5vcmRlcmVkTGlzdCxJbnNlcnRPcmRlcmVkTGlzdCc6IGNvbW1hbmQgPT4ge1xuICAgICAgICAgIGNvbnN0IGxpc3QgPSBlZGl0b3IuZG9tLmdldFBhcmVudChlZGl0b3Iuc2VsZWN0aW9uLmdldE5vZGUoKSwgJ3VsLG9sJyk7XG4gICAgICAgICAgcmV0dXJuIGxpc3QgJiYgKGNvbW1hbmQgPT09ICdpbnNlcnR1bm9yZGVyZWRsaXN0JyAmJiBsaXN0LnRhZ05hbWUgPT09ICdVTCcgfHwgY29tbWFuZCA9PT0gJ2luc2VydG9yZGVyZWRsaXN0JyAmJiBsaXN0LnRhZ05hbWUgPT09ICdPTCcpO1xuICAgICAgICB9XG4gICAgICB9LCAnc3RhdGUnKTtcbiAgICB9O1xuICAgIGNvbnN0IHJlZ2lzdGVyQ29tbWFuZHMkMyA9IGVkaXRvciA9PiB7XG4gICAgICByZWdpc3RlckV4ZWNDb21tYW5kcyQxKGVkaXRvcik7XG4gICAgICByZWdpc3RlclF1ZXJ5U3RhdGVDb21tYW5kcyhlZGl0b3IpO1xuICAgIH07XG5cbiAgICBjb25zdCByZWdpc3RlckNvbW1hbmRzJDIgPSBlZGl0b3IgPT4ge1xuICAgICAgZWRpdG9yLmVkaXRvckNvbW1hbmRzLmFkZENvbW1hbmRzKHtcbiAgICAgICAgaW5zZXJ0UGFyYWdyYXBoOiAoKSA9PiB7XG4gICAgICAgICAgaW5zZXJ0KGVkaXRvcik7XG4gICAgICAgIH0sXG4gICAgICAgIG1jZUluc2VydE5ld0xpbmU6IChfY29tbWFuZCwgX3VpLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgIGluc2VydChlZGl0b3IsIHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgSW5zZXJ0TGluZUJyZWFrOiAoX2NvbW1hbmQsIF91aSwgdmFsdWUpID0+IHtcbiAgICAgICAgICBpbnNlcnQkMShlZGl0b3IsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IHJlZ2lzdGVyQ29tbWFuZHMkMSA9IGVkaXRvciA9PiB7XG4gICAgICBlZGl0b3IuZWRpdG9yQ29tbWFuZHMuYWRkQ29tbWFuZHMoe1xuICAgICAgICBtY2VTZWxlY3ROb2RlRGVwdGg6IChfY29tbWFuZCwgX3VpLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgIGxldCBjb3VudGVyID0gMDtcbiAgICAgICAgICBlZGl0b3IuZG9tLmdldFBhcmVudChlZGl0b3Iuc2VsZWN0aW9uLmdldE5vZGUoKSwgbm9kZSA9PiB7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBjb3VudGVyKysgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2VsZWN0KG5vZGUpO1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgZWRpdG9yLmdldEJvZHkoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIG1jZVNlbGVjdE5vZGU6IChfY29tbWFuZCwgX3VpLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2VsZWN0KHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2VsZWN0QWxsOiAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgZWRpdGluZ0hvc3QgPSBlZGl0b3IuZG9tLmdldFBhcmVudChlZGl0b3Iuc2VsZWN0aW9uLmdldFN0YXJ0KCksIGlzQ29udGVudEVkaXRhYmxlVHJ1ZSQ0KTtcbiAgICAgICAgICBpZiAoZWRpdGluZ0hvc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHJuZyA9IGVkaXRvci5kb20uY3JlYXRlUm5nKCk7XG4gICAgICAgICAgICBybmcuc2VsZWN0Tm9kZUNvbnRlbnRzKGVkaXRpbmdIb3N0KTtcbiAgICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2V0Um5nKHJuZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3QgcmVnaXN0ZXJFeGVjQ29tbWFuZHMgPSBlZGl0b3IgPT4ge1xuICAgICAgZWRpdG9yLmVkaXRvckNvbW1hbmRzLmFkZENvbW1hbmRzKHtcbiAgICAgICAgbWNlUmVtb3ZlTm9kZTogKF9jb21tYW5kLCBfdWksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9IHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB2b2lkIDAgPyB2YWx1ZSA6IGVkaXRvci5zZWxlY3Rpb24uZ2V0Tm9kZSgpO1xuICAgICAgICAgIGlmIChub2RlICE9PSBlZGl0b3IuZ2V0Qm9keSgpKSB7XG4gICAgICAgICAgICBjb25zdCBibSA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0Qm9va21hcmsoKTtcbiAgICAgICAgICAgIGVkaXRvci5kb20ucmVtb3ZlKG5vZGUsIHRydWUpO1xuICAgICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5tb3ZlVG9Cb29rbWFyayhibSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtY2VQcmludDogKCkgPT4ge1xuICAgICAgICAgIGVkaXRvci5nZXRXaW4oKS5wcmludCgpO1xuICAgICAgICB9LFxuICAgICAgICBtY2VGb2N1czogKF9jb21tYW5kLCBfdWksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgZm9jdXMoZWRpdG9yLCB2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIG1jZVRvZ2dsZVZpc3VhbEFpZDogKCkgPT4ge1xuICAgICAgICAgIGVkaXRvci5oYXNWaXN1YWwgPSAhZWRpdG9yLmhhc1Zpc3VhbDtcbiAgICAgICAgICBlZGl0b3IuYWRkVmlzdWFsKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgcmVnaXN0ZXJDb21tYW5kcyA9IGVkaXRvciA9PiB7XG4gICAgICByZWdpc3RlckNvbW1hbmRzJGEoZWRpdG9yKTtcbiAgICAgIHJlZ2lzdGVyQ29tbWFuZHMkOShlZGl0b3IpO1xuICAgICAgcmVnaXN0ZXJDb21tYW5kcyQ2KGVkaXRvcik7XG4gICAgICByZWdpc3RlckNvbW1hbmRzJDEoZWRpdG9yKTtcbiAgICAgIHJlZ2lzdGVyQ29tbWFuZHMkOChlZGl0b3IpO1xuICAgICAgcmVnaXN0ZXJDb21tYW5kcyQ0KGVkaXRvcik7XG4gICAgICByZWdpc3RlckNvbW1hbmRzJDUoZWRpdG9yKTtcbiAgICAgIHJlZ2lzdGVyQ29tbWFuZHMkMihlZGl0b3IpO1xuICAgICAgcmVnaXN0ZXJDb21tYW5kcyQzKGVkaXRvcik7XG4gICAgICByZWdpc3RlckNvbW1hbmRzJDcoZWRpdG9yKTtcbiAgICAgIHJlZ2lzdGVyRXhlY0NvbW1hbmRzKGVkaXRvcik7XG4gICAgfTtcblxuICAgIGNsYXNzIEVkaXRvckNvbW1hbmRzIHtcbiAgICAgIGNvbnN0cnVjdG9yKGVkaXRvcikge1xuICAgICAgICB0aGlzLmNvbW1hbmRzID0ge1xuICAgICAgICAgIHN0YXRlOiB7fSxcbiAgICAgICAgICBleGVjOiB7fSxcbiAgICAgICAgICB2YWx1ZToge31cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5lZGl0b3IgPSBlZGl0b3I7XG4gICAgICB9XG4gICAgICBleGVjQ29tbWFuZChjb21tYW5kLCB1aSwgdmFsdWUsIGFyZ3MpIHtcbiAgICAgICAgY29uc3QgZWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgICAgIGNvbnN0IGxvd2VyQ2FzZUNvbW1hbmQgPSBjb21tYW5kLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IHNraXBGb2N1cyA9IGFyZ3MgPT09IG51bGwgfHwgYXJncyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXJncy5za2lwX2ZvY3VzO1xuICAgICAgICBpZiAoZWRpdG9yLnJlbW92ZWQpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvd2VyQ2FzZUNvbW1hbmQgIT09ICdtY2Vmb2N1cycpIHtcbiAgICAgICAgICBpZiAoIS9eKG1jZUFkZFVuZG9MZXZlbHxtY2VFbmRVbmRvTGV2ZWwpJC9pLnRlc3QobG93ZXJDYXNlQ29tbWFuZCkgJiYgIXNraXBGb2N1cykge1xuICAgICAgICAgICAgZWRpdG9yLmZvY3VzKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3RvcmUoZWRpdG9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXZlbnRBcmdzID0gZWRpdG9yLmRpc3BhdGNoKCdCZWZvcmVFeGVjQ29tbWFuZCcsIHtcbiAgICAgICAgICBjb21tYW5kLFxuICAgICAgICAgIHVpLFxuICAgICAgICAgIHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZXZlbnRBcmdzLmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZ1bmMgPSB0aGlzLmNvbW1hbmRzLmV4ZWNbbG93ZXJDYXNlQ29tbWFuZF07XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgICAgZnVuYyhsb3dlckNhc2VDb21tYW5kLCB1aSwgdmFsdWUpO1xuICAgICAgICAgIGVkaXRvci5kaXNwYXRjaCgnRXhlY0NvbW1hbmQnLCB7XG4gICAgICAgICAgICBjb21tYW5kLFxuICAgICAgICAgICAgdWksXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5Q29tbWFuZFN0YXRlKGNvbW1hbmQpIHtcbiAgICAgICAgaWYgKHRoaXMuZWRpdG9yLnF1aXJrcy5pc0hpZGRlbigpIHx8IHRoaXMuZWRpdG9yLnJlbW92ZWQpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbG93ZXJDYXNlQ29tbWFuZCA9IGNvbW1hbmQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgZnVuYyA9IHRoaXMuY29tbWFuZHMuc3RhdGVbbG93ZXJDYXNlQ29tbWFuZF07XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMobG93ZXJDYXNlQ29tbWFuZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcXVlcnlDb21tYW5kVmFsdWUoY29tbWFuZCkge1xuICAgICAgICBpZiAodGhpcy5lZGl0b3IucXVpcmtzLmlzSGlkZGVuKCkgfHwgdGhpcy5lZGl0b3IucmVtb3ZlZCkge1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsb3dlckNhc2VDb21tYW5kID0gY29tbWFuZC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCBmdW5jID0gdGhpcy5jb21tYW5kcy52YWx1ZVtsb3dlckNhc2VDb21tYW5kXTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYyhsb3dlckNhc2VDb21tYW5kKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgICBhZGRDb21tYW5kcyhjb21tYW5kTGlzdCwgdHlwZSA9ICdleGVjJykge1xuICAgICAgICBjb25zdCBjb21tYW5kcyA9IHRoaXMuY29tbWFuZHM7XG4gICAgICAgIGVhY2gkZihjb21tYW5kTGlzdCwgKGNhbGxiYWNrLCBjb21tYW5kKSA9PiB7XG4gICAgICAgICAgZWFjaCRnKGNvbW1hbmQudG9Mb3dlckNhc2UoKS5zcGxpdCgnLCcpLCBjb21tYW5kID0+IHtcbiAgICAgICAgICAgIGNvbW1hbmRzW3R5cGVdW2NvbW1hbmRdID0gY2FsbGJhY2s7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgYWRkQ29tbWFuZChjb21tYW5kLCBjYWxsYmFjaywgc2NvcGUpIHtcbiAgICAgICAgY29uc3QgbG93ZXJDYXNlQ29tbWFuZCA9IGNvbW1hbmQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdGhpcy5jb21tYW5kcy5leGVjW2xvd2VyQ2FzZUNvbW1hbmRdID0gKF9jb21tYW5kLCB1aSwgdmFsdWUpID0+IGNhbGxiYWNrLmNhbGwoc2NvcGUgIT09IG51bGwgJiYgc2NvcGUgIT09IHZvaWQgMCA/IHNjb3BlIDogdGhpcy5lZGl0b3IsIHVpLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICBxdWVyeUNvbW1hbmRTdXBwb3J0ZWQoY29tbWFuZCkge1xuICAgICAgICBjb25zdCBsb3dlckNhc2VDb21tYW5kID0gY29tbWFuZC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAodGhpcy5jb21tYW5kcy5leGVjW2xvd2VyQ2FzZUNvbW1hbmRdKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgYWRkUXVlcnlTdGF0ZUhhbmRsZXIoY29tbWFuZCwgY2FsbGJhY2ssIHNjb3BlKSB7XG4gICAgICAgIHRoaXMuY29tbWFuZHMuc3RhdGVbY29tbWFuZC50b0xvd2VyQ2FzZSgpXSA9ICgpID0+IGNhbGxiYWNrLmNhbGwoc2NvcGUgIT09IG51bGwgJiYgc2NvcGUgIT09IHZvaWQgMCA/IHNjb3BlIDogdGhpcy5lZGl0b3IpO1xuICAgICAgfVxuICAgICAgYWRkUXVlcnlWYWx1ZUhhbmRsZXIoY29tbWFuZCwgY2FsbGJhY2ssIHNjb3BlKSB7XG4gICAgICAgIHRoaXMuY29tbWFuZHMudmFsdWVbY29tbWFuZC50b0xvd2VyQ2FzZSgpXSA9ICgpID0+IGNhbGxiYWNrLmNhbGwoc2NvcGUgIT09IG51bGwgJiYgc2NvcGUgIT09IHZvaWQgMCA/IHNjb3BlIDogdGhpcy5lZGl0b3IpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGludGVybmFsQ29udGVudEVkaXRhYmxlQXR0ciA9ICdkYXRhLW1jZS1jb250ZW50ZWRpdGFibGUnO1xuICAgIGNvbnN0IHRvZ2dsZUNsYXNzID0gKGVsbSwgY2xzLCBzdGF0ZSkgPT4ge1xuICAgICAgaWYgKGhhcyhlbG0sIGNscykgJiYgc3RhdGUgPT09IGZhbHNlKSB7XG4gICAgICAgIHJlbW92ZSQ3KGVsbSwgY2xzKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUpIHtcbiAgICAgICAgYWRkJDIoZWxtLCBjbHMpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgc2V0RWRpdG9yQ29tbWFuZFN0YXRlID0gKGVkaXRvciwgY21kLCBzdGF0ZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZWRpdG9yLmdldERvYygpLmV4ZWNDb21tYW5kKGNtZCwgZmFsc2UsIFN0cmluZyhzdGF0ZSkpO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHNldENvbnRlbnRFZGl0YWJsZSA9IChlbG0sIHN0YXRlKSA9PiB7XG4gICAgICBlbG0uZG9tLmNvbnRlbnRFZGl0YWJsZSA9IHN0YXRlID8gJ3RydWUnIDogJ2ZhbHNlJztcbiAgICB9O1xuICAgIGNvbnN0IHN3aXRjaE9mZkNvbnRlbnRFZGl0YWJsZVRydWUgPSBlbG0gPT4ge1xuICAgICAgZWFjaCRnKGRlc2NlbmRhbnRzKGVsbSwgJypbY29udGVudGVkaXRhYmxlPVwidHJ1ZVwiXScpLCBlbG0gPT4ge1xuICAgICAgICBzZXQkMihlbG0sIGludGVybmFsQ29udGVudEVkaXRhYmxlQXR0ciwgJ3RydWUnKTtcbiAgICAgICAgc2V0Q29udGVudEVkaXRhYmxlKGVsbSwgZmFsc2UpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBzd2l0Y2hPbkNvbnRlbnRFZGl0YWJsZVRydWUgPSBlbG0gPT4ge1xuICAgICAgZWFjaCRnKGRlc2NlbmRhbnRzKGVsbSwgYCpbJHsgaW50ZXJuYWxDb250ZW50RWRpdGFibGVBdHRyIH09XCJ0cnVlXCJdYCksIGVsbSA9PiB7XG4gICAgICAgIHJlbW92ZSRhKGVsbSwgaW50ZXJuYWxDb250ZW50RWRpdGFibGVBdHRyKTtcbiAgICAgICAgc2V0Q29udGVudEVkaXRhYmxlKGVsbSwgdHJ1ZSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHJlbW92ZUZha2VTZWxlY3Rpb24gPSBlZGl0b3IgPT4ge1xuICAgICAgT3B0aW9uYWwuZnJvbShlZGl0b3Iuc2VsZWN0aW9uLmdldE5vZGUoKSkuZWFjaChlbG0gPT4ge1xuICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlKCdkYXRhLW1jZS1zZWxlY3RlZCcpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCByZXN0b3JlRmFrZVNlbGVjdGlvbiA9IGVkaXRvciA9PiB7XG4gICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNldFJuZyhlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpKTtcbiAgICB9O1xuICAgIGNvbnN0IHRvZ2dsZVJlYWRPbmx5ID0gKGVkaXRvciwgc3RhdGUpID0+IHtcbiAgICAgIGNvbnN0IGJvZHkgPSBTdWdhckVsZW1lbnQuZnJvbURvbShlZGl0b3IuZ2V0Qm9keSgpKTtcbiAgICAgIHRvZ2dsZUNsYXNzKGJvZHksICdtY2UtY29udGVudC1yZWFkb25seScsIHN0YXRlKTtcbiAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLmNvbnRyb2xTZWxlY3Rpb24uaGlkZVJlc2l6ZVJlY3QoKTtcbiAgICAgICAgZWRpdG9yLl9zZWxlY3Rpb25PdmVycmlkZXMuaGlkZUZha2VDYXJldCgpO1xuICAgICAgICByZW1vdmVGYWtlU2VsZWN0aW9uKGVkaXRvcik7XG4gICAgICAgIGVkaXRvci5yZWFkb25seSA9IHRydWU7XG4gICAgICAgIHNldENvbnRlbnRFZGl0YWJsZShib2R5LCBmYWxzZSk7XG4gICAgICAgIHN3aXRjaE9mZkNvbnRlbnRFZGl0YWJsZVRydWUoYm9keSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlZGl0b3IucmVhZG9ubHkgPSBmYWxzZTtcbiAgICAgICAgc2V0Q29udGVudEVkaXRhYmxlKGJvZHksIHRydWUpO1xuICAgICAgICBzd2l0Y2hPbkNvbnRlbnRFZGl0YWJsZVRydWUoYm9keSk7XG4gICAgICAgIHNldEVkaXRvckNvbW1hbmRTdGF0ZShlZGl0b3IsICdTdHlsZVdpdGhDU1MnLCBmYWxzZSk7XG4gICAgICAgIHNldEVkaXRvckNvbW1hbmRTdGF0ZShlZGl0b3IsICdlbmFibGVJbmxpbmVUYWJsZUVkaXRpbmcnLCBmYWxzZSk7XG4gICAgICAgIHNldEVkaXRvckNvbW1hbmRTdGF0ZShlZGl0b3IsICdlbmFibGVPYmplY3RSZXNpemluZycsIGZhbHNlKTtcbiAgICAgICAgaWYgKGhhc0VkaXRvck9yVWlGb2N1cyhlZGl0b3IpKSB7XG4gICAgICAgICAgZWRpdG9yLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdG9yZUZha2VTZWxlY3Rpb24oZWRpdG9yKTtcbiAgICAgICAgZWRpdG9yLm5vZGVDaGFuZ2VkKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBpc1JlYWRPbmx5ID0gZWRpdG9yID0+IGVkaXRvci5yZWFkb25seTtcbiAgICBjb25zdCByZWdpc3RlckZpbHRlcnMgPSBlZGl0b3IgPT4ge1xuICAgICAgZWRpdG9yLnBhcnNlci5hZGRBdHRyaWJ1dGVGaWx0ZXIoJ2NvbnRlbnRlZGl0YWJsZScsIG5vZGVzID0+IHtcbiAgICAgICAgaWYgKGlzUmVhZE9ubHkoZWRpdG9yKSkge1xuICAgICAgICAgIGVhY2gkZyhub2Rlcywgbm9kZSA9PiB7XG4gICAgICAgICAgICBub2RlLmF0dHIoaW50ZXJuYWxDb250ZW50RWRpdGFibGVBdHRyLCBub2RlLmF0dHIoJ2NvbnRlbnRlZGl0YWJsZScpKTtcbiAgICAgICAgICAgIG5vZGUuYXR0cignY29udGVudGVkaXRhYmxlJywgJ2ZhbHNlJyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLnNlcmlhbGl6ZXIuYWRkQXR0cmlidXRlRmlsdGVyKGludGVybmFsQ29udGVudEVkaXRhYmxlQXR0ciwgbm9kZXMgPT4ge1xuICAgICAgICBpZiAoaXNSZWFkT25seShlZGl0b3IpKSB7XG4gICAgICAgICAgZWFjaCRnKG5vZGVzLCBub2RlID0+IHtcbiAgICAgICAgICAgIG5vZGUuYXR0cignY29udGVudGVkaXRhYmxlJywgbm9kZS5hdHRyKGludGVybmFsQ29udGVudEVkaXRhYmxlQXR0cikpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGVkaXRvci5zZXJpYWxpemVyLmFkZFRlbXBBdHRyKGludGVybmFsQ29udGVudEVkaXRhYmxlQXR0cik7XG4gICAgfTtcbiAgICBjb25zdCByZWdpc3RlclJlYWRPbmx5Q29udGVudEZpbHRlcnMgPSBlZGl0b3IgPT4ge1xuICAgICAgaWYgKGVkaXRvci5zZXJpYWxpemVyKSB7XG4gICAgICAgIHJlZ2lzdGVyRmlsdGVycyhlZGl0b3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWRpdG9yLm9uKCdQcmVJbml0JywgKCkgPT4ge1xuICAgICAgICAgIHJlZ2lzdGVyRmlsdGVycyhlZGl0b3IpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGlzQ2xpY2tFdmVudCA9IGUgPT4gZS50eXBlID09PSAnY2xpY2snO1xuICAgIGNvbnN0IGdldEFuY2hvckhyZWZPcHQgPSAoZWRpdG9yLCBlbG0pID0+IHtcbiAgICAgIGNvbnN0IGlzUm9vdCA9IGVsbSA9PiBlcShlbG0sIFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVkaXRvci5nZXRCb2R5KCkpKTtcbiAgICAgIHJldHVybiBjbG9zZXN0JDMoZWxtLCAnYScsIGlzUm9vdCkuYmluZChhID0+IGdldE9wdChhLCAnaHJlZicpKTtcbiAgICB9O1xuICAgIGNvbnN0IHByb2Nlc3NSZWFkb25seUV2ZW50cyA9IChlZGl0b3IsIGUpID0+IHtcbiAgICAgIGlmIChpc0NsaWNrRXZlbnQoZSkgJiYgIVZLLm1ldGFLZXlQcmVzc2VkKGUpKSB7XG4gICAgICAgIGNvbnN0IGVsbSA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKGUudGFyZ2V0KTtcbiAgICAgICAgZ2V0QW5jaG9ySHJlZk9wdChlZGl0b3IsIGVsbSkuZWFjaChocmVmID0+IHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgaWYgKC9eIy8udGVzdChocmVmKSkge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0RWwgPSBlZGl0b3IuZG9tLnNlbGVjdChgJHsgaHJlZiB9LFtuYW1lPVwiJHsgcmVtb3ZlTGVhZGluZyhocmVmLCAnIycpIH1cIl1gKTtcbiAgICAgICAgICAgIGlmICh0YXJnZXRFbC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zY3JvbGxJbnRvVmlldyh0YXJnZXRFbFswXSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdpbmRvdy5vcGVuKGhyZWYsICdfYmxhbmsnLCAncmVsPW5vb3BlbmVyIG5vcmVmZXJyZXIsbWVudWJhcj15ZXMsdG9vbGJhcj15ZXMsbG9jYXRpb249eWVzLHN0YXR1cz15ZXMscmVzaXphYmxlPXllcyxzY3JvbGxiYXJzPXllcycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCByZWdpc3RlclJlYWRPbmx5U2VsZWN0aW9uQmxvY2tlcnMgPSBlZGl0b3IgPT4ge1xuICAgICAgZWRpdG9yLm9uKCdTaG93Q2FyZXQnLCBlID0+IHtcbiAgICAgICAgaWYgKGlzUmVhZE9ubHkoZWRpdG9yKSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBlZGl0b3Iub24oJ09iamVjdFNlbGVjdGVkJywgZSA9PiB7XG4gICAgICAgIGlmIChpc1JlYWRPbmx5KGVkaXRvcikpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCBuYXRpdmVFdmVudHMgPSBUb29scy5tYWtlTWFwKCdmb2N1cyBibHVyIGZvY3VzaW4gZm9jdXNvdXQgY2xpY2sgZGJsY2xpY2sgbW91c2Vkb3duIG1vdXNldXAgbW91c2Vtb3ZlIG1vdXNlb3ZlciBiZWZvcmVwYXN0ZSBwYXN0ZSBjdXQgY29weSBzZWxlY3Rpb25jaGFuZ2UgJyArICdtb3VzZW91dCBtb3VzZWVudGVyIG1vdXNlbGVhdmUgd2hlZWwga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBpbnB1dCBiZWZvcmVpbnB1dCBjb250ZXh0bWVudSBkcmFnc3RhcnQgZHJhZ2VuZCBkcmFnb3ZlciAnICsgJ2RyYWdnZXN0dXJlIGRyYWdkcm9wIGRyb3AgZHJhZyBzdWJtaXQgJyArICdjb21wb3NpdGlvbnN0YXJ0IGNvbXBvc2l0aW9uZW5kIGNvbXBvc2l0aW9udXBkYXRlIHRvdWNoc3RhcnQgdG91Y2htb3ZlIHRvdWNoZW5kIHRvdWNoY2FuY2VsJywgJyAnKTtcbiAgICBjbGFzcyBFdmVudERpc3BhdGNoZXIge1xuICAgICAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICAgICAgdGhpcy5iaW5kaW5ncyA9IHt9O1xuICAgICAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3MgfHwge307XG4gICAgICAgIHRoaXMuc2NvcGUgPSB0aGlzLnNldHRpbmdzLnNjb3BlIHx8IHRoaXM7XG4gICAgICAgIHRoaXMudG9nZ2xlRXZlbnQgPSB0aGlzLnNldHRpbmdzLnRvZ2dsZUV2ZW50IHx8IG5ldmVyO1xuICAgICAgfVxuICAgICAgc3RhdGljIGlzTmF0aXZlKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICEhbmF0aXZlRXZlbnRzW25hbWUudG9Mb3dlckNhc2UoKV07XG4gICAgICB9XG4gICAgICBmaXJlKG5hbWUsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2gobmFtZSwgYXJncyk7XG4gICAgICB9XG4gICAgICBkaXNwYXRjaChuYW1lLCBhcmdzKSB7XG4gICAgICAgIGNvbnN0IGxjTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBub3JtYWxpemUkMyhsY05hbWUsIGFyZ3MgIT09IG51bGwgJiYgYXJncyAhPT0gdm9pZCAwID8gYXJncyA6IHt9LCB0aGlzLnNjb3BlKTtcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuYmVmb3JlRmlyZSkge1xuICAgICAgICAgIHRoaXMuc2V0dGluZ3MuYmVmb3JlRmlyZShldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFuZGxlcnMgPSB0aGlzLmJpbmRpbmdzW2xjTmFtZV07XG4gICAgICAgIGlmIChoYW5kbGVycykge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IGhhbmRsZXJzW2ldO1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrLnJlbW92ZWQpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2sub25jZSkge1xuICAgICAgICAgICAgICB0aGlzLm9mZihsY05hbWUsIGNhbGxiYWNrLmZ1bmMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrLmZ1bmMuY2FsbCh0aGlzLnNjb3BlLCBldmVudCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgIHJldHVybiBldmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgfVxuICAgICAgb24obmFtZSwgY2FsbGJhY2ssIHByZXBlbmQsIGV4dHJhKSB7XG4gICAgICAgIGlmIChjYWxsYmFjayA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBjYWxsYmFjayA9IG5ldmVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgIGNvbnN0IHdyYXBwZWRDYWxsYmFjayA9IHtcbiAgICAgICAgICAgIGZ1bmM6IGNhbGxiYWNrLFxuICAgICAgICAgICAgcmVtb3ZlZDogZmFsc2VcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChleHRyYSkge1xuICAgICAgICAgICAgVG9vbHMuZXh0ZW5kKHdyYXBwZWRDYWxsYmFjaywgZXh0cmEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBuYW1lcyA9IG5hbWUudG9Mb3dlckNhc2UoKS5zcGxpdCgnICcpO1xuICAgICAgICAgIGxldCBpID0gbmFtZXMubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnROYW1lID0gbmFtZXNbaV07XG4gICAgICAgICAgICBsZXQgaGFuZGxlcnMgPSB0aGlzLmJpbmRpbmdzW2N1cnJlbnROYW1lXTtcbiAgICAgICAgICAgIGlmICghaGFuZGxlcnMpIHtcbiAgICAgICAgICAgICAgaGFuZGxlcnMgPSBbXTtcbiAgICAgICAgICAgICAgdGhpcy50b2dnbGVFdmVudChjdXJyZW50TmFtZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJlcGVuZCkge1xuICAgICAgICAgICAgICBoYW5kbGVycyA9IFtcbiAgICAgICAgICAgICAgICB3cmFwcGVkQ2FsbGJhY2ssXG4gICAgICAgICAgICAgICAgLi4uaGFuZGxlcnNcbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGhhbmRsZXJzID0gW1xuICAgICAgICAgICAgICAgIC4uLmhhbmRsZXJzLFxuICAgICAgICAgICAgICAgIHdyYXBwZWRDYWxsYmFja1xuICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5iaW5kaW5nc1tjdXJyZW50TmFtZV0gPSBoYW5kbGVycztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBvZmYobmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICBjb25zdCBuYW1lcyA9IG5hbWUudG9Mb3dlckNhc2UoKS5zcGxpdCgnICcpO1xuICAgICAgICAgIGxldCBpID0gbmFtZXMubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnROYW1lID0gbmFtZXNbaV07XG4gICAgICAgICAgICBsZXQgaGFuZGxlcnMgPSB0aGlzLmJpbmRpbmdzW2N1cnJlbnROYW1lXTtcbiAgICAgICAgICAgIGlmICghY3VycmVudE5hbWUpIHtcbiAgICAgICAgICAgICAgZWFjaCRmKHRoaXMuYmluZGluZ3MsIChfdmFsdWUsIGJpbmRpbmdOYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy50b2dnbGVFdmVudChiaW5kaW5nTmFtZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmJpbmRpbmdzW2JpbmRpbmdOYW1lXTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhbmRsZXJzKSB7XG4gICAgICAgICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVycy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlcmVkSGFuZGxlcnMgPSBwYXJ0aXRpb24kMihoYW5kbGVycywgaGFuZGxlciA9PiBoYW5kbGVyLmZ1bmMgPT09IGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICBoYW5kbGVycyA9IGZpbHRlcmVkSGFuZGxlcnMuZmFpbDtcbiAgICAgICAgICAgICAgICB0aGlzLmJpbmRpbmdzW2N1cnJlbnROYW1lXSA9IGhhbmRsZXJzO1xuICAgICAgICAgICAgICAgIGVhY2gkZyhmaWx0ZXJlZEhhbmRsZXJzLnBhc3MsIGhhbmRsZXIgPT4ge1xuICAgICAgICAgICAgICAgICAgaGFuZGxlci5yZW1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWhhbmRsZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMudG9nZ2xlRXZlbnQobmFtZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmJpbmRpbmdzW2N1cnJlbnROYW1lXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlYWNoJGYodGhpcy5iaW5kaW5ncywgKF92YWx1ZSwgbmFtZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy50b2dnbGVFdmVudChuYW1lLCBmYWxzZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5iaW5kaW5ncyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgb25jZShuYW1lLCBjYWxsYmFjaywgcHJlcGVuZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vbihuYW1lLCBjYWxsYmFjaywgcHJlcGVuZCwgeyBvbmNlOiB0cnVlIH0pO1xuICAgICAgfVxuICAgICAgaGFzKG5hbWUpIHtcbiAgICAgICAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0dXJuICEoIXRoaXMuYmluZGluZ3NbbmFtZV0gfHwgdGhpcy5iaW5kaW5nc1tuYW1lXS5sZW5ndGggPT09IDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGdldEV2ZW50RGlzcGF0Y2hlciA9IG9iaiA9PiB7XG4gICAgICBpZiAoIW9iai5fZXZlbnREaXNwYXRjaGVyKSB7XG4gICAgICAgIG9iai5fZXZlbnREaXNwYXRjaGVyID0gbmV3IEV2ZW50RGlzcGF0Y2hlcih7XG4gICAgICAgICAgc2NvcGU6IG9iaixcbiAgICAgICAgICB0b2dnbGVFdmVudDogKG5hbWUsIHN0YXRlKSA9PiB7XG4gICAgICAgICAgICBpZiAoRXZlbnREaXNwYXRjaGVyLmlzTmF0aXZlKG5hbWUpICYmIG9iai50b2dnbGVOYXRpdmVFdmVudCkge1xuICAgICAgICAgICAgICBvYmoudG9nZ2xlTmF0aXZlRXZlbnQobmFtZSwgc3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqLl9ldmVudERpc3BhdGNoZXI7XG4gICAgfTtcbiAgICBjb25zdCBPYnNlcnZhYmxlID0ge1xuICAgICAgZmlyZShuYW1lLCBhcmdzLCBidWJibGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2gobmFtZSwgYXJncywgYnViYmxlKTtcbiAgICAgIH0sXG4gICAgICBkaXNwYXRjaChuYW1lLCBhcmdzLCBidWJibGUpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmIChzZWxmLnJlbW92ZWQgJiYgbmFtZSAhPT0gJ3JlbW92ZScgJiYgbmFtZSAhPT0gJ2RldGFjaCcpIHtcbiAgICAgICAgICByZXR1cm4gbm9ybWFsaXplJDMobmFtZS50b0xvd2VyQ2FzZSgpLCBhcmdzICE9PSBudWxsICYmIGFyZ3MgIT09IHZvaWQgMCA/IGFyZ3MgOiB7fSwgc2VsZik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGlzcGF0Y2hlckFyZ3MgPSBnZXRFdmVudERpc3BhdGNoZXIoc2VsZikuZGlzcGF0Y2gobmFtZSwgYXJncyk7XG4gICAgICAgIGlmIChidWJibGUgIT09IGZhbHNlICYmIHNlbGYucGFyZW50KSB7XG4gICAgICAgICAgbGV0IHBhcmVudCA9IHNlbGYucGFyZW50KCk7XG4gICAgICAgICAgd2hpbGUgKHBhcmVudCAmJiAhZGlzcGF0Y2hlckFyZ3MuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICAgICAgcGFyZW50LmRpc3BhdGNoKG5hbWUsIGRpc3BhdGNoZXJBcmdzLCBmYWxzZSk7XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaXNwYXRjaGVyQXJncztcbiAgICAgIH0sXG4gICAgICBvbihuYW1lLCBjYWxsYmFjaywgcHJlcGVuZCkge1xuICAgICAgICByZXR1cm4gZ2V0RXZlbnREaXNwYXRjaGVyKHRoaXMpLm9uKG5hbWUsIGNhbGxiYWNrLCBwcmVwZW5kKTtcbiAgICAgIH0sXG4gICAgICBvZmYobmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGdldEV2ZW50RGlzcGF0Y2hlcih0aGlzKS5vZmYobmFtZSwgY2FsbGJhY2spO1xuICAgICAgfSxcbiAgICAgIG9uY2UobmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGdldEV2ZW50RGlzcGF0Y2hlcih0aGlzKS5vbmNlKG5hbWUsIGNhbGxiYWNrKTtcbiAgICAgIH0sXG4gICAgICBoYXNFdmVudExpc3RlbmVycyhuYW1lKSB7XG4gICAgICAgIHJldHVybiBnZXRFdmVudERpc3BhdGNoZXIodGhpcykuaGFzKG5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBET00kMiA9IERPTVV0aWxzLkRPTTtcbiAgICBsZXQgY3VzdG9tRXZlbnRSb290RGVsZWdhdGVzO1xuICAgIGNvbnN0IGdldEV2ZW50VGFyZ2V0ID0gKGVkaXRvciwgZXZlbnROYW1lKSA9PiB7XG4gICAgICBpZiAoZXZlbnROYW1lID09PSAnc2VsZWN0aW9uY2hhbmdlJykge1xuICAgICAgICByZXR1cm4gZWRpdG9yLmdldERvYygpO1xuICAgICAgfVxuICAgICAgaWYgKCFlZGl0b3IuaW5saW5lICYmIC9ebW91c2V8dG91Y2h8Y2xpY2t8Y29udGV4dG1lbnV8ZHJvcHxkcmFnb3ZlcnxkcmFnZW5kLy50ZXN0KGV2ZW50TmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGVkaXRvci5nZXREb2MoKS5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICB9XG4gICAgICBjb25zdCBldmVudFJvb3QgPSBnZXRFdmVudFJvb3QoZWRpdG9yKTtcbiAgICAgIGlmIChldmVudFJvb3QpIHtcbiAgICAgICAgaWYgKCFlZGl0b3IuZXZlbnRSb290KSB7XG4gICAgICAgICAgZWRpdG9yLmV2ZW50Um9vdCA9IERPTSQyLnNlbGVjdChldmVudFJvb3QpWzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlZGl0b3IuZXZlbnRSb290O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVkaXRvci5nZXRCb2R5KCk7XG4gICAgfTtcbiAgICBjb25zdCBpc0xpc3RlbmluZyA9IGVkaXRvciA9PiAhZWRpdG9yLmhpZGRlbiAmJiAhaXNSZWFkT25seShlZGl0b3IpO1xuICAgIGNvbnN0IGZpcmVFdmVudCA9IChlZGl0b3IsIGV2ZW50TmFtZSwgZSkgPT4ge1xuICAgICAgaWYgKGlzTGlzdGVuaW5nKGVkaXRvcikpIHtcbiAgICAgICAgZWRpdG9yLmRpc3BhdGNoKGV2ZW50TmFtZSwgZSk7XG4gICAgICB9IGVsc2UgaWYgKGlzUmVhZE9ubHkoZWRpdG9yKSkge1xuICAgICAgICBwcm9jZXNzUmVhZG9ubHlFdmVudHMoZWRpdG9yLCBlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGJpbmRFdmVudERlbGVnYXRlID0gKGVkaXRvciwgZXZlbnROYW1lKSA9PiB7XG4gICAgICBsZXQgZGVsZWdhdGU7XG4gICAgICBpZiAoIWVkaXRvci5kZWxlZ2F0ZXMpIHtcbiAgICAgICAgZWRpdG9yLmRlbGVnYXRlcyA9IHt9O1xuICAgICAgfVxuICAgICAgaWYgKGVkaXRvci5kZWxlZ2F0ZXNbZXZlbnROYW1lXSB8fCBlZGl0b3IucmVtb3ZlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBldmVudFJvb3RFbG0gPSBnZXRFdmVudFRhcmdldChlZGl0b3IsIGV2ZW50TmFtZSk7XG4gICAgICBpZiAoZ2V0RXZlbnRSb290KGVkaXRvcikpIHtcbiAgICAgICAgaWYgKCFjdXN0b21FdmVudFJvb3REZWxlZ2F0ZXMpIHtcbiAgICAgICAgICBjdXN0b21FdmVudFJvb3REZWxlZ2F0ZXMgPSB7fTtcbiAgICAgICAgICBlZGl0b3IuZWRpdG9yTWFuYWdlci5vbigncmVtb3ZlRWRpdG9yJywgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFlZGl0b3IuZWRpdG9yTWFuYWdlci5hY3RpdmVFZGl0b3IpIHtcbiAgICAgICAgICAgICAgaWYgKGN1c3RvbUV2ZW50Um9vdERlbGVnYXRlcykge1xuICAgICAgICAgICAgICAgIGVhY2gkZihjdXN0b21FdmVudFJvb3REZWxlZ2F0ZXMsIChfdmFsdWUsIG5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICAgIGVkaXRvci5kb20udW5iaW5kKGdldEV2ZW50VGFyZ2V0KGVkaXRvciwgbmFtZSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGN1c3RvbUV2ZW50Um9vdERlbGVnYXRlcyA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VzdG9tRXZlbnRSb290RGVsZWdhdGVzW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGVsZWdhdGUgPSBlID0+IHtcbiAgICAgICAgICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldDtcbiAgICAgICAgICBjb25zdCBlZGl0b3JzID0gZWRpdG9yLmVkaXRvck1hbmFnZXIuZ2V0KCk7XG4gICAgICAgICAgbGV0IGkgPSBlZGl0b3JzLmxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZWRpdG9yc1tpXS5nZXRCb2R5KCk7XG4gICAgICAgICAgICBpZiAoYm9keSA9PT0gdGFyZ2V0IHx8IERPTSQyLmlzQ2hpbGRPZih0YXJnZXQsIGJvZHkpKSB7XG4gICAgICAgICAgICAgIGZpcmVFdmVudChlZGl0b3JzW2ldLCBldmVudE5hbWUsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY3VzdG9tRXZlbnRSb290RGVsZWdhdGVzW2V2ZW50TmFtZV0gPSBkZWxlZ2F0ZTtcbiAgICAgICAgRE9NJDIuYmluZChldmVudFJvb3RFbG0sIGV2ZW50TmFtZSwgZGVsZWdhdGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZWdhdGUgPSBlID0+IHtcbiAgICAgICAgICBmaXJlRXZlbnQoZWRpdG9yLCBldmVudE5hbWUsIGUpO1xuICAgICAgICB9O1xuICAgICAgICBET00kMi5iaW5kKGV2ZW50Um9vdEVsbSwgZXZlbnROYW1lLCBkZWxlZ2F0ZSk7XG4gICAgICAgIGVkaXRvci5kZWxlZ2F0ZXNbZXZlbnROYW1lXSA9IGRlbGVnYXRlO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgRWRpdG9yT2JzZXJ2YWJsZSA9IHtcbiAgICAgIC4uLk9ic2VydmFibGUsXG4gICAgICBiaW5kUGVuZGluZ0V2ZW50RGVsZWdhdGVzKCkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgVG9vbHMuZWFjaChzZWxmLl9wZW5kaW5nTmF0aXZlRXZlbnRzLCBuYW1lID0+IHtcbiAgICAgICAgICBiaW5kRXZlbnREZWxlZ2F0ZShzZWxmLCBuYW1lKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgdG9nZ2xlTmF0aXZlRXZlbnQobmFtZSwgc3RhdGUpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmIChuYW1lID09PSAnZm9jdXMnIHx8IG5hbWUgPT09ICdibHVyJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5yZW1vdmVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgIGlmIChzZWxmLmluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICBiaW5kRXZlbnREZWxlZ2F0ZShzZWxmLCBuYW1lKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFzZWxmLl9wZW5kaW5nTmF0aXZlRXZlbnRzKSB7XG4gICAgICAgICAgICAgIHNlbGYuX3BlbmRpbmdOYXRpdmVFdmVudHMgPSBbbmFtZV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZWxmLl9wZW5kaW5nTmF0aXZlRXZlbnRzLnB1c2gobmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHNlbGYuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICBzZWxmLmRvbS51bmJpbmQoZ2V0RXZlbnRUYXJnZXQoc2VsZiwgbmFtZSksIG5hbWUsIHNlbGYuZGVsZWdhdGVzW25hbWVdKTtcbiAgICAgICAgICBkZWxldGUgc2VsZi5kZWxlZ2F0ZXNbbmFtZV07XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1bmJpbmRBbGxOYXRpdmVFdmVudHMoKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBjb25zdCBib2R5ID0gc2VsZi5nZXRCb2R5KCk7XG4gICAgICAgIGNvbnN0IGRvbSA9IHNlbGYuZG9tO1xuICAgICAgICBpZiAoc2VsZi5kZWxlZ2F0ZXMpIHtcbiAgICAgICAgICBlYWNoJGYoc2VsZi5kZWxlZ2F0ZXMsICh2YWx1ZSwgbmFtZSkgPT4ge1xuICAgICAgICAgICAgc2VsZi5kb20udW5iaW5kKGdldEV2ZW50VGFyZ2V0KHNlbGYsIG5hbWUpLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZGVsZXRlIHNlbGYuZGVsZWdhdGVzO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2VsZi5pbmxpbmUgJiYgYm9keSAmJiBkb20pIHtcbiAgICAgICAgICBib2R5Lm9ubG9hZCA9IG51bGw7XG4gICAgICAgICAgZG9tLnVuYmluZChzZWxmLmdldFdpbigpKTtcbiAgICAgICAgICBkb20udW5iaW5kKHNlbGYuZ2V0RG9jKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkb20pIHtcbiAgICAgICAgICBkb20udW5iaW5kKGJvZHkpO1xuICAgICAgICAgIGRvbS51bmJpbmQoc2VsZi5nZXRDb250YWluZXIoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3Qgc3RyaW5nTGlzdFByb2Nlc3NvciA9IHZhbHVlID0+IHtcbiAgICAgIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZTogdmFsdWUuc3BsaXQoL1sgLF0vKSxcbiAgICAgICAgICB2YWxpZDogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChpc0FycmF5T2YodmFsdWUsIGlzU3RyaW5nKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIHZhbGlkOiB0cnVlXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbGlkOiBmYWxzZSxcbiAgICAgICAgICBtZXNzYWdlOiBgVGhlIHZhbHVlIG11c3QgYmUgYSBzdHJpbmdbXSBvciBhIGNvbW1hL3NwYWNlIHNlcGFyYXRlZCBzdHJpbmcuYFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZ2V0QnVpbHRJblByb2Nlc3NvciA9IHR5cGUgPT4ge1xuICAgICAgY29uc3QgdmFsaWRhdG9yID0gKCgpID0+IHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgICAgICByZXR1cm4gaXNBcnJheSQxO1xuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICByZXR1cm4gaXNCb29sZWFuO1xuICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb247XG4gICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgcmV0dXJuIGlzTnVtYmVyO1xuICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgIHJldHVybiBpc09iamVjdDtcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICByZXR1cm4gaXNTdHJpbmc7XG4gICAgICAgIGNhc2UgJ3N0cmluZ1tdJzpcbiAgICAgICAgICByZXR1cm4gc3RyaW5nTGlzdFByb2Nlc3NvcjtcbiAgICAgICAgY2FzZSAnb2JqZWN0W10nOlxuICAgICAgICAgIHJldHVybiB2YWwgPT4gaXNBcnJheU9mKHZhbCwgaXNPYmplY3QpO1xuICAgICAgICBjYXNlICdyZWdleHAnOlxuICAgICAgICAgIHJldHVybiB2YWwgPT4gaXMkNCh2YWwsIFJlZ0V4cCk7XG4gICAgICAgIH1cbiAgICAgIH0pKCk7XG4gICAgICByZXR1cm4gdmFsdWUgPT4gcHJvY2Vzc1ZhbHVlKHZhbHVlLCB2YWxpZGF0b3IsIGBUaGUgdmFsdWUgbXVzdCBiZSBhICR7IHR5cGUgfS5gKTtcbiAgICB9O1xuICAgIGNvbnN0IGlzQnVpbHRJblNwZWMgPSBzcGVjID0+IGlzU3RyaW5nKHNwZWMucHJvY2Vzc29yKTtcbiAgICBjb25zdCBnZXRFcnJvck1lc3NhZ2UgPSAobWVzc2FnZSwgcmVzdWx0KSA9PiB7XG4gICAgICBjb25zdCBhZGRpdGlvbmFsVGV4dCA9IGlzRW1wdHkkMyhyZXN1bHQubWVzc2FnZSkgPyAnJyA6IGAuICR7IHJlc3VsdC5tZXNzYWdlIH1gO1xuICAgICAgcmV0dXJuIG1lc3NhZ2UgKyBhZGRpdGlvbmFsVGV4dDtcbiAgICB9O1xuICAgIGNvbnN0IGlzVmFsaWRSZXN1bHQgPSByZXN1bHQgPT4gcmVzdWx0LnZhbGlkO1xuICAgIGNvbnN0IHByb2Nlc3NWYWx1ZSA9ICh2YWx1ZSwgcHJvY2Vzc29yLCBtZXNzYWdlID0gJycpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHByb2Nlc3Nvcih2YWx1ZSk7XG4gICAgICBpZiAoaXNCb29sZWFuKHJlc3VsdCkpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCA/IHtcbiAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgdmFsaWQ6IHRydWVcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICB2YWxpZDogZmFsc2UsXG4gICAgICAgICAgbWVzc2FnZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHByb2Nlc3NEZWZhdWx0VmFsdWUgPSAobmFtZSwgZGVmYXVsdFZhbHVlLCBwcm9jZXNzb3IpID0+IHtcbiAgICAgIGlmICghaXNVbmRlZmluZWQoZGVmYXVsdFZhbHVlKSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBwcm9jZXNzVmFsdWUoZGVmYXVsdFZhbHVlLCBwcm9jZXNzb3IpO1xuICAgICAgICBpZiAoaXNWYWxpZFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGdldEVycm9yTWVzc2FnZShgSW52YWxpZCBkZWZhdWx0IHZhbHVlIHBhc3NlZCBmb3IgdGhlIFwiJHsgbmFtZSB9XCIgb3B0aW9uYCwgcmVzdWx0KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBjb25zdCBjcmVhdGUkNSA9IChlZGl0b3IsIGluaXRpYWxPcHRpb25zKSA9PiB7XG4gICAgICBjb25zdCByZWdpc3RyeSA9IHt9O1xuICAgICAgY29uc3QgdmFsdWVzID0ge307XG4gICAgICBjb25zdCBzZXRWYWx1ZSA9IChuYW1lLCB2YWx1ZSwgcHJvY2Vzc29yKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHByb2Nlc3NWYWx1ZSh2YWx1ZSwgcHJvY2Vzc29yKTtcbiAgICAgICAgaWYgKGlzVmFsaWRSZXN1bHQocmVzdWx0KSkge1xuICAgICAgICAgIHZhbHVlc1tuYW1lXSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oZ2V0RXJyb3JNZXNzYWdlKGBJbnZhbGlkIHZhbHVlIHBhc3NlZCBmb3IgdGhlICR7IG5hbWUgfSBvcHRpb25gLCByZXN1bHQpKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCByZWdpc3RlciA9IChuYW1lLCBzcGVjKSA9PiB7XG4gICAgICAgIGNvbnN0IHByb2Nlc3NvciA9IGlzQnVpbHRJblNwZWMoc3BlYykgPyBnZXRCdWlsdEluUHJvY2Vzc29yKHNwZWMucHJvY2Vzc29yKSA6IHNwZWMucHJvY2Vzc29yO1xuICAgICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSBwcm9jZXNzRGVmYXVsdFZhbHVlKG5hbWUsIHNwZWMuZGVmYXVsdCwgcHJvY2Vzc29yKTtcbiAgICAgICAgcmVnaXN0cnlbbmFtZV0gPSB7XG4gICAgICAgICAgLi4uc3BlYyxcbiAgICAgICAgICBkZWZhdWx0OiBkZWZhdWx0VmFsdWUsXG4gICAgICAgICAgcHJvY2Vzc29yXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGluaXRWYWx1ZSA9IGdldCRhKHZhbHVlcywgbmFtZSkub3JUaHVuaygoKSA9PiBnZXQkYShpbml0aWFsT3B0aW9ucywgbmFtZSkpO1xuICAgICAgICBpbml0VmFsdWUuZWFjaCh2YWx1ZSA9PiBzZXRWYWx1ZShuYW1lLCB2YWx1ZSwgcHJvY2Vzc29yKSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgaXNSZWdpc3RlcmVkID0gbmFtZSA9PiBoYXMkMihyZWdpc3RyeSwgbmFtZSk7XG4gICAgICBjb25zdCBnZXQgPSBuYW1lID0+IGdldCRhKHZhbHVlcywgbmFtZSkub3JUaHVuaygoKSA9PiBnZXQkYShyZWdpc3RyeSwgbmFtZSkubWFwKHNwZWMgPT4gc3BlYy5kZWZhdWx0KSkuZ2V0T3JVbmRlZmluZWQoKTtcbiAgICAgIGNvbnN0IHNldCA9IChuYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAoIWlzUmVnaXN0ZXJlZChuYW1lKSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihgXCIkeyBuYW1lIH1cIiBpcyBub3QgYSByZWdpc3RlcmVkIG9wdGlvbi4gRW5zdXJlIHRoZSBvcHRpb24gaGFzIGJlZW4gcmVnaXN0ZXJlZCBiZWZvcmUgc2V0dGluZyBhIHZhbHVlLmApO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBzcGVjID0gcmVnaXN0cnlbbmFtZV07XG4gICAgICAgICAgaWYgKHNwZWMuaW1tdXRhYmxlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBcIiR7IG5hbWUgfVwiIGlzIGFuIGltbXV0YWJsZSBvcHRpb24gYW5kIGNhbm5vdCBiZSB1cGRhdGVkYCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzZXRWYWx1ZShuYW1lLCB2YWx1ZSwgc3BlYy5wcm9jZXNzb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHVuc2V0ID0gbmFtZSA9PiB7XG4gICAgICAgIGNvbnN0IHJlZ2lzdGVyZWQgPSBpc1JlZ2lzdGVyZWQobmFtZSk7XG4gICAgICAgIGlmIChyZWdpc3RlcmVkKSB7XG4gICAgICAgICAgZGVsZXRlIHZhbHVlc1tuYW1lXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVnaXN0ZXJlZDtcbiAgICAgIH07XG4gICAgICBjb25zdCBpc1NldCA9IG5hbWUgPT4gaGFzJDIodmFsdWVzLCBuYW1lKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlZ2lzdGVyLFxuICAgICAgICBpc1JlZ2lzdGVyZWQsXG4gICAgICAgIGdldCxcbiAgICAgICAgc2V0LFxuICAgICAgICB1bnNldCxcbiAgICAgICAgaXNTZXRcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IGRlZmF1bHRNb2RlcyA9IFtcbiAgICAgICdkZXNpZ24nLFxuICAgICAgJ3JlYWRvbmx5J1xuICAgIF07XG4gICAgY29uc3Qgc3dpdGNoVG9Nb2RlID0gKGVkaXRvciwgYWN0aXZlTW9kZSwgYXZhaWxhYmxlTW9kZXMsIG1vZGUpID0+IHtcbiAgICAgIGNvbnN0IG9sZE1vZGUgPSBhdmFpbGFibGVNb2Rlc1thY3RpdmVNb2RlLmdldCgpXTtcbiAgICAgIGNvbnN0IG5ld01vZGUgPSBhdmFpbGFibGVNb2Rlc1ttb2RlXTtcbiAgICAgIHRyeSB7XG4gICAgICAgIG5ld01vZGUuYWN0aXZhdGUoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgcHJvYmxlbSB3aGlsZSBhY3RpdmF0aW5nIGVkaXRvciBtb2RlICR7IG1vZGUgfTpgLCBlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgb2xkTW9kZS5kZWFjdGl2YXRlKCk7XG4gICAgICBpZiAob2xkTW9kZS5lZGl0b3JSZWFkT25seSAhPT0gbmV3TW9kZS5lZGl0b3JSZWFkT25seSkge1xuICAgICAgICB0b2dnbGVSZWFkT25seShlZGl0b3IsIG5ld01vZGUuZWRpdG9yUmVhZE9ubHkpO1xuICAgICAgfVxuICAgICAgYWN0aXZlTW9kZS5zZXQobW9kZSk7XG4gICAgICBmaXJlU3dpdGNoTW9kZShlZGl0b3IsIG1vZGUpO1xuICAgIH07XG4gICAgY29uc3Qgc2V0TW9kZSA9IChlZGl0b3IsIGF2YWlsYWJsZU1vZGVzLCBhY3RpdmVNb2RlLCBtb2RlKSA9PiB7XG4gICAgICBpZiAobW9kZSA9PT0gYWN0aXZlTW9kZS5nZXQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKCFoYXMkMihhdmFpbGFibGVNb2RlcywgbW9kZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFZGl0b3IgbW9kZSAnJHsgbW9kZSB9JyBpcyBpbnZhbGlkYCk7XG4gICAgICB9XG4gICAgICBpZiAoZWRpdG9yLmluaXRpYWxpemVkKSB7XG4gICAgICAgIHN3aXRjaFRvTW9kZShlZGl0b3IsIGFjdGl2ZU1vZGUsIGF2YWlsYWJsZU1vZGVzLCBtb2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVkaXRvci5vbignaW5pdCcsICgpID0+IHN3aXRjaFRvTW9kZShlZGl0b3IsIGFjdGl2ZU1vZGUsIGF2YWlsYWJsZU1vZGVzLCBtb2RlKSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCByZWdpc3Rlck1vZGUgPSAoYXZhaWxhYmxlTW9kZXMsIG1vZGUsIGFwaSkgPT4ge1xuICAgICAgaWYgKGNvbnRhaW5zJDIoZGVmYXVsdE1vZGVzLCBtb2RlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBvdmVycmlkZSBkZWZhdWx0IG1vZGUgJHsgbW9kZSB9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5hdmFpbGFibGVNb2RlcyxcbiAgICAgICAgW21vZGVdOiB7XG4gICAgICAgICAgLi4uYXBpLFxuICAgICAgICAgIGRlYWN0aXZhdGU6ICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGFwaS5kZWFjdGl2YXRlKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYHByb2JsZW0gd2hpbGUgZGVhY3RpdmF0aW5nIGVkaXRvciBtb2RlICR7IG1vZGUgfTpgLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IGNyZWF0ZSQ0ID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IGFjdGl2ZU1vZGUgPSBDZWxsKCdkZXNpZ24nKTtcbiAgICAgIGNvbnN0IGF2YWlsYWJsZU1vZGVzID0gQ2VsbCh7XG4gICAgICAgIGRlc2lnbjoge1xuICAgICAgICAgIGFjdGl2YXRlOiBub29wLFxuICAgICAgICAgIGRlYWN0aXZhdGU6IG5vb3AsXG4gICAgICAgICAgZWRpdG9yUmVhZE9ubHk6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIHJlYWRvbmx5OiB7XG4gICAgICAgICAgYWN0aXZhdGU6IG5vb3AsXG4gICAgICAgICAgZGVhY3RpdmF0ZTogbm9vcCxcbiAgICAgICAgICBlZGl0b3JSZWFkT25seTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyUmVhZE9ubHlDb250ZW50RmlsdGVycyhlZGl0b3IpO1xuICAgICAgcmVnaXN0ZXJSZWFkT25seVNlbGVjdGlvbkJsb2NrZXJzKGVkaXRvcik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc1JlYWRPbmx5OiAoKSA9PiBpc1JlYWRPbmx5KGVkaXRvciksXG4gICAgICAgIHNldDogbW9kZSA9PiBzZXRNb2RlKGVkaXRvciwgYXZhaWxhYmxlTW9kZXMuZ2V0KCksIGFjdGl2ZU1vZGUsIG1vZGUpLFxuICAgICAgICBnZXQ6ICgpID0+IGFjdGl2ZU1vZGUuZ2V0KCksXG4gICAgICAgIHJlZ2lzdGVyOiAobW9kZSwgYXBpKSA9PiB7XG4gICAgICAgICAgYXZhaWxhYmxlTW9kZXMuc2V0KHJlZ2lzdGVyTW9kZShhdmFpbGFibGVNb2Rlcy5nZXQoKSwgbW9kZSwgYXBpKSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IGVhY2gkMiA9IFRvb2xzLmVhY2gsIGV4cGxvZGUgPSBUb29scy5leHBsb2RlO1xuICAgIGNvbnN0IGtleUNvZGVMb29rdXAgPSB7XG4gICAgICBmMTogMTEyLFxuICAgICAgZjI6IDExMyxcbiAgICAgIGYzOiAxMTQsXG4gICAgICBmNDogMTE1LFxuICAgICAgZjU6IDExNixcbiAgICAgIGY2OiAxMTcsXG4gICAgICBmNzogMTE4LFxuICAgICAgZjg6IDExOSxcbiAgICAgIGY5OiAxMjAsXG4gICAgICBmMTA6IDEyMSxcbiAgICAgIGYxMTogMTIyLFxuICAgICAgZjEyOiAxMjNcbiAgICB9O1xuICAgIGNvbnN0IG1vZGlmaWVyTmFtZXMgPSBUb29scy5tYWtlTWFwKCdhbHQsY3RybCxzaGlmdCxtZXRhLGFjY2VzcycpO1xuICAgIGNvbnN0IHBhcnNlU2hvcnRjdXQgPSBwYXR0ZXJuID0+IHtcbiAgICAgIGxldCBrZXk7XG4gICAgICBjb25zdCBzaG9ydGN1dCA9IHt9O1xuICAgICAgY29uc3QgaXNNYWMgPSBFbnYub3MuaXNNYWNPUygpIHx8IEVudi5vcy5pc2lPUygpO1xuICAgICAgZWFjaCQyKGV4cGxvZGUocGF0dGVybi50b0xvd2VyQ2FzZSgpLCAnKycpLCB2YWx1ZSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZSBpbiBtb2RpZmllck5hbWVzKSB7XG4gICAgICAgICAgc2hvcnRjdXRbdmFsdWVdID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoL15bMC05XXsyLH0kLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgc2hvcnRjdXQua2V5Q29kZSA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNob3J0Y3V0LmNoYXJDb2RlID0gdmFsdWUuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgIHNob3J0Y3V0LmtleUNvZGUgPSBrZXlDb2RlTG9va3VwW3ZhbHVlXSB8fCB2YWx1ZS50b1VwcGVyQ2FzZSgpLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGlkID0gW3Nob3J0Y3V0LmtleUNvZGVdO1xuICAgICAgZm9yIChrZXkgaW4gbW9kaWZpZXJOYW1lcykge1xuICAgICAgICBpZiAoc2hvcnRjdXRba2V5XSkge1xuICAgICAgICAgIGlkLnB1c2goa2V5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzaG9ydGN1dFtrZXldID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNob3J0Y3V0LmlkID0gaWQuam9pbignLCcpO1xuICAgICAgaWYgKHNob3J0Y3V0LmFjY2Vzcykge1xuICAgICAgICBzaG9ydGN1dC5hbHQgPSB0cnVlO1xuICAgICAgICBpZiAoaXNNYWMpIHtcbiAgICAgICAgICBzaG9ydGN1dC5jdHJsID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzaG9ydGN1dC5zaGlmdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzaG9ydGN1dC5tZXRhKSB7XG4gICAgICAgIGlmIChpc01hYykge1xuICAgICAgICAgIHNob3J0Y3V0Lm1ldGEgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNob3J0Y3V0LmN0cmwgPSB0cnVlO1xuICAgICAgICAgIHNob3J0Y3V0Lm1ldGEgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHNob3J0Y3V0O1xuICAgIH07XG4gICAgY2xhc3MgU2hvcnRjdXRzIHtcbiAgICAgIGNvbnN0cnVjdG9yKGVkaXRvcikge1xuICAgICAgICB0aGlzLnNob3J0Y3V0cyA9IHt9O1xuICAgICAgICB0aGlzLnBlbmRpbmdQYXR0ZXJucyA9IFtdO1xuICAgICAgICB0aGlzLmVkaXRvciA9IGVkaXRvcjtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGVkaXRvci5vbigna2V5dXAga2V5cHJlc3Mga2V5ZG93bicsIGUgPT4ge1xuICAgICAgICAgIGlmICgoc2VsZi5oYXNNb2RpZmllcihlKSB8fCBzZWxmLmlzRnVuY3Rpb25LZXkoZSkpICYmICFlLmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgICBlYWNoJDIoc2VsZi5zaG9ydGN1dHMsIHNob3J0Y3V0ID0+IHtcbiAgICAgICAgICAgICAgaWYgKHNlbGYubWF0Y2hTaG9ydGN1dChlLCBzaG9ydGN1dCkpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnBlbmRpbmdQYXR0ZXJucyA9IHNob3J0Y3V0LnN1YnBhdHRlcm5zLnNsaWNlKDApO1xuICAgICAgICAgICAgICAgIGlmIChlLnR5cGUgPT09ICdrZXlkb3duJykge1xuICAgICAgICAgICAgICAgICAgc2VsZi5leGVjdXRlU2hvcnRjdXRBY3Rpb24oc2hvcnRjdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoc2VsZi5tYXRjaFNob3J0Y3V0KGUsIHNlbGYucGVuZGluZ1BhdHRlcm5zWzBdKSkge1xuICAgICAgICAgICAgICBpZiAoc2VsZi5wZW5kaW5nUGF0dGVybnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUudHlwZSA9PT0gJ2tleWRvd24nKSB7XG4gICAgICAgICAgICAgICAgICBzZWxmLmV4ZWN1dGVTaG9ydGN1dEFjdGlvbihzZWxmLnBlbmRpbmdQYXR0ZXJuc1swXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHNlbGYucGVuZGluZ1BhdHRlcm5zLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGFkZChwYXR0ZXJuLCBkZXNjLCBjbWRGdW5jLCBzY29wZSkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgY29uc3QgZnVuYyA9IHNlbGYubm9ybWFsaXplQ29tbWFuZEZ1bmMoY21kRnVuYyk7XG4gICAgICAgIGVhY2gkMihleHBsb2RlKFRvb2xzLnRyaW0ocGF0dGVybikpLCBwYXR0ZXJuID0+IHtcbiAgICAgICAgICBjb25zdCBzaG9ydGN1dCA9IHNlbGYuY3JlYXRlU2hvcnRjdXQocGF0dGVybiwgZGVzYywgZnVuYywgc2NvcGUpO1xuICAgICAgICAgIHNlbGYuc2hvcnRjdXRzW3Nob3J0Y3V0LmlkXSA9IHNob3J0Y3V0O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZW1vdmUocGF0dGVybikge1xuICAgICAgICBjb25zdCBzaG9ydGN1dCA9IHRoaXMuY3JlYXRlU2hvcnRjdXQocGF0dGVybik7XG4gICAgICAgIGlmICh0aGlzLnNob3J0Y3V0c1tzaG9ydGN1dC5pZF0pIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5zaG9ydGN1dHNbc2hvcnRjdXQuaWRdO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIG5vcm1hbGl6ZUNvbW1hbmRGdW5jKGNtZEZ1bmMpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGNtZCA9IGNtZEZ1bmM7XG4gICAgICAgIGlmICh0eXBlb2YgY21kID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBzZWxmLmVkaXRvci5leGVjQ29tbWFuZChjbWQsIGZhbHNlLCBudWxsKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKFRvb2xzLmlzQXJyYXkoY21kKSkge1xuICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBzZWxmLmVkaXRvci5leGVjQ29tbWFuZChjbWRbMF0sIGNtZFsxXSwgY21kWzJdKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBjbWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNyZWF0ZVNob3J0Y3V0KHBhdHRlcm4sIGRlc2MsIGNtZEZ1bmMsIHNjb3BlKSB7XG4gICAgICAgIGNvbnN0IHNob3J0Y3V0cyA9IFRvb2xzLm1hcChleHBsb2RlKHBhdHRlcm4sICc+JyksIHBhcnNlU2hvcnRjdXQpO1xuICAgICAgICBzaG9ydGN1dHNbc2hvcnRjdXRzLmxlbmd0aCAtIDFdID0gVG9vbHMuZXh0ZW5kKHNob3J0Y3V0c1tzaG9ydGN1dHMubGVuZ3RoIC0gMV0sIHtcbiAgICAgICAgICBmdW5jOiBjbWRGdW5jLFxuICAgICAgICAgIHNjb3BlOiBzY29wZSB8fCB0aGlzLmVkaXRvclxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFRvb2xzLmV4dGVuZChzaG9ydGN1dHNbMF0sIHtcbiAgICAgICAgICBkZXNjOiB0aGlzLmVkaXRvci50cmFuc2xhdGUoZGVzYyksXG4gICAgICAgICAgc3VicGF0dGVybnM6IHNob3J0Y3V0cy5zbGljZSgxKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGhhc01vZGlmaWVyKGUpIHtcbiAgICAgICAgcmV0dXJuIGUuYWx0S2V5IHx8IGUuY3RybEtleSB8fCBlLm1ldGFLZXk7XG4gICAgICB9XG4gICAgICBpc0Z1bmN0aW9uS2V5KGUpIHtcbiAgICAgICAgcmV0dXJuIGUudHlwZSA9PT0gJ2tleWRvd24nICYmIGUua2V5Q29kZSA+PSAxMTIgJiYgZS5rZXlDb2RlIDw9IDEyMztcbiAgICAgIH1cbiAgICAgIG1hdGNoU2hvcnRjdXQoZSwgc2hvcnRjdXQpIHtcbiAgICAgICAgaWYgKCFzaG9ydGN1dCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvcnRjdXQuY3RybCAhPT0gZS5jdHJsS2V5IHx8IHNob3J0Y3V0Lm1ldGEgIT09IGUubWV0YUtleSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvcnRjdXQuYWx0ICE9PSBlLmFsdEtleSB8fCBzaG9ydGN1dC5zaGlmdCAhPT0gZS5zaGlmdEtleSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZS5rZXlDb2RlID09PSBzaG9ydGN1dC5rZXlDb2RlIHx8IGUuY2hhckNvZGUgJiYgZS5jaGFyQ29kZSA9PT0gc2hvcnRjdXQuY2hhckNvZGUpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgZXhlY3V0ZVNob3J0Y3V0QWN0aW9uKHNob3J0Y3V0KSB7XG4gICAgICAgIHJldHVybiBzaG9ydGN1dC5mdW5jID8gc2hvcnRjdXQuZnVuYy5jYWxsKHNob3J0Y3V0LnNjb3BlKSA6IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgY3JlYXRlJDMgPSAoKSA9PiB7XG4gICAgICBjb25zdCBidXR0b25zID0ge307XG4gICAgICBjb25zdCBtZW51SXRlbXMgPSB7fTtcbiAgICAgIGNvbnN0IHBvcHVwcyA9IHt9O1xuICAgICAgY29uc3QgaWNvbnMgPSB7fTtcbiAgICAgIGNvbnN0IGNvbnRleHRNZW51cyA9IHt9O1xuICAgICAgY29uc3QgY29udGV4dFRvb2xiYXJzID0ge307XG4gICAgICBjb25zdCBzaWRlYmFycyA9IHt9O1xuICAgICAgY29uc3QgYWRkID0gKGNvbGxlY3Rpb24sIHR5cGUpID0+IChuYW1lLCBzcGVjKSA9PiBjb2xsZWN0aW9uW25hbWUudG9Mb3dlckNhc2UoKV0gPSB7XG4gICAgICAgIC4uLnNwZWMsXG4gICAgICAgIHR5cGVcbiAgICAgIH07XG4gICAgICBjb25zdCBhZGRJY29uID0gKG5hbWUsIHN2Z0RhdGEpID0+IGljb25zW25hbWUudG9Mb3dlckNhc2UoKV0gPSBzdmdEYXRhO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWRkQnV0dG9uOiBhZGQoYnV0dG9ucywgJ2J1dHRvbicpLFxuICAgICAgICBhZGRHcm91cFRvb2xiYXJCdXR0b246IGFkZChidXR0b25zLCAnZ3JvdXB0b29sYmFyYnV0dG9uJyksXG4gICAgICAgIGFkZFRvZ2dsZUJ1dHRvbjogYWRkKGJ1dHRvbnMsICd0b2dnbGVidXR0b24nKSxcbiAgICAgICAgYWRkTWVudUJ1dHRvbjogYWRkKGJ1dHRvbnMsICdtZW51YnV0dG9uJyksXG4gICAgICAgIGFkZFNwbGl0QnV0dG9uOiBhZGQoYnV0dG9ucywgJ3NwbGl0YnV0dG9uJyksXG4gICAgICAgIGFkZE1lbnVJdGVtOiBhZGQobWVudUl0ZW1zLCAnbWVudWl0ZW0nKSxcbiAgICAgICAgYWRkTmVzdGVkTWVudUl0ZW06IGFkZChtZW51SXRlbXMsICduZXN0ZWRtZW51aXRlbScpLFxuICAgICAgICBhZGRUb2dnbGVNZW51SXRlbTogYWRkKG1lbnVJdGVtcywgJ3RvZ2dsZW1lbnVpdGVtJyksXG4gICAgICAgIGFkZEF1dG9jb21wbGV0ZXI6IGFkZChwb3B1cHMsICdhdXRvY29tcGxldGVyJyksXG4gICAgICAgIGFkZENvbnRleHRNZW51OiBhZGQoY29udGV4dE1lbnVzLCAnY29udGV4dG1lbnUnKSxcbiAgICAgICAgYWRkQ29udGV4dFRvb2xiYXI6IGFkZChjb250ZXh0VG9vbGJhcnMsICdjb250ZXh0dG9vbGJhcicpLFxuICAgICAgICBhZGRDb250ZXh0Rm9ybTogYWRkKGNvbnRleHRUb29sYmFycywgJ2NvbnRleHRmb3JtJyksXG4gICAgICAgIGFkZFNpZGViYXI6IGFkZChzaWRlYmFycywgJ3NpZGViYXInKSxcbiAgICAgICAgYWRkSWNvbixcbiAgICAgICAgZ2V0QWxsOiAoKSA9PiAoe1xuICAgICAgICAgIGJ1dHRvbnMsXG4gICAgICAgICAgbWVudUl0ZW1zLFxuICAgICAgICAgIGljb25zLFxuICAgICAgICAgIHBvcHVwcyxcbiAgICAgICAgICBjb250ZXh0TWVudXMsXG4gICAgICAgICAgY29udGV4dFRvb2xiYXJzLFxuICAgICAgICAgIHNpZGViYXJzXG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCByZWdpc3RyeSA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGJyaWRnZSA9IGNyZWF0ZSQzKCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhZGRBdXRvY29tcGxldGVyOiBicmlkZ2UuYWRkQXV0b2NvbXBsZXRlcixcbiAgICAgICAgYWRkQnV0dG9uOiBicmlkZ2UuYWRkQnV0dG9uLFxuICAgICAgICBhZGRDb250ZXh0Rm9ybTogYnJpZGdlLmFkZENvbnRleHRGb3JtLFxuICAgICAgICBhZGRDb250ZXh0TWVudTogYnJpZGdlLmFkZENvbnRleHRNZW51LFxuICAgICAgICBhZGRDb250ZXh0VG9vbGJhcjogYnJpZGdlLmFkZENvbnRleHRUb29sYmFyLFxuICAgICAgICBhZGRJY29uOiBicmlkZ2UuYWRkSWNvbixcbiAgICAgICAgYWRkTWVudUJ1dHRvbjogYnJpZGdlLmFkZE1lbnVCdXR0b24sXG4gICAgICAgIGFkZE1lbnVJdGVtOiBicmlkZ2UuYWRkTWVudUl0ZW0sXG4gICAgICAgIGFkZE5lc3RlZE1lbnVJdGVtOiBicmlkZ2UuYWRkTmVzdGVkTWVudUl0ZW0sXG4gICAgICAgIGFkZFNpZGViYXI6IGJyaWRnZS5hZGRTaWRlYmFyLFxuICAgICAgICBhZGRTcGxpdEJ1dHRvbjogYnJpZGdlLmFkZFNwbGl0QnV0dG9uLFxuICAgICAgICBhZGRUb2dnbGVCdXR0b246IGJyaWRnZS5hZGRUb2dnbGVCdXR0b24sXG4gICAgICAgIGFkZEdyb3VwVG9vbGJhckJ1dHRvbjogYnJpZGdlLmFkZEdyb3VwVG9vbGJhckJ1dHRvbixcbiAgICAgICAgYWRkVG9nZ2xlTWVudUl0ZW06IGJyaWRnZS5hZGRUb2dnbGVNZW51SXRlbSxcbiAgICAgICAgZ2V0QWxsOiBicmlkZ2UuZ2V0QWxsXG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCBET00kMSA9IERPTVV0aWxzLkRPTTtcbiAgICBjb25zdCBleHRlbmQgPSBUb29scy5leHRlbmQsIGVhY2gkMSA9IFRvb2xzLmVhY2g7XG4gICAgY2xhc3MgRWRpdG9yIHtcbiAgICAgIGNvbnN0cnVjdG9yKGlkLCBvcHRpb25zLCBlZGl0b3JNYW5hZ2VyKSB7XG4gICAgICAgIHRoaXMucGx1Z2lucyA9IHt9O1xuICAgICAgICB0aGlzLmNvbnRlbnRDU1MgPSBbXTtcbiAgICAgICAgdGhpcy5jb250ZW50U3R5bGVzID0gW107XG4gICAgICAgIHRoaXMubG9hZGVkQ1NTID0ge307XG4gICAgICAgIHRoaXMuaXNOb3REaXJ0eSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVkaXRvck1hbmFnZXIgPSBlZGl0b3JNYW5hZ2VyO1xuICAgICAgICB0aGlzLmRvY3VtZW50QmFzZVVybCA9IGVkaXRvck1hbmFnZXIuZG9jdW1lbnRCYXNlVVJMO1xuICAgICAgICBleHRlbmQodGhpcywgRWRpdG9yT2JzZXJ2YWJsZSk7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMuaGlkZGVuID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRPcHRpb25zID0gbm9ybWFsaXplT3B0aW9ucyhlZGl0b3JNYW5hZ2VyLmRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gY3JlYXRlJDUoc2VsZiwgbm9ybWFsaXplZE9wdGlvbnMpO1xuICAgICAgICByZWdpc3RlciQ3KHNlbGYpO1xuICAgICAgICBjb25zdCBnZXRPcHRpb24gPSB0aGlzLm9wdGlvbnMuZ2V0O1xuICAgICAgICBpZiAoZ2V0T3B0aW9uKCdkZXByZWNhdGlvbl93YXJuaW5ncycpKSB7XG4gICAgICAgICAgbG9nV2FybmluZ3Mob3B0aW9ucywgbm9ybWFsaXplZE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN1ZmZpeCA9IGdldE9wdGlvbignc3VmZml4Jyk7XG4gICAgICAgIGlmIChzdWZmaXgpIHtcbiAgICAgICAgICBlZGl0b3JNYW5hZ2VyLnN1ZmZpeCA9IHN1ZmZpeDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN1ZmZpeCA9IGVkaXRvck1hbmFnZXIuc3VmZml4O1xuICAgICAgICBjb25zdCBiYXNlVXJsID0gZ2V0T3B0aW9uKCdiYXNlX3VybCcpO1xuICAgICAgICBpZiAoYmFzZVVybCkge1xuICAgICAgICAgIGVkaXRvck1hbmFnZXIuX3NldEJhc2VVcmwoYmFzZVVybCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iYXNlVXJpID0gZWRpdG9yTWFuYWdlci5iYXNlVVJJO1xuICAgICAgICBjb25zdCByZWZlcnJlclBvbGljeSA9IGdldFJlZmVycmVyUG9saWN5KHNlbGYpO1xuICAgICAgICBpZiAocmVmZXJyZXJQb2xpY3kpIHtcbiAgICAgICAgICBTY3JpcHRMb2FkZXIuU2NyaXB0TG9hZGVyLl9zZXRSZWZlcnJlclBvbGljeShyZWZlcnJlclBvbGljeSk7XG4gICAgICAgICAgRE9NVXRpbHMuRE9NLnN0eWxlU2hlZXRMb2FkZXIuX3NldFJlZmVycmVyUG9saWN5KHJlZmVycmVyUG9saWN5KTtcbiAgICAgICAgfVxuICAgICAgICBBZGRPbk1hbmFnZXIubGFuZ3VhZ2VMb2FkID0gZ2V0T3B0aW9uKCdsYW5ndWFnZV9sb2FkJyk7XG4gICAgICAgIEFkZE9uTWFuYWdlci5iYXNlVVJMID0gZWRpdG9yTWFuYWdlci5iYXNlVVJMO1xuICAgICAgICB0aGlzLnNldERpcnR5KGZhbHNlKTtcbiAgICAgICAgdGhpcy5kb2N1bWVudEJhc2VVUkkgPSBuZXcgVVJJKGdldERvY3VtZW50QmFzZVVybChzZWxmKSwgeyBiYXNlX3VyaTogdGhpcy5iYXNlVXJpIH0pO1xuICAgICAgICB0aGlzLmJhc2VVUkkgPSB0aGlzLmJhc2VVcmk7XG4gICAgICAgIHRoaXMuaW5saW5lID0gaXNJbmxpbmUoc2VsZik7XG4gICAgICAgIHRoaXMuc2hvcnRjdXRzID0gbmV3IFNob3J0Y3V0cyh0aGlzKTtcbiAgICAgICAgdGhpcy5lZGl0b3JDb21tYW5kcyA9IG5ldyBFZGl0b3JDb21tYW5kcyh0aGlzKTtcbiAgICAgICAgcmVnaXN0ZXJDb21tYW5kcyh0aGlzKTtcbiAgICAgICAgY29uc3QgY2FjaGVTdWZmaXggPSBnZXRPcHRpb24oJ2NhY2hlX3N1ZmZpeCcpO1xuICAgICAgICBpZiAoY2FjaGVTdWZmaXgpIHtcbiAgICAgICAgICBFbnYuY2FjaGVTdWZmaXggPSBjYWNoZVN1ZmZpeC5yZXBsYWNlKC9eW1xcP1xcJl0rLywgJycpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudWkgPSB7XG4gICAgICAgICAgcmVnaXN0cnk6IHJlZ2lzdHJ5KCksXG4gICAgICAgICAgc3R5bGVTaGVldExvYWRlcjogdW5kZWZpbmVkLFxuICAgICAgICAgIHNob3c6IG5vb3AsXG4gICAgICAgICAgaGlkZTogbm9vcCxcbiAgICAgICAgICBzZXRFbmFibGVkOiBub29wLFxuICAgICAgICAgIGlzRW5hYmxlZDogYWx3YXlzXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubW9kZSA9IGNyZWF0ZSQ0KHNlbGYpO1xuICAgICAgICBlZGl0b3JNYW5hZ2VyLmRpc3BhdGNoKCdTZXR1cEVkaXRvcicsIHsgZWRpdG9yOiB0aGlzIH0pO1xuICAgICAgICBjb25zdCBzZXR1cENhbGxiYWNrID0gZ2V0U2V0dXBDYWxsYmFjayhzZWxmKTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oc2V0dXBDYWxsYmFjaykpIHtcbiAgICAgICAgICBzZXR1cENhbGxiYWNrLmNhbGwoc2VsZiwgc2VsZik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlbmRlcigpIHtcbiAgICAgICAgcmVuZGVyKHRoaXMpO1xuICAgICAgfVxuICAgICAgZm9jdXMoc2tpcEZvY3VzKSB7XG4gICAgICAgIHRoaXMuZXhlY0NvbW1hbmQoJ21jZUZvY3VzJywgZmFsc2UsIHNraXBGb2N1cyk7XG4gICAgICB9XG4gICAgICBoYXNGb2N1cygpIHtcbiAgICAgICAgcmV0dXJuIGhhc0ZvY3VzKHRoaXMpO1xuICAgICAgfVxuICAgICAgdHJhbnNsYXRlKHRleHQpIHtcbiAgICAgICAgcmV0dXJuIEkxOG4udHJhbnNsYXRlKHRleHQpO1xuICAgICAgfVxuICAgICAgZ2V0UGFyYW0obmFtZSwgZGVmYXVsdFZhbCwgdHlwZSkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBpZiAoIW9wdGlvbnMuaXNSZWdpc3RlcmVkKG5hbWUpKSB7XG4gICAgICAgICAgaWYgKGlzTm9uTnVsbGFibGUodHlwZSkpIHtcbiAgICAgICAgICAgIG9wdGlvbnMucmVnaXN0ZXIobmFtZSwge1xuICAgICAgICAgICAgICBwcm9jZXNzb3I6IHR5cGUsXG4gICAgICAgICAgICAgIGRlZmF1bHQ6IGRlZmF1bHRWYWxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zLnJlZ2lzdGVyKG5hbWUsIHtcbiAgICAgICAgICAgICAgcHJvY2Vzc29yOiBhbHdheXMsXG4gICAgICAgICAgICAgIGRlZmF1bHQ6IGRlZmF1bHRWYWxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIW9wdGlvbnMuaXNTZXQobmFtZSkgJiYgIWlzVW5kZWZpbmVkKGRlZmF1bHRWYWwpID8gZGVmYXVsdFZhbCA6IG9wdGlvbnMuZ2V0KG5hbWUpO1xuICAgICAgfVxuICAgICAgaGFzUGx1Z2luKG5hbWUsIGxvYWRlZCkge1xuICAgICAgICBjb25zdCBoYXNQbHVnaW4gPSBjb250YWlucyQyKGdldFBsdWdpbnModGhpcyksIG5hbWUpO1xuICAgICAgICBpZiAoaGFzUGx1Z2luKSB7XG4gICAgICAgICAgcmV0dXJuIGxvYWRlZCA/IFBsdWdpbk1hbmFnZXIuZ2V0KG5hbWUpICE9PSB1bmRlZmluZWQgOiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbm9kZUNoYW5nZWQoYXJncykge1xuICAgICAgICB0aGlzLl9ub2RlQ2hhbmdlRGlzcGF0Y2hlci5ub2RlQ2hhbmdlZChhcmdzKTtcbiAgICAgIH1cbiAgICAgIGFkZENvbW1hbmQobmFtZSwgY2FsbGJhY2ssIHNjb3BlKSB7XG4gICAgICAgIHRoaXMuZWRpdG9yQ29tbWFuZHMuYWRkQ29tbWFuZChuYW1lLCBjYWxsYmFjaywgc2NvcGUpO1xuICAgICAgfVxuICAgICAgYWRkUXVlcnlTdGF0ZUhhbmRsZXIobmFtZSwgY2FsbGJhY2ssIHNjb3BlKSB7XG4gICAgICAgIHRoaXMuZWRpdG9yQ29tbWFuZHMuYWRkUXVlcnlTdGF0ZUhhbmRsZXIobmFtZSwgY2FsbGJhY2ssIHNjb3BlKTtcbiAgICAgIH1cbiAgICAgIGFkZFF1ZXJ5VmFsdWVIYW5kbGVyKG5hbWUsIGNhbGxiYWNrLCBzY29wZSkge1xuICAgICAgICB0aGlzLmVkaXRvckNvbW1hbmRzLmFkZFF1ZXJ5VmFsdWVIYW5kbGVyKG5hbWUsIGNhbGxiYWNrLCBzY29wZSk7XG4gICAgICB9XG4gICAgICBhZGRTaG9ydGN1dChwYXR0ZXJuLCBkZXNjLCBjbWRGdW5jLCBzY29wZSkge1xuICAgICAgICB0aGlzLnNob3J0Y3V0cy5hZGQocGF0dGVybiwgZGVzYywgY21kRnVuYywgc2NvcGUpO1xuICAgICAgfVxuICAgICAgZXhlY0NvbW1hbmQoY21kLCB1aSwgdmFsdWUsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWRpdG9yQ29tbWFuZHMuZXhlY0NvbW1hbmQoY21kLCB1aSwgdmFsdWUsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgcXVlcnlDb21tYW5kU3RhdGUoY21kKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVkaXRvckNvbW1hbmRzLnF1ZXJ5Q29tbWFuZFN0YXRlKGNtZCk7XG4gICAgICB9XG4gICAgICBxdWVyeUNvbW1hbmRWYWx1ZShjbWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWRpdG9yQ29tbWFuZHMucXVlcnlDb21tYW5kVmFsdWUoY21kKTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5Q29tbWFuZFN1cHBvcnRlZChjbWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWRpdG9yQ29tbWFuZHMucXVlcnlDb21tYW5kU3VwcG9ydGVkKGNtZCk7XG4gICAgICB9XG4gICAgICBzaG93KCkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKHNlbGYuaGlkZGVuKSB7XG4gICAgICAgICAgc2VsZi5oaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgICBpZiAoc2VsZi5pbmxpbmUpIHtcbiAgICAgICAgICAgIHNlbGYuZ2V0Qm9keSgpLmNvbnRlbnRFZGl0YWJsZSA9ICd0cnVlJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgRE9NJDEuc2hvdyhzZWxmLmdldENvbnRhaW5lcigpKTtcbiAgICAgICAgICAgIERPTSQxLmhpZGUoc2VsZi5pZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGYubG9hZCgpO1xuICAgICAgICAgIHNlbGYuZGlzcGF0Y2goJ3Nob3cnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaGlkZSgpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmICghc2VsZi5oaWRkZW4pIHtcbiAgICAgICAgICBzZWxmLnNhdmUoKTtcbiAgICAgICAgICBpZiAoc2VsZi5pbmxpbmUpIHtcbiAgICAgICAgICAgIHNlbGYuZ2V0Qm9keSgpLmNvbnRlbnRFZGl0YWJsZSA9ICdmYWxzZSc7XG4gICAgICAgICAgICBpZiAoc2VsZiA9PT0gc2VsZi5lZGl0b3JNYW5hZ2VyLmZvY3VzZWRFZGl0b3IpIHtcbiAgICAgICAgICAgICAgc2VsZi5lZGl0b3JNYW5hZ2VyLmZvY3VzZWRFZGl0b3IgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBET00kMS5oaWRlKHNlbGYuZ2V0Q29udGFpbmVyKCkpO1xuICAgICAgICAgICAgRE9NJDEuc2V0U3R5bGUoc2VsZi5pZCwgJ2Rpc3BsYXknLCBzZWxmLm9yZ0Rpc3BsYXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxmLmhpZGRlbiA9IHRydWU7XG4gICAgICAgICAgc2VsZi5kaXNwYXRjaCgnaGlkZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpc0hpZGRlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGlkZGVuO1xuICAgICAgfVxuICAgICAgc2V0UHJvZ3Jlc3NTdGF0ZShzdGF0ZSwgdGltZSkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoKCdQcm9ncmVzc1N0YXRlJywge1xuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIHRpbWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBsb2FkKGFyZ3MpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGxldCBlbG0gPSBzZWxmLmdldEVsZW1lbnQoKSwgaHRtbDtcbiAgICAgICAgaWYgKHNlbGYucmVtb3ZlZCkge1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWxtKSB7XG4gICAgICAgICAgYXJncyA9IGFyZ3MgfHwge307XG4gICAgICAgICAgYXJncy5sb2FkID0gdHJ1ZTtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IGlzVGV4dGFyZWFPcklucHV0KGVsbSkgPyBlbG0udmFsdWUgOiBlbG0uaW5uZXJIVE1MO1xuICAgICAgICAgIGh0bWwgPSBzZWxmLnNldENvbnRlbnQodmFsdWUsIGFyZ3MpO1xuICAgICAgICAgIGFyZ3MuZWxlbWVudCA9IGVsbTtcbiAgICAgICAgICBpZiAoIWFyZ3Mubm9fZXZlbnRzKSB7XG4gICAgICAgICAgICBzZWxmLmRpc3BhdGNoKCdMb2FkQ29udGVudCcsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhcmdzLmVsZW1lbnQgPSBlbG0gPSBudWxsO1xuICAgICAgICAgIHJldHVybiBodG1sO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzYXZlKGFyZ3MpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGxldCBlbG0gPSBzZWxmLmdldEVsZW1lbnQoKSwgaHRtbCwgZm9ybTtcbiAgICAgICAgaWYgKCFlbG0gfHwgIXNlbGYuaW5pdGlhbGl6ZWQgfHwgc2VsZi5yZW1vdmVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGFyZ3MgPSBhcmdzIHx8IHt9O1xuICAgICAgICBhcmdzLnNhdmUgPSB0cnVlO1xuICAgICAgICBhcmdzLmVsZW1lbnQgPSBlbG07XG4gICAgICAgIGh0bWwgPSBhcmdzLmNvbnRlbnQgPSBzZWxmLmdldENvbnRlbnQoYXJncyk7XG4gICAgICAgIGlmICghYXJncy5ub19ldmVudHMpIHtcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoKCdTYXZlQ29udGVudCcsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcmdzLmZvcm1hdCA9PT0gJ3JhdycpIHtcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoKCdSYXdTYXZlQ29udGVudCcsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGh0bWwgPSBhcmdzLmNvbnRlbnQ7XG4gICAgICAgIGlmICghaXNUZXh0YXJlYU9ySW5wdXQoZWxtKSkge1xuICAgICAgICAgIGlmIChhcmdzLmlzX3JlbW92aW5nIHx8ICFzZWxmLmlubGluZSkge1xuICAgICAgICAgICAgZWxtLmlubmVySFRNTCA9IGh0bWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmb3JtID0gRE9NJDEuZ2V0UGFyZW50KHNlbGYuaWQsICdmb3JtJykpIHtcbiAgICAgICAgICAgIGVhY2gkMShmb3JtLmVsZW1lbnRzLCBlbG0gPT4ge1xuICAgICAgICAgICAgICBpZiAoZWxtLm5hbWUgPT09IHNlbGYuaWQpIHtcbiAgICAgICAgICAgICAgICBlbG0udmFsdWUgPSBodG1sO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsbS52YWx1ZSA9IGh0bWw7XG4gICAgICAgIH1cbiAgICAgICAgYXJncy5lbGVtZW50ID0gZWxtID0gbnVsbDtcbiAgICAgICAgaWYgKGFyZ3Muc2V0X2RpcnR5ICE9PSBmYWxzZSkge1xuICAgICAgICAgIHNlbGYuc2V0RGlydHkoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBodG1sO1xuICAgICAgfVxuICAgICAgc2V0Q29udGVudChjb250ZW50LCBhcmdzKSB7XG4gICAgICAgIHJldHVybiBzZXRDb250ZW50KHRoaXMsIGNvbnRlbnQsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgZ2V0Q29udGVudChhcmdzKSB7XG4gICAgICAgIHJldHVybiBnZXRDb250ZW50KHRoaXMsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgaW5zZXJ0Q29udGVudChjb250ZW50LCBhcmdzKSB7XG4gICAgICAgIGlmIChhcmdzKSB7XG4gICAgICAgICAgY29udGVudCA9IGV4dGVuZCh7IGNvbnRlbnQgfSwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5leGVjQ29tbWFuZCgnbWNlSW5zZXJ0Q29udGVudCcsIGZhbHNlLCBjb250ZW50KTtcbiAgICAgIH1cbiAgICAgIHJlc2V0Q29udGVudChpbml0aWFsQ29udGVudCkge1xuICAgICAgICBpZiAoaW5pdGlhbENvbnRlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHNldENvbnRlbnQodGhpcywgdGhpcy5zdGFydENvbnRlbnQsIHsgZm9ybWF0OiAncmF3JyB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRDb250ZW50KHRoaXMsIGluaXRpYWxDb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVuZG9NYW5hZ2VyLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuc2V0RGlydHkoZmFsc2UpO1xuICAgICAgICB0aGlzLm5vZGVDaGFuZ2VkKCk7XG4gICAgICB9XG4gICAgICBpc0RpcnR5KCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuaXNOb3REaXJ0eTtcbiAgICAgIH1cbiAgICAgIHNldERpcnR5KHN0YXRlKSB7XG4gICAgICAgIGNvbnN0IG9sZFN0YXRlID0gIXRoaXMuaXNOb3REaXJ0eTtcbiAgICAgICAgdGhpcy5pc05vdERpcnR5ID0gIXN0YXRlO1xuICAgICAgICBpZiAoc3RhdGUgJiYgc3RhdGUgIT09IG9sZFN0YXRlKSB7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaCgnZGlydHknKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZ2V0Q29udGFpbmVyKCkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKCFzZWxmLmNvbnRhaW5lcikge1xuICAgICAgICAgIHNlbGYuY29udGFpbmVyID0gRE9NJDEuZ2V0KHNlbGYuZWRpdG9yQ29udGFpbmVyIHx8IHNlbGYuaWQgKyAnX3BhcmVudCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxmLmNvbnRhaW5lcjtcbiAgICAgIH1cbiAgICAgIGdldENvbnRlbnRBcmVhQ29udGFpbmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50QXJlYUNvbnRhaW5lcjtcbiAgICAgIH1cbiAgICAgIGdldEVsZW1lbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy50YXJnZXRFbG0pIHtcbiAgICAgICAgICB0aGlzLnRhcmdldEVsbSA9IERPTSQxLmdldCh0aGlzLmlkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50YXJnZXRFbG07XG4gICAgICB9XG4gICAgICBnZXRXaW4oKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBsZXQgZWxtO1xuICAgICAgICBpZiAoIXNlbGYuY29udGVudFdpbmRvdykge1xuICAgICAgICAgIGVsbSA9IHNlbGYuaWZyYW1lRWxlbWVudDtcbiAgICAgICAgICBpZiAoZWxtKSB7XG4gICAgICAgICAgICBzZWxmLmNvbnRlbnRXaW5kb3cgPSBlbG0uY29udGVudFdpbmRvdztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGYuY29udGVudFdpbmRvdztcbiAgICAgIH1cbiAgICAgIGdldERvYygpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGxldCB3aW47XG4gICAgICAgIGlmICghc2VsZi5jb250ZW50RG9jdW1lbnQpIHtcbiAgICAgICAgICB3aW4gPSBzZWxmLmdldFdpbigpO1xuICAgICAgICAgIGlmICh3aW4pIHtcbiAgICAgICAgICAgIHNlbGYuY29udGVudERvY3VtZW50ID0gd2luLmRvY3VtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZi5jb250ZW50RG9jdW1lbnQ7XG4gICAgICB9XG4gICAgICBnZXRCb2R5KCkge1xuICAgICAgICBjb25zdCBkb2MgPSB0aGlzLmdldERvYygpO1xuICAgICAgICByZXR1cm4gdGhpcy5ib2R5RWxlbWVudCB8fCAoZG9jID8gZG9jLmJvZHkgOiBudWxsKTtcbiAgICAgIH1cbiAgICAgIGNvbnZlcnRVUkwodXJsLCBuYW1lLCBlbG0pIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXMsIGdldE9wdGlvbiA9IHNlbGYub3B0aW9ucy5nZXQ7XG4gICAgICAgIGNvbnN0IHVybENvbnZlcnRlckNhbGxiYWNrID0gZ2V0VXJsQ29udmVydGVyQ2FsbGJhY2soc2VsZik7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHVybENvbnZlcnRlckNhbGxiYWNrKSkge1xuICAgICAgICAgIHJldHVybiB1cmxDb252ZXJ0ZXJDYWxsYmFjay5jYWxsKHNlbGYsIHVybCwgZWxtLCB0cnVlLCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWdldE9wdGlvbignY29udmVydF91cmxzJykgfHwgZWxtICYmIGVsbS5ub2RlTmFtZSA9PT0gJ0xJTksnIHx8IHVybC5pbmRleE9mKCdmaWxlOicpID09PSAwIHx8IHVybC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnZXRPcHRpb24oJ3JlbGF0aXZlX3VybHMnKSkge1xuICAgICAgICAgIHJldHVybiBzZWxmLmRvY3VtZW50QmFzZVVSSS50b1JlbGF0aXZlKHVybCk7XG4gICAgICAgIH1cbiAgICAgICAgdXJsID0gc2VsZi5kb2N1bWVudEJhc2VVUkkudG9BYnNvbHV0ZSh1cmwsIGdldE9wdGlvbigncmVtb3ZlX3NjcmlwdF9ob3N0JykpO1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgfVxuICAgICAgYWRkVmlzdWFsKGVsbSkge1xuICAgICAgICBhZGRWaXN1YWwodGhpcywgZWxtKTtcbiAgICAgIH1cbiAgICAgIHJlbW92ZSgpIHtcbiAgICAgICAgcmVtb3ZlJDEodGhpcyk7XG4gICAgICB9XG4gICAgICBkZXN0cm95KGF1dG9tYXRpYykge1xuICAgICAgICBkZXN0cm95KHRoaXMsIGF1dG9tYXRpYyk7XG4gICAgICB9XG4gICAgICB1cGxvYWRJbWFnZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVkaXRvclVwbG9hZC51cGxvYWRJbWFnZXMoKTtcbiAgICAgIH1cbiAgICAgIF9zY2FuRm9ySW1hZ2VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lZGl0b3JVcGxvYWQuc2NhbkZvckltYWdlcygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IERPTSA9IERPTVV0aWxzLkRPTTtcbiAgICBjb25zdCBlYWNoID0gVG9vbHMuZWFjaDtcbiAgICBsZXQgYm91bmRHbG9iYWxFdmVudHMgPSBmYWxzZTtcbiAgICBsZXQgYmVmb3JlVW5sb2FkRGVsZWdhdGU7XG4gICAgbGV0IGVkaXRvcnMgPSBbXTtcbiAgICBjb25zdCBnbG9iYWxFdmVudERlbGVnYXRlID0gZSA9PiB7XG4gICAgICBjb25zdCB0eXBlID0gZS50eXBlO1xuICAgICAgZWFjaChFZGl0b3JNYW5hZ2VyLmdldCgpLCBlZGl0b3IgPT4ge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnc2Nyb2xsJzpcbiAgICAgICAgICBlZGl0b3IuZGlzcGF0Y2goJ1Njcm9sbFdpbmRvdycsIGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyZXNpemUnOlxuICAgICAgICAgIGVkaXRvci5kaXNwYXRjaCgnUmVzaXplV2luZG93JywgZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgdG9nZ2xlR2xvYmFsRXZlbnRzID0gc3RhdGUgPT4ge1xuICAgICAgaWYgKHN0YXRlICE9PSBib3VuZEdsb2JhbEV2ZW50cykge1xuICAgICAgICBjb25zdCBET00gPSBET01VdGlscy5ET007XG4gICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgIERPTS5iaW5kKHdpbmRvdywgJ3Jlc2l6ZScsIGdsb2JhbEV2ZW50RGVsZWdhdGUpO1xuICAgICAgICAgIERPTS5iaW5kKHdpbmRvdywgJ3Njcm9sbCcsIGdsb2JhbEV2ZW50RGVsZWdhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIERPTS51bmJpbmQod2luZG93LCAncmVzaXplJywgZ2xvYmFsRXZlbnREZWxlZ2F0ZSk7XG4gICAgICAgICAgRE9NLnVuYmluZCh3aW5kb3csICdzY3JvbGwnLCBnbG9iYWxFdmVudERlbGVnYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBib3VuZEdsb2JhbEV2ZW50cyA9IHN0YXRlO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcmVtb3ZlRWRpdG9yRnJvbUxpc3QgPSB0YXJnZXRFZGl0b3IgPT4ge1xuICAgICAgY29uc3Qgb2xkRWRpdG9ycyA9IGVkaXRvcnM7XG4gICAgICBlZGl0b3JzID0gZmlsdGVyJDYoZWRpdG9ycywgZWRpdG9yID0+IHtcbiAgICAgICAgcmV0dXJuIHRhcmdldEVkaXRvciAhPT0gZWRpdG9yO1xuICAgICAgfSk7XG4gICAgICBpZiAoRWRpdG9yTWFuYWdlci5hY3RpdmVFZGl0b3IgPT09IHRhcmdldEVkaXRvcikge1xuICAgICAgICBFZGl0b3JNYW5hZ2VyLmFjdGl2ZUVkaXRvciA9IGVkaXRvcnMubGVuZ3RoID4gMCA/IGVkaXRvcnNbMF0gOiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKEVkaXRvck1hbmFnZXIuZm9jdXNlZEVkaXRvciA9PT0gdGFyZ2V0RWRpdG9yKSB7XG4gICAgICAgIEVkaXRvck1hbmFnZXIuZm9jdXNlZEVkaXRvciA9IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2xkRWRpdG9ycy5sZW5ndGggIT09IGVkaXRvcnMubGVuZ3RoO1xuICAgIH07XG4gICAgY29uc3QgcHVyZ2VEZXN0cm95ZWRFZGl0b3IgPSBlZGl0b3IgPT4ge1xuICAgICAgaWYgKGVkaXRvciAmJiBlZGl0b3IuaW5pdGlhbGl6ZWQgJiYgIShlZGl0b3IuZ2V0Q29udGFpbmVyKCkgfHwgZWRpdG9yLmdldEJvZHkoKSkucGFyZW50Tm9kZSkge1xuICAgICAgICByZW1vdmVFZGl0b3JGcm9tTGlzdChlZGl0b3IpO1xuICAgICAgICBlZGl0b3IudW5iaW5kQWxsTmF0aXZlRXZlbnRzKCk7XG4gICAgICAgIGVkaXRvci5kZXN0cm95KHRydWUpO1xuICAgICAgICBlZGl0b3IucmVtb3ZlZCA9IHRydWU7XG4gICAgICAgIGVkaXRvciA9IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gZWRpdG9yO1xuICAgIH07XG4gICAgY29uc3QgaXNRdWlya3NNb2RlID0gZG9jdW1lbnQuY29tcGF0TW9kZSAhPT0gJ0NTUzFDb21wYXQnO1xuICAgIGNvbnN0IEVkaXRvck1hbmFnZXIgPSB7XG4gICAgICAuLi5PYnNlcnZhYmxlLFxuICAgICAgYmFzZVVSSTogbnVsbCxcbiAgICAgIGJhc2VVUkw6IG51bGwsXG4gICAgICBkZWZhdWx0T3B0aW9uczoge30sXG4gICAgICBkb2N1bWVudEJhc2VVUkw6IG51bGwsXG4gICAgICBzdWZmaXg6IG51bGwsXG4gICAgICBtYWpvclZlcnNpb246ICc2JyxcbiAgICAgIG1pbm9yVmVyc2lvbjogJzAuMycsXG4gICAgICByZWxlYXNlRGF0ZTogJzIwMjItMDUtMjUnLFxuICAgICAgaTE4bjogSTE4bixcbiAgICAgIGFjdGl2ZUVkaXRvcjogbnVsbCxcbiAgICAgIGZvY3VzZWRFZGl0b3I6IG51bGwsXG4gICAgICBzZXR1cCgpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGxldCBiYXNlVVJMLCBkb2N1bWVudEJhc2VVUkwsIHN1ZmZpeCA9ICcnO1xuICAgICAgICBkb2N1bWVudEJhc2VVUkwgPSBVUkkuZ2V0RG9jdW1lbnRCYXNlVXJsKGRvY3VtZW50LmxvY2F0aW9uKTtcbiAgICAgICAgaWYgKC9eW146XSs6XFwvXFwvXFwvP1teXFwvXStcXC8vLnRlc3QoZG9jdW1lbnRCYXNlVVJMKSkge1xuICAgICAgICAgIGRvY3VtZW50QmFzZVVSTCA9IGRvY3VtZW50QmFzZVVSTC5yZXBsYWNlKC9bXFw/I10uKiQvLCAnJykucmVwbGFjZSgvW1xcL1xcXFxdW15cXC9dKyQvLCAnJyk7XG4gICAgICAgICAgaWYgKCEvW1xcL1xcXFxdJC8udGVzdChkb2N1bWVudEJhc2VVUkwpKSB7XG4gICAgICAgICAgICBkb2N1bWVudEJhc2VVUkwgKz0gJy8nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmVJbml0ID0gd2luZG93LnRpbnltY2UgfHwgd2luZG93LnRpbnlNQ0VQcmVJbml0O1xuICAgICAgICBpZiAocHJlSW5pdCkge1xuICAgICAgICAgIGJhc2VVUkwgPSBwcmVJbml0LmJhc2UgfHwgcHJlSW5pdC5iYXNlVVJMO1xuICAgICAgICAgIHN1ZmZpeCA9IHByZUluaXQuc3VmZml4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHNjcmlwdHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0Jyk7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzY3JpcHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBzcmMgPSBzY3JpcHRzW2ldLnNyYyB8fCAnJztcbiAgICAgICAgICAgIGlmIChzcmMgPT09ICcnKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3JjU2NyaXB0ID0gc3JjLnN1YnN0cmluZyhzcmMubGFzdEluZGV4T2YoJy8nKSk7XG4gICAgICAgICAgICBpZiAoL3RpbnltY2UoXFwuZnVsbHxcXC5qcXVlcnl8KShcXC5taW58XFwuZGV2fClcXC5qcy8udGVzdChzcmMpKSB7XG4gICAgICAgICAgICAgIGlmIChzcmNTY3JpcHQuaW5kZXhPZignLm1pbicpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHN1ZmZpeCA9ICcubWluJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBiYXNlVVJMID0gc3JjLnN1YnN0cmluZygwLCBzcmMubGFzdEluZGV4T2YoJy8nKSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWJhc2VVUkwgJiYgZG9jdW1lbnQuY3VycmVudFNjcmlwdCkge1xuICAgICAgICAgICAgY29uc3Qgc3JjID0gZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmM7XG4gICAgICAgICAgICBpZiAoc3JjLmluZGV4T2YoJy5taW4nKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgc3VmZml4ID0gJy5taW4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmFzZVVSTCA9IHNyYy5zdWJzdHJpbmcoMCwgc3JjLmxhc3RJbmRleE9mKCcvJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZWxmLmJhc2VVUkwgPSBuZXcgVVJJKGRvY3VtZW50QmFzZVVSTCkudG9BYnNvbHV0ZShiYXNlVVJMKTtcbiAgICAgICAgc2VsZi5kb2N1bWVudEJhc2VVUkwgPSBkb2N1bWVudEJhc2VVUkw7XG4gICAgICAgIHNlbGYuYmFzZVVSSSA9IG5ldyBVUkkoc2VsZi5iYXNlVVJMKTtcbiAgICAgICAgc2VsZi5zdWZmaXggPSBzdWZmaXg7XG4gICAgICAgIHNldHVwJHYoc2VsZik7XG4gICAgICB9LFxuICAgICAgb3ZlcnJpZGVEZWZhdWx0cyhkZWZhdWx0T3B0aW9ucykge1xuICAgICAgICBjb25zdCBiYXNlVXJsID0gZGVmYXVsdE9wdGlvbnMuYmFzZV91cmw7XG4gICAgICAgIGlmIChiYXNlVXJsKSB7XG4gICAgICAgICAgdGhpcy5fc2V0QmFzZVVybChiYXNlVXJsKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdWZmaXggPSBkZWZhdWx0T3B0aW9ucy5zdWZmaXg7XG4gICAgICAgIGlmIChkZWZhdWx0T3B0aW9ucy5zdWZmaXgpIHtcbiAgICAgICAgICB0aGlzLnN1ZmZpeCA9IHN1ZmZpeDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0gZGVmYXVsdE9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHBsdWdpbkJhc2VVcmxzID0gZGVmYXVsdE9wdGlvbnMucGx1Z2luX2Jhc2VfdXJscztcbiAgICAgICAgaWYgKHBsdWdpbkJhc2VVcmxzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBlYWNoJGYocGx1Z2luQmFzZVVybHMsIChwbHVnaW5CYXNlVXJsLCBwbHVnaW5OYW1lKSA9PiB7XG4gICAgICAgICAgICBBZGRPbk1hbmFnZXIuUGx1Z2luTWFuYWdlci51cmxzW3BsdWdpbk5hbWVdID0gcGx1Z2luQmFzZVVybDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGluaXQob3B0aW9ucykge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgY29uc3QgaW52YWxpZElubGluZVRhcmdldHMgPSBUb29scy5tYWtlTWFwKCdhcmVhIGJhc2UgYmFzZWZvbnQgYnIgY29sIGZyYW1lIGhyIGltZyBpbnB1dCBpc2luZGV4IGxpbmsgbWV0YSBwYXJhbSBlbWJlZCBzb3VyY2Ugd2JyIHRyYWNrICcgKyAnY29sZ3JvdXAgb3B0aW9uIHRhYmxlIHRib2R5IHRmb290IHRoZWFkIHRyIHRoIHRkIHNjcmlwdCBub3NjcmlwdCBzdHlsZSB0ZXh0YXJlYSB2aWRlbyBhdWRpbyBpZnJhbWUgb2JqZWN0IG1lbnUnLCAnICcpO1xuICAgICAgICBjb25zdCBpc0ludmFsaWRJbmxpbmVUYXJnZXQgPSAob3B0aW9ucywgZWxtKSA9PiBvcHRpb25zLmlubGluZSAmJiBlbG0udGFnTmFtZS50b0xvd2VyQ2FzZSgpIGluIGludmFsaWRJbmxpbmVUYXJnZXRzO1xuICAgICAgICBjb25zdCBjcmVhdGVJZCA9IGVsbSA9PiB7XG4gICAgICAgICAgbGV0IGlkID0gZWxtLmlkO1xuICAgICAgICAgIGlmICghaWQpIHtcbiAgICAgICAgICAgIGlkID0gZ2V0JGEoZWxtLCAnbmFtZScpLmZpbHRlcihuYW1lID0+ICFET00uZ2V0KG5hbWUpKS5nZXRPclRodW5rKERPTS51bmlxdWVJZCk7XG4gICAgICAgICAgICBlbG0uc2V0QXR0cmlidXRlKCdpZCcsIGlkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBleGVjQ2FsbGJhY2sgPSBuYW1lID0+IHtcbiAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IG9wdGlvbnNbbmFtZV07XG4gICAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkoc2VsZiwgW10pO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBmaW5kVGFyZ2V0cyA9IG9wdGlvbnMgPT4ge1xuICAgICAgICAgIGlmIChFbnYuYnJvd3Nlci5pc0lFKCkgfHwgRW52LmJyb3dzZXIuaXNFZGdlKCkpIHtcbiAgICAgICAgICAgIGluaXRFcnJvcignVGlueU1DRSBkb2VzIG5vdCBzdXBwb3J0IHRoZSBicm93c2VyIHlvdSBhcmUgdXNpbmcuIEZvciBhIGxpc3Qgb2Ygc3VwcG9ydGVkJyArICcgYnJvd3NlcnMgcGxlYXNlIHNlZTogaHR0cHM6Ly93d3cudGlueS5jbG91ZC9kb2NzL3RpbnltY2UvNi9zdXBwb3J0LyNzdXBwb3J0ZWR3ZWJicm93c2VycycpO1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNRdWlya3NNb2RlKSB7XG4gICAgICAgICAgICBpbml0RXJyb3IoJ0ZhaWxlZCB0byBpbml0aWFsaXplIHRoZSBlZGl0b3IgYXMgdGhlIGRvY3VtZW50IGlzIG5vdCBpbiBzdGFuZGFyZHMgbW9kZS4gJyArICdUaW55TUNFIHJlcXVpcmVzIHN0YW5kYXJkcyBtb2RlLicpO1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNTdHJpbmcob3B0aW9ucy5zZWxlY3RvcikpIHtcbiAgICAgICAgICAgIHJldHVybiBET00uc2VsZWN0KG9wdGlvbnMuc2VsZWN0b3IpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNOb25OdWxsYWJsZShvcHRpb25zLnRhcmdldCkpIHtcbiAgICAgICAgICAgIHJldHVybiBbb3B0aW9ucy50YXJnZXRdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBsZXQgcHJvdmlkZVJlc3VsdHMgPSBlZGl0b3JzID0+IHtcbiAgICAgICAgICByZXN1bHQgPSBlZGl0b3JzO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBpbml0RWRpdG9ycyA9ICgpID0+IHtcbiAgICAgICAgICBsZXQgaW5pdENvdW50ID0gMDtcbiAgICAgICAgICBjb25zdCBlZGl0b3JzID0gW107XG4gICAgICAgICAgbGV0IHRhcmdldHM7XG4gICAgICAgICAgY29uc3QgY3JlYXRlRWRpdG9yID0gKGlkLCBvcHRpb25zLCB0YXJnZXRFbG0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVkaXRvciA9IG5ldyBFZGl0b3IoaWQsIG9wdGlvbnMsIHNlbGYpO1xuICAgICAgICAgICAgZWRpdG9ycy5wdXNoKGVkaXRvcik7XG4gICAgICAgICAgICBlZGl0b3Iub24oJ2luaXQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgIGlmICgrK2luaXRDb3VudCA9PT0gdGFyZ2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlUmVzdWx0cyhlZGl0b3JzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBlZGl0b3IudGFyZ2V0RWxtID0gZWRpdG9yLnRhcmdldEVsbSB8fCB0YXJnZXRFbG07XG4gICAgICAgICAgICBlZGl0b3IucmVuZGVyKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBET00udW5iaW5kKHdpbmRvdywgJ3JlYWR5JywgaW5pdEVkaXRvcnMpO1xuICAgICAgICAgIGV4ZWNDYWxsYmFjaygnb25wYWdlbG9hZCcpO1xuICAgICAgICAgIHRhcmdldHMgPSB1bmlxdWUkMShmaW5kVGFyZ2V0cyhvcHRpb25zKSk7XG4gICAgICAgICAgVG9vbHMuZWFjaCh0YXJnZXRzLCBlbG0gPT4ge1xuICAgICAgICAgICAgcHVyZ2VEZXN0cm95ZWRFZGl0b3Ioc2VsZi5nZXQoZWxtLmlkKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGFyZ2V0cyA9IFRvb2xzLmdyZXAodGFyZ2V0cywgZWxtID0+IHtcbiAgICAgICAgICAgIHJldHVybiAhc2VsZi5nZXQoZWxtLmlkKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAodGFyZ2V0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHByb3ZpZGVSZXN1bHRzKFtdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWFjaCh0YXJnZXRzLCBlbG0gPT4ge1xuICAgICAgICAgICAgICBpZiAoaXNJbnZhbGlkSW5saW5lVGFyZ2V0KG9wdGlvbnMsIGVsbSkpIHtcbiAgICAgICAgICAgICAgICBpbml0RXJyb3IoJ0NvdWxkIG5vdCBpbml0aWFsaXplIGlubGluZSBlZGl0b3Igb24gaW52YWxpZCBpbmxpbmUgdGFyZ2V0IGVsZW1lbnQnLCBlbG0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNyZWF0ZUVkaXRvcihjcmVhdGVJZChlbG0pLCBvcHRpb25zLCBlbG0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIERPTS5iaW5kKHdpbmRvdywgJ3JlYWR5JywgaW5pdEVkaXRvcnMpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm92aWRlUmVzdWx0cyA9IGVkaXRvcnMgPT4ge1xuICAgICAgICAgICAgICByZXNvbHZlKGVkaXRvcnMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGdldChpZCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBlZGl0b3JzLnNsaWNlKDApO1xuICAgICAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKGlkKSkge1xuICAgICAgICAgIHJldHVybiBmaW5kJDIoZWRpdG9ycywgZWRpdG9yID0+IHtcbiAgICAgICAgICAgIHJldHVybiBlZGl0b3IuaWQgPT09IGlkO1xuICAgICAgICAgIH0pLmdldE9yKG51bGwpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKGlkKSkge1xuICAgICAgICAgIHJldHVybiBlZGl0b3JzW2lkXSA/IGVkaXRvcnNbaWRdIDogbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGFkZChlZGl0b3IpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nRWRpdG9yID0gc2VsZi5nZXQoZWRpdG9yLmlkKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nRWRpdG9yID09PSBlZGl0b3IpIHtcbiAgICAgICAgICByZXR1cm4gZWRpdG9yO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleGlzdGluZ0VkaXRvciA9PT0gbnVsbCkge1xuICAgICAgICAgIGVkaXRvcnMucHVzaChlZGl0b3IpO1xuICAgICAgICB9XG4gICAgICAgIHRvZ2dsZUdsb2JhbEV2ZW50cyh0cnVlKTtcbiAgICAgICAgc2VsZi5hY3RpdmVFZGl0b3IgPSBlZGl0b3I7XG4gICAgICAgIHNlbGYuZGlzcGF0Y2goJ0FkZEVkaXRvcicsIHsgZWRpdG9yIH0pO1xuICAgICAgICBpZiAoIWJlZm9yZVVubG9hZERlbGVnYXRlKSB7XG4gICAgICAgICAgYmVmb3JlVW5sb2FkRGVsZWdhdGUgPSBlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gc2VsZi5kaXNwYXRjaCgnQmVmb3JlVW5sb2FkJyk7XG4gICAgICAgICAgICBpZiAoZXZlbnQucmV0dXJuVmFsdWUpIHtcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICBlLnJldHVyblZhbHVlID0gZXZlbnQucmV0dXJuVmFsdWU7XG4gICAgICAgICAgICAgIHJldHVybiBldmVudC5yZXR1cm5WYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCBiZWZvcmVVbmxvYWREZWxlZ2F0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVkaXRvcjtcbiAgICAgIH0sXG4gICAgICBjcmVhdGVFZGl0b3IoaWQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkKG5ldyBFZGl0b3IoaWQsIG9wdGlvbnMsIHRoaXMpKTtcbiAgICAgIH0sXG4gICAgICByZW1vdmUoc2VsZWN0b3IpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGxldCBpLCBlZGl0b3I7XG4gICAgICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgICAgICBmb3IgKGkgPSBlZGl0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBzZWxmLnJlbW92ZShlZGl0b3JzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1N0cmluZyhzZWxlY3RvcikpIHtcbiAgICAgICAgICBlYWNoKERPTS5zZWxlY3Qoc2VsZWN0b3IpLCBlbG0gPT4ge1xuICAgICAgICAgICAgZWRpdG9yID0gc2VsZi5nZXQoZWxtLmlkKTtcbiAgICAgICAgICAgIGlmIChlZGl0b3IpIHtcbiAgICAgICAgICAgICAgc2VsZi5yZW1vdmUoZWRpdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWRpdG9yID0gc2VsZWN0b3I7XG4gICAgICAgIGlmIChpc051bGwoc2VsZi5nZXQoZWRpdG9yLmlkKSkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVtb3ZlRWRpdG9yRnJvbUxpc3QoZWRpdG9yKSkge1xuICAgICAgICAgIHNlbGYuZGlzcGF0Y2goJ1JlbW92ZUVkaXRvcicsIHsgZWRpdG9yIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlZGl0b3JzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCBiZWZvcmVVbmxvYWREZWxlZ2F0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWRpdG9yLnJlbW92ZSgpO1xuICAgICAgICB0b2dnbGVHbG9iYWxFdmVudHMoZWRpdG9ycy5sZW5ndGggPiAwKTtcbiAgICAgICAgcmV0dXJuIGVkaXRvcjtcbiAgICAgIH0sXG4gICAgICBleGVjQ29tbWFuZChjbWQsIHVpLCB2YWx1ZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBjb25zdCBlZGl0b3JJZCA9IGlzT2JqZWN0KHZhbHVlKSA/IChfYSA9IHZhbHVlLmlkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB2YWx1ZS5pbmRleCA6IHZhbHVlO1xuICAgICAgICBzd2l0Y2ggKGNtZCkge1xuICAgICAgICBjYXNlICdtY2VBZGRFZGl0b3InOiB7XG4gICAgICAgICAgICBpZiAoIXNlbGYuZ2V0KGVkaXRvcklkKSkge1xuICAgICAgICAgICAgICBjb25zdCBlZGl0b3JPcHRpb25zID0gdmFsdWUub3B0aW9ucztcbiAgICAgICAgICAgICAgbmV3IEVkaXRvcihlZGl0b3JJZCwgZWRpdG9yT3B0aW9ucywgc2VsZikucmVuZGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ21jZVJlbW92ZUVkaXRvcic6IHtcbiAgICAgICAgICAgIGNvbnN0IGVkaXRvciA9IHNlbGYuZ2V0KGVkaXRvcklkKTtcbiAgICAgICAgICAgIGlmIChlZGl0b3IpIHtcbiAgICAgICAgICAgICAgZWRpdG9yLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdtY2VUb2dnbGVFZGl0b3InOiB7XG4gICAgICAgICAgICBjb25zdCBlZGl0b3IgPSBzZWxmLmdldChlZGl0b3JJZCk7XG4gICAgICAgICAgICBpZiAoIWVkaXRvcikge1xuICAgICAgICAgICAgICBzZWxmLmV4ZWNDb21tYW5kKCdtY2VBZGRFZGl0b3InLCBmYWxzZSwgdmFsdWUpO1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlZGl0b3IuaXNIaWRkZW4oKSkge1xuICAgICAgICAgICAgICBlZGl0b3Iuc2hvdygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZWRpdG9yLmhpZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5hY3RpdmVFZGl0b3IpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi5hY3RpdmVFZGl0b3IuZXhlY0NvbW1hbmQoY21kLCB1aSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sXG4gICAgICB0cmlnZ2VyU2F2ZTogKCkgPT4ge1xuICAgICAgICBlYWNoKGVkaXRvcnMsIGVkaXRvciA9PiB7XG4gICAgICAgICAgZWRpdG9yLnNhdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgYWRkSTE4bjogKGNvZGUsIGl0ZW1zKSA9PiB7XG4gICAgICAgIEkxOG4uYWRkKGNvZGUsIGl0ZW1zKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2xhdGU6IHRleHQgPT4ge1xuICAgICAgICByZXR1cm4gSTE4bi50cmFuc2xhdGUodGV4dCk7XG4gICAgICB9LFxuICAgICAgc2V0QWN0aXZlKGVkaXRvcikge1xuICAgICAgICBjb25zdCBhY3RpdmVFZGl0b3IgPSB0aGlzLmFjdGl2ZUVkaXRvcjtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlRWRpdG9yICE9PSBlZGl0b3IpIHtcbiAgICAgICAgICBpZiAoYWN0aXZlRWRpdG9yKSB7XG4gICAgICAgICAgICBhY3RpdmVFZGl0b3IuZGlzcGF0Y2goJ2RlYWN0aXZhdGUnLCB7IHJlbGF0ZWRUYXJnZXQ6IGVkaXRvciB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWRpdG9yLmRpc3BhdGNoKCdhY3RpdmF0ZScsIHsgcmVsYXRlZFRhcmdldDogYWN0aXZlRWRpdG9yIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aXZlRWRpdG9yID0gZWRpdG9yO1xuICAgICAgfSxcbiAgICAgIF9zZXRCYXNlVXJsKGJhc2VVcmwpIHtcbiAgICAgICAgdGhpcy5iYXNlVVJMID0gbmV3IFVSSSh0aGlzLmRvY3VtZW50QmFzZVVSTCkudG9BYnNvbHV0ZShiYXNlVXJsLnJlcGxhY2UoL1xcLyskLywgJycpKTtcbiAgICAgICAgdGhpcy5iYXNlVVJJID0gbmV3IFVSSSh0aGlzLmJhc2VVUkwpO1xuICAgICAgfVxuICAgIH07XG4gICAgRWRpdG9yTWFuYWdlci5zZXR1cCgpO1xuXG4gICAgY29uc3Qgc2V0dXAgPSAoKSA9PiB7XG4gICAgICBjb25zdCBkYXRhVmFsdWUgPSB2YWx1ZSQyKCk7XG4gICAgICBjb25zdCBGYWtlQ2xpcGJvYXJkSXRlbSA9IGl0ZW1zID0+ICh7XG4gICAgICAgIGl0ZW1zLFxuICAgICAgICB0eXBlczoga2V5cyhpdGVtcyksXG4gICAgICAgIGdldFR5cGU6IHR5cGUgPT4gZ2V0JGEoaXRlbXMsIHR5cGUpLmdldE9yVW5kZWZpbmVkKClcbiAgICAgIH0pO1xuICAgICAgY29uc3Qgd3JpdGUgPSBkYXRhID0+IHtcbiAgICAgICAgZGF0YVZhbHVlLnNldChkYXRhKTtcbiAgICAgIH07XG4gICAgICBjb25zdCByZWFkID0gKCkgPT4gZGF0YVZhbHVlLmdldCgpLmdldE9yVW5kZWZpbmVkKCk7XG4gICAgICBjb25zdCBjbGVhciA9IGRhdGFWYWx1ZS5jbGVhcjtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIEZha2VDbGlwYm9hcmRJdGVtLFxuICAgICAgICB3cml0ZSxcbiAgICAgICAgcmVhZCxcbiAgICAgICAgY2xlYXJcbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBGYWtlQ2xpcGJvYXJkID0gc2V0dXAoKTtcblxuICAgIGNvbnN0IG1pbiA9IE1hdGgubWluLCBtYXggPSBNYXRoLm1heCwgcm91bmQgPSBNYXRoLnJvdW5kO1xuICAgIGNvbnN0IHJlbGF0aXZlUG9zaXRpb24gPSAocmVjdCwgdGFyZ2V0UmVjdCwgcmVsKSA9PiB7XG4gICAgICBsZXQgeCA9IHRhcmdldFJlY3QueDtcbiAgICAgIGxldCB5ID0gdGFyZ2V0UmVjdC55O1xuICAgICAgY29uc3QgdyA9IHJlY3QudztcbiAgICAgIGNvbnN0IGggPSByZWN0Lmg7XG4gICAgICBjb25zdCB0YXJnZXRXID0gdGFyZ2V0UmVjdC53O1xuICAgICAgY29uc3QgdGFyZ2V0SCA9IHRhcmdldFJlY3QuaDtcbiAgICAgIGNvbnN0IHJlbENoYXJzID0gKHJlbCB8fCAnJykuc3BsaXQoJycpO1xuICAgICAgaWYgKHJlbENoYXJzWzBdID09PSAnYicpIHtcbiAgICAgICAgeSArPSB0YXJnZXRIO1xuICAgICAgfVxuICAgICAgaWYgKHJlbENoYXJzWzFdID09PSAncicpIHtcbiAgICAgICAgeCArPSB0YXJnZXRXO1xuICAgICAgfVxuICAgICAgaWYgKHJlbENoYXJzWzBdID09PSAnYycpIHtcbiAgICAgICAgeSArPSByb3VuZCh0YXJnZXRIIC8gMik7XG4gICAgICB9XG4gICAgICBpZiAocmVsQ2hhcnNbMV0gPT09ICdjJykge1xuICAgICAgICB4ICs9IHJvdW5kKHRhcmdldFcgLyAyKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWxDaGFyc1szXSA9PT0gJ2InKSB7XG4gICAgICAgIHkgLT0gaDtcbiAgICAgIH1cbiAgICAgIGlmIChyZWxDaGFyc1s0XSA9PT0gJ3InKSB7XG4gICAgICAgIHggLT0gdztcbiAgICAgIH1cbiAgICAgIGlmIChyZWxDaGFyc1szXSA9PT0gJ2MnKSB7XG4gICAgICAgIHkgLT0gcm91bmQoaCAvIDIpO1xuICAgICAgfVxuICAgICAgaWYgKHJlbENoYXJzWzRdID09PSAnYycpIHtcbiAgICAgICAgeCAtPSByb3VuZCh3IC8gMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3JlYXRlJDIoeCwgeSwgdywgaCk7XG4gICAgfTtcbiAgICBjb25zdCBmaW5kQmVzdFJlbGF0aXZlUG9zaXRpb24gPSAocmVjdCwgdGFyZ2V0UmVjdCwgY29uc3RyYWluUmVjdCwgcmVscykgPT4ge1xuICAgICAgbGV0IHBvcywgaTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCByZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHBvcyA9IHJlbGF0aXZlUG9zaXRpb24ocmVjdCwgdGFyZ2V0UmVjdCwgcmVsc1tpXSk7XG4gICAgICAgIGlmIChwb3MueCA+PSBjb25zdHJhaW5SZWN0LnggJiYgcG9zLnggKyBwb3MudyA8PSBjb25zdHJhaW5SZWN0LncgKyBjb25zdHJhaW5SZWN0LnggJiYgcG9zLnkgPj0gY29uc3RyYWluUmVjdC55ICYmIHBvcy55ICsgcG9zLmggPD0gY29uc3RyYWluUmVjdC5oICsgY29uc3RyYWluUmVjdC55KSB7XG4gICAgICAgICAgcmV0dXJuIHJlbHNbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgY29uc3QgaW5mbGF0ZSA9IChyZWN0LCB3LCBoKSA9PiB7XG4gICAgICByZXR1cm4gY3JlYXRlJDIocmVjdC54IC0gdywgcmVjdC55IC0gaCwgcmVjdC53ICsgdyAqIDIsIHJlY3QuaCArIGggKiAyKTtcbiAgICB9O1xuICAgIGNvbnN0IGludGVyc2VjdCA9IChyZWN0LCBjcm9wUmVjdCkgPT4ge1xuICAgICAgY29uc3QgeDEgPSBtYXgocmVjdC54LCBjcm9wUmVjdC54KTtcbiAgICAgIGNvbnN0IHkxID0gbWF4KHJlY3QueSwgY3JvcFJlY3QueSk7XG4gICAgICBjb25zdCB4MiA9IG1pbihyZWN0LnggKyByZWN0LncsIGNyb3BSZWN0LnggKyBjcm9wUmVjdC53KTtcbiAgICAgIGNvbnN0IHkyID0gbWluKHJlY3QueSArIHJlY3QuaCwgY3JvcFJlY3QueSArIGNyb3BSZWN0LmgpO1xuICAgICAgaWYgKHgyIC0geDEgPCAwIHx8IHkyIC0geTEgPCAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNyZWF0ZSQyKHgxLCB5MSwgeDIgLSB4MSwgeTIgLSB5MSk7XG4gICAgfTtcbiAgICBjb25zdCBjbGFtcCA9IChyZWN0LCBjbGFtcFJlY3QsIGZpeGVkU2l6ZSkgPT4ge1xuICAgICAgbGV0IHgxID0gcmVjdC54O1xuICAgICAgbGV0IHkxID0gcmVjdC55O1xuICAgICAgbGV0IHgyID0gcmVjdC54ICsgcmVjdC53O1xuICAgICAgbGV0IHkyID0gcmVjdC55ICsgcmVjdC5oO1xuICAgICAgY29uc3QgY3gyID0gY2xhbXBSZWN0LnggKyBjbGFtcFJlY3QudztcbiAgICAgIGNvbnN0IGN5MiA9IGNsYW1wUmVjdC55ICsgY2xhbXBSZWN0Lmg7XG4gICAgICBjb25zdCB1bmRlcmZsb3dYMSA9IG1heCgwLCBjbGFtcFJlY3QueCAtIHgxKTtcbiAgICAgIGNvbnN0IHVuZGVyZmxvd1kxID0gbWF4KDAsIGNsYW1wUmVjdC55IC0geTEpO1xuICAgICAgY29uc3Qgb3ZlcmZsb3dYMiA9IG1heCgwLCB4MiAtIGN4Mik7XG4gICAgICBjb25zdCBvdmVyZmxvd1kyID0gbWF4KDAsIHkyIC0gY3kyKTtcbiAgICAgIHgxICs9IHVuZGVyZmxvd1gxO1xuICAgICAgeTEgKz0gdW5kZXJmbG93WTE7XG4gICAgICBpZiAoZml4ZWRTaXplKSB7XG4gICAgICAgIHgyICs9IHVuZGVyZmxvd1gxO1xuICAgICAgICB5MiArPSB1bmRlcmZsb3dZMTtcbiAgICAgICAgeDEgLT0gb3ZlcmZsb3dYMjtcbiAgICAgICAgeTEgLT0gb3ZlcmZsb3dZMjtcbiAgICAgIH1cbiAgICAgIHgyIC09IG92ZXJmbG93WDI7XG4gICAgICB5MiAtPSBvdmVyZmxvd1kyO1xuICAgICAgcmV0dXJuIGNyZWF0ZSQyKHgxLCB5MSwgeDIgLSB4MSwgeTIgLSB5MSk7XG4gICAgfTtcbiAgICBjb25zdCBjcmVhdGUkMiA9ICh4LCB5LCB3LCBoKSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICB3LFxuICAgICAgICBoXG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgZnJvbUNsaWVudFJlY3QgPSBjbGllbnRSZWN0ID0+IHtcbiAgICAgIHJldHVybiBjcmVhdGUkMihjbGllbnRSZWN0LmxlZnQsIGNsaWVudFJlY3QudG9wLCBjbGllbnRSZWN0LndpZHRoLCBjbGllbnRSZWN0LmhlaWdodCk7XG4gICAgfTtcbiAgICBjb25zdCBSZWN0ID0ge1xuICAgICAgaW5mbGF0ZSxcbiAgICAgIHJlbGF0aXZlUG9zaXRpb24sXG4gICAgICBmaW5kQmVzdFJlbGF0aXZlUG9zaXRpb24sXG4gICAgICBpbnRlcnNlY3QsXG4gICAgICBjbGFtcCxcbiAgICAgIGNyZWF0ZTogY3JlYXRlJDIsXG4gICAgICBmcm9tQ2xpZW50UmVjdFxuICAgIH07XG5cbiAgICBjb25zdCBhd2FpdGVyID0gKHJlc29sdmVDYiwgcmVqZWN0Q2IsIHRpbWVvdXQgPSAxMDAwKSA9PiB7XG4gICAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgICAgbGV0IHRpbWVyID0gbnVsbDtcbiAgICAgIGNvbnN0IGNvbXBsZXRlID0gY29tcGxldGVyID0+ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGlmICghZG9uZSkge1xuICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgIGlmICh0aW1lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29tcGxldGVyLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgcmVzb2x2ZSA9IGNvbXBsZXRlKHJlc29sdmVDYik7XG4gICAgICBjb25zdCByZWplY3QgPSBjb21wbGV0ZShyZWplY3RDYik7XG4gICAgICBjb25zdCBzdGFydCA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGlmICghZG9uZSAmJiB0aW1lciA9PT0gbnVsbCkge1xuICAgICAgICAgIHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiByZWplY3QuYXBwbHkobnVsbCwgYXJncyksIHRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQsXG4gICAgICAgIHJlc29sdmUsXG4gICAgICAgIHJlamVjdFxuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IGNyZWF0ZSQxID0gKCkgPT4ge1xuICAgICAgY29uc3QgdGFza3MgPSB7fTtcbiAgICAgIGNvbnN0IHJlc3VsdEZucyA9IHt9O1xuICAgICAgY29uc3QgbG9hZCA9IChpZCwgdXJsKSA9PiB7XG4gICAgICAgIGNvbnN0IGxvYWRFcnJNc2cgPSBgU2NyaXB0IGF0IFVSTCBcIiR7IHVybCB9XCIgZmFpbGVkIHRvIGxvYWRgO1xuICAgICAgICBjb25zdCBydW5FcnJNc2cgPSBgU2NyaXB0IGF0IFVSTCBcIiR7IHVybCB9XCIgZGlkIG5vdCBjYWxsIFxcYHRpbnltY2UuUmVzb3VyY2UuYWRkKCckeyBpZCB9JywgZGF0YSlcXGAgd2l0aGluIDEgc2Vjb25kYDtcbiAgICAgICAgaWYgKHRhc2tzW2lkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIHRhc2tzW2lkXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCB0YXNrID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgd2FpdGVyID0gYXdhaXRlcihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgcmVzdWx0Rm5zW2lkXSA9IHdhaXRlci5yZXNvbHZlO1xuICAgICAgICAgICAgU2NyaXB0TG9hZGVyLlNjcmlwdExvYWRlci5sb2FkU2NyaXB0KHVybCkudGhlbigoKSA9PiB3YWl0ZXIuc3RhcnQocnVuRXJyTXNnKSwgKCkgPT4gd2FpdGVyLnJlamVjdChsb2FkRXJyTXNnKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGFza3NbaWRdID0gdGFzaztcbiAgICAgICAgICByZXR1cm4gdGFzaztcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGFkZCA9IChpZCwgZGF0YSkgPT4ge1xuICAgICAgICBpZiAocmVzdWx0Rm5zW2lkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmVzdWx0Rm5zW2lkXShkYXRhKTtcbiAgICAgICAgICBkZWxldGUgcmVzdWx0Rm5zW2lkXTtcbiAgICAgICAgfVxuICAgICAgICB0YXNrc1tpZF0gPSBQcm9taXNlLnJlc29sdmUoZGF0YSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgdW5sb2FkID0gaWQgPT4ge1xuICAgICAgICBkZWxldGUgdGFza3NbaWRdO1xuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxvYWQsXG4gICAgICAgIGFkZCxcbiAgICAgICAgdW5sb2FkXG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgUmVzb3VyY2UgPSBjcmVhdGUkMSgpO1xuXG4gICAgY29uc3QgY3JlYXRlID0gKCkgPT4gKCgpID0+IHtcbiAgICAgIGxldCBkYXRhID0ge307XG4gICAgICBsZXQga2V5cyA9IFtdO1xuICAgICAgY29uc3Qgc3RvcmFnZSA9IHtcbiAgICAgICAgZ2V0SXRlbToga2V5ID0+IHtcbiAgICAgICAgICBjb25zdCBpdGVtID0gZGF0YVtrZXldO1xuICAgICAgICAgIHJldHVybiBpdGVtID8gaXRlbSA6IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIHNldEl0ZW06IChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgZGF0YVtrZXldID0gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAga2V5OiBpbmRleCA9PiB7XG4gICAgICAgICAgcmV0dXJuIGtleXNbaW5kZXhdO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmVJdGVtOiBrZXkgPT4ge1xuICAgICAgICAgIGtleXMgPSBrZXlzLmZpbHRlcihrID0+IGsgPT09IGtleSk7XG4gICAgICAgICAgZGVsZXRlIGRhdGFba2V5XTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xlYXI6ICgpID0+IHtcbiAgICAgICAgICBrZXlzID0gW107XG4gICAgICAgICAgZGF0YSA9IHt9O1xuICAgICAgICB9LFxuICAgICAgICBsZW5ndGg6IDBcbiAgICAgIH07XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3RvcmFnZSwgJ2xlbmd0aCcsIHtcbiAgICAgICAgZ2V0OiAoKSA9PiBrZXlzLmxlbmd0aCxcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHN0b3JhZ2U7XG4gICAgfSkoKTtcblxuICAgIGxldCBsb2NhbFN0b3JhZ2U7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHRlc3QgPSAnX19zdG9yYWdlX3Rlc3RfXyc7XG4gICAgICBsb2NhbFN0b3JhZ2UgPSB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0odGVzdCwgdGVzdCk7XG4gICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSh0ZXN0KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2NhbFN0b3JhZ2UgPSBjcmVhdGUoKTtcbiAgICB9XG4gICAgdmFyIExvY2FsU3RvcmFnZSA9IGxvY2FsU3RvcmFnZTtcblxuICAgIGNvbnN0IHB1YmxpY0FwaSA9IHtcbiAgICAgIGdlb206IHsgUmVjdCB9LFxuICAgICAgdXRpbDoge1xuICAgICAgICBEZWxheSxcbiAgICAgICAgVG9vbHMsXG4gICAgICAgIFZLLFxuICAgICAgICBVUkksXG4gICAgICAgIEV2ZW50RGlzcGF0Y2hlcixcbiAgICAgICAgT2JzZXJ2YWJsZSxcbiAgICAgICAgSTE4bixcbiAgICAgICAgTG9jYWxTdG9yYWdlLFxuICAgICAgICBJbWFnZVVwbG9hZGVyXG4gICAgICB9LFxuICAgICAgZG9tOiB7XG4gICAgICAgIEV2ZW50VXRpbHMsXG4gICAgICAgIFRyZWVXYWxrZXI6IERvbVRyZWVXYWxrZXIsXG4gICAgICAgIFRleHRTZWVrZXIsXG4gICAgICAgIERPTVV0aWxzLFxuICAgICAgICBTY3JpcHRMb2FkZXIsXG4gICAgICAgIFJhbmdlVXRpbHMsXG4gICAgICAgIFNlcmlhbGl6ZXI6IERvbVNlcmlhbGl6ZXIsXG4gICAgICAgIFN0eWxlU2hlZXRMb2FkZXIsXG4gICAgICAgIENvbnRyb2xTZWxlY3Rpb24sXG4gICAgICAgIEJvb2ttYXJrTWFuYWdlcixcbiAgICAgICAgU2VsZWN0aW9uOiBFZGl0b3JTZWxlY3Rpb24sXG4gICAgICAgIEV2ZW50OiBFdmVudFV0aWxzLkV2ZW50XG4gICAgICB9LFxuICAgICAgaHRtbDoge1xuICAgICAgICBTdHlsZXMsXG4gICAgICAgIEVudGl0aWVzLFxuICAgICAgICBOb2RlOiBBc3ROb2RlLFxuICAgICAgICBTY2hlbWEsXG4gICAgICAgIERvbVBhcnNlcixcbiAgICAgICAgV3JpdGVyLFxuICAgICAgICBTZXJpYWxpemVyOiBIdG1sU2VyaWFsaXplclxuICAgICAgfSxcbiAgICAgIEVudixcbiAgICAgIEFkZE9uTWFuYWdlcixcbiAgICAgIEFubm90YXRvcixcbiAgICAgIEZvcm1hdHRlcixcbiAgICAgIFVuZG9NYW5hZ2VyLFxuICAgICAgRWRpdG9yQ29tbWFuZHMsXG4gICAgICBXaW5kb3dNYW5hZ2VyLFxuICAgICAgTm90aWZpY2F0aW9uTWFuYWdlcixcbiAgICAgIEVkaXRvck9ic2VydmFibGUsXG4gICAgICBTaG9ydGN1dHMsXG4gICAgICBFZGl0b3IsXG4gICAgICBGb2N1c01hbmFnZXIsXG4gICAgICBFZGl0b3JNYW5hZ2VyLFxuICAgICAgRE9NOiBET01VdGlscy5ET00sXG4gICAgICBTY3JpcHRMb2FkZXI6IFNjcmlwdExvYWRlci5TY3JpcHRMb2FkZXIsXG4gICAgICBQbHVnaW5NYW5hZ2VyLFxuICAgICAgVGhlbWVNYW5hZ2VyLFxuICAgICAgTW9kZWxNYW5hZ2VyLFxuICAgICAgSWNvbk1hbmFnZXIsXG4gICAgICBSZXNvdXJjZSxcbiAgICAgIEZha2VDbGlwYm9hcmQsXG4gICAgICB0cmltOiBUb29scy50cmltLFxuICAgICAgaXNBcnJheTogVG9vbHMuaXNBcnJheSxcbiAgICAgIGlzOiBUb29scy5pcyxcbiAgICAgIHRvQXJyYXk6IFRvb2xzLnRvQXJyYXksXG4gICAgICBtYWtlTWFwOiBUb29scy5tYWtlTWFwLFxuICAgICAgZWFjaDogVG9vbHMuZWFjaCxcbiAgICAgIG1hcDogVG9vbHMubWFwLFxuICAgICAgZ3JlcDogVG9vbHMuZ3JlcCxcbiAgICAgIGluQXJyYXk6IFRvb2xzLmluQXJyYXksXG4gICAgICBleHRlbmQ6IFRvb2xzLmV4dGVuZCxcbiAgICAgIHdhbGs6IFRvb2xzLndhbGssXG4gICAgICByZXNvbHZlOiBUb29scy5yZXNvbHZlLFxuICAgICAgZXhwbG9kZTogVG9vbHMuZXhwbG9kZSxcbiAgICAgIF9hZGRDYWNoZVN1ZmZpeDogVG9vbHMuX2FkZENhY2hlU3VmZml4XG4gICAgfTtcbiAgICBjb25zdCB0aW55bWNlID0gVG9vbHMuZXh0ZW5kKEVkaXRvck1hbmFnZXIsIHB1YmxpY0FwaSk7XG5cbiAgICBjb25zdCBleHBvcnRUb01vZHVsZUxvYWRlcnMgPSB0aW55bWNlID0+IHtcbiAgICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gdGlueW1jZTtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBleHBvcnRUb1dpbmRvd0dsb2JhbCA9IHRpbnltY2UgPT4ge1xuICAgICAgd2luZG93LnRpbnltY2UgPSB0aW55bWNlO1xuICAgICAgd2luZG93LnRpbnlNQ0UgPSB0aW55bWNlO1xuICAgIH07XG4gICAgZXhwb3J0VG9XaW5kb3dHbG9iYWwodGlueW1jZSk7XG4gICAgZXhwb3J0VG9Nb2R1bGVMb2FkZXJzKHRpbnltY2UpO1xuXG59KSgpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tinymce/tinymce.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"/js/app": 0,
/******/ 			"css/app": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 			return __webpack_require__.O(result);
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunk"] = self["webpackChunk"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 	__webpack_require__.O(undefined, ["css/app"], () => (__webpack_require__("./resources/js/app.js")))
/******/ 	var __webpack_exports__ = __webpack_require__.O(undefined, ["css/app"], () => (__webpack_require__("./resources/sass/app.scss")))
/******/ 	__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 	
/******/ })()
;